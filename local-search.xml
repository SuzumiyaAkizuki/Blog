<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>北航机器学习期末考试例题汇总</title>
    <link href="/2024/12/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E4%BE%8B%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/12/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E4%BE%8B%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>本文汇总了网上可以找到的北航机器学习期末考试信息，并根据所提到的题型给出一些例题。助教说本研的课程期末考试题型基本一致，因此没有进行区分。</p><p>参考文献：</p><ol type="1"><li><a href="https://blog.csdn.net/qq_43343919/article/details/112399970">北航机器学习期末考试试题2020年春</a></li><li><a href="https://blog.csdn.net/weixin_45262065/article/details/112555104">北航机器学习2020-2021秋季学期期末试题回忆</a></li><li><a href="https://blog.csdn.net/sinat_38425013/article/details/103689617">北航机器学习期末考试试题2019年秋</a></li><li><a href="https://blog.csdn.net/qq_43787197/article/details/122240658">北航机器学习期末考试试题2021年秋</a></li><li><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/2023%E7%A7%8B%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA%E3%80%8B%20%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98%E5%9B%9E%E5%BF%86%E7%89%88.pdf">2023秋 机器学习导论 期末试题回忆版</a></li></ol><span id="more"></span><p>[toc]</p><h2 id="贝叶斯决策">贝叶斯决策</h2><p>【来源】参考文献3、4</p><p>【例题】细胞有正常(<span class="math inline">\(w_1\)</span>)，异常(<span class="math inline">\(w_2\)</span>)两类，其先验概率为<span class="math inline">\(P(w_1)=0.9,P(w_2)=0.1\)</span>。有一个待识别的细胞，观测值为<span class="math inline">\(x\)</span>，现在已知如果细胞是正常的，出现<span class="math inline">\(x\)</span>的概率为<span class="math inline">\(0.2\)</span>；如果细胞是异常的，出现<span class="math inline">\(x\)</span>的概率是<span class="math inline">\(0.4\)</span>。决策的损失表如下：</p><table><thead><tr class="header"><th style="text-align: center;">决策</th><th style="text-align: center;"><span class="math inline">\(w_1\)</span></th><th style="text-align: center;"><span class="math inline">\(w_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(w_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(w_2\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><ol type="1"><li>基于最小错误率原则对待识别细胞进行归类</li><li>基于最小风险原则对待识别细胞进行归类</li></ol><p>【解答】</p><ol type="1"><li><p>应用贝叶斯公式：</p><p>已知<span class="math inline">\(x\)</span>，细胞属于<span class="math inline">\(w_1\)</span>的概率为： <span class="math display">\[\begin{align}P(w_1\mid x)&amp;=\frac{P(x\mid w_1)P(w_1)}{P(x\mid w_1)P(w_1)+P(x\mid w_2)P(w_2)}\\&amp;=\frac{0.2\times 0.9}{0.2\times 0.9+0.4\times 0.1}\\&amp;=0.818\end{align}\]</span> 已知<span class="math inline">\(x\)</span>，细胞属于<span class="math inline">\(w_2\)</span>的概率为： <span class="math display">\[\begin{align}P(w_2\mid x)&amp;=\frac{P(x\mid w_2)P(w_2)}{P(x\mid w_1)P(w_1)+P(x\mid w_2)P(w_2)}\\&amp;=\frac{0.4\times 0.1}{0.2\times 0.9+0.4\times 0.1}\\&amp;=0.182\end{align}\]</span> 所以，应该决策为<span class="math inline">\(w_1\)</span>。</p></li><li><p>决策为<span class="math inline">\(w_1\)</span>的风险为： <span class="math display">\[R(w_1)=0\times P(w_1\mid x)+6\times P(w_2\mid x)=1.092\]</span> 决策为<span class="math inline">\(w_2\)</span>的风险为： <span class="math display">\[R(w_2)=1\times P(w_1\mid x)+0\times P(w_2\mid x)=0.818\]</span> 所以，应该决策为<span class="math inline">\(w_2\)</span>。</p></li></ol><h2 id="使用感知机准则求判别函数">使用感知机准则求判别函数</h2><p>【来源】参考文献4、5</p><p>【讲解】问题的格式是：现有样本集<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>属于<span class="math inline">\(w_1,w_2\)</span>两类，寻找向量<span class="math inline">\(a\)</span>，使得：<span class="math inline">\(\forall x\in w_1,a^Tx&gt;0\)</span>，且<span class="math inline">\(\forall x\in w_2,a^Tx&lt;0\)</span>。即使用一个仿射流形把样本分成两半，这时称样本是线性可分的。其具体操作步骤是：</p><ol type="1"><li><p>构造规范化增广样本向量。</p><p>这一步的关键是增广和规范化。因为一般线性流形的表达式是<span class="math inline">\(w^Tx+b\)</span>，但是我们要把这个<span class="math inline">\(b\)</span>包含在<span class="math inline">\(w\)</span>里面，就要把样本进行增广。增广的操作步骤是给样本的坐标前面补充<span class="math inline">\(1\)</span>个<span class="math inline">\(1\)</span>。</p><p>规范化的意思是，如果样本是正例（属于<span class="math inline">\(w_1\)</span>），就保持不变；否则，它的每个坐标都变成相反数。</p><p>规范化增广样本向量记作<span class="math inline">\(\{y_1\cdots y_n\}\)</span></p></li><li><p>在<span class="math inline">\({y}\)</span>集合上循环迭代：对于每个<span class="math inline">\(y_i\)</span>，计算<span class="math inline">\(a_k^Ty\)</span>，如果<span class="math inline">\(a_k^Ty\leq 0\)</span>，则<span class="math inline">\(a_{k+1}=a_k+y\)</span>；否则，<span class="math inline">\(a_{k+1}=a_k\)</span>。直到对于某个<span class="math inline">\(a\)</span>，所有的<span class="math inline">\(y\)</span>都满足<span class="math inline">\(a^Ty&gt;0\)</span>，那么这就是最终结果。</p><p>这实际上是梯度下降法的过程，推导略。</p></li></ol><p>【例子】现有数据集：</p><ol type="1"><li>类别1：<span class="math inline">\(x_1^T=(-2,2)\)</span>，<span class="math inline">\(x_2^T=(-2,-2)\)</span></li><li>类别2：<span class="math inline">\(x_3^T=(2,1)\)</span>，<span class="math inline">\(x_4^T=(2,-1)\)</span></li></ol><p>初始化权：<span class="math inline">\(a_0^T=(0,2,1)\)</span>，利用感知机准则求判别函数。</p><p>【解答】</p><ol type="1"><li><p>构造规范化增广样本向量： <span class="math display">\[y_1^T=(1,-2,2),y_2^T=(1,-2,-2)\]</span></p><p><span class="math display">\[y_3^T=(-1,-2,-1),y_4^T=(-1,-2,1)\]</span></p></li><li><p>迭代</p><ol type="1"><li><span class="math inline">\(a_1^Ty_1=(0,2,1)\cdot (1,-2,2)^T=-2&lt; 0\)</span>，<span class="math inline">\(a_2=a_1+y_1=(1,0,3)\)</span></li><li><span class="math inline">\(a_2^Ty_2=(1,0,3)\cdot (1,-2,-2)^T=-1&lt; 0\)</span>，<span class="math inline">\(a_3=a_2+y_2=(2,-2,1)\)</span></li><li><span class="math inline">\(a_3^Ty_3=(2,-2,1)\cdot (-1,-2,-1)^T=1&gt; 0\)</span>，<span class="math inline">\(a_4=a_3\)</span></li><li><span class="math inline">\(a_4^Ty_4=(2,-2,1)\cdot (-1,-2,1)^T=3&gt; 0\)</span>，<span class="math inline">\(a_5=a_4\)</span></li><li><span class="math inline">\(a_5^Ty_1=(2,-2,1)\cdot (1,-2,2)^T=8&gt; 0\)</span>，<span class="math inline">\(a_6=a_5\)</span></li><li><span class="math inline">\(a_6^Ty_2=(2,-2,1)\cdot (-1,-2,-2)^T=4&gt; 0\)</span>，<span class="math inline">\(a_6=a_5\)</span></li></ol><p>至此，对于<span class="math inline">\(a^T=(2,-2,1)\)</span>，所有的<span class="math inline">\(y\)</span>都满足<span class="math inline">\(a^Ty&gt;0\)</span>，那么这就是最终结果。</p></li></ol><h2 id="主成分分析pca数据降维方法">主成分分析（PCA）数据降维方法</h2><p>【来源】参考文献1、2、3、4、5</p><p>【讲解】PCA的考法有两种，第一种是基于最大方差准则进行推导，第二种是给你一些二维向量，让你降成一维。</p><p>【例题1】基于最大方差准则推导PCA的方法</p><p>【解答1】问题是把<span class="math inline">\(D\)</span>维数据集<span class="math inline">\(\{\boldsymbol{x}_n\}\)</span>降为<span class="math inline">\(1\)</span>维。定义投影方向为<span class="math inline">\(D\)</span>维向量<span class="math inline">\(\boldsymbol{u}\)</span>，且满足<span class="math inline">\(\boldsymbol{u}^T\boldsymbol{u}=1\)</span>。</p><p>则样本均值为：<span class="math inline">\(\boldsymbol{u}^T\bar {\boldsymbol{x}}\)</span>，样本方差为 <span class="math display">\[\frac 1N \sum_{i=1}^N\boldsymbol{u}^T\boldsymbol{x}_i-\boldsymbol{u}^T\bar{\boldsymbol{x}}=\boldsymbol{u}^TS\boldsymbol{u}\]</span> 其中<span class="math inline">\(S\)</span>是协方差矩阵。那么优化问题为： <span class="math display">\[\begin{align}\text{maximize} \ \ &amp;\boldsymbol{u}^TS\boldsymbol{u}\\s.t. &amp; \boldsymbol{u}^T\boldsymbol{u}=1\end{align}\]</span> 利用拉格朗日乘数法，写出其拉格朗日函数： <span class="math display">\[L(\boldsymbol{u},\lambda)=\boldsymbol{u}^TS\boldsymbol{u}+\lambda(1-\boldsymbol{u}^T\boldsymbol{u})\]</span> 对<span class="math inline">\(\boldsymbol{u}\)</span>求导，并置零，有： <span class="math display">\[S\boldsymbol{u}=\lambda \boldsymbol{u}\]</span> 这意味着，<span class="math inline">\(\lambda\)</span>是<span class="math inline">\(S\)</span>的特征值，<span class="math inline">\(\boldsymbol{u}\)</span>是<span class="math inline">\(S\)</span>的特征向量。<span class="math inline">\(\boldsymbol{u}_1\)</span>是<span class="math inline">\(S\)</span>最大特征值对应的特征向量时，方差取到极大值，称<span class="math inline">\(\boldsymbol{u}_1\)</span>为第一主成分。于是，我们得到利用PCA降维的操作步骤：</p><ol type="1"><li><p>计算所有样本点的均值<span class="math inline">\(\boldsymbol{\bar x}\)</span></p></li><li><p>对所有样本点进行零均值化：<span class="math inline">\(\boldsymbol{x_i}=\boldsymbol{x_i-\bar x}\)</span></p></li><li><p>计算协方差阵： <span class="math display">\[S=\frac 1N\sum_{i=1}^N \boldsymbol{x}_i\boldsymbol{x}_i^T\]</span></p></li><li><p>计算协方差阵的最大的特征值和与其对应的特征向量<span class="math inline">\(\boldsymbol{u}\)</span></p></li><li><p>进行投影：<span class="math inline">\(y=\boldsymbol{u}^T\boldsymbol{x}\)</span></p></li></ol><p>【例题2】对以下五个二维向量，利用PCA降为一维 <span class="math display">\[x_{(1)} = \begin{bmatrix} 2 \\ 5 \end{bmatrix}, \quadx_{(2)} = \begin{bmatrix} 3 \\ 3 \end{bmatrix}, \quadx_{(3)} = \begin{bmatrix} 5 \\ 4 \end{bmatrix}, \quadx_{(4)} = \begin{bmatrix} 4 \\ 6 \end{bmatrix}, \quadx_{(5)} = \begin{bmatrix} 6 \\ 2 \end{bmatrix}\]</span> 【解答2】</p><ol type="1"><li><p>计算样本均值： <span class="math display">\[\bar {\boldsymbol{x}}=\begin{bmatrix} 4 \\ 4 \end{bmatrix}\]</span></p></li><li><p>零均值化： <span class="math display">\[x_{(1)} = \begin{bmatrix} -2 \\ 1 \end{bmatrix}, \quadx_{(2)} = \begin{bmatrix} -1 \\ -1 \end{bmatrix}, \quadx_{(3)} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}, \quadx_{(4)} = \begin{bmatrix} 0 \\ 2 \end{bmatrix}, \quadx_{(5)} = \begin{bmatrix} 2 \\ -2 \end{bmatrix}\]</span></p></li><li><p>计算协方差矩阵： <span class="math display">\[S=\begin{bmatrix}     2  &amp;  -1\\    -1   &amp; 2\\\end{bmatrix}\]</span></p></li><li><p>计算特征值和特征向量：</p><p>最大的特征值为<span class="math inline">\(\lambda=3\)</span>，对应的特征向量为： <span class="math display">\[\boldsymbol{u}=\begin{bmatrix} -\dfrac{1}{\sqrt{2}} \\ \dfrac{1}{\sqrt{2}} \end{bmatrix}\]</span></p></li><li><p>进行投影：</p><p><span class="math inline">\(y=\boldsymbol{u}^T\boldsymbol{x}\)</span></p></li></ol><p>【例题3】简述PCA和Fisher准则的区别</p><p>【解答3】（以下文字是AI生成的）</p><p>PCA（主成分分析）和Fisher准则（Fisher线性判别分析）都是降维技术，但它们的目标和方法有所不同：</p><ol type="1"><li><strong>目标不同</strong>：<ul><li><strong>PCA</strong>：主要目的是数据压缩和特征提取，通过正交变换将数据转换到新的坐标系，使得数据的任何投影的第一大方差在第一个坐标（称为第一主成分）上，第二大方差在第二个坐标上，依此类推。PCA不涉及监督学习，即不考虑数据的标签信息。</li><li><strong>Fisher准则</strong>：是一种监督学习的降维技术，目的是寻找最佳的投影方向，使得不同类别的数据在该方向上的距离尽可能远，而同类数据尽可能近。它利用了数据的类别标签信息。</li></ul></li><li><strong>方法不同</strong>：<ul><li><strong>PCA</strong>：通过协方差矩阵的特征值和特征向量来确定主成分，选择的是数据方差最大的方向。</li><li><strong>Fisher准则</strong>：通过最大化类间散度与类内散度的比值来确定最佳投影方向，选择的是区分不同类别最有效的方向。</li></ul></li><li><strong>应用场景不同</strong>：<ul><li><strong>PCA</strong>：适用于无监督学习场景，比如数据压缩、去噪等。</li><li><strong>Fisher准则</strong>：适用于监督学习场景，尤其是分类问题中的特征提取和降维。</li></ul></li><li><strong>对数据的要求不同</strong>：<ul><li><strong>PCA</strong>：对数据的分布没有特别的要求，可以处理各种类型的数据。</li><li><strong>Fisher准则</strong>：要求数据是分类的，需要知道每个数据点的类别标签。</li></ul></li></ol><p>总结来说，PCA是一种无监督的降维方法，关注于数据的方差；而Fisher准则是一种监督的降维方法，关注于类别的区分度。</p><h2 id="支持向量机">支持向量机</h2><p>【来源】参考文献1、2、3、4、5</p><p>【讲解】支持向量机的考法一般是让你简述一下原理，然后问一下软间隔和核函数。</p><p>【例题】svm的基本思想，模型表达式，软间隔和硬间隔的物理含义，如何用来解决非线性问题</p><p>【解答】对于分类问题：在空间中找一个超平面，最大化地分开不同数据点。对于样本<span class="math inline">\(\{\boldsymbol{x}_i,t_i\}\)</span>，其中<span class="math inline">\(\boldsymbol{x}_i\)</span>是空间中的点，<span class="math inline">\(t_i\in \{-1,1\}\)</span>是标签。找一个分类器<span class="math inline">\(y=\boldsymbol{w^Tx+b}\)</span>，使得：</p><p><span class="math display">\[t_i=\begin{cases}1,&amp;y(\boldsymbol{x}_i)&gt;0\\-1&amp;y(\boldsymbol{x}_i)&lt;0\end{cases}\]</span></p><p>SVM的思想是，寻找一个超平面，使其两端的空白区最大，即：</p><p><span class="math display">\[\begin{align}\text{maximize}_{w,b}\ \ &amp;\frac{1}{\|w\|}|\boldsymbol{w^Tx_i+b_i}|\\s.t.\ \ &amp; t_i(\boldsymbol{w_i^Tx_i+b_i})\geq 1\end{align}\]</span></p><p>问题等价为：</p><p><span class="math display">\[\begin{align}\text{minimize}_{w,b}\ \ &amp; \frac {1}{2} \boldsymbol{w^Tw}\\s.t.\ \ &amp; t_i(\boldsymbol{w_i^Tx_i+b_i})\geq 1\end{align}\]</span></p><p>这就是SVM的基本型。利用拉格朗日乘数法的对偶问题，可以写出其对偶型</p><p><span class="math display">\[\begin{align}\text{minimize}_\alpha\ \ &amp;\sum_{i=1}^N \sum_{j=1}^N \alpha_i\alpha_j t_i t_j \boldsymbol{x_i^Tx_j}-\sum_{i=1}^N \alpha_i\\s.t. \ \ &amp;\alpha&gt;0\\&amp; \sum_{i=1}^N \alpha_i t_i=0\end{align}\]</span></p><p>核技巧是应对非线性可分问题的一种方法。在<span class="math inline">\(\mathbb R^d\)</span>中，如果<span class="math inline">\(\{\boldsymbol{x}_i,t_i\}\)</span>不是线性可分的，则必定存在一个映射<span class="math inline">\(\phi : \mathbb R^d\to \mathbb R^{d&#39;}\)</span>，使得<span class="math inline">\(\{\phi(\boldsymbol{x}_i),t_i\}\)</span>在<span class="math inline">\(\mathbb R^{d&#39;}\)</span>中是线性可分的，其中一般有<span class="math inline">\(d&#39;\geq d\)</span>。此时，SVM的对偶问题变为：</p><p><span class="math display">\[\begin{align}\text{minimize}_\alpha\ \ &amp;\sum_{i=1}^N \sum_{j=1}^N \alpha_i\alpha_j t_i t_j \phi^T(\boldsymbol{x_i})\phi(\boldsymbol{x_j})-\sum_{i=1}^N \alpha_i\\s.t. \ \ &amp;\alpha&gt;0\\&amp; \sum_{i=1}^N \alpha_i t_i=0\end{align}\]</span></p><p>所谓的核技巧，就是寻找一个函数<span class="math inline">\(k(\boldsymbol{x_i,x_j})\)</span>，使得</p><p><span class="math display">\[k(\boldsymbol{x_i,x_j})=\phi^T(\boldsymbol{x_i})\phi(\boldsymbol{x_j})\]</span></p><p>且计算<span class="math inline">\(k\)</span>的复杂度是<span class="math inline">\(d\)</span>，这样就能够加速计算。常用的核有：</p><ol type="1"><li>线性核：<span class="math inline">\(k=x_i^Tx_j\)</span>，<span class="math inline">\(d\to d\)</span></li><li>多项式核：<span class="math inline">\(k=(\gamma x_i^Tx_j+c)^k\)</span>，<span class="math inline">\(d\to C_{k}^{d+k}\)</span></li><li>高斯核：<span class="math inline">\(k=\exp(-\gamma \|x_i-x_j\|^2)\)</span>，<span class="math inline">\(d\to \infty\)</span></li></ol><p>还有一种线性不可分是数据噪声造成的，这时可以用软间隔法。对于每一个样本引入一个松弛变量<span class="math inline">\(\epsilon\)</span>，原始问题变成：</p><p><span class="math display">\[\begin{align}\text{minimize}_{w,b}\ \ &amp; \frac {1}{2} \boldsymbol{w^Tw}\\s.t.\ \ &amp; t_i(\boldsymbol{w_i^Tx_i+b_i})\geq 1-\epsilon_i\end{align}\]</span></p><p>对偶问题变成：</p><p><span class="math display">\[\begin{align}\text{minimize}_\alpha\ \ &amp;\sum_{i=1}^N \sum_{j=1}^N \alpha_i\alpha_j t_i t_j \phi^T(\boldsymbol{x_i})\phi(\boldsymbol{x_j})-\sum_{i=1}^N \alpha_i\\s.t. \ \ &amp;\alpha\in (0,C)\\&amp; \sum_{i=1}^N \alpha_i t_i=0\end{align}\]</span></p><h2 id="k-means算法em算法">K-Means算法、EM算法</h2><p>【来源】参考文献1、2、3、4、5</p><p>【讲解】一般都是考概念题，问你K均值算法、高斯混合模型、EM算法分别是什么，有什么改进空间等。</p><h3 id="k均值算法">K均值算法</h3><p>定义：给定 D 维空间上的数据集 <span class="math inline">\(X=\left\{\mathbf{x}_1, \ldots, \mathbf{x}_N\right\}\)</span>, 这些数据对应类别未知。K均值算法将数据集划分成 <span class="math inline">\(K\)</span> 类, 各类的聚类中心记为 <span class="math inline">\(\mu_1, \ldots, \mu_k\)</span>, 并将每一个样本 <span class="math inline">\(\mathrm{x}_n\)</span> 划归到离该样本最近的聚类中心。</p><p>K均值算法的一般流程</p><ol type="1"><li><p>初始化选择K个初始聚类中心</p></li><li><p>将每个数据点划分给最近的聚类中心 <span class="math inline">\(\mu_k\)</span>, 得到聚类标注 <span class="math inline">\(r_n\)</span></p></li><li><p>最小化准则函数, 重新计算聚类中心 <span class="math inline">\(\mu_k\)</span>。求解方法：对<span class="math inline">\(\mu_k\)</span>求导并置零。 <span class="math display">\[J=\sum_{n=1}^N \sum_{k=1}^K r_{n k}\left\|\boldsymbol{x}_n-\mu_k\right\|^2\]</span> 求导： <span class="math display">\[2 \sum_{n=1}^N r_{n k}\left(\boldsymbol{x}_n-\mu_k\right)=0\]</span> 求解： <span class="math display">\[\mu_k=\frac{\sum_n r_{n k} \boldsymbol{x}_n}{\sum_n r_{n k}}\]</span></p></li><li><p>迭代步骤2和3, 直到满足终止条件：聚类中心不再发生显著变化或达到最大迭代次数</p></li></ol><h3 id="高斯混合模型">高斯混合模型</h3><p>是一种统计模型, 用于表示一组数据是由多个高斯分布混合而成的。具体地，高斯混合模型是多个高斯分布的线性组合，每个高斯分布称为一个混合成分, 每个混合成分都有一个对应的混合系数, 所有混合系数的和为 1</p><p><span class="math display">\[\begin{aligned}&amp; p(x)=\sum_i \alpha_i \mathcal{N}\left(x \mid \mu_i, \Sigma_i\right), \sum_i \alpha_i=1 \\\end{aligned}\]</span></p><p>GMM能够捕捉数据的多峰特性, 即数据集中可能存在多个簇, 每个簇的分布可以用一个高斯分布来描述。GMM广泛应用于聚类分析、图像分割、语音识别、数据降维等领域。</p><h3 id="em算法">EM算法</h3><p>EM算法是一种分步迭代优化算法, 适用于包含隐变量的极大似然估计问题。在高斯混合问题中, EM算法通过迭代更新隐变量 <span class="math inline">\(z_n\)</span> 的估计值和GMM的模型参数，使得对数似然函数逐步逼近最大值。通过计算 <span class="math inline">\(z_n\)</span> 的估计值, 可以消除隐变量的影响, 去掉 <span class="math inline">\(\ln\)</span> 函数中的求和项 具体地，EM算法包含两个步骤。E-step：固定GMM的模型参数, 计算隐变量 <span class="math inline">\(z_n\)</span> 的估计值, 即样本属于每个高斯分布的后验概率；M-step：已知隐变量 <span class="math inline">\(z_n\)</span> 的估计值，通过极大似然估计更新GMM的模型参数</p><p>【例题】从<span class="math inline">\(K\)</span>个单高斯模型中采样，得到观测数据<span class="math inline">\(\{x_,\cdots,x_n\}\)</span>。其中第<span class="math inline">\(k\)</span>个单高斯模型服从分布<span class="math inline">\(N(\mu_k,\Sigma_k)\)</span>，<span class="math inline">\(\pi_k\)</span>表示观测数据属于第<span class="math inline">\(k\)</span> 个子模型的概率。请说出如何利用 EM 算法估计混合高斯模型参数，并说明得到的结果是否一定为最优解，若是，请简述理由，若不是，请简述可行的优化方法。</p><p>【解答】似然函数为： <span class="math display">\[\ln p(\mathbf{X} \mid \boldsymbol{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma})=\sum_{n=1}^N \ln \left\{\sum_{k=1}^K \pi_k \mathcal{N}\left(\mathbf{x}_n \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k\right)\right\}\]</span> 其中，<span class="math inline">\(\mathcal{N}\left(\mathbf{x}_n \mid \boldsymbol{\mu}_k, \boldsymbol{\Sigma}_k\right)\)</span>是已知参数为<span class="math inline">\(\mu_k,\Sigma_k\)</span>时的正态分布概率密度函数（以<span class="math inline">\(x_n\)</span>为自变量）。</p><p>设<span class="math inline">\(\gamma(z_{nk})\)</span>为样本<span class="math inline">\(n\)</span>服从第<span class="math inline">\(k\)</span>个高斯分布的后验概率，即： <span class="math display">\[\gamma\left(z_{n k}\right)=\frac{\pi_k \mathcal{N}\left(\mathbf{x}_n \mid \mu_k, \Sigma_k\right)}{\sum_j \pi_j \mathcal{N}\left(\mathbf{x}_n \mid \mu_j, \Sigma_j\right)}\]</span> 将似然函数对<span class="math inline">\(\mu_k,\Sigma_k,\pi_k\)</span>分别求导，得到： <span class="math display">\[\begin{gathered}\boldsymbol{\mu}_k=\frac{1}{N_k} \sum_{n=1}^N \gamma\left(z_{n k}\right) \mathbf{x}_n \\N_k=\sum_{n=1}^N \gamma\left(z_{n k}\right) \\\boldsymbol{\Sigma}_k=\frac{1}{N_k} \sum_{n=1}^N \gamma\left(z_{n k}\right)\left(\mathbf{x}_n-\boldsymbol{\mu}_k\right)\left(\mathbf{x}_n-\boldsymbol{\mu}_k\right)^T \\\pi_k=\frac{N_k}{N}\end{gathered}\]</span> 则利用 EM 算法：</p><ol type="1"><li>初始化<span class="math inline">\(\mu_k,\Sigma_k,\pi_k\)</span></li><li>E step:计算<span class="math inline">\(\gamma(z_{nk})\)</span></li><li>M step:更新<span class="math inline">\(\mu_k,\Sigma_k,\pi_k\)</span></li></ol><p>最终不一定是最优解。可以初始化几次不同的参数进行迭代，取结果最好的那次。</p><h2 id="集成学习">集成学习</h2><p>【来源】参考文献1、2、5</p><p>【讲解】只考过一种题。</p><p>【例题】简述集成学习的基本思想，简述Boosting和Bagging的原理和区别</p><p>【解答】集成学习的基本思想是通过多个学习器进行集成，可以获得比单一学习器更优的泛化性能。其关键是如何产生「好而不同」的个体学习器。</p><p>Boosting是串行方法，即先训练一个学习器，然后对训练集的样本分布进行调整，使得先前错分的样本的权重增加，然后以新的训练集训练新的学习器。如此重复，直到获得够多的学习器，然后进行加权组合。其特点有：</p><ol type="1"><li>弱模型、偏差高、方差低</li><li>个体学习器之间有强依赖，串行生成</li><li>不能显著降低方差。</li></ol><p>Bagging是并行方法，基于自主采样法，构造<span class="math inline">\(T\)</span>个含<span class="math inline">\(m\)</span>个样本的采样集，基于每个采样集训练一个学习器。其特点有：方差低、易于并行、无法降低偏差。</p><h2 id="决策树">决策树</h2><p>【来源】参考文献1、2、3、4、5</p><p>【讲解】考法是使用ID3构造决策树，然后简述预剪枝和后剪枝法。</p><p>【例题】用ID3算法对下面的数据集进行分类，根据星球的大小和轨道判断其是否宜居：</p><table><thead><tr class="header"><th>数量</th><th>大小</th><th>轨道</th><th>是否宜居</th></tr></thead><tbody><tr class="odd"><td>30</td><td>大</td><td>远</td><td>是</td></tr><tr class="even"><td>130</td><td>大</td><td>近</td><td>是</td></tr><tr class="odd"><td>48</td><td>小</td><td>远</td><td>是</td></tr><tr class="even"><td>161</td><td>小</td><td>近</td><td>是</td></tr><tr class="odd"><td>20</td><td>大</td><td>远</td><td>否</td></tr><tr class="even"><td>170</td><td>大</td><td>近</td><td>否</td></tr><tr class="odd"><td>11</td><td>小</td><td>远</td><td>否</td></tr><tr class="even"><td>230</td><td>小</td><td>近</td><td>否</td></tr></tbody></table><ol type="1"><li><p>以分类目标为样本，计算总体信息熵： <span class="math display">\[P(宜居)=\frac{369}{800},P(不宜居)=\frac{431}{800}\]</span> 熵： <span class="math display">\[H_{总体}=-(P(宜居)\log_2(P(宜居))+P(不宜居)\log_2(P(不宜居)))=0.9957\]</span></p></li><li><p>计算属性：大小的信息增益：</p><ol type="1"><li><p>大小-大： <span class="math display">\[P(宜居|大)=\frac{160}{350},P(不宜居|大)=\frac{190}{350}\]</span></p><p><span class="math display">\[H_{大}=0.9947\]</span></p></li><li><p>大小-小： <span class="math display">\[P(宜居|小)=\frac{209}{450},P(不宜居|小)=\frac{241}{450}\]</span></p><p><span class="math display">\[H_{小}=0.9963\]</span></p></li></ol><p>期望信息熵为： <span class="math display">\[H_{大小}=P(大)H_{大}+P(小)H_{小}=0.9956\]</span> 信息增益 <span class="math display">\[G_{大小}=H_{总}-H_{大小}=0.001\]</span></p></li><li><p>计算属性：轨道的信息增益</p><ol type="1"><li><p>轨道-近： <span class="math display">\[P(宜居|近)=\frac{291}{691},P(不宜居|近)=\frac{400}{691}\]</span></p><p><span class="math display">\[H_{近}=0.9820\]</span></p></li><li><p>轨道-远： <span class="math display">\[P(宜居|远)=\frac{78}{109},P(不宜居|远)=\frac{31}{109}\]</span></p><p><span class="math display">\[H_{远}=0.8614\]</span></p></li></ol><p>期望信息熵为： <span class="math display">\[H_{轨道}=P(近)H_{近}+P(远)H_{远}=0.9656\]</span> 信息增益 <span class="math display">\[G_{轨道}=0.0301\]</span></p></li><li><p>所以，第一个结点为「轨道」：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412211550252.png" alt="image-20241221155055706" /><figcaption aria-hidden="true">image-20241221155055706</figcaption></figure></li><li><p>计算子树T1</p><p>因为 <span class="math display">\[P(宜居|大,近)&lt;P(不宜居|大,近)\]</span></p><p><span class="math display">\[P(宜居|小,近)&lt;P(不宜居|小,近)\]</span></p><p>所以<span class="math inline">\(T_1\)</span>为叶结点，置为「不宜居」</p></li><li><p>计算子树<span class="math inline">\(T_2\)</span> <span class="math display">\[P(宜居|大,远)&gt;P(不宜居|大,远)\]</span></p><p><span class="math display">\[P(宜居|小,远)&gt;P(不宜居|小,远)\]</span></p><p>所以<span class="math inline">\(T_2\)</span>为叶结点，置为「宜居」</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412211558936.png" alt="image-20241221155847215" /><figcaption aria-hidden="true">image-20241221155847215</figcaption></figure></li></ol><p>【例题2】描述预剪枝法和后剪枝法的方法和优缺点</p><p>【解答】（以下内容由AI生成）</p><p>预剪枝法（Pre-pruning）</p><p><strong>具体方法</strong>： 预剪枝是在决策树生成的过程中，对每个节点在划分前先进行估计，如果当前节点的划分不能带来决策树泛化性能提升，则停止划分，并将当前节点标记为叶子节点。常见的预剪枝策略包括限制树的最大深度、限制叶节点的最小样本数量、限制节点划分所需的最小信息增益等。</p><p><strong>优点</strong>： 1. <strong>降低过拟合风险</strong>：通过限制树的生长，减少过拟合的可能性。 2. <strong>减少训练和测试时间</strong>：由于树的生长被提前终止，可以减少模型的训练和预测时间。</p><p><strong>缺点</strong>： 1. <strong>欠拟合风险</strong>：由于提前停止树的生长，可能会错过一些对模型性能有益的分支，导致模型欠拟合。 2. <strong>视野效应问题</strong>：可能在当前划分看似不能提升性能的情况下，进一步的扩展能够显著提高性能，预剪枝会导致算法过早停止。</p><p>后剪枝法（Post-pruning）</p><p><strong>具体方法</strong>： 后剪枝是在决策树完全生长之后进行的剪枝，它首先生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。常见的后剪枝方法包括错误率降低剪枝（REP）、悲观错误剪枝（PEP）、代价复杂度剪枝（CCP）等。</p><p><strong>优点</strong>： 1. <strong>泛化性能通常优于预剪枝</strong>：后剪枝保留了更多的分支，使得模型有更大的空间去学习和适应数据的复杂模式。 2. <strong>减少欠拟合风险</strong>：相较于预剪枝，后剪枝的欠拟合风险更小。</p><p><strong>缺点</strong>： 1. <strong>训练时间开销大</strong>：后剪枝需要在生成完全决策树之后进行剪枝，因此其训练时间开销比未剪枝决策树和预剪枝决策树都要大得多。 2. <strong>计算资源需求高</strong>：由于需要在完整的决策树上进行剪枝操作，后剪枝需要更多的计算资源。</p><p>总结来说，预剪枝和后剪枝都是为了解决决策树的过拟合问题，提高模型的泛化能力。预剪枝通过提前停止树的生长来减少过拟合风险，但可能会增加欠拟合风险；而后剪枝通过在完全生成树之后进行剪枝，通常能获得更好的泛化性能，但需要更多的计算资源和时间。在实际应用中，需要根据具体的问题和数据集选择合适的剪枝策略。</p><h2 id="概率图模型">概率图模型</h2><p>【来源】参考文献1、2、3</p><p>【讲解】这部分的考法就是考贝叶斯网络或者马尔可夫场。先问你马尔可夫概率图的最大团，然后再让你写出两个概率图的联合分布。</p><p>其中贝叶斯网络是一个DAG（有向无环图）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412211606705.png" alt="贝叶斯概率图" /><figcaption aria-hidden="true">贝叶斯概率图</figcaption></figure><p>它的联合分布就从底向上一层层写即可，如下： <span class="math display">\[P(x_1)P(x_2)P(x_3)P(x_4|x_1,x_2,x_3)P(x_5|x_1,x_3)P(x_6|x_4)P(x_7|x_4,x_5)\]</span> 马尔可夫场是一个无向图，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412211612602.png" alt="image-20241221161219707" /><figcaption aria-hidden="true">image-20241221161219707</figcaption></figure><p>所谓的「团」指的是任意两点之间都有边的子集。最大团指的是不能被其它团包含的团。图中的蓝色框线就是两个最大团。</p><p>马尔可夫场的联合概率分布基于最大团分解为多个因子的乘积，设所有最大团构成的集合为<span class="math inline">\(C\)</span>，则联合概率分布为</p><p><span class="math display">\[P(X)=\frac{1}{Z} \prod_{Q \in C} \psi_Q\left(X_Q\right)\]</span> 上图的概率分布为： <span class="math display">\[P\left(x_1, x_2, x_3, x_4\right)=\frac{1}{Z} \psi_{123}\left(x_1, x_2, x_3\right) \psi_{34}\left(x_3, x_4\right)\]</span></p><h2 id="bp反向传播算法">BP反向传播算法</h2><p>【来源】参考文献1、2、3、4、5</p><p>【讲解】</p><p>首先记住这个神经元的基本结构，尤其记住各个符号的含义：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412211700434.png" alt="神经元的基本结构" /><figcaption aria-hidden="true">神经元的基本结构</figcaption></figure><ol type="1"><li><p><span class="math inline">\(x_1\cdots x_N\)</span>：前一层的输入</p></li><li><p><span class="math inline">\(w_1\cdots w_N\)</span>：权值，也是神经网络训练的目标</p></li><li><p><span class="math inline">\(\Sigma\)</span>：求和器</p></li><li><p><span class="math inline">\(\theta\)</span>：求和器阈值，可有可无</p></li><li><p><span class="math inline">\(a\)</span>： <span class="math display">\[a=\sum_{i=1}^Nx_iw_i-\theta\]</span></p></li><li><p><span class="math inline">\(f\)</span>：激活函数，就是ReLU啊、Sigmoid啊之类的</p></li><li><p><span class="math inline">\(y\)</span>：神经元输出 <span class="math display">\[y=f(a)\]</span></p></li></ol><p>之后的神经网络图中，每一个「圆点」，其实都暗含了这些东西。</p><p>所谓的反向传播算法，就是定义一个损失函数： <span class="math display">\[E(w)=\frac 12 \sum_{i=1}^N (y(x_i,w)-t_i)^2\]</span> 计算它的梯度<span class="math inline">\(\nabla E(w)\)</span>，然后用梯度下降法更新<span class="math inline">\(w\)</span>。</p><p>算法可以分为两个阶段：</p><ol type="1"><li>前馈(正向过程)：从输入层经隐层逐层正向计算各单元的输出；</li><li>学习(反向过程)：由输出误差逐层反向计算隐层各单元的误差，并用此误差修正前层的权值</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412211720451.png" alt="image-20241221172009190" /><figcaption aria-hidden="true">image-20241221172009190</figcaption></figure><p>现在，我们要计算<span class="math inline">\(E\)</span>对<span class="math inline">\(w\)</span>的导数，记激活函数为<span class="math inline">\(h\)</span>。我们知道<span class="math inline">\(E\)</span>是<span class="math inline">\(y\)</span>的函数，<span class="math inline">\(y\)</span>是<span class="math inline">\(a\)</span>的函数，<span class="math inline">\(a\)</span>是<span class="math inline">\(w,x\)</span>的函数，故： <span class="math display">\[\begin{aligned}\frac{\partial E_n}{\partial w_{k j}} &amp; =\frac{\partial E_n}{\partial y_k} \frac{\partial y_k}{\partial a_k} \frac{\partial a_k}{\partial w_{k j}} \\&amp; =\left(y_k-t_k\right) \frac{\partial y_k}{\partial a_k} \frac{\partial a_k}{\partial w_{k j}} \\&amp; =\left(y_k-t_k\right) h^{\prime}\left(a_k\right) \frac{\partial a_k}{\partial w_{k j}} \\&amp; =\left(y_k-t_k\right) h^{\prime}\left(a_k\right) x_j\end{aligned}\]</span> 现在，如果要计算<span class="math inline">\(j\)</span>层的梯度，即： <span class="math display">\[\frac{\partial E_n}{\partial w_{j i}}=\frac{\partial E_n}{\partial a_j} \frac{\partial a_j}{\partial w_{j i}}\]</span></p><p>接下来使用两个记号： <span class="math display">\[\delta_j=\frac{\partial E_n}{\partial y_j} \frac{\partial y_j}{\partial a_j}=\frac{\partial E_n}{\partial a_j}\]</span> 和 <span class="math display">\[z_i=\frac{\partial a_k}{\partial w_{k i}}\]</span> 则有 <span class="math display">\[\frac{\partial E_n}{\partial w_{j i}}=\delta_j z_i\]</span> 因为上面已经求出了输出层的误差，根据误差反向传播的原理，当前层的误差可理解为上一层所有神经元误差的复合函数，即使用上一层的误差来表示当前层误差，并依次递推。有： <span class="math display">\[\delta_j=\frac{\partial E_n}{\partial a_{j}}=\frac{\partial E_n}{\partial a_{k}}\frac{\partial a_{k}}{\partial a_j}\]</span> 其中 <span class="math display">\[a_{k}=\sum_{k}w_{kj}h(a_{j})\]</span> 故： <span class="math display">\[\delta_j=h^{\prime}\left(a_j\right) \sum_k w_{k j} \delta_k\]</span> 这样，我们就推导出了反向传播的递推式。</p><p>整体算法流程</p><ol type="1"><li><p>初始化权重 <span class="math inline">\(w_{i j}\)</span></p></li><li><p>对于输入的训练样本, 求取每个节点输出和最终输出层的输出值</p></li><li><p>对于输出层求 <span class="math display">\[\delta_k=y_k-t_k\]</span></p></li><li><p>对于隐藏层求 <span class="math display">\[\quad \delta_j=h^{\prime}\left(a_j\right) \sum_k w_{k j} \delta_k\]</span></p></li><li><p>求输出误差对于每个权重的梯度 <span class="math display">\[\frac{\partial E_n}{\partial w_{j i}}=\delta_j x_i\]</span></p></li><li><p>更新权重 <span class="math display">\[\quad \mathbf{w}^{(\tau+1)}=\mathbf{w}^{(\tau)}-\eta \nabla E\left(\mathbf{w}^{(\tau)}\right)\]</span></p></li></ol><p>此外，还要记住一个结论： <span class="math display">\[\sigma&#39;(x)=\sigma(x)(1-\sigma(x))\]</span> 其中<span class="math inline">\(\sigma\)</span>是Sigmoid函数，即 <span class="math display">\[\sigma(x)=\frac 1{1+e^{-x}}\]</span></p><p>【例题1】包含一层隐藏层的前馈神经网络如图所示, 其中给定训练集 <span class="math inline">\(D=\left\{\left(x_1, t_1\right),\left(x_2, t_2\right), \cdots,\left(x_N, t_N\right)\right\}, x_i \in \mathbb{R}^D, t_i \in \mathbb{R}^K\)</span> 。隐藏层激活函数为 <span class="math inline">\(\mathrm{h}(\mathrm{x})\)</span>, 输出层激活函数为 <span class="math inline">\(\sigma(\mathrm{x})\)</span> 。 <span class="math inline">\(y_n\)</span> 表示第<span class="math inline">\(n\)</span>个样本 <span class="math inline">\(x_n\)</span> 对应的神经网络输出向量, <span class="math inline">\(y_n=\left[y_{n 1}, \cdots, y_{n k}, \cdots, y_{n K}\right]^T\)</span>, 准则函数为 <span class="math inline">\(E_n(\mathrm{w})=\frac{1}{2} \sum_{\mathrm{k}=1}^{\mathrm{K}}\left\{\mathrm{y}_{\mathrm{nk}}-\mathrm{t}_{\mathrm{nk}}\right\}^2\)</span> 。网络包含$ D $个输入神经元, $K <span class="math inline">\(个输出神经元, 以及\)</span> M$个隐层神经元。试推导反向传播算法中对每一层权值参数（ <span class="math inline">\(\omega_{m d}^{(1)}\)</span> 与 <span class="math inline">\(\omega_{k m}^{(2)}\)</span> ) 的更新</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412281544407.png" alt="image-20241228154357203" style="zoom:50%;" /></p><p>【解答1】先推导前向传播： <span class="math display">\[\begin{align}a_m&amp;=\sum_{d=1}^D x_dw_{md}^{(1)}\\z_m&amp;=h(a_m)\\a_k&amp;=\sum_{m=0}^Mz_mw_{km}^{(2)}\\y_nk&amp;=\sigma(a_k)\end{align}\]</span> 对输出层： <span class="math display">\[\begin{align}\delta_k&amp;=\frac{\partial E_n}{\partial a_k}\\&amp;=\frac{\partial E_n}{\partial y_{nk}}\frac{\partial y_{nk}}{a_k}\\&amp;=(y_{nk}-t_{nk})\sigma&#39;(a_k)\end{align}\]</span> 对隐藏层： <span class="math display">\[\begin{align}\delta_m&amp;=\frac{\partial E_n}{\partial a_m}\\&amp;=\frac{\partial E_n}{\partial a_k}\frac{\partial a_k}{\partial a_m}\end{align}\]</span> 其中， <span class="math display">\[a_k=\sum h(a_m)w_{km}^{(2)}\]</span> 则有： <span class="math display">\[\begin{align}\delta_m&amp;=\frac{\partial E_n}{\partial a_m}\\&amp;=\frac{\partial E_n}{\partial a_k}\frac{\partial a_k}{\partial a_m}\\&amp;=h&#39;(a_m)\sum_{k}\delta_kw_{km}^{(2)}\end{align}\]</span> 则权值更新公式为： <span class="math display">\[\begin{aligned}&amp; \frac{\partial E_n}{\partial \omega_{k m}^{(2)}}=\delta_k \cdot \frac{\partial a_k}{\partial \omega_{k m}^{(2)}}=z_m \cdot\left(y_{n k}-t_{n k}\right) \cdot \sigma^{\prime}\left(a_k\right) \\&amp; \frac{\partial E_n}{\partial \omega_{m d}^{(1)}}=\delta_m \cdot \frac{\partial a_m}{\partial \omega_{m d}^{(1)}}=x_d \cdot h^{\prime}\left(a_m\right) \sum_k \delta_k \cdot \omega_{k m}^{(2)}\end{aligned}\]</span> 【例题2】考虑只有一个神经元的多层神经网络, 其中 <span class="math inline">\(x_{i+1}=\sigma\left(z_i\right)=\)</span> <span class="math inline">\(\sigma\left(w_i x_i+b_i\right)(i \in[1,4]), C=\operatorname{Loss}\left(x_5\right), \sigma\)</span> 表示 sigmoid 函数 <span class="math inline">\(f(x)=1 /(1+\)</span> <span class="math inline">\(\left.e^{-x}\right)\)</span>, 且 <span class="math inline">\(\left|w_i\right|&lt;1\)</span> 。假设已知 <span class="math inline">\(\frac{\partial C}{\partial b_5}\)</span>, 推导 <span class="math inline">\(\frac{\partial C}{\partial b_i}(i \in[1,4])\)</span>, 并阐述当神经网络层数过深时, 梯度消失的原因。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412281622074.png" alt="image-20241228162218891" /><figcaption aria-hidden="true">image-20241228162218891</figcaption></figure><p>【解答2】</p><ol type="1"><li><p><span class="math inline">\(i=4\)</span>时，有：<span class="math inline">\(x_5=\sigma(z_5),z_5=w_4x_4+b_4\)</span>，因此： <span class="math display">\[\frac{\partial {C}}{\partial {b}_4}=\frac{\partial {C}}{\partial {x}_5} \frac{\partial {x}_5}{\partial {z}_4} \frac{\partial {z}_4}{\partial {b}_4}=\frac{\partial {C}}{\partial {x}_5} \sigma^{\prime}\left({z}_4\right)\]</span></p></li><li><p><span class="math inline">\(i=3\)</span>时，有：<span class="math inline">\(x_4=\sigma(z_4),z_4=w_3x_3+b_3\)</span>，则： <span class="math display">\[\frac{\partial {C}}{\partial {b}_3}=\frac{\partial {C}}{\partial {x}_5} \frac{\partial {x}_5}{\partial {z}_4} \frac{\partial {z}_4}{\partial {x}_4} \frac{\partial {x}_4}{\partial {z}_3} \frac{\partial {z}_3}{\partial {b}_3}= \frac{\partial {C}}{\partial {x}_5} \sigma^{\prime}\left({z}_4\right) {w}_4 \sigma^{\prime}\left({z}_3\right) \]</span></p></li><li><p><span class="math inline">\(i=2\)</span>时，有：<span class="math inline">\(x_3=\sigma(z_3),z_3=w_2x_2+b_2\)</span>，则： <span class="math display">\[\frac{\partial {C}}{\partial {b}_2}=\frac{\partial {C}}{\partial {x}_5} \frac{\partial {x}_5}{\partial {z}_4} \frac{\partial {z}_4}{\partial {x}_4} \frac{\partial {x}_4}{\partial {z}_3} \frac{\partial {z}_3}{\partial {x}_3} \frac{\partial {x}_3}{\partial {z}_2} \frac{\partial {z}_2}{\partial {b}_2}=  \frac{\partial {C}}{\partial {x}_5} \sigma^{\prime}\left({z}_4\right) {w}_4 \sigma^{\prime}\left({z}_3\right) {w}_3 \sigma^{\prime}\left({z}_2\right)\]</span></p></li><li><p><span class="math inline">\(i=1\)</span>时，同理，有： <span class="math display">\[\frac{\partial {C}}{\partial {b}_1}=\frac{\partial {C}}{\partial {x}_5} \sigma^{\prime}\left({z}_4\right) {w}_4 \sigma^{\prime}\left({z}_3\right) {w}_3 \sigma^{\prime}\left({z}_2\right) {w}_2 \sigma^{\prime}\left({z}_1\right)\]</span></p></li></ol><p>由于 <span class="math inline">\(\sigma^{\prime}(z) \leq \frac{1}{4}\)</span> 且 <span class="math inline">\(|w|&lt;1\)</span>, 则当层数过深时, <span class="math inline">\(\frac{\partial C}{\partial b_1}\)</span> 趋于 0 , 则梯度消失</p><h2 id="开放性试题">开放性试题</h2><p>【来源】参考文献1、2、3、4、5</p><p>【讲解】每张卷子的最后一题是开放性试题。</p><p>【例题1】谈谈你对深度学习的理解，深度学习模型存在什么问题，你觉得深度学习未来会往什么方向发展。</p><p>【解答1】（以下解答由AI生成）</p><p><strong>我对深度学习的理解</strong></p><p>深度学习是机器学习的一个子领域，它基于人工神经网络的学习算法，特别是那些具有多个非线性变换的层（即深度）。这些层可以学习数据的复杂模式和表示。深度学习模型能够自动从原始数据中提取特征，而不需要人为设计特征提取算法。这种能力使得深度学习在图像识别、语音识别、自然语言处理等领域取得了革命性的进展。</p><p><strong>深度学习模型存在的问题</strong></p><ol type="1"><li><strong>数据需求</strong>：深度学习模型通常需要大量的标注数据来训练，这在某些领域（如医疗图像分析）可能是不切实际的。</li><li><strong>可解释性</strong>：深度学习模型通常被认为是“黑箱”，因为它们的决策过程缺乏透明度，难以解释。</li><li><strong>计算资源</strong>：训练深度学习模型需要大量的计算资源，这可能导致成本高昂和能源消耗问题。</li><li><strong>过拟合</strong>：在有限的数据集上训练时，深度学习模型可能会过拟合，即在训练数据上表现很好，但在未见过的数据上表现差。</li><li><strong>对抗性脆弱性</strong>：深度学习模型可能对精心设计的输入（对抗性样本）非常敏感，这些输入可以导致模型做出错误的预测。</li><li><strong>泛化能力</strong>：在某些情况下，深度学习模型可能难以泛化到新的、未见过的数据或任务上。</li></ol><p><strong>深度学习未来的发展方向</strong></p><ol type="1"><li><strong>更少的数据需求</strong>：研究者正在探索如何使用更少的数据来训练有效的深度学习模型，例如通过迁移学习、元学习和数据增强技术。</li><li><strong>提高可解释性</strong>：深度学习模型的可解释性是一个活跃的研究领域，目标是使模型的决策过程更加透明和可理解。</li><li><strong>节能和效率</strong>：随着对环境影响的关注增加，研究者正在寻找更节能的算法和硬件来训练和部署深度学习模型。</li><li><strong>对抗性鲁棒性</strong>：提高模型对对抗性攻击的鲁棒性是一个重要的研究方向，以确保模型在现实世界中的可靠性。</li><li><strong>泛化能力</strong>：研究者正在探索如何提高深度学习模型的泛化能力，使其能够更好地适应新环境和任务。</li><li><strong>跨领域应用</strong>：深度学习可能会扩展到新的领域，如生物信息学、材料科学和量子计算。</li><li><strong>集成学习</strong>：结合不同的模型和算法来提高性能和鲁棒性，例如集成学习。</li><li><strong>伦理和公平性</strong>：随着深度学习在社会中应用的增加，确保模型的公平性和避免偏见成为一个重要议题。</li><li><strong>自动机器学习（AutoML）</strong>：自动化深度学习模型的设计和训练过程，使非专家也能轻松使用深度学习技术。</li></ol><p>深度学习是一个快速发展的领域，随着技术的进步和新挑战的出现，未来的发展方向可能会不断变化。</p><p>【例题2】给出机器学习和深度学习的联系，各有什么优缺点</p><p>【解答2】（以下解答由AI生成）</p><p>机器学习和深度学习是人工智能领域中密切相关的两个概念，它们之间存在一些联系和区别。</p><p><strong>联系</strong></p><ol type="1"><li><strong>基础理论</strong>：深度学习是机器学习的一个子集，它基于机器学习的一些核心概念，如模式识别和学习算法。</li><li><strong>目标</strong>：两者都旨在从数据中学习，并做出预测或决策。</li><li><strong>数据驱动</strong>：机器学习和深度学习都依赖于数据来训练模型，并通过数据改进模型的性能。</li><li><strong>特征学习</strong>：深度学习是机器学习中特征学习的一个特例，它能够自动从原始数据中提取复杂的特征。</li></ol><p><strong>机器学习的优点</strong></p><ol type="1"><li><strong>灵活性</strong>：机器学习算法（如支持向量机、决策树、随机森林等）适用于各种不同的数据类型和问题。</li><li><strong>可解释性</strong>：某些机器学习模型（如决策树）相对容易解释，有助于理解模型的决策过程。</li><li><strong>数据效率</strong>：一些机器学习算法可以在较小的数据集上训练，不需要像深度学习那样大量的数据。</li><li><strong>适应性</strong>：机器学习模型可以更容易地适应新的数据分布，尤其是在数据分布发生变化时。</li></ol><p><strong>机器学习的缺点</strong></p><ol type="1"><li><strong>特征工程</strong>：在传统的机器学习中，特征工程是一个耗时且需要专业知识的过程。</li><li><strong>模型复杂度</strong>：对于非常复杂的数据模式，机器学习模型可能难以捕捉到这些模式。</li><li><strong>泛化能力</strong>：在面对未见过的数据时，一些机器学习模型可能泛化能力不足。</li></ol><p><strong>深度学习的优点</strong></p><ol type="1"><li><strong>自动特征提取</strong>：深度学习模型能够自动从原始数据中提取特征，减少了人工特征工程的需求。</li><li><strong>处理复杂数据</strong>：深度学习特别擅长处理高维和复杂的数据，如图像、视频和语音。</li><li><strong>强大的表示能力</strong>：深度学习模型具有强大的表示能力，能够学习数据的多层次抽象。</li><li><strong>端到端学习</strong>：深度学习可以实现端到端的学习，即直接从输入到输出的映射，无需手动设计中间步骤。</li></ol><p><strong>深度学习的缺点</strong></p><ol type="1"><li><strong>数据需求</strong>：深度学习模型通常需要大量的标注数据来训练。</li><li><strong>计算资源</strong>：训练深度学习模型需要强大的计算资源，如GPU集群。</li><li><strong>可解释性</strong>：深度学习模型（尤其是大型神经网络）通常被认为是“黑箱”，难以解释其决策过程。</li><li><strong>过拟合风险</strong>：在有限的数据集上，深度学习模型可能会过拟合，导致在新数据上的性能不佳。</li></ol><p>总的来说，机器学习和深度学习各有优势和局限，它们在不同的应用场景下可以互补。随着技术的发展，两者之间的界限越来越模糊，例如，通过集成学习和迁移学习，可以将深度学习模型的泛化能力和机器学习模型的灵活性结合起来。</p><p>【例题3】谈谈机器学习在某领域（医疗、金融、电商、交通等）的应用</p><p>【解答3】（以下解答由AI生成）</p><p><strong>机器学习在医疗领域的应用</strong></p><p>机器学习在医疗领域的应用非常广泛，主要包括：</p><ol type="1"><li><p><strong>疾病诊断与预测</strong>：通过分析患者的病史、基因组数据等信息，机器学习模型可以提前预测某些疾病的风险，帮助医生制定个性化的预防和治疗方案。例如，谷歌的深度学习模型通过分析视网膜扫描图像，能够准确预测糖尿病视网膜病变等眼疾，其诊断准确率媲美专业医生。</p></li><li><p><strong>医学影像识别</strong>：机器学习模型能够实现对X光片、CT扫描、MRI等影像的自动分析，提高影像学诊断的准确率，降低误诊率。</p></li><li><p><strong>药物研发与筛选</strong>：机器学习能够加速新药发现与优化，通过学习化学结构、生物活性、副作用等数据，预测化合物的药效，辅助药物设计与候选分子筛选，显著缩短研发周期。</p></li></ol><p><strong>机器学习在金融领域的应用</strong></p><p>机器学习在金融领域的应用包括：</p><ol type="1"><li><p><strong>风险评估与信用评估</strong>：金融机构利用机器学习模型分析客户的历史贷款记录、还款习惯等数据，评估其信用风险并定制个性化的贷款方案。</p></li><li><p><strong>交易策略</strong>：机器学习模型在投资预测中的应用也越来越普遍，例如，量化分析师使用机器学习算法分析市场数据，识别规律，实现高频交易。</p></li><li><p><strong>欺诈检测</strong>：机器学习模型能够实时监测交易行为，识别异常模式，及时预警并拦截潜在欺诈交易。</p></li></ol><p><strong>机器学习在电商领域的应用</strong></p><p>机器学习在电商领域的应用主要体现在：</p><ol type="1"><li><p><strong>推荐系统</strong>：电商平台利用机器学习技术，根据用户的购买历史、浏览行为等构建个性化推荐模型，提升商品转化率与用户满意度。</p></li><li><p><strong>库存优化与需求预测</strong>：零售商运用机器学习预测未来销售趋势，精准管理库存水平，避免过度库存导致的资金占用与滞销风险。</p></li></ol><p><strong>机器学习在交通领域的应用</strong></p><p>机器学习在交通领域的应用包括：</p><ol type="1"><li><p><strong>交通流量预测与拥堵缓解</strong>：通过分析历史交通数据，机器学习模型可以预测未来的交通流量，帮助交通管理部门优化交通流量分配，减少交通拥堵和事故的发生。</p></li><li><p><strong>智能交通管理</strong>：机器学习技术可以用于实时监测和预测交通状况，优化交通流量分配，提高交通的效率和安全性。</p></li><li><p><strong>自动驾驶</strong>：自动驾驶汽车依托深度学习、强化学习等技术，实现环境感知、路径规划、决策控制等功能。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Matlab训练卷积神经网络完成表情包分类任务</title>
    <link href="/2024/12/17/%E4%BD%BF%E7%94%A8Matlab%E8%AE%AD%E7%BB%83%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%8C%E6%88%90%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/12/17/%E4%BD%BF%E7%94%A8Matlab%E8%AE%AD%E7%BB%83%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%8C%E6%88%90%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>在本项目中，我使用Matlab 2019a软件搭建了两个模型，分别是自己设计的卷积神经网络模型，和参考了VGG结构的卷积神经网络模型，在数据量为4697的emoji表情包数据集上进行测试，完成表情包图像分类任务，最终分类准确率为93.8%。成绩不算高，只能说可以解决有无问题。</p><p>Matlab 语言要求所有函数都定义在代码的最后，但是为了阅读顺畅，本文档修改了部分代码的顺序。如果需要运行代码，请<a href="https://docsdown.oss-cn-beijing.aliyuncs.com/matlab%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%BA%90%E4%BB%A3%E7%A0%81.zip">下载源代码文件</a>。因版权原因，无法提供数据集和测试集。</p><span id="more"></span><p>[toc]</p><h2 id="概述">概述</h2><p>在本项目中，我使用Matlab 2019a软件搭建了两个模型，分别是自己设计的卷积神经网络模型，和参考了VGG结构的卷积神经网络模型，在数据量为4697的emoji表情包数据集上进行测试，完成表情包图像分类任务，最终分类准确率为93.8%。</p><p>其中，自己设计的卷积神经网络共有6个卷积层和2个全连接层，参考VGG结构的卷积神经网络有6个部分，其中前五个部分为2~3个卷积层的级联，第6个部分为三个全连接层。</p><p>在训练时，将数据集中的90%用作训练集，10%用作测试集，并在训练集上使用<code>augmentedImageDatastore</code>方法进行数据增强。考虑到数据集的特性，采取了随机水平翻转、随机缩放、随机水平/竖直位移四种方法进行增强。</p><p>用训练集训练，调整超参数，当模型的表现达到较好的水平时，再将整个数据集当作训练集，训练出最终的模型。</p><p>用上面的训练过程，调整不同的训练设置（例如将图像进行灰度/彩色处理），训练出多个不同的神经网络。在最终生成测试表格时，用这七个网络进行投票选择，按每个网络预测的前两名标签的置信概率加权投票，选出最终的预测标签。</p><h2 id="网络设定">网络设定</h2><h3 id="卷积神经网络">卷积神经网络</h3><p>卷积神经网络（CNN）是一种深度学习模型，它在图像识别、视频分析、自然语言处理等领域表现出色。CNN的原理基于生物学中的视觉皮层机制，特别是动物视觉系统对空间层次结构的处理方式。卷积神经网络的原理基于以下几点：</p><ol type="1"><li><p><strong>局部感受野</strong>：</p><p>卷积神经网络中的每个神经元都只对输入数据的一个局部区域（即感受野）进行响应，这与生物视觉系统中的局部感受器类似。相同的权重模式可以在视觉皮层的不同位置复制，以检测不同位置的相同特征,这种局部连接方式大大减少了网络的参数数量。</p></li><li><p><strong>权值共享</strong></p><p>在卷积层中，同一个卷积核（或滤波器）的权重在整个输入数据上是共享的。这意味着无论输入图像有多大，使用的卷积核大小是固定的，这有助于检测图像中的局部特征，并且减少了模型的参数量。</p></li><li><p><strong>池化</strong></p><p>也叫做下采样或汇聚层，对不同空间位置的特征值进行聚合统计。常用池化操作有最大池化（Max Pooling）、平均池化（Mean Pooling）、随机池化（Stochastic Pooling）往往在卷积层后面，实现降维，减少参数和计算量，防止过拟合，使模型对尺度、平移、旋转变化具有一定的不变性。</p></li><li><p><strong>多层处理</strong></p><p>CNN通常包含多个卷积层和池化层，每一层都在提取不同层次的特征。较低层次可能捕捉简单的特征（如边缘），而较高层次则可能捕捉更复杂的特征（如物体的部分）。</p></li></ol><p>在我自己设计的CNN中，参考课程PPT，共有1个卷积块，其中有6个卷积层，卷积核大小为3x3，通道数分别为16、32、64、128、256、512，卷积层之间有ReLU激活层；有两个全连接层，规模分别为1000和50，全连接层之间有dropout。</p><p>相关代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义CNN架构</span><br>layers = [<br>    imageInputLayer([<span class="hljs-number">64</span> <span class="hljs-number">64</span> <span class="hljs-number">3</span>]) <span class="hljs-comment">% 图像大小设置为64x64，3个颜色通道</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第1个卷积层</span><br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">% 池化层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第2个卷积层</span><br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">% 池化层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">64</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第3个卷积层</span><br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">128</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第4个卷积层</span><br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">256</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第5个卷积层</span><br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第6个卷积层</span><br>    batchNormalizationLayer<br>    reluLayer<br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    fullyConnectedLayer(<span class="hljs-number">1024</span>) <span class="hljs-comment">% 增加全连接层的神经元数量</span><br>    dropoutLayer(<span class="hljs-number">0.5</span>) <span class="hljs-comment">% 在全连接层之后添加 Dropout 层，丢弃概率为 0.5</span><br>    reluLayer<br>    fullyConnectedLayer(<span class="hljs-number">50</span>) <span class="hljs-comment">% 全连接层，有50个类别</span><br>    softmaxLayer<br>    classificationLayer];<br></code></pre></td></tr></table></figure><h3 id="vgg网络">VGG网络</h3><p>VGG（Visual Geometry Group）网络是由牛津大学的视觉几何组在2014年提出的深度学习模型，它在当年的ILSVRC（ImageNet Large Scale Visual Recognition Challenge）比赛中取得了分类任务的亚军。VGG网络以其简洁性和卓越的性能而受到广泛关注，并且至今仍被广泛应用于图像识别、目标检测等计算机视觉任务中。在本项目中，我试图自己构造了VGG16.</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412181555887.png" alt="image-20241218155554092" /><figcaption aria-hidden="true">image-20241218155554092</figcaption></figure><p>VGG16包含了5个卷积块，每个卷积块分别包含2、2、3、3、3个卷积层，每个卷积层的通道数依次是64、128、256、512、512；包含了3个全连接层，规模分别为4096、4096和50。全连接层之间有dropout。</p><p>相关代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义CNN架构</span><br>layers = [<br>    imageInputLayer([<span class="hljs-number">64</span> <span class="hljs-number">64</span> <span class="hljs-number">3</span>]) <br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">64</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第一个卷积块</span><br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">64</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">% 池化层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">128</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第二个卷积块</span><br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">128</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">% 池化层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">256</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第三个卷积块</span><br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">256</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">256</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第四个卷积块</span><br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">% 第五个卷积块</span><br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">512</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    fullyConnectedLayer(<span class="hljs-number">4096</span>) <span class="hljs-comment">% 增加全连接层的神经元数量</span><br>    reluLayer<br>    dropoutLayer(<span class="hljs-number">0.5</span>) <span class="hljs-comment">% 在全连接层之后添加 Dropout 层，丢弃概率为 0.5</span><br>    fullyConnectedLayer(<span class="hljs-number">4096</span>) <span class="hljs-comment">% 增加全连接层的神经元数量</span><br>    reluLayer<br>    dropoutLayer(<span class="hljs-number">0.5</span>) <span class="hljs-comment">% 在全连接层之后添加 Dropout 层，丢弃概率为 0.5</span><br>    fullyConnectedLayer(<span class="hljs-number">50</span>) <span class="hljs-comment">% 全连接层，有50个类别</span><br>    softmaxLayer<br>    classificationLayer];<br></code></pre></td></tr></table></figure><h2 id="数据预处理">数据预处理</h2><p>在数据预处理阶段，我主要使用<code>augmentedImageDatastore</code>方法进行数据增强。</p><p>图像分类中的<strong>数据增强</strong>是一种提高模型泛化能力和性能的技术，特别是在标注数据有限的情况下。数据增强通过创建图像数据的变体来模拟训练集中的多样性，帮助模型学习到更加鲁棒的特征。数据增强的主要方法有随机旋转、随机缩放、随机裁剪、随机翻转、颜色变换、仿射变换、添加噪声等。考虑到图标数据集比较风格化，也没有太多的旋转、倒置等情况，我采取了随机水平翻转、随机缩放、随机水平/竖直位移四种方法进行增强。</p><p>在读取阶段，我将所有图像放缩到同一大小，并对图像的数据进行归一化处理。</p><p>相关代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 加载训练数据，并应用读取函数</span><br>loadImages = imageDatastore(<span class="hljs-string">&#x27;train&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;IncludeSubfolders&#x27;</span>,<span class="hljs-built_in">true</span>, ...<br>    <span class="hljs-string">&#x27;LabelSource&#x27;</span>,<span class="hljs-string">&#x27;foldernames&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;ReadFcn&#x27;</span>,@readFcn);<br><br><span class="hljs-comment">% 测试集比例</span><br>validationRatio = <span class="hljs-number">0.1</span>;<br><br>[trainImages, validationImages] = splitEachLabel(loadImages, (<span class="hljs-number">1</span> - validationRatio),<span class="hljs-string">&#x27;randomized&#x27;</span>)<br><br><span class="hljs-comment">% 数据增强选项</span><br>imageAugmenter = imageDataAugmenter(...<br>    <span class="hljs-string">&#x27;RandXReflection&#x27;</span>,<span class="hljs-built_in">true</span>,...    <span class="hljs-comment">%水平翻转</span><br>    <span class="hljs-string">&#x27;RandScale&#x27;</span>,[<span class="hljs-number">0.6</span>,<span class="hljs-number">1.4</span>],...     <span class="hljs-comment">%随机缩放</span><br>    <span class="hljs-string">&#x27;RandXTranslation&#x27;</span>,[<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>],... <span class="hljs-comment">%随机水平位移</span><br>    <span class="hljs-string">&#x27;RandYTranslation&#x27;</span>,[<span class="hljs-number">-5</span>,<span class="hljs-number">5</span>]);   <span class="hljs-comment">%随机垂直位移</span><br>imageSize = [<span class="hljs-number">64</span> <span class="hljs-number">64</span> <span class="hljs-number">3</span>];<br>augimds = augmentedImageDatastore(imageSize,trainImages,...<br>                                  <span class="hljs-string">&#x27;DataAugmentation&#x27;</span>,imageAugmenter,...<br>                                  <span class="hljs-string">&#x27;ColorPreprocessing&#x27;</span>,<span class="hljs-string">&#x27;gray2rgb&#x27;</span>);<br>                                  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">im</span>=<span class="hljs-title">readFcn</span><span class="hljs-params">(filename)</span></span><br>    im=imread(filename);<br>    im=imresize(im,[<span class="hljs-number">64</span> <span class="hljs-number">64</span>]);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>(im,<span class="hljs-number">3</span>)==<span class="hljs-number">1</span>) <span class="hljs-comment">%如果是灰度图像，将其通道复制三份</span><br>        im=<span class="hljs-built_in">cat</span>(<span class="hljs-number">3</span>,im,im,im);<br>    <span class="hljs-keyword">end</span><br>    im=rescale(im);<br>    <span class="hljs-comment">% 归一化</span><br>    meanI = <span class="hljs-built_in">mean</span>(im(:));<br>    stdI = std(double(im(:)));<br>    im=(im - meanI) / stdI;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="训练过程">训练过程</h2><p>经过多次尝试，选择以下训练选项：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">options_init = trainingOptions(<span class="hljs-string">&#x27;sgdm&#x27;</span>, ... <span class="hljs-comment">% 随机梯度下降优化器</span><br>    <span class="hljs-string">&#x27;InitialLearnRate&#x27;</span>,<span class="hljs-number">0.01</span>, ...    <span class="hljs-comment">% 初始学习率</span><br>    <span class="hljs-string">&#x27;LearnRateSchedule&#x27;</span>,<span class="hljs-string">&#x27;piecewise&#x27;</span>, ...   <span class="hljs-comment">% 学习率按训练次数下降</span><br>    <span class="hljs-string">&#x27;LearnRateDropPeriod&#x27;</span>,<span class="hljs-number">5</span>, ...           <span class="hljs-comment">% 每5个epoch下降一次</span><br>    <span class="hljs-string">&#x27;LearnRateDropFactor&#x27;</span>,<span class="hljs-number">0.9</span>,...          <span class="hljs-comment">% 每次下降变成原来的0.9倍</span><br>    <span class="hljs-string">&#x27;MaxEpochs&#x27;</span>,<span class="hljs-number">60</span>, ...                    <span class="hljs-comment">% 训练60个epoch</span><br>    <span class="hljs-string">&#x27;Shuffle&#x27;</span>,<span class="hljs-string">&#x27;every-epoch&#x27;</span>, ...           <span class="hljs-comment">% 随机化</span><br>    <span class="hljs-string">&#x27;ValidationFrequency&#x27;</span>,<span class="hljs-number">30</span>, ...          <span class="hljs-comment">% 测试频率：30</span><br>    <span class="hljs-string">&#x27;Verbose&#x27;</span>,<span class="hljs-built_in">false</span>, ...                   <span class="hljs-comment">% 输出简略信息</span><br>    <span class="hljs-string">&#x27;Plots&#x27;</span>,<span class="hljs-string">&#x27;training-progress&#x27;</span>,...        <span class="hljs-comment">% 绘制图像</span><br>    <span class="hljs-string">&#x27;ValidationData&#x27;</span>,validationImages,...  <span class="hljs-comment">% 设置测试集</span><br>    <span class="hljs-string">&#x27;ExecutionEnvironment&#x27;</span>, <span class="hljs-string">&#x27;gpu&#x27;</span>,...      <span class="hljs-comment">% 使用gpu加速</span><br>    <span class="hljs-string">&#x27;ValidationPatience&#x27;</span>,<span class="hljs-number">5</span>,...             <span class="hljs-comment">% 连续5次测试，表现没改善就停止训练</span><br>    <span class="hljs-string">&#x27;L2Regularization&#x27;</span>, <span class="hljs-number">0.004</span>);            <span class="hljs-comment">% l2正则化</span><br></code></pre></td></tr></table></figure><p>用<code>trainNetwork</code>命令进行训练：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[net,info] = trainNetwork(augimds,layers,options_init);<br></code></pre></td></tr></table></figure><p>在两个模型上的训练曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412181459641.png" alt="在自定义CNN上训练的图像" /><figcaption aria-hidden="true">在自定义CNN上训练的图像</figcaption></figure><p>上图是在自定义CNN上训练的图像，因连续5次测试，测试结果未见明显改善而终止。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412181501470.png" alt="仿VGG网络" /><figcaption aria-hidden="true">仿VGG网络</figcaption></figure><p>观察曲线，可以发现在自定义CNN网络上拟合比较适中，最终是准确率是86.9%；在仿VGG网络上出现了轻度的过拟合现象，最终的准确率是91.6%，为了修正过拟合，采取过增大正则化系数，增强数据随机性等多种操作，但是最后仍然有轻度的过拟合现象。</p><h2 id="后续处理">后续处理</h2><p>为了进一步增加分类准确率，观察了一下模型在测试集上的混淆矩阵：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412181535354.svg" /></p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412181536389.svg" /></p><p>发现同一个模型结构，修改部分参数训练出的模型，它们所犯的错误是不太一样的。据此，通过调整数据增强方法、调整图像大小、调整图像通道数（灰度/彩色）、调整训练超参数、在图像上加不同的噪声，最终通过上面的两个架构训练出11个模型。在最终生成测试表格时，用这11个网络进行投票选择，按每个网络预测的前两名标签的置信概率加权投票，选出最终的预测标签。</p><p>相关代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 读取模型</span><br>num=<span class="hljs-number">11</span>; <span class="hljs-comment">%模型数量</span><br><br>models = cell(num, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:num<br>    models&#123;<span class="hljs-built_in">i</span>&#125; = load(sprintf(<span class="hljs-string">&#x27;net%d.mat&#x27;</span>, <span class="hljs-built_in">i</span>));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 加载测试集图像</span><br>testImagesGray = imageDatastore(<span class="hljs-string">&#x27;test&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;IncludeSubfolders&#x27;</span>,<span class="hljs-built_in">false</span>, ...<br>    <span class="hljs-string">&#x27;LabelSource&#x27;</span>,<span class="hljs-string">&#x27;none&#x27;</span>,...<br>    <span class="hljs-string">&#x27;ReadFcn&#x27;</span>,@readFcnGray);<br><br>testImagesRGB = imageDatastore(<span class="hljs-string">&#x27;test&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;IncludeSubfolders&#x27;</span>,<span class="hljs-built_in">false</span>, ...<br>    <span class="hljs-string">&#x27;LabelSource&#x27;</span>,<span class="hljs-string">&#x27;none&#x27;</span>,...<br>    <span class="hljs-string">&#x27;ReadFcn&#x27;</span>,@readFcn);<br><br><span class="hljs-comment">%% 预测测试集</span><br>predictions = cell(num, <span class="hljs-number">1</span>);<br>scores = cell(num,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">7</span><br>    [predictions&#123;<span class="hljs-built_in">i</span>&#125;,scores&#123;<span class="hljs-built_in">i</span>&#125;] = classify(models&#123;<span class="hljs-built_in">i</span>&#125;.net, testImagesGray);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">8</span>:<span class="hljs-number">11</span><br>    [predictions&#123;<span class="hljs-built_in">i</span>&#125;,scores&#123;<span class="hljs-built_in">i</span>&#125;] = classify(models&#123;<span class="hljs-built_in">i</span>&#125;.net, testImagesRGB);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%% 按权投票机制</span><br><br>finalPredictions = strings(<span class="hljs-built_in">numel</span>(testImagesRGB.Files), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(testImagesRGB.Files)<br>    weightedVotes = containers.Map(<span class="hljs-string">&#x27;KeyType&#x27;</span>, <span class="hljs-string">&#x27;char&#x27;</span>, <span class="hljs-string">&#x27;ValueType&#x27;</span>, <span class="hljs-string">&#x27;double&#x27;</span>);<br>    votes = categorical(<span class="hljs-built_in">cellfun</span>(@(x) char(x(<span class="hljs-built_in">j</span>)), predictions, <span class="hljs-string">&#x27;UniformOutput&#x27;</span>, <span class="hljs-built_in">false</span>)); <br>    flag=~all(votes(:) == votes(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> flag<br>        <span class="hljs-built_in">disp</span>(testImagesRGB.Files(<span class="hljs-built_in">j</span>));<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:num<br>        <span class="hljs-comment">% 获取前两个标签及其概率</span><br>        [sortedScores, sortedIdx] = <span class="hljs-built_in">sort</span>(scores&#123;<span class="hljs-built_in">i</span>&#125;(<span class="hljs-built_in">j</span>, :), <span class="hljs-string">&#x27;descend&#x27;</span>);<br>        categoriesLabels = categories(predictions&#123;<span class="hljs-built_in">i</span>&#125;);<br>        topLabels = categoriesLabels(sortedIdx(<span class="hljs-number">1</span>:<span class="hljs-number">2</span>));<br>        topProbs = sortedScores(<span class="hljs-number">1</span>:<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> flag<br>            <br>            <span class="hljs-built_in">disp</span>(topLabels);<br>            <span class="hljs-built_in">disp</span>(topProbs);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-comment">% 累加权重</span><br>        <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-number">2</span><br>            label = char(topLabels(k));<br>            prob = topProbs(k);<br>            <span class="hljs-keyword">if</span> isKey(weightedVotes, label)<br>                weightedVotes(label) = weightedVotes(label) + prob;<br>            <span class="hljs-keyword">else</span><br>                weightedVotes(label) = prob;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 找到权重最大的标签</span><br>    valuesArray = cell2mat(values(weightedVotes));<br>    [~, maxLabel] = <span class="hljs-built_in">max</span>(valuesArray);<br>    keysArray = keys(weightedVotes);<br>    finalPredictions(<span class="hljs-built_in">j</span>) = keysArray&#123;maxLabel&#125;;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%% 生成答案文件</span><br>submission = <span class="hljs-built_in">table</span>(testImagesRGB.Files, finalPredictions, <span class="hljs-string">&#x27;VariableNames&#x27;</span>, &#123;<span class="hljs-string">&#x27;filename&#x27;</span>, <span class="hljs-string">&#x27;category&#x27;</span>&#125;);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:height(submission)<br>    firstElement=string(submission&#123;<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>&#125;);<br>    firstElement=path2name(firstElement);<br>    submission&#123;<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>&#125;=cellstr(firstElement);<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">writetable</span>(submission, <span class="hljs-string">&#x27;submission.csv&#x27;</span>, <span class="hljs-string">&#x27;WriteVariableNames&#x27;</span>, <span class="hljs-built_in">true</span>);<br><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;答案文件已生成：submission.csv&#x27;</span>);<br><br><span class="hljs-comment">%% 调用函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">im</span>=<span class="hljs-title">readFcnGray</span><span class="hljs-params">(filename)</span></span><br>    im=imread(filename);<br>    im=imresize(im,[<span class="hljs-number">64</span> <span class="hljs-number">64</span>]);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>(im,<span class="hljs-number">3</span>)==<span class="hljs-number">3</span>)<br>        im=rgb2gray(im);<br>    <span class="hljs-keyword">end</span><br>    im=rescale(im);<br>    <span class="hljs-comment">% 计算整个数据集的均值和标准差</span><br>    meanI = <span class="hljs-built_in">mean</span>(im(:));<br>    stdI = std(double(im(:)));<br>    im=(im - meanI) / stdI;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">im</span>=<span class="hljs-title">readFcn</span><span class="hljs-params">(filename)</span></span><br>    im=imread(filename);<br>    im=imresize(im,[<span class="hljs-number">64</span> <span class="hljs-number">64</span>]);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>(im,<span class="hljs-number">3</span>)==<span class="hljs-number">1</span>)<br>        im=<span class="hljs-built_in">cat</span>(<span class="hljs-number">3</span>,im,im,im);<br>    <span class="hljs-keyword">end</span><br>    im=rescale(im);<br>    <span class="hljs-comment">% 计算整个数据集的均值和标准差</span><br>    meanI = <span class="hljs-built_in">mean</span>(im(:));<br>    stdI = std(double(im(:)));<br>    im=(im - meanI) / stdI;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str</span>=<span class="hljs-title">path2name</span><span class="hljs-params">(path)</span></span><br>    [folder, fileName, ext]=fileparts(path);<br>    str=strcat(fileName, ext);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412181618853.png" alt="image-20241218161817938" /><figcaption aria-hidden="true">image-20241218161817938</figcaption></figure><p>经过实际检验，投票方法确实可以提升准确率。其中编号为20-24的提交都是单个模型预测的结果，编号25、26的提交是7个模型投票的结果，编号27是11个模型投票的结果。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑箱优化与强化学习（EEee227c Lecture20学习笔记）</title>
    <link href="/2024/12/13/%E9%BB%91%E7%AE%B1%E4%BC%98%E5%8C%96%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/12/13/%E9%BB%91%E7%AE%B1%E4%BC%98%E5%8C%96%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>在本讲中，主要学习的是无导数优化，并从无导数优化自然过渡到强化学习。</p><p>本读书笔记阅读了<a href="https://ee227c.github.io/code/lecture20.html">相关资料</a>，并且使用 Matlab 语言独立实现了其中的实验。</p><p>Matlab 语言要求所有函数都定义在代码的最后，但是为了阅读顺畅，本文档修改了部分代码的顺序。如果需要运行代码，请<a href="https://docsdown.oss-cn-beijing.aliyuncs.com/s20.m">下载源代码文件</a>。</p><p>[toc]</p><h2 id="黑箱优化">黑箱优化</h2><p>在本讲中，我们将研究所谓的黑箱优化、无导数优化或零阶优化。</p><p>这里的一般目标是解决一个问题</p><p><span class="math display">\[\min_{x} f(x),\]</span></p><p>可能在约束集 <span class="math inline">\(x\in\Omega\)</span> 上，其中我们无法求函数 <span class="math inline">\(f\colon\mathbb{R}^n\to\mathbb{R}\)</span> 的梯度。我们只能对某个点 <span class="math inline">\(x\in\Omega\)</span> 并计算函数值 <span class="math inline">\(f(x)\in\mathbb{R}\)</span>。</p><h3 id="基本随机搜索">基本随机搜索</h3><p><strong>随机搜索</strong></p><p>选择一个初始点 <span class="math inline">\(x_0\)</span></p><p>从 <span class="math inline">\(t=1\)</span> 开始迭代： 1. 选择 <span class="math inline">\(d_t\)</span> 作为 <span class="math inline">\(\mathbb{R}^n\)</span> 中的一个随机方向。</p><ol start="2" type="1"><li><p>设置 <span class="math inline">\(\eta^* = \arg\min_\eta f(x_{t-1}+\eta d_t)\)</span></p></li><li><p>令 <span class="math inline">\(x_t = x_{t-1} + \eta^* d_t\)</span></p></li></ol><h4 id="分析">分析</h4><p>我们将看到，对于这个算法，基本上梯度下降的所有性质都成立，只是迭代次数多了一个因子 <span class="math inline">\(n\)</span>。假设 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\(\beta\)</span>-李普希兹的的可微凸函数。</p><p>对于任意 <span class="math inline">\(\eta\)</span>，根据泰勒展开和光滑性，有：</p><p><span class="math display">\[f(x_t + \eta d_t) \le f(x_t) + \eta \langle d_t, \nabla f(x_t) \rangle + \frac{\eta^2\beta}{2}\|d_t\|^2\]</span></p><p>因此，通过最小化上界，存在一个步长 <span class="math inline">\(\eta\)</span>，使得</p><p><span class="math display">\[f(x_t + \eta d_t) \le f(x_t) - \frac{1}{\beta}\langle d_t, \nabla f(x_t)\rangle^2 \|d_t\|^2\]</span></p><p>此外，我们实际采取的步长只会更好：</p><p><span class="math display">\[f(x_t + \eta^* d_t)  \le f(x_t + \eta d_t).\]</span></p><p>取期望后得到</p><p><span class="math display">\[\mathbb{E}[f(x_t + \eta^* d_t)]\le \mathbb{E}[f(x_t)] - \frac1{\beta n}\mathbb{E}[\|\nabla f(x_t)\|^2]\]</span></p><p>这看起来与梯度下降法非常相似，只是多了一个因子 <span class="math inline">\(n\)</span>。于是： - 对于凸函数，我们得到 <span class="math inline">\(n\beta/\epsilon\)</span> 的速率。 - 对于强凸函数，我们得到 <span class="math inline">\(n\beta\log(1/\epsilon)\)</span> 的速率。 - 对于非凸函数，我们收敛到一个驻点。</p><p>基本上，它比该函数类上的梯度方法的复杂度多了 <span class="math inline">\(n\)</span> 倍。</p><h4 id="线搜索问题">线搜索问题</h4><p>正如所述，该算法在随机方向上使用最优步长。我们通常只能通过各种方式近似这个步长。我们将讨论所谓的<strong>黄金分割搜索</strong>：</p><p>黄金分割搜索是一种在指定区间内寻找函数的极值（最小值或最大值）的技术。对于在区间内有极值的严格单峰函数，它将找到那个极值，而对于包含多个极值的区间（可能包括区间边界），它将收敛到其中一个极值。如果区间上唯一的极值在区间的边界上，它将收敛到那个边界点。该方法通过连续缩小指定区间内的值范围来操作，这使得它相对较慢，但非常稳健。这种技术的名字来源于算法保持了四个点的函数值，其三个区间宽度的比例为<span class="math inline">\(\varphi:1:\varphi\)</span>，其中<span class="math inline">\(\varphi\)</span>是黄金比例。这些比例在每次迭代中都保持最大效率。除边界点外，在搜索最小值时，中心点总是小于或等于外围点，以确保最小值包含在外围点之间。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132107960.png" alt="黄金分割搜索的示意图。初始的 $x$ 值三元组为 $\{x_1, x_2, x_3\}$。如果 $f(x_4) = f_{4a}$，则选择三元组 $\{x_1, x_2, x_4\}$ 进行下一次迭代。如果 $f(x_4) = f_{4b}$，则选择三元组 $\{x_2, x_4, x_3\}$。" style="zoom:50%;" /></p><p>这里的讨论是关于在单峰函数中寻找最小值。与求零点不同，求零点时，两个符号相反的函数值就可以确定一个根的范围，但是在寻找最小值时，就需要三个值。黄金分割搜索是一种逐步缩小包含最小值的区间的有效方法。关键在于，无论已经评估了多少个点，最小值都位于目前已经评估的最小值点相邻的两个点所确定的区间内。</p><p>上图说明了寻找最小值的方法中的一个步骤。纵轴是<span class="math inline">\(f(x)\)</span> 的函数值，横轴是 <span class="math inline">\(x\)</span> 参数。<span class="math inline">\(f(x)\)</span> 的值已经在三个点 <span class="math inline">\(x_1, x_2\)</span> 和 <span class="math inline">\(x_3\)</span> 处进行了求解。由于 <span class="math inline">\(f_2\)</span> 小于 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_3\)</span>，很明显最小值位于 <span class="math inline">\(x_1\)</span> 到 <span class="math inline">\(x_3\)</span> 的区间内。</p><p>最小化过程的下一步是通过在新的 <span class="math inline">\(x\)</span> 值 <span class="math inline">\(x_4\)</span> 处求函数值来“探测”函数。最有效的方法是选择 <span class="math inline">\(x_4\)</span> 位于最大的区间内，即 <span class="math inline">\(x_2\)</span> 和 <span class="math inline">\(x_3\)</span> 之间。从图中可以看出，如果函数在 <span class="math inline">\(x_4\)</span> 处的值 <span class="math inline">\(f_{4 a}&gt;f\left(x_2\right)\)</span>，那么最小值位于 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_4\)</span> 之间，新的三元组点将是 <span class="math inline">\(x_1, x_2\)</span> 和 <span class="math inline">\(x_4\)</span>。然而，如果函数在 <span class="math inline">\(x_4\)</span> 处的值 <span class="math inline">\(f_{4 b}&lt;f\left(x_2\right)\)</span>，那么最小值位于 <span class="math inline">\(x_2\)</span> 和 <span class="math inline">\(x_3\)</span> 之间，新的三元组点将是 <span class="math inline">\(x_2, x_4\)</span> 和 <span class="math inline">\(x_3\)</span>。因此，在任何情况下，我们都可以构造一个新的更窄的搜索区间，该区间保证包含函数的最小值。</p><p>从上图可以看出，新的搜索区间要么在 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_4\)</span> 之间，长度为 <span class="math inline">\(a+c\)</span>，要么在 <span class="math inline">\(x_2\)</span> 和 <span class="math inline">\(x_3\)</span> 之间，长度为 <span class="math inline">\(b\)</span>。黄金分割搜索要求这些区间相等。如果它们不相等，一连串的“坏运气”可能导致较宽的区间被多次使用，从而减慢收敛速度。为了确保 <span class="math inline">\(b=a+c\)</span>，算法应选择 <span class="math inline">\(x_4=x_1+\left(x_3-x_2\right)\)</span>。</p><p>然而，仍然存在 <span class="math inline">\(x_2\)</span> 相对于 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_3\)</span> 的位置问题。黄金分割搜索选择这些点之间的间距，使得这些点与随后的三元组 <span class="math inline">\(x_1, x_2, x_4\)</span> 或 <span class="math inline">\(x_2, x_4, x_3\)</span> 具有相同的间距比例。通过在整个算法中保持相同的间距比例，我们避免了 <span class="math inline">\(x_2\)</span> 非常接近 <span class="math inline">\(x_1\)</span> 或 <span class="math inline">\(x_3\)</span> 的情况，并保证在每一步中区间宽度按相同的常数比例缩小。</p><p>从数学上讲，为了确保在评估 <span class="math inline">\(f\left(x_4\right)\)</span> 后，间距与评估前的间距成比例，如果 <span class="math inline">\(f\left(x_4\right)\)</span> 是 <span class="math inline">\(f_{4 a}\)</span>，并且我们的新三元组点是 <span class="math inline">\(x_1, x_2\)</span> 和 <span class="math inline">\(x_4\)</span>，那么我们希望</p><p><span class="math display">\[\frac{c}{a}=\frac{a}{b} .\]</span></p><p>然而，如果 <span class="math inline">\(f\left(x_4\right)\)</span> 是 <span class="math inline">\(f_{4 b}\)</span>，并且我们的新三元组点是 <span class="math inline">\(x_2, x_4\)</span> 和 <span class="math inline">\(x_3\)</span>，那么我们希望</p><p><span class="math display">\[\frac{c}{b-c}=\frac{a}{b} .\]</span></p><p>从这两个同时方程中消去 <span class="math inline">\(c\)</span>，得到</p><p><span class="math display">\[\left(\frac{b}{a}\right)^2-\frac{b}{a}=1\]</span></p><p>或</p><p><span class="math display">\[\frac{b}{a}=\varphi\]</span></p><p>其中 <span class="math inline">\(\varphi\)</span> 是黄金比例：</p><p><span class="math display">\[\varphi=\frac{1+\sqrt{5}}{2}\]</span></p><p>评估点之间间距比例中黄金比例的出现，正是这个搜索算法得名的原因。</p><p>算法的代码实现如下： <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x_min</span> = <span class="hljs-title">gss</span><span class="hljs-params">(f, a, b, tol)</span></span><br>    <span class="hljs-comment">% 黄金分割搜索</span><br>    <span class="hljs-comment">% 求函数f在[a,b]之间的最小值</span><br>    <span class="hljs-comment">% f: 函数句柄，待求函数</span><br>    <span class="hljs-comment">% a: 实数，区间下界</span><br>    <span class="hljs-comment">% b: 实数，区间上界</span><br>    <span class="hljs-comment">% tol: 收敛容差</span><br>    <br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        tol = <span class="hljs-number">1e-5</span>; <br>    <span class="hljs-keyword">end</span><br>    <br>    gr = (<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    c = b - (b - a) / gr;<br>    d = a + (b - a) / gr;<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">abs</span>(c - d) &gt; tol<br>        <span class="hljs-keyword">if</span> f(c) &lt; f(d)<br>            b = d;<br>        <span class="hljs-keyword">else</span><br>            a = c;<br>        <span class="hljs-keyword">end</span><br>        c = b - (b - a) / gr;<br>        d = a + (b - a) / gr;<br>    <span class="hljs-keyword">end</span><br>    <br>    x_min = (b + a) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p><p>有了行搜索，我们就可以编写随机搜索算法的代码了。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterates</span> = <span class="hljs-title">random_search</span><span class="hljs-params">(oracle, init, num_steps, line_search)</span></span><br>    <span class="hljs-comment">% 实现随机搜索。</span><br>    <br>    <span class="hljs-comment">% oracle: 函数句柄，待求函数。</span><br>    <span class="hljs-comment">% init: 列向量，oracle 定义域中的点，迭代起始点。</span><br>    <span class="hljs-comment">% num_steps: 整数，迭代次数。</span><br>    <span class="hljs-comment">% line_search: 线搜索方法（默认为黄金分割搜索）。</span><br>    <br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        line_search = @gss;<br>    <span class="hljs-keyword">end</span><br>    <br>    iterates = [init];<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:num_steps<br>        d = <span class="hljs-built_in">randn</span>(<span class="hljs-built_in">size</span>(init)) .* <span class="hljs-number">100</span>;<br>        d = d / norm(d);<br>        x = iterates(:,<span class="hljs-keyword">end</span>);<br>        <span class="hljs-built_in">size</span>(x)<br>        eta = line_search(@(step) oracle(x + step * d), <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br>        iterates = [iterates, x + eta * d];<br>        <span class="hljs-built_in">size</span>(iterates)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在简单的最小二乘问题上检验一下方法的正确性：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span> = <span class="hljs-title">least_squares</span><span class="hljs-params">(x, A, b)</span></span><br>    <span class="hljs-comment">% 计算最小二乘误差。</span><br>    <br>    <span class="hljs-comment">% x: 列向量，自变量</span><br>    <span class="hljs-comment">% A: 矩阵</span><br>    <span class="hljs-comment">% b: 列向量</span><br>    <br>    error = <span class="hljs-number">0.5</span> * norm(A * x - b)^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = <span class="hljs-built_in">randn</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>b = <span class="hljs-built_in">randn</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);<br><br>xs = random_search(@(x)least_squares(x,A,b), b, <span class="hljs-number">1000</span>, @gss);<br><br><span class="hljs-comment">% 绘制误差图</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) least_squares(xs(:, <span class="hljs-built_in">i</span>),A,b), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br><span class="hljs-built_in">plot</span>(ys);<br>xlabel(<span class="hljs-string">&#x27;Iteration&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;Error&#x27;</span>);<br>title(<span class="hljs-string">&#x27;Error Plot&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132218443.svg" /></p><h2 id="nelder-mead法">Nelder-Mead法</h2><p>内尔德和米德提出了一种更复杂的随机搜索变体。在matlab中，可以直接调用<code>fminsearch</code>函数，其中的内核即为Nelder-Mead法。</p><p>让我们在一个常见的非凸测试函数上测试： <span class="math display">\[H(\boldsymbol{x})=(x_1^2+x_2-11)^2+(x_1+x_2^2-7)^2\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ans</span>=<span class="hljs-title">himmelblau</span><span class="hljs-params">(X)</span></span><br>    <span class="hljs-comment">% 非凸函数</span><br>    <span class="hljs-comment">% x: 列向量，自变量</span><br>    <span class="hljs-built_in">ans</span> = (X(<span class="hljs-number">1</span>).^<span class="hljs-number">2</span> + X(<span class="hljs-number">2</span>) - <span class="hljs-number">11</span>).^<span class="hljs-number">2</span> + (X(<span class="hljs-number">1</span>) + X(<span class="hljs-number">2</span>).^<span class="hljs-number">2</span> - <span class="hljs-number">7</span>).^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>可以画出这个函数的图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">points = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>);<br>[X, Y] = <span class="hljs-built_in">meshgrid</span>(points, points); <span class="hljs-comment">% 生成网格数据</span><br>Z = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(X));<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(X)<br>    vector_input=[X(<span class="hljs-built_in">i</span>);Y(<span class="hljs-built_in">i</span>)];<br>    Z(<span class="hljs-built_in">i</span>)=himmelblau(vector_input);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% 创建图形和轴</span><br>fig = <span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">800</span>, <span class="hljs-number">800</span>]); <span class="hljs-comment">% 设置图形窗口大小</span><br>ax = axes(<span class="hljs-string">&#x27;Parent&#x27;</span>, fig, <span class="hljs-string">&#x27;Projection&#x27;</span>, <span class="hljs-string">&#x27;orthographic&#x27;</span>); <br><br><span class="hljs-comment">% 绘制曲面图</span><br>surf(ax, X, Y, Z, <span class="hljs-string">&#x27;FaceColor&#x27;</span>, <span class="hljs-string">&#x27;interp&#x27;</span>, <span class="hljs-string">&#x27;EdgeColor&#x27;</span>, <span class="hljs-string">&#x27;none&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;X&#x27;</span>); <span class="hljs-comment">% X轴标签</span><br>ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>); <span class="hljs-comment">% Y轴标签</span><br>zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>); <span class="hljs-comment">% Z轴标签</span><br>title(<span class="hljs-string">&#x27;Himmelblau&#x27;&#x27;s Function&#x27;</span>); <span class="hljs-comment">% 图形标题</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132227120.svg" /></p><p>使用Nelder-Mead法求解最小值：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">options = optimset(<span class="hljs-string">&#x27;Display&#x27;</span>,<span class="hljs-string">&#x27;iter&#x27;</span>,<span class="hljs-string">&#x27;PlotFcns&#x27;</span>,@myplot);<br>x0 = [<span class="hljs-number">1</span>;<span class="hljs-number">1</span>];<br>fun = @himmelblau;<br>[x,fval,exitflag,output] = fminsearch(fun,x0,options)<br></code></pre></td></tr></table></figure><p>其中，<code>myplot</code>为适配<code>fminsearch</code>函数而写的自定义绘图函数，实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stop</span> = <span class="hljs-title">myplot</span><span class="hljs-params">(x,optimValues,state)</span></span><br>    stop = <span class="hljs-built_in">false</span>;<br>    <span class="hljs-keyword">persistent</span> points steps;<br>    <span class="hljs-keyword">switch</span> state<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;init&#x27;</span><br>              <span class="hljs-comment">% Setup for plots or dialog boxes</span><br>              <span class="hljs-built_in">hold</span> on<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;iter&#x27;</span><br>              <span class="hljs-comment">% Make updates to plots or dialog boxes as needed</span><br>              <span class="hljs-built_in">plot</span>(optimValues.iteration,optimValues.fval,<span class="hljs-string">&#x27;bx&#x27;</span>);<br>              points=[points,optimValues.fval];<br>              steps = [steps,optimValues.iteration];<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;done&#x27;</span><br>              <span class="hljs-comment">% Cleanup of plots, dialog boxes, or final plot</span><br>              <span class="hljs-built_in">plot</span>(steps,points);<br>              <span class="hljs-built_in">hold</span> off<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132223093.svg" alt="Nelder-Mead法" /><figcaption aria-hidden="true">Nelder-Mead法</figcaption></figure><p>随机搜索在这里的效果也不错：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">xs = random_search(@himmelblau,[<span class="hljs-number">1</span>;<span class="hljs-number">1</span>], <span class="hljs-number">50</span>);<br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) himmelblau(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br><span class="hljs-built_in">figure</span>;<br><span class="hljs-built_in">plot</span>(ys);<br>xlabel(<span class="hljs-string">&#x27;Iteration&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;Error&#x27;</span>);<br>title(<span class="hljs-string">&#x27;Error Plot&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132229204.svg" alt="随机搜索" /><figcaption aria-hidden="true">随机搜索</figcaption></figure><h2 id="强化学习">强化学习</h2><p>考虑一个抽象的动态系统模型</p><p><span class="math display">\[x_{t+1} = f(x_t, u_t, e_t)\,.\]</span></p><p>这里，<span class="math inline">\(x_t\)</span> 是系统的<strong>状态</strong>，<span class="math inline">\(u_t\)</span> 是控制动作，<span class="math inline">\(e_t\)</span> 是随机扰动。我们将假设 <span class="math inline">\(f\)</span> 是固定的但未知的。</p><p><strong>轨迹</strong>是由这个动态系统生成的状态和控制动作的序列。</p><p><span class="math display">\[\tau_t = (u_1,…,u_{t-1},x_0,…,x_t) \,.\]</span></p><p><strong>控制策略</strong>是一个函数 <span class="math inline">\(\pi\)</span>，它接受一个来自动态系统的轨迹并输出一个新的控制动作。注意，<span class="math inline">\(\pi\)</span> 只能访问之前的状态和控制动作。</p><h3 id="flappy-bird-动力系统">Flappy bird 动力系统</h3><p>想象我们有一只以恒定速度飞行的小鸟。它的垂直位置 <span class="math inline">\(h\)</span> 由重力和空气阻力控制。因此，总的向下力为 <span class="math inline">\(F = mg - kv\)</span>，其中 <span class="math inline">\(g\)</span> 是重力加速度，<span class="math inline">\(v\)</span> 是向下的速度，<span class="math inline">\(k\)</span> 是与速度相关的阻力系数。使用 <span class="math inline">\(F=ma\)</span>，这给出了一阶微分方程 <span class="math display">\[\frac{dv}{dt} = g - (k/m)v\]</span> 这只鸟可以选择加速向上飞。它试图避免撞到地面 <span class="math inline">\(h=0\)</span>，同时最小化向上的加速度。</p><p>据此，我们建立这个动力系统的数学模型：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[new_state]</span> = <span class="hljs-title">flappy_bird</span><span class="hljs-params">(state, action)</span></span><br>    <span class="hljs-comment">% Flappy bird 动态系统。</span><br>    <span class="hljs-comment">% 输入: </span><br>        <span class="hljs-comment">% state: 2维列向量，下降速度和高度</span><br>        <span class="hljs-comment">% action: 实数，向上加速度</span><br>    <span class="hljs-comment">% 返回: </span><br>        <span class="hljs-comment">% new_state: 列向量，新的下降速度和高度</span><br>        <br>    v = state(<span class="hljs-number">1</span>); <span class="hljs-comment">% 下降速度</span><br>    h = state(<span class="hljs-number">2</span>); <span class="hljs-comment">% 高度</span><br>    g = <span class="hljs-number">1</span>; <span class="hljs-comment">% 重力加速度</span><br>    k = <span class="hljs-number">0.01</span>; <span class="hljs-comment">% 阻力系数</span><br>    m = <span class="hljs-number">1</span>; <span class="hljs-comment">% 质量</span><br>    new_state = [v + g - (k/m)*v - action; h - v]; <span class="hljs-comment">% 计算新的速度和高度</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[states, actions]</span> = <span class="hljs-title">unroll</span><span class="hljs-params">(system, init_state,init_action, policy, num_steps)</span></span><br>    <span class="hljs-comment">% 展开动态系统。</span><br>    <span class="hljs-comment">% 输入: </span><br>        <span class="hljs-comment">% system: 函数句柄，动力系统</span><br>        <span class="hljs-comment">% init_state: 2维列向量，动力系统状态（速度和高度）</span><br>        <span class="hljs-comment">% init_action: 实数，动力系统状态（加速度）</span><br>        <span class="hljs-comment">% policy: 函数句柄，运动策略</span><br>        <span class="hljs-comment">% num_steps: 整数，模拟的长度</span><br>    <span class="hljs-comment">% 返回: </span><br>        <span class="hljs-comment">% states: 2行num_steps列矩阵，整个过程中的速度和高度</span><br>        <span class="hljs-comment">% actions: num_steps维行向量，整个过程中的加速度</span><br>        <br>    states = init_state; <span class="hljs-comment">% 初始化状态列表</span><br>    actions = init_action; <span class="hljs-comment">% 初始化动作列表</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:num_steps<br>        action = policy(states, actions); <span class="hljs-comment">% 根据策略函数确定动作</span><br>        actions = [actions, action]; <span class="hljs-comment">% 将动作添加到动作列表</span><br>        states = [states, system(states(:,<span class="hljs-keyword">end</span>), action)]; <span class="hljs-comment">% 更新状态</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span> = <span class="hljs-title">example_policy</span><span class="hljs-params">(states, actions)</span></span><br>    <span class="hljs-comment">% 每5步加速向上。</span><br>    <span class="hljs-comment">% 输入: </span><br>        <span class="hljs-comment">% states: 2行k列矩阵，迄今为止的速度和高度</span><br>        <span class="hljs-comment">% actions: k维行向量，迄今为止的加速度</span><br>    <span class="hljs-comment">% 返回: </span><br>        <span class="hljs-comment">% action: 实数，动作完成后的加速度</span><br>        <br>    v = states(<span class="hljs-number">1</span>,<span class="hljs-keyword">end</span>); <span class="hljs-comment">% 最后一个状态的速度</span><br>    h = states(<span class="hljs-number">2</span>,<span class="hljs-keyword">end</span>); <span class="hljs-comment">% 最后一个状态的高度</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">mod</span>(<span class="hljs-built_in">length</span>(states), <span class="hljs-number">5</span>) == <span class="hljs-number">0</span><br>        action = <span class="hljs-number">7</span>; <span class="hljs-comment">% 每5步执行一次向上加速</span><br>    <span class="hljs-keyword">else</span><br>        action = <span class="hljs-number">0</span>; <span class="hljs-comment">% 否则不加速</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>在这里，还建立了一个简单的策略，即每模拟5步加速向上一次。</p><p>进行仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 初始化Flappy Bird的初始状态和动作</span><br>init_action = <span class="hljs-number">0</span>;<br>init_state = [<span class="hljs-number">0</span>;<span class="hljs-number">10</span>];<br>num_steps = <span class="hljs-number">10</span>; <span class="hljs-comment">% 定义展开的步数</span><br><br><span class="hljs-comment">% 展开动态系统</span><br>[states, actions] = unroll(@flappy_bird, init_state,init_action, @example_policy, num_steps);<br><br><span class="hljs-comment">% 提取高度数据</span><br>heights = states(<span class="hljs-number">2</span>,:);<br><br><span class="hljs-comment">% 创建图形</span><br>fig = <span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">750</span>, <span class="hljs-number">500</span>]); <br>ax = axes(<span class="hljs-string">&#x27;Parent&#x27;</span>, fig);<br><br><span class="hljs-built_in">plot</span>(ax, <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(heights), heights, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br>ylabel(ax, <span class="hljs-string">&#x27;height&#x27;</span>);<br>xlabel(ax, <span class="hljs-string">&#x27;time&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132246095.svg" alt="仿真10步" /><figcaption aria-hidden="true">仿真10步</figcaption></figure><p>在短距离模拟时，它表现得好像不错。但是如果把时间放长，它就有些超过需要。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">num_steps = <span class="hljs-number">20</span>; <span class="hljs-comment">% 定义展开的步数</span><br><br>[states, actions] = unroll(@flappy_bird, init_state,init_action, @example_policy, num_steps);<br><br>heights = states(<span class="hljs-number">2</span>,:);<br><br>fig = <span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">750</span>, <span class="hljs-number">500</span>]); <br>ax = axes(<span class="hljs-string">&#x27;Parent&#x27;</span>, fig); <br><br><br><span class="hljs-comment">% 绘制高度随时间变化的折线图</span><br><span class="hljs-built_in">plot</span>(ax, <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(heights), heights, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br>ylabel(ax, <span class="hljs-string">&#x27;height&#x27;</span>);<br>xlabel(ax, <span class="hljs-string">&#x27;time&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132247298.svg" /></p><h3 id="从奖励中学习策略">从奖励中学习策略</h3><p>强化学习的主要目标是解决最优控制问题：</p><p><span class="math display">\[\begin{array}{ll}\mbox{maximize}_{u_t} &amp; \mathbb{E}_{e_t}[ \sum_{t=0}^N R_t[x_t,u_t] ]\\\mbox{subject to} &amp;    x_{t+1} = f(x_t, u_t, e_t)\\&amp; \mbox{($x_0$ given)}\end{array}\]</span></p><ul><li><span class="math inline">\(R_t[x_t,u_t]\)</span> 是一个<em>奖励</em>，我们假设它是已知的，事实上它是人为设定的。</li><li>函数 <span class="math inline">\(f\)</span> 是未知的。</li></ul><p>在我们的 Flappy Bird 示例中，撞到地面会获得一个巨大的负奖励，而向上加速会获得一个小的负奖励。</p><p>当代强化学习的主要范式是以下方法。我们决定一个策略 <span class="math inline">\(\pi\)</span> 和视野长度 <span class="math inline">\(L\)</span>。然后，我们要么将这个策略传递给模拟引擎，要么传递给真实的机器人系统，并获得一个轨迹</p><p><span class="math display">\[\tau_L = (u_1,…,u_{L-1},x_0,…,x_L)\,,\]</span></p><p>其中 <span class="math inline">\(u_t = \pi(\tau_t)\)</span>。这是我们的<em>预言模型</em>。我们通常希望最小化由预言模型计算的样本总数。因此，如果我们运行 <span class="math inline">\(m\)</span> 个视野长度为 <span class="math inline">\(L\)</span> 的查询，我们将支付总成本 <span class="math inline">\(mL\)</span>。然而，我们可以自由地为每个实验改变视野长度。</p><h3 id="策略梯度">策略梯度</h3><p>在策略梯度方法中，我们假设策略是随机的，并由一组可调参数 <span class="math inline">\(\theta\)</span> 指定。</p><p>然后，我们可以将奖励最大化问题写成一般形式的随机优化问题。令 <span class="math inline">\(p_\theta\)</span> 表示由参数 <span class="math inline">\(\theta\)</span> 产生的轨迹的概率分布。下面我们使用 <span class="math inline">\(\mathbb{E}_\theta\)</span> 表示从 <span class="math inline">\(p_\theta\)</span> 中抽取的轨迹的期望。</p><p><span class="math display">\[J(\theta):=\mathbb{E}_\theta[R(u)]\]</span></p><p>关键思想是使用以下技巧计算 <span class="math inline">\(J(\theta)\)</span> 的梯度。</p><p><span class="math display">\[\begin{align*}\nabla_{\theta} J(\theta) &amp;= \int R(u) \nabla_{\theta} p_\theta(u) \,\mathrm{d}u\\&amp;= \int R(u) \left(\frac{\nabla_{\theta} p_\theta(u)}{p_\theta(u)}\right) p_\theta(u) \,\mathrm{d}u\\&amp;= \int \left( R(u) \nabla_{\theta} \log p_\theta(u) \right) p_\theta(u)\,\mathrm{d}u   \\&amp;= \mathbb{E}_{\theta}\left[ R(u) \nabla_{\theta} \log p_\theta(u) \right]\,.\end{align*}\]</span></p><p>因此，以下是用于最大化参数化分布的奖励的通用算法：</p><p>选择一些初始猜测 <span class="math inline">\(\theta_0\)</span></p><p>对 <span class="math inline">\(t\ge 1\)</span> 迭代：</p><ul><li>从 <span class="math inline">\(p_{\theta_k}\)</span> 中独立同分布地采样 <span class="math inline">\(u_k\)</span>。</li><li>设置 <span class="math inline">\(\theta_{k+1} = \theta_k + \alpha_k R(u_k) \nabla_{\theta} \log p_{\theta_k}(u_k)\)</span>，其中 <span class="math inline">\(\alpha_k\)</span> 是某个步长。</li></ul><p>请注意，我们想要优化的奖励函数仅通过函数求值进行访问。我们不计算 <span class="math inline">\(R\)</span> 本身的梯度。</p><p>因此，这种方法可以视为类似于随机搜索或 Nelder-Mead 的零阶优化算法。</p><p>让我们来看看这些想法如何在Flappy Bird游戏上发挥作用。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reward</span> = <span class="hljs-title">flappy_reward</span><span class="hljs-params">(states, actions)</span></span><br>    <span class="hljs-comment">% Flappy bird游戏的奖励函数。</span><br>     <span class="hljs-comment">% 输入: </span><br>        <span class="hljs-comment">% states: 2行k列矩阵，迄今为止的速度和高度</span><br>        <span class="hljs-comment">% actions: k维行向量，迄今为止的加速度</span><br>    <span class="hljs-comment">% 返回: </span><br>        <span class="hljs-comment">% reward: 实数，奖励值</span><br>        <br>    reward = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(states, <span class="hljs-number">2</span>)<br>        state = states(:, <span class="hljs-built_in">i</span>);<br>        action = actions(<span class="hljs-built_in">i</span>);<br>        height = state(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> height &lt; <span class="hljs-number">0</span><br>            reward = reward + (<span class="hljs-number">10</span> * height<span class="hljs-number">-10</span>);<br>        <span class="hljs-keyword">end</span><br>        reward = reward - <span class="hljs-built_in">abs</span>(action);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span> = <span class="hljs-title">flappy_policy</span><span class="hljs-params">(theta, states, actions)</span></span><br>    <span class="hljs-comment">% 策略函数</span><br>    <span class="hljs-comment">% 输入: </span><br>        <span class="hljs-comment">% theta: 4维列向量，加权系数</span><br>        <span class="hljs-comment">% states: 2行k列矩阵，迄今为止的速度和高度</span><br>        <span class="hljs-comment">% actions: k维行向量，迄今为止的加速度（实际未使用）</span><br>    <span class="hljs-comment">% 输出: </span><br>        <span class="hljs-comment">% action: 实数，动作完成后的加速度</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">size</span>(states, <span class="hljs-number">2</span>) == <span class="hljs-number">1</span><br>        states = [states, states];<br>    <span class="hljs-keyword">end</span><br>    state_vector = states(:,<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>:<span class="hljs-keyword">end</span>); <span class="hljs-comment">% 取最后两个状态</span><br>    action = theta&#x27; * <span class="hljs-built_in">reshape</span>(state_vector, [], <span class="hljs-number">1</span>); <span class="hljs-comment">%用theta进行加权</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reward</span> = <span class="hljs-title">flappy_simulator</span><span class="hljs-params">(theta, num_steps)</span></span><br>    <span class="hljs-comment">% 计算给定步数的策略奖励。</span><br>    <span class="hljs-comment">% 输入: </span><br>        <span class="hljs-comment">% theta: 4维列向量，加权系数</span><br>        <span class="hljs-comment">% num_steps: 仿真长度</span><br>    <span class="hljs-comment">% 输出:</span><br>        <span class="hljs-comment">% reward: 本轮仿真获得的奖励值</span><br>    policy = @(sts, ats) flappy_policy(theta, sts, ats);<br>    init_action = <span class="hljs-number">0</span>;<br>    init_state = [<span class="hljs-number">0</span>;<span class="hljs-number">10</span>];<br>    [states, actions] = unroll(@flappy_bird, init_state,init_action, policy, num_steps);<br>    reward = flappy_reward(states, actions);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后定义优化的目标函数。注意「奖励值」是越大越好，但是我们的优化目标是求最小值，所以要加个负号：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reward</span>=<span class="hljs-title">objective</span><span class="hljs-params">(theta)</span></span><br>    reward=(<span class="hljs-number">-1.0</span>)*flappy_simulator(theta,<span class="hljs-number">20</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>进行仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">9</span><br>    <br>    xs = random_search(@objective, <span class="hljs-built_in">zeros</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), <span class="hljs-number">10</span>, @gss);<br>    <br>    <span class="hljs-comment">% 创建策略函数</span><br>    policy = @(states, actions) flappy_policy(xs(:,<span class="hljs-keyword">end</span>), states, actions);<br>    <br>    init_action = <span class="hljs-number">0</span>;<br>    init_state = [<span class="hljs-number">0</span>;<span class="hljs-number">10</span>];<br>    [states, actions] = unroll(@flappy_bird, init_state,init_action, policy, <span class="hljs-number">20</span>);<br>    <br>    heights = states(<span class="hljs-number">2</span>,:);<br><br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-built_in">i</span>);<br>    <span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(heights), heights, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br>    <br>    ylabel(<span class="hljs-string">&#x27;height&#x27;</span>);<br>    xlabel(<span class="hljs-string">&#x27;time&#x27;</span>);    <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>进行9次重复实验，结果如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132324082.svg" /></p><p>如果将迭代次数增加为500次，结果如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412132325095.svg" /></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投影梯度下降法（ee227c Lecture4 学习笔记）</title>
    <link href="/2024/12/12/%E6%8A%95%E5%BD%B1%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%EF%BC%88ee227c%20Lecture%204%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/"/>
    <url>/2024/12/12/%E6%8A%95%E5%BD%B1%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%EF%BC%88ee227c%20Lecture%204%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本读书笔记阅读了<a href="https://ee227c.github.io/code/lecture4.html#Projected-gradient-descent">相关资料</a>，并且使用 Matlab 语言独立实现了其中的实验。</p><p>Matlab 语言要求所有函数都定义在代码的最后，但是为了阅读顺畅，本文档修改了部分代码的顺序。如果需要运行代码，请<a href="https://docsdown.oss-cn-beijing.aliyuncs.com/s4.m">下载源代码文件</a>。</p><span id="more"></span><h2 id="投影梯度下降">投影梯度下降</h2><p>投影梯度下降（PGD）是一种解决带约束非线性优化问题的有力工具。它结合了梯度下降的直观性和投影操作的约束性，通过迭代地沿着负梯度方向更新解，并将更新后的解投影回可行域内，以确保解始终满足约束条件。</p><p>在无约束优化问题中，梯度下降法是一种常用的方法。然而，在实际应用中，许多问题都伴随着各种约束，如变量的界限、线性等式或不等式约束等。PGD通过在每一步中将梯度下降的结果投影回可行域，有效地处理这些约束。</p><p>PGD适用于目标函数<span class="math inline">\(f(x)\)</span> 可微且定义在凸集 <span class="math inline">\(\Omega\)</span> 上的问题。其基本步骤为：</p><ol type="1"><li>计算当前点的梯度：<span class="math inline">\(\nabla f(x)\)</span></li><li>沿着负梯度方向更新：<span class="math inline">\(x_{k+1}’=x_k-\alpha_k\nabla f(x_k)\)</span></li><li>将<span class="math inline">\(x&#39;\)</span>投影回可行域：<span class="math inline">\(x_{k+1}=P_{\Omega}(x&#39;_{k+1})\)</span></li></ol><p>PGD的基本函数形式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xs</span> = <span class="hljs-title">gradient_descent</span><span class="hljs-params">(init, steps, grad, proj)</span></span><br>    <span class="hljs-comment">% 投影梯度下降法</span><br>    <span class="hljs-comment">% 输入参数：</span><br>    <span class="hljs-comment">%   init：列向量，迭代起始点</span><br>    <span class="hljs-comment">%   step：标量列表：迭代每一步的步长</span><br>    <span class="hljs-comment">%   grad：函数句柄，梯度函数</span><br>    <span class="hljs-comment">%   proj：函数句柄，投影函数</span><br>    <span class="hljs-comment">% 输出参数：</span><br>    <span class="hljs-comment">%   xs：n行k列矩阵，其中n是init的维数，k是step的长度，每一列表示迭代的每一步</span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        proj = @(x) x; <span class="hljs-comment">% proj默认为x</span><br>    <span class="hljs-keyword">end</span><br>    xs = [init];<br>    <span class="hljs-keyword">for</span> step = steps<br>        k=proj(xs(:,<span class="hljs-keyword">end</span>) - step * grad(xs(:,<span class="hljs-keyword">end</span>)));<br>        xs = [xs, k];<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="热身优化二次型">热身：优化二次型</h2><p>对于函数： <span class="math display">\[f(\boldsymbol{x})=\frac{1}{2}\|\boldsymbol{x}\|^2\]</span> 其梯度为： <span class="math display">\[\nabla f(\boldsymbol{x})=\boldsymbol{x}\]</span> 有：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">quadratic</span><span class="hljs-params">(x)</span></span><br>    y = <span class="hljs-number">0.5</span> * (x&#x27; * x);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grad</span> = <span class="hljs-title">quadratic_gradient</span><span class="hljs-params">(x)</span></span><br>    grad = x;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>注意到函数是1-光滑和1-强凸的。这意味着算法可以使用恒定的步长1来保证收敛。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x0 = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">% 生成一个1x1000的随机数组，元素值来自标准正态分布</span><br>xs = gradient_descent(x0, [<span class="hljs-number">1.0</span>], @quadratic_gradient);<br><span class="hljs-built_in">disp</span>(all(xs(:,<span class="hljs-keyword">end</span>)==<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p>如果步长选取得有问题，那么会得到：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">steps = <span class="hljs-number">0.1</span> * <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">% 创建一个包含50个0.1的数组</span><br>xs = gradient_descent(x0, steps, @quadratic_gradient); <span class="hljs-comment">% 调用梯度下降函数</span><br><br><span class="hljs-comment">% 计算每个点的二次函数值</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) quadratic(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br><span class="hljs-comment">% 绘制误差曲线</span><br>Error_plot(ys, <span class="hljs-string">&#x27;log&#x27;</span>); <span class="hljs-comment">% 假设error_plot函数已经在工作空间中定义</span><br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412112334267.png" alt="基本二次型" /><figcaption aria-hidden="true">基本二次型</figcaption></figure><h2 id="约束优化问题">约束优化问题</h2><p>如果我们把优化问题限制在一个仿射子空间中。注意到，仿射子空间是一个凸集，我们随机选取一个仿射子空间<span class="math inline">\(U+b\)</span>，并且定义投影函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">U = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">100</span>); <br>[U, R] = qr(U); <span class="hljs-comment">% 计算QR分解，取Q矩阵，如此一来，U就是一个100维空间的正交基</span><br>b = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>); <br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x_proj</span> = <span class="hljs-title">proj1</span><span class="hljs-params">(x,U,b)</span></span><br>    x_proj = b + U * (U&#x27; * (x-b));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>即： <span class="math display">\[P_{\Omega}(\boldsymbol{x})=UU^T(\boldsymbol{x-b})+\boldsymbol{b}\]</span> 进行优化仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x0 = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>);<br>steps = <span class="hljs-number">0.1</span> * <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>);<br>xs = gradient_descent(x0, steps, @quadratic_gradient, @(x)proj1(x,U,b)); <span class="hljs-comment">% 调用梯度下降函数</span><br><br>x_opt = proj1(<span class="hljs-number">0</span>,U,b); <span class="hljs-comment">%最优解：0的投影</span><br><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) quadratic(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys, <span class="hljs-string">&#x27;linear&#x27;</span>);<br><br><span class="hljs-built_in">hold</span> on;<br><br><span class="hljs-comment">% 绘制最优解的误差曲线</span><br>quadratic_opt = quadratic(x_opt) .* <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>(xs,<span class="hljs-number">2</span>));<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs,<span class="hljs-number">2</span>), quadratic_opt, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">% 绘制红色线</span><br>h = <span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;误差&#x27;</span>,<span class="hljs-string">&#x27;$$\frac&#123;1&#125;&#123;2&#125;||x_&#123;opt&#125;||^2$$&#x27;</span>); <span class="hljs-comment">% 添加图例</span><br>set(h,<span class="hljs-string">&#x27;Interpreter&#x27;</span>,<span class="hljs-string">&#x27;latex&#x27;</span>);<br><span class="hljs-built_in">hold</span> off;<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412112343515.png" alt="仿射空间约束优化" /><figcaption aria-hidden="true">仿射空间约束优化</figcaption></figure><p>可以看到，算法在30步内就收敛到了很低的水平。我们还可以画一下迭代到的各点同最优解的距离，即<span class="math inline">\(k-\|x_k-x_{opt}\|^2\)</span>图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ys = arrayfun(@(<span class="hljs-built_in">i</span>) norm(xs(:, <span class="hljs-built_in">i</span>)-x_opt)^<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys, <span class="hljs-string">&#x27;log&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412112350319.png" /></p><p>我们称之为「领域收敛」。</p><h2 id="最小二乘法">最小二乘法</h2><p>线性最小二乘法是数据分析中的重要工具，其目标是找到一个向量<span class="math inline">\(\boldsymbol{x}\)</span>，使得<span class="math inline">\(A\boldsymbol{x}-\boldsymbol{b}\)</span>的平方误差之和最小。问题的目标函数为： <span class="math display">\[f(\boldsymbol{x})=\frac 1{2m}\|A\boldsymbol{x}-\boldsymbol{b}\|^2\]</span> 它的梯度是： <span class="math display">\[\nabla f(\boldsymbol{x})=A^{T}(A\boldsymbol{x}-\boldsymbol{b})\]</span> 海森矩阵为： <span class="math display">\[\nabla^2f(\boldsymbol{x})=A^TA\]</span> 这个问题是<span class="math inline">\(\beta-\)</span>李普希兹的和<span class="math inline">\(\alpha-\)</span>强凸的，其中： <span class="math display">\[\beta=\lambda_\max(A^TA),\alpha=\lambda_{\min}(A^TA)\]</span> 定义目标函数和梯度：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">least_squares</span><span class="hljs-params">(A, b, x)</span></span><br>    m=<span class="hljs-built_in">size</span>(A,<span class="hljs-number">1</span>);<br>    y=(<span class="hljs-number">0.5</span>/m)*norm(A*x-b)^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grad</span> = <span class="hljs-title">least_squares_gradient</span><span class="hljs-params">(A, b, x)</span></span><br>    m = <span class="hljs-built_in">size</span>(A,<span class="hljs-number">1</span>);<br>    grad = A&#x27; * (A*x-b)/m;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="过定问题mn">过定问题：<span class="math inline">\(m&gt;n\)</span></h3><p>在这种情况下，最小二乘问题通常是有解的，而且目标函数是强凸的。为了仿真方便，我们先生成最优解，然后再用最优解加一个噪声反向生成问题中的<span class="math inline">\(b\)</span>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义基本变量</span><br>m = <span class="hljs-number">1000</span>;<br>n = <span class="hljs-number">100</span>;<br><br>A = <span class="hljs-built_in">randn</span>(m,n);<br>x_opt = <span class="hljs-built_in">randn</span>(n,<span class="hljs-number">1</span>);<br>noise = <span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>) * <span class="hljs-number">0.1</span>;<br>b = A * x_opt + noise;<br><br><span class="hljs-comment">% 定义目标函数和梯度函数</span><br>objective = @(x) least_squares(A, b, x);<br>gradient = @(x) least_squares_gradient(A, b, x);<br></code></pre></td></tr></table></figure><p>进行仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 进行仿真</span><br>x0 = <span class="hljs-built_in">randn</span>(n,<span class="hljs-number">1</span>);<br>steps = <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)*<span class="hljs-number">0.1</span>;<br>xs = gradient_descent(x0, steps, gradient);<br><br><span class="hljs-comment">% 绘制迭代点的误差曲线</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) objective(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys, <span class="hljs-string">&#x27;log&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br><br><span class="hljs-comment">% 绘制噪声直线</span><br>noise_level = norm(noise)^<span class="hljs-number">2</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps), noise_level,<span class="hljs-string">&#x27;r&#x27;</span>);<br><br><span class="hljs-comment">% 绘制最优解的误差直线</span><br>optimal_level = objective(x_opt)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps), optimal_level,<span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;noise level&#x27;</span>, <span class="hljs-string">&#x27;optimal&#x27;</span>);<br><span class="hljs-built_in">hold</span> off;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412112359189.png" alt="最小二乘-过定问题" /><figcaption aria-hidden="true">最小二乘-过定问题</figcaption></figure><p>我们还可以画一下迭代到的各点同最优解的距离，即<span class="math inline">\(k-\|x_k-x_{opt}\|^2\)</span>图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 绘制迭代点趋近于最优解的过程</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) norm(xs(:, <span class="hljs-built_in">i</span>)-x_opt)^<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys, <span class="hljs-string">&#x27;log&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120010278.png" alt="最小二乘-过定问题" /><figcaption aria-hidden="true">最小二乘-过定问题</figcaption></figure><h3 id="欠定问题mn">欠定问题：<span class="math inline">\(m&lt;n\)</span></h3><p>在欠定时，目标函数可能不是强凸的，因为<span class="math inline">\(A^TA\)</span>不是满秩矩阵，而且<span class="math inline">\(\lambda_\min(A^TA)=0\)</span>。</p><p>运行仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义基本变量</span><br>m = <span class="hljs-number">100</span>;<br>n = <span class="hljs-number">1000</span>;<br>A = <span class="hljs-built_in">randn</span>(m,n);<br>b = <span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>);<br>x_opt = pinv(A)*b;<br><br><span class="hljs-comment">% 定义目标函数和梯度函数</span><br>objective = @(x) least_squares(A, b, x);<br>gradient = @(x) least_squares_gradient(A, b, x);<br><br><span class="hljs-comment">% 进行仿真</span><br>x0 = <span class="hljs-built_in">randn</span>(n,<span class="hljs-number">1</span>);<br>steps = <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>) * <span class="hljs-number">0.1</span>;<br>xs = gradient_descent(x0, steps, gradient);<br><br><span class="hljs-comment">% 绘制迭代点的误差曲线</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) objective(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys,<span class="hljs-string">&#x27;log&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br><br><span class="hljs-comment">% 绘制最优解的误差直线</span><br>optimal_level=objective(x_opt)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps),optimal_level,<span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;optimal&#x27;</span>);<br><span class="hljs-built_in">hold</span> off;<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120015771.png" alt="最小二乘：欠定问题" /><figcaption aria-hidden="true">最小二乘：欠定问题</figcaption></figure><p>可以看到，算法并没有收敛到最优解。我们还可以画一下迭代到的各点同最优解的距离，即<span class="math inline">\(k-\|x_k-x_{opt}\|^2\)</span>图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 绘制迭代点趋近于最优解的过程</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) norm(xs(:, <span class="hljs-built_in">i</span>)-x_opt)^<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys,<span class="hljs-string">&#x27;linear&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>optimal_norm=norm(x_opt)^<span class="hljs-number">2</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps),optimal_norm,<span class="hljs-string">&#x27;r&#x27;</span>);<br>h=<span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-string">&#x27;$$||x_&#123;opt&#125;||^2$$&#x27;</span>);<br>set(h,<span class="hljs-string">&#x27;Interpreter&#x27;</span>,<span class="hljs-string">&#x27;latex&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120016377.png" alt="最小二乘：欠定问题" /><figcaption aria-hidden="true">最小二乘：欠定问题</figcaption></figure><h2 id="l_2-正规化"><span class="math inline">\(l_2-\)</span>正规化</h2><p>在之前讨论的欠定问题中，可以试图通过添加<span class="math inline">\(l_2-\)</span>罚函数来恢复问题的强凸性。</p><p>此时的目标函数变为： <span class="math display">\[f(\boldsymbol{x})=\frac 1{2m}\|A\boldsymbol{x}-\boldsymbol{b}\|+\frac \alpha 2\|\boldsymbol{x}\|^2\]</span> 这样一来，函数就是<span class="math inline">\(\alpha-\)</span>强凸的了。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obj</span> = <span class="hljs-title">least_squares_l2</span><span class="hljs-params">(A, b, x, alpha)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        alpha = <span class="hljs-number">0.1</span>; <span class="hljs-comment">% 如果没有提供alpha，默认为0.1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% 最小二乘L2正则化目标函数</span><br>    obj = least_squares(A, b, x) + (alpha/<span class="hljs-number">2</span>) * x&#x27; * x;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grad</span> = <span class="hljs-title">least_squares_l2_gradient</span><span class="hljs-params">(A, b, x, alpha)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        alpha = <span class="hljs-number">0.1</span>; <span class="hljs-comment">% 如果没有提供alpha，默认为0.1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% 最小二乘L2正则化目标函数的梯度</span><br>    grad = least_squares_gradient(A, b, x) + alpha * x;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>运行仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义基本变量</span><br>m = <span class="hljs-number">100</span>;<br>n = <span class="hljs-number">1000</span>;<br>A = <span class="hljs-built_in">randn</span>(m,n);<br>b = A*<span class="hljs-built_in">randn</span>(n,<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 定义目标函数和梯度函数</span><br>objective = @(x) least_squares_l2(A, b, x);<br>gradient = @(x) least_squares_l2_gradient(A, b, x);<br><br><span class="hljs-comment">% 理论计算最优解</span><br>x_opt = inv(A&#x27; * A + <span class="hljs-number">0.1</span> * <span class="hljs-built_in">eye</span>(<span class="hljs-number">1000</span>)) * A&#x27; * b; <span class="hljs-comment">% eye(n)表示n阶单位阵</span><br><br><span class="hljs-comment">% 进行仿真</span><br>x0 = <span class="hljs-built_in">randn</span>(n,<span class="hljs-number">1</span>);<br>steps = <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>) * <span class="hljs-number">0.1</span>;<br>xs = gradient_descent(x0, steps, gradient);<br><br><span class="hljs-comment">% 绘制迭代点的误差曲线</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) objective(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys,<span class="hljs-string">&#x27;log&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br><br><span class="hljs-comment">% 绘制最优解的误差直线</span><br>optimal_level = objective(x_opt)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps), optimal_level,<span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;optimal&#x27;</span>);<br><span class="hljs-built_in">hold</span> off;<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120040250.png" alt="l2-正规化" /><figcaption aria-hidden="true">l2-正规化</figcaption></figure><p>由于正规化项的存在，函数并没有收敛到<span class="math inline">\(0\)</span>，但是这是正常的，至少它收敛了。事实上，正则化项具有很强的凸性，这将再次导致领域收敛：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 绘制迭代点趋近于最优解的过程</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) norm(xs(:, <span class="hljs-built_in">i</span>)-x_opt)^<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys,<span class="hljs-string">&#x27;log&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>optimal_norm=norm(x_opt)^<span class="hljs-number">2</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps),optimal_norm,<span class="hljs-string">&#x27;r&#x27;</span>);<br>h=<span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-string">&#x27;$$||x_&#123;opt&#125;||^2$$&#x27;</span>);<br>set(h,<span class="hljs-string">&#x27;Interpreter&#x27;</span>,<span class="hljs-string">&#x27;latex&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120042440.png" alt="l2-正规化" /><figcaption aria-hidden="true">l2-正规化</figcaption></figure><h2 id="隐式正则化的魔力">隐式正则化的魔力</h2><p>有时，只需从一个合适的初始点开始梯度下降，本身就会产生正则化效果，而无需引入明确的正则化项。 我们将在下文中看到这一点，我们将重温非正则化最小二乘法目标，但从原点而非随机高斯点开始梯度下降。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义起始点</span><br>x0 = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 定义梯度函数</span><br>gradient = @(x) least_squares_gradient(A, b, x);<br><br><span class="hljs-comment">% 运行仿真</span><br>steps = <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>)*<span class="hljs-number">0.1</span>;<br>xs = gradient_descent(x0,steps,gradient);<br><br><span class="hljs-comment">% 绘制迭代点的误差曲线</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) norm(xs(:, <span class="hljs-built_in">i</span>)-x_opt)^<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys,<span class="hljs-string">&#x27;linear&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br><br><span class="hljs-comment">% 绘制最优解的误差直线</span><br>optimal_norm=norm(x_opt)^<span class="hljs-number">2</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(steps),optimal_norm,<span class="hljs-string">&#x27;r&#x27;</span>);<br>h=<span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-string">&#x27;$$||x_&#123;opt&#125;||^2$$&#x27;</span>);<br>set(h,<span class="hljs-string">&#x27;Interpreter&#x27;</span>,<span class="hljs-string">&#x27;latex&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120045839.png" alt="隐式正则化" /><figcaption aria-hidden="true">隐式正则化</figcaption></figure><h2 id="lasso">LASSO</h2><p>回到之前的欠定问题。LASSO是<span class="math inline">\(l_1-\)</span>正则化最小二乘线性回归的名称。其目标函数为： <span class="math display">\[f(\boldsymbol{x})=\frac 1{2m}\|A\boldsymbol{x}-\boldsymbol{b}\|+\alpha \|\boldsymbol{x}\|_1\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obj</span> = <span class="hljs-title">lasso</span><span class="hljs-params">(A, b, x, alpha)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        alpha = <span class="hljs-number">0.1</span>; <span class="hljs-comment">% 如果没有提供alpha，默认为0.1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% Lasso目标函数</span><br>    obj = least_squares(A, b, x) + alpha * norm(x, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span> = <span class="hljs-title">ell1_subgradient</span><span class="hljs-params">(x)</span></span><br>    <span class="hljs-comment">% 计算L1范数的次梯度</span><br>    g = <span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(x));<br>    g(x &lt; <span class="hljs-number">0</span>) = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subgrad</span> = <span class="hljs-title">lasso_subgradient</span><span class="hljs-params">(A, b, x, alpha)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        alpha = <span class="hljs-number">0.1</span>; <span class="hljs-comment">% 如果没有提供alpha，默认为0.1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% Lasso目标函数的次梯度</span><br>    subgrad = least_squares_gradient(A, b, x) + alpha * ell1_subgradient(x);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>如果存在稀疏解，LASSO能够对其细化，这也是使用LASSO的重要原因之一。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义基本变量</span><br>m = <span class="hljs-number">100</span>;<br>n = <span class="hljs-number">1000</span>;<br>A = <span class="hljs-built_in">randn</span>(m,n);<br>x_opt=<span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);<br>x_opt(<span class="hljs-number">1</span>:<span class="hljs-number">10</span>)=<span class="hljs-number">1</span>; <span class="hljs-comment">% 定义稀疏解</span><br>b = A * x_opt;<br><br><span class="hljs-comment">% 定义目标函数和梯度函数</span><br>objective = @(x) lasso(A, b, x);<br>gradient =@(x) lasso_subgradient(A, b, x);<br><br><span class="hljs-comment">% 进行仿真</span><br>x0 = <span class="hljs-built_in">randn</span>(n, <span class="hljs-number">1</span>);<br>steps = <span class="hljs-number">0.1</span> * <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>, <span class="hljs-number">500</span>); <br>xs = gradient_descent(x0, steps, gradient); <br><br><span class="hljs-comment">% 绘制迭代点的误差曲线</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) objective(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br>Error_plot(ys,<span class="hljs-string">&#x27;log&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120051635.png" alt="LASSO" /><figcaption aria-hidden="true">LASSO</figcaption></figure><p>初始点、最佳点和计算点的比较：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 初始点、最佳点和计算点的比较</span><br>idxs = <span class="hljs-number">1</span>:<span class="hljs-number">100</span>; <span class="hljs-comment">% 画前100个点</span><br><span class="hljs-built_in">figure</span>;<br><span class="hljs-built_in">plot</span>(idxs, x0(idxs), <span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-string">&#x27;Color&#x27;</span>, [<span class="hljs-number">0.6667</span> <span class="hljs-number">0.6667</span> <span class="hljs-number">0.6667</span>], <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, <span class="hljs-string">&#x27;initial&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">plot</span>(idxs, x_opt(idxs), <span class="hljs-string">&#x27;r-&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, <span class="hljs-string">&#x27;optimal&#x27;</span>);<br><span class="hljs-built_in">plot</span>(idxs, xs(<span class="hljs-keyword">end</span>, idxs), <span class="hljs-string">&#x27;g-&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, <span class="hljs-string">&#x27;final&#x27;</span>); <br>xlabel(<span class="hljs-string">&#x27;Coordinate&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;Value&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120052588.png" /></p><p>正如所承诺的那样，LASSO 能正确识别最优解的重要坐标。 因此，在实际应用中，LASSO 是一种常用的特征选择工具</p><h2 id="支持向量机">支持向量机</h2><p>在线性分类问题中，我们给出了 <span class="math inline">\(m\)</span> 个标记点 <span class="math inline">\((a_i, y_i)\)</span>，我们希望找到一个由点 <span class="math inline">\(x\)</span> 定义的超平面，将它们分开，使得：</p><ul><li>当 <span class="math inline">\(y_i=1\)</span> 时，<span class="math inline">\(\langle a_i, x\rangle \ge 1\)</span>；</li><li>当 <span class="math inline">\(y_i = -1\)</span> 时，<span class="math inline">\(\langle a_i, x\rangle \le -1\)</span>。</li></ul><p>范数 <span class="math inline">\(|x|\)</span> 越小，正负实例之间的间隔就越大。因此，引入一个惩罚大范数的正则化项是有意义的。这导致了目标函数的产生。 <span class="math display">\[\frac 1m \sum_{i=1}^m \max\{1-y_i(a_i^\top x), 0\} + \frac{\alpha}2\|x\|^2\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loss</span> = <span class="hljs-title">hinge_loss</span><span class="hljs-params">(z)</span></span><br>    <span class="hljs-comment">% 返回hinge损失</span><br>    loss = <span class="hljs-built_in">max</span>(<span class="hljs-number">1.</span>-z, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obj</span> = <span class="hljs-title">svm_objective</span><span class="hljs-params">(A, y, x, alpha)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        alpha = <span class="hljs-number">0.1</span>; <span class="hljs-comment">% 如果没有提供alpha，默认为0.1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% SVM目标函数</span><br>    m = <span class="hljs-built_in">size</span>(A, <span class="hljs-number">1</span>); <span class="hljs-comment">% 获取样本数量m</span><br>    obj = <span class="hljs-built_in">mean</span>(hinge_loss(<span class="hljs-built_in">diag</span>(y) * (A * x))) + (alpha/<span class="hljs-number">2</span>) * x&#x27; * x;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>绘制hinge_loss图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">z = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">480</span>, <span class="hljs-number">400</span>]); <span class="hljs-comment">% 12x10 inches</span><br><span class="hljs-built_in">plot</span>(z, hinge_loss(z), <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>); <br>xlabel(<span class="hljs-string">&#x27;z&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;Hinge Loss&#x27;</span>);<br>title(<span class="hljs-string">&#x27;Hinge Loss Function&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120056625.png" alt="SVM" /><figcaption aria-hidden="true">SVM</figcaption></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span> = <span class="hljs-title">hinge_subgradient</span><span class="hljs-params">(z)</span></span><br>    <span class="hljs-comment">% 计算hinge损失的次梯度</span><br>    g = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(z));<br>    g(z &lt; <span class="hljs-number">1</span>) = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subgrad</span> = <span class="hljs-title">svm_subgradient</span><span class="hljs-params">(A, y, x, alpha)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">4</span><br>        alpha = <span class="hljs-number">0.1</span>; <span class="hljs-comment">% 如果没有提供alpha，默认为0.1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% 计算SVM目标函数的次梯度</span><br>    g1 = hinge_subgradient(<span class="hljs-built_in">diag</span>(y) * (A * x));<br>    g2 = <span class="hljs-built_in">diag</span>(y) * A;<br>    subgrad = (g1&#x27; * g2)&#x27; + alpha * x;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>绘制次梯度：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">z = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">480</span>, <span class="hljs-number">400</span>]);<br><span class="hljs-built_in">plot</span>(z, hinge_subgradient(z), <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>); <br><br>xlabel(<span class="hljs-string">&#x27;z&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;Hinge Subgradient&#x27;</span>);<br>title(<span class="hljs-string">&#x27;Hinge Subgradient Function&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120057764.png" /></p><p>进行SVM仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义基本变量</span><br>m = <span class="hljs-number">1000</span>;<br>n = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">% 生成m*n的矩阵A，其中前m/2行来自均值为0.1，标准差为1的正态分布，</span><br>    <span class="hljs-comment">% 后m/2行来自均值为-0.1，标准差为1的正态分布</span><br>A = [<span class="hljs-built_in">randn</span>(m/<span class="hljs-number">2</span>, n)*<span class="hljs-number">0.1</span>+<span class="hljs-built_in">randn</span>(m/<span class="hljs-number">2</span>, n); <span class="hljs-number">-0.1</span>*<span class="hljs-built_in">randn</span>(m/<span class="hljs-number">2</span>, n)+<span class="hljs-built_in">randn</span>(m/<span class="hljs-number">2</span>, n)];<br>    <span class="hljs-comment">% 生成m维向量y，前m/2个元素为1，后m/2个元素为-1</span><br>y = [<span class="hljs-built_in">ones</span>(m/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>); <span class="hljs-number">-1</span>*<span class="hljs-built_in">ones</span>(m/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)];<br>    <span class="hljs-comment">% 定义初始点x0</span><br>x0 = <span class="hljs-built_in">randn</span>(n, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 定义目标函数和梯度函数</span><br>objective = @(x) svm_objective(A, y, x, <span class="hljs-number">0.05</span>);<br>gradient = @(x) svm_subgradient(A, y, x, <span class="hljs-number">0.05</span>);<br><br><span class="hljs-comment">% 执行梯度下降</span><br>steps = <span class="hljs-number">0.01</span> * <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>xs = gradient_descent(x0, steps, gradient); <br><br><span class="hljs-comment">% 计算SVM目标函数值的误差曲线</span><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) objective(xs(:, <span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">% 绘制误差曲线</span><br>Error_plot(ys, <span class="hljs-string">&#x27;linear&#x27;</span>); <br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120059415.png" /></p><p>让我们看看求解的平均值是否能带来更好的函数值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">xavg=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs,<span class="hljs-number">2</span>)<br>    xavg = xavg+xs(:,<span class="hljs-built_in">i</span>);<br><span class="hljs-keyword">end</span><br>xavg = xavg / <span class="hljs-built_in">size</span>(xs,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&quot;Let&#x27;s see if averaging out the solutions gives us an improved function value.&quot;</span>);<br><span class="hljs-built_in">disp</span>(objective(xs(:,<span class="hljs-keyword">end</span>)));<br><span class="hljs-built_in">disp</span>(objective(xavg));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">Let<span class="hljs-symbol">&#x27;s</span> see <span class="hljs-keyword">if</span> averaging <span class="hljs-keyword">out</span> the solutions gives us an improved <span class="hljs-keyword">function</span> <span class="hljs-title">value.</span><br>    1.8370<br><br>    1.0100<br></code></pre></td></tr></table></figure><p>我们还可以看看线性模型预测标签的准确率。 从我们定义数据的方式可以看出，在无限数据（<span class="math inline">\(m\)</span>非常大）的情况下，全一向量是准确率最高的分类器。 对于有限数据集，由于随机波动，准确率可能会更高。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">acc</span> = <span class="hljs-title">accuracy</span><span class="hljs-params">(A, y, x)</span></span><br>    <span class="hljs-comment">% 计算准确率</span><br>    acc = <span class="hljs-built_in">mean</span>(<span class="hljs-built_in">diag</span>(y) * (A * x) &gt; <span class="hljs-number">0</span>);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">480</span>, <span class="hljs-number">400</span>]); <span class="hljs-comment">% 12x10 inches</span><br><br>ylabel(<span class="hljs-string">&#x27;Accuracy&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;Step&#x27;</span>);<br><br><span class="hljs-comment">% 绘制准确率曲线</span><br><span class="hljs-built_in">hold</span> on; <br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(xs), arrayfun(@(<span class="hljs-built_in">i</span>) accuracy(A, y, xs(:,<span class="hljs-built_in">i</span>)), <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs,<span class="hljs-number">2</span>)), <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% 绘制总体最优解的准确率曲线</span><br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(xs), arrayfun(@(<span class="hljs-built_in">i</span>) accuracy(A, y, <span class="hljs-built_in">ones</span>(n, <span class="hljs-number">1</span>)),<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(xs,<span class="hljs-number">2</span>)), <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, <span class="hljs-string">&#x27;Population optimum&#x27;</span>);<br><br><span class="hljs-comment">% 添加图例</span><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;Accuracy Curve&#x27;</span>, <span class="hljs-string">&#x27;Population optimum&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120101479.png" /></p><h2 id="稀疏反协方差估计">稀疏反协方差估计</h2><p>稀疏逆协方差估计是一种统计方法，用于估计变量之间的依赖关系。该方法通过优化一个包含正则化项的目标函数来实现。其优化目标为： <span class="math display">\[\min _{X \in \mathbb{R}^{n \times n}, X \succeq 0}\langle S, X\rangle-\log \operatorname{det}(X)+\alpha\|X\|_1\]</span> 在这里，我们定义： <span class="math display">\[\langle S, X\rangle=\trace (S^\top X)\]</span> 和 <span class="math display">\[\|X\|_1=\sum_{ij}|X_{ij}|\]</span> 在原文中，使用到了<code>python</code>的<code>autograd</code>功能。但是<code>matlab</code>不带有这个功能，为此，我颇下了一番功夫，最终得到一个解决方案。</p><p>这个问题解决起来很棘手，因为函数的参数都是矩阵。如果只用 <code>syms A</code> 指令，生成的只是单个变量。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; syms S X<br>&gt;&gt; sparse_inv_cov_syms = trace(S&#x27; * X) - <span class="hljs-built_in">log</span>(det(X)) + <span class="hljs-number">0.1</span> * sum(<span class="hljs-built_in">abs</span>(X),<span class="hljs-string">&#x27;all&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">sparse_inv_cov_syms =<br> <br><span class="hljs-built_in">abs</span>(X)/<span class="hljs-number">10</span> - <span class="hljs-built_in">log</span>(X) + X*<span class="hljs-built_in">conj</span>(S)<br></code></pre></td></tr></table></figure><p>这显然不是我们要的结果。这时，我们需要生成矩阵符号：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; n=<span class="hljs-number">5</span><br>&gt;&gt; syms S [n n]<br>&gt;&gt; syms X [n n]<br>&gt;&gt; sparse_inv_cov_syms = trace(S&#x27; * X) - <span class="hljs-built_in">log</span>(det(X)) + <span class="hljs-number">0.1</span> * sum(<span class="hljs-built_in">abs</span>(X),<span class="hljs-string">&#x27;all&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sparse_inv_cov_syms =<br> <br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(X1_1)</span></span>/<span class="hljs-number">10</span> + <span class="hljs-built_in">abs</span>(X1_2)/<span class="hljs-number">10</span> + <span class="hljs-built_in">abs</span>(X1_3)/<span class="hljs-number">10</span> + <span class="hljs-built_in">abs</span>(X1_4)/<span class="hljs-number">10</span> + <span class="hljs-built_in">abs</span>(X1_5)/<span class="hljs-number">10</span> + <span class="hljs-built_in">abs</span>(X2_1)/<span class="hljs-number">10</span> + ...<br></code></pre></td></tr></table></figure><p>但是此时如果我们直接用<code>matlabFunction</code>函数转换，会得到一个以25个变量为参数的函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; <span class="hljs-built_in">ans</span>=matlabFunction(sparse_inv_cov_syms)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ans =<br><br>  包含以下值的 function_handle:<br><br><span class="hljs-meta">    @(<span class="hljs-params">S1_1,S1_2,S1_3,S1_4,S1_5,S2_1,S2_2,S2_3,S2_4,S2_5,S3_1,S3_2,S3_3,S3_4,S3_5,S4_1,S4_2,S4_3,S4_4,S4_5,S5_1,S5_2,S5_3,S5_4,S5_5,X1_1,X1_2,X1_3,X1_4,X1_5,X2_1,X2_2,X2_3,X2_4,X2_5,X3_1,X3_2,X3_3,X3_4,X3_5,X4_1,X4_2,X4_3,X4_4,X4_5,X5_1,X5_2,X5_3,X5_4,X5_5</span>)...</span><br></code></pre></td></tr></table></figure><p>这并不是我们需要的形式。在生成函数时，我们使用<code>Vars</code>字符串，然后把<code>S</code>和<code>X</code>用大括号括起来，这样就行了。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; <span class="hljs-built_in">ans</span>=matlabFunction(sparse_inv_cov_syms,<span class="hljs-string">&quot;Vars&quot;</span>,&#123;S,X&#125;)<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ans =<br><br>  包含以下值的 function_handle:<br><br><span class="hljs-meta">    @(<span class="hljs-params">in1,in2</span>)abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">6</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">11</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">16</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">21</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">7</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">12</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">17</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">22</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">8</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">13</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">18</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">23</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">4</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">9</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">14</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">19</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">24</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>+abs(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)</span>)./<span class="hljs-number">1.0e+1</span>-log(<span class="hljs-params">in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">25</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">20</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">15</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)-in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">10</span></span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*in2(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">1</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">6</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">6</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">11</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">11</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">16</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">16</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">21</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">21</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">2</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">7</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">7</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">12</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">12</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">17</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">17</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">22</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">22</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">3</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">8</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">8</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">13</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">13</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">18</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">18</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">23</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">23</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">4</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">4</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">9</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">9</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">14</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">14</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">19</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">19</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">24</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">24</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">5</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">10</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">15</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">15</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">20</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">20</span></span>)</span>)+in2(<span class="hljs-params"><span class="hljs-number">25</span></span>).*conj(<span class="hljs-params">in1(<span class="hljs-params"><span class="hljs-number">25</span></span>)</span>)</span><br></code></pre></td></tr></table></figure><p>此时如果想用<code>gradient</code>函数求微分，又会报错：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; g = gradient(sparse_inv_cov_syms,Xsyms)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">错误使用 sym/gradient (<span class="hljs-built_in">line</span> <span class="hljs-number">39</span>)<br>Second <span class="hljs-keyword">argument</span> must <span class="hljs-keyword">be</span> <span class="hljs-keyword">a</span> vector of variables.<br></code></pre></td></tr></table></figure><p>既然他说 must be a vector，那就把它向量化：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; Xvec=X(:)<br>&gt;&gt; g = gradient(sparse_inv_cov_syms,Xvec)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g =<br> <br> <span class="hljs-built_in">conj</span>(Ssyms1_1) + <span class="hljs-built_in">sign</span>(Xsyms1_1)/<span class="hljs-number">10</span> - (Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms2_1) + <span class="hljs-built_in">sign</span>(Xsyms2_1)/<span class="hljs-number">10</span> + (Xsyms1_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms3_4*Xsyms4_3*Xsyms5_2)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms3_1) + <span class="hljs-built_in">sign</span>(Xsyms3_1)/<span class="hljs-number">10</span> - (Xsyms1_2*Xsyms2_3*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_4*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_5*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms4_4*Xsyms5_3 - Xsyms1_3*Xsyms2_2*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_4*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_5*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms4_4*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_3*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_5*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_3*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_4*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms4_3*Xsyms5_2)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms4_1) + <span class="hljs-built_in">sign</span>(Xsyms4_1)/<span class="hljs-number">10</span> + (Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms5_4 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms5_3 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms5_3 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms5_4 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms5_2 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms5_3 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms5_2 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms5_3 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms5_2 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms5_2)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms5_1) + <span class="hljs-built_in">sign</span>(Xsyms5_1)/<span class="hljs-number">10</span> - (Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms1_2) + <span class="hljs-built_in">sign</span>(Xsyms1_2)/<span class="hljs-number">10</span> + (Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms2_2) + <span class="hljs-built_in">sign</span>(Xsyms2_2)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms3_4*Xsyms4_3*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms3_2) + <span class="hljs-built_in">sign</span>(Xsyms3_2)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms2_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms4_4*Xsyms5_3 - Xsyms1_3*Xsyms2_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms4_4*Xsyms5_1 + Xsyms1_4*Xsyms2_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms4_3*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms4_2) + <span class="hljs-built_in">sign</span>(Xsyms4_2)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms5_4 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms5_3 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms5_4 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms5_1 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms5_3 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms5_1 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms5_3 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms5_2) + <span class="hljs-built_in">sign</span>(Xsyms5_2)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms1_3) + <span class="hljs-built_in">sign</span>(Xsyms1_3)/<span class="hljs-number">10</span> - (Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms2_3) + <span class="hljs-built_in">sign</span>(Xsyms2_3)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms3_4*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms3_3) + <span class="hljs-built_in">sign</span>(Xsyms3_3)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms2_2*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_4*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_5*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms4_4*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_4*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_5*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms4_4*Xsyms5_1 + Xsyms1_4*Xsyms2_1*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_2*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_1*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_2*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms4_3) + <span class="hljs-built_in">sign</span>(Xsyms4_3)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms5_4 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms5_2 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms5_4 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms5_1 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms5_1 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms5_2 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms5_1 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms5_2 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms5_3) + <span class="hljs-built_in">sign</span>(Xsyms5_3)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms1_4) + <span class="hljs-built_in">sign</span>(Xsyms1_4)/<span class="hljs-number">10</span> + (Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms2_4) + <span class="hljs-built_in">sign</span>(Xsyms2_4)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms3_3*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms3_4) + <span class="hljs-built_in">sign</span>(Xsyms3_4)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms2_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_5*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_5*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_5*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_3*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms4_4) + <span class="hljs-built_in">sign</span>(Xsyms4_4)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms5_2 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms5_3 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms5_1 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms5_3 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms5_1 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms5_2 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms5_1 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms5_3 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms5_2 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms5_3 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms5_1 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms5_2 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms5_4) + <span class="hljs-built_in">sign</span>(Xsyms5_4)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms1_5) + <span class="hljs-built_in">sign</span>(Xsyms1_5)/<span class="hljs-number">10</span> - (Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms2_5) + <span class="hljs-built_in">sign</span>(Xsyms2_5)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms3_5) + <span class="hljs-built_in">sign</span>(Xsyms3_5)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms2_2*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms4_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms4_5) + <span class="hljs-built_in">sign</span>(Xsyms4_5)/<span class="hljs-number">10</span> + (Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms5_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1)<br> <span class="hljs-built_in">conj</span>(Ssyms5_5) + <span class="hljs-built_in">sign</span>(Xsyms5_5)/<span class="hljs-number">10</span> - (Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1)/(Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_5 - Xsyms1_1*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_5 + Xsyms1_1*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_3 + Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_4 - Xsyms1_1*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_3 - Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_5 + Xsyms1_1*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_5 - Xsyms1_1*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_2 - Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_4 + Xsyms1_1*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_5 - Xsyms1_1*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_5 + Xsyms1_1*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_2 + Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_3 - Xsyms1_1*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_4 + Xsyms1_1*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_4 - Xsyms1_1*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_2 - Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_3 + Xsyms1_1*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_5 + Xsyms1_2*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_5 - Xsyms1_2*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_3 - Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_4 + Xsyms1_2*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_3 + Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_5 - Xsyms1_2*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_5 + Xsyms1_2*Xsyms2_3*Xsyms3_4*Xsyms4_5*Xsyms5_1 + Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_4 - Xsyms1_2*Xsyms2_3*Xsyms3_5*Xsyms4_4*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_5 + Xsyms1_2*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_5 - Xsyms1_2*Xsyms2_4*Xsyms3_3*Xsyms4_5*Xsyms5_1 - Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_3 + Xsyms1_2*Xsyms2_4*Xsyms3_5*Xsyms4_3*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_4 - Xsyms1_2*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_4 + Xsyms1_2*Xsyms2_5*Xsyms3_3*Xsyms4_4*Xsyms5_1 + Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_3 - Xsyms1_2*Xsyms2_5*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_5 - Xsyms1_3*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_5 + Xsyms1_3*Xsyms2_1*Xsyms3_4*Xsyms4_5*Xsyms5_2 + Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_4 - Xsyms1_3*Xsyms2_1*Xsyms3_5*Xsyms4_4*Xsyms5_2 - Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_5 + Xsyms1_3*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_5 - Xsyms1_3*Xsyms2_2*Xsyms3_4*Xsyms4_5*Xsyms5_1 - Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_4 + Xsyms1_3*Xsyms2_2*Xsyms3_5*Xsyms4_4*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_5 - Xsyms1_3*Xsyms2_4*Xsyms3_1*Xsyms4_5*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_5 + Xsyms1_3*Xsyms2_4*Xsyms3_2*Xsyms4_5*Xsyms5_1 + Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_1*Xsyms5_2 - Xsyms1_3*Xsyms2_4*Xsyms3_5*Xsyms4_2*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_4 + Xsyms1_3*Xsyms2_5*Xsyms3_1*Xsyms4_4*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_4 - Xsyms1_3*Xsyms2_5*Xsyms3_2*Xsyms4_4*Xsyms5_1 - Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_1*Xsyms5_2 + Xsyms1_3*Xsyms2_5*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_5 + Xsyms1_4*Xsyms2_1*Xsyms3_2*Xsyms4_5*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_5 - Xsyms1_4*Xsyms2_1*Xsyms3_3*Xsyms4_5*Xsyms5_2 - Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_2*Xsyms5_3 + Xsyms1_4*Xsyms2_1*Xsyms3_5*Xsyms4_3*Xsyms5_2 + Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_5 - Xsyms1_4*Xsyms2_2*Xsyms3_1*Xsyms4_5*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_5 + Xsyms1_4*Xsyms2_2*Xsyms3_3*Xsyms4_5*Xsyms5_1 + Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_1*Xsyms5_3 - Xsyms1_4*Xsyms2_2*Xsyms3_5*Xsyms4_3*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_5 + Xsyms1_4*Xsyms2_3*Xsyms3_1*Xsyms4_5*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_5 - Xsyms1_4*Xsyms2_3*Xsyms3_2*Xsyms4_5*Xsyms5_1 - Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_1*Xsyms5_2 + Xsyms1_4*Xsyms2_3*Xsyms3_5*Xsyms4_2*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_2*Xsyms5_3 - Xsyms1_4*Xsyms2_5*Xsyms3_1*Xsyms4_3*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_1*Xsyms5_3 + Xsyms1_4*Xsyms2_5*Xsyms3_2*Xsyms4_3*Xsyms5_1 + Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_1*Xsyms5_2 - Xsyms1_4*Xsyms2_5*Xsyms3_3*Xsyms4_2*Xsyms5_1 + Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_3*Xsyms5_4 - Xsyms1_5*Xsyms2_1*Xsyms3_2*Xsyms4_4*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_2*Xsyms5_4 + Xsyms1_5*Xsyms2_1*Xsyms3_3*Xsyms4_4*Xsyms5_2 + Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_2*Xsyms5_3 - Xsyms1_5*Xsyms2_1*Xsyms3_4*Xsyms4_3*Xsyms5_2 - Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_3*Xsyms5_4 + Xsyms1_5*Xsyms2_2*Xsyms3_1*Xsyms4_4*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_1*Xsyms5_4 - Xsyms1_5*Xsyms2_2*Xsyms3_3*Xsyms4_4*Xsyms5_1 - Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_1*Xsyms5_3 + Xsyms1_5*Xsyms2_2*Xsyms3_4*Xsyms4_3*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_2*Xsyms5_4 - Xsyms1_5*Xsyms2_3*Xsyms3_1*Xsyms4_4*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_1*Xsyms5_4 + Xsyms1_5*Xsyms2_3*Xsyms3_2*Xsyms4_4*Xsyms5_1 + Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_1*Xsyms5_2 - Xsyms1_5*Xsyms2_3*Xsyms3_4*Xsyms4_2*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_2*Xsyms5_3 + Xsyms1_5*Xsyms2_4*Xsyms3_1*Xsyms4_3*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_1*Xsyms5_3 - Xsyms1_5*Xsyms2_4*Xsyms3_2*Xsyms4_3*Xsyms5_1 - Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_1*Xsyms5_2 + Xsyms1_5*Xsyms2_4*Xsyms3_3*Xsyms4_2*Xsyms5_1) <br></code></pre></td></tr></table></figure><p>成功了。</p><p>所以我先用matlab的符号运算生成了矩阵符号，书写函数以后，将被求导的矩阵转换成向量，用<code>gradient</code>函数进行符号求导，然后再进行一次矩阵向量化的包装，这样一来，基本可以实现<code>autograd</code>自动求导的效果。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义基本变量</span><br>n = <span class="hljs-number">5</span>;<br>A = <span class="hljs-built_in">randn</span>(n,n);<br>S = A*A&#x27;;<br><br><span class="hljs-comment">% 定义目标函数，这里使用了符号运算</span><br>syms Ssyms <span class="hljs-number">5</span>; <span class="hljs-comment">% 表示生成5x5的矩阵符号</span><br>syms Xsyms <span class="hljs-number">5</span>;<br>sparse_inv_cov_syms = trace(Ssyms&#x27; * Xsyms) - <span class="hljs-built_in">log</span>(det(Xsyms)) + <span class="hljs-number">0.1</span> * sum(<span class="hljs-built_in">abs</span>(Xsyms),<span class="hljs-string">&#x27;all&#x27;</span>); <span class="hljs-comment">% 目标函数</span><br>X_vec=Xsyms(:);<span class="hljs-comment">% 将矩阵 X 向量化，因为后面的gradient函数的第二个参数必须是vector</span><br>sparse_inv_cov_grad_syms = gradient(sparse_inv_cov_syms,X_vec); <span class="hljs-comment">% 微分</span><br><br>objective=matlabFunction(sparse_inv_cov_syms,<span class="hljs-string">&quot;Vars&quot;</span>,&#123;Ssyms,Xsyms&#125;); <br><span class="hljs-comment">% 将符号函数转换为matlab函数。这里要加&quot;Vars&quot;，并且把两个矩阵符号用大括号括起来</span><br><span class="hljs-comment">% 这样生成的matlab函数的参数才是矩阵</span><br>grad=matlabFunction(sparse_inv_cov_grad_syms,<span class="hljs-string">&quot;Vars&quot;</span>,&#123;Ssyms,X_vec&#125;); <br>gradien=@(X) grad(S,X(:)); <span class="hljs-comment">% 用矩阵向量化包装，形成真正的梯度函数</span><br></code></pre></td></tr></table></figure><p>定义投影函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">X_proj</span> = <span class="hljs-title">projection</span><span class="hljs-params">(X)</span></span><br>    <span class="hljs-comment">% Projection onto positive semidefinite cone.</span><br>    [U,es] = eig(X);<br>    es(es &lt; <span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;<br>    X_proj = U * es * U&#x27;;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>因为这里的优化目标<span class="math inline">\(X\)</span>也是矩阵，所以梯度下降函数的写法也做了相应修改：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xs</span> = <span class="hljs-title">gradient_descent_xx</span><span class="hljs-params">(n,init, steps, grad, proj)</span></span><br>    <span class="hljs-keyword">if</span> nargin &lt; <span class="hljs-number">5</span><br>        proj = @(x) x; <span class="hljs-comment">% If proj is not provided, use the identity function</span><br>    <span class="hljs-keyword">end</span><br>    xs = [init];<br>    <span class="hljs-keyword">for</span> step = steps<br>        startCol = (<span class="hljs-built_in">size</span>(xs, <span class="hljs-number">2</span>) - n) + <span class="hljs-number">1</span>; <span class="hljs-comment">% 从总列数减去n，然后加1</span><br>        endCol = <span class="hljs-built_in">size</span>(xs ,<span class="hljs-number">2</span>); <span class="hljs-comment">% 总列数</span><br>        lastSubMatrix = xs(:, startCol:endCol)<br>        G=grad(lastSubMatrix);;<br>        G=<span class="hljs-built_in">reshape</span>(G,<span class="hljs-built_in">size</span>(lastSubMatrix));<br>        temp=lastSubMatrix - step * G;<br>        k=proj(temp);<br>        xs = [xs, k];<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>运行仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A0 = <span class="hljs-built_in">randn</span>(n,n);<br>X0 = A0*A0&#x27;;<br>steps=<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>)*<span class="hljs-number">0.01</span>;<br>Xs = gradient_descent_xx(n,X0,steps,gradien,@projection);<br><br>ys = arrayfun(@(<span class="hljs-built_in">i</span>) objective(S,Xs(:,(<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*n+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*n)), <span class="hljs-number">1</span>:<span class="hljs-number">500</span>);<br>Error_plot(ys,<span class="hljs-string">&#x27;log&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412120111323.png" /></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合成孔径雷达的「斑马图」到底是怎么回事</title>
    <link href="/2024/11/10/%E5%90%88%E6%88%90%E5%AD%94%E5%BE%84%E9%9B%B7%E8%BE%BE%E7%9A%84%E3%80%8C%E6%96%91%E9%A9%AC%E5%9B%BE%E3%80%8D%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/"/>
    <url>/2024/11/10/%E5%90%88%E6%88%90%E5%AD%94%E5%BE%84%E9%9B%B7%E8%BE%BE%E7%9A%84%E3%80%8C%E6%96%91%E9%A9%AC%E5%9B%BE%E3%80%8D%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>在合成孔径雷达（以下简称SAR）的波位设计中，经常会遇到一个叫做「斑马图」（或者「菱形图」）的东西，它大概长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411101734786.png" alt="image-20241110173408561" /><figcaption aria-hidden="true">image-20241110173408561</figcaption></figure><p>斑马图的横轴是脉冲重复频率，纵轴一般是入射角或者距星下点地面距离。其中有两组曲线，分别表示了星下点回波的干扰和发射信号盲区。对于发射和接收公用一个天线的星载 SAR 系统，由于在任何时刻空中同时有发射脉冲、星下点脉冲和回波必须对 PRF 加以限制，使发射脉冲、星下点脉冲不落在回波窗之中。只有当脉冲重复频率和星下点地面距离的选择在图里的「大菱形区域」里，SAR才能正常工作。如何选择脉冲重复频率或者星下点地面距离，就是所谓的「波位设计」。</p><p>我接触到的很多教材都对这个东西的绘制语焉不详，所以在这里我写一下怎么画。画斑马图的关键是几何关系：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411101748589.png" alt="image-20241110174855700" /><figcaption aria-hidden="true">image-20241110174855700</figcaption></figure><p>在这个图中，以点<span class="math inline">\(A\)</span>为圆心的圆形表示地球，点<span class="math inline">\(C\)</span>表示SAR卫星，点<span class="math inline">\(B\)</span>表示目标，点<span class="math inline">\(D\)</span>表示SAR卫星和地心的连线，也就是星下点。其它长度和角度的名称如下：</p><ul><li><span class="math inline">\(R_e\)</span>：即线段<span class="math inline">\(DA\)</span>的长度，地球半径，已知</li><li><span class="math inline">\(R_p\)</span>：即线段<span class="math inline">\(BA\)</span>的长度，也是地球半径，已知</li><li><span class="math inline">\(R_s\)</span>：圆弧<span class="math inline">\(DB\)</span>的长度，地距</li><li><span class="math inline">\(R\)</span>：线段<span class="math inline">\(CB\)</span>的长度，斜距</li><li><span class="math inline">\(H\)</span>：线段<span class="math inline">\(CD\)</span>的长度，卫星高度，已知</li><li><span class="math inline">\(\alpha\)</span>：<span class="math inline">\(\angle DCB\)</span>，视角</li><li><span class="math inline">\(\theta\)</span>：<span class="math inline">\(\pi-\angle{CBA}\)</span>，入射角</li><li><span class="math inline">\(\gamma\)</span>：<span class="math inline">\(\angle{DAB}\)</span>，地心角，显然有：<span class="math inline">\(\gamma=\theta-\alpha\)</span></li></ul><p>对于一个SAR系统，要绘制其斑马图，还要知道脉冲宽度<span class="math inline">\(\tau\)</span>、斑马图横坐标的范围（最大最小脉冲重复频率）、最大最小中心视角。</p><h2 id="绘制发射信号干扰带的斑马图">绘制发射信号干扰带的斑马图</h2><ol type="1"><li><p>计算其前后沿回波时间：</p><p>假设总共要画<span class="math inline">\(m\)</span>个曲线，现在正在画第<span class="math inline">\(j\)</span>个，当前正在看的脉冲重复频率为<span class="math inline">\(f_{PRF}\)</span>，有 <span class="math display">\[\begin{align}T_{e_1}=\frac{j}{f_{PRF}}-(\tau+T_g)\\\\T_{e_1}=\frac{j}{f_{PRF}}+(\tau+T_g)\end{align}\]</span> 这里面的<span class="math inline">\(T_g\)</span>叫做「保护时间带」，我还不太确定这是什么，好像是一种类似于冗余的东西，取<span class="math inline">\(0\)</span>也没关系。</p></li><li><p>计算对应的最大最小斜距： <span class="math display">\[\begin{align}R_{\min}=T_{e_1}\frac c2=\left(\frac{j}{f_{PRF}}-(\tau+T_g)\right)\cdot\frac c2\\\\R_{\max}=T_{e_2}\frac c2=\left(\frac{j}{f_{PRF}}+(\tau+T_g)\right)\cdot\frac c2\end{align}\]</span></p></li><li><p>计算对应的最大最小视角：</p><p>即解三角形<span class="math inline">\(CBA\)</span>，对<span class="math inline">\(\alpha\)</span>应用余弦定理： <span class="math display">\[\alpha=\arccos\left(\frac{R^2+(R_e+H)^2-R_p^2}{2R(R_e+H)}\right)\]</span> 有： <span class="math display">\[\begin{align}\alpha_{\max}=\arccos\left(\frac{R_\max^2+(R_e+H)^2-R_p^2}{2R_\max(R_e+H)}\right)\\\\\alpha_{\min}=\arccos\left(\frac{R_\min^2+(R_e+H)^2-R_p^2}{2R_\min(R_e+H)}\right)\end{align}\]</span></p></li><li><p>计算对应的最大最小入射角：</p><p>即解三角形<span class="math inline">\(CBA\)</span>，求解<span class="math inline">\(\theta\)</span>。</p><p>由余弦定理： <span class="math display">\[\angle CBA=\arccos\left(\frac{R_p^2+R^2-(R_e+H)^2}{2R_pR}\right)\]</span> 有： <span class="math display">\[\begin{align}\theta_{\max}=\pi-\arccos\left(\frac{R_p^2+R_{\max}^2-(R_e+H)^2}{2R_pR_{\max}}\right)\\\\\theta_{\min}=\pi-\arccos\left(\frac{R_p^2+R_{\min}^2-(R_e+H)^2}{2R_pR_{\min}}\right)\end{align}\]</span></p></li><li><p>计算最大最小地距：</p><p>由圆弧<span class="math inline">\(DB\)</span>，得：<span class="math inline">\(R_s=\gamma R_e=(\theta-\alpha)R_e\)</span>。有： <span class="math display">\[\begin{align}R_{s_\max}=(\theta_\max-\alpha_\max)R_e\\\\R_{s_\min}=(\theta_\min-\alpha_\min)R_e\end{align}\]</span></p></li></ol><p>由上面的推导，可以看出，<span class="math inline">\(R_{s\min}\)</span>和<span class="math inline">\(R_{s\max}\)</span>总的来说是<span class="math inline">\(j\)</span>和<span class="math inline">\(f_{PRF}\)</span>的函数。在计算时，我们写一个双重循环，外层循环遍历<span class="math inline">\(f_{PRF}\)</span>，内层循环遍历<span class="math inline">\(j\)</span>，然后算出<span class="math inline">\(R_{s\max},R_{s\min}\)</span>并画图就行了。</p><p>让我们说得再明白一点，也就是说每个<span class="math inline">\(j\)</span>对应两条曲线：<span class="math inline">\(R_{s\max}(f_{PRF}),R_{s\min}(f_{PRF})\)</span>。</p><p>现在的问题是：<span class="math inline">\(j\)</span>怎么取值？首先明确<span class="math inline">\(j\)</span>是正整数。如果<span class="math inline">\(j\)</span>取得太小，会让三角形无解（表现为<span class="math inline">\(\arccos\)</span>函数算出来不是实数）。如果<span class="math inline">\(j\)</span>取得太大，会让画出来的曲线没有意义（在图上不显示）。书上说： <span class="math display">\[\begin{align}j_{\min}=\lfloor{T_{e\min}\cdot f_{PRF\min}}\rfloor\\\\j_{\max}=\lfloor{T_{e\max}\cdot f_{PRF\max}}\rfloor\end{align}\]</span> 其中，<span class="math inline">\(T_e\)</span>是所选择区域的最近/远斜距对应的回波时间，<span class="math inline">\(f_{PRF}\)</span>是所选择的最小/大可能脉冲重复频率。在这里，<span class="math inline">\(f_{PRF}\)</span>的最大最小值很容易理解，已经被给定了。但是<span class="math inline">\(T_e\)</span>需要计算，因为给定的是最小/大中心视角。</p><p>回到前面的几何关系：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411101748589.png" alt="image-20241110174855700" /><figcaption aria-hidden="true">image-20241110174855700</figcaption></figure><p>也就是说，解三角形<span class="math inline">\(CBA\)</span>，给定<span class="math inline">\(CA,AB,\alpha\)</span>，求解<span class="math inline">\(CB\)</span>。注意在数学里这个三角形似乎并不唯一确定（有两个解），但是在我们这里显然只需要取<span class="math inline">\(\angle CBA\)</span>是钝角的那个解。</p><p>过<span class="math inline">\(A\)</span>作直线<span class="math inline">\(CB\)</span>的垂线交于点<span class="math inline">\(E\)</span>：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411102107191.png" alt="image-20241110210718722" /><figcaption aria-hidden="true">image-20241110210718722</figcaption></figure><p>则有： <span class="math display">\[AE=(Re+H)\sin\alpha\]</span></p><p>于是 <span class="math display">\[\angle BAE=\arccos\left(\frac{AE}{R_p}\right)=\arccos\left(\frac{(Re+H)\sin\alpha}{R_p}\right)\]</span> 则 <span class="math display">\[\gamma=\frac \pi2-\alpha-\angle BAE=\frac \pi2-\alpha-\arccos\left(\frac{(Re+H)\sin\alpha}{R_p}\right)\]</span> 由正弦定理 <span class="math display">\[\frac{R_p}{\sin \alpha}=\frac{R}{\sin \gamma}\]</span> 有 <span class="math display">\[R=\frac{\sin \gamma R_p}{\sin \alpha}\]</span> 则 <span class="math display">\[T_e=\frac {2R}{c}\]</span> 其中<span class="math inline">\(c\)</span>是光速。这样一来，我们就把<span class="math inline">\(T_e\)</span>表示成了<span class="math inline">\(\alpha\)</span>的函数： <span class="math display">\[T_e=\frac {2}{c} \frac{\sin\left(\frac \pi2-\alpha-\arccos\left(\frac{(Re+H)\sin\alpha}{R_p}\right)\right)R_p}{\sin \alpha}\]</span></p><h2 id="绘制星下点回波区的斑马图">绘制星下点回波区的斑马图</h2><p>首先，计算前后沿回波时间 <span class="math display">\[\begin{align}T_\min=\frac {2h}c+\frac i {f_{PRF}}-(\tau+T_g)\\\\T_\max=\frac {2h}c+\frac i {f_{PRF}}+(\tau+T_g)\end{align}\]</span></p><p>后面的计算和上一部分的完全一样。</p><p>关于<span class="math inline">\(i\)</span>的取值，有： <span class="math display">\[\begin{align}i_\min&amp;=j_\min-\lfloor (T_{nad}+\tau+2T_g)f_{PRF\min}\rfloor\\\\i_\max&amp;=j_\max-\lfloor T_{nad}f_{PRF\min}\rfloor\end{align}\]</span> 其中 <span class="math display">\[T_{nad}=\frac{2h}c-T_g\]</span> 称为「星下点回波起始时间」。</p><h2 id="算法伪代码">算法伪代码</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411110950937.png" alt="image-20241111095027940" /><figcaption aria-hidden="true">image-20241111095027940</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411110950386.png" alt="image-20241111095045845" /><figcaption aria-hidden="true">image-20241111095045845</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SAR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ヤマノススメ！2024年9月！</title>
    <link href="/2024/10/08/%E9%94%BB%E7%82%BC202409/"/>
    <url>/2024/10/08/%E9%94%BB%E7%82%BC202409/</url>
    
    <content type="html"><![CDATA[<p>其实我之前有个栏目叫做周记，但是已经很久没更新了。主要原因是懒，其次的原因是里面有很多个人化的碎碎念，所以我都加密了。</p><p>受某个动画片的影响，我想在三年以内登顶富士山，所以最近在锻炼。受不知道什么的影响，友人想骑车去天津，所以也在锻炼。于是我决定以此来复活一下周记，但是只记录锻炼，不再进行个人化的碎碎念了。</p><p>[toc]</p><h2 id="骑自行车">骑自行车</h2><p>骑的都是美团。过去的一个月，总共骑了20次。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081053782.png" alt="第一次骑车，北航西部" /><figcaption aria-hidden="true">第一次骑车，北航西部</figcaption></figure><p>北航西部路线。路上没什么值得说的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081053837.png" alt="北航南部" /><figcaption aria-hidden="true">北航南部</figcaption></figure><p>经过西直门。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081053996.png" alt="北航北部" /><figcaption aria-hidden="true">北航北部</figcaption></figure><p>有很长的下坡，比较爽。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081054811.png" alt="东四十条-北航" /><figcaption aria-hidden="true">东四十条-北航</figcaption></figure><p>聚餐完了骑的，消食。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081054424.png" alt="半个奥森环线" /><figcaption aria-hidden="true">半个奥森环线</figcaption></figure><p>看完电影骑的。本来想画一个所谓的「鸭子」，最后形成了这样的曲线。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081054442.png" alt="长安街" /><figcaption aria-hidden="true">长安街</figcaption></figure><p>主要是去看景。骑完逛了三月兽。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081054831.png" alt="北航北部" /><figcaption aria-hidden="true">北航北部</figcaption></figure><p>没什么好说的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081055516.png" alt="北航-长安街-西单" /><figcaption aria-hidden="true">北航-长安街-西单</figcaption></figure><p>这一路上太京爷了，有神秘小胡同、四合院和美食街。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081055405.png" alt="北航南部大环线" /><figcaption aria-hidden="true">北航南部大环线</figcaption></figure><p>这个路很好，有很多景点。西边有北理工和国图，南边有动物园和展览馆，东边有西直门、枫蓝国际和北邮。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081055917.png" alt="百望山森林公园-五道口" /><figcaption aria-hidden="true">百望山森林公园-五道口</figcaption></figure><p>爬完山骑车回来，这一路上风景也不错，有圆明园和清北。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081056709.png" alt="中关村" /><figcaption aria-hidden="true">中关村</figcaption></figure><p>没啥意思</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081056655.png" alt="北航南部小环线" /><figcaption aria-hidden="true">北航南部小环线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081056880.png" alt="北航-长安街-西单-北航" /><figcaption aria-hidden="true">北航-长安街-西单-北航</figcaption></figure><p>目前的长途记录。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081056358.png" alt="清华大环线" /><figcaption aria-hidden="true">清华大环线</figcaption></figure><p>这个路很好，风景不错，而且没多少车，在荷清路上运气好的话能和地铁并排。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081057452.png" alt="怀柔北" /><figcaption aria-hidden="true">怀柔北</figcaption></figure><p>打发时间。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081057689.png" alt="雁栖湖" /><figcaption aria-hidden="true">雁栖湖</figcaption></figure><p>看地图直线4km，没想到全是爬坡，很累。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081057644.png" alt="望京-北航" /><figcaption aria-hidden="true">望京-北航</figcaption></figure><p>路上上下坡不少，有点累。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081057801.png" alt="清华大环线" /><figcaption aria-hidden="true">清华大环线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081057686.png" alt="人才是海淀最美的风景" /><figcaption aria-hidden="true">人才是海淀最美的风景</figcaption></figure><p>其实是清华大环线的变体。主要是为了打卡两个「人才是海淀最美的风景」招牌。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081058549.png" alt="八角游乐园-北航" /><figcaption aria-hidden="true">八角游乐园-北航</figcaption></figure><p>练习一下长途。</p><h2 id="爬山">爬山</h2><h3 id="百望山">百望山</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081109588.png" alt="游击队之林" /><figcaption aria-hidden="true">游击队之林</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081226584.png" alt="从半山腰看山顶" /><figcaption aria-hidden="true">从半山腰看山顶</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081111831.png" alt="从山顶俯视" /><figcaption aria-hidden="true">从山顶俯视</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081112504.png" alt="从山顶俯视" /><figcaption aria-hidden="true">从山顶俯视</figcaption></figure><p>难度：★☆☆☆☆</p><p>风景：★★★☆☆</p><p>交通：★★★★★</p><p>有两条路线，一条是快速爬升路线，我计时了，从检票到登顶总共用了30分钟左右。还有一条是轮椅路线，非常平缓，是个人就能爬上去。</p><p>风景除了树林子以外，还有很多石碑，这儿好像是什么「历史文化碑林」。</p><p>交通很方便，去的时候坐地铁，回去的时候骑车。很近，十几公里吧。</p><h3 id="西山">西山</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081117078.png" alt="大门口" /><figcaption aria-hidden="true">大门口</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081117956.png" alt="半山腰俯瞰电视塔" /><figcaption aria-hidden="true">半山腰俯瞰电视塔</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081118837.png" alt="彩色的天空" /><figcaption aria-hidden="true">彩色的天空</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081118405.png" alt="鬼笑石" /><figcaption aria-hidden="true">鬼笑石</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081118353.png" alt="网红夜景" /><figcaption aria-hidden="true">网红夜景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081118901.png" alt="网红夜景" /><figcaption aria-hidden="true">网红夜景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081120186.png" alt="路线" /><figcaption aria-hidden="true">路线</figcaption></figure><p>难度：★★☆☆☆</p><p>风景：★★★★☆</p><p>交通：★★☆☆☆</p><p>这个海拔是四百多米，但是我感觉和百望山差不多好爬，可能是因为这个西山的树林子很好，氧气很足，导致没那么累。</p><p>风景很不错，路上的树林子、夕阳，还有山顶的夜景，都很好。虽然这个夜景也是「网红夜景」，但是我感觉还是不如神户摩耶山。</p><p>交通不是特别方便，没有直达轨道交通。到了鬼笑石，如果有条件还是建议返回到大门口去坐车，不要去那个停车场，不然只能打车回咯。</p><h3 id="雁栖湖西山步道">雁栖湖西山步道</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081127732.png" alt="登山道" /><figcaption aria-hidden="true">登山道</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081128619.png" alt="来雁云峰" /><figcaption aria-hidden="true">来雁云峰</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081128886.png" alt="聆雁回鸣" /><figcaption aria-hidden="true">聆雁回鸣</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410081128184.png" alt="路线（绿色线条）" /><figcaption aria-hidden="true">路线（绿色线条）</figcaption></figure><p>难度：☆☆☆☆☆</p><p>风景：★★★★☆</p><p>交通：★★☆☆☆</p><p>这个开发得很好，没有任何难度，是个人就能上，最高处是「来雁云峰」。</p><p>风景很好，小红书上说是「京郊小瑞士」，到地方看确实还不错，主要是俯瞰雁栖湖。遗憾的是我去的时候天气比较阴。这个森林也是很舒服的。</p><p>交通一般吧，就是先坐动车去怀柔北站/雁栖湖站，然后骑车/打车过去。骑车的时候爬坡很多，可能还没到登山口就累了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锻炼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵理论笔记</title>
    <link href="/2024/10/05/%E7%9F%A9%E9%98%B5%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/05/%E7%9F%A9%E9%98%B5%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr /><p>须知：</p><ol type="1"><li>这篇笔记并不是《矩阵理论》课程的全部内容，只是我（以及往年题）认为的重点内容。</li><li>因为这篇笔记从头到尾都是我一个人写的，也没有细致地校对过，所以一定会存在一些笔误，欢迎在评论区帮我指正，不胜感激。</li><li>由此，我强烈建议各位在线阅读，而不是下载下来阅读，因为我会随时更新错误或者补充内容。</li></ol><h2 id="线性空间引论">线性空间引论</h2><p>这一部分其实基本就高代的内容，复习一下。</p><h3 id="非齐次线性方程组的解法">非齐次线性方程组的解法</h3><p>这个必须得会吧。为了防止遗忘，还是写一下。</p><p>对于非齐次线性方程组 <span class="math display">\[Ax=b\]</span> 其解是由一个特解和齐次线性方程组<span class="math inline">\(Ax=0\)</span>的通解组成的。接下来通过一个例子展示方程组的解法。</p><blockquote><p>【例】 求</p><p><span class="math display">\[\left\{\begin{array}{l}x_1-x_2+2 x_3-2 x_4=0 \\ 2 x_1-x_2-x_3+x_4=1 \\ 3 x_1-2 x_2+x_3-x_4=1\end{array}\right.\]</span></p><p>的通解。 【解】首先写出增广矩阵，也就是系数矩阵右边加上<span class="math inline">\(b\)</span>这一列。 <span class="math display">\[\bar{A}=\left(\begin{array}{ccccc}1 &amp; -1 &amp; 2 &amp; -2 &amp; 0 \\ 2 &amp; -1 &amp; -1 &amp; 1 &amp; 1 \\ 3 &amp; -2 &amp; 1 &amp; -1 &amp; 1\end{array}\right) \rightarrow\left(\begin{array}{ccccc}1 &amp; 0 &amp; -3 &amp; 3 &amp; 1 \\ 0 &amp; 1 &amp; -5 &amp; 5 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\end{array}\right)\]</span> 因此 <span class="math display">\[r(\bar{A})=r(A)=2&lt;4\]</span> 移项，得方程组的一般解为 <span class="math display">\[\left\{\begin{array}{l}x_1=1+3 x_3-3 x_4 \\ x_2=1+5 x_3-5 x_4 \\ x_3=x_3 \\ x_4=x_4\quad\end{array}\right.\]</span></p><p>即： <span class="math display">\[\left(\begin{array}{l}x_1 \\x_2 \\x_3 \\x_4\end{array}\right)=\left(\begin{array}{l}1 \\1 \\0 \\0\end{array}\right)+x_3\left(\begin{array}{l}3 \\5 \\1 \\0\end{array}\right)+x_4\left(\begin{array}{c}-3 \\-5 \\0 \\1\end{array}\right)\]</span></p><p>则取 <span class="math inline">\(\eta_0=(1,1,0,0)^T\)</span> 为一个特解。</p><p><span class="math inline">\(\xi_1=(3,5,1,0)^T, \xi_2=(-3,-5,0,1)^T\)</span> 为导出组的一个基础解系, 从而方程组的通解为</p><p><span class="math display">\[\eta=\eta_0+k_1 \xi_1+k_2 \xi_2\]</span></p></blockquote><h3 id="线性空间和线性子空间">线性空间和线性子空间</h3><p>一般学习线性代数只会学习到向量空间，而不会学习线性空间，所以笔记从线性空间开始写。线性空间是向量空间的推广，为此需要首先定义两个概念：</p><p>【数域】数集<span class="math inline">\(F\)</span>中任意两个元素经过四则运算后的结果仍然在<span class="math inline">\(F\)</span>中，称<span class="math inline">\(F\)</span>为一个数域。</p><p>常见的数域有：</p><ul><li>有理数 <span class="math inline">\(\mathbb Q\)</span></li><li>实数<span class="math inline">\(\mathbb R\)</span></li><li>复数<span class="math inline">\(\mathbb C\)</span></li><li>扩域，例如<span class="math inline">\(\mathbb Q(\sqrt 3)=\{a+b\sqrt 3\mid a,b\in \mathbb Q\}\)</span></li></ul><p>【加群】在非空集合<span class="math inline">\(V\)</span>上定义一种代数运算,称之为<strong>加法</strong>（记为“<span class="math inline">\(+\)</span>” ）,使得<span class="math inline">\(\forall ab\in V\)</span>都有中唯一元素<span class="math inline">\(a+b\)</span>与之对应,该元素称为<span class="math inline">\(a\)</span>与<span class="math inline">\(b\)</span>的和，且满足如下性质</p><ul><li>交换律：<span class="math inline">\(a+b=b+a\)</span></li><li>结合律：<span class="math inline">\((a+b)+c=a+(b+c)\)</span></li><li>存在零：<span class="math inline">\(\exists \theta\in V,s.t.\forall a\in V,a+\theta=a\)</span></li><li>存在负元：<span class="math inline">\(\forall a\in V,\exists -a\in V,s.t.a+(-a)=\theta\)</span></li></ul><p>称<span class="math inline">\((V,+)\)</span>构成一个加群。</p><p>于是，可以将向量空间推广为线性空间：</p><p>【线性空间】 设 <span class="math inline">\((V,+)\)</span> 是一个加群, <span class="math inline">\(F\)</span> 是一个数域. 定义了 <span class="math inline">\(F\)</span> 中的数与 <span class="math inline">\(V\)</span> 中元素的一种代数运算, 称为数乘, 使得 <span class="math inline">\(\forall \lambda \in F, \boldsymbol{\alpha} \in V\)</span>, 有 <span class="math inline">\(V\)</span> 中唯一元素 <span class="math inline">\(\lambda \alpha\)</span> 与之对应, <span class="math inline">\(\lambda \alpha\)</span> 称为 <span class="math inline">\(\lambda\)</span> 与 <span class="math inline">\(\alpha\)</span> 的积, 且满足以下性质:</p><ul><li><p><span class="math inline">\(\lambda(\alpha+\beta)=\lambda\alpha+\lambda\beta\)</span></p></li><li><p><span class="math inline">\((\lambda+\mu) \alpha=\lambda \alpha+\mu \alpha\)</span></p></li><li><p><span class="math inline">\(\lambda(\mu \alpha)=(\lambda \mu) \alpha\)</span></p></li><li><p><span class="math inline">\(1 \alpha=\alpha\)</span></p></li></ul><p>此时，称<span class="math inline">\(V\)</span>为数域<span class="math inline">\(F\)</span>上的线性空间。此时，<span class="math inline">\(V\)</span>中的元素称为「向量」，<span class="math inline">\(F\)</span>中的元素称为「标量」。特别的，如果<span class="math inline">\(F\)</span>是实数域或者复数域，称<span class="math inline">\(V\)</span>为实线性空间或者复线性空间。</p><p>可能向量空间给人一种既定观念，就是向量一定是由标量组合而成的，但是其实并不是这样。考虑正弦函数集合： <span class="math display">\[S=\{a\sin(x+b),a,b\in \mathbb R\}\]</span> 和数域<span class="math inline">\(\mathbb R\)</span>，很显然<span class="math inline">\(S\)</span>在<span class="math inline">\(\mathbb R\)</span>上构成一个线性空间。此时这些正弦函数就是向量，标量仍然是普通的实数。可能很难说「正弦函数」这个东西是由实数组合而成的吧。</p><p>常见的线性空间有：</p><ul><li>向量空间</li><li>矩阵空间，<span class="math inline">\(V\)</span> 是复数域上所有<span class="math inline">\(m\times n\)</span>矩阵构成的集合。</li><li>一元多项式，<span class="math inline">\(V=P_n(x)=\{\sum_{i=0}^n a_ix^i\mid a_i\in \mathbb C\}\)</span></li><li>设<span class="math inline">\(A\in \mathbb C^{m\times n},x\in \mathbb C^n\)</span>，则<span class="math inline">\(Ax=0\)</span>的解集构成线性空间。</li><li>定义在<span class="math inline">\([a,b]\)</span>上的全体多项式、全体可微函数、全体连续函数、全体可积函数、全体实函数，都是<span class="math inline">\(\mathbb R\)</span>上的线性空间。</li></ul><p>在线性空间上有：</p><ul><li><p>零向量唯一</p></li><li><p>任意向量的负向量存在且唯一</p></li><li><p><span class="math inline">\(\forall k\in F,\alpha\in V\)</span> <span class="math display">\[0\alpha=\theta,(-1)\alpha=-\alpha,k\theta=\theta\]</span></p></li><li><p><span class="math inline">\(k\alpha=\theta\to k=0 \or a=\theta\)</span></p></li></ul><p>【线性子空间】设<span class="math inline">\(V\)</span>是<span class="math inline">\(F\)</span>上的线性空间,<span class="math inline">\(V\)</span>是<span class="math inline">\(W\)</span>的非空子集.若<span class="math inline">\(W\)</span>的向量关于<span class="math inline">\(V\)</span>的加法和数乘运算也构成<span class="math inline">\(F\)</span>上的线性空间,则称<span class="math inline">\(W\)</span>是<span class="math inline">\(V\)</span>的子空间。</p><p>例如，平面<span class="math inline">\(xOy\)</span>是三维空间<span class="math inline">\(\mathbb R^3\)</span>的一个线性子空间。但是不能说，<span class="math inline">\(\mathbb R^2\)</span>是<span class="math inline">\(\mathbb R^3\)</span>的线性子空间，因为前者的元素是二维向量，后者的元素是三维向量，二维向量并不是三维向量的子集。可以说，<span class="math inline">\(W=\{(a_1,a_2,0)^T,a_1,a_2\in \mathbb R\}\)</span>是<span class="math inline">\(\mathbb R^3\)</span>的子空间。</p><p>对于子空间的判别，以下三个命题等价：</p><ul><li><span class="math inline">\(W\)</span>是<span class="math inline">\(V\)</span>的子空间</li><li><span class="math inline">\(\forall k\in F,a\in W,ka\in W\)</span>且<span class="math inline">\(\forall a,b\in W,a+b\in W\)</span></li><li><span class="math inline">\(\forall k,l\in F,a,b\in W,ka+lb\in W\)</span></li></ul><p>其实，在实操中，判定子空间，一般首先看<span class="math inline">\(W\)</span>中是否含有零元素。如果不含，那么一定不是子空间。如果包含，再验证第三个命题。</p><p>如果<span class="math inline">\(W_1,W_2\)</span>都是数域<span class="math inline">\(F\)</span>上<span class="math inline">\(V\)</span>的子空间，那么它们的交与和也是<span class="math inline">\(V\)</span>的子空间。其中集合交的定义是显然的，集合的和指的是： <span class="math display">\[W_1+W_2=\{\alpha_1+\alpha_2\mid \alpha_1\in W_1,\alpha_2\in W_2\}\]</span> 而且，交空间是包含于<span class="math inline">\(W_1,W_2\)</span>的最大子空间，和空间是包含了<span class="math inline">\(W_1,W_2\)</span>的最小子空间。两个子空间的并，不一定是子空间。</p><p>对于矩阵<span class="math inline">\(A\in C^{m\times n}\)</span>来说，有两个相当重要的子空间：</p><p>【矩阵零空间】齐次线性方程组<span class="math inline">\(Ax=0\)</span>的解集，记作<span class="math inline">\(N(A)\)</span></p><p>【矩阵列空间】<span class="math inline">\(A\)</span>的列的所有线性组合构成的集合，记作<span class="math inline">\(R(A)\)</span>。列空间也叫做值空间，是因为当且仅当<span class="math inline">\(b\in R(A)\)</span>时，方程<span class="math inline">\(Ax=b\)</span>才是有解的。</p><h3 id="基和坐标">基和坐标</h3><p>首先回顾一下线性相关和线性无关的概念，因为和线代里面的没啥区别，所以不重复写了。</p><p>【极大线性无关组与秩】设 <span class="math inline">\(\boldsymbol{\alpha}_1, \cdots, \boldsymbol{\alpha}_n\)</span> 是线性空间 <span class="math inline">\(V\)</span> 的一组向量. 若 <span class="math inline">\(\boldsymbol{\alpha}_1, \cdots, \boldsymbol{\alpha}_n\)</span> 中存在 <span class="math inline">\(r\)</span> 个线性无关的向量 <span class="math inline">\(\boldsymbol{\alpha}_{i_1}, \cdots, \boldsymbol{\alpha}_{i_r}\)</span>, 并且 <span class="math inline">\(\boldsymbol{\alpha}_1, \cdots, \boldsymbol{\alpha}_n\)</span> 中任一向量均可由向量组 <span class="math inline">\(\boldsymbol{\alpha}_{i_1}, \cdots, \boldsymbol{\alpha}_{i_r}\)</span> 线性表示, 则称向量组 <span class="math inline">\(\boldsymbol{\alpha}_{i_1}, \cdots, \boldsymbol{\alpha}_{i_r}\)</span> 为向量组 <span class="math inline">\(\boldsymbol{\alpha}_1, \cdots, \boldsymbol{\alpha}_n\)</span> 的极大线性无关组,数 <span class="math inline">\(r\)</span> 称为向量组 <span class="math inline">\(\boldsymbol{\alpha}_1, \cdots, \boldsymbol{\alpha}_n\)</span> 的秩, 记为</p><p><span class="math display">\[\operatorname{rank}\left[\boldsymbol{\alpha}_1, \cdots, \boldsymbol{\alpha}_n\right]=r\]</span> 向量组中的任一向量都可由极大线性无关组唯一表示。</p><p>由极大线性无关组，可以定义线性空间的基：</p><p>【基】设<span class="math inline">\(V\)</span>是数域<span class="math inline">\(F\)</span>上的线性空间，<span class="math inline">\(\{\alpha_1\cdots\alpha_n\}\)</span>是<span class="math inline">\(V\)</span>里的一组向量，而且</p><ol type="1"><li><span class="math inline">\(\{\alpha_1\cdots\alpha_n\}\)</span>线性无关</li><li><span class="math inline">\(V\)</span>中所有向量都可以由<span class="math inline">\(\{\alpha_1\cdots\alpha_n\}\)</span>线性表示</li></ol><p>那么说<span class="math inline">\(\{\alpha_1\cdots\alpha_n\}\)</span>是<span class="math inline">\(V\)</span>的一组基。事实上，<span class="math inline">\(V\)</span>中所有向量可以由基唯一表示，这叫唯一表示定理。</p><p>定义了基，其目的就是唯一表示其它的向量。这种表示的方法叫做坐标：</p><p>【坐标】 设 <span class="math inline">\(x_1, \cdots, x_n\)</span> 是数域 <span class="math inline">\(F\)</span> 上线性空间 <span class="math inline">\(V\)</span> 的一组基, 对任意向量 <span class="math inline">\(x \in V\)</span>, 令</p><p><span class="math display">\[\boldsymbol{x}=\sum_{i=1}^n \alpha_i \boldsymbol{x}_i=\left[\boldsymbol{x}_1, \cdots, \boldsymbol{x}_n\right]\left[\begin{array}{c}\alpha_1 \\\vdots \\\alpha_n\end{array}\right]\]</span></p><p>称有序数组 <span class="math inline">\(\left[\alpha_1, \cdots, \alpha_n\right]^T \in F^n\)</span> 是 <span class="math inline">\(x\)</span> 在基 <span class="math inline">\(x_1, \cdots, x_n\)</span> 下的坐标，它由 <span class="math inline">\(x\)</span> 与基 <span class="math inline">\(x_1, \cdots, x_n\)</span> 唯一确定.</p><p>对于两个不同的基，存在过渡矩阵：</p><p>【过渡矩阵】 设 <span class="math inline">\(x_1, \cdots, x_n\)</span> 和 <span class="math inline">\(y_1, \cdots, y_n\)</span> 是数域 <span class="math inline">\(F\)</span> 上线性空间 <span class="math inline">\(V\)</span> 的两组基, 令</p><p><span class="math display">\[\boldsymbol{y}_i=a_{1 i} \boldsymbol{x}_1+\cdots+a_{n i} \boldsymbol{x}_n=\left[\boldsymbol{x}_1, \cdots, \boldsymbol{x}_n\right]\left[\begin{array}{c}a_{1 i} \\\vdots \\a_{n i}\end{array}\right]\]</span></p><p>引入矩阵表示:</p><p><span class="math display">\[\left[y_1, \cdots, y_n\right]=\left[x_1, \cdots, x_n\right] A\]</span></p><p>其中 <span class="math inline">\(A=\left(a_{i j}\right) \in F^{n \times n}\)</span>, 称 <span class="math inline">\(A\)</span> 是由基 <span class="math inline">\(\boldsymbol {x_1, \cdots, x_n}\)</span> 到基 <span class="math inline">\(\boldsymbol{y}_1, \cdots, \boldsymbol{y}_n\)</span> 的过渡矩阵（或变换矩阵）.</p><p>对于<span class="math inline">\(V\)</span>中的任意向量<span class="math inline">\(x\)</span>，设其在基<span class="math inline">\(\{x_1\cdots x_n\}\)</span>中的坐标为<span class="math inline">\(\{\alpha_1\cdots \alpha_n\}\)</span>，在基<span class="math inline">\(\{y_1\cdots y_n\}\)</span>中的坐标为<span class="math inline">\(\{\beta_1\cdots \beta_n\}\)</span>，则有： <span class="math display">\[\left[\begin{array}{c}\beta_1 \\\vdots \\\beta_n\end{array}\right]=A^{-1}\left[\begin{array}{c}\alpha_1 \\\vdots \\\alpha_n\end{array}\right] \text { 或 }\left[\begin{array}{c}\alpha_1 \\\vdots \\\alpha_n\end{array}\right]=A\left[\begin{array}{c}\beta_1 \\\vdots \\\beta_n\end{array}\right]\]</span> 【维数】 在线性空间 <span class="math inline">\(V\)</span> 中, 不同线性无关组中向量个数最大者叫作 <span class="math inline">\(V\)</span> 的维数, 记为 <span class="math inline">\(\operatorname{dim} V\)</span>. 当 <span class="math inline">\(\operatorname{dim} V&lt;\infty\)</span>, 称 <span class="math inline">\(V\)</span> 为有限维空间, 否则称为无限维空间, 记 <span class="math inline">\(\operatorname{dim} V=\infty\)</span>。其实，<span class="math inline">\(\dim V=n\)</span>等价于<span class="math inline">\(V\)</span>的任意一个基的向量个数为<span class="math inline">\(n\)</span>。</p><blockquote><p>例：空间<span class="math inline">\(\mathbb C\)</span>在数域<span class="math inline">\(\mathbb C\)</span>和<span class="math inline">\(\mathbb R\)</span>上的维数分别是多少？</p><p>解：在<span class="math inline">\(\mathbb R\)</span>上，向量组<span class="math inline">\(\{1,i\}\)</span>是<span class="math inline">\(\mathbb C\)</span>的一组基，所以维数是2。在<span class="math inline">\(\mathbb C\)</span>上，向量<span class="math inline">\(1\)</span>和<span class="math inline">\(i\)</span>线性相关,且任一复数均可由<span class="math inline">\(1\)</span>或<span class="math inline">\(i\)</span>线性表示.故向量组<span class="math inline">\(1\)</span>和<span class="math inline">\(i\)</span>分别构成<span class="math inline">\(\mathbb C\)</span>的一组基,即定义在<span class="math inline">\(\mathbb C\)</span>上的线性空间<span class="math inline">\(\mathbb C\)</span>的维数为<span class="math inline">\(1\)</span> .</p></blockquote><p>有维数定理：设<span class="math inline">\(W_1,W_2\)</span>是<span class="math inline">\(V\)</span>的两个子空间，则： <span class="math display">\[\dim (W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)\]</span></p><blockquote><p>【例】设 <span class="math inline">\(W_1=\operatorname{span}\left\{\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2\right\} \quad W_2=\operatorname{span}\left\{\boldsymbol{\beta}_1, \boldsymbol{\beta}_2\right\}\)</span>, 求 <span class="math inline">\(\left(W_1+W_2\right)\)</span> 及 <span class="math inline">\(\left(W_1 \cap W_2\right)\)</span>的维数，其中 <span class="math inline">\(\boldsymbol{\alpha}_1=(1,2,1,0), \boldsymbol{\alpha}_2=(-1,1,1,1), \quad \boldsymbol{\beta}_1=(2,-1,0,1), \quad \boldsymbol{\beta}_2=(1,-1,3,7)\)</span> 。</p><p>【解1】</p><p>要求<span class="math inline">\(W_1+W_2\)</span>的维数，即求<span class="math inline">\(\boldsymbol{\alpha_1,\alpha_2,\beta_2,\beta_2}\)</span>四个向量张成的空间的维数。有： <span class="math display">\[\left[\boldsymbol{\alpha}_1^T, \boldsymbol{\alpha}_2^T, \boldsymbol{\beta}_1^T, \boldsymbol{\beta}_2{ }^T\right]=\left[\begin{array}{cccc}1 &amp; -1 &amp; 2 &amp; 1 \\2 &amp; 1 &amp; -1 &amp; -1 \\1 &amp; 1 &amp; 0 &amp; 3 \\0 &amp; 1 &amp; 1 &amp; 7\end{array}\right]\]</span> 对其进行初等行变换，有： <span class="math display">\[\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -1 \\0 &amp; 1 &amp; 0 &amp; 4 \\0 &amp; 0 &amp; 1 &amp; 3 \\0 &amp; 0 &amp; 0 &amp; 0\end{array}\right]\]</span> 这个矩阵的秩是<span class="math inline">\(3\)</span>，所以<span class="math inline">\(\dim (W_1+W_2)=3\)</span>。</p><p>设<span class="math inline">\(\boldsymbol{x}\in W_1\cap W_2\)</span>，则有： <span class="math display">\[\boldsymbol{x}=k_1\boldsymbol{\alpha}_1+k_2\boldsymbol{\alpha}_2=l_1\boldsymbol{\beta}_1+l_2\boldsymbol{\beta}_2\]</span> 即： <span class="math display">\[\begin{align}k_1-k_2&amp;=2l_1+l_2\\2k_1+k_2&amp;=-l_1-l_2\\k_1+k_2&amp;=0l_1+3l_2\\0k_1+k_2&amp;=l_1+7l_2\\\end{align}\]</span> 移项并化简，有： <span class="math display">\[\begin{bmatrix}1&amp;-1&amp;-2&amp;-1\\2&amp;1&amp;1&amp;1\\1&amp;1&amp;0&amp;-3\\0&amp;1&amp;-1&amp;-7\end{bmatrix}\begin{bmatrix}k_1\\k_2\\l_1\\l_2\end{bmatrix}=O\]</span> 化简，有： <span class="math display">\[\begin{bmatrix}1&amp;-1&amp;-2&amp;-1\\0&amp;1&amp;-1&amp;-7\\0&amp;0&amp;1&amp;3\\0&amp;0&amp;0&amp;0\end{bmatrix}\begin{bmatrix}k_1\\k_2\\l_1\\l_2\end{bmatrix}=O\]</span></p><p>左边的矩阵的秩是<span class="math inline">\(3\)</span>，所以解是一维的。具体一点，有： <span class="math display">\[\begin{cases}k_1&amp;=-l_2 \\k_2&amp;=4 l_2 \\l_1&amp;=-3 l_2\end{cases}\]</span> 代入，有： <span class="math display">\[\boldsymbol{x}=l_2\begin{bmatrix}-5\\2\\3\\4\end{bmatrix}\]</span> 所以，<span class="math inline">\(\dim(W_1\cap W_2)=1\)</span></p><p>【解2】</p><p>显然，<span class="math inline">\(\dim W_1=\dim W_2=2\)</span>，由维数定理： <span class="math display">\[\dim (W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)\]</span> 只需像上面那样求出<span class="math inline">\(\dim (W_1\cap W_2)\)</span>即可，无需算两个矩阵的秩。</p></blockquote><h3 id="内积空间">内积空间</h3><p>在线性空间上，额外定义对于两个向量<span class="math inline">\(\alpha,\beta\)</span>的内积运算，内积运算的结果是数域<span class="math inline">\(F\)</span>中的一个数，且满足：</p><ol type="1"><li>共轭对称性: <span class="math inline">\((x, y)=\overline{(y, x)}\)</span>;</li><li>可加性: <span class="math inline">\((x+y, z)=(x, z)+(y, z)\)</span>;</li><li>齐次性: <span class="math inline">\((k \boldsymbol{x}, \boldsymbol{y})=k(\boldsymbol{x}, \boldsymbol{y})\)</span>;</li><li>正定性: <span class="math inline">\((x, x) \geq 0\)</span>, 当且仅当 <span class="math inline">\(x=\theta\)</span> 时等号成立.</li></ol><p>此时可以称<span class="math inline">\(V\)</span>是一个<strong>内积空间</strong>。有限维的实内积空间叫欧几里得空间，有限维的复内积空间叫酉空间。</p><p>注意，齐次性只对第一个向量成立。对于第二个向量，有共轭齐次性： <span class="math display">\[(x,ky)=\bar k (x,y)\]</span> 考虑<span class="math inline">\(\mathbb C^n\)</span>中的向量<span class="math inline">\(x,y\)</span>，定义运算<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="其中的$y^H$是共轭转置的意思，也就是说$y^H=\bar y^T$">[1]</span></a></sup>： <span class="math display">\[(x,y)=y^HAx\]</span> 那么，<span class="math inline">\(A\)</span>需要满足什么条件，才能使得这个运算成为内积呢？</p><p>由内积定义中的共轭对称性，有： <span class="math display">\[\begin{align}y^HAx&amp;=\overline{x^HAy}\\&amp;=(x^HAy)^H\\&amp;=y^H(x^HA)^H\\&amp;=y^HA^Hx\end{align}\]</span> 这个推导有两点可能需要解释。第一，因为它的结果是个1*1的矩阵，所以共轭可以写作共轭转置。第二，<span class="math inline">\((AB)^H=B^HA^H\)</span></p><p>所以有： <span class="math display">\[A=A^H\]</span> 我们将满足<span class="math inline">\(A=A^H\)</span>的矩阵称为<strong>Hermite矩阵</strong>。此外，还需补充正定性： <span class="math display">\[x^HAx\geq 0\]</span></p><p>将<span class="math inline">\(f(x)=x^HAx\)</span>称为二次型，<span class="math inline">\(A\)</span>为<span class="math inline">\(f(x)\)</span>的矩阵，如果<span class="math inline">\(f(x)\geq0\)</span>且等号仅在<span class="math inline">\(x=\theta\)</span>取得，称<span class="math inline">\(A\)</span>为<strong>正定矩阵</strong>，<span class="math inline">\(f(x)\)</span>为正定二次型。</p><p>【度量矩阵】 设 <span class="math inline">\(\epsilon_1, \cdots, \epsilon_n\)</span> 是内积空间 <span class="math inline">\(V\)</span> 中的一组基, 称 <span class="math inline">\(n\)</span> 阶矩阵</p><p><span class="math display">\[A=\left(\left(\epsilon_i, \epsilon_j\right)\right)_{n \times n}=\left[\begin{array}{cccc}\left(\epsilon_1, \epsilon_1\right) &amp; \left(\epsilon_1, \epsilon_2\right) &amp; \ldots &amp; \left(\epsilon_1, \epsilon_n\right) \\\left(\epsilon_2, \epsilon_1\right) &amp; \left(\epsilon_2, \epsilon_2\right) &amp; \ldots &amp; \left(\epsilon_2, \epsilon_n\right) \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\\left(\epsilon_n, \epsilon_1\right) &amp; \left(\epsilon_n, \epsilon_2\right) &amp; \ldots &amp; \left(\epsilon_n, \epsilon_n\right)\end{array}\right]\]</span></p><p>为 <span class="math inline">\(V\)</span> 关于基 <span class="math inline">\(\epsilon_1, \cdots, \epsilon_n\)</span> 的度量矩阵 (或Gram矩阵),常记为 <span class="math inline">\(G\left(\epsilon_1, \cdots, \epsilon_n\right)\)</span>。度量矩阵和基是一一对应的。</p><p>如果<span class="math inline">\(x,y\in V\)</span>，且其在基 <span class="math inline">\(\epsilon_1, \cdots, \epsilon_n\)</span>下的坐标分别是<span class="math inline">\([\xi_1\cdots\xi n]^T\)</span>和<span class="math inline">\([\eta_1\cdots\eta_n]^T\)</span>，则有： <span class="math display">\[(x,y)=\eta^HG^H\left(\epsilon_1, \cdots, \epsilon_n\right)\xi\]</span> 显然，度量矩阵是正定Hermite矩阵。</p><p>在内积空间中，可以定义一个向量的长度： <span class="math display">\[||x||=\sqrt{(x,x)}\]</span> 长度具有以下的性质：</p><ol type="1"><li><p>齐次：<span class="math inline">\(||kx||=k||x||\)</span></p></li><li><p>正定：不再解释了</p></li><li><p>平行四边形法则： <span class="math display">\[\|x+y\|^2+\|x-y\|^2=2\left(\|x\|^2+\|y\|^2\right)\]</span></p></li><li><p>三角不等式（三角形两边之和大于第三边） <span class="math display">\[\|x+y\|\leq\|x\|+\|y\|\]</span></p></li><li><p>Cauchy-Schwarz不等式（余弦定理） <span class="math display">\[\|x\|\cdot\|y\|\geq|(x,y)|\]</span> 定义两个向量之间的夹角为： <span class="math display">\[\alpha=&lt;x,y&gt;=\arccos \frac{(x,y)}{\|x\|\|y\|}\in[0,\pi]\]</span></p></li></ol><p>由内积和夹角，可以引出正交的概念：</p><p>【正交】对于内积空间<span class="math inline">\(V\)</span>中的两个向量，如果有<span class="math inline">\((x,y)=0\)</span>，称这两个向量正交。一组互相垂直的向量组称为正交向量组，单位向量构成的正交向量组称为标准正交向量组。在<span class="math inline">\(n\)</span>维内积空间中，由<span class="math inline">\(n\)</span>​个向量组成的正交向量组称为正交基，由单位向量组成的正交基称为标准正交基。</p><p>向量正交于集合，指的是对于线性空间<span class="math inline">\(V\)</span>中的一个向量<span class="math inline">\(x\)</span>和子集<span class="math inline">\(W\)</span>，<span class="math inline">\(x\)</span>正交于<span class="math inline">\(W\)</span>中的任何一个向量，那么称<span class="math inline">\(x\)</span>正交于集合<span class="math inline">\(W\)</span>。</p><p>集合正交于集合，指的是线性空间中的两个集合，其中任意两个向量都相互正交。</p><blockquote><p>注意：集合正交于集合并不简单地等同于集合垂直于集合。考虑到3维欧氏空间中的两个相互垂直的平面，它们并不相互正交（因为两个集合的交集上任意两向量共线）。</p></blockquote><p>【正交补】设<span class="math inline">\(W\)</span>是线性空间<span class="math inline">\(V\)</span>的子空间，那么所有和<span class="math inline">\(W\)</span>正交的向量构成的集合称为<span class="math inline">\(W\)</span>的正交补。正交补一定是线性子空间。 <span class="math display">\[W^\perp=\{x\in V\mid x\perp W\}\]</span></p><p>对于正交补，有： <span class="math display">\[W+W^\perp =V\]</span></p><blockquote><p>【例】</p><p><span class="math display">\[\boldsymbol{A}=\left[\begin{array}{ccccc}2 &amp; 1 &amp; -1 &amp; 1 &amp; -3 \\1 &amp; 1 &amp; -1 &amp; 0 &amp; 1\end{array}\right]^T\]</span></p><p>求<span class="math inline">\(A\)</span>的列空间的正交补<span class="math inline">\(R^\perp(A)\)</span>。</p><p>【解】即解方程组： <span class="math display">\[A^Tx=0\]</span> 方程组的解集，就是和<span class="math inline">\(A\)</span>的每一列都正交的向量的集合。化简得： <span class="math display">\[A^T\sim \begin{bmatrix}1&amp;0&amp;0&amp;1&amp;-4\\0&amp;1&amp;-1&amp;-1&amp;5\end{bmatrix}\]</span> 所以，原方程组可为： <span class="math display">\[\begin{cases}x_1=x_4-4x_5\\x_2=-x_3-x_4+5x_5\\x_3=x_3\\x_4=x_4\\x_5=x_5\end{cases}\]</span> 所以，解空间为： <span class="math display">\[x=x_3\begin{bmatrix}0\\-1\\1\\0\\0\end{bmatrix}+x_4\begin{bmatrix}1\\-1\\0\\1\\0\end{bmatrix}+x_5\begin{bmatrix}-4\\5\\0\\0\\1\end{bmatrix}\]</span></p></blockquote><p>其实，有线性代数基本定理：</p><p>行空间 <span class="math inline">\(R\left(A^T\right)\)</span> 和零空间 <span class="math inline">\(N(A)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中的正交补空间；列空间 <span class="math inline">\(R(A)\)</span> 和左零空间 <span class="math inline">\(N\left(A^T\right)\)</span> 是 <span class="math inline">\(\mathbb{R}^m\)</span> 中的正交补空间。</p><h3 id="直和与投影">直和与投影</h3><p>【直和与正交直和】 设 <span class="math inline">\(W_1\)</span> 与 <span class="math inline">\(W_2\)</span> 是线性空间 <span class="math inline">\(V\)</span> 的子空间，若和空间 <span class="math inline">\(W_1+W_2\)</span> 中任意向量均唯一地表示成 <span class="math inline">\(W_1\)</span> 中的一个向量和 <span class="math inline">\(W_2\)</span> 中的一个向量之和， 则称 <span class="math inline">\(W_1+W_2\)</span> 是 <span class="math inline">\(W_1\)</span> 与 <span class="math inline">\(W_2\)</span> 的直和， 记为 <span class="math inline">\(W_1 \dot{+} W_2\)</span>。</p><p>特别的, 若 <span class="math inline">\(V=W_1 \dot{+} W_2\)</span>, 则称表达式 <span class="math inline">\(V=W_1 \dot{+} W_2\)</span> 为直和分解.</p><p>进一步, 若 <span class="math inline">\(W_1 \perp W_2\)</span>, 则称直和 <span class="math inline">\(W_1 \dot{+} W_2\)</span> 是 <span class="math inline">\(W_1\)</span> 与 <span class="math inline">\(W_2\)</span>的正交直和, 记为 <span class="math inline">\(W_1 \oplus W_2\)</span>。</p><p>其实，若 <span class="math inline">\(W_1 \perp W_2\)</span>，则<span class="math inline">\(W_1+W_2=W_1 \oplus W_2\)</span>.</p><blockquote><p>【例】在立体直角坐标系中，<span class="math inline">\(W_1=xOy,W_2=yOz\)</span>，那么<span class="math inline">\(W_1+W_2\)</span>是直和吗？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202410061052487.png" alt="image-20241006105251194" /><figcaption aria-hidden="true">image-20241006105251194</figcaption></figure><p>【解】不是，因为 <span class="math display">\[\left[\begin{array}{l}0 \\1 \\0\end{array}\right]=\left[\begin{array}{c}0 \\\mu+1 \\0\end{array}\right]+\left[\begin{array}{c}0 \\-\mu \\0\end{array}\right]\]</span> 所以分解不唯一。</p></blockquote><p>为了判断一个和是不是直和，有以下四个等价命题：</p><ol type="1"><li><span class="math inline">\(W_1\)</span>+<span class="math inline">\(W_2\)</span>是直和</li><li><span class="math inline">\(W_1+W_2\)</span>中零元素表示方法唯一</li><li><span class="math inline">\(W_1\cap W_2=\theta\)</span></li><li><span class="math inline">\(\dim (W_1+W_2)=\dim W_1+\dim W_2\)</span></li></ol><h3 id="mooc第一章答案">MOOC第一章答案</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">A A C D <span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B </span><span class="hljs-keyword">B </span><span class="hljs-keyword">B </span>C <span class="hljs-keyword">B </span><br><span class="hljs-keyword">B </span><span class="hljs-keyword">BCD </span>CD ABC ABC<br>ABD AD AC <span class="hljs-keyword">BCD </span>C<br><span class="hljs-keyword">BC </span>ABCD <span class="hljs-number">110</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">11101</span><br><span class="hljs-number">11100</span><br><span class="hljs-number">01000</span><br><span class="hljs-number">11001</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">1011</span><br></code></pre></td></tr></table></figure><h2 id="矩阵和线性映射">矩阵和线性映射</h2><h3 id="映射和线性映射">映射和线性映射</h3><p>【单射和满射】对于映射<span class="math inline">\(f:V\to W\)</span>，如果有<span class="math inline">\(\forall x_1,x_2\in V,x_1\neq x_2\to f(x_1)\neq f(x_2)\)</span>，那么<span class="math inline">\(f\)</span>是一个<strong>单射</strong>。<em>也就是说，不同的元素一定被映射为不同的像。</em>如果有<span class="math inline">\(\forall y\in W,\exists x\in V,f(x)=y\)</span>，那么<span class="math inline">\(f\)</span>是一个满射。<em>也就是说，像集里的每个元素都能被取到。</em>如果既是单射又是满射，那么<span class="math inline">\(f\)</span>是双射。<em>也就是说，每个<span class="math inline">\(x\in V\)</span>都有且仅有一个<span class="math inline">\(f(x)\in W\)</span>与其对应。</em></p><blockquote><p>考察实数域<span class="math inline">\(R\to R\)</span>上的函数<span class="math inline">\(f(x)=2x\)</span>和<span class="math inline">\(g(x)=x^2\)</span>。因为<span class="math inline">\(g(1)=g(-2)\)</span>，所以<span class="math inline">\(g\)</span>不是单射；因为<span class="math inline">\(g(x)=-1\)</span>无解，所以<span class="math inline">\(g(x)\)</span>不是满射。<span class="math inline">\(f(x)\)</span>既是单射又是满射，所以<span class="math inline">\(f(x)\)</span>是双射。</p></blockquote><p>【线性映射】如果对于映射<span class="math inline">\(T:V\to W\)</span>和数域<span class="math inline">\(F\)</span>（其中<span class="math inline">\(V,W\)</span>是<span class="math inline">\(F\)</span>上线性空间）满足两条线性性质，称<span class="math inline">\(T\)</span>为<span class="math inline">\(F\)</span>上的线性映射。如果<span class="math inline">\(W=V\)</span>，称为线性变换。</p><ol type="1"><li>可加性：<span class="math inline">\(T(x+y)=T(x)+T(y)\)</span></li><li>齐次性：<span class="math inline">\(\forall \lambda\in F,T(\lambda x)=\lambda T(x)\)</span></li></ol><blockquote><p>【例】对于在其自身上<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="意思就是，线性空间的「数域」也是那个集合Q(√3)">[2]</span></a></sup>的线性空间<span class="math inline">\(Q(\sqrt 3)\)</span>上的映射： <span class="math display">\[T(x+y\sqrt 3)=x\]</span> 不是线性映射。因为<span class="math inline">\(T(\sqrt 3\times \sqrt 3)=3\neq \sqrt 3T(\sqrt 3)\)</span></p></blockquote><p>关于线性映射，有以下推论：</p><ol type="1"><li><p>保持原点不动：<span class="math inline">\(T(\theta)=\theta&#39;\)</span></p></li><li><p>如果<span class="math inline">\(\{\alpha \}\)</span>是<span class="math inline">\(V\)</span>中一组线性<strong>相关</strong>向量，那么<span class="math inline">\(\{T(\alpha)\}\)</span>也是<span class="math inline">\(W\)</span>中一组线性<strong>相关</strong>向量</p></li><li><p>如果<span class="math inline">\(\{T(\alpha) \}\)</span>是<span class="math inline">\(W\)</span>中一组线性<strong>无关</strong>向量，那么<span class="math inline">\(\{\alpha\}\)</span>也是<span class="math inline">\(V\)</span>中一组线性<strong>无关</strong>向量</p></li><li><p>当且仅当<span class="math inline">\(T\)</span>是单射，如果<span class="math inline">\(\{\alpha \}\)</span>是<span class="math inline">\(V\)</span>中一组线性<strong>无关</strong>向量，那么<span class="math inline">\(\{T(\alpha)\}\)</span>也是<span class="math inline">\(W\)</span>中一组线性<strong>无关</strong>向量</p><blockquote><p>如果<span class="math inline">\(W,V\)</span>维数相同，那么此时<span class="math inline">\(V\)</span>中一组基的像是<span class="math inline">\(W\)</span>中的一组基，<span class="math inline">\(T\)</span>是双射</p></blockquote></li></ol><p>与矩阵相似地，定义线性映射<span class="math inline">\(T:V\to W\)</span>的零空间和值空间：</p><ol type="1"><li>零空间：<span class="math inline">\(N(T)=\{x\in V\mid T(x)=\theta\}\)</span>，即使得像为原点的<span class="math inline">\(x\)</span>的值的集合。它的维数叫做<span class="math inline">\(T\)</span>的「亏」。</li><li>值空间：<span class="math inline">\(R(T)=\{y\in W\mid y=T(x),x\in V\}\)</span>，即<span class="math inline">\(T\)</span>的实际取值范围。它的维数叫做<span class="math inline">\(T\)</span>的「秩」。</li></ol><p>【亏加秩定理】线性映射的亏和秩之和等于其定义域空间的维数。 <span class="math display">\[\dim N(T)+\dim R(T)=\dim V\]</span></p><h3 id="矩阵与同构">矩阵与同构</h3><p>【线性映射的矩阵】设 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(W\)</span> 是数域 <span class="math inline">\(F\)</span> 上的线性空间, <span class="math inline">\(\varepsilon_1, \cdots, \varepsilon_n\)</span> 和 <span class="math inline">\(\boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\)</span> 分别是 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(W\)</span> 的基，且 <span class="math inline">\(T \in\)</span> <span class="math inline">\(\mathcal{L}(V, W)\)</span>. 因此 <span class="math inline">\(T\left(\boldsymbol{\varepsilon}_i\right)\)</span> 可由基 <span class="math inline">\(\boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\)</span> 线性表示，即 <span class="math display">\[\begin{gathered}\left\{\begin{array}{c}T\left(\boldsymbol{\varepsilon}_1\right)=a_{11} \boldsymbol{\eta}_1+a_{21} \boldsymbol{\eta}_2+\cdots+a_{m 1} \boldsymbol{\eta}_m \\T\left(\boldsymbol{\varepsilon}_2\right)=a_{12} \boldsymbol{\eta}_1+a_{22} \boldsymbol{\eta}_2+\cdots+a_{m 2} \boldsymbol{\eta}_m \\T\left(\boldsymbol{\varepsilon}_n\right)=a_{1 n} \boldsymbol{\eta}_1+a_{2 n} \boldsymbol{\eta}_2+\cdots+a_{m n} \boldsymbol{\eta}_m\end{array}\right. \\T\left(\boldsymbol{\varepsilon}_1, \cdots, \boldsymbol{\varepsilon}_n\right) =\left[T\left(\boldsymbol{\varepsilon}_1\right), \cdots, T\left(\boldsymbol{\varepsilon}_n\right)\right]=\left[\boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\right] A\end{gathered}\]</span> 其中 <span class="math display">\[A=\left[\begin{array}{cccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\ a_{m 1} &amp; a_{m 2} &amp; \cdots &amp; a_{m n}\end{array}\right] \in F^{m \times n}\]</span> 称为 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(V\)</span> 的基 <span class="math inline">\(\varepsilon_1, \cdots, \varepsilon_n\)</span> 和 <span class="math inline">\(W\)</span> 的基 <span class="math inline">\(\boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\)</span> 下的矩阵.</p><p>简单理解：线性映射的矩阵，就是<span class="math inline">\(V\)</span>中的基的像在<span class="math inline">\(W\)</span>的基下的坐标，依次写成纵列，然后拼接起来。</p><p>当线性空间<span class="math inline">\(V\)</span>和<span class="math inline">\(W\)</span>的基确定后，矩阵<span class="math inline">\(A\)</span>和线性映射<span class="math inline">\(T\)</span>唯一确定。即：有且仅有一个矩阵使得线性映射是<span class="math inline">\(T\)</span>，也有且仅有一个线性映射使得矩阵是<span class="math inline">\(A\)</span>。</p><blockquote><p>【例】已知多项式空间 <span class="math inline">\(P_3[t]\)</span> （即以<span class="math inline">\(t\)</span>为变量的三次多项式空间）的子空间 <span class="math inline">\(W=\operatorname{span}\left\{f_1(t), f_2(t), f_3(t), f_4(t)\right\}\)</span>,其中 <span class="math inline">\(f_1(t)=1+t^3, f_2(t)=t+t^2, \quad f_3(t)=1+t^2, \quad f_4(t)=t+t^3\)</span>.</p><ol type="1"><li>求子空间 <span class="math inline">\(W\)</span> 的一个基;</li><li>对于 <span class="math inline">\(W\)</span> 中的多项式 <span class="math inline">\(f(t)=a_0+a_1 t+a_2 t^2+a_3 t^3\)</span>, 定义线性变换</li></ol><p><span class="math display">\[T[f(t)]=\left(a_0+a_1-a_2-a_3\right)+a_1 t+\left(a_2-a_3\right) t^2+\left(a_0+2 a_1-2 a_2\right) t^3\]</span></p><p>求线性变换 <span class="math inline">\(T\)</span> 在（1）中求出的基下的矩阵.</p><p>【解】</p><ol type="1"><li><p>注意到：<span class="math inline">\(f_4=f_1+f_2-f_3\)</span>，因此一组基为<span class="math inline">\(\{f_1,f_2,f_3\}\)</span></p></li><li><p>计算基象组：</p><p><span class="math inline">\(T[f_1]=-t^2+t^3=f_1-f_3,T[f_2]=t+t^2=f_2,T[f_3]=t^2-t^3=-f_1+f_3\)</span></p><p>因此，矩阵为把基象组依次写成纵列然后拼起来： <span class="math display">\[\left[\begin{array}{rrr}1 &amp; 0 &amp; -1 \\0 &amp; 1 &amp; 0 \\-1 &amp; 0 &amp; 1\end{array}\right]\]</span></p></li></ol></blockquote><p>【同构】设<span class="math inline">\(V,W\)</span>是<span class="math inline">\(F\)</span>上的线性空间，如果有一个既是双射又是线性映射的映射<span class="math inline">\(f:V\to W\)</span>，那么称<span class="math inline">\(V\)</span>和<span class="math inline">\(W\)</span>同构，<span class="math inline">\(f\)</span>是同构映射。同构映射一定可逆，而且其逆映射也是同构映射。</p><blockquote><p>所谓的「同构」，其实就是「一样」，「一回事」的意思。</p></blockquote><p>两个线性空间同构，当且仅当其维数相等。</p><p>【同一个线性映射在不同基下的矩阵的关系】<span class="math inline">\(\operatorname{dim} V=n, \varepsilon_1, \cdots, \boldsymbol{\varepsilon}_n\)</span> 和 <span class="math inline">\(\varepsilon_1^{\prime}, \cdots, \boldsymbol{\varepsilon}_n^{\prime}\)</span> 是 <span class="math inline">\(V\)</span> 的两组基,</p><p><span class="math display">\[\left[\varepsilon_1^{\prime}, \cdots, \boldsymbol{\varepsilon}_n^{\prime}\right]=\left[\varepsilon_1, \cdots, \varepsilon_n\right] Q\]</span></p><p><span class="math inline">\(\operatorname{dim} W=m, \boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\)</span> 和 <span class="math inline">\(\boldsymbol{\eta}_1^{\prime}, \cdots, \boldsymbol{\eta}_m^{\prime}\)</span> 是 <span class="math inline">\(W\)</span> 的两组基,</p><p><span class="math display">\[\left[\boldsymbol{\eta}_1^{\prime}, \cdots, \boldsymbol{\eta}_m^{\prime}\right]=\left[\boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\right] P \]</span></p><p>设 <span class="math inline">\(T \in \mathcal{L}(V, W)\)</span> ， <span class="math display">\[\boldsymbol{T}\left(\boldsymbol{\varepsilon}_1, \cdots, \boldsymbol{\varepsilon}_n\right)=\left[\boldsymbol{\eta}_1, \cdots, \boldsymbol{\eta}_m\right] A\]</span></p><p><span class="math display">\[\boldsymbol{T}\left(\boldsymbol{\varepsilon}_1^{\prime}, \cdots, \boldsymbol{\varepsilon}_n^{\prime}\right)=\left[\boldsymbol{\eta}_1^{\prime}, \cdots, \boldsymbol{\eta}_m^{\prime}\right] B\]</span></p><p>则 <span class="math inline">\(B=P^{-1} A Q\)</span>。即：矩阵<span class="math inline">\(A\)</span>可以通过有限次初等变换变成矩阵<span class="math inline">\(B\)</span>，两矩阵相抵（等价）。</p><p>特别的，如果线性映射是变换，即<span class="math inline">\(V=W\)</span>，那么有： <span class="math display">\[B=P^{-1}AP\]</span> 也就是<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>相似。可以看出，矩阵相似其实就是矩阵等价的特殊情况。</p><h3 id="特征值和特征向量">特征值和特征向量</h3><p>【线性变换的特征值和特征向量】设线性变换 <span class="math inline">\(T \in L(V)\)</span> ，若存在 <span class="math inline">\(\lambda_0 \in F\)</span> 及 <span class="math inline">\(V\)</span> 的<strong>非零向量</strong> <span class="math inline">\(\xi\)</span> 使得</p><p><span class="math display">\[T \xi=\lambda_0 \xi,\]</span></p><p>则称 <span class="math inline">\(\lambda_0\)</span> 是 <span class="math inline">\(T\)</span> 的一个特征值, 称 <span class="math inline">\(\xi\)</span> 为 <span class="math inline">\(T\)</span> 的属于特征值 <span class="math inline">\(\lambda_0\)</span> 的一个特征向量。</p><p>需要注意：</p><ol type="1"><li><p>从几何上来看，就是线性变换作用于特征向量后，仍然保持共线</p></li><li><p>属于同一个特征值的特征向量的线性组合也是属于这个特征值的特征向量</p></li><li><p>如果特征向量是线性变换零空间里的非零向量，那么其特征值是0</p></li><li><p>设 <span class="math inline">\(T\)</span>是线性变换，<span class="math inline">\(\xi_1, \cdots, \xi_n\)</span> 是 <span class="math inline">\(V\)</span> 的一组基, 且<span class="math inline">\(T \xi_i=\lambda_i \xi_i(i=1, \cdots, n)\)</span>, 则 <span class="math inline">\(T\)</span> 在基 <span class="math inline">\(\xi_1, \cdots, \xi_n\)</span> 下的矩阵为对角阵</p></li></ol><p>【矩阵的特征值和特征向量】设 <span class="math inline">\(A \in F^{n \times n}, \lambda\)</span> 为一文字, 矩阵 <span class="math inline">\(\lambda I-A\)</span> 称为 <span class="math inline">\(A\)</span> 的特征矩阵, 其行列式 <span class="math inline">\(|\lambda I-A|\)</span> 称为 <span class="math inline">\(A\)</span> 的特征多项式, 方程 <span class="math inline">\(|\lambda I-A|=0\)</span> 的根称为 <span class="math inline">\(A\)</span> 的特征值（或特征根）. 方程 <span class="math inline">\((\lambda I-A) \boldsymbol{\alpha}=0\)</span> 的非零解向量 <span class="math inline">\(\boldsymbol{\alpha}\)</span> 称为属于特征值 <span class="math inline">\(\lambda\)</span>的特征向量。</p><p><span class="math inline">\(\lambda\)</span> 是线性变换<span class="math inline">\(T\)</span>的特征值，当且仅当它是<span class="math inline">\(T\)</span>的任意一个矩阵的特征值，属于同一<strong>线性变换</strong>的各个矩阵的特征值完全相同。</p><p>由定义可以知道，矩阵的特征值是一个一元<span class="math inline">\(n\)</span>次方程式的根。这个根的重数是特征值的<strong>代数重数</strong>。因此，一个<span class="math inline">\(n\times n\)</span>的矩阵的所有特征值的重数之和是<span class="math inline">\(n\)</span>。有时，我们也说「一个<span class="math inline">\(n\)</span>阶方阵有<span class="math inline">\(n\)</span>个特征值」，注意这里的「个」是要计算重数的。</p><p>一个矩阵的特征值之和等于其对角线上元素之和，这个和也叫做矩阵的「迹」，记作<span class="math inline">\(tr(A)\)</span>。</p><blockquote><p>【例】已知<span class="math inline">\(a=(a_1,\cdots,a_n)^T,b=(b_1,\cdots,b_n)\)</span>，求<span class="math inline">\(A=ab\)</span>的特征多项式，并求<span class="math inline">\(|A|\)</span>。</p><p>【解】显然，<span class="math inline">\(A_{ij}=a_ib_j\)</span>，因此<span class="math inline">\(A\)</span>是一个秩为<span class="math inline">\(1\)</span>的矩阵（每一行都是向量<span class="math inline">\(b\)</span>乘以标量倍）。那么，考虑齐次线性方程组 <span class="math display">\[Ax=0\]</span> 它的基础解系是<span class="math inline">\(n-1\)</span>维的，即矩阵的零空间是<span class="math inline">\(n-1\)</span>维的。从特征方程的角度来看，<span class="math inline">\(Ax=0\)</span>代表<span class="math inline">\(0\)</span>为矩阵<span class="math inline">\(A\)</span>的其一特征值，那么其特征值为<span class="math inline">\(0\)</span>的线性无关的特征向量的个数为<span class="math inline">\(N-1\)</span>，又特征值的代数重数不会少于几何重数，所以<span class="math inline">\(0\)</span>至少为<span class="math inline">\(N-1\)</span>重特征值。</p><p>所以<span class="math inline">\(A\)</span>只有一个非零特征值。所以矩阵的特征多项式具有如下的形式： <span class="math display">\[\lambda^{n-1}(\lambda-x)\]</span> 因为<span class="math inline">\(A\)</span>的特征值之和等于其对角线元素之和，所以 <span class="math display">\[x=\sum_{i=1}^n a_ib_i\]</span></p><p>关于<span class="math inline">\(|A|\)</span>，有： <span class="math display">\[|A|=\begin{cases}0,&amp;n&gt;1\\a_1b_1,&amp;n=1\end{cases}\]</span></p></blockquote><p>【特征子空间】矩阵的属于某个特征值<span class="math inline">\(\lambda\)</span>的全体特征值再加上零向量，构成一个线性空间，叫做属于特征值<span class="math inline">\(\lambda\)</span>的特征子空间，记作 <span class="math display">\[E(\lambda)=\{x\in C^n\mid Ax=\lambda x\}\]</span> 特征子空间的维数是特征值的几何重数。几何重数不会超过代数重数。</p><p>如果所有特征值的几何重数等于代数重数，则矩阵可以相似对角化，即：<span class="math inline">\(B=P^{-1}AP\)</span>，其中<span class="math inline">\(B\)</span>是对角矩阵。</p><h3 id="酉变换和酉矩阵">酉变换和酉矩阵</h3><p>酉变换是实数域中的正交变换推广到复数域中的结果。</p><p>【正交变换和酉变换】若欧氏(酉)空间中的线性变换 <span class="math inline">\(T\)</span> 保持向量的内积不变，即</p><p><span class="math display">\[(T(x), T(y))=(x, y), \forall x, y \in V\]</span></p><p>称 <span class="math inline">\(T\)</span> 为正交(酉)变换。</p><p>【正交矩阵和酉矩阵】如果<span class="math inline">\(n\)</span>阶实方阵满足<span class="math inline">\(AA^T=I\)</span>或者<span class="math inline">\(A^TA=I\)</span>，称为正交矩阵；如果<span class="math inline">\(n\)</span>阶复方阵满足<span class="math inline">\(AA^H=I\)</span>或者<span class="math inline">\(A^HA=I\)</span>，称为酉矩阵。</p><p>标准正交基经过酉变换以后仍然是标准正交基，而且酉变换在标准正交基下的矩阵是酉矩阵。正交/酉变换的核心特征是「保持长度不变」。</p><p>酉矩阵的行列式的模是<span class="math inline">\(1\)</span>，所有特征值的模也是<span class="math inline">\(1\)</span>。</p><p>矩阵是酉矩阵的充要条件是它的<span class="math inline">\(n\)</span>个列向量构成标准正交基。</p><p>常见的酉矩阵有初等旋转矩阵和反射矩阵。</p><p>其中，初等旋转矩阵记为<span class="math inline">\(T(i,j,\varphi)\)</span>，它的形式是，先写出一个<span class="math inline">\(n\)</span>阶单位阵，然后把矩阵 <span class="math display">\[\left[\begin{array}{cc}\cos \varphi &amp; -\sin \varphi \\ \sin \varphi &amp; \cos \varphi\end{array}\right]\]</span> 放到第<span class="math inline">\(i,j\)</span>行<span class="math inline">\(i,j\)</span>列，最后变成这样： <span class="math display">\[T(i, j)=\left(\begin{array}{ccccccccccc}1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\&amp; \ddots &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\&amp; &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\&amp; &amp; &amp; \cos \varphi &amp; 0 &amp; \cdots &amp; 0 &amp; \sin \varphi &amp; &amp; &amp; \\&amp; &amp; &amp; 0 &amp; 1 &amp; &amp; &amp; 0 &amp; &amp; &amp; \\&amp; &amp; &amp; \vdots &amp; &amp; \ddots &amp; &amp; \vdots &amp; &amp; &amp; \\&amp; &amp; &amp; 0 &amp; &amp; &amp; 1 &amp; 0 &amp; &amp; &amp; \\&amp; &amp; &amp; -\sin \varphi &amp; 0 &amp; \cdots &amp; 0 &amp; \cos \varphi &amp; &amp; &amp; \\&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 1 &amp; &amp; \\&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \ddots &amp; \\&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 1\end{array}\right)\]</span> 初等反射矩阵表示了把向量用 以<span class="math inline">\(w\)</span>作为法向量的超平面 作为镜面反射的变换。有： <span class="math display">\[H=I-2ww^H\]</span></p><h3 id="幂等矩阵">幂等矩阵</h3><p>这个书里面并没有，但是慕课作业里面有很多相关的内容，所以整理一下。</p><p>幂等矩阵指的是满足<span class="math inline">\(A=A^2\)</span>的矩阵。从几何上看，幂等矩阵代表了一种投影变换，因为投影一次（<span class="math inline">\(Ax\)</span>）和投影两次（<span class="math inline">\(A^2x\)</span>）的结果一样。一个典型的幂等矩阵是： <span class="math display">\[A=\begin{pmatrix}1 &amp;0 &amp;0\\0 &amp;1 &amp;0\\0 &amp;0 &amp;0\end{pmatrix}\]</span> 它就是把三维坐标投影到前两个维度构成的平面上的投影变换。</p><p>关于幂等矩阵<span class="math inline">\(P\)</span>的性质，有：</p><ol type="1"><li><p><span class="math inline">\(N(P)=R(I-P),R(P)=N(I-P)\)</span></p><p>证明：注意到幂等矩阵的定义等价为<span class="math inline">\(P(I-P)=0\)</span>。设<span class="math inline">\(x\in N(P)\)</span>，即<span class="math inline">\(Px=0\)</span>，则<span class="math inline">\(x=x-Px=(I-P)x\)</span>，则<span class="math inline">\(x\in R(I-P)\)</span>。</p><p>若<span class="math inline">\(x\in R(I-P)\)</span>，即<span class="math inline">\((I-P)y=x\)</span>，故<span class="math inline">\(Px=P(I-P)y=0\)</span>。</p><p>因为<span class="math inline">\((I-P)(I-P)=I^2-2P+P^2=I-P\)</span>，所以<span class="math inline">\(I-P\)</span>也是幂等矩阵，故第二部分证毕。</p><blockquote><p><span class="math inline">\(P-I\)</span>不是幂等矩阵，因为<span class="math inline">\((P-I)^2=P^2-2P+I^2=I-P\)</span>。</p></blockquote></li><li><p><span class="math inline">\(R(P)\cap N(P)=\theta\)</span></p><p>证明：设<span class="math inline">\(x\in R(P)\cap N(P)\)</span>，则有<span class="math inline">\(x=Py,x=(I-P)z\)</span>，有<span class="math inline">\(z=Py+Pz\)</span>，两边同时乘以<span class="math inline">\(P\)</span>：<span class="math inline">\(Pz=Py+Pz\)</span>，则<span class="math inline">\(x=Py=0\)</span></p></li><li><p><span class="math inline">\(\text{rank} P=\dim N(I-P)\)</span></p><p>由第一条性质易得</p></li><li><p><span class="math inline">\(\text{rank} P+\text{rank} (I-P)=n\)</span></p><p>亏加秩定理：<span class="math inline">\(\dim R(P)+\dim C(P)=\dim R(P)+\dim R(I-P)=n\)</span></p></li><li><p>可对角化为<span class="math inline">\(\text{diag}\{1,1\cdots 1,0,0,\cdots,0\}\)</span></p><p>考虑任意一个特征值，有<span class="math inline">\(Px=\lambda x\)</span>，则<span class="math inline">\(P^2x=\lambda^2x\)</span>，但是<span class="math inline">\(P^2=P\)</span>，故<span class="math inline">\(\lambda^2=\lambda\)</span>，<span class="math inline">\(\lambda=0 \text{or}1\)</span>。</p><p>其中，如果特征值为<span class="math inline">\(1\)</span>，其特征子空间是<span class="math inline">\(N(P-I)\)</span>，如果特征值为<span class="math inline">\(0\)</span>，其特征子空间是<span class="math inline">\(N(P)\)</span>.</p><p>这两个特征子空间的基底合并以后可以生成<span class="math inline">\(R^n\)</span>。</p></li><li><p><span class="math inline">\(\text{rank} P=\text{tr} P\)</span></p><p>特征值<span class="math inline">\(1\)</span>的代数重数。</p></li></ol><h3 id="mooc第二章答案">MOOC第二章答案</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span> C ACD BC BD<br><span class="hljs-attribute">AB</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">1</span> BD <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> B A A B<br></code></pre></td></tr></table></figure><h2 id="矩阵分解">矩阵分解</h2><h3 id="满秩分解">满秩分解</h3><p>【满秩分解】设<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>的秩为<span class="math inline">\(r\)</span>的矩阵，记作<span class="math inline">\(A\in \mathbb C^{m\times n}_r\)</span>，则存在<span class="math inline">\(B\in \mathbb C^{m\times r}_r\)</span>和<span class="math inline">\(C\in \mathbb C^{r\times n}_r\)</span>，使得 <span class="math display">\[A=BC\]</span></p><blockquote><p>证明：假设<span class="math inline">\(A=[\boldsymbol{a_1,a_2,\cdots,a_n}]\)</span>，取<span class="math inline">\(R(A)\)</span>的一组基<span class="math inline">\([\boldsymbol{b_1,b_2,\cdots,b_r}]\)</span>，则有： <span class="math display">\[\boldsymbol{a_i=[b_1\cdots b_r]}c_i\]</span> 定义<span class="math inline">\(B=\boldsymbol{[b_1\cdots b_r]},C=\boldsymbol{[c_1\cdots c_n]}\)</span>，则有： <span class="math display">\[A=BC\]</span> 其中，<span class="math inline">\(rank(B)=r\)</span> 又因为<span class="math inline">\(rank(c)\geq rank(A)=r,rank(C)\leq r\)</span></p><p>所以<span class="math inline">\(rank(C)=r\)</span>.</p></blockquote><p>可以看到，满秩分解取决于<span class="math inline">\(R(A)\)</span>上基的选取，所以满秩分解并不唯一。</p><blockquote><p>【例】求 <span class="math display">\[\begin{pmatrix}i &amp; 1 &amp; 1\\1 &amp; -i &amp; 1\end{pmatrix}\]</span> 的满秩分解。</p><p>【解】观察得，<span class="math inline">\([\boldsymbol{a_1,a_3}]\)</span>构成<span class="math inline">\(R(A)\)</span>的一组基。 则向量<span class="math inline">\(\boldsymbol{a_1,a_2,a_3}\)</span>在这组基下的坐标分别是： <span class="math display">\[c_1=[1,0]^T,c_2=[-i,0]^T,c_3=[0,1]^T\]</span></p><p>故满秩分解为： <span class="math display">\[A=BC=\begin{pmatrix}i &amp;1\\  1 &amp;1\\  \end{pmatrix} \times \begin{pmatrix}1 &amp;-i &amp;0\\   0 &amp;0 &amp;1\\  \end{pmatrix}\]</span></p></blockquote><p>那么如果观察不出来怎么办呢？其实也有通用方法：</p><blockquote><p>【例】求以下矩阵的满秩分解： <span class="math display">\[A=\left[\begin{array}{cccc}-1 &amp; 0 &amp; 1 &amp; 2 \\1 &amp; 2 &amp; -1 &amp; 1 \\2 &amp; 2 &amp; -2 &amp; -1\end{array}\right]\]</span> 【解】</p><ol type="1"><li><p>先通过初等行变换把它变成行最简形： <span class="math display">\[A\sim \left[\begin{array}{cccc}1 &amp; 0 &amp; -1 &amp; -2 \\0 &amp; 1 &amp; 0 &amp; \frac{3}{2} \\0 &amp; 0 &amp; 0 &amp; 0\end{array}\right]\]</span></p></li><li><p>观察每一行的首元出现在哪一列，把原矩阵的这些列抽出来，组合在一起，作为<span class="math inline">\(F\)</span>矩阵： <span class="math display">\[F=\left[\begin{array}{cc}-1 &amp; 0 \\1 &amp; 2 \\2 &amp; 2\end{array}\right]\]</span></p></li><li><p>观察每一行的首元出现在哪一行，把行最简矩阵的这些行抽出来，组合在一起，作为<span class="math inline">\(G\)</span>矩阵： <span class="math display">\[G=\left[\begin{array}{rrrr}1 &amp; 0 &amp; -1 &amp; -2 \\0 &amp; 1 &amp; 0 &amp; \frac{3}{2}\end{array}\right]\]</span></p></li><li><p>有： <span class="math display">\[A=FG\]</span></p></li></ol></blockquote><p>【矩阵的左右逆】设矩阵<span class="math inline">\(A\in \mathbb C^{m\times n}_r\)</span>，如果存在<span class="math inline">\(B\)</span>使得<span class="math inline">\(AB=I\)</span>，称<span class="math inline">\(B\)</span>是<span class="math inline">\(A\)</span>的右逆；如果存在矩阵<span class="math inline">\(B\)</span>使得<span class="math inline">\(BA=I\)</span>，称<span class="math inline">\(B\)</span>是<span class="math inline">\(A\)</span>的左逆。矩阵存在右逆的充要条件是它是行满秩矩阵；矩阵存在左逆的充要条件是它是列满秩矩阵。</p><p>关于矩阵的秩有重要结论： <span class="math display">\[\text{rank}(A)=\text{rank}(AA^H)=\text{rank}(A^HA)=\text{rank}(A^H)\]</span></p><h3 id="qr分解">QR分解</h3><p>【QR分解】如果复（实）方阵<span class="math inline">\(A\)</span>可以分解为： <span class="math display">\[A=QR\]</span> 其中<span class="math inline">\(Q\)</span>是酉（正交）矩阵，<span class="math inline">\(R\)</span>是上三角矩阵，则称<span class="math inline">\(A\)</span>可以被QR分解。QR分解也叫酉三角分解（正交三角分解）。</p><p>如果实数方阵<span class="math inline">\(A\)</span>是满秩的，那么它可以被QR分解，而且分解方法唯一。</p><blockquote><p>证明：设<span class="math inline">\(A=[\boldsymbol{a_1\cdots a_n}]\)</span>，那么这个向量组是<span class="math inline">\(\mathbb R^n\)</span>的一组基。把这组基进行施密特正交化，得到标准正交基<span class="math inline">\([\boldsymbol{z_1\cdots z_n}]\)</span>。注意到<span class="math inline">\(\{\boldsymbol{a}\}\)</span>,<span class="math inline">\(\{\boldsymbol{z}\}\)</span>都是空间的基，有： <span class="math display">\[[\boldsymbol{a_1\cdots a_n}]=[\boldsymbol{z_1\cdots z_n}]R\]</span> 其中<span class="math inline">\(R\)</span>是过度矩阵。</p><p>考虑施密特正交化的过程： <span class="math display">\[y_k=a_k-\sum_{i=1}^{k-1}(a_k,z_i)z_i\\\\z_k=\dfrac {y_k}{\|y_k\|}\]</span> 则有 <span class="math display">\[R=\left[\begin{array}{cccc}\left\|y_1\right\| &amp; \left(a_2, z_1\right) &amp; \cdots &amp; \left(a_n, z_1\right) \\&amp; \left\|y_2\right\| &amp; \cdots &amp; \left(a_n, z_2\right) \\&amp; &amp; \ddots &amp; \vdots \\&amp; 0 &amp; &amp; \left\|y_n\right\|\end{array}\right]\]</span></p></blockquote><p>也可以用初等反射变换求QR分解，具体操作方法是：</p><ol type="1"><li><p>取<span class="math inline">\(a_1\)</span>为矩阵<span class="math inline">\(A\)</span>的第一列构成的列向量，计算其<span class="math inline">\(2\)</span>范数<span class="math inline">\(\alpha_1\)</span></p></li><li><p>构造： <span class="math display">\[u_1=\frac{a_1-\alpha_1e_1}{\|a_1-\alpha_1e_1\|}\]</span></p></li><li><p>构造： <span class="math display">\[\tilde{H}_1=I-2u_1u_1^T\]</span></p></li><li><p>计算： <span class="math display">\[\tilde{H}_1A\]</span> 其结果的第一列除了第一个元素以外都是<span class="math inline">\(0\)</span>，即： <span class="math display">\[\begin{bmatrix}a_{11} &amp;\cdots\\O &amp;A_2\end{bmatrix}\]</span></p></li><li><p>对矩阵<span class="math inline">\(A_2\)</span>递归进行前四步，最终得到的即为<span class="math inline">\(R\)</span>矩阵。</p></li><li><p><span class="math inline">\(Q\)</span>矩阵的计算方法是： <span class="math display">\[Q=H_nH_{n-1}\cdots H_1\]</span> 其中： <span class="math display">\[H_n=\begin{bmatrix}I_{n-1} &amp;O\\O &amp;\tilde{H_n}\end{bmatrix}\]</span></p></li></ol><blockquote><p>【例】计算QR分解：</p><p><span class="math display">\[A=\left(\begin{array}{lll}0 &amp; 4 &amp; 1 \\1 &amp; 1 &amp; 1 \\0 &amp; 3 &amp; 2\end{array}\right)\]</span></p><p>【解】</p><p>$$ <span class="math display">\[\begin{align}a_1 &amp; =\left(\begin{array}{l}0 \\1 \\0\end{array}\right), \alpha_1=1 \\u_1 &amp; =\frac{a_1-\alpha_1 \cdot e_1}{\| a_1-\alpha_1 e_1 \|}=\frac{1}{\sqrt{2}}\left(\begin{array}{c}-1 \\1 \\0\end{array}\right) \\H_1 &amp; =I-2 u_1 u_1^T \\&amp; =I-2 \cdot\left(\frac{1}{\sqrt{2}}\right)^2 \cdot\left(\begin{array}{c}-1 \\1 \\0\end{array}\right)\left(\begin{array}{lll}-1 &amp; 1&amp;0\end{array}\right) \\&amp; =\left(\begin{array}{ccc}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right) \\H_1 A_1 &amp; =\left(\begin{array}{lll}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 2 \\0 &amp; 0 &amp; 1\end{array}\right)\left(\begin{array}{lll}0 &amp; 4 &amp; 1 \\1 &amp; 1 &amp; 1 \\0 &amp; 3 &amp; 2\end{array}\right) \\&amp; =\left(\begin{array}{lll}1 &amp; 1 &amp; 1 \\0 &amp; 4 &amp; 1 \\0 &amp; 3 &amp; 2\end{array}\right)\end{align}\]</span> $$</p><p>则：</p><p><span class="math display">\[A_2=\left(\begin{array}{ll}4 &amp; 1 \\ 3&amp;2\end{array}\right)\]</span></p><p><span class="math display">\[\begin{aligned}a_2 &amp; =\binom{4}{3} \quad \alpha_2=5 \\\tilde{u}_2 &amp; =\frac{a_2-\alpha_2 e_2}{\| a_2-\alpha_1 e_{2}\|}=\frac{1}{\sqrt{10}}\binom{-1}{3} \\\tilde{H}_2 &amp; =I-2 \tilde{u}_2 \tilde{u}_2 ^T \\&amp; =\left(\begin{array}{cc}\dfrac{4}{5} &amp; \dfrac{3}{5} \\\dfrac{3}{5} &amp; -\dfrac{4}{5}\end{array}\right) \\\tilde{H}_2A_2&amp;=\left(\begin{array}{cc}5 &amp; 2 \\0 &amp; -1\end{array}\right) \\\end{aligned}\]</span></p><p>则：</p><p><span class="math display">\[\begin{aligned}&amp; R=\left[\begin{array}{ccc}1 &amp; 1 &amp; 1 \\0 &amp; 5 &amp; 2 \\0 &amp; 0 &amp; -1\end{array}\right] \\&amp; Q=\left(\begin{array}{cc}1 &amp; 0 \\0 &amp; \tilde{H_2}\end{array}\right) \cdot H_1=\left(\begin{array}{ccc}0 &amp; \frac{4}{5} &amp; \frac{3}{5} \\1 &amp; 0 &amp; 0 \\0 &amp; \frac{1}{5} &amp; -\frac{4}{5}\end{array}\right)\end{aligned}\]</span></p></blockquote><p>接下来考察长方形矩阵的QR分解。</p><p>【列/行正交规范矩阵】设<span class="math inline">\(Q\in \mathbb C^{m\times n}\)</span>，若 <span class="math display">\[Q^HQ=I_n\]</span> 则称<span class="math inline">\(Q\)</span>是列正交规范矩阵，<span class="math inline">\(Q^H\)</span>是行正交规范矩阵。</p><p>考虑 <span class="math display">\[B=\left[\begin{array}{ll}3 &amp; 0 \\0 &amp; 1 \\4 &amp; 0\end{array}\right]\]</span> 的QR分解。按照上面的施密特正交化法，有： <span class="math display">\[B=\left[\begin{array}{ll}3 &amp; 0 \\0 &amp; 1 \\4 &amp; 0\end{array}\right]=\left[\begin{array}{cc}\frac{3}{5} &amp; 0 \\0 &amp; 1 \\\frac{4}{5} &amp; 0\end{array}\right]\left[\begin{array}{cc}5 &amp; 0 \\0 &amp; 1\end{array}\right]=Q_1R_1\]</span> 其中<span class="math inline">\(Q_1\)</span>是列正交规范矩阵。我们把它的列补齐成<span class="math inline">\(C^3\)</span>的标准正交基： <span class="math display">\[Q_1=\left[\begin{array}{cc}\frac{3}{5} &amp; 0 \\0 &amp; 1 \\\frac{4}{5} &amp; 0\end{array}\right] \rightarrow Q=\left[\begin{array}{ccc}\frac{3}{5} &amp; 0 &amp; -\frac{4}{5} \\0 &amp; 1 &amp; 0 \\\frac{4}{5} &amp; 0 &amp; \frac{3}{5}\end{array}\right]\]</span> 则有： <span class="math display">\[B=\left[\begin{array}{ll}3 &amp; 0 \\0 &amp; 1 \\4 &amp; 0\end{array}\right]=\left[\begin{array}{ccc}\frac{3}{5} &amp; 0 &amp; -\frac{4}{5} \\0 &amp; 1 &amp; 0 \\\frac{4}{5} &amp; 0 &amp; \frac{3}{5}\end{array}\right]\left[\begin{array}{ll}5 &amp; 0 \\0 &amp; 1 \\0 &amp; 0\end{array}\right]=Q R\]</span> 所以 <span class="math inline">\(A \in \mathbb{C}_n^{m \times n}\)</span> 可分解为 <span class="math inline">\(A=U R\)</span>, 其中, <span class="math inline">\(U\)</span> 是 <span class="math inline">\(m\)</span>阶酉矩阵, <span class="math inline">\(R=\left[\begin{array}{c}R_1 \\ 0\end{array}\right]_{m \times n}, R_1\)</span> 为正线上三角阵, <span class="math inline">\(n \leq m\)</span>.</p><h3 id="schur分解和矩阵多项式">Schur分解和矩阵多项式</h3><p>【Schur引理】任意复方阵 <span class="math inline">\(A\)</span> 相似于上三角阵，即存在可逆矩阵<span class="math inline">\(P\)</span>使得<span class="math inline">\(\Lambda=P^{-1}AP\)</span>，且<span class="math inline">\(\Lambda\)</span>的对角元素是<span class="math inline">\(A\)</span>的特征值。进一步，任意复方阵 <span class="math inline">\(A\)</span> 酉相似于上三角阵 <span class="math inline">\(\Lambda\)</span>, 即存在酉矩阵 <span class="math inline">\(U\)</span> 使得 <span class="math inline">\(U^H A U=\Lambda\)</span> 为上三角阵。</p><p>【矩阵多项式】 设 <span class="math inline">\(A \in \mathbb{C}^{n \times n}\)</span>, 定义数域 <span class="math inline">\(\mathbb{C}\)</span> 上的多项式</p><p><span class="math display">\[\varphi(\lambda)=a_n \lambda^n+a_{n-1} \lambda^{n-1}+\cdots+a_1 \lambda+a_0,\]</span></p><p>式中, <span class="math inline">\(a_i \in \mathbb{C}, i=0,1, \cdots, n\)</span>. 则</p><p><span class="math display">\[\varphi(A)=a_n A^n+a_{n-1} A^{n-1}+\cdots+a_1 A+a_0 I\]</span></p><p>称为矩阵多项式。</p><p>其实矩阵多项式就是把普通多项式的变量变成了一个矩阵。</p><p>我们可以利用Schur引理来研究矩阵多项式的性质，例如：</p><p>【定理】设复矩阵<span class="math inline">\(A\)</span>的特征值为<span class="math inline">\(\lambda_1\cdots\lambda_n\)</span>，<span class="math inline">\(\phi(\lambda)\)</span>是任意多项式，那么<span class="math inline">\(\phi(A)\)</span>的特征值是<span class="math inline">\(\phi(\lambda_1)\cdots\phi(\lambda_n)\)</span>。</p><blockquote><p>【证明】：存在一个酉矩阵<span class="math inline">\(U\)</span>，使得 <span class="math display">\[U^HAU=\Lambda\]</span> 其中<span class="math inline">\(\Lambda\)</span>是上三角阵，其对角线元素是<span class="math inline">\(A\)</span>的特征值。注意到： <span class="math display">\[\phi(A)=\phi(U\Lambda U^H)=U\phi(\Lambda)U^H\]</span> 其中上三角阵<span class="math inline">\(\phi(\Lambda)\)</span>的对角线元素是<span class="math inline">\(\phi(\lambda_1)\cdots\phi(\lambda_n)\)</span>，由于<span class="math inline">\(\phi(A)\)</span>酉相似于<span class="math inline">\(\phi(\Lambda)\)</span>，所以它们有相同的特征值，证毕。</p></blockquote><p>【Hamilton-Cayley定理】设<span class="math inline">\(f_A(\lambda)=|\lambda I-A|\)</span>是<span class="math inline">\(A\)</span>的特征多项式，那么<span class="math inline">\(f_A(A)=O\)</span>。即：矩阵是自己的特征多项式的根。</p><blockquote><p>【证明】：<span class="math inline">\(f_A(\lambda)\)</span>可以表示为： <span class="math display">\[f_A(\lambda)=\prod_{i=1}^n(\lambda-\lambda_i)\]</span> 则由shur引理，有<span class="math inline">\(P^{-1}AP=\Lambda\)</span>，<span class="math inline">\(f_A(A)\)</span>可以表示为： <span class="math display">\[f_A(P\Lambda P^{-1})=P\prod_{i=1}^n(\Lambda-\lambda_1I)P^{-1}\]</span> 因为上三角阵相乘，对角线元素相乘，所以中间的累乘式结果是<span class="math inline">\(O\)</span>，证毕。</p></blockquote><p>接下来介绍关于矩阵的几个重要多项式：</p><p>【零化多项式】如果多项式<span class="math inline">\(f(\lambda)\)</span>满足<span class="math inline">\(f(A)=O\)</span>，称其为矩阵<span class="math inline">\(A\)</span>的零化多项式。</p><blockquote><p>不难发现，矩阵的特征多项式就是一个典型的零化多项式。</p></blockquote><p>【最小多项式】矩阵的零化多项式中，最小次数且最高次项系数为<span class="math inline">\(1\)</span>的多项式称为最小多项式，记作<span class="math inline">\(m_A(\lambda)\)</span>。</p><blockquote><p>矩阵的特征多项式不一定是最小多项式。例如二阶单位矩阵，其特征多项式是<span class="math inline">\((\lambda-1)^2\)</span>，但是最小多项式是<span class="math inline">\((\lambda-1)\)</span>。</p></blockquote><p>关于最小多项式，有以下结论：</p><ol type="1"><li>矩阵的最小多项式唯一，而且可以整除任何零化多项式</li><li>矩阵的最小多项式的根与特征多项式相同（不计重数）</li></ol><p>据此，可以知道一个求矩阵的最小多项式的方法，就是先求它的特征多项式，并写成根的分解的形式，然后将每一项的次数置为<span class="math inline">\(1\)</span>，验证是否是零化多项式，如果不是， 就挨个提高次数，直到发现一个零化多项式为止。</p><blockquote><p>【例】求最小多项式： <span class="math display">\[\begin{bmatrix}3 &amp; -3 &amp; 2\\-1 &amp; 5 &amp;-2\\-1 &amp; 3 &amp; 0\\\end{bmatrix}\]</span> 【解】矩阵的特征多项式为： <span class="math display">\[(\lambda-2)^2(\lambda-4)\]</span> 因此最小多项式可能是<span class="math inline">\((\lambda-2)(\lambda-4)\)</span>或者<span class="math inline">\((\lambda-2)^2(\lambda-4)\)</span></p><p>验证第一个，有： <span class="math display">\[(A-2I)(A-4I)=O\]</span> 因此最小多项式是<span class="math inline">\((\lambda-2)(\lambda-4)\)</span>。</p></blockquote><h3 id="对角化分解">对角化分解</h3><p>【定义：单纯矩阵】如果<span class="math inline">\(n\)</span>阶复方阵相似于对角矩阵<span class="math inline">\(\Lambda\)</span>，即存在<span class="math inline">\(n\)</span>阶可逆矩阵<span class="math inline">\(P\)</span>，使得 <span class="math display">\[P^{-1}AP=\Lambda\]</span> 则称<span class="math inline">\(A\)</span>​是单纯矩阵，也叫可对角化矩阵。单纯阵的定义式就是单纯阵的对角化分解式，它实际上是Schur分解的一种特殊形式（Schur分解是「上三角阵」，对角化分解是「对角矩阵」）。</p><p>关于单纯矩阵，以下命题等价：</p><ol type="1"><li><span class="math inline">\(A\)</span>是单纯矩阵</li><li><span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量</li><li>特征值<span class="math inline">\(\lambda_i,i=1\cdots m\)</span>的代数重数等于几何重数</li><li><span class="math inline">\(\sum_{i=1}^m \dim E(\lambda_i)=n\)</span></li><li>最小多项式无重根</li></ol><p>关于单纯矩阵，还有两个充分而不必要条件：</p><ol type="1"><li>如果复方阵的零化多项式无重根，那么它是单纯矩阵</li><li>如果<span class="math inline">\(n\)</span>阶复方阵有<span class="math inline">\(n\)</span>个互异的特征值，那么它是单纯矩阵</li></ol><blockquote><p>【例】之前分析过的<a href="https://blog.sakizuki.site/2024/10/05/%E7%9F%A9%E9%98%B5%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/#%E5%B9%82%E7%AD%89%E7%9F%A9%E9%98%B5">幂等矩阵</a>是单纯矩阵吗？</p><p>【解】幂等矩阵是满足<span class="math inline">\(A^2=A\)</span>的矩阵，显然<span class="math inline">\(g(\lambda)=\lambda^2-\lambda\)</span>是它的一个零化多项式，无重根，所以<span class="math inline">\(A\)</span>是单纯矩阵。</p></blockquote><p>【酉相似对角化】如果<span class="math inline">\(n\)</span>阶复方阵<span class="math inline">\(A\)</span>酉相似于对角矩阵<span class="math inline">\(\Lambda\)</span>，即存在<span class="math inline">\(n\)</span>阶酉矩阵，使得<span class="math inline">\(U^HAU=\Lambda\)</span>，那么称<span class="math inline">\(A\)</span>是可酉相似对角化的。</p><p>设矩阵<span class="math inline">\(A\in \mathbb{C}^{n\times n}\)</span>，那么<span class="math inline">\(A\)</span>是Hermit矩阵（<span class="math inline">\(A=A^H\)</span>）当且仅当<span class="math inline">\(A\)</span>的所有特征值<span class="math inline">\(\lambda_1\cdots \lambda_n\)</span>是实数，而且存在酉矩阵<span class="math inline">\(U\)</span>，使得<span class="math inline">\(U^HAU=\text{diag}\{\lambda_1\cdots \lambda_n\}\)</span>.</p><p>求Hermite矩阵<span class="math inline">\(A\)</span>酉相似于对角阵的步骤如下:</p><ol type="1"><li>求出<span class="math inline">\(A\)</span>所有的相异特征值和重数</li><li>对于每个特征值，求<span class="math inline">\((\lambda I-A)x=0\)</span>的基础解系，并将其单位正交化</li><li>由标准正交特征向量生成酉矩阵<span class="math inline">\(Q\)</span>，则<span class="math inline">\(Q^HAQ\)</span>是酉矩阵</li></ol><p>【正规矩阵】设<span class="math inline">\(A\in \mathbb{C}^{n\times n}\)</span>，则满足<span class="math inline">\(AA^H=A^HA\)</span>的矩阵称为正规矩阵。</p><p>复方阵<span class="math inline">\(A\)</span>是正规矩阵，和<span class="math inline">\(A\)</span>酉相似于对角阵等价。</p><p>关于正规矩阵，有：</p><ol type="1"><li><p>显然：正规矩阵的单纯矩阵的加强版。</p></li><li><p>复方阵 <span class="math inline">\(A\)</span> 是正规矩阵当且仅当 <span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个特征向量构成 <span class="math inline">\(\mathbb{C}^n\)</span> 空间的一组标准正交基，且属于 <span class="math inline">\(A\)</span> 的不同特征值的特征向量正交.</p></li><li><p><span class="math inline">\(n\)</span> 阶实方阵 <span class="math inline">\(A\)</span> 是正交矩阵当且仅当 <span class="math inline">\(A\)</span> 的所有特征值的模值为 1 , 且存在酉矩阵 <span class="math inline">\(U\)</span> 使得</p></li></ol><p><span class="math display">\[   U^H A U=\operatorname{diag}\left(\lambda_1, \cdots, \lambda_n\right)   \]</span></p><p>其中 <span class="math inline">\(\lambda_1, \cdots, \lambda_n\)</span> 是 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(n\)</span> 个特征值.</p><ol start="4" type="1"><li><span class="math inline">\(n\)</span> 阶复方阵 <span class="math inline">\(A\)</span> 是酉矩阵当且仅当 <span class="math inline">\(A\)</span> 的所有特征值的模值为 1 , 且存在酉矩阵 <span class="math inline">\(U\)</span> 使得</li></ol><p><span class="math display">\[   U^H A U=\operatorname{diag}\left(\lambda_1, \cdots, \lambda_n\right)   \]</span></p><p>其中 <span class="math inline">\(\lambda_1, \cdots, \lambda_n\)</span> 是 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(n\)</span> 个特征值.</p><ol start="5" type="1"><li>常见的正規矩陣有：实对称矩阵、Hermitian矩阵、酉矩阵、反Hermitian矩阵</li></ol><h3 id="谱分解">谱分解</h3><p>接下来进一步研究单纯矩阵和正规矩阵的性质。</p><h4 id="单纯矩阵谱分解">单纯矩阵谱分解</h4><p>单纯矩阵<span class="math inline">\(A\in \mathbb C^{n\times n}\)</span>可以写成一系列幂等矩阵的加权和的形式，其中的权是<span class="math inline">\(A\)</span>的特征值： <span class="math display">\[A=\sum_{i=1}^n\lambda_iA_i\]</span></p><blockquote><p>【证明】：</p><p>因为<span class="math inline">\(A\)</span>是单纯矩阵，有： <span class="math display">\[A=P\times \text{diag}\{\lambda_1,\cdots,\lambda_n\}\times P^{-1}\]</span> 把<span class="math inline">\(P,P^{-1}\)</span>按行列进行分块，有： <span class="math display">\[P=\left(v_1, v_2, \cdots, v_n\right), P^{-1}=\left(\begin{array}{c}\omega_1^T \\\omega_2^T \\\vdots \\\omega_n^T\end{array}\right)\]</span> 在这里，<span class="math inline">\(v_i\)</span>其实就是属于<span class="math inline">\(\lambda_i\)</span>的特征向量。</p><p>则有： <span class="math display">\[A=\sum_{i=1}^n v_i\lambda_iw_i^T=\sum_{i=1}^n\lambda_iA_i\]</span> 其中 <span class="math display">\[A_i=v_iw_i^T\]</span> 下证<span class="math inline">\(A_i\)</span>是幂等矩阵。由<span class="math inline">\(P^{-1}P=I\)</span>，有： <span class="math display">\[w_i^Tv_i=1\]</span> 则有： <span class="math display">\[A_i^2=(v_iw_i^T)(v_iw_i^T)=v_i(w_i^Tv_i)w_i^T=v_iw_i^T=A_i\]</span> 证毕。</p><p>其实，可用同样的方法证明：<span class="math inline">\(A_iA_j=O(i\neq j)\)</span>。</p></blockquote><p>进一步的，如果更一般的情况，即有<span class="math inline">\(m&lt;n\)</span>个特征值，其中<span class="math inline">\(d_i\)</span>是特征值<span class="math inline">\(\lambda_i\)</span>的重数， 有： <span class="math display">\[A=\sum_{i=1}^m \lambda_iE_i\]</span> 其中 <span class="math display">\[E_i=\sum_{j=1}^{d_i} \alpha _{ij}\beta^{H}_{ij}\]</span> 其中，<span class="math inline">\(\alpha_{ij}\)</span>是第<span class="math inline">\(i\)</span>个特征值的第<span class="math inline">\(j\)</span>个特征向量，<span class="math inline">\(\beta_{ij}\)</span>可由<span class="math inline">\(P^{-1}\)</span>求出</p><blockquote><p>【例】计算谱分解： <span class="math display">\[\boldsymbol{A}=\left[\begin{array}{rrr}4 &amp; 6 &amp; 0 \\-3 &amp; -5 &amp; 0 \\-3 &amp; -6 &amp; 1\end{array}\right]\]</span> 【解】先计算特征值： <span class="math display">\[\lambda_1=\lambda_2=1,\lambda_3=-2\]</span> 对应的特征向量为： <span class="math display">\[\boldsymbol{\alpha}_1=[2,-1,0]^{\mathrm{T}}, \quad \boldsymbol{\alpha}_2=[0,0,1]^{\mathrm{T}}, \quad \boldsymbol{\alpha}_3=[-1,1,1]^{\mathrm{T}}\]</span> 则有： <span class="math display">\[\boldsymbol{P}=\left[\begin{array}{rrr}2 &amp; 0 &amp; -1 \\-1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1\end{array}\right], \quad \boldsymbol{P}^{-1}=\left[\begin{array}{rrr}1 &amp; 1 &amp; 0 \\-1 &amp; -2 &amp; 1 \\1 &amp; 2 &amp; 0\end{array}\right]\]</span> 则： <span class="math display">\[\boldsymbol{\beta}_1=[1,1,0]^{\mathrm{T}}, \boldsymbol{\beta}_2=[-1,-2,1]^{\mathrm{T}}, \boldsymbol{\beta}_3=[1,2,0]^{\mathrm{T}} .\]</span> 由定义： <span class="math display">\[\begin{aligned}&amp; \boldsymbol{E}_1=\boldsymbol{\alpha}_1 \boldsymbol{\beta}_1^{\mathrm{H}}+\boldsymbol{\alpha}_2 \boldsymbol{\beta}_2^{\mathrm{H}}=\left[\begin{array}{rrr}2 &amp; 2 &amp; 0 \\-1 &amp; -1 &amp; 0 \\-1 &amp; -2 &amp; 1\end{array}\right] \\&amp; \boldsymbol{E}_2=\boldsymbol{\alpha}_3 \boldsymbol{\beta}_3^{\mathrm{H}}=\left[\begin{array}{rrr}-1 &amp; -2 &amp; 0 \\1 &amp; 2 &amp; 0 \\1 &amp; 2 &amp; 0\end{array}\right]\end{aligned}\]</span></p></blockquote><p>关于单纯矩阵的谱分解，有性质：</p><ol type="1"><li><span class="math inline">\(E_i=E^2_i\)</span></li><li><span class="math inline">\(E_iE_j=O(i\neq j)\)</span></li><li><span class="math inline">\(E_iA=AE_i=\lambda_iE_i\)</span></li><li><span class="math inline">\(\sum_{i=1}^mE_i=I\)</span></li><li>集合<span class="math inline">\(\{E_i\}\)</span>唯一</li></ol><p>有推论：</p><p>若<span class="math inline">\(f(\lambda)\)</span>是一个多项式，有： <span class="math display">\[f(A)=\sum_{i=1}^m f(\lambda_i)E_i\]</span> 进一步，若设<span class="math inline">\(f_i(\lambda)=\prod_{l=1,l\neq i}^m (\lambda-\lambda_l)\)</span>，则有： <span class="math display">\[E_i=\frac{\prod_{l=1,l\neq i}^{m} (A-\lambda_lI)}{\prod_{l=1,l\neq i}^{m} (\lambda_i-\lambda_l)}\]</span></p><blockquote><p>例】计算谱分解： <span class="math display">\[\boldsymbol{A}=\left[\begin{array}{rrr}4 &amp; 6 &amp; 0 \\-3 &amp; -5 &amp; 0 \\-3 &amp; -6 &amp; 1\end{array}\right]\]</span> 【解】先计算特征值： <span class="math display">\[\lambda_1=\lambda_2=1,\lambda_3=-2\]</span> 定义 <span class="math inline">\(f_1(\lambda)=\lambda+2, f_2(\lambda)=\lambda-1\)</span>, 则</p><p><span class="math display">\[\begin{aligned}&amp; \boldsymbol{E}_1=\frac{1}{f_1\left(\lambda_1\right)} f_1(\boldsymbol{A})=\left[\begin{array}{rrr}2 &amp; 2 &amp; 0 \\-1 &amp; -1 &amp; 0 \\-1 &amp; -2 &amp; 1\end{array}\right] \\&amp; \boldsymbol{E}_2=\frac{1}{f_2\left(\lambda_2\right)} f_2(\boldsymbol{A})=\left[\begin{array}{rrr}-1 &amp; -2 &amp; 0 \\1 &amp; 2 &amp; 0 \\1 &amp; 2 &amp; 0\end{array}\right]\end{aligned}\]</span></p></blockquote><h4 id="正规矩阵的谱分解">正规矩阵的谱分解</h4><p>正规矩阵是单纯矩阵的特殊情况。在正规矩阵的谱分解中，<span class="math inline">\(E_i\)</span>都是正交矩阵。而且有： <span class="math display">\[E_i=\sum_{k=1}^{d_i} u_{ik}u_{ik}^H\]</span> 其中<span class="math inline">\(u_i\)</span>是属于<span class="math inline">\(\lambda_i\)</span>的单位正交的特征向量们。</p><blockquote><p>【例】求正规矩阵的谱分解 <span class="math display">\[\boldsymbol{A}=\left[\begin{array}{rrrr}0 &amp; 1 &amp; 1 &amp; -1 \\ 1 &amp; 0 &amp; -1 &amp; 1 \\ 1 &amp; -1 &amp; 0 &amp; 1 \\ -1 &amp; 1 &amp; 1 &amp; 0\end{array}\right]\]</span> 【解】计算矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的特征值与特征向量, 分别为: <span class="math inline">\(\lambda_1=\lambda_2=\lambda_3=1\)</span> ，<span class="math inline">\(\boldsymbol{\beta}_1=[1,1,0,0]^{\mathrm{T}}, \boldsymbol{\beta}_2=[1,0,1,0]^{\mathrm{T}}, \boldsymbol{\beta}_3=[-1,0,0,1]^{\mathrm{T}} ; \lambda_4=-3, \boldsymbol{\beta}_4=[1,-1,-1,1]^{\mathrm{T}}\)</span>.</p><p>将 <span class="math inline">\(\boldsymbol{\beta}_1, \boldsymbol{\beta}_2\)</span> 和 <span class="math inline">\(\boldsymbol{\beta}_3\)</span> 单位正交化, 并将 <span class="math inline">\(\boldsymbol{\beta}_4\)</span> 单位化, 得 <span class="math display">\[\begin{gathered}\boldsymbol{\alpha}_1=\left[\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}, 0,0\right]^{\mathrm{T}} \\\boldsymbol{\alpha}_2=\left[\frac{1}{\sqrt{6}},-\frac{1}{\sqrt{6}}, \frac{2}{\sqrt{6}}, 0\right]^{\mathrm{T}} \\\boldsymbol{\alpha}_3=\left[-\frac{1}{\sqrt{12}}, \frac{1}{\sqrt{12}}, \frac{1}{\sqrt{12}}, \frac{3}{\sqrt{12}}\right]^{\mathrm{T}} \\\cdot \boldsymbol{\alpha}_4=\left[\frac{1}{2},-\frac{1}{2},-\frac{1}{2}, \frac{1}{2}\right]^{\mathrm{T}}\end{gathered}\]</span></p><p>定义 <span class="math inline">\(\boldsymbol{E}_1=\boldsymbol{\alpha}_1 \boldsymbol{\alpha}_1^{\mathrm{H}}+\boldsymbol{\alpha}_2 \boldsymbol{\alpha}_2^{\mathrm{H}}+\boldsymbol{\alpha}_3 \boldsymbol{\alpha}_3^{\mathrm{H}}, \boldsymbol{E}_2=\boldsymbol{\alpha}_1 \boldsymbol{\alpha}_4^{\mathrm{H}}\)</span>, 则 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{E}_1-3 \boldsymbol{E}_2\)</span> 是 <span class="math inline">\(\boldsymbol{A}\)</span> 的谱分解式。</p></blockquote><h3 id="若当标准型">若当标准型</h3><p>接下来讨论不单纯的矩阵，也就是不能相似对角化的矩阵，如果非要把它相似对角化会怎样。</p><h4 id="lambda矩阵与三个重要因子"><span class="math inline">\(\lambda\)</span>矩阵与三个重要因子</h4><p>【<span class="math inline">\(\lambda\)</span>矩阵】如果矩阵<span class="math inline">\(A\)</span>的元素都是<span class="math inline">\(\lambda\)</span>多项式，那么矩阵<span class="math inline">\(A\)</span>称为<span class="math inline">\(\lambda\)</span>矩阵。</p><p>例如，我们经常见到的特征矩阵<span class="math inline">\(\lambda I-A\)</span>就是一个典型的<span class="math inline">\(\lambda\)</span>矩阵。</p><p><span class="math inline">\(\lambda\)</span>矩阵的的秩定义为其非零子式的最大阶数。<span class="math inline">\(\lambda\)</span>矩阵可逆，等价于其行列式<span class="math inline">\(|A(\lambda)|\)</span>是非零的<strong>常数</strong>。</p><p><span class="math inline">\(\lambda\)</span>矩阵也可以进行初等行列变换，即：</p><ol type="1"><li>交换行/列顺序</li><li>给某一行/列乘以非零常数</li><li>给某一行/列乘以一个<span class="math inline">\(\lambda\)</span>多项式然后加到另一行/列上。</li></ol><p>若<span class="math inline">\(A(\lambda)\)</span>经过有限次初等变换变为<span class="math inline">\(B(\lambda)\)</span>，称这两个矩阵相抵。与数字矩阵不同的是，秩相同的<span class="math inline">\(\lambda\)</span>矩阵不一定相抵。<span class="math inline">\(\lambda\)</span>矩阵如果要相抵，除了秩相同以外，还要有相同的各阶行列式因子。</p><p>【行列式因子】一个矩阵的<span class="math inline">\(k\)</span>阶行列式因子定义为其全部<span class="math inline">\(k\)</span>阶子式的首<span class="math inline">\(1\)</span>最大公因子，记为<span class="math inline">\(D_k(\lambda)\)</span>。</p><p>【不变因子】不变因子可以通过下面的形式计算： <span class="math display">\[d_1=D_1,d_2=\frac {D_2}{D_1},\cdots,d_n=\frac{D_n}{D_{n-1}}\]</span></p><p>不变因子的前一项总是后一项的因子，而且有：</p><p><span class="math display">\[D_k =\prod _{i=1}^k d_k\]</span></p><p>一个矩阵的特征矩阵的不变因子的最后一项<span class="math inline">\(d_n\)</span>即为原矩阵的最小多项式。</p><p>【初等因子】把每个不变因子分解成一次因式的幂的乘积形式，所有这些一次因式的幂的集合（相同的必须按出现次数重复计算）称为矩阵的初等因子组。</p><blockquote><p>【例】求矩阵 <span class="math display">\[\begin{bmatrix}\lambda+1 &amp; 2 &amp; -6\\1 &amp; \lambda &amp; -3\\1 &amp; 1 &amp; \lambda-4\\\end{bmatrix}\]</span> 的各阶行列式因子、初等因子和不变因子</p><p>【解】<strong>先求行列式因子：</strong></p><p>三阶行列式因子： <span class="math display">\[\begin{vmatrix}\lambda+1 &amp; 2 &amp; -6\\1 &amp; \lambda &amp; -3\\1 &amp; 1 &amp; \lambda-4\\\end{vmatrix}=(\lambda-1)^3\]</span> 二阶行列式因子：</p><p>求矩阵的9个子式的最大公因式，例如： <span class="math display">\[\begin{vmatrix}\lambda+1 &amp; 2 \\1 &amp; \lambda\\\end{vmatrix}=(\lambda-1)(\lambda+2)\]</span></p><p><span class="math display">\[\begin{vmatrix}2 &amp; -6 \\\lambda &amp;-3\\\end{vmatrix}=6(\lambda-1)\]</span></p><p>等等。最终算出来最大公因式是<span class="math inline">\((\lambda-1)\)</span>。</p><p>一阶行列式因子：</p><p>即所有元素的最大公因式：<span class="math inline">\(1\)</span></p><p><strong>求不变因子：</strong> <span class="math display">\[d_1=D_1=1\]</span></p><p><span class="math display">\[d_2=\frac{D_2}{D_1}=\lambda-1\]</span></p><p><span class="math display">\[d_3=\frac{D_3}{D_2}=(\lambda-1)^2\]</span></p><p><strong>求初等因子：</strong> <span class="math display">\[(\lambda-1),(\lambda-1)^2\]</span></p></blockquote><p>设 <span class="math inline">\(\lambda\)</span> 矩阵 <span class="math inline">\(A(\lambda)\)</span> 为对角块矩阵, 即</p><p><span class="math display">\[A(\lambda)=\operatorname{diag}\left(A_1(\lambda), \cdots, A_s(\lambda)\right)\]</span></p><p>则 <span class="math inline">\(A_1(\lambda), \cdots, A_S(\lambda)\)</span> 初等因子的全体就是 <span class="math inline">\(A(\lambda)\)</span> 的全部初等因子，其中 <span class="math inline">\(A_i(\lambda), i=1, \cdots, s\)</span> 是适当阶数的 <span class="math inline">\(\lambda\)</span>矩阵。</p><h4 id="史密斯标准型">史密斯标准型</h4><p>一个<span class="math inline">\(\lambda\)</span>矩阵的史密斯标准型为： <span class="math display">\[A(\lambda)=\left(\begin{array}{llllll}d_1(\lambda) &amp; &amp; &amp; &amp; &amp; &amp; \\&amp; d_2(\lambda) &amp; &amp; &amp; &amp; &amp; \\&amp; &amp; \ddots &amp; &amp; &amp; &amp;\\&amp; &amp; &amp; d_r(\lambda) &amp; &amp; &amp; \\&amp; &amp; &amp; &amp; 0 &amp; &amp;\\&amp; &amp; &amp; &amp; &amp; \ddots &amp; \\&amp; &amp; &amp; &amp; &amp; &amp;0\end{array}\right)\]</span> 其中<span class="math inline">\(d(\lambda)\)</span>是矩阵的不变因子。</p><p>史密斯标准型的求法是：</p><ol type="1"><li><p>确定原矩阵的一阶行列式因子</p></li><li><p>通过初等变换，把原矩阵的左上角元素变成<span class="math inline">\(d_1=D_1\)</span></p></li><li><p>通过初等变换，把原矩阵的第一行、第一列除了第一个以外的元素都变成<span class="math inline">\(0\)</span>，此时矩阵为： <span class="math display">\[\begin{bmatrix}d_1 &amp;0\\0 &amp;B_1(\lambda)\end{bmatrix}\]</span></p></li><li><p>对<span class="math inline">\(B_1(\lambda)\)</span>递归进行前三步。</p></li></ol><blockquote><p>【例】求史密斯标准型： <span class="math display">\[\left(\begin{array}{ccc}-\lambda+1 &amp; 2 \lambda-1 &amp; \lambda \\\lambda &amp; \lambda^2 &amp; -\lambda \\\lambda^2+1 &amp; \lambda^2+\lambda-1 &amp; -\lambda^2\end{array}\right)\]</span> 【解】</p><p>计算一阶行列式因子<span class="math inline">\(D_1=1\)</span>，则： <span class="math display">\[\begin{align}A(\lambda)=&amp;\left(\begin{array}{ccc}-\lambda+1 &amp; 2 \lambda-1 &amp; \lambda \\\lambda &amp; \lambda^2 &amp; -\lambda \\\lambda^2+1 &amp; \lambda^2+\lambda-1 &amp; -\lambda^2\end{array}\right) \\\stackrel{C_3+C_1}{\simeq}&amp;\left(\begin{array}{ccc}1 &amp; 2 \lambda-1 &amp; \lambda \\0 &amp; \lambda^2 &amp; -\lambda \\1 &amp; \lambda^2+\lambda-1 &amp; -\lambda^2\end{array}\right)\\\stackrel{-R_1+R_3}{\simeq}&amp;\left(\begin{array}{ccc}1 &amp; 2 \lambda-1 &amp; \lambda \\0 &amp; \lambda^2 &amp; -\lambda \\0 &amp; \lambda^2-\lambda &amp; -\lambda^2-\lambda\end{array}\right)\\\stackrel{}{\simeq}&amp;\left(\begin{array}{c|cc}1 &amp; 0 &amp; 0 \\\hline 0 &amp; \lambda^2 &amp; -\lambda \\0 &amp; \lambda^2-\lambda &amp; -\lambda^2-\lambda\end{array}\right)\end{align}\]</span> 计算右下方子矩阵的一阶行列式因子：<span class="math inline">\(\lambda\)</span> <span class="math display">\[\begin{align}&amp;\left(\begin{array}{c|cc}1 &amp; 0 &amp; 0 \\\hline 0 &amp; \lambda^2 &amp; -\lambda \\0 &amp; \lambda^2-\lambda &amp; -\lambda^2-\lambda\end{array}\right)\\\stackrel{C_2\leftrightarrow C_3}{\simeq} &amp;\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; -\lambda &amp; \lambda^2 \\0 &amp; -\lambda^2-\lambda &amp; \lambda^2-\lambda\end{array}\right)\\\stackrel{-R_2}{\simeq} &amp;\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \lambda &amp; -\lambda^2 \\0 &amp; -\lambda^2-\lambda &amp; \lambda^2-\lambda\end{array}\right)\\\stackrel{(\lambda+1)R_2+R_3}{\simeq} &amp;\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \lambda &amp; -\lambda^2 \\0 &amp; 0 &amp; -\lambda^3-\lambda\end{array}\right)\\\stackrel{\lambda C_2+C_3}{\simeq} &amp;\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \lambda &amp; 0 \\0 &amp; 0 &amp; -\lambda^3-\lambda\end{array}\right)\\\stackrel{-R_3}{\simeq} &amp;\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \lambda &amp; 0 \\0 &amp; 0 &amp; \lambda^3+\lambda\end{array}\right)\\\end{align}\]</span></p></blockquote><h4 id="若当标准型的求法">若当标准型的求法</h4><p>假如矩阵有一个不变因子是<span class="math inline">\((\lambda-k)^n\)</span>，那么它对应一个<span class="math inline">\(n\)</span>阶，主对角线元素为<span class="math inline">\(k\)</span>，主对角线上一行元素为<span class="math inline">\(1\)</span>的若当块。</p><p>对于矩阵<span class="math inline">\(A\)</span>的特征矩阵<span class="math inline">\(\lambda I-A\)</span>的初等因子组，它们对应的若当块以任意顺序组合，就是矩阵的若当标准型。</p><blockquote><p>【例】已知三阶矩阵<span class="math inline">\(A\neq 2I\)</span>，且<span class="math inline">\(A^2-4A+4I=O\)</span>，求其若当标准型。</p><p>【解】因为 <span class="math display">\[(A-2I)^2=O\]</span> 所以<span class="math inline">\((A-2I)^2\)</span>是<span class="math inline">\(A\)</span>的一个零化多项式。又因为<span class="math inline">\(A-2I\neq O\)</span>，所以是最小多项式。</p><p>考虑<span class="math inline">\(A\)</span>的特征矩阵<span class="math inline">\(\lambda A-I\)</span>，其行列式<span class="math inline">\(|\lambda A-I|\)</span>是其所有不变因子的积（史密斯标准型），也是矩阵的特征多项式。所以，其所有初等因子的最小公倍式就是<span class="math inline">\(A\)</span>的最小多项式<span class="math inline">\((A-2I)^2\)</span>，所以其初等因子组是<span class="math inline">\((\lambda-2),(\lambda-2)^2\)</span>，其若当标准型为： <span class="math display">\[\begin{bmatrix}2&amp; 0&amp; 0\\0&amp; 2 &amp;1\\0&amp; 0&amp;2\end{bmatrix}\]</span></p><p>【例2】 <span class="math inline">\(\boldsymbol{A} \in C^{8 \times 8}, \quad \lambda \boldsymbol{I}-\boldsymbol{A} \cong \operatorname{diag}\left\{\lambda^2+1,1, \lambda^2-2,1, \lambda^2, \lambda, \lambda+1,1\right\}\)</span> 。求 <span class="math inline">\(\lambda \boldsymbol{I}-\boldsymbol{A}\)</span> 的初等因子,不变因子, 及 Smith 标准型。写出 <span class="math inline">\(\boldsymbol{A}\)</span> 的 Jordan 标准型及最小多项式。</p><p>【解2】初等因子为：<span class="math inline">\((\lambda-i),(\lambda+i),(\lambda-\sqrt 2),(\lambda+\sqrt2),\lambda^2,\lambda,(\lambda+1)\)</span></p><p>考虑矩阵：<span class="math inline">\(\text{diag}\{1,1,1,\lambda,\lambda+1,\lambda^2,\lambda^2+1,\lambda^2-2\}\)</span>，先求其各阶行列式因子，再由行列式因子求出不变因子和史密斯标准型。</p><ol type="1"><li><span class="math inline">\(D_1=D_2=D_3=1\)</span></li><li>求<span class="math inline">\(D_4\)</span>，因为<span class="math inline">\(\lambda\)</span>和<span class="math inline">\(\lambda+1\)</span>的最大公因式为<span class="math inline">\(1\)</span>，因此<span class="math inline">\(D_4=1\)</span></li><li>求<span class="math inline">\(D_5\)</span>，因为<span class="math inline">\(\lambda\cdot \lambda^2\)</span>和<span class="math inline">\((\lambda+1)(\lambda^2-2)\)</span>的最大公因式为<span class="math inline">\(1\)</span>，因此<span class="math inline">\(D_5=1\)</span></li><li>求<span class="math inline">\(D_6\)</span>，因为<span class="math inline">\(\lambda^3(\lambda+1)\)</span>、<span class="math inline">\(\lambda^3(\lambda^2-2)\)</span>和<span class="math inline">\((\lambda+1)(\lambda^2-2)(\lambda^2+1)\)</span>的最大公因式为<span class="math inline">\(1\)</span>，因此<span class="math inline">\(D_6=1\)</span></li><li>求<span class="math inline">\(D_7\)</span>，因为原来的矩阵有<span class="math inline">\(8\)</span>项，求<span class="math inline">\(D_7\)</span>即选择其中的<span class="math inline">\(7\)</span>项相乘。如果不选<span class="math inline">\(\lambda\)</span>，那么必选<span class="math inline">\(\lambda^2\)</span>；如果不选<span class="math inline">\(\lambda^2\)</span>，那么必选<span class="math inline">\(\lambda\)</span>，因此<span class="math inline">\(\lambda\)</span>必定是其中一个公因式，而且是最大公因式。</li><li>求<span class="math inline">\(D_8\)</span>，为<span class="math inline">\(\lambda^3(\lambda+1)(\lambda^2-2)(\lambda^2+1)\)</span></li></ol><p>因此，矩阵不变因子为： <span class="math display">\[d_1=d_2=d_3=d_4=d_5=d_6=1\]</span></p><p><span class="math display">\[d_7=\lambda,d_8=\lambda^2(\lambda+1)(\lambda^2-2)(\lambda^2+1)\]</span></p><p>史密斯标准型为： <span class="math display">\[\begin{bmatrix}1&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\&amp;1&amp;&amp;&amp;&amp;&amp;&amp;\\&amp;&amp;1&amp;&amp;&amp;&amp;&amp;\\&amp;&amp;&amp;1&amp;&amp;&amp;&amp;\\&amp;&amp;&amp;&amp;1&amp;&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;1&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;&amp; \lambda &amp;\\&amp;&amp;&amp;&amp;&amp;&amp;&amp; \lambda^2(\lambda+1)(\lambda^2-2)(\lambda^2+1) \\\end{bmatrix}\]</span> 若当标准型为： <span class="math display">\[\left[\begin{array}{cccccccc}0 &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp; \\&amp; 0 &amp; &amp; &amp; &amp; &amp; &amp; \\&amp; &amp; 0 &amp; &amp; &amp; &amp; &amp; \\&amp; &amp; &amp; i &amp; &amp; &amp; &amp; \\&amp; &amp; &amp; &amp; -i &amp; &amp; &amp; \\&amp; &amp; &amp; &amp; &amp; \sqrt{2} &amp; &amp; \\&amp; &amp; &amp; &amp; &amp; &amp; -\sqrt{2} &amp; \\&amp; &amp; &amp; &amp; &amp; &amp; &amp; -1\end{array}\right]\]</span> 最小多项式为： <span class="math display">\[m(\lambda)=d_8=\lambda^2(\lambda+1)(\lambda^2-2)(\lambda^2+1)\]</span></p></blockquote><h3 id="mooc第三章答案">MOOC第三章答案</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">C</span> <span class="hljs-built_in">C</span> <span class="hljs-variable">CD</span> <span class="hljs-variable">A</span> <span class="hljs-variable">B</span><br><span class="hljs-variable">B</span> <span class="hljs-built_in">D</span> <span class="hljs-variable">A</span> <span class="hljs-variable">ACD</span> <span class="hljs-variable">ABCD</span><br><span class="hljs-variable">AC</span> <span class="hljs-variable">CD</span> <span class="hljs-built_in">C</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">D</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">1</span> <span class="hljs-built_in">C</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">D</span><br><span class="hljs-built_in">C</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <span class="hljs-variable">A</span><br><span class="hljs-variable">B</span> <span class="hljs-variable">ABC</span> <span class="hljs-variable">ABCD</span> <span class="hljs-variable">BC</span> <span class="hljs-variable">AD</span><br><span class="hljs-variable">ABCD</span> <span class="hljs-variable">BC</span> <span class="hljs-variable">AD</span> <span class="hljs-variable">ABC</span> <span class="hljs-number">1</span><br><span class="hljs-number">00111</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">01101</span><br><span class="hljs-number">11111</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">00111</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">01111</span><br><span class="hljs-number">0</span> <span class="hljs-variable">ABCD</span> <span class="hljs-number">111</span><br><span class="hljs-number">1111</span> <span class="hljs-variable">BC</span><br><span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h2 id="矩阵分析">矩阵分析</h2><h3 id="向量范数">向量范数</h3><p>【向量范数】设<span class="math inline">\(V\)</span>是数域<span class="math inline">\(F\)</span>上的线性空间，<span class="math inline">\(\|x\|\)</span>是<span class="math inline">\(x\in V\)</span>的实值函数，如果满足：</p><ol type="1"><li>正定：<span class="math inline">\(\|x\|\geq 0\)</span>且当且仅当<span class="math inline">\(x=\theta\)</span>时，<span class="math inline">\(\|x\|=0\)</span></li><li>齐次：<span class="math inline">\(\forall k\in F,\|kx\|=k\|x\|\)</span></li><li>三角不等式：<span class="math inline">\(\forall x,y\in V,\|x+y\|\leq \|x\|+\|y\|\)</span></li></ol><p>称其为向量的范数，称这个线性空间为赋范线性空间。</p><p>有以下三种常用的范数：</p><ol type="1"><li><span class="math inline">\(\|x\|_1=\sum_i |x_i|\)</span>，即所有元素的绝对值之和</li><li><span class="math inline">\(\|x\|_\infty=\max_i |x_i|\)</span>，即所有元素的绝对值中的最大值</li><li><span class="math inline">\(\|x\|_2=\sqrt {\sum_i |x_i|^2}\)</span>，即我们日常使用的「欧氏距离」</li><li><span class="math inline">\(\|x\|_p=\left(\sum _i |x_i|^p\right)^{\frac 1p}\)</span>，其中<span class="math inline">\(p\in [1,\infty]\)</span>，上面三个范数都是它的特殊情况。</li></ol><blockquote><p>问：内积空间是赋范线性空间吗？</p><p>答：是的，不仅如此，内积空间所定义的距离还满足「平行四边形法则」。</p></blockquote><p>【范数等价】对于两个向量范数<span class="math inline">\(\|x\|_\alpha\)</span>和<span class="math inline">\(\|x\|_\beta\)</span>，如果有： <span class="math display">\[k_1\|x\|_\beta\leq \|x\|_\alpha \leq k_2\|x\|_\beta\]</span> 那么称这两个范数等价。范数等价满足等价的性质，即传递性、自反性和对称性。</p><p>事实上，有限维线性空间的所有范数都是等价的。</p><h3 id="矩阵范数">矩阵范数</h3><p>【矩阵的向量范数】对于定义在<span class="math inline">\(\mathbb C^{m\times n}\)</span>上的矩阵<span class="math inline">\(A\)</span>，如果满足：</p><ol type="1"><li>正定：<span class="math inline">\(\|A\|\geq 0\)</span>且当且仅当<span class="math inline">\(A=O\)</span>时，<span class="math inline">\(\|A\|=0\)</span></li><li>齐次：<span class="math inline">\(\forall k\in F,\|kA\|=k\|A\|\)</span></li><li>三角不等式：<span class="math inline">\(\forall A,B\in \mathbb C^{m\times n},\|A+B\|\leq \|A\|+\|B\|\)</span></li></ol><p>称其为<strong>矩阵的向量范数</strong>。这其实就是把矩阵”拉直“看成向量。如果要考虑真正的矩阵，就要满足第四条性质：</p><ol start="4" type="1"><li>矩阵乘法相容性：<span class="math inline">\(\forall A,B\in \mathbb C^{m\times n},\|AB\|\leq \|A\|\|B\|\)</span></li></ol><p>则称其为<strong>矩阵范数</strong>。</p><p>【向量范数与矩阵范数相容】 若对 <span class="math inline">\(A \in\)</span> <span class="math inline">\(\mathbb{C}^{m \times n}\)</span> 和 <span class="math inline">\(\boldsymbol{x} \in \mathbb{C}^n\)</span>, 向量范数 <span class="math inline">\(\|x\|_v\)</span> 与矩阵范数 <span class="math inline">\(\|A\|_m\)</span> 满足</p><p><span class="math display">\[\|A x\|_v \leq\|A\|_m\|x\|_v\]</span></p><p>则称向量范数 <span class="math inline">\(\|x\|_v\)</span> 与矩阵范数 <span class="math inline">\(\|A\|_m\)</span> 相容.</p><p>给定一个<span class="math inline">\(\mathbb{C}^{n\times n}\)</span>的矩阵范数<span class="math inline">\(\|A\|_m\)</span>，一定会对应一个<span class="math inline">\(\mathbb{C}^n\)</span>的向量范数与之相容。这是显然的：<span class="math inline">\(\|x\|_v=\|x\alpha^T\|_m\)</span>，其中<span class="math inline">\(\alpha\)</span>是任意非零向量。证明相容性，有： <span class="math display">\[\|A x\|_v=\left\|A x \alpha^T\right\|_m \leq\|A\|_m\left\|x \alpha^T\right\|_m=\|A\|_m\|x\|_v\]</span> 已知向量范数，其实也有矩阵范数与之对应且相容，不过这个没有那么显然：</p><p>【算子范数/诱导范数】 设 <span class="math inline">\(\|x\|_v\)</span> 是 <span class="math inline">\(\mathbb{C}^n\)</span> 上的一个向量范数, 对任意 <span class="math inline">\(A \in \mathbb{C}^{m \times n}\)</span> ，定义 <span class="math display">\[\|A\|=\max _{\|\boldsymbol{x}\|_v=1}\|A \boldsymbol{x}\|_v\]</span></p><p>则 <span class="math inline">\(\|A\|\)</span> 是一个与 <span class="math inline">\(\|x\|_v\)</span> 相容的矩阵范数, 称其是从属于向量范数 <span class="math inline">\(\|\cdot\|_v\)</span> 的算子范数或由向量范数 <span class="math inline">\(\|\cdot\|_v\)</span> 诱导的矩阵范数。</p><p>对于向量范数<span class="math inline">\(\|x\|_1,\|x\|_\infty,\|x\|_2\)</span>，有诱导范数<span class="math inline">\(\|A\|_1,\|A\|_\infty,\|A\|_2\)</span>，它们分别称为列和范数、行和范数和谱范数。</p><ol type="1"><li><p>列和范数：每一列的元素绝对值之和的最大值： <span class="math display">\[\|A\|_1=\max _{1 \leq j \leq n} \sum_{i=1}^m\left|a_{i j}\right|\]</span></p></li><li><p>行和范数：每一行的元素绝对值之和的最大值： <span class="math display">\[\|A\|_{\infty}=\max _{1 \leq i \leq m} \sum_{j=1}^n\left|a_{i j}\right|\]</span></p></li><li><p>谱范数： <span class="math display">\[\|A\|_2=\sqrt{\lambda_{\text {max }}\left(A^H A\right)}=\sigma_{\text {max }}(A)\]</span></p></li></ol><h3 id="矩阵特征值的估计">矩阵特征值的估计</h3><p>【谱和谱半径】对于复方阵<span class="math inline">\(A\in \mathbb C^{n\times n}\)</span>，其所有特征值的集合<span class="math inline">\(S_p(A)\)</span>叫做这个矩阵的谱，其中特征值最大的模叫做这个矩阵的谱半径。</p><blockquote><p>谱半径本身不是范数（不满足正定性中的「范数为0等价于矩阵为<span class="math inline">\(O\)</span>」），而且它不大于任何一个矩阵范数。</p></blockquote><p>【盖尔圆盘】对于<span class="math inline">\(A\in \mathbb C^{n\times n}\)</span>，每一行来说，以它的主对角线上的那个元素为圆心，其它所有元素的模之和为半径的圆及其内部，叫做这个矩阵的盖尔圆盘。用数学公式来说，就是： <span class="math display">\[\delta_i=\sum_{j=1,j\neq i}^n |a_{ij}|,i=1\cdots n\]</span> 定义盖尔圆盘 <span class="math display">\[G_i=\{z\in \mathbb C\mid\ |z-a_{ii}|\leq \delta_i\}\]</span> 【盖尔圆盘定理】矩阵的所有特征值都在矩阵的所有盖尔圆盘的并集之内。</p><blockquote><p>因为<span class="math inline">\(A\)</span>与<span class="math inline">\(A^T\)</span>有相同的特征值集合，所以实际上矩阵的所有特征值要落在<span class="math inline">\(A\)</span>和<span class="math inline">\(A^T\)</span>的所有盖尔圆盘的并集之内。</p></blockquote><p>如果<span class="math inline">\(A\)</span>的其中<span class="math inline">\(k\)</span>个盖尔圆盘是并集形成一个联通的区域（相切也算），且该区域和其余圆盘都不相交，那么这个区域里面恰好有<span class="math inline">\(k\)</span>个特征值。那么，孤立的盖尔圆盘里面有且只有一个特征值。如果矩阵有<span class="math inline">\(k\)</span>个独立的盖尔圆盘，那么它至少有<span class="math inline">\(k\)</span>个互异的实特征值。如果所有盖尔圆盘互不相交，那么矩阵是单纯矩阵。</p><p>如果原点不在任何盖尔圆盘内，矩阵就不是奇异矩阵。</p><blockquote><p>【例】证明下面的矩阵至少有两个实特征值 <span class="math display">\[A=\left[\begin{array}{cccc}9 &amp; 1 &amp; -2 &amp; 1 \\0 &amp; 8 &amp; 1 &amp; 1 \\-1 &amp; 0 &amp; 4 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span> 【解】矩阵的四个盖尔圆为： <span class="math display">\[\begin{aligned}&amp; G_1:|z-9| \leq 4  \\&amp; G_2:|z-8| \leq 2  \\&amp; G_3:|z-4| \leq 1  \\&amp; G_4:|z-1| \leq 1 \end{aligned}\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412241039310.png" alt="image-20241224102739574" /></p><p>在紫色的圆里，有一个实特征值。矩阵是<span class="math inline">\(4\)</span>阶矩阵，所以有四个特征值。因为复特征值都是成对出现的，所以最多只能有一对复特征值，所以至少有两个实特征值。</p></blockquote><p>在使用盖尔圆估计特征值时，为了获得更多的孤立圆，我们可以构造一个矩阵<span class="math inline">\(D\)</span>，然后有： <span class="math display">\[B=DAD^{-1}\]</span> 因为<span class="math inline">\(AB\)</span>相似，所以它们具有相同的特征值。但是<span class="math inline">\(B\)</span>的盖尔圆盘是相互孤立的，这样就能更加精准地估计了。</p><p>一般来说，构造<span class="math inline">\(D\)</span>的方法是取一些非零实数<span class="math inline">\(\{d_1\cdots d_n\}\)</span>，然后有： <span class="math display">\[D=\text{diag}\{d_1,\cdots,d_n\}\]</span> 通常，<span class="math inline">\(d_i\)</span>的选取方法为：</p><ol type="1"><li>如果<span class="math inline">\(d_i&lt;1\)</span>，其它<span class="math inline">\(d\)</span>都是<span class="math inline">\(1\)</span>，那么会缩小第<span class="math inline">\(i\)</span>个盖尔圆、放大其它盖尔圆。</li><li>如果<span class="math inline">\(d_i&gt;1\)</span>，其它<span class="math inline">\(d\)</span>都是<span class="math inline">\(1\)</span>，那么会放大第<span class="math inline">\(i\)</span>个盖尔圆，缩小其它盖尔圆。</li></ol><blockquote><p>【例】用盖尔圆隔离特征值： <span class="math display">\[\boldsymbol{A}=\left[\begin{array}{cccc}1 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 9 &amp; 1.3 &amp; -2 \\1 &amp; 0 &amp; 15 &amp; 1.4 \\0 &amp; -1 &amp; 0 &amp; 4\end{array}\right]\]</span> 【解】原矩阵的四个盖尔圆为： <span class="math display">\[\begin{align}G_1&amp;:|z-1|\leq 1\\G_2&amp;:|z-9|\leq 4.3\\G_3&amp;:|z-15|\leq 2.4\\G_4&amp;:|z-4|\leq 1\end{align}\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412311058061.png" alt="image-20241231105809280" /> <span class="math display">\[\boldsymbol{D}=\left[\begin{array}{llll}5 / 3 &amp; &amp; &amp; \\&amp; 1 &amp; &amp; \\&amp; &amp; 1 &amp; \\&amp; &amp; &amp; 1\end{array}\right], \quad \boldsymbol{B}=\boldsymbol{D} \boldsymbol{A} \boldsymbol{D}^{-1}=\left[\begin{array}{cccc}1 &amp; 5 / 3 &amp; 0 &amp; 0 \\0.6 &amp; 9 &amp; 1.3 &amp; -2 \\0.6 &amp; 0 &amp; 15 &amp; 1.4 \\0 &amp; -1 &amp; 0 &amp; 4\end{array}\right]\]</span> <span class="math inline">\(B\)</span>的四个盖尔圆为： <span class="math display">\[\begin{align}G_1&amp;:|z-1|\leq \frac 35\\G_2&amp;:|z-9|\leq 3.9\\G_3&amp;:|z-15|\leq 2\\G_4&amp;:|z-4|\leq 1\end{align}\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412311101068.png" alt="image-20241231110127858" /></p><p>TIPS：往年题里，这个<span class="math inline">\(D\)</span>的元素的选取，往往在<span class="math inline">\(1.6\sim 1.9\)</span>之间。</p></blockquote><h3 id="矩阵幂级数">矩阵幂级数</h3><p>要讨论幂级数，就要先讨论收敛。要讨论矩阵，就要先讨论向量。</p><p>【向量按范数收敛】 <span class="math inline">\(\left(V,\|\cdot\|_\alpha\right)\)</span> 是 <span class="math inline">\(n\)</span>维赋范线性空间， <span class="math inline">\(x_1, x_2, \cdots, x_k, \cdots\)</span> 是 <span class="math inline">\(V\)</span> 中一个向量序列, 记为 <span class="math inline">\(\left\{\boldsymbol{x}_k\right\}\)</span>. 若存在 <span class="math inline">\(V\)</span> 的向量 <span class="math inline">\(\boldsymbol{x}\)</span> 满足</p><p><span class="math display">\[\lim _{k \rightarrow \infty}\left\|x_k-x\right\|_\alpha=0\]</span></p><p>则称向量序列 <span class="math inline">\(\left\{x_k\right\}\)</span> 按范数 <span class="math inline">\(\|\cdot\|_\alpha\)</span> 收敛于 <span class="math inline">\(x\)</span>, 记作</p><p><span class="math display">\[\lim _{k \rightarrow \infty} x_k=x \text { 或 } x_k \xrightarrow{\alpha} x\]</span> 因为有限维线性空间中所有范数都是等价的，所以只要向量按某种范数收敛，它就按所有范数收敛。</p><p>【向量按坐标收敛】设 <span class="math inline">\(\left(V,\|\cdot\|_\alpha\right)\)</span> 是 <span class="math inline">\(n\)</span>维赋范线性空间, <span class="math inline">\(\boldsymbol{\epsilon}_1, \cdots, \boldsymbol{\epsilon}_n\)</span> 是 <span class="math inline">\(V\)</span> 中一组基, <span class="math inline">\(\left\{\boldsymbol{x}_k\right\}\)</span> 是 <span class="math inline">\(V\)</span>中一个向量序列，并记向量序列 <span class="math inline">\(\left\{x_k\right\}\)</span> 中的任一向量 <span class="math inline">\(\boldsymbol{x}_k\)</span> 在 <span class="math inline">\(\epsilon_1, \cdots, \epsilon_n\)</span> 下坐标为</p><p><span class="math display">\[\xi_k=\left[\xi_1^{(k)}, \cdots, \xi_n^{(k)}\right]^T \in F^n\]</span></p><p>若存在 <span class="math inline">\(V\)</span> 的向量 <span class="math inline">\(\boldsymbol{x}\)</span> 满足 <span class="math inline">\(\lim _{k \rightarrow \infty} \xi_i^{(k)}=\xi_i, i=1, \cdots, n\)</span>则称向量序列 <span class="math inline">\(\left\{x_k\right\}\)</span> 按坐标收敛于向量 <span class="math inline">\(x\)</span>, 其中 <span class="math inline">\(\xi\)</span> 是向量 <span class="math inline">\(\boldsymbol{x}\)</span> 在基 <span class="math inline">\(\epsilon_1, \cdots, \epsilon_n\)</span> 下坐标.</p><p>事实上，这些收敛的定义都是相互等价的：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412241527786.png" alt="image-20241224152720210" /><figcaption aria-hidden="true">image-20241224152720210</figcaption></figure><p>矩阵的收敛和上面的一样，只需要把范数改成矩阵范数就行了。</p><p>【矩阵级数】设有矩阵序列<span class="math inline">\(\{A_k\}\)</span>，则 <span class="math display">\[\sum_{k=1}^\infty A_k\]</span> 称为矩阵级数。</p><p>矩阵级数收敛，等价于：</p><ol type="1"><li><p>部分和序列收敛 <span class="math display">\[S_n=\sum_{k=1}^n A_k\]</span></p></li><li><p><span class="math inline">\(mn\)</span>个数项级数 <span class="math display">\[\sum_{k=1}^\infty a_{ijk}\]</span> 收敛。</p></li></ol><p>矩阵级数绝对收敛，等价于：</p><ol type="1"><li><p><span class="math inline">\(mn\)</span>个数项级数 <span class="math display">\[\sum_{k=1}^\infty |a_{ijk}|\]</span> 收敛。</p></li><li><p>存在一个矩阵范数，使得 <span class="math display">\[\sum_{k=1}^\infty \|A_k\|\]</span> 收敛。</p></li></ol><p>【矩阵幂级数】设<span class="math inline">\(A\in \mathbb C^{n\times n}\)</span>，则定义矩阵级数 <span class="math display">\[\sum_{k=0}^\infty a_kA^k\]</span> 其中<span class="math inline">\(A^0=I\)</span>为矩阵幂级数。</p><p>关于其收敛性，有：设普通幂级数<span class="math inline">\(\sum_{k=0}^\infty a_kx^k\)</span>的收敛半径为<span class="math inline">\(R\)</span>，则</p><ol type="1"><li><span class="math inline">\(\rho(A)&lt; R\)</span>，矩阵幂级数<span class="math inline">\(\sum_{k=0}^\infty a_kA^k\)</span>绝对收敛</li><li><span class="math inline">\(\rho(A)&gt;R\)</span>，矩阵幂级数<span class="math inline">\(\sum_{k=0}^\infty a_kA^k\)</span>发散</li><li><span class="math inline">\(\rho(A)=R\)</span>，无法判断，只能通过定义（每个元素都收敛）判断</li></ol><p>其中<span class="math inline">\(\rho(A)\)</span>是矩阵的谱半径，即特征值的绝对值的最大值。</p><p>回顾：计算普通幂级数的收敛半径：</p><p><span class="math display">\[R=\frac 1\rho\]</span></p><p><span class="math display">\[\rho=\lim_{k\to \infty}\left|\frac{a_{k+1}}{a_k}\right|\]</span></p><blockquote><p>【例】判断矩阵幂级数的收敛性，如果收敛，求其和。 <span class="math display">\[\sum_{k=0}^{+\infty}\left(\begin{array}{ll}0.1 &amp; 0.7 \\0.3 &amp; 0.6\end{array}\right)^k\]</span> 【解】矩阵幂级数中，有：<span class="math inline">\(a_k=1\)</span>，因此普通幂级数 <span class="math display">\[\sum_{k=0}^\infty a_kx^k\]</span> 的收敛半径为<span class="math inline">\(1\)</span>。</p><p>矩阵的谱半径为 <span class="math display">\[\rho(A)=\frac{0.7+\sqrt{1.09}}{2}&lt;1\]</span> 因此收敛。</p><p>当然，这里也并不是一定要求特征值。因为矩阵的行和范数是<span class="math inline">\(0.9\)</span>，而谱半径一定是小于行和范数的，所以谱半径一定小于<span class="math inline">\(0.9\)</span>，进而小于<span class="math inline">\(1\)</span>。</p><p>求和： <span class="math display">\[\begin{align}S&amp;=I+A+A^2+A^3+\cdots\\AS&amp;=A+A^2+A^3+\cdots\end{align}\]</span> 相减，有： <span class="math display">\[(I-A)S=I\]</span> 即 <span class="math display">\[S=(I-A)^{-1}=\frac{2}{3}\left(\begin{array}{ll}4 &amp; 7 \\3 &amp; 9\end{array}\right)\]</span> 【例2】设 <span class="math inline">\(A=\left[\begin{array}{cc}-1 &amp; 1 \\ 0 &amp; -1\end{array}\right]\)</span>, 判断 <span class="math inline">\(\sum_{k=1}^{\infty} \dfrac{1}{k} A^k\)</span> 的敛散性.</p><p>【解2】<span class="math inline">\(\rho(A)=1\)</span>，普通级数<span class="math inline">\(\sum_{k=1}^\infty \dfrac 1k x^k\)</span>收敛半径也为<span class="math inline">\(1\)</span>，因此改用定义判断。</p><p>对于若当块的乘方，有：</p>$$ (<span class="math display">\[\begin{array}{ccccc}\lambda &amp; 1 &amp; &amp; &amp; \\&amp; \lambda &amp; 1 &amp; &amp; \\&amp; &amp; \lambda &amp; \ddots &amp; \\&amp; &amp; &amp; \ddots &amp; 1 \\&amp; &amp; &amp; &amp; \lambda\end{array}\]</span>)_k^n=(<span class="math display">\[\begin{array}{ccccc}\lambda^n &amp; C_n^1 \lambda^{n-1} &amp; C_n^2 \lambda^{n-2} &amp; \cdots &amp; C_n^{k-1} \lambda^{n-(k-1)} \\&amp; \lambda^n &amp; C_n^1 \lambda^{n-1} &amp; \cdots &amp; C_n^{k-2} \lambda^{n-(k-2)} \\&amp; &amp; \lambda^n &amp; \cdots &amp; C_n^{k-3} \lambda^{n-(k-3)} \\&amp; &amp; &amp; \ddots &amp; \vdots \\&amp; &amp; &amp; &amp; \lambda^n \\\end{array}\]</span><p>)_k $$</p><p>代入到本题，有： <span class="math display">\[\begin{bmatrix}-1&amp;1\\0&amp;-1\end{bmatrix}^k=\begin{bmatrix}-1^k&amp;k(-1)^{k-1}\\0&amp;-1^k\end{bmatrix}\]</span> 容易发现， <span class="math display">\[\sum_{k=1}^\infty (-1)^{k-1}\]</span> 发散，因此原矩阵级数发散。</p></blockquote><h3 id="矩阵函数">矩阵函数</h3><p>如果把收敛的矩阵幂级数写成函数的形式，就是矩阵函数： <span class="math display">\[f(A)=\sum_{k=0}^\infty a_kA^k\]</span> 若矩阵函数 <span class="math inline">\(f(A)\)</span> 的自变量由矩阵 <span class="math inline">\(A\)</span>换成 <span class="math inline">\(A t\)</span>, 其中 <span class="math inline">\(t\)</span> 为标量参数, 则有矩阵函数表达式为</p><p><span class="math display">\[f(A t)=\sum_{m=0}^{\infty} c_m(A t)^m=\sum_{m=0}^{\infty} c_m t^m A^m,|t| \rho(A)&lt;r\]</span></p><p>称之为含参矩阵函数。</p><p>尽管矩阵函数看起来好像是无穷级数，但是因为矩阵有个最小多项式，所以它总是可以表示成有限个矩阵次幂的线性组合。即：</p><p>设矩阵 <span class="math inline">\(A \in \mathbb{C}^{n \times n}\)</span> 的最小多项式次数为 <span class="math inline">\(l\)</span>, 幂级数 <span class="math inline">\(f(z)=\sum_{m=0}^{\infty} c_m z^m\)</span> 的收敛半径为 <span class="math inline">\(r\)</span>. 若 <span class="math inline">\(\rho(A)&lt;r\)</span>,定义矩阵函数 <span class="math inline">\(f(A)\)</span>, 则必存在唯一的 <span class="math inline">\((l-1)\)</span> 次矩阵多项式 <span class="math inline">\(p(A)=\beta_0 I+\beta_1 A+\cdots+\beta_{l-1} A^{l-1}\)</span> 使得 <span class="math inline">\(f(A)=p(A)\)</span>.</p><p>现在，就是要求出这个有限和<span class="math inline">\(p(A)\)</span>。</p><p>【复函数的谱上给定】如果对于复函数<span class="math inline">\(f(z)\)</span>和矩阵<span class="math inline">\(A\)</span>，如果对于<span class="math inline">\(A\)</span>的代数重数为<span class="math inline">\(n\)</span>的特征值<span class="math inline">\(\lambda\)</span>，<span class="math inline">\(f(\lambda)\)</span>和<span class="math inline">\(f(z)\)</span>在<span class="math inline">\(\lambda\)</span>处的<span class="math inline">\(1\sim n\)</span>阶导数都有界，那么称复函数在矩阵的谱上给定。</p><p>【谱上一致】设复方阵 <span class="math inline">\(A\)</span> 的最小多项式为 <span class="math inline">\(m_A(\lambda)=\left(\lambda-\lambda_1\right)^{n_1}\left(\lambda-\lambda_2\right)^{n_2} \cdots\left(\lambda-\lambda_S\right)^{n_S}\)</span>, <span class="math inline">\(\operatorname{deg}\left(m_A(\lambda)\right)=l\)</span>. 若函数 <span class="math inline">\(f(\lambda)\)</span> 和 <span class="math inline">\(p(\lambda)\)</span> 在谱上给定且满足</p><p><span class="math display">\[\left\{\begin{array}{rl}f\left(\lambda_i\right) &amp; =p\left(\lambda_i\right) \\f^{\prime}\left(\lambda_i\right) &amp; =p^{\prime}\left(\lambda_i\right) \\&amp; \vdots \\f^{\left(n_i-1\right)}\left(\lambda_i\right) &amp; =p^{\left(n_i-1\right)}\left(\lambda_i\right)\end{array}, i=1, \cdots, s\right.\]</span></p><p>则称函数 <span class="math inline">\(f(\lambda)\)</span> 和 <span class="math inline">\(p(\lambda)\)</span> 在矩阵 <span class="math inline">\(A\)</span> 的谱上一致。</p><p><strong><span class="math inline">\(f(z)\)</span>和<span class="math inline">\(p(z)\)</span>在矩阵<span class="math inline">\(A\)</span>的谱上一致是<span class="math inline">\(f(A)=p(A)\)</span>的充要条件。</strong></p><p>由此，可以利用谱上一致法计算矩阵函数，操作步骤为：</p><ol type="1"><li><p>计算矩阵的最小多项式，假设最小多项式是<span class="math inline">\(m\)</span>次</p></li><li><p>待定系数法，设 <span class="math display">\[f(At)=a_0(t)+a_1(t)A+\cdots+a_{m-1}A^{m-1}\]</span></p></li><li><p>把矩阵的各个特征值依次带入上面的方程（代入<span class="math inline">\(A\)</span>的位置），得到方程组。如果特征值不够用，就对上面的方程两边求导，再代入，直到能求出<span class="math inline">\(a\)</span>的唯一解。</p></li></ol><blockquote><p>【例】计算<span class="math inline">\(e^{At}\)</span>，其中： <span class="math display">\[A=\left(\begin{array}{ccc}-2 &amp; 1 &amp; 3 \\0 &amp; -3 &amp; 0 \\0 &amp; 2 &amp; -2\end{array}\right)\]</span> 【解】首先计算<span class="math inline">\(A\)</span>的特征多项式： <span class="math display">\[(\lambda+2)^3(\lambda+3)\]</span> 验证： <span class="math display">\[(A+2I)(A+3I)\neq O\]</span></p><p><span class="math display">\[(A+2I)^2(A+3I)=O\]</span></p><p>故最小多项式为3次。</p><p>设： <span class="math display">\[e^{At}=a_0(t)+a_1(t)A+a_2(t)A^2\]</span> 把特征值代入<span class="math inline">\(A\)</span>的位置，有： <span class="math display">\[\begin{cases}e^{-2t}=a_0-2a_1+4a_2\\e^{-3t}=a_0-3a_1+9a_2\end{cases}\]</span> 发现方程不够，对原方程求导： <span class="math display">\[te^{\lambda t}=a_1+2a_2\lambda\]</span> 代入，得到最终方程组： <span class="math display">\[\left\{\begin{array}{l}e^{-2 t}=a_0-2 a_1+4 a_2 \\e^{-3 t}=a_0-3 a_1+9 a_2 \\t e^{-2 t}=a_1-4 a_2\end{array}\right.\]</span> 解得： <span class="math display">\[\begin{cases}&amp; a_0=(6 t-3) e^{-2 t}+4 e^{-3 t} \\&amp; a_1=(5 t-4) e^{-2 t}+4 e^{-3 t} \\&amp; a_2=(t-1) e^{-2 t}+e^{-3 t}\end{cases}\]</span> 后略。</p></blockquote><h3 id="mooc第四章答案">MOOC第四章答案</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">DAACC BDABC<br>C0001 <span class="hljs-number">01111</span><br><span class="hljs-number">01111</span> <span class="hljs-number">1</span>BBAA<br>AABAA <span class="hljs-built_in">BA</span>(ABCD)(ABC)<br>(ABC)(ACD)(ABC)(AD)(AC) <span class="hljs-number">10111</span><br><span class="hljs-number">11110</span> <span class="hljs-number">11001</span><br><span class="hljs-number">11110</span> <span class="hljs-number">11111</span><br><span class="hljs-number">11111</span> <span class="hljs-number">11111</span><br><span class="hljs-number">01011</span> BD00D<br></code></pre></td></tr></table></figure><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>其中的<span class="math inline">(y^H)</span>是共轭转置的意思，也就是说<span class="math inline">(y<sup>H=y</sup>T)</span> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>意思就是，线性空间的「数域」也是那个集合Q(√3) <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化笔记</title>
    <link href="/2024/10/03/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    <url>/2024/10/03/%E6%9C%80%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr /><h2 id="凸性">凸性</h2><h3 id="集合">集合</h3><h4 id="凸集">凸集</h4><p>【定义】集合<span class="math inline">\(C\subseteq \mathbb R^n\)</span>凸，指的是<span class="math inline">\(\forall x_0,x_1\in C,\forall \theta\in [0,1],(1-\theta)x_0+\theta x_1\in C\)</span>。</p><p>其中，「<span class="math inline">\((1-\theta)x_0+\theta x_1\)</span>」指的是「<span class="math inline">\(x_1,x_0\)</span>两点连接成的线段」，这是一个常用的表述技巧。那么，凸集的定义的人话版本，就是「一个集合中任意两点连接成的线段，也在集合中」。</p><p>对于一些凸集 <span class="math inline">\(\{C_i\}_{i\in I}\)</span>，以下运算的结果仍然是凸集，这样的运算叫「保凸运算」：</p><ol type="1"><li><p>【交】<span class="math inline">\(C=\cup_{i\in I}C_i\)</span>是凸集。即：任意个凸集的交集是凸集。这里的「任意个」可以是不可数无穷个。</p></li><li><p>【直积】<span class="math inline">\(C=C_1\times C_2=\{(\boldsymbol {x_1,x_2})\mid \boldsymbol x_1\in C_1,\boldsymbol x_2\in C_2\}\)</span> 是<span class="math inline">\(\mathbb R^{n_1+n_2}\)</span>上的凸集。</p></li><li><p>【加权和】如果 <span class="math inline">\(C_i\)</span> 都是<span class="math inline">\(\mathbb R^n\)</span>上的凸集，<span class="math inline">\(\beta\in \mathbb R\)</span>，那么 <span class="math display">\[C=\sum_{i=1}^I \beta_iC_i=\{\beta_1 x_1+\beta_2 x_2+\cdots +\beta_Ix_I,x_i\in C_i\}\]</span> 是凸集。</p></li><li><p>【仿射】如果<span class="math inline">\(C\)</span>是<span class="math inline">\(\mathbb R^n\)</span>上的凸集，<span class="math inline">\(A\in \mathbb R^{m\times n},b\in \mathbb R^m\)</span>，则<span class="math inline">\(D=\{Ax+b,x\in C\}\)</span>是凸集。其实，所谓仿射，也就是线性变换再加上一个平移。</p></li></ol><p>有一些比较常见的凸集，需要知道他们的表示方法：</p><ol type="1"><li><p>【超平面】<span class="math inline">\(H=\{x\in \mathbb R^n\mid w^Tx=b\}\)</span>，其中<span class="math inline">\(w\in \mathbb R^n,b\in \mathbb R\)</span>。称<span class="math inline">\(w\)</span>为超平面的法向量。</p></li><li><p>【半空间】<span class="math inline">\(H=\{x\in \mathbb R^n\mid w^Tx\geq b\}\)</span>，也就是一个超平面把空间分成两个半空间（以及超平面自身）</p></li><li><p>【多面体】<span class="math inline">\(H=\{x\in \mathbb R^n\mid Ax\leq b\}\)</span>，也就是有限多个半空间的交集。</p></li><li><p>【子空间】<span class="math inline">\(L\in \mathbb R^n,\forall x,y\in L,\alpha x+\beta y\in L\)</span>.这个和高代里面的子空间是一个意思，也就是元素的线性组合仍在子空间中。</p></li><li><p>【仿射集/线性流形/仿射子空间】对于子空间<span class="math inline">\(L\)</span>，存在<span class="math inline">\(\alpha\in\mathbb R^n\)</span>，<span class="math inline">\(M=\alpha+L\)</span>，则<span class="math inline">\(M\)</span>是仿射集。称<span class="math inline">\(L\)</span>的线性维数为<span class="math inline">\(M\)</span>的仿射维数，记作<span class="math inline">\(\dim M\)</span>。其实就是说，子空间不是必须要通过<span class="math inline">\(0\)</span>点吗，那么把子空间平移了以后，它不通过<span class="math inline">\(0\)</span>点了，虽然不再是子空间了，但是仍然是线性的，也是凸集。</p><p>例如： <span class="math display">\[M=\{x\in R^n\mid Ax=b\}\\\\L=\{x\in R^n\mid Ax=0\}\]</span> <span class="math inline">\(\alpha\)</span> 为 <span class="math inline">\(Ax=b\)</span> 的任意一个特解。<span class="math inline">\(\dim M=n-\text{rank} A\)</span>。所以说，一般来说可以用一个非齐次线性方程组<span class="math inline">\(Ax=b\)</span>的解集来表示仿射集。</p></li><li><p>【球体】<span class="math inline">\(H=\{x\in \mathbb R^n\mid ||x-\alpha||\leq r\}\)</span>，其中<span class="math inline">\(||\cdot||\)</span>是范数，<span class="math inline">\(\alpha\in\mathbb R^n,r\in \mathbb R\)</span>.</p></li><li><p>【椭球体】<span class="math inline">\(H=\{x\in \mathbb R^n\mid x^TEx\leq r\}\)</span>，其中<span class="math inline">\(E\)</span>是对称正定矩阵，<span class="math inline">\(r\geq 0\)</span>。</p><blockquote><p>例如：<span class="math inline">\(S=\{x\in \mathbb R^2\mid x_1^2+ix_1x_2+i^2x_2^2\leq 1\}\)</span></p><p>令 <span class="math display">\[E_i=\begin{pmatrix}1 &amp; \dfrac i2\\\dfrac i2 &amp; i^2\end{pmatrix}\]</span> 则<span class="math inline">\(E_i\)</span>是对称正定矩阵，且<span class="math inline">\(S=\{x\in \mathbb R^2\mid x^TE_xx\leq 1\}\)</span>，故<span class="math inline">\(S\)</span>是凸集。</p></blockquote></li><li><p>【凸函数的下水平集】<span class="math inline">\(H=\{x\in S\mid f(x)\leq \alpha\}\)</span>，其中<span class="math inline">\(f\)</span>是凸函数，<span class="math inline">\(S\)</span>是凸集，<span class="math inline">\(\alpha\in R\)</span></p></li></ol><p>还有一类特殊的集合，叫做「锥」。</p><p>【定义】称<span class="math inline">\(K\in \mathbb R^n\)</span>为「锥形的」，当且仅当<span class="math inline">\(\forall x\in K,\forall \alpha&gt;0,\alpha x\in K\)</span>。如果<span class="math inline">\(K\)</span>还是凸集，称<span class="math inline">\(K\)</span>为「锥」。</p><p>常见的锥有：</p><ol type="1"><li>【第一卦限】<span class="math inline">\(K=\{x\in \mathbb R^n\mid \forall i,x_i&gt;0\}\)</span></li><li>【二阶锥】<span class="math inline">\(K=\{x\in \mathbb R^n\mid x_n\geq\sqrt{\sum_{i=1}^{n-1} x_i^2}\}\)</span></li><li>【对称矩阵、半正定矩阵、正定矩阵】</li></ol><h4 id="集合的内部和闭包">集合的内部和闭包</h4><p>集合的闭包记作<span class="math inline">\(cl X\)</span>，指的是集合中的点列的极限的集合。</p><blockquote><p>例如：对于集合<span class="math inline">\(x&gt;0\)</span>，点列<span class="math inline">\(1/n\)</span>，其极限为<span class="math inline">\(\lim_{n\to \infty} \dfrac 1n=0\)</span>，所以<span class="math inline">\(0\)</span>在集合<span class="math inline">\(X\)</span>的闭包中。</p></blockquote><p>闭包是包含<span class="math inline">\(X\)</span>的最小闭集。</p><p>集合的内部记作<span class="math inline">\(\text{int} X\)</span>，指的是集合中，存在以其为中心的球体也在集合中的点构成的集合。</p><blockquote><p>例如：对于集合<span class="math inline">\(x&gt;0\)</span>，对于点<span class="math inline">\(0\)</span>，无论半径<span class="math inline">\(r\)</span>取何值，球体中的一点<span class="math inline">\(r\)</span>总是大于<span class="math inline">\(0\)</span>，从而不在集合中，所以<span class="math inline">\(0\)</span>不在<span class="math inline">\(X\)</span>的内部。</p></blockquote><p>内部是包含在<span class="math inline">\(X\)</span>中的最大开集。</p><p>但是有时候，对于一个凸集，其内部是空集。比如在<span class="math inline">\(R^3\)</span>中的平面。此时，无法用内点来对<span class="math inline">\(X\)</span>进行分析，但是就直观来看，<span class="math inline">\(X\)</span>并不是一个很「空」的集合。这时候需要定义「相对内部」，也就是在<span class="math inline">\(X\)</span>的仿射包中定义<span class="math inline">\(X\)</span>的内部。例如，在<span class="math inline">\(R^3\)</span>中有一个集合<span class="math inline">\(X\)</span>，它是一个圆形。那么它的仿射包就是包含这个圆形的二维平面。在<span class="math inline">\(R^3\)</span>中，这个圆形集合的内部是空集。但是如果只在仿射包中看，这个圆形集合的内部就不是空集了。从仿射包看的所谓「内部」，就是「相对内部」。</p><p>对于集合<span class="math inline">\(X\in \mathbb R^n\)</span>，其仿射包为<span class="math inline">\(M\)</span>，定义相对内部： <span class="math display">\[\text{ri }X=\left\{x\in X\mid \exists r_x&gt;0 s.t.\{y\in M\mid ||y-x||_2&lt;r_x)\subseteq  X\} \right\}\]</span> 看这个可能很晕。其实就是说，在<span class="math inline">\(X\)</span>中存在一些点，它们满足一个条件，这个条件就是「在<span class="math inline">\(M\)</span>中存在以这些点为中心的球包含于<span class="math inline">\(X\)</span>」。我们把这些点的集合称为<span class="math inline">\(X\)</span>的相对内部。相对内部和内部的区别，就是把「球」所存在的空间，从<span class="math inline">\(\mathbb R^n\)</span>变成了<span class="math inline">\(X\)</span>的仿射包。</p><h4 id="组合和包">组合和包</h4><p>点<span class="math inline">\(x_1\cdots x_k\in \mathbb R^n\)</span>的<strong>凸组合</strong>指的是： <span class="math display">\[\sum_{i=1}^k \theta_i x_i\]</span> 其中<span class="math inline">\(\theta&gt;0,\sum \theta=1\)</span>。有没有发现这个定义特别像前面「凸集定义」的一部分。在二维空间中，凸组合可以看作经过两个点的线段。所以凸集的定义也可以表示为：<span class="math inline">\(C\)</span>中的点的凸组合也都属于<span class="math inline">\(C\)</span>，那么<span class="math inline">\(C\)</span>是凸集。</p><p>如果集合<span class="math inline">\(X\)</span>不是凸集，那么称包含<span class="math inline">\(X\)</span>的最小凸集<span class="math inline">\(C\)</span>为<span class="math inline">\(X\)</span>的凸包，记作<span class="math inline">\(C=\text{conv} X\)</span>。可以证明： <span class="math display">\[\text{conv} X=\left\{\sum_{i=1}^k\theta_ix_i\mid k\in \mathbb Z_{++}，x_i\in X,\sum_{i=1}^k\theta_i=1\right\}\]</span> 看着很复杂，其实就是<span class="math inline">\(X\)</span>中的任意有限个点的凸组合的集合。</p><p>点<span class="math inline">\(x_1\cdots x_k\in \mathbb R^n\)</span>的<strong>仿射组合</strong>指的是： <span class="math display">\[\sum_{i=1}^k \theta_i x_i\]</span> 其中<span class="math inline">\(\sum \theta=1\)</span>.相比于「凸组合」，「仿射组合」只是删去了「<span class="math inline">\(\theta&gt;0\)</span>」的条件。在二维空间中，仿射组合相当于经过两个点的直线。</p><p>对于仿射包的定义和生成，也和凸包类似。仿射包记作<span class="math inline">\(C=\text{aff} X\)</span>。</p><p>通过仿射包，可以定义任意集合的维数。对于任意非空集合<span class="math inline">\(X\in \mathbb R^n\)</span>，称其仿射包<span class="math inline">\(\text {aff}X\)</span>的仿射维数是<span class="math inline">\(X\)</span>的仿射维数，记作<span class="math inline">\(\dim X\)</span>。</p><p>点<span class="math inline">\(x_1\cdots x_k\in \mathbb R^n\)</span>的<strong>锥组合</strong>指的是： <span class="math display">\[\sum_{i=1}^k \theta_i x_i\]</span> 其中<span class="math inline">\(\theta&gt;0\)</span>.相比于「凸组合」，「锥组合」只是删去了「<span class="math inline">\(\sum\theta=1\)</span>」的条件。在二维空间中，锥组合相当于经过两个点的射线。</p><p>对于锥包的定义和生成，也和凸包类似。锥包记作<span class="math inline">\(C=\text{cone} X\)</span>。</p><p>可以总结一下：</p><table><thead><tr class="header"><th style="text-align: center;">组合类型</th><th style="text-align: center;">系数限制</th><th style="text-align: center;">集合名称</th><th style="text-align: center;">样例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">线性组合</td><td style="text-align: center;">无限制</td><td style="text-align: center;">向量子空间</td><td style="text-align: center;"><span class="math inline">\(\mathbb R^n\)</span></td></tr><tr class="even"><td style="text-align: center;">仿射组合</td><td style="text-align: center;"><span class="math inline">\(\sum \theta=1\)</span></td><td style="text-align: center;">仿射集/线性流形/仿射子空间</td><td style="text-align: center;">仿射超平面</td></tr><tr class="odd"><td style="text-align: center;">锥组合</td><td style="text-align: center;"><span class="math inline">\(\theta&gt;0\)</span></td><td style="text-align: center;">锥</td><td style="text-align: center;">第一卦限</td></tr><tr class="even"><td style="text-align: center;">凸组合</td><td style="text-align: center;"><span class="math inline">\(\theta&gt;0,\sum \theta=1\)</span></td><td style="text-align: center;">凸集</td><td style="text-align: center;">单纯形</td></tr></tbody></table><h3 id="凸函数">凸函数</h3><h4 id="梯度和海森矩阵">梯度和海森矩阵</h4><p>这俩东西后面有用。</p><p>梯度： <span class="math display">\[\nabla f(\boldsymbol{x})=\left[\begin{array}{c}\frac{\partial f}{\partial x_1} \\\vdots \\\frac{\partial f}{\partial x_n}\end{array}\right]\]</span> 海森矩阵： <span class="math display">\[\nabla^2 f(\boldsymbol{x})=\left[\begin{array}{ccc}\frac{\partial^2 f}{\partial x_1^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n \partial x_1} \\\vdots &amp; \ddots &amp; \vdots \\\frac{\partial^2 f}{\partial x_1 \partial x_n} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}\end{array}\right]\]</span> 简单理解，梯度就是一阶导，海森矩阵就是二阶导（曲率）。</p><h4 id="凸函数-1">凸函数</h4><p>对于凸集<span class="math inline">\(S\)</span>上的函数<span class="math inline">\(f\)</span>，如果： <span class="math display">\[f(\theta x_0+(1-\theta)x_1)\leq \theta f(x_0)+(1-\theta)f(x_1)\]</span> 其实就是：函数线上的两点之间的连线，一定在函数线以上。</p><p>凸函数的性质有：</p><ol type="1"><li><p>函数<span class="math inline">\(f\)</span>在凸集<span class="math inline">\(S\)</span>上是凸函数，等价于其上镜图是凸集。 <span class="math display">\[\text{epi} f=\{(x,r)\in S\times \mathbb R\mid r\geq f(x)\}\]</span></p></li><li><p>函数<span class="math inline">\(f\)</span>在凸集<span class="math inline">\(S\)</span>上是凸函数，则有Jensen不等式： <span class="math display">\[f\left(\frac{\sum_{i=1}^m \alpha_i \boldsymbol{x}_{\boldsymbol{i}}}{\sum_{s=1}^m \alpha_s}\right) \leq \frac{\sum_{i=1}^m \alpha_i f\left(\boldsymbol{x}_{\boldsymbol{i}}\right)}{\sum_{s=1}^m \alpha_s}\]</span> 其中<span class="math inline">\(x_i\in S,\alpha&gt;0\)</span>。</p><blockquote><p>证明：令 <span class="math display">\[\theta_i=\frac{\alpha_i}{\sum_{i=1}^m \alpha_i}\]</span> 因为<span class="math inline">\(f\)</span>是凸函数，所以其上镜图是凸集，所以其上镜图上的点的凸组合是在上镜图里，有： <span class="math display">\[\begin{align}&amp;\sum_{i=1}^m\theta_i(x_i,f(x_i))\in \text{epi} f\\&amp;\to \left(\sum_{i=1}^m \theta x_i,\sum_{i=1}^m \theta_i f(x_i)\right)\in \text{epi} f\\&amp;\to f\left(\sum_{i=1}^m \theta_i x_i\right)\leq \sum_{i=1}^m \theta_i f(x_i)\end{align}\]</span></p></blockquote></li><li><p>函数<span class="math inline">\(f\)</span>在<span class="math inline">\(\mathbb R^n\)</span>上凸，当且仅当，<span class="math inline">\(\forall x_0\in \mathbb R^n,\forall d\in \mathbb R^n,\phi(\alpha)=f(x_0+\alpha d)\)</span>关于<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(\mathbb R\)</span>上凸。</p></li><li><p>函数<span class="math inline">\(f\)</span>在凸集<span class="math inline">\(S\)</span>上是凸函数，则其在<span class="math inline">\(S\)</span>的相对内部上连续。如果有界闭集<span class="math inline">\(K\subset \text{ri }S\)</span>，那么<span class="math inline">\(f\)</span>在<span class="math inline">\(K\)</span>上Lipschitz连续（比一致连续更强的连续）。</p></li><li><p>函数<span class="math inline">\(f\)</span>一阶偏导连续，那么它在凸集<span class="math inline">\(S\)</span>上是凸函数，当且仅当 <span class="math display">\[f(y)\geq f(x)+\nabla f(x)^T(y-x),\forall xy\in S\]</span></p></li><li><p>函数<span class="math inline">\(f\)</span>二阶偏导连续，那么它在内部非空的凸集<span class="math inline">\(S\)</span>上是凸函数，当且仅当<span class="math inline">\(\nabla ^2f(x)\)</span>半正定。</p></li><li><p>函数<span class="math inline">\(f\)</span>在凸集<span class="math inline">\(S\)</span>上是凸函数，有：<span class="math inline">\(\forall c\in \mathbb R,\{x\in S\mid c\geq f(x)\}\)</span>是凸集。即：使得<span class="math inline">\(f(x)\)</span>小于一个定值的<span class="math inline">\(x\)</span>的取值范围是凸集，这个范围叫做下水平集。</p></li><li><p>函数<span class="math inline">\(f\)</span>在凸集<span class="math inline">\(S\)</span>上是凸函数，则<span class="math inline">\(f\)</span>的所有局部极小点都是全局极小点，而且局部极小点组成的集合是凸集。如果<span class="math inline">\(f\)</span>是严格凸的，那么最多有一个极小点。</p></li></ol><p>和凸集一样，有时候直接确定函数是不是凸函数比较难，因此可以利用保凸运算：</p><ol type="1"><li>【锥组合】凸函数的锥组合是凸函数。即：对于<span class="math inline">\(\mathbb R^n\)</span>上的凸函数<span class="math inline">\(f_i(x)\)</span>，<span class="math inline">\(\forall \alpha_i&gt;0\)</span>，<span class="math inline">\(F(x)=\sum_i \alpha_if_i(x)\)</span>是凸函数。</li><li>【仿射替换】对于<span class="math inline">\(\mathbb R^n\)</span>上的凸函数<span class="math inline">\(f_i(x)\)</span>，<span class="math inline">\(x=Ay+b\)</span>是<span class="math inline">\(\mathbb R^m\to\mathbb R^n\)</span>的仿射，则<span class="math inline">\(h(y)=f(Ay+b)\)</span>是<span class="math inline">\(\mathbb R^m\)</span>上的凸函数。</li><li>【上确界】对于<span class="math inline">\(\mathbb R^n\)</span>上的凸函数<span class="math inline">\(f_i(x)\)</span>，<span class="math inline">\(h(x)=\max _{i}f_i(x)\)</span>是凸函数。</li><li>【单调复合】<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(\mathbb R^n\)</span>上凸，<span class="math inline">\(h(y)\)</span>在<span class="math inline">\(\mathbb R\)</span>上凸且单增，则<span class="math inline">\(h(f(x))\)</span>在<span class="math inline">\(\mathbb R^n\)</span>上凸。</li></ol><h2 id="解和算法的基本性质">解和算法的基本性质</h2><p>本节主要讨论无约束最优化问题 <span class="math display">\[\min_{x\in S}f(x)\]</span> 其中<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(n\)</span>元实函数，<span class="math inline">\(S\)</span>是<span class="math inline">\(R^n\)</span>的子集（在本章，<span class="math inline">\(S\)</span>在大部分情况下就是<span class="math inline">\(R^n\)</span>）。</p><h3 id="可行方向和一阶条件">可行方向和一阶条件</h3><p>优化的基本思想是目标函数沿着某个方向可以看作一元函数，于是就可以利用一元函数的微积分。对于向量<span class="math inline">\(x,d\)</span>，如果存在<span class="math inline">\(\bar \alpha\)</span>，使得<span class="math inline">\(\forall \alpha\in [0,\bar \alpha],x+\alpha d\in S\)</span>，那么称<span class="math inline">\(d\)</span>是<span class="math inline">\(x\)</span>处的<strong>可行方向</strong>。此时，多元函数转化为一元函数<span class="math inline">\(\phi(a)=f(x*+ad)\)</span>，其导数（方向导数）为： <span class="math display">\[\phi&#39;(a)=\langle \nabla f(x*+ad),d\rangle\]</span> 【一阶必要条件】设<span class="math inline">\(S\subset R^n\)</span>，<span class="math inline">\(f\)</span>是连续可微的，如果<span class="math inline">\(x*\)</span>是局部极小点，那么对于<span class="math inline">\(x*\)</span>处的任何可行方向<span class="math inline">\(d\)</span>，有： <span class="math display">\[\langle \nabla f(x*),d\rangle\geq 0\]</span> 梯度向量的方向是函数增长最快的方向，其与可行方向的内积非负，表示从<span class="math inline">\(x*\)</span>出发，在所有可行方向上移动，<span class="math inline">\(f(x)\)</span>都会增长。</p><p>特别的，如果<span class="math inline">\(x*\)</span>是<span class="math inline">\(S\)</span>的内点，此时所有方向都是可行方向，所以对所有的<span class="math inline">\(d\)</span>都有一阶必要条件条件，容易发现这时的一阶必要条件实际上是 <span class="math display">\[\nabla f(x*)=0\]</span></p><blockquote><p>对于一元函数来说，它就是「一阶导数为零」。</p></blockquote><p>将满足这种条件的点称为「驻点」。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411031615362.png" alt="image-20241103161508658" /><figcaption aria-hidden="true">image-20241103161508658</figcaption></figure><h3 id="二阶条件">二阶条件</h3><p>【二阶必要条件】设<span class="math inline">\(S\subset R^n\)</span>，<span class="math inline">\(f\)</span>是二阶连续可微的，如果<span class="math inline">\(x*\)</span>是局部极小点，那么对于<span class="math inline">\(x*\)</span>处的任何可行方向<span class="math inline">\(d\)</span>，有：</p><ol type="1"><li><span class="math inline">\(\langle \nabla f(x*),d\rangle\geq 0\)</span></li><li>如果<span class="math inline">\(\langle \nabla f(x*),d\rangle= 0\)</span>，则<span class="math inline">\(d^T\nabla^2f(x*)d\geq 0\)</span></li></ol><p>如果<span class="math inline">\(x*\)</span>是集合的内点，这两个条件就变成</p><ol type="1"><li><span class="math inline">\(\langle \nabla f(x*),d\rangle= 0\)</span></li><li><span class="math inline">\(\nabla^2f(x*)\)</span>半正定</li></ol><p>如果<span class="math inline">\(\nabla ^2f(x*)\)</span>正定，那么<span class="math inline">\(x*\)</span>是严格局部极小点。</p><h3 id="线搜索法">线搜索法</h3><p>线搜索法指的是在当前迭代点处，根据收集到的信息选择一个有待进一步探测的方向，然后在这个方向上进行一维搜索得到合适的步长，进而得到下一个迭代点的过程。后续的梯度下降法、共轭梯度法、牛顿法、拟牛顿法都是线搜索法。</p><p>已知初始估计 <span class="math inline">\(\boldsymbol{x}_0, k=0\)</span>.设 <span class="math inline">\(\boldsymbol{x}_k\)</span> 处 <span class="math inline">\(\boldsymbol{g}_k=\nabla f\left(\boldsymbol{x}_k\right) \neq \mathbf{0}\)</span> ，则第 <span class="math inline">\(k\)</span> 次迭代:</p><ol type="1"><li>根据某种近似函数确定设 <span class="math inline">\(\boldsymbol{x}_k\)</span> 处的搜索方向设 <span class="math inline">\(\boldsymbol{d}_{\boldsymbol{k}}\)</span>,</li><li>线搜索: 求解关于 <span class="math inline">\(\alpha\)</span> 的一元函数极小化问题</li></ol><p><span class="math display">\[\min _\alpha \phi(\alpha)=f\left(\boldsymbol{x}_k+\alpha \boldsymbol{d}_k\right)\]</span></p><p>​ 得到步长 <span class="math inline">\(\alpha_k\)</span></p><ol start="3" type="1"><li>置 <span class="math inline">\(\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\alpha_k \boldsymbol{d}_k\)</span></li></ol><p>不同的线搜索法之所以不同，核心区别在于<span class="math inline">\(\boldsymbol{d}_k\)</span>的选取。具体来说，由函数的二次近似 <span class="math display">\[f(x) \approx f\left(\boldsymbol{x}_k\right)+\boldsymbol{g}_k^T\left(\boldsymbol{x}-\boldsymbol{x}_k\right)+\frac{1}{2}\left(\boldsymbol{x}-\boldsymbol{x}_k\right)^T \boldsymbol{B}_k\left(\boldsymbol{x}-\boldsymbol{x}_k\right)\]</span> 只要<span class="math inline">\(\boldsymbol{B}_k\)</span>正定，那么<span class="math inline">\(\boldsymbol{d}_k\)</span>就一定是下降方向。正是不同的<span class="math inline">\(\boldsymbol{B}_k\)</span>导致了不同的搜索方向。</p><p>所谓的<strong>精确线搜索</strong>，指的是精确求解<span class="math inline">\(\min _\alpha \phi(\alpha)=f\left(\boldsymbol{x}_k+\alpha \boldsymbol{d}_k\right)\)</span>。其重要性质为： <span class="math display">\[\nabla f(\boldsymbol{x}_{k+1})^T \boldsymbol{d}_k=0\]</span> 精确线搜索的运算量经常很大，所以大多数情况下都会用<strong>非精确线搜索</strong>，即不精确求解<span class="math inline">\(\min _\alpha \phi(\alpha)=f\left(\boldsymbol{x}_k+\alpha \boldsymbol{d}_k\right)\)</span>，转而使用别的方法确定<span class="math inline">\(\alpha_k\)</span>。如果<span class="math inline">\(\alpha_k\)</span>的选择不合理，则可能会出现算法无法找到最优解的情况。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411031912076.png" alt="算法无法找到最优解" /><figcaption aria-hidden="true">算法无法找到最优解</figcaption></figure><p>对于一元函数<span class="math inline">\(f(x)=x^2\)</span>，想要求其最小值。选取初始点<span class="math inline">\(x_0=2\)</span>。</p><p>左图中有<span class="math inline">\(d_k=-1,\alpha_k=2+\dfrac 3 {2^{k+1}}\)</span>，算法收敛于<span class="math inline">\(1\)</span>。</p><p>右图中有<span class="math inline">\(d_k=(-1)^{k+1},\alpha_k=\dfrac{1}{2^{k+1}}\)</span>，算法有两个聚点<span class="math inline">\(1,-1\)</span>。</p><p>假设<span class="math inline">\(\bar \alpha\)</span>是使得<span class="math inline">\(\phi(\alpha)=\phi(0)\)</span>，即<span class="math inline">\(f(\boldsymbol{x}+\alpha\boldsymbol{d})=f(\boldsymbol{x})\)</span>成立的最小正数，从上述两个例子可以看出，<span class="math inline">\(\alpha\)</span>的选择不能太过靠近区间<span class="math inline">\([0,\bar \alpha]\)</span>的两个端点。有一些法则给出了选取<span class="math inline">\(\alpha\)</span>需要满足的条件。</p><h4 id="armijo条件">Armijo条件</h4><p>定义一次函数 <span class="math display">\[l(\alpha)=\phi(0)+\rho \phi&#39;(0)\alpha\]</span> 其中<span class="math inline">\(\rho\)</span>是由设计者自由选定的参数。于是这个一次函数是一条完全由<span class="math inline">\(\rho\)</span>确定的直线，称为「<span class="math inline">\(\rho\)</span>线」。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411031920343.png" alt="image-20241103192043054" /><figcaption aria-hidden="true">image-20241103192043054</figcaption></figure><p>如果<span class="math inline">\(\alpha\)</span>对应的函数值在<span class="math inline">\(\rho\)</span>线以下，则认为<span class="math inline">\(\alpha\)</span>不太大。再选取参数「缩短因子」<span class="math inline">\(\lambda&lt;1\)</span>，如果将<span class="math inline">\(\alpha\)</span>扩大<span class="math inline">\(\lambda ^{-1}\)</span>倍以后，对应的函数值不再在<span class="math inline">\(\rho\)</span>线以下，则认为<span class="math inline">\(\alpha\)</span>不太小。写成数学表达式，有： <span class="math display">\[\begin{cases} \phi(\alpha) &amp;\leq \phi(0)+\rho \phi^{\prime}(0) \alpha \\\phi(\alpha / \gamma)&amp;&gt;\phi(0)+\rho \phi^{\prime}(0) \alpha / \gamma\end{cases}\]</span></p><h4 id="goldstein测验">Goldstein测验</h4><p>「不太大」的条件不变，将「不太小」的条件改为： <span class="math display">\[\phi(\alpha) \geq \phi(0)+(1-\rho) \phi^{\prime}(0) \alpha\]</span> 这要求<span class="math inline">\(\rho \in (0,\dfrac 12)\)</span>。在上面的图中，也就是两条经过<span class="math inline">\((0,\phi(0))\)</span>的虚线之间的范围，即<span class="math inline">\([b,c]\)</span>。</p><h4 id="wolfe准则">Wolfe准则</h4><p>如果<span class="math inline">\(\phi\)</span>不是二次函数，则Goldstein测验可能使得真正的极小点不满足条件（看上面的图）。此时仍然保持「不太大」条件不变，把「不太小」条件改为 <span class="math display">\[\phi&#39;(\alpha)\geq \sigma\phi&#39;(0)\]</span> 这就是Wolfe准则。</p><h2 id="无约束优化方法">无约束优化方法</h2><h3 id="梯度下降法">梯度下降法</h3><p>梯度下降法的基本格式是： <span class="math display">\[\boldsymbol{x}_{k+1}=\boldsymbol{x}_k-\alpha_k \nabla f(\boldsymbol{x}_k)\]</span> 即线搜索法中让<span class="math inline">\(\boldsymbol{d}_k\)</span>是<span class="math inline">\(f\)</span>在<span class="math inline">\(\boldsymbol{x}_k\)</span>处的负梯度。</p><p>梯度下降法是怎么想到的呢？其实有两种解释。</p><ol type="1"><li><p>函数值在负梯度方向下降最快</p></li><li><p>极小化函数在<span class="math inline">\(\boldsymbol{x}_k\)</span>附近的二次泰勒展开 <span class="math display">\[x_{k+1}=\underset{x\in \mathbb{R}^n}{\arg \min} f\left(\boldsymbol{x}_k\right)+\nabla f\left(\boldsymbol{x}_k\right)^T\left(\boldsymbol{x}-\boldsymbol{x}_k\right)+\frac{1}{2 \alpha_k}\left\|\boldsymbol{x}-\boldsymbol{x}_k\right\|_2^2\]</span></p></li></ol><p>梯度下降法有全局收敛性：假设与初始点 <span class="math inline">\(x_0\)</span> 关联的 <span class="math inline">\(f\)</span> 的下水平集</p><p><span class="math display">\[S=\left\{\boldsymbol{x}: f(\boldsymbol{x}) \leq f\left(\boldsymbol{x}_0\right)\right\}\]</span></p><p>是紧的(有界闭集), 并且 <span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(S\)</span> 的某开集上连续可微. 那么对于步长满足Armijo法则的梯度下降法来说，</p><ol type="1"><li>迭代轨迹不离开 <span class="math inline">\(S: \boldsymbol{x}_i \in S \forall i\)</span></li><li>除非得到驻点；否则 <span class="math inline">\(\left\{f\left(\boldsymbol{x}_i\right)\right\}\)</span> 严格单调递减</li><li>轨迹有聚点, 并且每个聚点均是 <span class="math inline">\(f\)</span> 的驻点.</li></ol><p>接下来分析<span class="math inline">\(f(\boldsymbol{x})\)</span>在满足三种特殊情况的条件下，梯度下降法的复杂性。所谓的复杂性一般指的是一个不等式，衡量了迭代<span class="math inline">\(k\)</span>步时，所得到的值有多接近局部极小点。这三种特殊情况分别是：</p><ol type="1"><li>任何具有Lipschitz（李普希茨）梯度的函数</li><li>任何具有李普希茨梯度的凸函数</li><li>任何具有李普希茨梯度的强凸函数</li></ol><p>在此之前，需要定义「李普希茨梯度」和「强凸函数」。</p><p>【Lipschitz梯度】 设 <span class="math inline">\(L \geq 0\)</span>. 称函数 <span class="math inline">\(f\)</span> 的梯度在开集 <span class="math inline">\(U\)</span> 上是 <span class="math inline">\(L-\)</span> Lipschitz的，如果</p><p><span class="math display">\[\|\nabla f(\boldsymbol{x})-\nabla f(\boldsymbol{y})\| \leq L\|x-y\| \forall x, y \in U .\]</span></p><p>称 <span class="math inline">\(f\)</span> 的梯度在集合 <span class="math inline">\(S\)</span> 上是 <span class="math inline">\(L-\)</span> Lipschitz的，如果存在开集 <span class="math inline">\(U \supseteq S\)</span>使得 <span class="math inline">\(f\)</span> 的梯度在开集 <span class="math inline">\(U\)</span> 上是 <span class="math inline">\(L-\)</span> Lipschitz的.</p><p>Lipschitz梯度这个名字可能有点容易让人误解。它并不是一种特殊的梯度，而指的是函数的梯度满足某种条件。</p><p>如果函数的梯度满足<span class="math inline">\(L-\)</span>Lipschitz条件，也称为这个函数是<span class="math inline">\(L-\)</span>光滑的。函数是<span class="math inline">\(L-\)</span>光滑的等价于函数的Hesse矩阵的谱范数不大于<span class="math inline">\(L\)</span>，即： <span class="math display">\[\forall \boldsymbol{x},||\nabla ^2f(\boldsymbol{x})||_2\leq L\]</span> 从直观上来说，<span class="math inline">\(L\)</span>-光滑性质保证了函数的梯度的变化速率是受限的，可以理解为函数的斜率在任意两点之间的变化都有一个上界，这使得优化算法在更新变量时，能对目标函数的变化有一定的控制。</p><p>【强凸函数】设 <span class="math inline">\(l&gt;0\)</span>. 称定义在凸集 <span class="math inline">\(S\)</span> 上的函数 <span class="math inline">\(f(\)</span> 关于范数 <span class="math inline">\(\|\cdot\|)\)</span>是 <span class="math inline">\(l\)</span> —强凸的(strong convex), 如果对每个 <span class="math inline">\(x_0, x_1 \in S\)</span> 和每个<span class="math inline">\(\theta\in(0,1)\)</span> <span class="math display">\[\quad f\left((1-\theta) x_0+\theta x_1\right) \leq(1-\theta) f\left(x_0\right)+\theta f\left(x_1\right)-\frac{l}{2} \theta(1-\theta)\left\|x_0-x_1\right\|^2 .\]</span> 其实就是比凸函数的定义多了一个<span class="math inline">\(\dfrac{l}{2} \theta(1-\theta)\left\|x_0-x_1\right\|^2 .\)</span></p><p>从直观上来说，强凸性是凸性的加强版，它要求函数不仅仅是凸的，还得有一定的曲率（例如：<span class="math inline">\(|x|\)</span>不是强凸函数），这样的曲率保证了函数在全局上有唯一的最优解，一般来说，强凸函数的<span class="math inline">\(l\)</span>越大，函数的「盆地」越深，优化算法收敛的也越快。</p><h4 id="具有lipschitz李普希茨梯度的函数">具有Lipschitz（李普希茨）梯度的函数</h4><p>【二次上界】：设<span class="math inline">\(f\)</span>的梯度是L-Lipschitz的，那么： <span class="math display">\[f(\boldsymbol{y}) \leq f(\boldsymbol{x})+\nabla f(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x})+\frac{L}{2}\|\boldsymbol{y}-\boldsymbol{x}\|^2 \forall \boldsymbol{x}, \boldsymbol{y} \in \mathbb{R}^n .\]</span> 如果设<span class="math inline">\(\phi(\alpha)=f(\boldsymbol{x}+a(\boldsymbol{y-x}))\)</span>，则上面的式子可以写作（按项对应）： <span class="math display">\[\phi(1)\leq \phi(0)+\phi&#39;(0)+\frac L2\|\boldsymbol{y-x}\|^2\]</span> 由二次上界，可以得到关于梯度下降法的两个结论：</p><ol type="1"><li><p>对于常数步长<span class="math inline">\(\alpha\in \left(0,\dfrac 2L\right)\)</span>，梯度下降法是下降算法</p></li><li><p>对于常数步长<span class="math inline">\(\alpha\in\left(0,\dfrac 1L\right)\)</span>，梯度下降法满足 <span class="math display">\[f\left(\boldsymbol{x}_{s+1}\right) \leq f\left(\boldsymbol{x}_s\right)-\frac{\alpha}{2}\left\|\nabla f\left(\boldsymbol{x}_s\right)\right\|^2 \quad \forall s \geq 0\]</span></p></li></ol><p>为了证明这个结论，只需要让二次上界定理中的<span class="math inline">\(\boldsymbol{x}=\boldsymbol{x}_s,y=\boldsymbol{x}_{s+1}=\boldsymbol{x}_s-\alpha_s \nabla f(\boldsymbol{x}_s)\)</span>即可。 <span class="math display">\[f\left(\boldsymbol{x}_{s+1}\right)-f\left(\boldsymbol{x}_s\right) \leq \alpha\left(\frac{\alpha L}{2}-1\right)\left\|\nabla f\left(\boldsymbol{x}_s\right)\right\|^2 \quad \forall s \geq 0\]</span> 当<span class="math inline">\(\alpha\leq \dfrac 2L\)</span>，右式为负；当<span class="math inline">\(\alpha\leq \dfrac 1L\)</span>，<span class="math inline">\(\dfrac {\alpha L}{2}\leq \dfrac 12\)</span>。</p><p>由这两个结论，可以推出具有Lipschitz（李普希茨）梯度的函数上梯度下降法的复杂度：</p><p>设 <span class="math inline">\(f\)</span> 的梯度是 <span class="math inline">\(L-\)</span> Lipschitz的, 且 <span class="math inline">\(f\)</span> 存在极小点 <span class="math inline">\(\boldsymbol{x}_*\)</span>.记 <span class="math inline">\(f_*=f\left(\boldsymbol{x}_*\right)\)</span>, 则步长为 <span class="math inline">\(1 / L\)</span> 的 GD 迭代满足</p><p><span class="math display">\[\min _{0 \leq s \leq k-1}\left\|\nabla f\left(\boldsymbol{x}_s\right)\right\| \leq \sqrt{\frac{2 L}{k}\left(f\left(\boldsymbol{x}_0\right)-f_*\right)}\]</span> 这里的「复杂度」是用「前<span class="math inline">\(k-1\)</span>步中函数的梯度的最小范数」表示的。当这个范数是零时，意味着找到了驻点。这个范数越小，就越接近驻点。</p><p>将<span class="math inline">\(\alpha=1/L\)</span>代入<span class="math inline">\(f\left(\boldsymbol{x}_{s+1}\right) \leq f\left(\boldsymbol{x}_s\right)-\dfrac{\alpha}{2}\left\|\nabla f\left(\boldsymbol{x}_s\right)\right\|^2\)</span>,有： <span class="math display">\[\frac{1}{2 L}\left\|\nabla f\left(\boldsymbol{x}_s\right)\right\|^2 \leq f\left(\boldsymbol{x}_s\right)-f\left(\boldsymbol{x}_{s+1}\right)\]</span> 对于<span class="math inline">\(s=0\sim k-1\)</span>，写出这个不等式然后求和，消除中间的项，有： <span class="math display">\[\begin{align}f(\boldsymbol{x}_0)-f(\boldsymbol{x}_s)&amp;\geq \frac 1{2L}\sum_{s=0}^{k-1}\|\nabla f(\boldsymbol{x}_s)\|^2\\&amp;\geq \frac k{2L} \min _{0 \leq s \leq k-1}\left\|\nabla f\left(\boldsymbol{x}_s\right)\right\| ^2\end{align}\]</span> 证毕。</p><h4 id="具有李普希茨梯度的凸函数">具有李普希茨梯度的凸函数</h4><p>设 <span class="math inline">\(f\)</span> 是凸函数, 梯度是 <span class="math inline">\(L-\)</span> Lipschitz的, 且 <span class="math inline">\(\boldsymbol{x}_*\)</span> 是它的极小点. 那么步长为 <span class="math inline">\(1 / L\)</span> 的 GD迭代满足</p><p><span class="math display">\[f\left(\boldsymbol{x}_k\right)-f\left(\boldsymbol{x}_*\right) \leq \frac{L\left\|\boldsymbol{x}_0-\boldsymbol{x}_*\right\|^2}{2 k}, k \geq 1 .\]</span> 这里的「复杂度」是用「当前迭代点的函数值和局部极小值的差」表示的。这个差越小，就越接近驻点。</p><h4 id="具有李普希茨梯度的强凸函数">具有李普希茨梯度的强凸函数</h4><p>关于强凸函数有如下结论：</p><ol type="1"><li><span class="math inline">\(f\)</span> 是 <span class="math inline">\(l\)</span> 强凸的当且仅当 <span class="math inline">\(f(\boldsymbol{x})-\frac{l}{2}\|\boldsymbol{x}\|^2\)</span> 是凸的.</li><li>设 <span class="math inline">\(f \in C^1\)</span>. 则 <span class="math inline">\(f\)</span> 在凸集 <span class="math inline">\(S\)</span> 上是1强凸的当且仅当</li></ol><p><span class="math display">\[f(\boldsymbol{y}) \geq f(\boldsymbol{x})+\nabla f(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x})+\frac{l}{2}\|\boldsymbol{y}-\boldsymbol{x}\|^2, \quad \forall \boldsymbol{x}, \boldsymbol{y} \in S .\]</span></p><ol start="3" type="1"><li>设 <span class="math inline">\(f \in C^2\)</span>. 则 <span class="math inline">\(f\)</span> 在内部非空的凸集 <span class="math inline">\(S\)</span> 上是 <span class="math inline">\(l\)</span>-强凸的当且仅当</li></ol><p><span class="math display">\[\nabla^2 f(\boldsymbol{x}) \succeq l \boldsymbol{I}, \quad \forall \boldsymbol{x} \in S .\]</span></p><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(l\)</span>-强凸的, 它的梯度是 <span class="math inline">\(L-\)</span> Lipschitz的, 且 <span class="math inline">\(\boldsymbol{x}_*\)</span> 是 <span class="math inline">\(f\)</span> 的极小点. 那么步长为 <span class="math inline">\(1 / L\)</span> 的 GD迭代满足</p><p><span class="math display">\[\left\|\boldsymbol{x}_k-\boldsymbol{x}_*\right\|^2 \leq\left(1-\frac{1}{k}\right)^k\left\|\boldsymbol{x}_0-\boldsymbol{x}_*\right\|^2 \quad \forall k \geq 1,\]</span></p><p>其中 <span class="math inline">\(\kappa=L / l\)</span>.</p><h3 id="牛顿法">牛顿法</h3><p>考虑二次连续可微的函数，对其进行泰勒展开： <span class="math display">\[f(x)\approx q_k(x)=f(\boldsymbol{ x_k})+(\boldsymbol{x-x_k})^T\nabla f(\boldsymbol{x_k})+\dfrac 12 (\boldsymbol{x-x_k})^T\nabla^2f(\boldsymbol{x}_k)(\boldsymbol{x-x_k})\]</span> 当<span class="math inline">\(\nabla^2f(x_k)\)</span>正定时，<span class="math inline">\(q_k\)</span>有唯一极小点。将极小点作为新迭代，由此得到基本牛顿法： <span class="math display">\[\boldsymbol{x_{k+1}}=\boldsymbol {x}_k-(\nabla ^2f(\boldsymbol{x}_k))^{-1}\nabla f(\boldsymbol x_k)\]</span> 关于牛顿法，有二次收敛定理：假设 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\mathbb{R}^n\)</span> 上是 <span class="math inline">\(M\)</span>-Lipschitz的，且局部极小点 <span class="math inline">\(x_*\)</span> 处的Hesse矩阵 <span class="math inline">\(\nabla^2 f\left(x_*\right)\)</span> 正定, 即存在 <span class="math inline">\(l&gt;0\)</span> 使得 <span class="math inline">\(\nabla^2 f\left(x_*\right) \geqslant l I\)</span>. 如果初始点 <span class="math inline">\(x_0\)</span> 满足</p><p><span class="math display">\[\left\|x_0-x_*\right\| \leq \frac{l}{2 M}\]</span></p><p>那么 <span class="math inline">\(\forall k \geq 0\)</span>, 牛顿法是良定义的, 且由它产生的序列至少二次收敛到 <span class="math inline">\(\boldsymbol{x}_*\)</span>.</p><p>但是在使用上，基本牛顿法存在一些问题。</p><ol type="1"><li><span class="math inline">\(\nabla^2f(x_k)\)</span>正定，但是牛顿增量很大，导致局部二次近似失效</li><li><span class="math inline">\(\nabla f(x_k)\)</span>不正定</li></ol><p>在这两种情况下，基本牛顿法会失效，因此需要寻求将其修正的方法。常用方法是对于<span class="math inline">\(\epsilon_k&gt;0\)</span>，取 <span class="math display">\[M_k=[\nabla^2f(x_k)+\epsilon_kI]^{-1}\]</span> 计算<span class="math inline">\(\nabla^2f(x_k)\)</span>的特征值，设<span class="math inline">\(\epsilon_k\)</span>是让<span class="math inline">\([\nabla^2f(x_k)+\epsilon_kI]\)</span>特征值大于常数<span class="math inline">\(\delta\)</span>的最小非负整数，然后沿方向 <span class="math display">\[d_k=-M_k\nabla f(x_k)\]</span> 进行线搜索。</p><h3 id="共轭梯度法">共轭梯度法</h3><p>【定义：<span class="math inline">\(G-\)</span>正交/共轭】已知对称正定矩阵<span class="math inline">\(G\)</span>，定义两个向量的<span class="math inline">\(G-\)</span>内积： <span class="math display">\[\langle\boldsymbol{u}, \boldsymbol{v}\rangle_G=\boldsymbol{u}^T \boldsymbol{G} \boldsymbol{v}\]</span> 如果两个向量的<span class="math inline">\(G-\)</span>内积为<span class="math inline">\(0\)</span>，则称其为<span class="math inline">\(G-\)</span>正交或者<span class="math inline">\(G-\)</span>共轭向量。</p><p>共轭梯度法的过程如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411271520022.png" alt="image-20241127151957560" /><figcaption aria-hidden="true">image-20241127151957560</figcaption></figure><h3 id="次梯度">次梯度</h3><p>为了讨论次梯度和次微分，引入扩展实值函数：</p><p>设 <span class="math inline">\(S \subseteq \mathbb{R}^n, f: S \rightarrow[-\infty,+\infty]\)</span>. 称</p><p><span class="math display">\[\{(\boldsymbol{x}, r): \boldsymbol{x} \in S, r \in \mathbb{R}, r \geq f(x)\}\]</span></p><p>是 <span class="math inline">\(f\)</span> 的上镜图(epigraph),记作<span class="math inline">\(\text{epi} f\)</span>. 如果<span class="math inline">\(\text{epi} f\)</span>是 <span class="math inline">\(\mathbb{R}^{n+1}\)</span> 中的凸集，称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(S\)</span> 上的凸函数. 称 <span class="math inline">\(\mathrm{epi} f\)</span> 在 <span class="math inline">\(\mathbb{R}^n\)</span> 上的投影是 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(S\)</span> 上的有效域(effective domain), 记作<span class="math inline">\(\text{dom} f\)</span> 。</p><p>简单来说，上镜图就是函数图像上面的部分，有效域就是函数的「定义域」。</p><p>如果凸函数满足有效域非空，且<span class="math inline">\(\forall x,f(x)&gt;-\infty\)</span>，那么称这个函数为「正常凸函数」，这个假设叫做「正常假设」。</p><p>设函数<span class="math inline">\(f\)</span>在凸集<span class="math inline">\(S\)</span>上凸，则其扩展实值表示为： <span class="math display">\[\tilde{f}(\boldsymbol{x})=\left\{\begin{array}{cc}f(\boldsymbol{x}), &amp; \text { 如果 } \boldsymbol{x} \in S \\+\infty, &amp; \text { 否则 }\end{array}\right.\]</span> 从这个函数可以看出有效域和定义域的区别，在这里，定义域是<span class="math inline">\(R^n\)</span>，有效域是<span class="math inline">\(S\)</span>。</p><p>【次梯度】称向量 <span class="math inline">\(\boldsymbol{g}\)</span> 是凸函数 <span class="math inline">\(f: \mathbb{R}^n \rightarrow(-\infty,+\infty]\)</span> 在点 <span class="math inline">\(\boldsymbol{x}\)</span> 的次梯度(subgradient), 如果</p><p><span class="math display">\[f(\boldsymbol{y}) \geq f(\boldsymbol{x})+\boldsymbol{g}^T(\boldsymbol{y}-\boldsymbol{x}), \quad \forall \boldsymbol{y} \in \mathbb{R}^n .\]</span></p><p><span class="math inline">\(f\)</span> 在 <span class="math inline">\(x\)</span> 的次梯度的全体称作 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x\)</span> 处的次微分(subdifferential),记作 <span class="math inline">\(\partial f(x)\)</span>. 如果 <span class="math inline">\(\partial f(x) \neq \varnothing\)</span>, 称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x\)</span> 处次可微 (subdifferentiable).</p><p>其中<span class="math inline">\(h(\boldsymbol{y})=f(\boldsymbol{x})+\boldsymbol{g}^T(\boldsymbol{y}-\boldsymbol{x}), \quad\)</span>是一个关于<span class="math inline">\(\boldsymbol{y}\)</span>的仿射函数，次梯度中不等式的含义，就是这个仿射函数的图像是<span class="math inline">\(f\)</span>上镜图<span class="math inline">\(\text{epi} f\)</span>在点<span class="math inline">\((x,f(x))\)</span>处的非竖直支撑超平面。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202411271553666.png" alt="示意图" style="zoom: 67%;" /></p><p>其中<span class="math inline">\(g_1,g_2\)</span>是<span class="math inline">\(f\)</span>在<span class="math inline">\(x_1\)</span>处的次梯度，<span class="math inline">\(g_3\)</span>是<span class="math inline">\(f\)</span>在<span class="math inline">\(x_2\)</span>处的次梯度。</p><p>对于凸函数<span class="math inline">\(f\)</span>，<span class="math inline">\(x\in \text{dom}f\)</span>，如果<span class="math inline">\(f\)</span>在<span class="math inline">\(x\)</span>处可微，那么<span class="math inline">\(\partial f(x)=\{\nabla f(x)\}\)</span>，反之，如果<span class="math inline">\(f\)</span>在<span class="math inline">\(x\)</span>处的次梯度唯一，那么<span class="math inline">\(f\)</span>可微。</p><p>设 <span class="math inline">\(f\)</span> 是凸函数. 那么 <span class="math inline">\(\forall \boldsymbol{x}, \partial f(\boldsymbol{x})\)</span> 是闭凸集. 对于 <span class="math inline">\(\boldsymbol{x} \notin \operatorname{dom} f, \partial f(\boldsymbol{x})=\emptyset\)</span>. 对于 <span class="math inline">\(\boldsymbol{x} \in \operatorname{ri}(\operatorname{dom} f), \partial f(\boldsymbol{x})\)</span> 非空, 这时 <span class="math inline">\(f\)</span> 沿方向 <span class="math inline">\(\boldsymbol{d}\)</span> 的方向导数存在，并且</p><p><span class="math display">\[f^{\prime}(\boldsymbol{x} ; \boldsymbol{d})=\max _{\boldsymbol{g} \in \partial f(\boldsymbol{x})} \boldsymbol{d}^T \boldsymbol{g}\]</span></p><p>最后， <span class="math inline">\(\partial f(\boldsymbol{x})\)</span> 是非空有界闭凸集当且仅当 <span class="math inline">\(\boldsymbol{x} \in \operatorname{int}(\operatorname{dom} f)\)</span>.此时对每个 <span class="math inline">\(d, f^{\prime}(\boldsymbol{x} ; \boldsymbol{d})\)</span> 有限.</p><p><a href="https://blog.sakizuki.site/2024/10/03/%E6%9C%80%E4%BC%98%E5%8C%96/#%E9%9B%86%E5%90%88%E7%9A%84%E5%86%85%E9%83%A8%E5%92%8C%E9%97%AD%E5%8C%85">如果忘了</a>，这里的<span class="math inline">\(\text{ri}\)</span>是「相对内部」，<span class="math inline">\(\text{int}\)</span>是「内部」。</p><p>最优性条件:设 <span class="math inline">\(f: \mathbb{R}^n \rightarrow(-\infty,+\infty]\)</span> 是凸的.</p><ol type="1"><li>则 <span class="math inline">\(\boldsymbol{x}_*\)</span> 是 <span class="math inline">\(f\)</span> 的极小点当且仅当 <span class="math inline">\(0 \in \partial f\left(\boldsymbol{x}_*\right)\)</span>.</li><li>设 <span class="math inline">\(C \subseteq \mathbb{R}^n\)</span> 是非空凸集，则 <span class="math inline">\(x_*\)</span> 是 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(C\)</span> 上的极小点的充分条件是：存在 <span class="math inline">\(\boldsymbol{u} \in \partial f\left(\boldsymbol{x}_*\right)\)</span> 使得 <span class="math inline">\(-\boldsymbol{u} \in N_C\left(\boldsymbol{x}_*\right)\)</span> 。如果ri <span class="math inline">\((\operatorname{dom} f)\)</span> 与 ri <span class="math inline">\(C\)</span> 相交, 或者当 <span class="math inline">\(C\)</span> 是多面体时 ri( <span class="math inline">\(\operatorname{dom} f)\)</span> 与C相交, 该条件是必要的.</li></ol><h2 id="约束优化问题kkt条件">约束优化问题（KKT条件）</h2><p>考虑有如下格式的优化问题： <span class="math display">\[\begin{align}\text{minimize}\ \ &amp;f(x)\\\text{s.t.}\ \ &amp;h_i(x)=0,i=1,\cdots,m\\&amp;g_i(x)\leq 0,i=1,\cdots,l\\\end{align}\]</span> 其中，所有的<span class="math inline">\(f,g_i,h_i\)</span>都是可微的。</p><blockquote><p>把常用的不可微分函数转变为可微分函数的技巧：</p><ol type="1"><li><p><span class="math inline">\(\max\{f,g\}\leq 0\to f\leq0\)</span>且<span class="math inline">\(g\leq 0\)</span></p></li><li><p><span class="math inline">\(\min\{f,g\}\geq 0 \to f\geq 0\)</span>且<span class="math inline">\(g\geq 0\)</span></p></li><li><p><span class="math inline">\(|f|=\max\{-f,f\}\)</span></p></li></ol></blockquote><p>假如<span class="math inline">\(x*\)</span>是问题的局部最优解，而且在<span class="math inline">\(x*\)</span>处满足某个「适当的条件」，则存在<span class="math inline">\(\lambda,\mu\)</span>使得： <span class="math display">\[\begin{align}\nabla f(x^*)+\sum_{i=1}^m \lambda_i \nabla g_i(x^*)+\sum_{i=1}^l \mu_i\nabla h_i(x^*)&amp;=0\\\lambda_i&amp;\geq 0\\g_i(x^*)&amp;\leq 0\\h_i(x^*)&amp;= 0\\\lambda_ig_i(x^*)&amp;=0\end{align}\]</span> 这一组条件被称为KKT条件。为了对KKT条件建立一个直观印象，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412271616157.png" alt="image-20241227161650142" /><figcaption aria-hidden="true">image-20241227161650142</figcaption></figure><p>考虑如图所示的二维平面优化问题。红色的曲线是三个约束函数<span class="math inline">\(g_i(x)\leq0\)</span>的<span class="math inline">\(0\)</span>等值线，绿色虚线是<span class="math inline">\(f(x)\)</span>等值线，在最左边这个点取到最小值。那么，在这个点，观察三条蓝色的向量。可以发现，<span class="math inline">\(-\nabla f\)</span>即<span class="math inline">\(f\)</span>的负梯度应当是<span class="math inline">\(\nabla g_1,\nabla g_2\)</span>的线性组合，而且组合系数都是正数。这就是KKT条件的第一条式子的来历。我们发现，<span class="math inline">\(g_3(x)\leq0\)</span>这个条件目前并没有「起作用」，所以它的梯度对应的线性组合系数是零。KKT条件的第五条式子，即 <span class="math display">\[\lambda_ig_i(x^*)=0\]</span> 正是在标记哪些条件在「起作用」。如果起作用了，那么<span class="math inline">\(\lambda_i\geq 0,g_i(x^*)=0\)</span>；否则，如果没起作用，那么<span class="math inline">\(g_i(x^*)\neq0\)</span>，此时有<span class="math inline">\(\lambda_i=0\)</span>。我们管「起作用」了的约束条件叫做「积极约束」。用记号： <span class="math display">\[A(x^*)=\{j\mid g_j(x^*)=0,j=1,\cdots,l\}\]</span> 表示积极约束（的标号）的集合。</p><p>KKT条件是「一阶必要条件」，即凡是局部最优解都满足KKT条件，但是满足KKT条件的不一定是局部最优解。</p><blockquote><p>简单介绍一下证明KKT条件的思路：</p><ol type="1"><li><p>如果<span class="math inline">\(x^*\)</span>是局部最优解，那么<span class="math inline">\(D(x^*)\cap T(x^*)=\empty\)</span>。其中，<span class="math inline">\(D,T\)</span>都是一些方向的集合。</p><p><span class="math inline">\(D\)</span>是使得目标函数下降的方向的集合，即和目标函数的梯度的内积小于零： <span class="math display">\[D(x^*)=\{d\mid \nabla f(x^*)d\leq 0\}\]</span> <span class="math inline">\(T\)</span>是「切向锥」,即从<span class="math inline">\(x^*\)</span>开始，往哪些方向稍微挪动一点，不会离开可行域的范围： <span class="math display">\[T(x^*)=\left\{\alpha d\mid \alpha&gt;0,d=\lim_{k\to \infty}\frac{x_k-x^*}{\|x_k-x^*\|}\mid x_k\to x^*\right\}\]</span></p></li><li><p>因为<span class="math inline">\(T\)</span>很难求，所以另外定义一个「看起来像可行的方向的集合」 <span class="math display">\[F_1(x^*)=\{d\mid \nabla g_i(x)^Td\leq 0,\nabla h_j(x)^Td=0\mid i\in A(x^*) ,j=1,\cdots,l\}\]</span> 构造它的方法是「排除显然不可能的方向」，例如，让<span class="math inline">\(g_i(x)\)</span>上升的方向（<span class="math inline">\(\nabla g_i(x)^T&gt;0\)</span>）以及让<span class="math inline">\(h_i(x)\)</span>变化的方向<span class="math inline">\(\nabla h_i(x)^Td\neq 0\)</span></p></li><li><p>在某些「适当的条件」下，有<span class="math inline">\(T(x^*)=F_1(x^*)\)</span>。此时，有： <span class="math display">\[D(x^*)\cap F_1(x^*)=0\]</span> 这其实是KKT条件的某种等价表述。</p></li></ol></blockquote><p>之前提到的那个「适当的条件」叫做「约束品性」，常见的约束品性有：</p><ol type="1"><li>正则性：设点<span class="math inline">\(x^*\)</span>满足<span class="math inline">\(h(x^*)=0,g(x^*)\leq 0\)</span>，对于<span class="math inline">\(x^*\)</span>处的所有<span class="math inline">\(h\)</span>和积极约束<span class="math inline">\(g\)</span>，如果梯度向量<span class="math inline">\(\nabla h_1(x^*),\cdots,\nabla h_n(x^*),\nabla g_j(x^*),j\in A(x^*)\)</span>是线性无关的，称<span class="math inline">\(x^*\)</span>是约束<span class="math inline">\(h(x^*)=0,g(x^*)\leq 0\)</span>的正则点。如果<span class="math inline">\(x^*\)</span>是局部最优解而且是正则点，那么KKT条件成立。</li></ol><p>如果满足：</p><ol type="1"><li><span class="math inline">\(f,g_i\)</span>都是凸函数</li><li><span class="math inline">\(h_i\)</span>是线性函数</li></ol><p>那么，原问题是凸问题，而且KKT点就是全局最优点。</p><p>现在的问题是，这两个条件实在是太强了，有没有弱一点的条件，也能说明KKT点是最优点？</p><h3 id="二阶必要条件">二阶必要条件</h3><p>假设对于KKT点<span class="math inline">\(x^*\)</span>： <span class="math display">\[\begin{align}\nabla f(x^*)+\sum_{i=1}^m \lambda_i \nabla g_i(x^*)+\sum_{i=1}^l \mu_i\nabla h_i(x^*)&amp;=0\\\lambda_i&amp;\geq 0\\g_i(x^*)&amp;\leq 0\\h_i(x^*)&amp;= 0\\\lambda_ig_i(x^*)&amp;=0\end{align}\]</span> 考虑一个函数： <span class="math display">\[L(x,\lambda,\mu)=f(x)+\sum_{i=1}^m \lambda_ig_i(x)+\sum_{i=1}^l \mu_ih_i(x)\]</span> 注意，因为满足了KKT条件，所以这个函数里面只有<span class="math inline">\(x\)</span>是变量，<span class="math inline">\(\lambda,\mu\)</span>都是常量。这个函数<span class="math inline">\(L(x)\)</span>有什么性质？</p><ol type="1"><li><span class="math inline">\(\nabla L(x^*)=0\)</span>。这就是KKT条件的第一条</li><li><span class="math inline">\(L(x^*)=f(x^*)\)</span>。因为KKT条件的第五条，所以第二项是零；因为KKT条件的第四条，所以第三项是零。</li><li><span class="math inline">\(\forall x\in S,L(x)\leq f(x)\)</span>，其中<span class="math inline">\(S\)</span>是原问题的可行解集。因为在可行解集里总有<span class="math inline">\(\sum_{i=1}^m \lambda_ig_i(x)\leq 0\)</span>。</li></ol><p>由2和3知：如果<span class="math inline">\(x^*\)</span>的<span class="math inline">\(L(x)\)</span>的最优解（最小值），那么<span class="math inline">\(x^*\)</span>是原问题的最优解。</p><p>对于无约束问题<span class="math inline">\(\text{minimize}\ \ L(x)\)</span>，其二阶条件有：</p><ol type="1"><li><span class="math inline">\(\nabla^2L(x)\)</span>半正定，那么<span class="math inline">\(x^*\)</span>是原问题的全局最优解</li><li><span class="math inline">\(\nabla ^2L(x)\)</span>在<span class="math inline">\(S\)</span>中的一个<span class="math inline">\(x^*\)</span>的邻域里半正定，那么<span class="math inline">\(x^*\)</span>是原问题的局部最优解</li><li><span class="math inline">\(\nabla^2L(x^*)\)</span>正定，那么<span class="math inline">\(x^*\)</span>是原问题的严格局部最优解。</li></ol><p>接下来重点考虑第三项。正定，也就是说有二次型： <span class="math display">\[d^T\nabla^2L(x^*)d&gt;0,\forall d\]</span> 那么这个条件能不能再弱一点呢？这个二次型或许不需要对任何<span class="math inline">\(d\)</span>都正定。回忆证明KKT条件时用的的<span class="math inline">\(F_1(x^*)\)</span>集合，它是「看起来像可行的方向的集合」。只要<span class="math inline">\(d\)</span>看起来不是可行方向，那么就可以不考虑这个<span class="math inline">\(d\)</span>。于是，有： <span class="math display">\[d^T\nabla^2L(x^*)d&gt;0,d\in F_1(x^*)\]</span> 那么这个条件能不能再再弱一点呢？对于大于<span class="math inline">\(0\)</span>的<span class="math inline">\(\lambda_i,i\in A(x^*)\)</span>，如果<span class="math inline">\(\nabla g_i(x^*)^Td&lt; 0\)</span>，则<span class="math inline">\(x*\)</span>沿着<span class="math inline">\(d\)</span>移动，会导致<span class="math inline">\(g_i(x)\)</span>小于零，而这意味着目标函数的值上升。定义 <span class="math display">\[F_2(x^*)=\{d\mid \nabla g_i(x)^Td= 0,\nabla h_j(x)^Td=0\mid i\in A^+(x^*) ,j=1,\cdots,l\}\]</span> 其中， <span class="math display">\[A^+(x^*)=\{j\mid g_j(x^*)=0,\lambda_j\neq0,j=1,\cdots,l\}\]</span> 二阶必要条件的最终表述为：</p><p>假如<span class="math inline">\(x^*\)</span>满足KKT条件，<span class="math inline">\(\lambda,\mu\)</span>为相应的乘子， <span class="math display">\[L(x,\lambda,\mu)=f(x)+\sum_{i=1}^m \lambda_ig_i(x)+\sum_{i=1}^l \mu_ih_i(x)\]</span> <span class="math inline">\(\nabla L(x^*)=0\)</span>，若<span class="math inline">\(d^T\nabla^2L(x^*)d&gt;0,\forall x\in F_2(x^*)\)</span>，则<span class="math inline">\(x^*\)</span>是原问题的严格最优解。</p><h3 id="对偶问题">对偶问题</h3><p>考虑一般的约束问题<span class="math inline">\((P)\)</span>: <span class="math display">\[\begin{align}\text{minimize}\ \ &amp;f(x)\\\text{s.t.}\ \ &amp;h_i(x)=0,i=1,\cdots,m\\&amp;g_i(x)\leq 0,i=1,\cdots,l\\&amp;x\in X\end{align}\]</span> 记录可行集，即满足所有约束条件的集合为<span class="math inline">\(S\)</span>。</p><p>如果<span class="math inline">\((P)\)</span>问题比较难于求解，例如<span class="math inline">\((P)\)</span>是非凸问题，我们试图寻找一个和<span class="math inline">\((P)\)</span>关系紧密，又比较简单的问题<span class="math inline">\((D)\)</span>。</p><p>引入拉格朗日函数： <span class="math display">\[L(x,\lambda,\mu)=f(x)+\sum_{i=1}^m \lambda_ig_i(x)+\sum_{i=1}^l \mu_ih_i(x)\]</span> 和对偶函数，即在集合约束满足的前提下对拉格朗日函数求最小值： <span class="math display">\[d(\lambda,\mu)=\min_{x\in X}\left\{f(x)+\sum_{i=1}^m \lambda_ig_i(x)+\sum_{i=1}^l \mu_ih_i(x)\right\}\]</span> 给一组<span class="math inline">\(\lambda,\mu\)</span>，在<span class="math inline">\(X\)</span>里面就有一个<span class="math inline">\(L(x,\lambda,\mu)\)</span>的最小值；给另一组<span class="math inline">\(\lambda,\mu\)</span>，就会对应另一个最小值，这样一来，我们把这个最小值写成<span class="math inline">\(\lambda,\mu\)</span>的函数<span class="math inline">\(d(\lambda,\mu)\)</span>。接下来研究 <span class="math inline">\(d\)</span> 函数的特征，有： <span class="math display">\[\begin{align}\forall \lambda,\mu,\lambda&gt;0,d(\lambda,\mu)&amp;=\min_{x\in X}\left\{f(x)+\sum_{i=1}^m \lambda_ig_i(x)+\sum_{i=1}^l \mu_ih_i(x)\right\}\\&amp;\leq \min_{x\in S}\left\{f(x)+\sum_{i=1}^m \lambda_ig_i(x)+\sum_{i=1}^l \mu_ih_i(x)\right\}\\&amp; \leq \min_{x\in S}\left\{f(x)\right\}=v(P)\end{align}\]</span> 其中，<span class="math inline">\(v(P)\)</span>表示<span class="math inline">\((P)\)</span>问题的最优值，即<span class="math inline">\((P)\)</span>问题最优值的下界。由此，我们可以说，<span class="math inline">\(d(\lambda,\mu)\)</span>是对<span class="math inline">\((P)\)</span>问题的下界的估计。对下界的估计必然是越大越好，于是，有： <span class="math display">\[\begin{align}\text{maximize}\ \ &amp;d(\lambda,\mu)\\\text{s.t.}\ \ &amp;\lambda_i\geq 0,i=1,\cdots ,m\end{align}\]</span> 我们把这个问题叫做「对偶问题」，记作<span class="math inline">\((D)\)</span>。接下来分析一下对偶问题和原问题的关系。对偶问题可以写作： <span class="math display">\[\max_{\lambda\geq 0,\mu}\min_{x\in X}L(x,\lambda,\mu)\]</span> 如果我们把两个求最值换一下顺序： <span class="math display">\[\min_{x\in X}\max_{\lambda\geq 0,\mu}L(x,\lambda,\mu)\]</span> 其中，<span class="math inline">\(\max_{\lambda&gt;0,\mu}L(x,\lambda,\mu)\)</span>是很容易取到正无穷的。因为如果<span class="math inline">\(g(x)&gt;0\)</span>，因为<span class="math inline">\(\lambda\)</span>无上界，所以可以取到正无穷。如果<span class="math inline">\(h(x)\neq0\)</span>，因为<span class="math inline">\(\mu\)</span>无上下界，所以也可以取到正无穷。那么有： <span class="math display">\[\max_{\lambda&gt;0,\mu}L(x,\lambda,\mu)=\begin{cases}f(x),&amp;g_i(x)\leq 0,h_i(x)=0\\+\infty,&amp;\text{otherwise}\end{cases}\]</span> 然后求外层的最小值，显然我们不关心正无穷的情况，那么有： <span class="math display">\[\begin{align}\text{minimize}\ \ &amp;f(x)\\\text{s.t.}\ \ &amp;h_i(x)=0,i=1,\cdots,m\\&amp;g_i(x)\leq 0,i=1,\cdots,l\\&amp;x\in X\end{align}\]</span> 我们发现，这就是原问题<span class="math inline">\((P)\)</span>。</p><p>接下来，讨论一下对偶问题的几何解释。<span class="math inline">\(x\)</span>为点<span class="math inline">\((y,z)\)</span>。<span class="math inline">\(f(x)=x_1=z\)</span>，即取向量的第一个分量；<span class="math inline">\(g(x)=x_2=y\)</span>，即取坐标的第二个分类。考虑原问题： <span class="math display">\[\begin{align}\text{minimize}\ \ &amp;z\\\text{s.t.}\ \ &amp;y\leq 0\\&amp;(y,z)\in G\end{align}\]</span> 那么有： <span class="math display">\[d(\lambda)=\min_{(y,z)\in G}\{z+\lambda y\}\]</span> 对偶问题为： <span class="math display">\[\begin{align}\text{maximize}\ \ &amp;d(\lambda)\\\text{s.t.}\ \ &amp;\lambda\geq 0\end{align}\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412282343286.png" alt="image-20241228234339606" /></p><p>如图所示是原问题的解。红色阴影区域即原问题的可行区域，绿色的点就是原问题的最优解。</p><p>那么已知<span class="math inline">\(\lambda\)</span>，如何求<span class="math inline">\(d(\lambda)\)</span>？假如说，有<span class="math inline">\(d(\lambda)=\alpha\)</span>，那么有直线： <span class="math display">\[z+\lambda y=\alpha\]</span> 我们尽可能地把直线往下移动，而且让其至少有一部分在<span class="math inline">\(G\)</span>以内，</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412282345224.png" alt="image-20241228234458195" /><figcaption aria-hidden="true">image-20241228234458195</figcaption></figure><p>蓝色圆圈处的点就是已知<span class="math inline">\(\lambda\)</span>时的<span class="math inline">\(d(\lambda)\)</span>。</p><p>现在，我们要改变<span class="math inline">\(\lambda\)</span>，求<span class="math inline">\(\lambda&gt;0\)</span>时的<span class="math inline">\(d(\lambda)\)</span>最大值，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412282348286.png" alt="image-20241228234840079" /><figcaption aria-hidden="true">image-20241228234840079</figcaption></figure><p>图中，浅蓝色的直线表示了不同<span class="math inline">\(\lambda\)</span>时<span class="math inline">\(d(\lambda)\)</span>的计算过程。最终，<span class="math inline">\(d(\lambda)\)</span>在深蓝色直线处取得最大值，我们发现它刚好是<span class="math inline">\(v(P)\)</span>，即有：<span class="math inline">\(v(D)=v(P)\)</span>。</p><p>那么这是巧合吗，是否永远有<span class="math inline">\(v(D)=v(P)\)</span>呢？很遗憾，这是巧合。这是因为我们的<span class="math inline">\(G\)</span>集合刚好是一个性质特别特别好的集合。如果它长得丑一点，比如：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202412290002904.png" alt="image-20241229000227829" /><figcaption aria-hidden="true">image-20241229000227829</figcaption></figure><p>如图所示是原问题的解。红色阴影区域即原问题的可行区域，绿色的点就是原问题的最优解。</p><p>接下来在这个附近变化<span class="math inline">\(\lambda\)</span>，观察一下对偶问题的解。浅蓝色直线<span class="math inline">\(1\)</span>是<span class="math inline">\(\lambda\)</span>过小的情况，自不必说；深蓝色直线是最优解的情况。这时如果有人问，如果继续增大<span class="math inline">\(\lambda\)</span>，那么不会和<span class="math inline">\(z\)</span>轴交在更高的地方吗？这里我画出了继续增大<span class="math inline">\(\lambda\)</span>的灰色直线，我们发现，这时，它和<span class="math inline">\(z\)</span>轴的交点并不是<span class="math inline">\(d(\lambda)\)</span>（请复习<span class="math inline">\(d(\lambda)\)</span>的计算方法），而与他平行的下面那条蓝色直线<span class="math inline">\(2\)</span>才是和<span class="math inline">\(d(\lambda)\)</span>对应的真正的直线。</p><p>我们可以发现： <span class="math display">\[v(D)\leq v(P)\]</span></p><p>考虑线性规划问题： <span class="math display">\[\begin{align}\text{minimize}\ \ &amp;c^Tx\\\text{s.t.}\ \ &amp;Ax=b\\&amp;-x\leq 0\\&amp;x\in \mathbb R^n\end{align}\]</span></p><p><span class="math display">\[L(x,\mu)=c^Tx+\mu^T(b-Ax)\]</span></p><p><span class="math display">\[d(\mu)=\min_{x\geq0}\{(c-A^T\mu)^Tx+b^T\mu\}\]</span></p><p>有： <span class="math display">\[d(\mu)=\begin{cases}b^T\mu,&amp;c-A^T\mu\geq 0\\-\infty,&amp;\text{otherwise}\end{cases}\]</span> 对偶问题为： <span class="math display">\[\begin{align}\text{maximize}\ \ &amp;b^T\mu\\\text{s.t.}\ \ &amp;A^T\mu\leq c\end{align}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么在2024年给CentOS7的gcc升级</title>
    <link href="/2024/08/15/%E6%80%8E%E4%B9%88%E5%9C%A82024%E5%B9%B4%E7%BB%99CentOS7%E7%9A%84gcc%E5%8D%87%E7%BA%A7/"/>
    <url>/2024/08/15/%E6%80%8E%E4%B9%88%E5%9C%A82024%E5%B9%B4%E7%BB%99CentOS7%E7%9A%84gcc%E5%8D%87%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>出于某种原因，我需要在2024年使用CentOS7，而且还要给它自带的gcc升级。网上的教程们，比如<a href="https://www.cnblogs.com/shadowmurloc-blog/p/18060565">这个</a>，多数要用到<code>yum</code>命令在线下载，但是CentOS7的软件源在2024年早就被关停了，我在网上找了好多镜像，也没有结果，总是报这个错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">Could not retrieve mirrorlist http://mirrorlist.centos.org?<span class="hljs-built_in">arch</span>=x86_64&amp;release=7&amp;repo=sclo-rh error was<br>14: curl#6 - <span class="hljs-string">&quot;Could not resolve host: mirrorlist.centos.org; 未知的错误&quot;</span><br><br><br> One of the configured repositories failed (未知),<br> and yum doesn<span class="hljs-string">&#x27;t have enough cached data to continue. At this point the only</span><br><span class="hljs-string"> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:</span><br><span class="hljs-string"></span><br><span class="hljs-string">     1. Contact the upstream for the repository and get them to fix the problem.</span><br><span class="hljs-string"></span><br><span class="hljs-string">     2. Reconfigure the baseurl/etc. for the repository, to point to a working</span><br><span class="hljs-string">        upstream. This is most often useful if you are using a newer</span><br><span class="hljs-string">        distribution release than is supported by the repository (and the</span><br><span class="hljs-string">        packages for the previous distribution release still work).</span><br><span class="hljs-string"></span><br><span class="hljs-string">     3. Run the command with the repository temporarily disabled</span><br><span class="hljs-string">            yum --disablerepo=&lt;repoid&gt; ...</span><br><span class="hljs-string"></span><br><span class="hljs-string">     4. Disable the repository permanently, so yum won&#x27;</span>t use it by default. Yum<br>        will <span class="hljs-keyword">then</span> just ignore the repository <span class="hljs-keyword">until</span> you permanently <span class="hljs-built_in">enable</span> it<br>        again or use --enablerepo <span class="hljs-keyword">for</span> temporary usage:<br><br>            yum-config-manager --<span class="hljs-built_in">disable</span> &lt;repoid&gt;<br>        or<br>            subscription-manager repos --<span class="hljs-built_in">disable</span>=&lt;repoid&gt;<br><br>     5. Configure the failing repository to be skipped, <span class="hljs-keyword">if</span> it is unavailable.<br>        Note that yum will try to contact the repo. when it runs most commands,<br>        so will have to try and fail each time (and thus. yum will be be much<br>        slower). If it is a very temporary problem though, this is often a <span class="hljs-built_in">nice</span><br>        compromise:<br><br>            yum-config-manager --save --<span class="hljs-built_in">setopt</span>=&lt;repoid&gt;.skip_if_unavailable=<span class="hljs-literal">true</span><br><br>Cannot find a valid baseurl <span class="hljs-keyword">for</span> repo: centos-sclo-rh/x86_64<br></code></pre></td></tr></table></figure><p>于是我不得不在不使用<code>yum</code>的情况下安装gcc。</p><p>首先，获取软件包。在<a href="https://ftp.gnu.org/gnu/gcc/">gcc的官网</a>上选择你需要的版本。注意，如果你选择了太新的版本，有编译不通过的可能。在这里，我选择的是<a href="https://ftp.gnu.org/gnu/gcc/gcc-6.1.0/">gcc-6.1.0</a>。</p><p>选择好了以后，下载所需的软件包，<code>.tar.gz</code>格式即可。当然，你也可以在准备保存下载文件的文件夹处打开终端，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://ftp.gnu.org/gnu/gcc/gcc-6.1.0/gcc-6.1.0.tar.gz<br></code></pre></td></tr></table></figure><p>然后使用<code>tar</code>命令解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xzvf gcc-6.1.0.tar.gz<br></code></pre></td></tr></table></figure><p>解压完成后进入解压得到的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> gcc-6.1.0<br></code></pre></td></tr></table></figure><p>用脚本安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./contrib/download_prerequisites<br></code></pre></td></tr></table></figure><p>建立并进入一个用来编译的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> gcc-build-6.1.0<br><span class="hljs-built_in">cd</span> gcc-build-6.1.0<br></code></pre></td></tr></table></figure><p>初始化编译设置，生成makefile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib<br></code></pre></td></tr></table></figure><p>开始编译。这一步耗时会非常长，我在虚拟机上用了6个小时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p>重启电脑，检查gcc版本：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">gcc <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc (GCC) 6.1.0<br>Copyright © 2016 Free Software Foundation, Inc.<br>本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；<br>包括没有适销性和某一专用目的下的适用性担保。<br></code></pre></td></tr></table></figure><p>说明你更新好了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是怎么学会自行车的</title>
    <link href="/2024/08/06/%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E4%BC%9A%E8%87%AA%E8%A1%8C%E8%BD%A6%E7%9A%84/"/>
    <url>/2024/08/06/%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E4%BC%9A%E8%87%AA%E8%A1%8C%E8%BD%A6%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>尽管我拿到了工学和理学的两个学士学位，但其实我直到两天以前都不会骑自行车。这听起来很离谱，但是确实是事实。在之前，我的父母和朋友们总是试图教我骑自行车，但是他们屡战屡败，屡败屡战，屡战屡败。虽然试了很多次，但是他们的教法无外乎三种：</p><blockquote><p>骑自行车就是要找到一个「窍」，只要你这个「窍」通了，就什么都会了。</p><p>你问我自行车向左倾斜的时候应该怎么办？其实主要就是一个感觉，你有了这个感觉了就会了。</p><p>骑自行车怎么能摔呢？快要摔了的时候用腿一撑地不就好了么？</p></blockquote><p>这些话语都有一种荒诞的搞笑，在我听起来大概是这样的：</p><blockquote><p>其实打东方很简单，看见子弹来了躲开就行，就像音游看见音符到判定线上了按就行了。</p><p>编程时为什么我的输出和样例不一样？因为你的程序写错了，只要把它改对就行了，你能把程序改对那么输出就和样例一样了。</p><p>做数学题怎么能错呢？你填答题卡的时候把正确答案用铅笔涂黑不就好了么？</p></blockquote><p>那么为什么这次又学会了呢？因为我独立发现了关于自行车的几个定理。其实骑自行车是一件比较困难，而且有技巧的事，所谓的「窍」和「感觉」并不存在。</p><blockquote><p>【公理1】：自行车这个机械是可以保持稳定的。</p></blockquote><p>我们首先要相信这个<strong>公理</strong>，不只是通过观察世界上其它的自行车而相信，而是把它当成「任意两个点可以通过一条直线连接」这样的公理而坚信。如果我们不打心底里认为它是可以保持稳定的，就不能让它保持稳定。</p><blockquote><p><strong>【定理1】</strong>：学会自行车是从成功让它保持一定时间的稳定开始的。</p></blockquote><blockquote><p><strong>【定理2】</strong>：自行车保持稳定的前提条件是有足够的初速度。</p></blockquote><p>由<strong>定理1</strong>和<strong>定理2</strong>可以得到<strong>推论1</strong>：</p><blockquote><p><strong>【推论1】</strong>：如果要想学会自行车，首先要设法得到足够的初速度。</p></blockquote><p>单靠臀部坐在车座上，用两脚蹭地滑行是无法达到这样的初速度的，所以作为成年人千万不要这样学车。</p><p>对于未成年人来说，初速度最主要的来源是父母的助推，相信很多人都听说过孩子在前面蹬轮，家长在后面推，边推车边寻机悄悄撒手，孩子蹬一圈回头看家长早已落在身后，于是就这样学会了骑车。故事。在这样的经典例子中，父母的手除了「扶着」以保持稳定，还有一个重要的作用就是「推着」以给孩子的自行车提供足够的初速度。</p><p>对于成年人来说，指望父母的助推提供初速度是不现实的，而最简单的获得速度的方式就是求之于势能和动能的相互转换。因此，如果我们能找到一个足够长的斜坡，来自大地母亲的重力势能就会成为我们的助推器。</p><blockquote><p><strong>【公理2】</strong>：一切机械都只能在标准的工作状态工作，如果在非标准的状态工作，就会出现故障。</p></blockquote><blockquote><p><strong>【定理3】</strong>：自行车存在有限的工作状态，即停车、直行、左转、右转。</p><p>自行车停车的状态是：无速度，由撑子或者人体撑起车身使其不倒下。</p><p>自行车直行的状态是：有速度，车头朝向正前方，车身竖直，由一种我们目前不知道但和速度有关的神秘力量使其不倒下。</p><p>自行车左转的状态是：有速度，车头朝向左前方，车身略微向左倾斜，由一种我们目前不知道但和速度有关的神秘力量使其不倒下。</p><p>自行车右转的状态是：有速度，车头朝向右前方，车身略微向右倾斜，由一种我们目前不知道但和速度有关的神秘力量使其不倒下。</p></blockquote><p>由<strong>公理2</strong>和<strong>定理3</strong>，我们可以推出推论2：</p><blockquote><p><strong>【推论2】</strong>：当自行车向左倾斜以至于将要倒下时，我们应该略微向左打车头，向右亦然。</p></blockquote><p>这么做的原理是：自行车向左倾斜而车头朝向正前方是「非标准状态」，而机械工作在「非标准状态」就会出现故障，因此我们需要把非标准状态转换为标准状态。既然我们暂时无法将车身恢复为竖直（尽管这是我们的最终目标），那么就先把工作状态设定为「左转」，这样，机械就工作在了标准状态，从而为我们的进一步调整赢得了时间。也就是说，我们把「将要倒下」的状态迅速转换为「意料之外的左转」状态，用一个可控的小意外来代替不可控的大意外，然后再设法解决这个小意外。</p><p>同时请注意，这里是「略微」，而不是「猛打」，因此：</p><blockquote><p><strong>【推论2.5】</strong>：为了方便操纵，我们的重心应该在车座上，而不应该在车把上，而且不要握的太紧。</p></blockquote><p>由定理1和推论2，我们可以推出推论3：</p><blockquote><p><strong>【推论3】</strong>：在初学时，最好找一个足够宽广的路，为我们的「意料之外的左/右转」争取足够的空间。</p></blockquote><p>此时，我们应该可以在足够宽广的、坡度足够的斜坡上顺利地维持一段时间的无动力滑行，但是当想用脚踏板（而不是重力势能）为车提供动力时，又发现这是一件很困难的事。这时，有些人会认为这是「手脚不协调」导致的，但是实际上不是。</p><p>一般来说，较为简单的起步方法是：右脚踏在脚踏板上，左脚踩地，右脚踏半圈，左脚找到左脚踏板，左右一起蹬，车向前走。之前教我的人们也是这么说的，但是这漏掉了一个重要的事实，即：</p><blockquote><p><strong>【现象】</strong>单靠右脚蹬的半圈是提供不了足够的初速度的。</p></blockquote><p>所以，上面的步骤应该改写为：右脚踏在脚踏板上，左脚踩地，右脚踏半圈，<strong>左脚狠狠蹬一下地</strong>，左脚找到左脚踏板，左右一起蹬，车向前走。</p><p>这样，我们就学会骑自行车了。但是在这个过程中，可能会失败，为了把失败的损失降到最低，需要注意到定理3的「停车」一项：自行车停车时，除了用撑子撑起，也可以用人体撑起。当我们试图从「将要倒下」状态转换为「意料之外的左右转」而失败时，就需要立刻将状态转换为「停车」这个正常状态，而不是「倒下」这个故障状态。具体来说，我们可以用「车闸」把车的速度降低，然后立刻伸腿撑地（不要在高速时直接伸腿撑地）。为了保证这个过程是安全的，我们需要：</p><blockquote><p><strong>【推论4】</strong>：在学习骑车前，保证：</p><ol type="1"><li>车闸是正常工作的</li><li>坐在车座上，双脚撑住地是一件轻松的事（也就是说需要把座位适当调低）</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·捌：7月8日箱根之旅，与返程</title>
    <link href="/2024/07/25/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B78%EF%BC%9A7%E6%9C%888-9%E6%97%A5%E7%AE%B1%E6%A0%B9%E6%A8%AA%E6%BB%A8%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/25/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B78%EF%BC%9A7%E6%9C%888-9%E6%97%A5%E7%AE%B1%E6%A0%B9%E6%A8%AA%E6%BB%A8%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>今天来写一下箱根旅途，这是本次7天旅程的总路线图：</p><p><a href="https://exping.world/map/774742?eid=Cygnus_9911&amp;uid=643849&amp;nickname=misakaacer&amp;lang=zh-CN&amp;title=%E6%97%A5%E6%9C%AC%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C&amp;auid=643849&amp;p=411767654888308736">总路线图</a></p><p>这是本次日本旅途的最后一天，也是《秋月的霓虹旅行杂记》正篇的完结篇。日后可能还会写一两个特辑，但是正篇就到此为止了。今天主要就是在箱根转。</p><p>[toc]</p><h2 id="景点">景点</h2><h3 id="新干线">新干线</h3><p>为了去箱根，我们先从东京站到小田原，然后从小田原转乘箱根登山铁路到箱根汤本。</p><p>从东京站去小田原，坐的是新干线「回声号」。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251113389.png" alt="东京站" /><figcaption aria-hidden="true">东京站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121455271.png" alt="乘车券·新干线特急券" /><figcaption aria-hidden="true">乘车券·新干线特急券</figcaption></figure><p>这个不同于从大阪到东京的新干线，乘车券和特急券是在一张纸上的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251113599.png" alt="回声号新干线" /><figcaption aria-hidden="true">回声号新干线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121538845.png" alt="在新干线上拍的地图、车票和公交卡" /><figcaption aria-hidden="true">在新干线上拍的地图、车票和公交卡</figcaption></figure><p>从小田原站下车，转乘箱根登山铁路的前半段（小田原-箱根汤本）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251116617.png" alt="箱根汤本" /><figcaption aria-hidden="true">箱根汤本</figcaption></figure><p>在箱根汤本见到了传说中的「浪漫特快」，拍了就是坐了，都是机会。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251117730.png" alt="浪漫特快" /><figcaption aria-hidden="true">浪漫特快</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251117632.png" alt="浪漫特快" /><figcaption aria-hidden="true">浪漫特快</figcaption></figure><p>因为箱根是EVA的主要取景地之一，所以这里有一个EVA专卖店，一出站就是。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251159828.png" alt="EVA专卖店" /><figcaption aria-hidden="true">EVA专卖店</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251159375.png" alt="EVA专卖店" /><figcaption aria-hidden="true">EVA专卖店</figcaption></figure><p>去酒店放了一下行李以后就出去转悠了。这个酒店还挺高级的，是个四星级温泉酒店，后面细说。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251121708.png" alt="酒店招牌，一看就很上流" /><figcaption aria-hidden="true">酒店招牌，一看就很上流</figcaption></figure><h3 id="箱根登山铁路">箱根登山铁路</h3><p>这里的箱根登山铁路，指的是「箱根汤本-强罗」段，这一段是真的在爬山。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251239767.png" alt="箱根登山铁路" /><figcaption aria-hidden="true">箱根登山铁路</figcaption></figure><p>和电车一起在郁郁葱葱的绿色中间穿行，也是别有一番风味的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251125004.png" alt="箱根登山铁路窗外风景" /><figcaption aria-hidden="true">箱根登山铁路窗外风景</figcaption></figure><p>不过这个铁路最有趣的地方还是传说中的「之字形铁路」。箱根登山铁道线集大坡度、急转弯、之字型铁路于一身，单是坐这个车也是非常有趣的体验了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251132061.png" alt="之字形铁路，致敬传奇铁道工程师詹天佑" /><figcaption aria-hidden="true">之字形铁路，致敬传奇铁道工程师詹天佑</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251137425.png" alt="司机" /><figcaption aria-hidden="true">司机</figcaption></figure><p>每到之字形铁路的尽头，列车员都会从车头下车，走到另外一个方向的车头继续开车，真神奇。</p><p>这个铁路只到强罗站，估计是往后的坡度即使是这个「全日本最能爬坡的铁路」也无能为力了，因此换乘缆车。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251144812.png" alt="强罗站（注意坡度）" /><figcaption aria-hidden="true">强罗站（注意坡度）</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251153269.png" alt="强罗站的箱根登山铁路电车模型" /><figcaption aria-hidden="true">强罗站的箱根登山铁路电车模型</figcaption></figure><h3 id="缆车索道和大涌谷">缆车、索道和大涌谷</h3><p>索道和缆车都不能刷公交卡，所以得买票。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251200882.png" alt="缆车和索道票" /><figcaption aria-hidden="true">缆车和索道票</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251249960.png" alt="缆车" /><figcaption aria-hidden="true">缆车</figcaption></figure><p>这个缆车长得挺好玩的，远处看起来和电车一样，实际上是斜的（注意车窗和地面之间的夹角）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251248902.png" alt="缆车" /><figcaption aria-hidden="true">缆车</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251250960.png" alt="铁轨中间是「缆车」的「缆」" /><figcaption aria-hidden="true">铁轨中间是「缆车」的「缆」</figcaption></figure><p>缆车坐到早云山，然后换乘索道。在早云山有缆车的缆展览。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251603215.png" alt="「缆车」的「缆」" /><figcaption aria-hidden="true">「缆车」的「缆」</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251559265.png" alt="早云山索道站，可以看到远处的山上有个「大」字" /><figcaption aria-hidden="true">早云山索道站，可以看到远处的山上有个「大」字</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121520729.png" alt="索道车厢" /><figcaption aria-hidden="true">索道车厢</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251610584.png" alt="大涌谷" /><figcaption aria-hidden="true">大涌谷</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251649930.avif" alt="《新世纪福音战士》截图" /><figcaption aria-hidden="true">《新世纪福音战士》截图</figcaption></figure><p>这个大涌谷就是一个有很多硫磺的山谷，空气中有很浓的硫化氢味儿，地上还冒着气。这个地方的特产是「黑鸡蛋」，我品鉴了以后觉得跟普通鸡蛋没有多大区别。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251617549.png" alt="黑鸡蛋" /><figcaption aria-hidden="true">黑鸡蛋</figcaption></figure><p>在大涌谷上可以远眺到富士山。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251633888.png" alt="富士山" /><figcaption aria-hidden="true">富士山</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251633783.png" alt="富士山" /><figcaption aria-hidden="true">富士山</figcaption></figure><p>昨天说到梅子饭团，没想到今天梅子又打过来了。友人Q在这个大涌谷的商店里买了一盒梅子，包装盒特别精美，看起来特别适合送礼，他说是要送给导师。他还买了两个散装的试吃。我一吃就感觉到一股酸咸味直冲脑门，一点都不甜，绝了。据说这玩意的正确吃法是一颗梅子下一碗白米饭，叫什么「日之丸便当」，让我们祝友人Q的导师幸福吧。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251642002.png" alt="梅子干" /><figcaption aria-hidden="true">梅子干</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251847519.png" alt="散装梅子干·友人摄" /><figcaption aria-hidden="true">散装梅子干·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251653470.png" alt="友人Q：吃完后的感受" /><figcaption aria-hidden="true">友人Q：吃完后的感受</figcaption></figure><p>从大涌谷继续坐缆车，就到了芦之湖。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251629197.png" alt="芦之湖（缆车上拍）" /><figcaption aria-hidden="true">芦之湖（缆车上拍）</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251629059.png" alt="芦之湖" /><figcaption aria-hidden="true">芦之湖</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251639483.png" alt="芦之湖海盗船" /><figcaption aria-hidden="true">芦之湖海盗船</figcaption></figure><p>因为芦之湖是EVA和雷天使战斗的地方，所以这边也有很多EVA装饰。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251645930.png" alt="桃源站" /><figcaption aria-hidden="true">桃源站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251652416.png" alt="雷天使" /><figcaption aria-hidden="true">雷天使</figcaption></figure><p>因为时候不早了，所以我们就坐巴士回酒店了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251655051.png" alt="坐巴士路过的草原，感觉好像也在EVA里出现过" /><figcaption aria-hidden="true">坐巴士路过的草原，感觉好像也在EVA里出现过</figcaption></figure><h3 id="吉池旅馆">吉池旅馆</h3><p>四星级和式温泉旅馆，太tm高端了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251700161.png" alt="酒店导览图" /><figcaption aria-hidden="true">酒店导览图</figcaption></figure><p>这酒店里面还有个不小的日式庭院，据说是德川家第几代家住的故居，好像还是个古迹。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251821502.png" alt="日式庭院" /><figcaption aria-hidden="true">日式庭院</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251821956.png" alt="日式庭院" /><figcaption aria-hidden="true">日式庭院</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251823917.png" alt="日式庭院" /><figcaption aria-hidden="true">日式庭院</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251830979.png" alt="酒店房间：2人间和室" /><figcaption aria-hidden="true">酒店房间：2人间和室</figcaption></figure><p>我们订的是6人间和室套房，实际上套间里面有2个卫生间、1个2人间和室（上图）和1个4人间和室（下图）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251831014.png" alt="4人间和室" /><figcaption aria-hidden="true">4人间和室</figcaption></figure><p>你现在看着没有床铺，实际上服务员会趁着你去吃晚饭的时候把它变成铺好的床铺。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252354722.png" alt="铺好床铺的和室" /><figcaption aria-hidden="true">铺好床铺的和室</figcaption></figure><p>真好啊，希望回头等我买房了也整个这种房间，睡起来真舒服......</p><p>在房间休整了一会儿，并拍下「二次元战利品」照片以后，我们就去吃酒店的晚饭了。是怀石料理，很牛逼，虽然没吃饱。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251841984.png" alt="二次元战利品" /><figcaption aria-hidden="true">二次元战利品</figcaption></figure><p>吃完晚饭，换完浴衣，自然就是温泉环节了。因为时间比较晚了，所以人不是很多，基本也是我们包场（除我们以外，只有两位日本老人）。这个酒店的浴室有不露天的和露天的两种，我们都体验了一下，很舒服。而且据有经验的友人Z说，水都是真正的温泉水，非常好。照片当然是没有。</p><p>另：这个旅馆的温泉里面的免费麦茶是我在日本喝到的最好喝的麦茶，薄纱自动贩卖机。</p><p>洗完澡以后因为还感觉有点饿，于是决定出去找便利店。但是我们走了十分钟的路才找到了一个便利店，并将其中的便当「洗劫一空」。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407261211229.png" alt="夜游箱根" /><figcaption aria-hidden="true">夜游箱根</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407261212440.png" alt="夜游箱根·注意猴子" /><figcaption aria-hidden="true">夜游箱根·注意猴子</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407261212268.png" alt="夜游箱根·河道" /><figcaption aria-hidden="true">夜游箱根·河道</figcaption></figure><p>说起来箱根虽然是乡下，好歹也算个旅游圣地，十点就这么阴森恐怖了吗......</p><h3 id="横滨9日">横滨（9日）</h3><p>本来9号就该回国了，但是因为订的飞机比较晚，在友人的提议下，我们横滨稍微逛一下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251845426.png" alt="横滨站" /><figcaption aria-hidden="true">横滨站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251848532.png" alt="横滨站很火的中华料理·友人摄" /><figcaption aria-hidden="true">横滨站很火的中华料理·友人摄</figcaption></figure><p>说是逛，其实也就逛了骏河屋，不过这个骏河屋真是神中神了，后悔没多逛逛。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251848123.png" alt="横滨骏河屋·友人摄" /><figcaption aria-hidden="true">横滨骏河屋·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251849552.png" alt="横滨骏河屋·友人摄" /><figcaption aria-hidden="true">横滨骏河屋·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251849938.png" alt="横滨骏河屋·友人摄" /><figcaption aria-hidden="true">横滨骏河屋·友人摄</figcaption></figure><p>这里面的二手谷子（日语叫「中古」），都是放在这个筐里，然后你得自己在里面挖掘。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251856816.png" alt="筐子里的谷子们" /><figcaption aria-hidden="true">筐子里的谷子们</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407251856215.png" alt="收获" /><figcaption aria-hidden="true">收获</figcaption></figure><p>这是我们的收获。其中有300日元（13块钱）的莉克莉斯摆件，1200日元（54块钱）的凉宫春日带特典DVD等，简直神了。这都要感谢友人的英明决断。</p><h3 id="羽田机场9日">羽田机场（9日）</h3><p>说是羽田机场，实际上就是在飞机上俯瞰了一下东京和富士山，相当震撼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252207610.png" alt="飞机俯瞰东京" /><figcaption aria-hidden="true">飞机俯瞰东京</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252208483.png" alt="飞机眺望富士山" /><figcaption aria-hidden="true">飞机眺望富士山</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252208408.png" alt="云层和小乡村" /><figcaption aria-hidden="true">云层和小乡村</figcaption></figure><p>这也是本次日本旅途的最后一站，日本的旅行宣告结束。</p><p>不过到现在了，还是出了最后一个小插曲。就是我回国时买的是「东京羽田→北京大兴→西安咸阳」的联程票，但是北京到西安这一段起飞时延误了半小时，最后却按时抵达了，鉴定为飞行员太拼命了（笑），而且我还因为这个半小时的延误获得了60块钱的赔偿，可喜可贺。</p><h2 id="饮食">饮食</h2><p>这两天里值得写的饮食有两个，第一个是吉池旅馆的怀石料理，第二个是在日本吃的最后一顿正餐：横滨咖喱饭。</p><h3 id="怀石料理">怀石料理</h3><p>在刚进入包间时，每个人面前是这样子：一盒前菜，一块小豆腐，一碗酱油，一杯梅子酒，一个菜单。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252221890.png" alt="前菜和菜单" /><figcaption aria-hidden="true">前菜和菜单</figcaption></figure><p>对前菜的评价是：那个海螺是MVP，肉很劲道，有海鲜味，牛肉和油豆腐也很好；那个装着虾的容器很酸，不太喜欢。</p><p>细看菜单：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252225057.png" alt="菜单" /><figcaption aria-hidden="true">菜单</figcaption></figure><p>答案是看不懂。其实就是他会依次给你上「前菜」、「御椀」...等等，你吃完一个他给你上一个。下面的菜名都是我的臆测，哈哈。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252227112.png" alt="鱼翅蒸蛋" /><figcaption aria-hidden="true">鱼翅蒸蛋</figcaption></figure><p>我的评价是：口感非常好，可惜是凉的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252227383.png" alt="彩椒、酱茄子、红薯段佐炸鱼肉卷" /><figcaption aria-hidden="true">彩椒、酱茄子、红薯段佐炸鱼肉卷</figcaption></figure><p>我的评价是：最符合中国人口味的一集，豪赤。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252228787.png" alt="板栗南瓜、苦瓜佐炖牛肉" /><figcaption aria-hidden="true">板栗南瓜、苦瓜佐炖牛肉</figcaption></figure><p>我的评价是：最硬菜的一集，豪赤。美中不足是肉有点肥。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252231887.png" alt="甜虾、瑶柱、三文鱼刺身拼盘" /><figcaption aria-hidden="true">甜虾、瑶柱、三文鱼刺身拼盘</figcaption></figure><p>我的评价是：瑶柱刺身好吃，很鲜甜；甜虾有一点黏液，这个口感我不太喜欢。三文鱼质量也好。如果我只长了嘴而没有胃，这个菜应该非常不错。可是我的胃还是有点接受不了生吃这么多东西。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252232251.png" alt="赤味增、玉米白米饭、咸菜" /><figcaption aria-hidden="true">赤味增、玉米白米饭、咸菜</figcaption></figure><p>我的评价是：日本人真的干吃米饭吗？真就米饭是菜？要不是我留下了点炖牛肉酱，这个米饭还真就吃不完了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252232974.png" alt="餐后甜点：抹茶蛋糕、芒果布丁、橘子、樱桃" /><figcaption aria-hidden="true">餐后甜点：抹茶蛋糕、芒果布丁、橘子、樱桃</figcaption></figure><p>我的评价是：吃起来就像长得一样，材料用的都很好，好吃。</p><p>总览一下评价，发现似乎都很好吃，但是量好少，而且还有很多生的，导致没吃饱。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252306166.png" alt="没吃饱喵..." style="zoom:25%;" /></p><h3 id="咖喱饭">咖喱饭</h3><p>在横滨站吃的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407252309922.png" alt="温泉蛋炸鸡块咖喱饭" /><figcaption aria-hidden="true">温泉蛋炸鸡块咖喱饭</figcaption></figure><p>比coco一番屋的咖喱更辣，咖喱的量更多（标准份饭是吃不完这些咖喱的）。这个红色的小菜也好吃，友人Z说它叫红姜。之所以写在这里只是因为它是我在日本吃的最后一顿正餐。</p><h2 id="结束语">结束语</h2><p>为期一周的日本旅途到此结束。在旅行的过程中，我们收获了很多快乐，也留下了一些遗憾。如果一定要就遗憾写两句建议，我想说的是：<strong>一定要看清楚各个店家饭店公交电车的开放时间！一定要早起！</strong>我们因为起得比较晚，每天基本上都是九点半十点才出门，同时一开始又不知道日本人这么爱早下班的这个习性，有很多该逛的地方没有逛，很多该买的东西没有买，这实在是太遗憾了。</p><p>尽管我很不喜欢给快乐的事情上价值，我一直在拥护「单纯的快乐」，但是这次旅途除去快乐以外，也确实给我们带来了许多的收益。毕竟算是出了一次国，也见识到了真实的日本的样子，锻炼了计划和随机应变的能力，认知到了资本主义社会和社会主义社会国家不同的风貌，也增进了与各位友人的情谊。作为毕业旅行，这是一次团结的旅行，一次胜利的旅行。</p><p>六年前在看《凉宫春日的忧郁》时，我肯定也想过「也许有一天能到西宫北高去吧？」，结果今年就真的去到了。和朋友一起做计划，然后看着计划书上面抽象的黄色区块和地名变成立体的风景出现在自己的眼前，真的是一件很快乐的事情。</p><p>本次旅行的计划由友人在2024年4月10日提出，5月24日由我开始为友人们办理签证并收集各位友人的「想去的地方」，友人Z于6月12日调研了酒店。6月15日晚上，我们在北航的主楼研讨室召开了确定行程的会议，全员列席，在会上所有人一起确定了大致行程，预订了酒店和交通票。会后，由我、友人Z和友人Y一起对行程的规划进行了细化。最终，在7月2日~7月8日，我们进行了毕业旅行。在旅行过程中，友人和友人Z在日语沟通上帮了很大的忙，友人Q为大家提供了充足的日元现金。友人L白天跟我们旅游，晚上还要科研，很不容易。</p><p>为了成功进行这次毕业旅行，每个人都付出了不少努力。或是调研酒店，或是调研景点，或是求解旅行商问题分配行程，或是克服了实习和实验室打工的困难。在此，我要感谢一起努力的每位朋友，如果没有我们大家的努力，我们也不会一起度过难忘而快乐的一周，同时也感谢各位朋友为本系列文章提供图片素材和内容建议。本次旅行的成员有：</p><center>我</center><center>友人</center><center>友人Q</center><center>友人L</center><center>友人Y</center><center>友人Z</center><p>在准备旅途，以及撰写本文的过程中，也参考了不少同志们的意见，以及网络上的教程文章。</p><p>[1] 养蝶的庭师. 日本短期旅行攻略——我的毕业旅行纪念[EB/OL]. https://www.bilibili.com/read/cv26319083, 2023-09.</p><p>[2] 咲凌. 关于远征live你所需要的一切[EB/OL].https://arisa114514.feishu.cn/wiki/QCNOwAGPxiAE1Ak39BIcRlGbnjh, 2024-05.</p><p>[3] 鹤翔万里. 【吹响吧！上低音号】京吹圣地巡礼游记[EB/OL]. https://www.bilibili.com/read/cv31187483, 2024-02.</p><p>[4] 爱してるまき. 吹响吧，上低音号圣地巡礼[EB/OL]. https://www.bilibili.com/read/cv4047809, 2019-11.</p><p>[5] 凉宫春日搬运站. 【凉宫春日系列】2024保姆级圣地巡礼指南【上·忧郁篇】[EB/OL]. https://www.bilibili.com/read/cv28985479, 2024-01-03.</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·柒：7月7日池袋秋叶原之旅</title>
    <link href="/2024/07/23/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E6%9F%92%EF%BC%9A7%E6%9C%887%E6%97%A5%E6%B1%A0%E8%A2%8B%E7%A7%8B%E5%8F%B6%E5%8E%9F%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/23/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E6%9F%92%EF%BC%9A7%E6%9C%887%E6%97%A5%E6%B1%A0%E8%A2%8B%E7%A7%8B%E5%8F%B6%E5%8E%9F%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>今天来写一下池袋和秋叶原的旅途，这是本次7天旅程的总路线图：</p><p><a href="https://expin.site/D8MXM">总路线图</a></p><p>今天主要就是在池袋和秋叶原转悠，纯纯的二次元。</p><p>[toc]</p><h2 id="景点">景点</h2><h3 id="sunshine-city">Sunshine City</h3><p>去池袋就要先去Sunshine City，主要是为了巡礼MyGO。池袋是MyGO的主舞台，所以有很多MyGO的巡礼点，刚出站就能看到不少既视感极强的画面。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232220705.png" alt="RiNG的原型" /><figcaption aria-hidden="true">RiNG的原型</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232220962.png" alt="池袋站前，「Soyorin也别退出哦」" /><figcaption aria-hidden="true">池袋站前，「Soyorin也别退出哦」</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232221942.png" alt="MyGO!!!!!动画截图" /><figcaption aria-hidden="true">MyGO!!!!!动画截图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232224520.png" alt="梦开始的立交桥" /><figcaption aria-hidden="true">梦开始的立交桥</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232224652.png" alt="MyGO!!!!!动画截图" /><figcaption aria-hidden="true">MyGO!!!!!动画截图</figcaption></figure><p>然后直接去Sunshine City楼顶的Sunshine Aquarium，中文名是阳光水族馆。这是MyGO里高松灯经常去的水族馆，我们去的主要目的也是圣地巡礼。当然，即使不是为了圣地巡礼，这个水族馆也是很值得一看的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232228169.png" alt="Sunshine Aquarium的招牌" /><figcaption aria-hidden="true">Sunshine Aquarium的招牌</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232228871.png" alt="水族馆和天文馆" /><figcaption aria-hidden="true">水族馆和天文馆</figcaption></figure><p>这个旁边的「满天」就是高松灯经常去的天文馆，但是我们并没有去。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232229916.png" alt="天文馆放映时间表" /><figcaption aria-hidden="true">天文馆放映时间表</figcaption></figure><p>这个天文馆竟然还有18+ONLY：《希腊众神的爱情事务》，偷摸铃酱......</p><p>总之还是进入正题，看看水族馆吧。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232231935.jpeg" alt="鱼缸" /><figcaption aria-hidden="true">鱼缸</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232231082.jpeg" alt="竖着游泳的鱼" /><figcaption aria-hidden="true">竖着游泳的鱼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232232789.jpeg" alt="超大鱼缸，和鳐鱼" /><figcaption aria-hidden="true">超大鱼缸，和鳐鱼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232232677.jpeg" alt="长得还挺丑的鱼" /><figcaption aria-hidden="true">长得还挺丑的鱼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232232069.jpeg" alt="鳐鱼" /><figcaption aria-hidden="true">鳐鱼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232237610.png" alt="正在进食的海星" /><figcaption aria-hidden="true">正在进食的海星</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232233084.jpeg" alt="正在给鱼喂食的工作人员" /><figcaption aria-hidden="true">正在给鱼喂食的工作人员</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232233448.jpeg" alt="水母" /><figcaption aria-hidden="true">水母</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232233001.jpeg" alt="带鱼" /><figcaption aria-hidden="true">带鱼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232234636.jpeg" alt="鱼" /><figcaption aria-hidden="true">鱼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232234578.jpeg" alt="王八" /><figcaption aria-hidden="true">王八</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232235183.jpeg" alt="额头很大的鱼" /><figcaption aria-hidden="true">额头很大的鱼</figcaption></figure><p>这些鱼虽然都很好看，但是不是重点。重点当然是：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232235527.jpeg" alt="将将！俩fish~" /><figcaption aria-hidden="true">将将！俩fish~</figcaption></figure><p>偷摸铃同款天空企鹅！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232239680.png" alt="一个fish" /><figcaption aria-hidden="true">一个fish</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232239865.png" alt="好多fish" /><figcaption aria-hidden="true">好多fish</figcaption></figure><p>在这个Sunshine City的3楼有一个万代店，我们逛完水族馆以后就顺便去了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232326252.png" alt="万代" /><figcaption aria-hidden="true">万代</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232332347.png" alt="万代店内" /><figcaption aria-hidden="true">万代店内</figcaption></figure><p>这里面有一亿个扭蛋机，还挺震撼的。日本的扭蛋机简直丰富多彩，似乎是想把啥都做成扭蛋。我在这里面见到了扭蛋机的扭蛋、饭的扭蛋（比如饭团、寿司、咖喱饭等）、麻将牌的扭蛋，还有文具的扭蛋。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232338450.png" alt="文具扭蛋，这里面有本子橡皮啥的，都是模型，不是实物" /><figcaption aria-hidden="true">文具扭蛋，这里面有本子橡皮啥的，都是模型，不是实物</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232338196.png" alt="手办展柜" /><figcaption aria-hidden="true">手办展柜</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232340117.png" alt="美少女机甲模型" /><figcaption aria-hidden="true">美少女机甲模型</figcaption></figure><p>后来我们被迫结束了万代店的逛。并不是因为逛够了，而是因为商场火警响了，说是2楼的传感器检测到了火源，于是把我们都疏散了。怎么说呢，希望人没事吧。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232342373.png" alt="正在疏散的万代店" /><figcaption aria-hidden="true">正在疏散的万代店</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241118859.png" alt="和友人一起扭了小猫雕像扭蛋" /><figcaption aria-hidden="true">和友人一起扭了小猫雕像扭蛋</figcaption></figure><p>从Sunshine City出来以后，我们又顺便巡礼了MyGO标志性的台阶。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232352798.png" alt="灯神长阶" /><figcaption aria-hidden="true">灯神长阶</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232352048.png" alt="灯神长阶" /><figcaption aria-hidden="true">灯神长阶</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232357886.png" alt="灯神长阶" /><figcaption aria-hidden="true">灯神长阶</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407232353526.png" alt="MyGO!!!!!华灯初上名场面" /><figcaption aria-hidden="true">MyGO!!!!!华灯初上名场面</figcaption></figure><p>眼尖的同志们可能会发现：这楼梯上怎么还有几个COSER呢？其实是因为这个地方这天似乎在办名为ACOSTA的漫展。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241617024.png" alt="acosta!" /><figcaption aria-hidden="true">acosta!</figcaption></figure><p>这个地方就是爱音被她初中同学看到然后吓晕的地方。</p><h3 id="池袋街景和animate">池袋街景和Animate</h3><p>别用日语问东问西的，这里是池袋！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201713064.png" alt="杨国福麻辣烫和黄焖鸡米饭" /><figcaption aria-hidden="true">杨国福麻辣烫和黄焖鸡米饭</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240000944.png" alt="叫了个炸鸡" /><figcaption aria-hidden="true">叫了个炸鸡</figcaption></figure><p>在池袋看到了个K-BOOK和Animate，顺便就进去逛了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241559572.png" alt="KBOOK里面的PJSK谷子" /><figcaption aria-hidden="true">KBOOK里面的PJSK谷子</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240003176.png" alt="好多漫画" /><figcaption aria-hidden="true">好多漫画</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240003677.png" alt="赠送的芙蓉王" /><figcaption aria-hidden="true">赠送的芙蓉王</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240004793.png" alt="银英" /><figcaption aria-hidden="true">银英</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240004468.png" alt="娜娜" /><figcaption aria-hidden="true">娜娜</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240004976.png" alt="凉宫春日" /><figcaption aria-hidden="true">凉宫春日</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240011966.png" alt="芳文社" /><figcaption aria-hidden="true">芳文社</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240005277.png" alt="mygo" /><figcaption aria-hidden="true">mygo</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407240005803.png" alt="mygo小玩偶" /><figcaption aria-hidden="true">mygo小玩偶</figcaption></figure><p>在这儿买了不少东西：一个迷迹波专辑，两个MyGO立牌，一本凉宫春日的消失，一本末日时在做什么，一本天才麻将少女。值得一提的是：在A店买东西可以免税，但是你得主动问，你不问店员，店员也不问你；你问了店员，才能免税。</p><h3 id="秋叶原">秋叶原</h3><p>到日本，不逛秋叶原，等于白来。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241104070.png" alt="秋叶原站的广告" /><figcaption aria-hidden="true">秋叶原站的广告</figcaption></figure><p>还没下车就闻到二次元味儿了，出音味来。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241118495.png" alt="偶像大师·友人摄" /><figcaption aria-hidden="true">偶像大师·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241119505.png" alt="秋叶原街景" /><figcaption aria-hidden="true">秋叶原街景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241126721.png" alt="atre·友人摄" /><figcaption aria-hidden="true">atre·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241119086.png" alt="偶像大师店" /><figcaption aria-hidden="true">偶像大师店</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241119390.png" alt="辣舞莱芜店" /><figcaption aria-hidden="true">辣舞莱芜店</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241126481.png" alt="谷子·友人摄" /><figcaption aria-hidden="true">谷子·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241126903.png" alt="谷子·友人摄" /><figcaption aria-hidden="true">谷子·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241132385.png" alt="致敬秋叶原传奇科学家冈部伦太郎" /><figcaption aria-hidden="true">致敬秋叶原传奇科学家冈部伦太郎</figcaption></figure><p>喝起来的味道是京都念慈庵兑气泡水。这一切都是命运石之门的选择，El Psy Congroo。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241133445.png" alt="原神，占领世界！" /><figcaption aria-hidden="true">原神，占领世界！</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241131034.png" alt="黄油店" /><figcaption aria-hidden="true">黄油店</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241131223.png" alt="hahaha" /><figcaption aria-hidden="true">hahaha</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241133474.png" alt="美好的每一天" /><figcaption aria-hidden="true">美好的每一天</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241701291.png" alt="美少女万华镜·友人Q摄" /><figcaption aria-hidden="true">美少女万华镜·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241703376.png" alt="galgame CD·友人Q摄" /><figcaption aria-hidden="true">galgame CD·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241704060.png" alt="近月·友人Q摄" /><figcaption aria-hidden="true">近月·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241705816.png" alt="柚子·友人Q摄" /><figcaption aria-hidden="true">柚子·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241149628.png" alt="你猜我为啥打码.jpg" /><figcaption aria-hidden="true">你猜我为啥打码.jpg</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241150162.png" alt="手办·友人Y摄" /><figcaption aria-hidden="true">手办·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241658770.png" alt="原神手办·派蒙为什么这么贵·友人L摄" /><figcaption aria-hidden="true">原神手办·派蒙为什么这么贵·友人L摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241205565.png" alt="手办·友人Y摄" /><figcaption aria-hidden="true">手办·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090916149.png" alt="手办·友人Y摄" /><figcaption aria-hidden="true">手办·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090919903.png" alt="手办·友人Y摄" /><figcaption aria-hidden="true">手办·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090909085.png" alt="手办·友人Y摄" /><figcaption aria-hidden="true">手办·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241159743.png" alt="手办们·友人Y摄" /><figcaption aria-hidden="true">手办们·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241204790.png" alt="秋叶原标志性的十字路口" /><figcaption aria-hidden="true">秋叶原标志性的十字路口</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241208569.png" alt="战利品" /><figcaption aria-hidden="true">战利品</figcaption></figure><h2 id="饮食">饮食</h2><p>今天早饭是便利店饭团，午饭是和牛拌饭，晚饭是便利店便当。</p><h3 id="早餐">早餐</h3><p>这个便利店饭团本来不想提的，但是还是得提一下。就是我吃了一个梅子味饭团，结果感觉难吃的要死，本来以为再也不会受梅子的害了，可是它一天以后竟然又打回来了，简直阴魂不散，这事儿咱明天细说。</p><h3 id="和牛拌饭">和牛拌饭</h3><p>在池袋吃的，店名是<a href="https://maps.app.goo.gl/oNUwkSdad52zeH5EA">ローストビーフ大野 南池袋店</a></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241241172.png" alt="image-20240724124113854" /><figcaption aria-hidden="true">image-20240724124113854</figcaption></figure><p>这个牛肉饭长得跟富士山爆发似的：锥体，上面有点白的（吃起来像沙拉酱），然后有黄色的液体（其实是温泉蛋）流下来。</p><p>酱汁的味道很有特色，叫シャリアピンソース，有一种洋葱和红酒的味，难以形容，不过还算好吃，这有个简单<a href="https://cookpad.com/recipe/7767395">介绍</a>。</p><p>牛肉的片非常薄，你看它是半生的，其实也确实是半生的，但是和热米饭一拌，基本也就七成熟了，味道可以，说是什么黑毛和牛。</p><p>套餐里面那个汤是牛尾汤，普通的肉汤味道。</p><h3 id="便利店便当">便利店便当</h3><p>在东京逛完秋叶原九点想找个吃的，在御茶之水附近的街道上转了两圈，只有三家餐饮店亮着灯，分别是印度菜、印度菜，和忘记关灯的日本菜，甚至松屋都关门了（这玩意难道不应该是24小时营业吗）。我们到了日本菜门口，人家才说是忘了关灯了。最后我们去了711买便当解决——顺便一提：711的营业员是印度人。哎，不说了，说多了都是泪，无语，典型的日本躺平摆烂思维。</p><p>买了亲子丼，就是鸡蛋炒鸡肉盖饭，味道还行。</p><p>今天的二次元之旅就是这样，纯纯的圣地巡礼+扫货，明天是箱根。别问我为啥先去东京再去箱根，因为我是啥子。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407241303328.png" alt="别骂了" style="zoom:25%;" /></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·陆：7月6日涩谷下北泽之旅</title>
    <link href="/2024/07/22/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E9%99%86%EF%BC%9A7%E6%9C%886%E6%97%A5%E6%B6%A9%E8%B0%B7%E4%B8%8B%E5%8C%97%E6%B3%BD%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/22/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E9%99%86%EF%BC%9A7%E6%9C%886%E6%97%A5%E6%B6%A9%E8%B0%B7%E4%B8%8B%E5%8C%97%E6%B3%BD%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>7月6日就是从大阪去东京，然后下午在涩谷和下北泽转了一下，晚上因为下大雨所以被硬控在酒店了。</p><p>从7月6日起，步行的少，而坐公共交通的多，但是谷歌地图又不支持显示公共交通的线路，所以没有按天的路线图了。</p><p>7天的总路线图：https://expin.site/D8MXM</p><p>[toc]</p><h2 id="景点">景点</h2><h3 id="希望号新干线">希望号新干线</h3><p>今天一大早就从新大阪站坐新干线到东京。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221116729.png" alt="新大阪站的新干线检票口·友人Y摄" /><figcaption aria-hidden="true">新大阪站的新干线检票口·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121523959.png" alt="新干线的票" /><figcaption aria-hidden="true">新干线的票</figcaption></figure><p>在乘车的时候，要同时把乘车券和新干线特急券塞到闸机里，然后它会从闸机出口弹出来，记得取一下。如果闸机没把票弹出来，一定要及时联系工作人员。那天友人L就是这样，结果到了东京站还得花700多块钱补票才能出站。工作人员说必须要把票的原件找见，才能退钱。这个票的原件直到我们离开日本的那一天才被找见。东京的车站又必须见到车票的原件才行，但是车票是在大阪找见的，最后委托了一位在日本留学的朋友帮忙退费，让我们祝愿友人L的退费事业顺利吧。</p><p>（无语，跟你说不下去，典型的信息化落后国家思维，国内早刷个身份证解决了，哪来这么多破事？）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407231037310.png" alt="新干线列车·友人Y摄" /><figcaption aria-hidden="true">新干线列车·友人Y摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221211511.png" alt="显示「nozomi(希望号)」和目的地的显示器" /><figcaption aria-hidden="true">显示「nozomi(希望号)」和目的地的显示器</figcaption></figure><p>新干线上座位前后之间的间距特别大，即使你把座位完全放下去也不会影响其他人，躺着也挺舒服的，眼睛一闭就睡着了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221229250.png" alt="新干线上的逆天广告" /><figcaption aria-hidden="true">新干线上的逆天广告</figcaption></figure><p>就是这个广告实在太逆天了，睡的时候老是感觉有前排的乘客回头盯着我看。</p><p>在路过富士的时候，如果你在车厢的左侧（也就是DE座位），可以通过窗户看到富士山。如果各位有这个需求，可以在买指定席座位的时候注意一下。其实也可以到车厢连接处去看，窗户还更大。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221250656.png" alt="富士山" /><figcaption aria-hidden="true">富士山</figcaption></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221250207.png" alt="富士山" /><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221250755.png" alt="富士山" /></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407231035486.png" alt="富士山和桥·友人Q摄" /><figcaption aria-hidden="true">富士山和桥·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407231036563.png" alt="富士山和农田·友人Q摄" /><figcaption aria-hidden="true">富士山和农田·友人Q摄</figcaption></figure><p>看起来真的像水墨画一样。</p><p>在新干线上还可以听京吹限定广播剧，听完可以领取小礼物（一个A5文件夹+一个限定京吹风格新干线车票）。虽然不限制乘车方向，但是礼物只能在京都市领，所以我拜托了另外一个在日本旅游的朋友帮忙领了一下。这个乘车证明的原理是检测你的速度，所以不要在快进站的时候听，很可能检测不出来。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221253321.png" alt="京吹广播剧，和小礼物·友人Q摄" /><figcaption aria-hidden="true">京吹广播剧，和小礼物·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221256294.png" alt="一亿个人的东京站" /><figcaption aria-hidden="true">一亿个人的东京站</figcaption></figure><h3 id="涩谷">涩谷</h3><p>去涩谷之前在御城门站下了个车，远眺了一下东京塔。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221556832.png" alt="东京塔" /><figcaption aria-hidden="true">东京塔</figcaption></figure><p>从御城门走到滨松町，然后坐山手线到涩谷。从涩谷站一下车就给我震撼了，在日本还是第一次见到这么多人。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221557939.png" alt="涩谷十字路口" /><figcaption aria-hidden="true">涩谷十字路口</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407231037697.png" alt="涩谷十字路口（PJSK截图）" /><figcaption aria-hidden="true">涩谷十字路口（PJSK截图）</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221559560.png" alt="涩谷街景" /><figcaption aria-hidden="true">涩谷街景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221559066.png" alt="涩谷Sky里的电梯" /><figcaption aria-hidden="true">涩谷Sky里的电梯</figcaption></figure><p>日本真的好喜欢大站快车，不仅电车有，连电梯都有。</p><p>不过我们实际上没上去涩谷Sky，因为票卖没了，只在这个商场的12楼看了一下。这也是我们在日本遇到的唯一一个不提前预约然后真的没票了的景点。总之如果有想去涩谷Sky的，记得提前买票，KLOOK上就能买。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221607864.png" alt="涩谷Sky12楼看东京" /><figcaption aria-hidden="true">涩谷Sky12楼看东京</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407231028027.png" alt="涩谷十字路口（俯瞰版）·友人Q摄" /><figcaption aria-hidden="true">涩谷十字路口（俯瞰版）·友人Q摄</figcaption></figure><p>后来还是看到了俯瞰东京的，不过那是在羽田机场看的。</p><p>从涩谷Sky出来以后，准备去下北泽。</p><h3 id="下北泽">下北泽</h3><p>之所以去下北泽，主要是为了巡礼孤独摇滚。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221615056.png" alt="孤独摇滚海报" /><figcaption aria-hidden="true">孤独摇滚海报</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221615808.png" alt="下北泽站" /><figcaption aria-hidden="true">下北泽站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221615521.png" alt="本多剧场" /><figcaption aria-hidden="true">本多剧场</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221616925.png" alt="本多剧场里面的孤独摇滚谷子" /><figcaption aria-hidden="true">本多剧场里面的孤独摇滚谷子</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221616530.png" alt="下北泽街景" /><figcaption aria-hidden="true">下北泽街景</figcaption></figure><p>在下北泽，我确信了对「日本城市」的刻板印象：低矮密集的房子，狭窄的马路，以及在天上横跨马路的电线。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221617567.png" alt="「剧」小剧场" /><figcaption aria-hidden="true">「剧」小剧场</figcaption></figure><p>在下北泽吃了午饭，我们本来是打算回酒店办下入住，然后逛秋叶原的。但是还没到酒店，突然下了一场特别特别大的雨，直到七点才停，所以今晚的秋叶原计划就寄了。</p><h3 id="晚上逛街">晚上逛街</h3><p>雨停了以后还是出去转了一下，主要是吃了晚饭，然后去御茶之水散了散步。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221708517.png" alt="雨后的酒店附近" /><figcaption aria-hidden="true">雨后的酒店附近</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221709770.png" alt="御茶之水" /><figcaption aria-hidden="true">御茶之水</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221709362.png" alt="御茶之水" /><figcaption aria-hidden="true">御茶之水</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221709903.png" alt="御茶之水" /><figcaption aria-hidden="true">御茶之水</figcaption></figure><h2 id="饮食">饮食</h2><p>今天早餐没吃，午餐在下北泽吃了牛舌料理，晚上在酒店附近吃了名叫「春日亭」的拉面。</p><h3 id="牛舌料理">牛舌料理</h3><p>这个店的名字叫<a href="https://maps.app.goo.gl/eszNsZ3DTJzLSCMi8">「牛舌·夏火钵」</a>，我们总共点了四种菜，分别是凉菜（前菜）、烤牛舌、炖牛舌和烤羊排。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221715191.png" alt="炖牛舌" /><figcaption aria-hidden="true">炖牛舌</figcaption></figure><p>其中我觉得炖牛舌是TOP1，非常软烂，汁水也很下饭。烤牛舌就是很普通的烤牛排的感觉，虽然也挺好吃的。</p><h3 id="春日亭">春日亭</h3><p>这是个<a href="https://maps.app.goo.gl/AwHXNLCXsiXZ1coZ6">干拌油荞麦面店</a>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221724038.png" alt="春日亭的干拌拉面" /><figcaption aria-hidden="true">春日亭的干拌拉面</figcaption></figure><p>这家拉面也不错，面条还挺筋道的，我这个是小份，其实有点点不够。</p><p>这个店的二楼满墙都是客人的涂鸦，我们也写了写：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221725714.png" alt="春日亭·涂鸦" /><figcaption aria-hidden="true">春日亭·涂鸦</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407221725406.png" alt="春日亭·涂鸦" /><figcaption aria-hidden="true">春日亭·涂鸦</figcaption></figure><p>留下：</p><ul><li>「为什么要品尝春日亭」</li><li>「要和我吃一辈子拉面」</li><li>「我永远喜欢爱莉希雅」</li><li>「おいしいぜ」</li><li>「北京航空航天大学群友一同」</li></ul><p>真迹五句。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·2i：日本广告告示牌特辑</title>
    <link href="/2024/07/20/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B72i%EF%BC%9A%E6%97%A5%E6%9C%AC%E5%B9%BF%E5%91%8A%E7%89%8C%E7%89%B9%E8%BE%91/"/>
    <url>/2024/07/20/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B72i%EF%BC%9A%E6%97%A5%E6%9C%AC%E5%B9%BF%E5%91%8A%E7%89%8C%E7%89%B9%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>感觉日本好多广告或者告示牌都挺好玩的，整个特辑发一下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132158748.png" alt="关西国际机场·支付宝广告" /><figcaption aria-hidden="true">关西国际机场·支付宝广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132215487.png" alt="南海机场急行·大学广告" /><figcaption aria-hidden="true">南海机场急行·大学广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132216658.png" alt="天下茶屋站·大学广告" /><figcaption aria-hidden="true">天下茶屋站·大学广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201626788.png" alt="谷町四丁目·左北右南上东下西地图" /><figcaption aria-hidden="true">谷町四丁目·左北右南上东下西地图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201629123.png" alt="大阪城公园·你航同款禁飞无人机" /><figcaption aria-hidden="true">大阪城公园·你航同款禁飞无人机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201629278.png" alt="大阪市·品牌化停车场" /><figcaption aria-hidden="true">大阪市·品牌化停车场</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152137576.png" alt="近铁奈良站·欢迎光临奈良" /><figcaption aria-hidden="true">近铁奈良站·欢迎光临奈良</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152150694.png" alt="奈良公园·不要触碰小鹿" /><figcaption aria-hidden="true">奈良公园·不要触碰小鹿</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201631651.png" alt="春日大社·指路牌，不知道为什么感觉很好看" /><figcaption aria-hidden="true">春日大社·指路牌，不知道为什么感觉很好看</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407202141206.png" alt="奈良市·DV是domestic violence，这太高级词汇了" /><figcaption aria-hidden="true">奈良市·DV是domestic violence，这太高级词汇了</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201632643.png" alt="宇治市·结束乐队提醒您20岁以下不要抽烟" /><figcaption aria-hidden="true">宇治市·结束乐队提醒您20岁以下不要抽烟</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201634928.png" alt="大吉山·不要夜爬大吉山" /><figcaption aria-hidden="true">大吉山·不要夜爬大吉山</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201641071.png" alt="宇治市·垃圾投放处，日本人扔个垃圾还真难啊" /><figcaption aria-hidden="true">宇治市·垃圾投放处，日本人扔个垃圾还真难啊</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201635325.png" alt="宇治市·黄前相谈所" /><figcaption aria-hidden="true">宇治市·黄前相谈所</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121204995.png" alt="京阪宇治站·京吹3广告" /><figcaption aria-hidden="true">京阪宇治站·京吹3广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160111005.png" alt="京阪宇治站·京吹3广告" /><figcaption aria-hidden="true">京阪宇治站·京吹3广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201638025.png" alt="堺筋线·补课班广告" /><figcaption aria-hidden="true">堺筋线·补课班广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201639139.png" alt="堺筋线·大学广告" /><figcaption aria-hidden="true">堺筋线·大学广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201640791.png" alt="伏见稻荷·BA联动" /><figcaption aria-hidden="true">伏见稻荷·BA联动</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201640802.png" alt="伏见稻荷大社·地图" /><figcaption aria-hidden="true">伏见稻荷大社·地图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201648324.png" alt="京都站·「最近、この子といるとドキドキする。でも、誰にも気付かれないようにしよう......」" /><figcaption aria-hidden="true">京都站·「最近、この子といるとドキドキする。でも、誰にも気付かれないようにしよう......」</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201710739.png" alt="京都站·我去二次元" /><figcaption aria-hidden="true">京都站·我去二次元</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181558299.png" alt="西宫北口·凉宫春日立牌" /><figcaption aria-hidden="true">西宫北口·凉宫春日立牌</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181847153.png" alt="西宫北口·还是补课班广告" /><figcaption aria-hidden="true">西宫北口·还是补课班广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201725737.png" alt="甲阳园站·房地产广告" /><figcaption aria-hidden="true">甲阳园站·房地产广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201726834.png" alt="甲阳园站·医院广告" /><figcaption aria-hidden="true">甲阳园站·医院广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201706754.png" alt="西宫北高通学路·不要在危险的地方玩" /><figcaption aria-hidden="true">西宫北高通学路·不要在危险的地方玩</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182345439.png" alt="西宫北高通学路·注意痴汉！打110" /><figcaption aria-hidden="true">西宫北高通学路·注意痴汉！打110</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182249868.png" alt="西宫北高通学路·注意行人，推行自行车" /><figcaption aria-hidden="true">西宫北高通学路·注意行人，推行自行车</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201709185.png" alt="神户线·遇到痴汉，打110" /><figcaption aria-hidden="true">神户线·遇到痴汉，打110</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201709773.png" alt="神户线·关于婴儿车" /><figcaption aria-hidden="true">神户线·关于婴儿车</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201710482.png" alt="神户·西安门，跟回家了一样" /><figcaption aria-hidden="true">神户·西安门，跟回家了一样</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201711350.png" alt="新干线·在车上睡觉的时候一直感觉前排有人回头盯着我看..." /><figcaption aria-hidden="true">新干线·在车上睡觉的时候一直感觉前排有人回头盯着我看...</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201712782.png" alt="下北泽·结束乐队提醒你注意交通安全" /><figcaption aria-hidden="true">下北泽·结束乐队提醒你注意交通安全</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407202119099.png" alt="便利店·随处可见的二次元联动，真好" /><figcaption aria-hidden="true">便利店·随处可见的二次元联动，真好</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407202117156.png" alt="天下茶屋·我们家的拉面馆上过电视！" /><figcaption aria-hidden="true">天下茶屋·我们家的拉面馆上过电视！</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201713064.png" alt="池袋·麻辣烫和黄焖鸡米饭，就是没找见沙县营养小吃" /><figcaption aria-hidden="true">池袋·麻辣烫和黄焖鸡米饭，就是没找见沙县营养小吃</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201714114.png" alt="池袋·炸梦!这是我去!!!!!" /><figcaption aria-hidden="true">池袋·炸梦!这是我去!!!!!</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201714887.png" alt="秋叶原站·还没出站二次元浓度就上来了" /><figcaption aria-hidden="true">秋叶原站·还没出站二次元浓度就上来了</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407202122488.png" alt="电车·日本的广告好像很多都是纸做的，国内地铁上很少见纸做的广告" /><figcaption aria-hidden="true">电车·日本的广告好像很多都是纸做的，国内地铁上很少见纸做的广告</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201716664.png" alt="箱根·火山爆发会产生有毒气体 &amp; 有以下情况的不能坐索道" /><figcaption aria-hidden="true">箱根·火山爆发会产生有毒气体 &amp; 有以下情况的不能坐索道</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201715221.png" alt="箱根·火山爆发，逃进建筑物！" /><figcaption aria-hidden="true">箱根·火山爆发，逃进建筑物！</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201716037.png" alt="箱根·别开窗小心蜜蜂" /><figcaption aria-hidden="true">箱根·别开窗小心蜜蜂</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407201717363.png" alt="箱根·小心猴子" /><figcaption aria-hidden="true">箱根·小心猴子</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·伍：7月5日西宫神户之旅</title>
    <link href="/2024/07/18/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E4%BC%8D%EF%BC%9A7%E6%9C%885%E6%97%A5%E8%A5%BF%E5%AE%AB%E7%A5%9E%E6%88%B7%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/18/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E4%BC%8D%EF%BC%9A7%E6%9C%885%E6%97%A5%E8%A5%BF%E5%AE%AB%E7%A5%9E%E6%88%B7%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>今天来写一下西宫和神户的旅途，这是本次旅程的路线图： <a href="https://www.google.com/maps/d/edit?mid=1Y26JV4Xb_Yj9rLDk_BtDPyBxlOOZX4E&amp;usp=sharing">Day4 7.5 西宫神户</a></p><p>今天早上去了大阪的偶像大师店，以及西宫北口，下午去了西宫北高，神户的生田神社，美利坚公园和摩耶山。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407190004161.png" alt="封面图·西宫北高西门" /><figcaption aria-hidden="true">封面图·西宫北高西门</figcaption></figure><p>[toc]</p><h2 id="景点">景点</h2><h3 id="南梦宫店">南梦宫店</h3><p><a href="https://maps.app.goo.gl/GzNgrs38kY3QuQUt8">南梦宫店</a>，里面有很多万代南梦宫的东西。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181517578.png" alt="店铺外景·友人摄" /><figcaption aria-hidden="true">店铺外景·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181525326.png" alt="手办展柜" /><figcaption aria-hidden="true">手办展柜</figcaption></figure><p>不同于国内的游戏厅基本只有抓娃娃，这个店里有很多千奇百怪的游戏机。比如有一个圆环上放了很多支架，支架们上面放着景品手办，圆环上有一个高速移动的高亮区域，你每拍一次按钮（花费100日元），高亮区域对应的支架就会被撤下，直到有足够多的支架被撤下，手办掉下去，你就得到了这个手办。我在游戏厅花了500日元，一无所获。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181517569.png" alt="游戏厅·友人摄" /><figcaption aria-hidden="true">游戏厅·友人摄</figcaption></figure><p>这个地方离酒店很近，而且是非常喜欢偶像大师的友人推荐的，所以我们都去了。尽管我并不看偶像大师，但是也觉得挺有趣的，这一部分的照片也都是她拍的，感谢友人。（说起来，我其实也开始看了，不过才看2集）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181520931.png" alt="20年前偶像大师街机·友人摄" /><figcaption aria-hidden="true">20年前偶像大师街机·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181522545.png" alt="20年前的偶像大师街机·友人摄" /><figcaption aria-hidden="true">20年前的偶像大师街机·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181526017.png" alt="店外的大阪街景" /><figcaption aria-hidden="true">店外的大阪街景</figcaption></figure><p>逛完这个店以后，我们就准备从大阪难波前往西宫北口。谷歌地铁告诉我们，应该从大阪难波上车，坐御堂筋线，到梅田换乘阪急神户线特急。如果熟悉这两个站的朋友应该知道接下来会发生什么...</p><p>没错，我们理所当然地在大阪难波站迷路了，因为路牌上面只有「南海本线」、「南海特急」和「地下铁」，并没有我们要坐的「御堂筋线」。后来问了案内才知道，原来御堂筋线是地下铁的子集。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181542741.png" alt="梅田站" /><figcaption aria-hidden="true">梅田站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181543965.png" alt="阪急32番街" /><figcaption aria-hidden="true">阪急32番街</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181543916.png" alt="阪急神户线特急" /><figcaption aria-hidden="true">阪急神户线特急</figcaption></figure><p>成功找到御堂筋线后，总之算是顺利到了西宫北口。</p><h3 id="西宫北口梦咖啡">西宫北口·梦咖啡</h3><p>西宫市是凉宫春日的圣地，其中我们主要去了西宫北口和西宫北高。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181546767.png" alt="西宫北口站" /><figcaption aria-hidden="true">西宫北口站</figcaption></figure><p>刚到西宫北口的时候还是很激动的，因为没想到和朋友一起来日本毕业旅行竟然能成真，甚至真的来凉宫春日圣地巡礼了。能认识这么一群朋友真是大学生活中最大的幸事啊，谢谢大家！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181547601.png" alt="西宫北口自动贩卖机卖的冰激凌" /><figcaption aria-hidden="true">西宫北口自动贩卖机卖的冰激凌</figcaption></figure><p>这冰激凌，2000多日元，一瓶冰激凌+一个钥匙扣，性价比超低，不是厨力就别买了。我都有点后悔。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181548511.png" alt="凉宫春日经典集合处，「春日钟」" /><figcaption aria-hidden="true">凉宫春日经典集合处，「春日钟」</figcaption></figure><p>据说这个钟计划要拆除，但是凉宫春日粉丝联名保留了下来。</p><p>从西宫北口往北走一点点，就到了<a href="https://maps.app.goo.gl/sBucFQJemygQoU6u5">珈琲屋ドリーム</a>，这是谷川流写凉宫春日小说的地方，也是动画片里SOS团经常聚餐的地方，是粉丝常去的咖啡厅，不过更换过地址。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181555155.png" alt="西宫北口附近的街景" /><figcaption aria-hidden="true">西宫北口附近的街景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181558299.png" alt="西宫街道上的凉宫春日立牌" /><figcaption aria-hidden="true">西宫街道上的凉宫春日立牌</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181556318.png" alt="咖啡屋门口的1096立牌和七夕短册" /><figcaption aria-hidden="true">咖啡屋门口的1096立牌和七夕短册</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181556842.png" alt="梦咖啡门口" /><figcaption aria-hidden="true">梦咖啡门口</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182324431.png" alt="梦咖啡·店内·友人摄" /><figcaption aria-hidden="true">梦咖啡·店内·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181558654.png" alt="梦咖啡·菜单" /><figcaption aria-hidden="true">梦咖啡·菜单</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181558844.png" alt="梦咖啡里面的凉宫春日圣地巡礼地图" /><figcaption aria-hidden="true">梦咖啡里面的凉宫春日圣地巡礼地图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181600236.png" alt="长门有希同款蜜瓜气泡冰激凌饮料" /><figcaption aria-hidden="true">长门有希同款蜜瓜气泡冰激凌饮料</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181604195.png" alt="凉宫春日的忧郁2009 截图" /><figcaption aria-hidden="true">凉宫春日的忧郁2009 截图</figcaption></figure><p>说起来发生在七夕的《竹叶狂想曲》也是凉宫春日的重要篇章，所以我们合写了一个七夕短册</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181627235.png" alt="七夕短册" /><figcaption aria-hidden="true">七夕短册</figcaption></figure><p>在这里吃了午饭以后，就坐电车去甲阳园站，开始巡礼西宫北高通学路。</p><p>说起西宫北口，除去圣地巡礼以外，还有一个我很在意的地方。就是这一条街上都是二手房/租房的，以及补课班，这下谁还能分清西宫和国内啊（笑）。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181847153.png" alt="车站的补课班广告" /><figcaption aria-hidden="true">车站的补课班广告</figcaption></figure><h3 id="西宫北高">西宫北高</h3><p>从甲阳园步行到西宫北高，就是凉宫春日动画片里最经典的阿虚上学路了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181719331.png" alt="甲阳园站" /><figcaption aria-hidden="true">甲阳园站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181816753.png" alt="台阶" /><figcaption aria-hidden="true">台阶</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181815068.png" alt="长椅" /><figcaption aria-hidden="true">长椅</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181812961.png" alt="斑马线" /><figcaption aria-hidden="true">斑马线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181812486.png" alt="桥" /><figcaption aria-hidden="true">桥</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181810315.png" alt="加油站" /><figcaption aria-hidden="true">加油站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181809458.png" alt="平板桥" /><figcaption aria-hidden="true">平板桥</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181808486.png" alt="西宫北高西门" /><figcaption aria-hidden="true">西宫北高西门</figcaption></figure><p>还有最重量级的：西宫北高正门！圣地！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181818861.png" alt="凉宫春日的忧郁 截图" /><figcaption aria-hidden="true">凉宫春日的忧郁 截图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181819047.png" alt="西宫北高正门" /><figcaption aria-hidden="true">西宫北高正门</figcaption></figure><p>在这一路上，除了圣地巡礼以外，西宫这个小县城也给我很深的感触。不同于之前去的经典景区，这个地方就是一个很普通的日本小县城，坐落在一座山上。到处都是坡度超过20°的超级陡坡，以至于转角见到都因为这个坡陡得太抽象而想笑。就这种又细又陡的路，还有十几个锃光瓦亮的大货车疾驰而下，不得不说日本司机技术真是高啊。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182348181.png" alt="向抽象陡坡进发的众人·友人摄" /><figcaption aria-hidden="true">向抽象陡坡进发的众人·友人摄</figcaption></figure><p>随着越来越靠近西宫北高，海拔也越来越高，从这里可以眺望神户和大阪湾。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181840305.png" alt="西宫市眺望大阪湾" /><figcaption aria-hidden="true">西宫市眺望大阪湾</figcaption></figure><p>我们去西宫北高的时候，刚好是他们中小学放学。学生们真的都背着书包，拿着便当盒，从山上走下来。有一个小学女生看到了友人L的初音未来书包，笑着字正腔圆地说：「はつね みく！」（我去！初音未来！）。街道旁边也有一些很有生活气息的告示牌，比如</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181845408.png" alt="告示牌：不要在危险的地方玩" /><figcaption aria-hidden="true">告示牌：不要在危险的地方玩</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182249868.png" alt="不准骑自行车" /><figcaption aria-hidden="true">不准骑自行车</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182345439.png" alt="注意痴汉！拨打110！·友人摄" /><figcaption aria-hidden="true">注意痴汉！拨打110！·友人摄</figcaption></figure><p>学生们就这样充满活力地在超级陡坡上行进，周围都是很典型的日本一户建。感觉生活在这里，成天要爬这么陡的坡，真辛苦啊。但是开窗就能看到海和神户，说不定也会很幸福。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407181853382.png" alt="西宫北高前方的下坡路" /><figcaption aria-hidden="true">西宫北高前方的下坡路</figcaption></figure><p>看到图右下角那个自动贩卖机了吗？吞了友人Q的500日元，气死了。</p><p>从西宫北高走到苦乐园公交站，坐公交车前往JR芦屋市站，继续前往生田神社。</p><h3 id="生田神社-美利坚公园">生田神社 · 美利坚公园</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182252936.png" alt="生田神社 鸟居" /><figcaption aria-hidden="true">生田神社 鸟居</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182250936.png" alt="生田神社" /><figcaption aria-hidden="true">生田神社</figcaption></figure><p>去生田神社的主要目的当然是进行千恋万花的圣地巡礼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182251304.webp" alt="千恋万花 游戏CG" /><figcaption aria-hidden="true">千恋万花 游戏CG</figcaption></figure><p>除此之外，我们一行人还合写了一个绘马</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182302047.png" alt="「祝大家顺利毕业、抽卡不歪、朝九晚五，变成小猫＞＜，万事顺意，すべてに順調でありますように」" /><figcaption aria-hidden="true">「祝大家顺利毕业、抽卡不歪、朝九晚五，变成小猫＞＜，万事顺意，すべてに順調でありますように」</figcaption></figure><p>总共六行字，一人一句。</p><p>逛完生田神社，我们进行了一个决策，那就是应该直接上摩耶山呢？还是应该再去一下那个「美利坚公园」呢？最终因为时候似乎还早，我们决定先去美利坚公园。这是我觉得一个决策失误的地方，也导致了后来从摩耶山上下来时间的紧张。如果有人看到了这里，还想去摩耶山，而且已经五点半了的话，请直接去上山吧！</p><p>说是这么说，美利坚公园还是有点意思的，它其实就是濒临大阪湾的一个海滨公园。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182258703.png" alt="美利坚公园旁边的酒店，和夕阳" /><figcaption aria-hidden="true">美利坚公园旁边的酒店，和夕阳</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182302430.png" alt="大阪湾和游轮" /><figcaption aria-hidden="true">大阪湾和游轮</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182302946.png" alt="从美利坚公园回望神户" /><figcaption aria-hidden="true">从美利坚公园回望神户</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407190904571.png" alt="fate著名群众演员神户大桥·友人Q摄" /><figcaption aria-hidden="true">fate著名群众演员神户大桥·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182302984.png" alt="「成为科比」" /><figcaption aria-hidden="true">「成为科比」</figcaption></figure><h3 id="摩耶山掬星台">摩耶山掬星台</h3><p>从美利坚公园步行到电车站，坐到摩耶站，再坐公交车到缆车站，抵达缆车站时已经是19:54了。这代表着我们需要赶20:00上山的车，和20:50的下山末班车。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182307572.png" alt="摩耶缆车票，背后有时刻表" /><figcaption aria-hidden="true">摩耶缆车票，背后有时刻表</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407190857957.png" alt="摩耶山缆车站·友人Q摄" /><figcaption aria-hidden="true">摩耶山缆车站·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407190907034.png" alt="由缆车换乘索道的虹之站·友人Q摄" /><figcaption aria-hidden="true">由缆车换乘索道的虹之站·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182308368.png" alt="摩耶索道" /><figcaption aria-hidden="true">摩耶索道</figcaption></figure><p>其实在索道上已经能看到传说中的「百万夜景」了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182309406.png" alt="百万夜景（索道内）" /><figcaption aria-hidden="true">百万夜景（索道内）</figcaption></figure><p>在索道上看也没什么不好，当然，掬星台对我来说，更加地海阔天空嘛。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407190900775.png" alt="从索道站到掬星台的「kirakira路」·友人Q摄" /><figcaption aria-hidden="true">从索道站到掬星台的「kirakira路」·友人Q摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182309676.png" alt="摩耶山掬星台夜景" /><figcaption aria-hidden="true">摩耶山掬星台夜景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182310348.png" alt="摩耶山掬星台夜景2" /><figcaption aria-hidden="true">摩耶山掬星台夜景2</figcaption></figure><p>在这个台子上总共停了能有十几分钟吧，就要赶紧赶下山的缆车了。摩耶山因为看人太多，所以把20分钟一趟变成了10分钟一趟，我们赶上了20:40的那一趟。</p><p>这时候如果拿谷歌地图一查，会发现它推荐的第一条线路，全是末班车。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182314770.png" alt="全是末班车的线路" /><figcaption aria-hidden="true">全是末班车的线路</figcaption></figure><p>这一下子可把我们惊出了一身冷汗。不是哥们，咱就是说九点钟虽然不早了，但是也不算太晚吧？怎么就有滞留在神户的风险了呢？</p><p>当然，最终我们并没有这么极限，而是采用了这条路线，总的来说，这条线比较松弛，不用那么赶，给各位坐到了摩耶末班缆车的同志们参考：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182316922.png" alt="18路，神户三宫下车换乘阪神本线（大阪梅田方面）特急，尼崎下车换乘阪神难波线（近铁奈良方面）快速急行，大阪难波站直通近铁奈良线，近铁日本桥下车" /><figcaption aria-hidden="true">18路，神户三宫下车换乘阪神本线（大阪梅田方面）特急，尼崎下车换乘阪神难波线（近铁奈良方面）快速急行，大阪难波站直通近铁奈良线，近铁日本桥下车</figcaption></figure><p>有趣的是，这趟车路过甲子园的时候，呼啦上来了一亿个人，还都穿着球衣，可能是刚看完球赛吧。</p><p>回去已经十一点了，吃个晚饭就回去呼呼了。</p><h2 id="餐饮">餐饮</h2><p>今天吃了三顿饭。早饭吃了传说中的「炒面面包」（便利店买的），午饭在凉宫春日的圣地梦咖啡解决，晚上吃了烧鸟连锁店「鸟贵族」。</p><h3 id="炒面面包">炒面面包</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182321055.png" alt="炒面面包·友人摄" /><figcaption aria-hidden="true">炒面面包·友人摄</figcaption></figure><p>我的评价是：相当好吃，如果你航超市有我可能也会每天买来当早饭。</p><h3 id="梦咖啡">梦咖啡</h3><p>除了长门有希最喜欢的蜜瓜气泡冰激凌特饮以外，我们还点了一些松饼、热狗和三明治。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182322601.png" alt="火腿松饼·友人摄" /><figcaption aria-hidden="true">火腿松饼·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182323332.png" alt="照烧鸡肉热三明治·友人摄" /><figcaption aria-hidden="true">照烧鸡肉热三明治·友人摄</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182323116.png" alt="水果巴菲（怎么没有抹茶巴菲？）·友人摄" /><figcaption aria-hidden="true">水果巴菲（怎么没有抹茶巴菲？）·友人摄</figcaption></figure><p>松饼挺一般的，并不出彩；热鸡肉三明治特别好吃；巴菲也不错。</p><p>但是准备在这里用午饭的各位请注意：他们家上菜速度挺慢的，如果要在这里吃午饭，请做好被硬控一个多小时的准备。</p><h3 id="鸟贵族">鸟贵族</h3><p>我们吃的是<a href="https://maps.app.goo.gl/LXXAqrgL8DQsU9zS9">近铁日本桥店</a>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182328054.png" alt="鸟贵族" /><figcaption aria-hidden="true">鸟贵族</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182329438.png" alt="鸟贵族·友人摄" /><figcaption aria-hidden="true">鸟贵族·友人摄</figcaption></figure><p>总的来说，就是个中规中矩的烧鸟店。有葱烧鸡腿肉、鸡肉丸子、鸡胗、牛肉等等经典烤串。小红书上面有很多说分量大点了吃不完的，其实我们放开了点，吃完了以后还是欠了一点。</p><p>鸟贵族旁边有个很搞笑的广告牌。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407182331498.png" alt="（爱犬）（猫）" /><figcaption aria-hidden="true">（爱犬）（猫）</figcaption></figure><p>7月5日的旅途就是这样，随着7月5日的结束，我们在大阪的4天行程也宣告结束，下一站是东京。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·肆：7月4日伏见京都之旅</title>
    <link href="/2024/07/16/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E8%82%86%EF%BC%9A7%E6%9C%884%E6%97%A5%E4%BC%8F%E8%A7%81%E4%BA%AC%E9%83%BD%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/16/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E8%82%86%EF%BC%9A7%E6%9C%884%E6%97%A5%E4%BC%8F%E8%A7%81%E4%BA%AC%E9%83%BD%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>今天来写一下伏见和京都的旅途，这是本次旅程的路线图：</p><p><a href="https://www.google.com/maps/d/edit?mid=1EF85i4VRiEIC7zZ699TfiE0mnkX371U&amp;usp=drive_link">Day3 伏见京都</a></p><p>今天主要就是在京都附近逛，上午去了伏见稻荷大社，中午去了京都站，下午去了清水寺、二三年坂，最后去了任天堂。</p><p>[toc]</p><h2 id="景点">景点</h2><h3 id="伏见稻荷大社">伏见稻荷大社</h3><p>伏见稻荷大社作为日本的一个代表性的景点，自然是不得不去的。这是我们的路线图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162318982.png" alt="伏见稻荷大社游览路线图" /><figcaption aria-hidden="true">伏见稻荷大社游览路线图</figcaption></figure><p>简单来说，我们就是从京阪伏见稻荷站下车，经过千本鸟居到达熊鹰社，然后返回JR稻荷站。</p><p>「伏见稻荷大社」的意思就是「在伏见供奉稻荷神的很大的神社」。稻荷神是日本神话中的谷物和食物神，它的常见神使是狐狸，所以伏见稻荷大社附近有很多狐狸的景观。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162346190.png" alt="狐狸景观" /><figcaption aria-hidden="true">狐狸景观</figcaption></figure><p>前往伏见稻荷时，我们从近铁日本桥出发，乘坐堺筋线(高槻市方面)，北滨站下车换乘京阪本线(出町柳方面)特急，丹波桥站下车换乘京阪本线(出町柳方面)准急，伏见稻荷下车。这里就是我之前在<a href="https://blog.sakizuki.site/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7i%EF%BC%9A%E6%97%A5%E6%9C%AC%E5%85%AC%E5%85%B1%E4%BA%A4%E9%80%9A%E7%89%B9%E8%BE%91/#%E5%90%8C%E7%BA%BF%E6%8D%A2%E4%B9%98">日本公共交通特辑</a>里提到过的「同线换乘」。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162324125.png" alt="京阪伏见稻荷站" /><figcaption aria-hidden="true">京阪伏见稻荷站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162324060.png" alt="正在进站的京阪列车" /><figcaption aria-hidden="true">正在进站的京阪列车</figcaption></figure><p>出站以后就会进入一个很繁忙的商业街，有卖小吃和纪念品的。其实这个街上有时候就会突然出现一个鸟居，还挺神奇的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162330367.png" alt="鸟居（突然出现）" /><figcaption aria-hidden="true">鸟居（突然出现）</figcaption></figure><p>很快就到伏见稻荷大社的正门了。我们还在这里买了朱印账，写了御朱印。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162331656.png" alt="伏见稻荷大社正门" /><figcaption aria-hidden="true">伏见稻荷大社正门</figcaption></figure><p>值得一提的是，如果你是自带朱印账让他写，那么所有的字儿都是现场手写的；但是如果你是现场买的朱印账，那么「伏见稻荷大社」这几个字是预先写好的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162334733.png" alt="朱印" /><figcaption aria-hidden="true">朱印</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162334144.png" alt="朱印账，古色古香的一个小本子" /><figcaption aria-hidden="true">朱印账，古色古香的一个小本子</figcaption></figure><p>求了签，我的是「凶后吉」，我也成为了我们一行人在神社求签中，签文里第一个出现「凶」字的人。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162336412.png" alt="凶后吉" /><figcaption aria-hidden="true">凶后吉</figcaption></figure><p>整完了这些，我们就开始上山。说起伏见稻荷大社，最著名的当然是千本鸟居。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162337376.png" alt="千本鸟居" /><figcaption aria-hidden="true">千本鸟居</figcaption></figure><p>这应该是不少ACG作品的圣地，简直无法列数了，如果让我一定要就第一印象说一个，那么是《Hello World》。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162339183.png" alt="Hello World 截图" /><figcaption aria-hidden="true">Hello World 截图</figcaption></figure><p>这些鸟居应该都是人捐的，两根柱子上一个写「某某某株式会社」，另一根写「某年某月某日建之」，就我们去的那一天还有个工人给刚建好的鸟居刷漆，却也不知道建一个多少钱。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162343733.png" alt="千本鸟居（从外面看）" /><figcaption aria-hidden="true">千本鸟居（从外面看）</figcaption></figure><p>通过了千本鸟居，就是慢慢往山上走了。在途中我们还遇到了一个神秘仪式，叫「おもかる石」，意思就是你给赛钱箱里投币，然后许愿，然后在赛钱箱左右两侧两个圆形石头里面挑一个举起。如果石头比你想象的轻，说明愿望能实现；反之，则说明愿望还需要努力。</p><p>一路上的景色还是不错的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162346547.png" alt="鸟居" /><figcaption aria-hidden="true">鸟居</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162347802.png" alt="发现的神奇绘马" /><figcaption aria-hidden="true">发现的神奇绘马</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162348495.png" alt="使用「留念镜」观察地狐小雕像" /><figcaption aria-hidden="true">使用「留念镜」观察地狐小雕像</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162348444.png" alt="熊鹰社的洗手池，浸泡着紫阳花" /><figcaption aria-hidden="true">熊鹰社的洗手池，浸泡着紫阳花</figcaption></figure><p>逛完下来以后，我们在JR稻荷站旁边发现了名为「一果」的甜品店，和《相合之物》的主角名字一样，题材也一样，这下不得不被硬控了。买了个菠萝汽水，非常好喝。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162350049.png" alt="一果" /><figcaption aria-hidden="true">一果</figcaption></figure><p>在前往京都站之前，我们还去<a href="https://maps.app.goo.gl/fv2bp4jQKNgzjFZKA">伏見稲荷郵便局</a>给国内寄了明信片，友人的已经收到了，我的还没有。我忽然感觉在旅游的时候，用景点的明信片、邮票和邮戳往家里寄信，也不失为一件很浪漫的事。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162352073.png" alt="JR奈良线列车" /><figcaption aria-hidden="true">JR奈良线列车</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162353415.png" alt="JR稻荷站内" /><figcaption aria-hidden="true">JR稻荷站内</figcaption></figure><p>从JR稻荷站直接坐奈良线就可以前往京都站了。</p><h3 id="京都站">京都站</h3><p>京都站作为一个车站，本身也是景点。在京都站可以看三个东西：京阿尼快闪店；京吹和柯南的圣地巡礼；京都塔。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407162358184.png" alt="京阿尼快闪店。这招牌怎么整得久美子和黑江是CP似的..." /><figcaption aria-hidden="true">京阿尼快闪店。这招牌怎么整得久美子和黑江是CP似的...</figcaption></figure><p>京都站的规模特别大，是一个新干线站，而且建在一个购物中心里面，道路错综复杂。这个店在一楼，谷歌地图带着我们在二楼逡巡了十分钟，直到智慧的友人打开了小红书，我们才找到正确的地方。不得不说，谷歌地图在室内的表现就像依托史。</p><p>京阿尼快闪店是本次旅途中第一个纯纯的二次元景点，里面有很多关于京阿尼的作品的展览和谷子。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170000067.png" alt="高太尉同款小号" /><figcaption aria-hidden="true">高太尉同款小号</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170000736.png" alt="久美子同款上低音号" /><figcaption aria-hidden="true">久美子同款上低音号</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170001230.png" alt="紫罗兰永恒花园，手套、信封和打字机" /><figcaption aria-hidden="true">紫罗兰永恒花园，手套、信封和打字机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170001459.png" alt="京吹立牌" /><figcaption aria-hidden="true">京吹立牌</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170002372.png" alt="京吹四人组签名的乐器箱" /><figcaption aria-hidden="true">京吹四人组签名的乐器箱</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170003572.png" alt="顾客留言本，有很多有趣的画和留言，比如「秀一 didn&#39;t find your goods」" /><figcaption aria-hidden="true">顾客留言本，有很多有趣的画和留言，比如「秀一 didn't find your goods」</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407171441595.png" alt="魔法少女郭德纲" /><figcaption aria-hidden="true">魔法少女郭德纲</figcaption></figure><p>我在这里面买了6000日元的东西，大概是一些杂七杂八的谷子，一个凉宫春日名场面明信片册，和一幅画。</p><p>从京都站一出来就能看到京都塔了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170004179.png" alt="京都塔" /><figcaption aria-hidden="true">京都塔</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170005428.png" alt="标志性的「JR京都站」" /><figcaption aria-hidden="true">标志性的「JR京都站」</figcaption></figure><p>说起来这个车站里有<a href="https://blog.sakizuki.site/2024/07/13/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E8%B4%B0%EF%BC%9A7%E6%9C%882%E6%97%A5%E5%A4%A7%E9%98%AA%E4%B9%8B%E6%97%85/#%E4%BB%8E%E6%9C%BA%E5%9C%BA%E5%88%B0%E9%85%92%E5%BA%97">大学宣传册</a>免费发放，我拿了一本「京都橘大学」的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170008144.png" alt="京都橘大学宣传册，封面和内页" /><figcaption aria-hidden="true">京都橘大学宣传册，封面和内页</figcaption></figure><p>在京都站附近吃过午饭以后，坐公交车前往清水寺。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170009377.png" alt="就是在这个站台坐的车！" /><figcaption aria-hidden="true">就是在这个站台坐的车！</figcaption></figure><h3 id="清水寺周边">清水寺周边</h3><p>其实「清水寺周边」包括了清水寺、二年坂、三年坂、花见小路、任天堂京都这五个地方，我们全部采用步行前往，从清水道公交车站(<span class="math inline">\(A\)</span>)下车，途径清水寺(<span class="math inline">\(B\)</span>)，三(<span class="math inline">\(C\)</span>)二年坂(<span class="math inline">\(D\)</span>)，花见小路(<span class="math inline">\(E\)</span>)，一直走到任天堂(<span class="math inline">\(F\)</span>)。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170013701.png" alt="清水寺路线图" /><figcaption aria-hidden="true">清水寺路线图</figcaption></figure><p>在下公交车时，我们发现京都有点下雨。此后，京都就一直维持着这个似雨未雨的状态。</p><p>从清水道下车，需要爬一个很陡的坡才能到清水寺，这个坡其实也是个商业步行街，布满了门面房和摊贩。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170014549.png" alt="似雨未雨的天空，和丁达尔效应" /><figcaption aria-hidden="true">似雨未雨的天空，和丁达尔效应</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170014343.png" alt="从清水寺山顶看京都塔" /><figcaption aria-hidden="true">从清水寺山顶看京都塔</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170015363.png" alt="标志性的清水寺三重塔" /><figcaption aria-hidden="true">标志性的清水寺三重塔</figcaption></figure><p>在清水寺休憩时，我发现了对日本的第四个刻板印象：<strong>休息处的喷雾降温装置很普遍。</strong></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170021594.png" alt="休息处的喷雾装置" /><figcaption aria-hidden="true">休息处的喷雾装置</figcaption></figure><p>这个装置，我第一次见它是在上海世博会上。在日本的大街或者景点里，只要有这种亭子一样的休息处，基本都会带这种喷雾装置，挺凉快的，点个赞。</p><p>三年坂和二年坂其实都是坐落在比较陡峭的山路上的商业步行街，也是千恋万花的巡礼处。即使没有商铺，传统老屋错落有致地排放，也是很好看的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170015105.png" alt="三年坂，千恋万花圣地巡礼" /><figcaption aria-hidden="true">三年坂，千恋万花圣地巡礼</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170019715.png" alt="二年坂，千恋万花巡礼地" /><figcaption aria-hidden="true">二年坂，千恋万花巡礼地</figcaption></figure><p>二年坂结束以后基本就是平地了。走一段就到了花见小路，同样也是千恋万花的巡礼地。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170023637.png" alt="花见小路" /><figcaption aria-hidden="true">花见小路</figcaption></figure><p>感觉京都就是这种古色古香，同时又到处都是店面的模式。我们从花见小路走到任天堂的这一段路也是这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170025107.png" alt="大街边上的门面摊位" /><figcaption aria-hidden="true">大街边上的门面摊位</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170028831.png" alt="国士无双扭蛋机" /><figcaption aria-hidden="true">国士无双扭蛋机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170025565.png" alt="傍晚的鸭川，好看" /><figcaption aria-hidden="true">傍晚的鸭川，好看</figcaption></figure><p>任天堂其实是在一个商场的七楼和八楼。从照片上可以看出，我们大概七点到任天堂，而商场八点关门，所以可以在里面逛一个小时。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170026154.png" alt="任天堂里的马里奥雕像，我们在这里拍了合影" /><figcaption aria-hidden="true">任天堂里的马里奥雕像，我们在这里拍了合影</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170028785.png" alt="商场书店里的二次元" /><figcaption aria-hidden="true">商场书店里的二次元</figcaption></figure><p>商场关门后我们就坐京阪特急回大阪了。这一路上真的很累，大概是湿热的天气+陡峭的地形+较快的移动速度+较长的移动距离共同作用的结果，累到到了任天堂只想找个椅子先坐下歇歇的程度。</p><h2 id="饮食">饮食</h2><p>今天吃了两顿饭：中午在京都站附近吃了咖喱饭；晚上在酒店附近吃了松屋。</p><h3 id="咖喱饭">咖喱饭</h3><p>这个咖喱店的名字叫做<a href="https://maps.app.goo.gl/YeJmujMUi9GkmVzC6">カレーハウスCoCo壱番屋 南区八条口店</a>，似乎是一个规模不小的连锁店。支持扫码点餐，支持简体中文，跟回家了一样。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170032462.png" alt="咖喱" /><figcaption aria-hidden="true">咖喱</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407171439199.png" alt="咖喱合照，和点单页面（神奇的加辣加钱）" /><figcaption aria-hidden="true">咖喱合照，和点单页面（神奇的加辣加钱）</figcaption></figure><p>质量还是非常不错的，咖喱浓郁，炸物酥脆多汁，温泉蛋熟度也刚好好。值得一提的是：日本人很喜欢在咖喱里面加茄子，这是我在国内没见过的吃法，而且还挺好吃。我们每人一盘咖喱饭+三个小食拼盘，人均97元。</p><h3 id="松屋">松屋</h3><p>为什么选择松屋？当然是因为食其家和吉野家国内都有啦。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407170034201.png" alt="温泉蛋葱花牛肉饭套餐" /><figcaption aria-hidden="true">温泉蛋葱花牛肉饭套餐</figcaption></figure><p>松屋的点餐也是像昨天的那个拉面店一样，先在机器上点，然后把票给店员。在松屋，我得到了对日本的第五个刻板印象，虽然这个印象老早就形成了，但是在松屋才真正确信。那就是：<strong>日本的餐饮店全都默认免费提供冰水！</strong>我觉得这简直太文明了，我愿意将其和「休息处喷雾器」并称为全日本两大文明之光。国内的餐厅你要桶冰块还扣扣嗖嗖地不给，日本人直接每桌放个装着冰水混合物的水壶随意取用。对于觉得冰水是「好喝饮料排行榜」TOP3之一的我来说，这简直就是天堂。</p><p>说回松屋的饭，感觉还蛮不错的，虽然没有显著地比国内的吉野家好吃多少，但是菜单比吉野家丰富，我吃了葱花牛肉饭，友人吃了芝士牛肉饭，都是挺新鲜的体验。</p><h3 id="自助洗衣和便利店">自助洗衣和便利店</h3><p>在日本已经呆了3天了，也积累了不少脏衣服，是时候去洗一洗了。日本有一个特色，就是投币式洗衣店。它的运行模式就像大学里的自助洗衣一样，只不过还带了烘干功能。洗衣机的容量非常的大，最大的有30kg，同时放三个人三天的衣服是完全没问题的。作为游客，我感觉自助洗衣房的存在是一件非常方便的事情。有很多二次元作品，比如《命运石之门》也描写了投币式洗衣房。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407171047531.jpeg" alt="投币式洗衣房，图片来自网络，侵删" /><figcaption aria-hidden="true">投币式洗衣房，图片来自网络，侵删</figcaption></figure><p>日本的便利店也是一大特色，是日本少数有可能24小时营业的商铺了（当然晚上店员有可能不是日本人）。里面除了中国便利店都有的饮料小吃百货以外，还有很多便当，比如亲子丼、牛丼、咖喱饭、照烧鸡排等等，便利店也成为了深夜晚饭的主要来源。我们把衣服扔到洗衣机里了以后，就在旁边的便利店转悠，这时，友人Z和印度店员之间发生了一件趣事。</p><blockquote><p>友人Z：（既然是印度人 那我说英文吧就不说蹩脚的日语了）</p><p>友人Z：Is there any soap？</p><p>印度店员：？</p><p>友人Z：soap.</p><p>印度店员：（掏出一把勺子）</p><p>友人Z：……I mean soap not soup.</p><p>印度店员：Can you speak it in English?</p><p>友人Z：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407171052624.png" /></p></blockquote><p>此事发生时，我和另一个一同去洗衣的友人Q都不在现场。我被便利店里的二次元和文春杂志硬控了，而友人Q被便利店里的ATM硬控了。友人Q在我们7天的旅途中，一直孜孜不倦地试图在日本的各种ATM机上给他的芯片银联卡取钱，可总是无功而返。尽管他也是一片好心，但是这种西西弗斯、吴刚伐桂的精神还是给我们增添了一丝笑意（糟了，有点地狱了......）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407171055700.png" alt="日本ATM机，最终发现只支持磁条卡" /><figcaption aria-hidden="true">日本ATM机，最终发现只支持磁条卡</figcaption></figure><p>7月4日的旅途就到这里。7月5日我们去了西宫和神户。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·叁：7月3日奈良宇治之旅</title>
    <link href="/2024/07/15/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E5%8F%81%EF%BC%9A7%E6%9C%883%E6%97%A5%E5%A5%88%E8%89%AF%E5%AE%87%E6%B2%BB%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/15/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E5%8F%81%EF%BC%9A7%E6%9C%883%E6%97%A5%E5%A5%88%E8%89%AF%E5%AE%87%E6%B2%BB%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>今天来写一下奈良和宇治的旅途，这是本次旅程的路线图：</p><p><a href="https://www.google.com/maps/d/edit?mid=1VHdABrG2zvnWYSlZ5RcUBAXPQjzHlso&amp;usp=drive_link">Day 2 奈良宇治路线图</a></p><p>正如标题所说，这次主要是去了奈良和宇治。</p><h2 id="景点">景点</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152245606.png" alt="奈良部分路线图" /><figcaption aria-hidden="true">奈良部分路线图</figcaption></figure><h3 id="奈良小鹿">奈良小鹿</h3><p>一大早吃过早饭以后，就直接从酒店门口的近铁日本桥站坐近铁奈良线到了近铁奈良站。（为什么写这么多「近铁」？请看我之前的<a href="https://blog.sakizuki.site/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7i%EF%BC%9A%E6%97%A5%E6%9C%AC%E5%85%AC%E5%85%B1%E4%BA%A4%E9%80%9A%E7%89%B9%E8%BE%91/">日本公共交通特辑</a>）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152137576.png" alt="近铁奈良站" /><figcaption aria-hidden="true">近铁奈良站</figcaption></figure><p>一开始我还以为奈良的鹿们至少是在一个院子里的，可是没想到一出地铁站就碰上了散在大马路上的鹿。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152146984.png" alt="碰到的第一只鹿" /><figcaption aria-hidden="true">碰到的第一只鹿</figcaption></figure><p>这似乎还是我第一次这么近距离地接触这种体型的野生动物，哈哈......</p><p>奈良的马路边上有很多售卖鹿饼的小商贩，鹿饼都是一样的，价格也都是一样的（200日元一摞），所以随便在哪里买都好，我们平均一个人买了2摞鹿饼，后来证明是完全够的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152157644.png" alt="鹿煎饼，用了《鹿乃子乃子虎视眈眈》的图，就长这样" /><figcaption aria-hidden="true">鹿煎饼，用了《鹿乃子乃子虎视眈眈》的图，就长这样</figcaption></figure><blockquote><p><strong>是「鹿煎饼」还是「鹿仙贝」呢？</strong></p><p>其实这俩是一种东西的两种叫法，在日语中，煎饼写作「煎餅」，念作「せんべい」，罗马音是「senbei」，它在中文里读作「仙贝」，含义是煎饼。所以，这是一个经过翻译兜兜转转最后发现自己不是自己了的故事。</p></blockquote><p>鹿煎饼里面只有面、糠和水，没有任何糖油，吃起来很难吃（别问我为什么知道）。</p><p>但是你不要看这些鹿好像很温顺的样子，还给你鞠躬；其实它们还挺凶的，很擅于发现你本想要藏起来的鹿饼。我就经常被三四只鹿逼在墙角动弹不得，最终不得不拿出一张鹿饼喂喂他们落荒而逃。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152205004.png" alt="这些鹿真的很能抢" /><figcaption aria-hidden="true">这些鹿真的很能抢</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152150694.png" alt="马路上随处可见的告示牌，这证明鹿真的挺凶的..." /><figcaption aria-hidden="true">马路上随处可见的告示牌，这证明鹿真的挺凶的...</figcaption></figure><p>甚至还有个朋友被鹿站起来踢了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407161118464.png" alt="被鹿踢的痕迹" /><figcaption aria-hidden="true">被鹿踢的痕迹</figcaption></figure><p>其实也有不那么活泼，比较摆的鹿。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152210145.png" alt="（窝）" /><figcaption aria-hidden="true">（窝）</figcaption></figure><p>虽然告示牌不让摸鹿，但是就这个情况下，不摸到鹿实在是一件很困难的事情。鹿的角不是完全光滑的，上面有一些细小的绒毛；鹿身子摸起来体温很高，和马的手感差不多。</p><h3 id="春日大社">春日大社</h3><p>为什么我对春日大社这么有兴趣呢，其中一个原因是它很有名，另一个原因自然是我喜欢凉宫春日，尽管这俩事物的关系应该仅仅局限于名字一样。</p><p>从地铁站出来以后一直往西走，然后在一个十字路口往右（南）一偏，就进入了「春日大社」表参道，往里走就是去春日大社的路了。这一路上有很多石灯笼，当然也有很多路。正是在这条路上，我拍到了今天最满意的一张照片，必须要发个原图纪念一下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408091051362.jpg" alt="春日大社的石灯笼和鹿" /><figcaption aria-hidden="true">春日大社的石灯笼和鹿</figcaption></figure><p>这一条路基本都是上坡路，走着走着就遇到一个石头：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152216217.png" alt="春日大社石头" /><figcaption aria-hidden="true">春日大社石头</figcaption></figure><p>看到这个石头就说明你再往前走就进春日大社里面了，要遵守他们的一些规矩，其中最需要注意的是不能饮食。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152218165.png" alt="春日大社正门" /><figcaption aria-hidden="true">春日大社正门</figcaption></figure><p>这也是我们在日本去的第一个神社，刚一进门就是正殿，左边有一溜求签的、卖御守的、写御朱印的和卖其它纪念品的，顺着这个街往里走是一个绘马架子，上面挂了很多用来祈福的绘马。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152220794.png" alt="春日大社的绘马，好多汉语" /><figcaption aria-hidden="true">春日大社的绘马，好多汉语</figcaption></figure><p>右边的路再往前就是参拜的了，因为我们都没有这个神道教的宗教信仰，所以并没有进行参拜，但是还是求了个签。春日大社的求签有两种：600日元的：除了签文以外还会给你送一个陶土小鹿偶，这个小鹿嘴里叼着签文；200日元的：只有签文的一张纸。我俩都抽了一下，俩都是末吉......</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152225401.png" alt="陶土小鹿" /><figcaption aria-hidden="true">陶土小鹿</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152226542.png" alt="200日元的，俩大吉俩末吉" /><figcaption aria-hidden="true">200日元的，俩大吉俩末吉</figcaption></figure><p>在春日大社稍事休息后，我们就准备下山，前往下一站：若草山</p><h3 id="若草山">若草山</h3><p>从春日大社下来以后，我们并没有走最近的春日大社公交站路线前往若草山，而是又回到了那个浮云园地的十字路口再去若草山，其中的深意当然是......走错路了。</p><p>但是正因为这个错误，我们吃上了传说中的日本刨冰。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152246407.png" alt="抹茶刨冰，要乐奈狂喜" /><figcaption aria-hidden="true">抹茶刨冰，要乐奈狂喜</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152249119.png" alt="草莓刨冰，这图我没任何后期，它就这个颜色" /><figcaption aria-hidden="true">草莓刨冰，这图我没任何后期，它就这个颜色</figcaption></figure><p>抹茶刨冰很好吃，感觉像真抹茶；草莓刨冰很一般，感觉像色素+糖水。在吃刨冰的时候，周围还有很多鹿和我们抢食（没错，你在看整个奈良部分的时候，一直默认我们身边都有很多鹿就好了）</p><p>经过谷歌地图的一系列「将军走此小道」，我们终于还是抵达了若草山，上山还要收150日元门票。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152253733.png" alt="若草山门票" /><figcaption aria-hidden="true">若草山门票</figcaption></figure><p>若草山就是一个被草坪铺满的山，上面也有一些鹿（从门票上就看出来了）。因为我们体力比较有限，所以并没有登顶，而是在半路上找了个视野好的地方就坐下了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152257058.png" alt="所谓「视野好」" /><figcaption aria-hidden="true">所谓「视野好」</figcaption></figure><p>在若草山上发生了一件趣事。有一只小鹿紧紧地跟着我们，我又给它喂鹿饼，又给它喝水，但是它还是没有要走的意思，直到我把手里的鹿饼都喂完了，它还是在跟着我们。我一直没搞明白这是什么情况，直到那个鹿用嘴打开了我的背包，才发现还有半摞鹿饼被我忘在了包里，最后自然是全部给它吃了。可能这就是传说中的选择大于努力吧，山下的四只鹿抢半块饼，山上的鹿一只鹿吃一摞饼。哎，还不是你不努力爬山。</p><p>游览完若草山，回春日大社公交站坐巴士去JR奈良站，这也是我们第一次在日本坐公交车，万幸这回没走错路。在公交车上遇见了一队修学旅行的中学生（感觉是初中生），啊，真是青春啊......</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407161121123.png" alt="公交车上拍到的路牌「！🦌」" /><figcaption aria-hidden="true">公交车上拍到的路牌「！🦌」</figcaption></figure><h3 id="宇治">宇治</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152354729.png" alt="宇治路线" /><figcaption aria-hidden="true">宇治路线</figcaption></figure><p>在JR奈良站吃完午饭以后就动身前往宇治，大概是五点零四到的。到了宇治站，才发现一个问题：那个有京吹快闪的游客服务中心竟然关门了。这时的我们还不知道，这至少我们在日本遇到的「关门地狱」的序曲罢了......</p><p>这就是我对日本的第二个刻板印象了：<strong>他们真的不赚钱吗？日本人是晚上八点以后就消失了吗？</strong>游客服务中心是五点钟关门，他们真的觉得五点以后就没有游客了吗？京都的那个任天堂店所在的商场是晚上八点关门，八点不应该才是夜生活刚开始，商场最热闹的时间吗？后来在东京逛完秋叶原九点<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="至于为什么九点多就逛完了呢，哈哈哈，你猜">[1]</span></a></sup>想找个吃的，在御茶之水附近的街道上转了两圈，只有三家餐饮店亮着灯，分别是印度菜、印度菜，和忘记关灯的日本菜，甚至松屋都关门了（这玩意难道不应该是24小时营业吗）。我们到了日本菜门口，人家才说是忘了关灯了。最后我们去了711买便当解决——顺便一提：711的营业员是印度人。</p><p>回到宇治，我们首先看了宇治川和宇治桥。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152350637.png" alt="苦呀西" /><figcaption aria-hidden="true">苦呀西</figcaption></figure><p>说说这个宇治川，除了作为京吹的圣地巡礼以外，它给我的最大的印象是：真的很湍急。在去之前我还以为是那种很经典的城中小河，静静流过。到了一看才发现，水流真的很大，有一种这条河真的在活着的感觉。我很喜欢这种城里面有个活着的河。</p><p>过了宇治桥，我们直接前往大吉山展望台。在去大吉山展望台的过程中，我也拍了拍宇治的街景</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152356838.png" alt="宇治街景" /><figcaption aria-hidden="true">宇治街景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152357801.png" alt="坡道，当时看起来感觉很陡于是拍了，到西宫才发现这根本不算什么" /><figcaption aria-hidden="true">坡道，当时看起来感觉很陡于是拍了，到西宫才发现这根本不算什么</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407152358039.png" alt="大吉山展望台登山路入口" /><figcaption aria-hidden="true">大吉山展望台登山路入口</figcaption></figure><p>他说夜间危险，但是没有任何人拦你，后来我们才发现根本不用拦。</p><p>这个登山路真的很难走，不是水泥路，基本都是石子路和土路，而且比较长，爬起来还是挺费劲的。如果自觉体力不是特别好，就不要学久美子和高坂丽奈那样穿着高跟鞋拿着上低音号去爬了，真的会很累。</p><p>爬到大吉山展望台基本已经快要日落了，我们决定待在上面看看夕阳下的宇治。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160005108.png" alt="夕阳下的宇治" /><figcaption aria-hidden="true">夕阳下的宇治</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160005225.png" alt="大吉山展望台（为保护隐私，本图采用了人工智能自动去物技术）" /><figcaption aria-hidden="true">大吉山展望台（为保护隐私，本图采用了人工智能自动去物技术）</figcaption></figure><p>可惜我们既不会吹小号和上低音号，也没那个体力把它们拿上来，就没法复刻高黄名场面了。</p><p>太阳落山了，我们也该下山了。黑天（其实都不算完全黑）的大吉山只能用一个词来形容，那就是「阴森恐怖」。根本没有路灯，只有漆黑的树，漆黑的路，以及苟延残喘的阳光。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160008673.png" alt="黑天的大吉山登山道" /><figcaption aria-hidden="true">黑天的大吉山登山道</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160009009.png" alt="「导师怎么知道我这段论文是抄袭的呢？」" /><figcaption aria-hidden="true">「导师怎么知道我这段论文是抄袭的呢？」</figcaption></figure><p>在下山的路上，我们发现了一处绝景，想要拍张合照，但是光线条件实在太差，再加上大家都比较疲惫，最终的效果大概跟这张图差不多。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160011101.png" alt="我也迷失了......" /><figcaption aria-hidden="true">我也迷失了......</figcaption></figure><p>夜间的宇治川。小城里万籁俱寂，只有黢黑湍急的宇治川流淌的声音。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160013891.png" alt="宇治川" /><figcaption aria-hidden="true">宇治川</figcaption></figure><p>虽然天已经黑了，但是我们还有最后一个景点：黄前相谈所。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160025195.png" alt="黄前相谈所" /><figcaption aria-hidden="true">黄前相谈所</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160021918.png" alt="黄前相谈所" /><figcaption aria-hidden="true">黄前相谈所</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160024601.png" alt="吹响吧！上低音号：誓言的终章 截图" /><figcaption aria-hidden="true">吹响吧！上低音号：誓言的终章 截图</figcaption></figure><p>江畔何人初见月？江月何年初照人？人生代代无穷已，江月年年望相似。不知江月待何人，但见长江送流水。可能这就是「圣地巡礼」的魅力吧。</p><p>吃了久美子同款晚饭以后我们就去京阪宇治站坐电车回去了。</p><p>这个京阪宇治站里面有很多京吹广告<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="虽然都是京吹三的，众所周知京吹三是......">[3]</span></a></sup>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121204995.png" alt="京吹广告其一" /><figcaption aria-hidden="true">京吹广告其一</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160111005.png" alt="京吹广告其二" /><figcaption aria-hidden="true">京吹广告其二</figcaption></figure><h2 id="餐饮">餐饮</h2><p>今天总共吃了三顿饭，分别是酒店的和式早餐，JR奈良站附近的拉面小馆，和黄前久美子同款萨莉亚。</p><h3 id="和式早餐">和式早餐</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160033967.png" alt="和式早餐" /><figcaption aria-hidden="true">和式早餐</figcaption></figure><p>一人是2200日元，有三条小鱼、油豆腐、蔬菜沙拉，若干碗小菜、生鱼片、苹果汁、酸奶、米饭、温泉蛋等，花样繁多，而且味道还算不错，但我感觉早上吃这个不如煎饼果子（笑）。友人的评价是：还没吃完就累死了。总之是新奇体验，而且并不难吃。</p><h3 id="拉面">拉面</h3><p>我们去的这家拉面叫<a href="https://maps.app.goo.gl/LWFkAC31pu1DWNcB8">麺屋龍</a>，是一个非常小的拉面小馆，里面只有六个座位，刚好坐下我们六个人。日本的这种小馆一般都是在门口的自动售货机点餐，然后给你出3张票，分别是你点的餐、小票和收据，你进去以后把你点的菜的那张票交给店员，然后他就开始给你做饭了。<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160045058.png" alt="小票和收据" /></p><p>我要在这里说我对日本的第三个<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="按时间顺序是第二个，按行文顺序则是第三个。">[2]</span></a></sup>刻板印象了：<strong>日本人特别喜欢喝苹果汁</strong>，苹果汁在日本的普及程度就像橙汁在中国的普及程度一样。自动贩卖机里有苹果汁，饭店的饮料里还有苹果汁，而且还挺好喝。在国内，默认提供苹果汁的地方我只见过一个，那就是飞机上。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160049380.png" alt="「浓厚龙拉面」和苹果汁" /><figcaption aria-hidden="true">「浓厚龙拉面」和苹果汁</figcaption></figure><p>拉面不错，真的很浓厚。友人点了个定食，内容是拉面一碗，炸鸡块三个，米饭一小碗。可能这就是传说中的<a href="https://music.163.com/song?id=22803904">「米饭是菜」</a>吧。</p><h3 id="久美子同款萨莉亚">久美子同款萨莉亚</h3><p>萨莉亚就是萨莉亚嘛，不过这次是萨莉亚老家的萨莉亚。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160103563.png" alt="萨莉亚" /><figcaption aria-hidden="true">萨莉亚</figcaption></figure><p>友人点了久石奏同款多利亚饭，我点了日本特色牛肉汉堡肉。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160107127.png" alt="久石奏的多利亚饭" /><figcaption aria-hidden="true">久石奏的多利亚饭</figcaption></figure><p>日本萨莉亚还有很多北京没有的东西，我印象最深的是汉堡肉、凉拌莴笋和冰激凌夹面包，都很好吃。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407161114951.png" alt="日本萨莉亚菜单，看看有多少是北京没有的？" /><figcaption aria-hidden="true">日本萨莉亚菜单，看看有多少是北京没有的？</figcaption></figure><p>别苦着脸了，来喝一杯吧！今天最高兴了！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407160112116.png" alt="干杯！" /><figcaption aria-hidden="true">干杯！</figcaption></figure><p>7月3日的游记就到这里，7月4日我们去了伏见和京都。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>至于为什么九点多就逛完了呢，哈哈哈，你猜 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>按时间顺序是第二个，按行文顺序则是第三个。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>虽然都是京吹三的，众所周知京吹三是...... <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·贰：7月2日大阪之旅</title>
    <link href="/2024/07/13/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E8%B4%B0%EF%BC%9A7%E6%9C%882%E6%97%A5%E5%A4%A7%E9%98%AA%E4%B9%8B%E6%97%85/"/>
    <url>/2024/07/13/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E8%B4%B0%EF%BC%9A7%E6%9C%882%E6%97%A5%E5%A4%A7%E9%98%AA%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>今天来写一下大阪的旅途。这是这次大阪旅途的路线：</p><p><a href="https://www.google.com/maps/d/edit?mid=1zMXT9xAecBmcscrZrtbjS7NX78mgydI&amp;usp=sharing">Day 1 大阪路线图</a></p><p>因为我们都是一伙二刺螈，也没什么特别的购物欲望，所以大阪并不是此次行程的重点，也只转了几个特别著名的景点。总的来说，这次大阪之旅分为三部分：从机场到酒店，大阪城（天守阁），以及通天阁周边City Walk。</p><p>[toc]</p><h2 id="景点">景点</h2><h3 id="从机场到酒店">从机场到酒店</h3><p>在关西国际机场落地以后，要先坐一个电车，它大概长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090853383.png" alt="机场的电车" /><figcaption aria-hidden="true">机场的电车</figcaption></figure><p>顺带一提，里面还有神奇支付宝广告：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090854272.png" alt="电车里的支付宝广告" /><figcaption aria-hidden="true">电车里的支付宝广告</figcaption></figure><p>通过电车到了这个本馆以后，就是先过海关，然后取行李。过海关时，日本的工作人员会给你的护照上贴一个「上陆许可」的贴纸，有这个就说明你顺利过关了。取完行李出大门，迎面就有很多租随身WiFi和卖日本流量卡的摊子，如果你在国内没有买，那么在这里买就好了。买完以后坐电梯上二楼右转，就到了电车站。此时你的右面应该会有一个写着「南海电车」的牌子，左边有巨幅铁路路线图以及很多机器，你可以在这些机器上办一张ICOCA卡。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090854640.png" alt="办理ICOCA卡" /><figcaption aria-hidden="true">办理ICOCA卡</figcaption></figure><p>办完卡以后，进那个写着「南海电车」的车站，就能坐车了。本来，我们计划的是坐南海特急或者HARUKA，但是因为刚来不知道咋坐电车，就问了一下工作人员，他说能到我们的目的地，于是就上车了。后来看了一下，我们坐的车应该是南海机场急行，在天下茶屋换乘堺筋线，不过刚好省钱了，不错。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090854253.png" alt="电车外景" /><figcaption aria-hidden="true">电车外景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090854043.png" alt="电车广告" /><figcaption aria-hidden="true">电车广告</figcaption></figure><p>说起这个电车广告，我就要说我对日本的第一印象了：<strong>电车上有很多大学和补课班的广告！</strong>我是很难想象你航在地铁上打广告的。不过也没准，不是有「二三本的好出路，校本部上课，军事化管理」吗？</p><p>但是就我对这些广告的第一印象来看，设计感很足，完全没有那种廉价感，导致这些大学看起来还不错的样子，至少看起来比你航高一个档次吧。如果不信的话，我就再放张图，这是地铁站里的：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090854963.png" alt="地铁站里也有大学广告！" /><figcaption aria-hidden="true">地铁站里也有大学广告！</figcaption></figure><p>这是我们坐的电车的内饰，应该是堺筋线的，特别高级，又绒又软，还以为进入了什么收费车厢。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855056.png" alt="电车的内饰" /><figcaption aria-hidden="true">电车的内饰</figcaption></figure><p>到酒店办完入住，又歇了一个小时左右，我们就准备出发了。</p><h3 id="大阪城公园">大阪城公园</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855939.png" alt="大阪城公园游览路线" /><figcaption aria-hidden="true">大阪城公园游览路线</figcaption></figure><p>大阪城公园是一个很开放的公园，并没有围墙，什么人都可以进，只有进天守阁里面是要收费的，因为我们大多对日本战国历史没有啥兴趣，所以就没进去。大阪城只是从外面看看也是很好看的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855773.png" alt="大阪城天守阁外景" /><figcaption aria-hidden="true">大阪城天守阁外景</figcaption></figure><p>这个地方还是名侦探柯南，以及原神（？）的圣地巡礼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855939.png" alt="另一个角度的天守阁" /><figcaption aria-hidden="true">另一个角度的天守阁</figcaption></figure><p>抛开天守阁不谈，这个公园就是一个普通的，景色还算不错的公园。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855762.png" alt="大概是护城河" /><figcaption aria-hidden="true">大概是护城河</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855165.png" alt="七夕短册" /><figcaption aria-hidden="true">七夕短册</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855826.png" alt="你航同款禁飞无人机" /><figcaption aria-hidden="true">你航同款禁飞无人机</figcaption></figure><p>我们从谷町四丁目出来，到进JR大阪城公园站，大概是85分钟左右。其实逛得很悠闲，中间还和自动贩卖机斗智斗勇了一会儿。</p><h3 id="通天阁周边-city-walk">通天阁周边 City Walk</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855382.png" alt="大阪环状线" /><figcaption aria-hidden="true">大阪环状线</figcaption></figure><p>从JR大阪城公园乘坐大版环状线到新今宫下车，就到通天阁了。这个通天阁是一个富有上世纪八九十年代风格的街区，有一种赛博朋克的感觉。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855789.png" alt="通天阁附近街景其一" /><figcaption aria-hidden="true">通天阁附近街景其一</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855893.png" alt="通天阁附近街景其二" /><figcaption aria-hidden="true">通天阁附近街景其二</figcaption></figure><p>这里面有很多吃饭的地方。在这里简单吃了顿饭以后，我们就徒步回酒店了，并且打算途中路过心斋桥、道顿堀等地，也就是「City Walk」。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855768.png" alt="逛街路线" /><figcaption aria-hidden="true">逛街路线</figcaption></figure><p>谷歌地图给我们导航了一条人迹罕至的小路，我们也得以一窥大阪静谧的一面，也不失为一种体验。但是还是要吐槽一下，谷歌地图总是给我们导航这种小路，以至于后来我们都觉得它是「将军走此小道」了。我放点有趣的照片吧。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090855575.png" alt="雀庄。一桌一小时1000日元，真便宜，里面是四口机" /><figcaption aria-hidden="true">雀庄。一桌一小时1000日元，真便宜，里面是四口机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090856193.png" alt="大阪小毛米" /><figcaption aria-hidden="true">大阪小毛米</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090856292.png" alt="长快门拍的车流" /><figcaption aria-hidden="true">长快门拍的车流</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090857830.png" alt="写字楼与列车。听说Key社新址就在附近？" /><figcaption aria-hidden="true">写字楼与列车。听说Key社新址就在附近？</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090857013.png" alt="普普通通的街景。日本房子特别喜欢在这个对着路口的地方倒个角" /><figcaption aria-hidden="true">普普通通的街景。日本房子特别喜欢在这个对着路口的地方倒个角</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090857154.png" alt="居酒屋和自行车" /><figcaption aria-hidden="true">居酒屋和自行车</figcaption></figure><p>我们就沿着这个不太亮，也不太有人的小路一直走，一路上畅聊，感觉很放松。同行的朋友还买了个苹果糖。我感觉苹果糖的原理和冰糖葫芦一样，不过它是一整个苹果外面裹糖，所以比较坚硬，吃起来有点困难，万幸味道还算不错（毕竟就是苹果......）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090857014.png" alt="苹果糖" /><figcaption aria-hidden="true">苹果糖</figcaption></figure><p>转着转着就到道顿堀了，人流量哗啦一下从没几个人变成一亿个人，快吓死我了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090857730.png" alt="很有名的广告牌，和一亿个人" /><figcaption aria-hidden="true">很有名的广告牌，和一亿个人</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090857752.png" alt="道顿堀川，很好看吧" /><figcaption aria-hidden="true">道顿堀川，很好看吧</figcaption></figure><p>今天的旅程就到这里，因为我们的酒店就在道顿堀旁边，所以就直接回去了。</p><h2 id="餐饮">餐饮</h2><p>今天总共吃了两顿饭。第一顿是在飞机上吃的，什么鸡肉米饭牛肉面，都挺难吃的（比回国的飞机餐差远了）。</p><p>晚饭是在那个通天阁街区里面吃的，随便选了一家，主要是炸物。炸的东西怎么会难吃呢？所以我感觉还行，但是总有一种外地人来回民街吃饭的感觉。对此我的评价是：旅游怎么能不花钱呢（）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132339270.png" alt="炸鸡块，汁水很多" /><figcaption aria-hidden="true">炸鸡块，汁水很多</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132339500.png" alt="大阪烧，感觉是西葫芦糊塌子+沙拉酱" /><figcaption aria-hidden="true">大阪烧，感觉是西葫芦糊塌子+沙拉酱</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407142125937.png" alt="炸串，近处的是猪排，远处的是牛肉和葱" /><figcaption aria-hidden="true">炸串，近处的是猪排，远处的是牛肉和葱</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132340072.png" alt="可乐饼，极好吃，评价为MVP" /><figcaption aria-hidden="true">可乐饼，极好吃，评价为MVP</figcaption></figure><p>这一顿人均108RMB，感觉还是贵了，可能景区就是这样的吧，哈哈...</p><h2 id="住宿">住宿</h2><p>我们在大阪住的这个酒店名叫 <a href="https://maps.app.goo.gl/ahdjTP6SZxprhkAAA">Yamatoya honten</a> ，我对这个酒店非常的满意。因为：</p><ol type="1"><li><p>我们订了一个6人间和洋室套间，其实是2张西式床+4人间和室，和室作为新奇体验也不错，而且睡起来也很舒服。酒店里面有冰箱，可以冰带来的饮料，也有WiFi，会提供毛巾浴巾和日式浴衣。一个套间有一个浴室和一个卫生间。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202408090858795.png" alt="和室，摄影师是朋友" /><figcaption aria-hidden="true">和室，摄影师是朋友</figcaption></figure></li><li><p>负一楼有个澡堂子，可以泡澡，虽然不是特别大，但是我们每次去基本都包场，还挺舒服的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407132353238.png" alt="澡堂子里面的礼仪规范" /><figcaption aria-hidden="true">澡堂子里面的礼仪规范</figcaption></figure></li><li><p>离地铁站特别近，去和回都很方便。</p></li><li><p>酒店前台有会说中文的工作人员。</p></li><li><p>300多块钱/人/晚，价格还算可以。</p></li></ol><p>这看起来真的很像打广告，但我真没收钱......</p><p>那么第一天就到这里，我们的下一站是奈良+宇治。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·I：日本公共交通特辑</title>
    <link href="/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7I%EF%BC%9A%E6%97%A5%E6%9C%AC%E5%85%AC%E5%85%B1%E4%BA%A4%E9%80%9A%E7%89%B9%E8%BE%91/"/>
    <url>/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7I%EF%BC%9A%E6%97%A5%E6%9C%AC%E5%85%AC%E5%85%B1%E4%BA%A4%E9%80%9A%E7%89%B9%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>在<a href="https://blog.sakizuki.site/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E5%A3%B9%EF%BC%9A%E5%89%8D%E8%A8%80%E5%92%8C%E7%AE%80%E7%9F%ADfaq/#%E6%97%A5%E6%9C%AC%E7%9A%84%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF%E5%9B%BE%E5%A4%AA%E5%A4%8D%E6%9D%82%E7%9C%8B%E4%B8%8D%E6%87%82%E6%80%8E%E4%B9%88%E5%9D%90%E5%95%8A">《秋月的霓虹旅行杂记·壹：前言和简短FAQ》</a>中，我简单提了一下在日本怎么坐地铁：跟着谷歌地图走就好了。今天，我想介绍一下日本这个地铁究竟是怎么回事，最重要的原因是我觉得它很好玩，同时，也能解答你在观看谷歌地图所给的路线时的一些疑问。当然，我不是资深的铁路爱好者，所以下文都是我的个人观点，可能不是特别严谨，如果有错漏，还请斧正。</p><h2 id="铁路">铁路</h2><p>日本的铁路产业极其发达，而且大部分都是私营，我们日常看到的「JR线」、「京阪线」、「阪急线」、「阪神线」，就是隶属于不同公司的铁路路线，可以类比于「东方航空」、「南方航空」、「中国国际航空」。由于铁路产业的发达，铁路也不局限于地下铁，经常会有在地面上运行的铁路，和汽车、自行车一起穿梭在城市地表，构成了独具特色的日本铁路景观。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121146403.png" alt="京阪电车行驶在伏见稻荷" /><figcaption aria-hidden="true">京阪电车行驶在伏见稻荷</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121147465.png" alt="箱根登山铁道" /><figcaption aria-hidden="true">箱根登山铁道</figcaption></figure><p>在我看来，如果你想搞明白日本的地铁，需要把握住以下关键点。</p><h3 id="线路的表达">线路的表达</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121250849.png" alt="阪急神户线" /><figcaption aria-hidden="true">阪急神户线</figcaption></figure><p>请看列车时刻表。「HK」、棕黑色和「阪急神户线」，共同表达了列车所属的线路，类比于国内的「地铁四号线」。「神户三宫/西宫北口方面」表达了列车运行的方向，左边的时间表达了列车的开车时间，中间的站名表达了列车的目的地（可以看到，神户三宫方面的车并不总是会到神户三宫的），右边的「各站停车」，「特急」等表达了列车的速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121252377.png" alt="列车车厢" /><figcaption aria-hidden="true">列车车厢</figcaption></figure><p>在列车的车厢上，会标明速度「特急」和目的地「新开地」。</p><p>如果你时间赶得特别紧，急匆匆地找到<strong>正确的站台</strong>，发现上面正停着一辆车！怎么快速判断自己要不要上车呢？就看这个速度和目的地，如果都对了，那大概率就是这个了，然后你可以先上车，然后在车里面的LED屏幕上看这列车在自己要去的地方停不停。</p><h3 id="铁路通勤化">铁路通勤化</h3><p>为什么我在之前那篇文章里说</p><blockquote><p>在本段中，为照顾国人的日常习惯，「地铁」指的是「铁路」，也就是说，不区分地下铁、市郊铁路、城际铁路等，而将这种「跑在铁路上，不用提前买票，只用刷公交卡进闸机，在站台上站着等，车来了就上」的交通工具统称为地铁。</p></blockquote><p>呢？因为其实在日本，符合「跑在铁路上，不用提前买票，只用刷公交卡进闸机，在站台上站着等，车来了就上」的不仅仅有「地下铁」，还有各种市郊铁路、城际铁路。为表严谨，以下将这样的公共交通工具称为「铁路」，和真的需要像国内一样额外买票的「新干线」进行区分。</p><p>这是什么意思呢？比如说在国内你想从北京去天津玩，那么你需要先坐北京地铁到北京南站，然后出站，在12306买北京南站到天津的火车票，上二楼刷身份证进火车站，上火车，到天津。但是如果你在大阪的市中心日本桥站，想去奈良玩，谷歌地图告诉你：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121151813.png" alt="日本桥到奈良的路线" /><figcaption aria-hidden="true">日本桥到奈良的路线</figcaption></figure><p>你只需要用公交卡刷进地铁站，站在站台上等着，上这个「近铁奈良线」，就能直接到奈良了。事实上，除非你要进行从大阪到东京这种超长距离的移动，一般都是直接像坐地铁一样坐城际/市郊铁路。</p><p>请再看一下这条从近铁日本桥前往西宫北口的路线：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121154786.png" alt="近铁日本桥前往西宫北口" /><figcaption aria-hidden="true">近铁日本桥前往西宫北口</figcaption></figure><p>其中，红色的「御堂筋线」就是大阪的「地下铁」，而棕黑色的「阪急神户线特急」，就像国内的市郊铁路，但是你在大阪梅田换乘时仍然只需要像地铁换乘一样刷卡进站然后在站台上等着，无需先去12306上额外购买市郊铁路的车票，再去候车室坐着，然后等车来了再去站台上上车。</p><p>或许也是因为通勤化，日本的铁路站台很多时候也是景点本身，它会和购物中心深度融合，比如大阪难波站、京都站和大阪梅田站，我已经不好说是车站里有个购物中心还是购物中心里有个车站了。即使是比较小的车站，比如宇治站、伏见稻荷站和奈良站，也很有当地特色：比如宇治站有京吹周边，伏见稻荷站有红木鸟居和小狐狸。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121204995.png" alt="京阪宇治站" /><figcaption aria-hidden="true">京阪宇治站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121204960.png" alt="伏见稻荷站" /><figcaption aria-hidden="true">伏见稻荷站</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121205543.png" alt="三宫站购物中心？购物中心三宫站？" /><figcaption aria-hidden="true">三宫站购物中心？购物中心三宫站？</figcaption></figure><h3 id="站台车和目的地">站台、车和目的地</h3><p>在国内乘坐地铁时，假如说你想从西直门坐四号线去圆明园吧，往往「四号线经过西直门」、「西直门有四号线站台」、「四号线前往圆明园」是不言自明的公理，大家可能都习以为常了，也就是说我在西直门站一定能找到四号线站台，在四号线站台上等来的车一定是四号线，我上了四号线就一定能到圆明园。</p><p>但是，在日本的这三个「一定」<strong>全不成立</strong>。</p><h4 id="在西直门站一定能找到四号线站台no">在西直门站一定能找到四号线站台？NO！</h4><p>在日本，存在很多名字相近，但是并不相连的铁路站，以奈良站为例，存在「JR奈良站」和「近铁奈良站」两个完全不相干的铁路站，甚至中间有10分钟车程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121214753.png" alt="JR奈良站和近铁奈良站" /><figcaption aria-hidden="true">JR奈良站和近铁奈良站</figcaption></figure><p>如果你想坐JR的奈良线而在近铁奈良站寻找站台，那么是掘地三尺也找不到的，你必须先做公交车前往JR奈良站。</p><h4 id="在四号线站台上等来的一定是四号线no">在四号线站台上等来的一定是四号线？NO！</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407120014995.jpeg" alt="横滨站2号站台" /><figcaption aria-hidden="true">横滨站2号站台</figcaption></figure><p>请看横滨站2号站台的大屏幕，可以看到有四种车都在这个站台停靠，所以如果你到了正确的站台，但是随便上了个车，本来要去羽田机场的你可能就被发送到高砂了。</p><h4 id="上了四号线就一定能到圆明园no">上了四号线就一定能到圆明园？NO！</h4><p>现在假如你走对了车站，走对了站台，上对了线路，是不是就高枕无忧了？不是！请看从中书岛站发出的京阪本线列车的时刻表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121237955.png" alt="京阪本线时刻表" /><figcaption aria-hidden="true">京阪本线时刻表</figcaption></figure><p>这个后面的「快速急行」、「准急」和「特急」是什么呢？它是这列列车的速度。尽管所有列车使用的都是一样的车厢，跑在一样的铁路上，但是它们的速度仍然有区别，而实现这种区别的方法就是甩站。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121232786.png" alt="特急与准急" /><figcaption aria-hidden="true">特急与准急</figcaption></figure><p>假如你想去守口市，但是上了特急，那么你只能看着列车以特急的速度正线通过你本来要下车的守口市咯。但是两列列车从中书岛出发只间隔了3分钟，而抵达淀屋桥的时间就差了20分钟。</p><p>一般来说，这种通过甩站实现的特急是不需要额外花钱的。有两种情况下你需要额外为乘坐特急付费，第一是你坐了「收费特急」（而不是「特急」），第二是你坐了「特急」的指定席或者贵宾席。在京阪本线上，指定席是6号车厢。</p><h3 id="一些离谱的换乘">一些离谱的换乘</h3><h4 id="无需换乘">无需换乘</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121730778.png" alt="无需换乘" /><figcaption aria-hidden="true">无需换乘</figcaption></figure><p>这是从京都河源町到近铁日本桥的路线。在天下茶屋站，所乘坐的线路从「阪急千里线」变成了「堺筋线」，但是地图提示「继续乘坐同一辆车」或者「无需换乘」。这时，你只需要继续坐在列车上不要动，你就会发现列车自己从阪急千里线变成了堺筋线。这是因为这两条线路共用一台列车。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407130931006.png" alt="如果不小心在大阪环状线上睡着，可能就要被发送到五条了吧" /><figcaption aria-hidden="true">如果不小心在大阪环状线上睡着，可能就要被发送到五条了吧</figcaption></figure><h4 id="同线换乘">同线换乘</h4><p>在从近铁日本桥前往伏见稻荷时，首先坐堺筋线到北滨，然后坐京阪本线特急，在丹波桥下车后换乘京阪本线准急。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121736032.png" alt="同线换乘" /><figcaption aria-hidden="true">同线换乘</figcaption></figure><p>同样都是坐京阪本线，为什么还要换乘呢？这是因为这两列车的速度不一样，特急车不在伏见稻荷停车，所以如果要去伏见稻荷，只能坐准急。因此，谷歌地图推荐你先坐很快的特急，然后换乘准急抵达终点。</p><h2 id="新干线">新干线</h2><p>新干线也就是日本的「高铁」了。和国内一样，它不能通过刷公交卡出入，需要单独买票。当你在售票机上买票时，它会问你买自由席还是指定席，这个看心情就好，指定席会贵点但是自由席一般也有座。重点是它还会问你是只买特急券，还是同时买乘车券和特急券，这时候一定要选两个都买。然后，机器会给你吐出来两张票（每人）：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121523959.png" alt="乘车券（左）和特急券（右）" /><figcaption aria-hidden="true">乘车券（左）和特急券（右）</figcaption></figure><p>当然，也有乘车券和特急券合并在一张纸上的：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121455271.png" alt="乘车券·新干线特急券" /><figcaption aria-hidden="true">乘车券·新干线特急券</figcaption></figure><p>乘车券的意思是你要移动这么长的距离要付出的基本费用，因为其实你如果不坐新干线，只是通过不断地换乘铁路，也是能从大阪抵达东京的。而特急券则是你为了新干线的高速而付出的增值费用。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407130928626.png" alt="换乘铁路从大阪到东京" /><figcaption aria-hidden="true">换乘铁路从大阪到东京</figcaption></figure><p>在进站时，你需要<strong>同时把乘车券和特急券塞进闸机，票会在闸机出口弹出来，务必保管好这两张票。如果丢了，你就得重买一张，日本人是这样的，给他看什么付款记录都是没有用的。</strong></p><p>进站之后的过程就和国内高铁差不多了。怎么看面前的车是不是自己能上的呢？看第一张图右边的特急券，上面写着「のぞみ２０６号」，这个就是你要坐的车号了。</p><p>当到了地方要出站时，一般会有两道闸机，这是因为日本的高铁站都是在地铁站里面的。出站时，在第一道闸机，你需要投入特急券；在第二道闸机，你需要投入乘车券。这样就完成了出站。这里投入以后，票不会再被弹出来，就没有了。</p><p>不同于国内高铁的地方在于，你基本不用因为担心票卖完了而提前很久买票，当天在车站的机器上买，大部分情况下都是能买到的。如果你错过了指定席的车次，你也可以坐下一班车，但是你的车票就只能视作自由席了。</p><p>如果你想要留着自己的票当个纪念，不想它被出站口的闸机吃掉，那么你可以走人工通道，告诉工作人员「May I have a stamp？I want to keep the ticket as a souvenir.」，然后工作人员就会拿出一个印章盖在你的票上（看第二张票上的那个「无效 海 小田原」），然后打开人工通道的门，你就可以出去了。这个操作同样也适用于铁路、以及马上要讲的缆车和索道。公交车我没尝试过，因为感觉会影响后面的人。</p><h2 id="公交车">公交车</h2><p>日本的大部分公交车都是从后门上前门下的，而且公交车也是按区间收费，因此上下车都需要刷卡。还有一些公交车（多是旅游特化）不按区间收费，而是固定价格，因此只用刷一次卡。当然，也支持现金支付，如果想要用现金支付，需要在上车时领取一个小纸条「整理券」，下车时把它和现金一起扔进箱子里。如果一个人的卡不够了，或者现金不够了，也可以给司机说明情况，让同伴帮他刷卡/付钱。</p><p>在下车前你需要按一下车上的铃，不如司机很有可能就甩站了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121616442.png" alt="下车铃" /><figcaption aria-hidden="true">下车铃</figcaption></figure><h2 id="缆车和索道">缆车和索道</h2><p>我们这次行程安排了两次上山，分别是神户的摩耶山和箱根的芦之湖，而且都安排了乘坐缆车和索道。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121519313.png" alt="缆车 Cable Car 忘拍照了Orz" /><figcaption aria-hidden="true">缆车 Cable Car 忘拍照了Orz</figcaption></figure><p>缆车长得和电车一样，但是它斜率很大，整个车厢都是斜的，里面有台阶。缆车也走在铁道上，但是是由线缆提供动力的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121520729.png" alt="索道 Rope Way" /><figcaption aria-hidden="true">索道 Rope Way</figcaption></figure><p>索道也是由线缆提供动力的，但是它整个是悬空的。</p><p>缆车和索道一般都不能刷公交卡，需要自己买票。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121525087.png" alt="摩耶山缆车+索道往返套票，箱根缆车和索道的单程票" /><figcaption aria-hidden="true">摩耶山缆车+索道往返套票，箱根缆车和索道的单程票</figcaption></figure><h2 id="jr-pass一日通票和公交卡">JR Pass、一日通票和公交卡</h2><p>首先来说JR Pass：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121527471.avif" alt="JRPass" /><figcaption aria-hidden="true">JRPass</figcaption></figure><p>这是JR Pass可以用到的路线。其实也就是JR公司负责运营的公共交通。可以看出其实如果<strong>你是在关东（东京）玩得比较多，或者涉及到很多长途往返要坐新干线，那么JR Pass是比较值的。</strong>但是我们这次在关西待4天，在关东只待3天，而且只进行一次新干线长途，所以就没有买JR Pass。</p><p>然后说说一日通票：</p><p>一日通票其实就相当于地区里的小型Pass，就是某地方的几日内随意乘坐当地列车的通票，比如东京地铁三日券<strong>，</strong>江之岛一日券<strong>，</strong>京都一日券等，如果在某地当天需要反复乘坐某列车，可以考虑购买日券更省钱。但是买的时候也要看清运营公司，很有可能你买了东京的都营地铁一日券，但是一整天都没坐一次都营的地铁，那就亏麻了。</p><p>最后说下交通卡：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121538845.png" alt="ICOCA卡，在日本带了一周，最后在回国的飞机上弄丢了，太遗憾了" /><figcaption aria-hidden="true">ICOCA卡，在日本带了一周，最后在回国的飞机上弄丢了，太遗憾了</figcaption></figure><p>因为我们这次是在关西机场着陆的，所以办的是ICOCA卡。虽然是在关西办的，但是在东京箱根也都可以用。你在机场着陆以后，找到机场的车站（写着巨幅NANKAI招牌），往左边看，就能看到很多办卡的机器了。机器支持简体中文，你调成简体中文以后他让你干啥你干啥就行。买卡和充钱只支持现金。这个公交卡除了坐新干线和缆车索道，其它地方，例如铁路、公交车等，基本都可以用，有些自动贩卖机和便利店也能用，可以说是非常方便了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋月的霓虹旅行杂记·壹：前言和简短FAQ</title>
    <link href="/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E5%A3%B9%EF%BC%9A%E5%89%8D%E8%A8%80%E5%92%8C%E7%AE%80%E7%9F%ADFAQ/"/>
    <url>/2024/07/12/%E7%A7%8B%E6%9C%88%E7%9A%84%E9%9C%93%E8%99%B9%E6%97%85%E8%A1%8C%E6%9D%82%E8%AE%B0%C2%B7%E5%A3%B9%EF%BC%9A%E5%89%8D%E8%A8%80%E5%92%8C%E7%AE%80%E7%9F%ADFAQ/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>2024年7月2日~7月9日，我和其余5位朋友们进行了一次毕业旅行，目的地是日本，具体来说，游览了天津→大阪→奈良→宇治→京都→西宫→神户→东京→箱根。</p><p>准备旅行，以及旅行本身，都是非常有意思的事情，因此我决定写一写这个栏目，主要目的是记录一下自己的快乐时光，次要目的是为其他想要来日本自由行的同志们提供一些参考。首先，咱们来聊聊提到「日本自由行」大家可能最关心的几个问题。这些问题都是我在做准备的时候比较关心，或者看其他人提到得比较多的，在本篇博客里，我会做一个简短的回答。</p><p>在回答完这些问题以后，我打算按照时间顺序整理一下本次旅行的情况，介绍每一天去过的各个景点和吃过的各项食物，然后就一些我觉得有意思的事情整理出一些特辑，敬请期待。</p><h2 id="去日本对语言的要求高不高">去日本对语言的要求高不高？</h2><p>如果只是对于旅游一两周的日常生活，不高，基本只需要散装英语+看二次元看的日语+肢体语言，就可以完成生活中的大部分事项了。具体一点的情况是：</p><ol type="1"><li>日语里面有汉字，你可以根据汉字猜测一些句子的意思，大多数地铁站的名字也都是汉字。</li><li>一多半标识牌都有日、中、韩、英四种语言。</li><li>大部分大地铁站/景点的咨询处（案内，information）都有中文服务，大部分的景点的导览图有简体中文版。</li><li>小部分便利店有懂中文的店员，即使没有也可以使用「this one」，「no bag」等简单英语交流。</li><li>实在不行的话，大部分日本的店员都很理解并支持你使用谷歌翻译来交流。日本人的英语水平并不显著普遍地比中国人强，基本也都是散装的。当你感觉对面在说奇怪的英语时，请他直接对着语音翻译说日语就好了。</li></ol><p>当然，不是说日语是不需要的，只是说即使不会也能活着。如果有一个略懂一点日语的朋友，会让你的旅途的各项工作方便不少。</p><h2 id="在日本怎么花钱花多少钱">在日本怎么花钱，花多少钱?</h2><blockquote><p>在本段中，所有货币单位，若未经特殊声明，均是人民币。</p></blockquote><p>去日本当然要狠狠扫二次元谷子，除此之外，交通、饮食等也要花钱。在日本的消费，主要是通过纸币、信用卡、银联卡和微信支付宝二维码进行的。如果你的旅程时间在7~14天左右，并且还想买点二次元谷子，推荐每人最好准备至少15000元的总预算。</p><p>关于纸币的用量：我们这次6个人总共携带了20万日元纸币，紧巴巴勉强够用，可以参考。</p><p>在日本，绝大多数的便利店、一大半的贩卖机、一大半的旅店、大多数的大型二次元谷子店都支持微信二维码；新干线的买票机器支持信用卡；一小部分的地方支持银联卡；所有地方都支持实体现金。</p><p>在乘坐公共交通工具时，推荐使用ICOCA卡（实体版用现金购买充值）或者西瓜卡（实体版同上，苹果手机可用NFC版）。在关西机场的车站旁边就有机器卖ICOCA卡。说起这个交通IC卡，其实很多日常消费，比如贩卖机便利店等都可以刷它，它其实有点像大学里面的校园卡。</p><p>除去机酒以外日常消费的情况，一顿普通的正餐是40-60元，自动贩卖机里一瓶饮料是6-8元，便利店里的面包是13元左右，坐一天电车如果行程比较长的话是100多元。</p><h2 id="日本的地铁线路图太复杂看不懂怎么坐啊">日本的地铁线路图太复杂看不懂，怎么坐啊？</h2><blockquote><p>在本段中，为照顾国人的日常习惯，「地铁」指的是「电车」，也就是说，不区分地下铁、近铁线、京阪线等，而将这种「跑在铁路上，不用提前买票，只用刷公交卡进闸机，在站台上站着等，车来了就上」的交通工具统称为地铁。</p></blockquote><p>极简版究极省流回答：</p><p>下载APP《Google 地图》和《换乘案内》，选好出发地、目的地和<strong>出发时间</strong>，然后严格按照它给你的方案走。（其实，我们主要只用了谷歌地图，几乎没用到换乘案内）</p><p>这个「严格」需要解释一下：你需要确保线路的出发站台、<strong>颜色</strong>、名称、<strong>终点站</strong>、<strong>速度</strong>（普通、准急、急行、特急）、<strong>出发时间</strong>，都和地图所给的方案完全一样。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407120014634.jpeg" alt="一个典型的谷歌地图方案（节选），其中，出发站台是横滨站2号站台，颜色是淡蓝色，线路名称是「KK京急本线」，终点站是羽田机场，速度是急行，出发时间是13：18" /><figcaption aria-hidden="true">一个典型的谷歌地图方案（节选），其中，出发站台是横滨站2号站台，颜色是淡蓝色，线路名称是「KK京急本线」，终点站是羽田机场，速度是急行，出发时间是13：18</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407120014995.jpeg" alt="一个典型的日本地铁站台（横滨站2号站台），这四趟车会依次在 同一个 站台进站，请注意从上往下数的第三条信息和上面所给的条件吻合，所以你需要上第三趟车，如果上前两趟车就寄了。" /><figcaption aria-hidden="true">一个典型的日本地铁站台（横滨站2号站台），这四趟车会依次在 <strong>同一个</strong> 站台进站，请注意从上往下数的第三条信息和上面所给的条件吻合，所以你需要上第三趟车，如果上前两趟车就寄了。</figcaption></figure><p>好了，看到这里，如果你能记住上面的那句话，你在日本坐地铁就没问题了。</p><p>如果想坐公交车，日本的大部分公交车都是从后门上前门下的，而且公交车也是按区间收费，因此上下车都需要刷卡。还有一些公交车（多是旅游特化）不按区间收费，而是固定价格，因此只用刷一次卡。当然，也支持现金支付，如果想要用现金支付，需要在上车时领取一个小纸条「整理券」，下车时把它和现金一起扔进箱子里。如果一个人的卡不够了，或者现金不够了，也可以给司机说明情况，让同伴帮他刷卡/付钱。</p><p>在下车前你需要按一下车上的铃，不如司机很有可能就甩站了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202407121616442.png" alt="下车铃" /><figcaption aria-hidden="true">下车铃</figcaption></figure><p>除了地铁和公交车以外，我们这次还坐了缆车Cable Car和索道Rope Way。关于日本交通更进一步的说明，我会写一个特辑。</p><h2 id="日本是不是所有餐厅都要预约">日本是不是所有餐厅都要预约？</h2><p>不是的，想吃饭了用tabelog或者Google地图搜一下都能出来很多，我们这次去了7天没有一次的饭是提前预约了的（酒店的除外）。</p><p>比起预约，你更需要注意的是：很多日本餐厅的关门时间非常早，早则下午四点，一般是晚上八点，「开门到23点」是可以作为餐厅的主要优势用巨幅字体写在大广告牌上的。所以如果有喜欢睡懒觉的同志，晚饭很可能吃不上了。</p><h2 id="去日本之前需要下载什么软件">去日本之前需要下载什么软件？</h2><ol type="1"><li><p>Google Map【必须】</p><p>所有的路线规划都可以用它来做，很好用，虽然可能效率不如换乘案内，但是你肯定丢不了。而且也可以在上面找吃的。不用下载离线地图，或者说下了也没用，因为离线地图只支持开车和走路，不支持公共交通。而在日本最主要的出行方式就是公共交通。</p></li><li><p>Google 翻译【必须】</p><p>可以拍照翻译，可以语音翻译，如果不会日语就下一个吧。如果拍照翻译用不了，你需要下载一个最新版的《Google》APP。</p></li><li><p>JapanTransitPlanner（换乘案内）【强推】</p><p>在你对日本的铁路系统有了一个基本的认识以后，它比Google Map好用一点，具体表现为它没那么死板，比如说你要从A经过B抵达C，Google Map很可能只会给你推荐一条从A出发在B换乘C的地铁，但是其实有很多地铁都能从A先到B，那么换乘案内就可以告诉你其实别的车也能上。</p></li><li><p>KLOOK客路旅行【推荐】</p><p>先说好，我没收钱哈。这个是一个用来订票的APP，我这次用它来订了新干线和高松灯同款水族馆Sunshine Aquarium的票，比起日本官网要你填各种信息还必须信用卡支付，这个直接填你国内的姓名手机号然后微信支付就行，和国内预约景点一模一样，而且取票很快，Sunshine Aquarium甚至可以直接进，我觉得很方便。</p></li><li><p>Tabelog 【推荐】</p><p>日本版大众点评，可以结合Google Map找吃的。日本人打分都比较严苛，基本3.1以上的都算是高分了。Google Play国区不能下载，需要自行寻找apk文件。</p></li><li><p>卡余额查询【推荐】</p><p>如果手机有NFC功能，用这个可以查询你的交通卡的消费记录。无论是留作纪念还是看看自己有多花钱如流水，都挺好的。</p></li><li><p>虚拟专网【提醒】</p><p>如果你有强烈的在日本观看B站网易云等国内流媒体的需求，那么请注意：大部分B站网易云买的资源的版权都是仅限中国大陆的，如果你非要看，只能用虚拟专网翻墙翻到中国大陆，就像在大陆翻墙翻到外面一样。不过现在国内的虚拟专网节点越来越难找了，所以我觉得你既然来日本了，就别看那B站了......</p></li></ol><h2 id="去日本之前需要准备哪些物品">去日本之前需要准备哪些物品？</h2><ol type="1"><li><p><strong>药物</strong></p><p>感冒药、止痛药、抗过敏药、抗腹泻药、跌打损伤药，按自己平时的喜好带，这五种品类带全就行。其实日本有很多药店，但是我觉得药还是自己熟悉的最好。</p></li><li><p><strong>护照、日本签证、VJW</strong></p><p>办护照可以直接去出入境大厅办，不用预约（因为每天有几千个名额），工本费120元，你让他邮寄到学校就行了。</p><p>日本签证不能自己办，需要找个旅行社，你可以在淘宝上搜个，我们这次用的是中青旅，还挺靠谱的。对于大学生来说有大学生简化签证，你只需要准备户口卡本人页+首页，护照，学校开具的在读证明、学信网学籍验证报告、证件照、身份证就行了。</p><p>VJW全称叫做Visit Japan Web，链接是：<a href="https://www.vjw.digital.go.jp/main/#/vjwplo001">Visit Japan Web</a>，在去日本前一晚上需要填写一下这个表，然后在日本机场着陆以后，海关会要求你出示VJW的二维码作为过关的依据。其中有一个填酒店地址的环节你可能觉得很麻烦，但是其实只要你把邮编填上，其它信息都会自动识别出来的。</p></li><li><p><strong>电源插座转接头</strong></p><p>日本只有二孔插座（和国内的一样），没有三孔插座，所以如果你有带三孔插头的插线板，需要转一下。另外，日本的电压是110V，但是个人体感影响不是很大，因为手机电脑IPAD的电源适配器都有变压功能。</p></li><li><p><strong>日元现金</strong></p><p>之前提过了，这里再提一下，我们6个人总共20万日元紧巴巴地够用。如果有条件的话可以办张VISA信用卡，要有额度的，而且要实体卡。</p></li><li><p><strong>流量卡</strong></p><p>到了日本国内的电话卡就不能用了（其实能用，国际漫游嘛，就是实在消费不起而且不能用谷歌，只能作为紧急手段），如果想上网需要日本电话卡，这有四种解决方案</p><p>第一是国内买好流量卡带到日本用，优点是买卡的过程很简单，缺点是如果卡质量不太好也没法换。</p><p>第二是在日本的机场买流量卡，优点是如果你试了不好用它可以当场给你换新的。</p><p>第三是整个随身WiFi，优点是便宜而且不限流量，缺点是它很重，而且一个人拿着别人就不能走太远。</p><p>第四是小米的“全球上网”。优点是很方便，缺点是比较贵而且只有小米有。</p><p>日本大多数公共场合以及酒店都有WiFi，所有不用太担心流量限额，一天1GB是差不多够用的。我感觉我在国内买的流量卡是这次旅行中四种解决方案中体感最好的，信号最稳定而且网速最快，品牌是亿点，仅供参考。</p></li><li><p><strong>其它旅行必须品</strong></p><p>防晒霜、雨伞、换洗衣物（我7天带了3套）、扇子、遮阳帽、日元硬币夹等等，按自己喜好带就行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游攻略</tag>
      
      <tag>日本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用matlabAPPDesigner制作软件、调用外部库并打包</title>
    <link href="/2024/04/15/%E7%94%A8matlab%20APP%20designer%E5%88%B6%E4%BD%9C%E8%BD%AF%E4%BB%B6%E3%80%81%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%BA%93%E5%B9%B6%E6%89%93%E5%8C%85/"/>
    <url>/2024/04/15/%E7%94%A8matlab%20APP%20designer%E5%88%B6%E4%BD%9C%E8%BD%AF%E4%BB%B6%E3%80%81%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%BA%93%E5%B9%B6%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>这个事儿很复杂啊，尤其是对于我这种很不会和“环境”打交道的人来说，今天捣鼓了半天终于捣鼓明白了，所以写个文章记录一下。</p><p>所用到的软件有Matlab 2019A和Visual Studio 2022.</p><span id="more"></span><h2 id="编写c语言代码编译为.dll库">编写C语言代码，编译为<code>.dll</code>库</h2><p>在VS2022中新建项目，选择“Windows桌面向导”</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151717267.png" alt="image-20240415171656059" /><figcaption aria-hidden="true">image-20240415171656059</figcaption></figure><p>给项目起个名字，选择“动态链接库”，并选择“空项目”</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151718173.png" alt="image-20240415171819074" /><figcaption aria-hidden="true">image-20240415171819074</figcaption></figure><p>在“源文件”和“头文件”中创建文件</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151719419.png" alt="image-20240415171928365" /><figcaption aria-hidden="true">image-20240415171928365</figcaption></figure><p>两个文件的内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dlltest.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dlltest.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add_dll</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sub_dll</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dlltest.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> __declspec(dllexport) <span class="hljs-built_in">add_dll</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> __declspec(dllexport) <span class="hljs-built_in">sub_dll</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>注意：<code>.h</code>文件必须严格按照上面的格式书写，否则编译完成以后，在 Matlab 中调用时会出现“calllib 找不到方法”的错误。</p><p>这个<code>extern "C"</code>的意思，就是<strong>里面包括的代码只能用C语言的语法</strong>，例如<code>string</code>要用<code>char*</code>，<code>vector</code>要用数组，STL的所有容器都不能直接用，各种对象要用<code>void *</code>来传递，所以本质上还是C语言的动态库。如果一定要用C++，那么得用mex。</p><p>写完代码以后，点击“生成/生成dlltest”</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151721941.png" alt="image-20240415172115882" /><figcaption aria-hidden="true">image-20240415172115882</figcaption></figure><p>在对应路径找到 <code>dlltest.dll</code> 文件</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151721035.png" alt="image-20240415172158982" /><figcaption aria-hidden="true">image-20240415172158982</figcaption></figure><p>然后保存<code>dlltest.dll</code>文件和<code>dlltest.h</code>文件，这是我们未来要使用到的文件。</p><h2 id="编写matlab测试代码调用-.dll-库">编写Matlab测试代码，调用 <code>.dll</code> 库</h2><p>在写Matlab代码之前，先需要完成一些基本的配置，也就是安装<code>mex</code>。</p><p>首先，下载这两个文件<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/m0_51546637/article/details/126325136">[1]</span></a></sup>：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/msvcpp2022.xml">msvcpp2022.xml</a></p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/msvc2022.xml">msvc2022.xml</a></p><p>然后把它放到Matlab的安装目录<code>…\MATLAB\R2019a\bin\win64\mexopts</code>里面。</p><p>在Matlab中运行代码 <code>mex -setup -v</code>，最终看到</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">MEX</span> 配置为使用 <span class="hljs-operator">&#x27;</span><span class="hljs-variable">Microsoft</span> <span class="hljs-variable">Visual</span> <span class="hljs-built_in">C</span><span class="hljs-operator">++</span> <span class="hljs-number">2022</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><span class="hljs-operator">&#x27;</span> 以进行 <span class="hljs-built_in">C</span> 语言编译。<br>警告<span class="hljs-operator">:</span> <span class="hljs-variable">MATLAB</span> <span class="hljs-built_in">C</span> 和 <span class="hljs-variable">Fortran</span> <span class="hljs-variable">API</span> 已更改，现可支持<br> 包含 <span class="hljs-number">2</span><span class="hljs-operator">^</span><span class="hljs-number">32</span><span class="hljs-operator">-</span><span class="hljs-number">1</span> 个以上元素的 <span class="hljs-variable">MATLAB</span> 变量。您需要<br> 更新代码以利用新的 <span class="hljs-variable">API</span>。<br> 您可以在以下网址找到更多的相关信息<span class="hljs-operator">:</span><br> <span class="hljs-variable">https</span><span class="hljs-operator">://</span><span class="hljs-variable">www</span><span class="hljs-operator">.</span><span class="hljs-variable">mathworks</span><span class="hljs-operator">.</span><span class="hljs-variable">com</span><span class="hljs-operator">/</span><span class="hljs-variable">help</span><span class="hljs-operator">/</span><span class="hljs-variable">matlab</span><span class="hljs-operator">/</span><span class="hljs-type">matlab_external</span><span class="hljs-operator">/</span><span class="hljs-variable">upgrading</span><span class="hljs-operator">-</span><span class="hljs-variable">mex</span><span class="hljs-operator">-</span><span class="hljs-variable">files</span><span class="hljs-operator">-</span><span class="hljs-variable">to</span><span class="hljs-operator">-</span><span class="hljs-variable">use</span><span class="hljs-operator">-</span><span class="hljs-number">64</span><span class="hljs-operator">-</span><span class="hljs-variable">bit</span><span class="hljs-operator">-</span><span class="hljs-variable">api</span><span class="hljs-operator">.</span><span class="hljs-variable">html</span>。<br><br>要选择不同的语言，请从以下选项中选择一种命令<span class="hljs-operator">:</span><br> <span class="hljs-variable">mex</span> <span class="hljs-operator">-</span><span class="hljs-variable">setup</span> <span class="hljs-built_in">C</span><span class="hljs-operator">++</span> <br> <span class="hljs-variable">mex</span> <span class="hljs-operator">-</span><span class="hljs-variable">setup</span> <span class="hljs-variable">FORTRAN</span><br></code></pre></td></tr></table></figure><p>就算成功，然后点击 <code>mex -setup C++</code>，就行了。</p><p>新建文件夹，把之前得到的<code>dlltest.dll</code>文件和<code>dlltest.h</code>文件复制进去，然后新建 Matlab 脚本，内容如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">slib_name = <span class="hljs-string">&#x27;dlltest&#x27;</span>; <span class="hljs-comment">%库名，不要加路径和后缀</span><br>shead_name = <span class="hljs-string">&#x27;dlltest.h&#x27;</span>; <span class="hljs-comment">%头文件名</span><br>sfunc_name = <span class="hljs-string">&#x27;add_dll&#x27;</span>; <span class="hljs-comment">%函数名</span><br><span class="hljs-keyword">if</span> not(libisloaded(slib_name)) <span class="hljs-comment">%判断此库是否已经被引用</span><br>    loadlibrary(slib_name, shead_name);<br>    libfunctions(slib_name,<span class="hljs-string">&#x27;-full&#x27;</span>); <span class="hljs-comment">%显示库中的所有函数</span><br><span class="hljs-keyword">end</span><br>a=<span class="hljs-number">1</span>;<br>b=<span class="hljs-number">2</span>;<br><span class="hljs-comment">%calllib函数调用库，使用的方法为：</span><br><span class="hljs-comment">%calllib(库名，头文件名，函数名，函数参数1，函数参数2...)</span><br>calllib(slib_name,sfunc_name,a,b)<br></code></pre></td></tr></table></figure><p>运行脚本，输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">类 lib.dlltest 的方法:<br><br><span class="hljs-built_in">int32</span> add_dll(<span class="hljs-built_in">int32</span>, <span class="hljs-built_in">int32</span>)<br><span class="hljs-built_in">int32</span> sub_dll(<span class="hljs-built_in">int32</span>, <span class="hljs-built_in">int32</span>)<br><br><br><br>ans =<br><br>     <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>说明你已经成功实现在 Matlab 中调用 <code>.dll</code> 库。</p><h2 id="使用app-designer创建软件">使用App designer创建软件</h2><p>首先简单画个UI界面，大概就这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151739714.png" alt="image-20240415173905647" /><figcaption aria-hidden="true">image-20240415173905647</figcaption></figure><p>其中有三个回调函数、一个全局属性需要写，代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%全局属性</span><br><span class="hljs-keyword">properties</span> (Access = private)<br>    slib_name = <span class="hljs-string">&#x27;dlltest&#x27;</span>;<br>    shead_name = <span class="hljs-string">&#x27;dlltest.h&#x27;</span>;<br>    sfuc_add=<span class="hljs-string">&#x27;add_dll&#x27;</span>;<br>    sfuc_sub=<span class="hljs-string">&#x27;sub_dll&#x27;</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%按钮add回调函数</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addButtonPushed</span><span class="hljs-params">(app, event)</span></span><br>     s1=string(app.EditField.Value)<br>     s2=string(app.EditField2.Value)<br>     app.EditField3.Value=double(calllib(app.slib_name,...<br>     app.sfuc_add,str2num(s1),str2num(s2)));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 按钮sub回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subButtonPushed</span><span class="hljs-params">(app, event)</span></span><br>    s1=string(app.EditField.Value)<br>    s2=string(app.EditField2.Value)<br>    app.EditField3.Value=double(calllib(app.slib_name,...<br>    app.sfuc_sub,str2num(s1),str2num(s2)));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 按钮初始化回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ButtonPushed</span><span class="hljs-params">(app, event)</span></span><br>    <span class="hljs-keyword">if</span> not(libisloaded(app.slib_name))<br>        loadlibrary(app.slib_name,app.shead_name);<br>        libfunctions(app.slib_name,<span class="hljs-string">&#x27;-full&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后点运行，应该就可以出现想要的效果了。但是这时候我们打包APP时，发现即使把<code>dlltest.dll</code>文件和<code>dlltest.h</code>文件打包进去了，出来的<code>.exe</code>文件还是没有办法运行。这是因为我们需要修改一下<code>loadlibrary</code>函数的写法。</p><p>退出并重新打开 Matlab ，然后不要进行任何操作，在你的工作文件夹中运行<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://ww2.mathworks.cn/help/compiler/matlab-library-loading.html">[2]</span></a></sup></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">loadlibrary(<span class="hljs-string">&#x27;dlltest&#x27;</span>, <span class="hljs-string">&#x27;dlltest.h&#x27;</span>, <span class="hljs-string">&#x27;mfilename&#x27;</span>, <span class="hljs-string">&#x27;mylibrarymfile&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里面的<code>mfilename</code>是不能调整的，<code>mylibrarymfile</code>是可以自定义的。</p><p>然后你的文件夹中会多出一些文件：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151748213.png" alt="image-20240415174850140" /><figcaption aria-hidden="true">image-20240415174850140</figcaption></figure><p>然后，把你的<code>loadlibrary</code>函数的写法都修改成：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">loadlibrary(app.slib_name, @mylibrarymfile);<br></code></pre></td></tr></table></figure><p>然后，点击共享/独立桌面APP</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151751214.png" alt="image-20240415175120148" /><figcaption aria-hidden="true">image-20240415175120148</figcaption></figure><p>名字什么的自己填，关键是这里：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151752707.png" alt="image-20240415175205628" /><figcaption aria-hidden="true">image-20240415175205628</figcaption></figure><p>在 Files required for your application to run 中，把所有和<code>dlltest</code>有关的文件，以及最后生成的<code>mylibrartmfil.m</code>全部丢进去，然后选择 Create log file 创建日志（日志非必须，只是方便你查错而已）。</p><p>然后选择”Runtime included in package“，检查后点击”Package“。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202404151753448.png" alt="image-20240415175326391" /><figcaption aria-hidden="true">image-20240415175326391</figcaption></figure><p>它会生成一段时间，你可以休息一下。生成完毕后，在<code>\工作文件夹\app1\for_redistribution</code>中找到用于共享的安装包。顺便一提，你可以在 <code>\工作文件夹\app1\for_redistribution_files_only</code> 里面预览安装后的效果。</p><p><strong>附录</strong></p><p>APP Designer的完整代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">classdef</span> app1 &lt; matlab.apps.AppBase<br><br>    <span class="hljs-comment">% Properties that correspond to app components</span><br>    <span class="hljs-keyword">properties</span> (Access = public)<br>        UIFigure         matlab.ui.Figure<br>        EditFieldLabel   matlab.ui.control.Label<br>        EditField        matlab.ui.control.NumericEditField<br>        EditField2Label  matlab.ui.control.Label<br>        EditField2       matlab.ui.control.NumericEditField<br>        addButton        matlab.ui.control.Button<br>        subButton        matlab.ui.control.Button<br>        EditField3Label  matlab.ui.control.Label<br>        EditField3       matlab.ui.control.NumericEditField<br>        Button           matlab.ui.control.Button<br>        addsubLabel      matlab.ui.control.Label<br>    <span class="hljs-keyword">end</span><br><br>    <br>    <span class="hljs-keyword">properties</span> (Access = private)<br>         slib_name = <span class="hljs-string">&#x27;dlltest&#x27;</span>;<br>         shead_name = <span class="hljs-string">&#x27;dlltest.h&#x27;</span>;<br>         sfuc_add=<span class="hljs-string">&#x27;add_dll&#x27;</span>;<br>         sfuc_sub=<span class="hljs-string">&#x27;sub_dll&#x27;</span>;<br>    <span class="hljs-keyword">end</span><br>    <br><br>    <span class="hljs-comment">% Callbacks that handle component events</span><br>    <span class="hljs-keyword">methods</span> (Access = private)<br><br>        <span class="hljs-comment">% Button pushed function: addButton</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addButtonPushed</span><span class="hljs-params">(app, event)</span></span><br>            s1=string(app.EditField.Value)<br>            s2=string(app.EditField2.Value)<br>            app.EditField3.Value=double(calllib(app.slib_name,app.sfuc_add,str2num(s1),str2num(s2)));<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-comment">% Button pushed function: subButton</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subButtonPushed</span><span class="hljs-params">(app, event)</span></span><br>            s1=string(app.EditField.Value)<br>            s2=string(app.EditField2.Value)<br>            app.EditField3.Value=double(calllib(app.slib_name,app.sfuc_sub,str2num(s1),str2num(s2)));<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-comment">% Button pushed function: Button</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ButtonPushed</span><span class="hljs-params">(app, event)</span></span><br>            <span class="hljs-keyword">if</span> not(libisloaded(app.slib_name))<br>                loadlibrary(app.slib_name, @mylibrarymfile);<br>                libfunctions(app.slib_name,<span class="hljs-string">&#x27;-full&#x27;</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">% Component initialization</span><br>    <span class="hljs-keyword">methods</span> (Access = private)<br><br>        <span class="hljs-comment">% Create UIFigure and components</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createComponents</span><span class="hljs-params">(app)</span></span><br><br>            <span class="hljs-comment">% Create UIFigure and hide until all components are created</span><br>            app.UIFigure = uifigure(<span class="hljs-string">&#x27;Visible&#x27;</span>, <span class="hljs-string">&#x27;off&#x27;</span>);<br>            app.UIFigure.Position = [<span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">232</span> <span class="hljs-number">285</span>];<br>            app.UIFigure.Name = <span class="hljs-string">&#x27;UI Figure&#x27;</span>;<br><br>            <span class="hljs-comment">% Create EditFieldLabel</span><br>            app.EditFieldLabel = uilabel(app.UIFigure);<br>            app.EditFieldLabel.HorizontalAlignment = <span class="hljs-string">&#x27;right&#x27;</span>;<br>            app.EditFieldLabel.Position = [<span class="hljs-number">32</span> <span class="hljs-number">175</span> <span class="hljs-number">55</span> <span class="hljs-number">22</span>];<br>            app.EditFieldLabel.Text = <span class="hljs-string">&#x27;Edit Field&#x27;</span>;<br><br>            <span class="hljs-comment">% Create EditField</span><br>            app.EditField = uieditfield(app.UIFigure, <span class="hljs-string">&#x27;numeric&#x27;</span>);<br>            app.EditField.Position = [<span class="hljs-number">102</span> <span class="hljs-number">175</span> <span class="hljs-number">100</span> <span class="hljs-number">22</span>];<br><br>            <span class="hljs-comment">% Create EditField2Label</span><br>            app.EditField2Label = uilabel(app.UIFigure);<br>            app.EditField2Label.HorizontalAlignment = <span class="hljs-string">&#x27;right&#x27;</span>;<br>            app.EditField2Label.Position = [<span class="hljs-number">25</span> <span class="hljs-number">129</span> <span class="hljs-number">62</span> <span class="hljs-number">22</span>];<br>            app.EditField2Label.Text = <span class="hljs-string">&#x27;Edit Field2&#x27;</span>;<br><br>            <span class="hljs-comment">% Create EditField2</span><br>            app.EditField2 = uieditfield(app.UIFigure, <span class="hljs-string">&#x27;numeric&#x27;</span>);<br>            app.EditField2.Position = [<span class="hljs-number">102</span> <span class="hljs-number">129</span> <span class="hljs-number">100</span> <span class="hljs-number">22</span>];<br><br>            <span class="hljs-comment">% Create addButton</span><br>            app.addButton = uibutton(app.UIFigure, <span class="hljs-string">&#x27;push&#x27;</span>);<br>            app.addButton.ButtonPushedFcn = createCallbackFcn(app, @addButtonPushed, <span class="hljs-built_in">true</span>);<br>            app.addButton.Position = [<span class="hljs-number">32</span> <span class="hljs-number">72</span> <span class="hljs-number">71</span> <span class="hljs-number">22</span>];<br>            app.addButton.Text = <span class="hljs-string">&#x27;add&#x27;</span>;<br><br>            <span class="hljs-comment">% Create subButton</span><br>            app.subButton = uibutton(app.UIFigure, <span class="hljs-string">&#x27;push&#x27;</span>);<br>            app.subButton.ButtonPushedFcn = createCallbackFcn(app, @subButtonPushed, <span class="hljs-built_in">true</span>);<br>            app.subButton.Position = [<span class="hljs-number">131</span> <span class="hljs-number">72</span> <span class="hljs-number">71</span> <span class="hljs-number">22</span>];<br>            app.subButton.Text = <span class="hljs-string">&#x27;sub&#x27;</span>;<br><br>            <span class="hljs-comment">% Create EditField3Label</span><br>            app.EditField3Label = uilabel(app.UIFigure);<br>            app.EditField3Label.HorizontalAlignment = <span class="hljs-string">&#x27;right&#x27;</span>;<br>            app.EditField3Label.Position = [<span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">62</span> <span class="hljs-number">22</span>];<br>            app.EditField3Label.Text = <span class="hljs-string">&#x27;Edit Field3&#x27;</span>;<br><br>            <span class="hljs-comment">% Create EditField3</span><br>            app.EditField3 = uieditfield(app.UIFigure, <span class="hljs-string">&#x27;numeric&#x27;</span>);<br>            app.EditField3.Position = [<span class="hljs-number">102</span> <span class="hljs-number">28</span> <span class="hljs-number">100</span> <span class="hljs-number">22</span>];<br><br>            <span class="hljs-comment">% Create Button</span><br>            app.Button = uibutton(app.UIFigure, <span class="hljs-string">&#x27;push&#x27;</span>);<br>            app.Button.ButtonPushedFcn = createCallbackFcn(app, @ButtonPushed, <span class="hljs-built_in">true</span>);<br>            app.Button.Position = [<span class="hljs-number">32</span> <span class="hljs-number">207</span> <span class="hljs-number">170</span> <span class="hljs-number">25</span>];<br>            app.Button.Text = <span class="hljs-string">&#x27;初始化&#x27;</span>;<br><br>            <span class="hljs-comment">% Create addsubLabel</span><br>            app.addsubLabel = uilabel(app.UIFigure);<br>            app.addsubLabel.Position = [<span class="hljs-number">16</span> <span class="hljs-number">253</span> <span class="hljs-number">202</span> <span class="hljs-number">22</span>];<br>            app.addsubLabel.Text = &#123;<span class="hljs-string">&#x27;输入两个整数，按add或sub进行计算&#x27;</span>; <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br><br>            <span class="hljs-comment">% Show the figure after all components are created</span><br>            app.UIFigure.Visible = <span class="hljs-string">&#x27;on&#x27;</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">% App creation and deletion</span><br>    <span class="hljs-keyword">methods</span> (Access = public)<br><br>        <span class="hljs-comment">% Construct app</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">app</span> = <span class="hljs-title">app1</span></span><br><br>            <span class="hljs-comment">% Create UIFigure and components</span><br>            createComponents(app)<br><br>            <span class="hljs-comment">% Register the app with App Designer</span><br>            registerApp(app, app.UIFigure)<br><br>            <span class="hljs-keyword">if</span> nargout == <span class="hljs-number">0</span><br>                clear app<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-comment">% Code that executes before app deletion</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delete</span><span class="hljs-params">(app)</span></span><br><br>            <span class="hljs-comment">% Delete UIFigure when app is deleted</span><br>            delete(app.UIFigure)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://blog.csdn.net/m0_51546637/article/details/126325136 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://ww2.mathworks.cn/help/compiler/matlab-library-loading.html <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debug检查单</title>
    <link href="/2023/11/17/debug%20%E6%A3%80%E6%9F%A5%E5%8D%95/"/>
    <url>/2023/11/17/debug%20%E6%A3%80%E6%9F%A5%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>当你的程序没有AC时，请按此检查单一项一项检查。</p><h2 id="首先看这个">首先看这个</h2><ol type="1"><li><p><strong>电脑坏了，键盘鼠标坏了，IDE坏了，账号上不去了，电脑没电了，运行不了代码了，题目/数据有问题……</strong></p><p>重启IDE，再不行就重启电脑，还不行就举手向监考老师提问。</p></li><li><p><strong>做题时一字不落地阅读整个题目（包括提示、Hint）了吗？</strong></p></li><li><p><strong>编译时打开「显示所有警告信息（<code>-Wall</code>）」开关了吗？</strong></p></li><li><p><strong>能看懂编译器给出的警告吗？妥善处理了这些警告吗？</strong></p><p>在 <code>scanf</code>、<code>printf</code> 函数里用 <code>%lld</code> 输入输出 <code>long long</code> 类型变量时，会产生这样的警告：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[警告] <span class="hljs-type">unknown</span> <span class="hljs-keyword">conversion</span> <span class="hljs-keyword">type</span> <span class="hljs-type">character</span> <span class="hljs-string">&#x27;l&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">format</span> [-Wformat=]<br>[警告] too many arguments <span class="hljs-keyword">for</span> <span class="hljs-keyword">format</span> [-Wformat-extra-args]<br></code></pre></td></tr></table></figure><p>这是可以忽略的。其它的警告，一般都不能忽略，需要消除。</p></li><li><p><strong>然后，请根据你的具体错误选择对应的检查单</strong></p><p>怎么看？</p><p>比赛页面左侧，点击「我的提交」：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202311062240962.png" alt="image-20231106224033830" /><figcaption aria-hidden="true">image-20231106224033830</figcaption></figure><p>把鼠标放到「结果」那一栏上：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202311062241221.png" alt="image-20231106224123162" /><figcaption aria-hidden="true">image-20231106224123162</figcaption></figure></li></ol><h2 id="cecompile-error">CE（Compile Error）</h2><blockquote><p>你的程序存在语法错误（C / C++ 最常见的是缺少分号、缺少括号、使用了中文标点符号或者函数调用错误等等）或者OJ系统不支持的写法（较少见）。</p><p>此时应当仔细检查代码在本机能否通过编译，改正后再次提交。</p></blockquote><ol type="1"><li><p><strong>保存文件时，后缀名是 <code>.c</code> 而不是 <code>.cpp</code> 吗？</strong></p></li><li><p><strong>编译器的标准选到 <code>ISOC99</code> 了吗？</strong></p></li><li><p><strong>能看懂编译器给出的报错信息吗？用翻译软件翻译一下呢？</strong></p></li><li><p><strong>输出特殊字符时，合理地进行转义了吗？</strong></p></li><li><p><strong>是否使用了不在标准库中的函数？</strong></p><p>例如：<code>strrev</code></p></li></ol><p>报错：<code>[错误] ld returned 1 exit status</code>：</p><ol type="1"><li><p><strong>使用的各库函数名、关键字拼写正确吗？</strong></p><p>常见易错：<code>main</code>、<code>printf</code>、<code>scanf</code>、<code>sin</code>、<code>void</code></p></li><li><p><strong>之前运行程序打开的控制台（黑框框）关掉了吗？</strong></p></li><li><p><strong>实在不行，新建一个 <code>.c</code> 文件，并把你原来的代码粘贴进去，再编译试试。</strong></p></li></ol><p>报错：<code>[错误] stray '\xxx' in program</code>：</p><ol type="1"><li><p><strong>程序里有全角（中文）符号吗？</strong></p><p>半角符号（正确）：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">. <span class="hljs-comment">; : &#x27; &quot; ! ( ) [ ]</span><br></code></pre></td></tr></table></figure><p>全角符号（错误）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">。 ； ： ’ “ ！ （） 【】<br></code></pre></td></tr></table></figure></li></ol><h2 id="wawrong-answer">WA（Wrong Answer）</h2><blockquote><p>你程序输出的结果有错误，与期望输出不匹配（也有可能是因为缺少了必要的换行和空格）。</p><p>请检查你的程序是否出现了致命的逻辑错误，当然有的时候是因为手滑。</p></blockquote><ol type="1"><li><p><strong>用到的运算有可能产生数据溢出吗？数据溢出的情况得到妥善处理了吗？</strong></p><p>例如：<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是 <code>int</code> 类型的变量，那么 <span class="math inline">\(a+b\)</span> 、<span class="math inline">\(a-b\)</span> 和 <span class="math inline">\(a\times b\)</span> 都有可能超过 <code>int</code> 型上下限，从而产生数据溢出。即便你使用一个 <code>long long</code> 类型的变量承接表达式的值，可是表达式计算过程中已经发生了溢出，仍然会导致结果错误。</p><p>请对照下面的代码，思考错误的原因和正确的处理方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a,b;<br>a=<span class="hljs-number">2147483647</span>;<br>b=<span class="hljs-number">2</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> c,d;<br>c=a+b;<br>d=a*b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,c,d);<br><span class="hljs-comment">//错误，输出-2147483647 -2</span><br>c=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a+b;<br>d=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,c,d);<br><span class="hljs-comment">//正确，输出2147483649 4294967294</span><br></code></pre></td></tr></table></figure><p>再例：有些情况下，即便题目保证了输入数据和结果都在 <code>int</code> 范围内，但是中间计算过程仍然会发生溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a,b,c;<br>a=<span class="hljs-number">2000000000</span>;<br>b=<span class="hljs-number">2000000000</span>;<br>c=<span class="hljs-number">5000</span>;<br><span class="hljs-type">int</span> d=(a+b)/c;<br><span class="hljs-comment">//在本代码中，abc，以及d本应得到的值都在int范围内</span><br><span class="hljs-comment">//但a+b已经超过了int范围，因此会得到错误的结果。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>如果程序用到了浮点数，那么合理地处理了浮点误差和 <code>NaN</code> 吗？</strong></p><p>例如：不能用 <code>==</code> 判断两个浮点数是否相等，计算整数的整数次方时不要用 <code>pow</code> 函数，浮点数除法的除数、<span class="math inline">\(\log (x)\)</span> 里的 <span class="math inline">\(x\)</span> 是否可能是 <span class="math inline">\(0\)</span>。</p></li><li><p><strong>希望其值为浮点数的算式，值真的是浮点数吗？</strong></p><p>请对照下面的代码，思考错误的原因和正确的处理方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> a=<span class="hljs-number">1</span>/<span class="hljs-number">3</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>,a);<span class="hljs-comment">//a=0</span><br>a=<span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>,a);<span class="hljs-comment">//a=0.3333...</span><br></code></pre></td></tr></table></figure></li><li><p><strong>程序的输入部分输入的内容真的是正确的吗？</strong></p><p>在输入结束以后，把输入的变量输出一下看看。</p></li><li><p><strong>输出特殊字符时，合理地进行转义了吗？</strong></p></li><li><p><strong>重复声明了相同名称的变量吗？</strong></p><p>错误示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br><span class="hljs-comment">//i在不同作用域中被重复声明</span><br>&#125;<br></code></pre></td></tr></table></figure><p>错误示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span> &#123;<span class="hljs-comment">//函数形参和全局变量重复</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1LL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; ++i) &#123;<br>ans *= a;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>printf</code> 语句输出时，类型标识符和输出的变量类型的对应关系是正确的吗？</strong></p><p>从 <code>int</code> 改成 <code>long long</code> 的时候，输出的 <code>%d</code> 改成 <code>%lld</code> 了没？</p></li><li><p><strong>输出给定的字符串时，是从题目上复制粘贴的吗？</strong></p></li><li><p><strong>特殊情况、边界情况考虑了吗？</strong></p><p>例如：区间合并，输入只有一个区间；进制转换，被转换的数为零……</p></li><li><p><strong>在声明任何变量、数组、指针、字符串时，给它赋予了合理的初始值吗？</strong></p><p>除非你这个变量（数组、指针、字符串……）是声明了以后立刻输入的，否则必须赋予初始值，不管是全局还是局部。</p></li><li><p><strong>多组输入输出问题中，在每组开始时，给用到的变量、数组清零或重新初始化了吗？</strong></p><p>其实不只是每组开始时，最好能检查一下整个程序里该初始化的地方都初始化了没。</p></li><li><p><strong>多组输入输出问题中，在输出每组答案以后换行了吗？</strong></p></li></ol><h2 id="regruntime-error">REG（Runtime Error）</h2><blockquote><p>这种错误分很多种，具体请百度。最常见的是 SIGSEGV，一般是因为访问了不存在的数组元素或者函数调用过多导致爆栈。</p></blockquote><p>在本地，这样的错误往往表现为输入了数据以后，程序卡死，过一会儿后结束，然后程序的返回值不是零，例如：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202311062246827.png" alt="image-20231106224607702" /><figcaption aria-hidden="true">image-20231106224607702</figcaption></figure><p><code>... with return value</code> 后面的那个 <code>3221225620</code> 就是程序的返回值。当它不是 <code>0</code> 时，说明你的程序发生了运行时错误。</p><ol type="1"><li><p><strong>数组的长度开得够大吗？</strong></p><p>如果你习惯下标从 <span class="math inline">\(1\)</span> 开始，那么数组的长度要加一。</p><p>字符串注意 <code>\0</code> 也要占一位。</p><p><span class="math inline">\(10^x\)</span> 就是 <span class="math inline">\(1\)</span> 后面有 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(0\)</span> 。</p><p>字符串做拼接操作时，是否预留了足够的空间？</p></li><li><p><strong>用变量做数组的长度了吗？</strong></p><p>这种写法是错误的，请思考为什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[n];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>scanf</code> 语句时，加 <code>&amp;</code> 符号了吗？</strong></p><p>字符串不用加，别的都得加。</p></li><li><p><strong>使用除法 <code>/</code> 或取模 <code>%</code> 运算时，除数或模数有可能是零吗？</strong></p><p>有可能因为数据溢出而导致意外的 <span class="math inline">\(0\)</span> 。例如：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202311241629696.png" alt="image-20231124162927558" /><figcaption aria-hidden="true">image-20231124162927558</figcaption></figure></li><li><p><strong>递归调用函数的层数是否太多了？能改写成循环吗？</strong></p><p>例如：计算阶乘、二分法等，都要写成循环</p></li><li><p><strong>在使用下标访问数组元素时，下标会小于 <span class="math inline">\(0\)</span> 或超过数组长度吗？</strong></p></li><li><p><strong>长度超过十万（<span class="math inline">\(10^5=100000\)</span>）的数组，开成全局的了吗？</strong></p></li><li><p><strong>主函数结束的时候写 <code>return 0</code> 了吗？</strong></p></li></ol><h2 id="tletime-limit-exceeded">TLE（Time Limit Exceeded）</h2><blockquote><p>你的程序可能因为时间效率不高或者出现了死循环，所以未能在规定的时限内运行结束</p></blockquote><p>在本地，这样的错误往往表现为输入数据以后程序没有反应，也不退出。</p><ol type="1"><li><p><strong>程序是否有死循环？</strong></p><p>检查方法：</p><ol type="1"><li><p>在每个模块前加入调试输出语句，例如：在输入完成后加一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入完成!\n&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>运行程序，找到程序在哪个循环处死循环了</p></li><li><p>在出现死循环的循环中，输出循环控制变量，进行详细检查。</p></li></ol></li><li><p><strong>多组输入输出问题时，是否设置了正确的终止条件？</strong></p><p><code>scanf(...)!=EOF</code>、<code>gets(...)!=NULL</code></p></li><li><p><strong>递归调用函数的效率是否太低了？能改写成循环吗？</strong></p><p>例如：计算斐波那契数列</p></li><li><p><strong>评测机一秒只能运算 <span class="math inline">\(10^8\)</span> 次，你循环的次数是否太多了？</strong></p><p>OJ上题目的时间限制大部分是<span class="math inline">\(1000\text{ms}\)</span>，而<span class="math inline">\(1000\text{ms}\)</span>评测机能够计算的次数大概不超过1亿次。所以当你的代码中 <code>for</code> 循环，或 <code>while</code> 循环循环了超过一亿次时，请果断更换解题方法。</p></li></ol><h2 id="mlememory-limit-exceeded">MLE（Memory Limit Exceeded）</h2><blockquote><p>你的程序占用的内存超过了规定值，可能是因为使用了过大的数组，也可能是没有做到内存释放（较少见）。</p></blockquote><ol type="1"><li><p><strong>请计算程序所占用的内存，检查是否超过了限制。</strong></p><p>一般来说，一道题的内存限制是 <span class="math inline">\(65536 \text{KB}\)</span>，即 <span class="math inline">\(65536\)</span> 千字节。</p><p>一个 <code>int</code> 占用 <span class="math inline">\(4\)</span> 个字节，与此同时，一个空的程序还要占用一定的基础内存。也就是说，你最多只能开长度为 <span class="math inline">\((65536-1200)\times 1024/4 =16470016\)</span> 的 <code>int</code> 数组。</p><p><strong>保险起见，最多开 <span class="math inline">\(10000000=10^7\)</span> 长度的 <code>int</code> 数组。</strong></p></li></ol><h2 id="pepresentation-error">PE（Presentation Error）</h2><blockquote><p>你的程序几乎能AC了，但是和标准输出数据有点细微的差距（大小写，空格数量，换行数量之类的）。</p><p>此时应当仔细观察题目给出的输出样例，确认格式无误（选中数据粘贴到编辑器最为稳妥）。</p></blockquote><ol type="1"><li><strong>认真阅读题目的「输出格式」部分了吗？</strong></li><li><strong>多组输入输出问题中，在输出每组答案以后换行了吗？</strong></li></ol><h2 id="oeother-error">OE（Other Error）</h2><blockquote><p>其他错误，详询老师或者助教。</p></blockquote><ol type="1"><li><strong>把它先当REG（Runtime Error）看。</strong></li></ol><hr /><p>作者：梁秋月、逐月的游星</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础第五~六周答疑要点整理</title>
    <link href="/2023/11/02/C5-E6%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2023/11/02/C5-E6%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的return语句的意义表示函数结束">函数的<code>return</code>语句的意义：表示函数结束</h2><p>对一个函数来说，当执行到<code>return</code>语句的时候，表示这个函数要直接结束，返回到函数外面调用这个函数的地方继续运行。即使<code>return</code>套在多重循环里，而循环可能还剩很多趟要跑，也会直接“撒手不管”，不会去执行<strong>执行顺序在<code>return</code>后面</strong>的语句。</p><h2 id="关于函数单向传参问题">关于函数单向传参问题</h2><p>有些同学想使用如下函数将传入函数的两个<strong>局部变量</strong>的值交换，是一种很常见的错误写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误写法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-type">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家在学习函数的时候都知道，函数传参是<strong>单向</strong>的。函数在被调用时，会在内存中开辟一块自己的内存空间。此时，作为函数参数的变量，它们的值会被相应地拷贝一份，存在属于函数自己的内存空间中。当在函数内“交换”变量<code>a</code>和<code>b</code>的时候，事实上是把函数自己的内存空间中保存的<code>a</code>、<code>b</code>变量值的一个<strong>副本</strong>进行了交换，而外面真正的变量<code>a</code>和<code>b</code>的值并没有受到影响。</p><p>如果需要通过在函数中的操作修改外部变量的值，一种可选的方法是使用<strong>全局变量</strong>。此时，因为函数可以直接访问全局变量，所以不需要将全局变量的值作为参数传入函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, b;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//函数内可以直接访问全局变量a和b</span><br>    <span class="hljs-type">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>    swap();<span class="hljs-comment">//swap函数调用结束后，全局变量a和b的值发生了交换</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外一种方法是将待交换变量的<strong>指针</strong>作为函数参数传入函数，下次课学过指针后会有详细讲解。</p><h2 id="字符串字面值和字符字面值的区别">字符串字面值和字符字面值的区别</h2><p>字符字面值是由一对<strong>单引号<code>''</code></strong>括起来的<strong>单个字符</strong>（转义字符的反斜杠<code>\</code>和后面的字符合起来算作一个字符），一个字符字面值存在一个字节（<code>char</code>）的内存空间中。</p><p>字符串字面值是由一对<strong>双引号<code>""</code></strong>括起来的任意个字符，在内存中，字符串中的每个字符都各自存在一个字节（<code>char</code>）的内存空间中，这些字节按字符在字符串中的顺序连续排列，最后以一个存有结束符<code>'\0'</code>的字节作为结尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//c1是一个字符，存入的值是字符字面量&#x27;a&#x27;</span><br><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//str1是一个长度为1的字符串，str1[0]为&#x27;a&#x27;，str1[1]为结束符&#x27;\0&#x27;</span><br><span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;this is a string&quot;</span>;<span class="hljs-comment">//一个合法的字符串</span><br><span class="hljs-type">char</span> c2 = <span class="hljs-string">&#x27;this is a string&#x27;</span>;<span class="hljs-comment">//错误写法！单引号不能用来括住多个字符</span><br><span class="hljs-type">char</span> c3 = <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment">//正确写法，c3是一个字符，存入的值是换行符&#x27;\n&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符串在数组中的存储">字符串在数组中的存储</h2><p>当使用<code>scanf("%s", str);</code>或<code>gets(str);</code>读取长度为<code>len</code>的字符串，并存入字符数组<code>str</code>时，字符串中的字符在数组中存储的下标范围是<code>0 ~ len-1</code>，下标为<code>len</code>的位置上则是一个标识字符串结束位置的<code>'\0'</code>。在遍历字符串时需要注意下标范围。</p><p>与此同时，也需要注意：字符串里的<code>'\0'</code>也是需要一个位置来存储的。所以声明数组时，请适量地把长度开大一点。</p><h2 id="字符数组的推荐初始化方法">字符数组的推荐初始化方法</h2><p>在声明字符数组时，推荐将字符数组的各位置初始化为全<code>0</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>] = &#123;&#125;;<br></code></pre></td></tr></table></figure><p>初始化为全<code>0</code>后，字符数组的每个位置上的字符都是<code>'\0'</code>，即标识字符串结束的字符。万一遇到需要自己手动给字符数组的某个位置赋值<code>'\0'</code>、标识字符串的结尾但是不小心忘记了的情况，也能使字符串能够结尾。</p><h2 id="字符串操作函数的传入参数">字符串操作函数的传入参数</h2><p><code>strcpy</code>、<code>strcat</code>、<code>strcmp</code>、<code>strlen</code>、<code>strstr</code>等诸多字符串操作函数，当需要对一维字符数组执行操作时，需要传入这些函数的参数是<strong>数组名。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">105</span>] = &#123;&#125;, b[<span class="hljs-number">105</span>] = &#123;&#125;;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a, b);<br><span class="hljs-built_in">strcpy</span>(a, b);<span class="hljs-comment">//正确</span><br><span class="hljs-built_in">strcpy</span>(a[<span class="hljs-number">105</span>], b[<span class="hljs-number">105</span>]);<span class="hljs-comment">//错误，a[105]和b[105]是访问数组a,b中下标为105的位置上的单个字符值，且访问操作发生了越界</span><br></code></pre></td></tr></table></figure><p>事实上，传入的参数需要是指向一维<code>char</code>数组的指针类型，下次课学到指针后会有详细讲解。</p><h2 id="遍历字符串时一个常见的易超时写法">遍历字符串时一个常见的易超时写法</h2><p>在需要遍历字符串的题目中，经常出现一种比较典型的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>] = &#123;&#125;;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(str); i++)&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当不会在循环中修改字符串<code>str</code>的长度时，这种写法的效率是十分低的。</p><p>因为由<code>for</code>循环中语句的执行顺序可知：每跑完一趟循环，都要去执行<code>for</code>后面括号里中间的判断条件<code>i &lt; strlen(str)</code>，来判断循环要继续还是结束。而<code>strlen</code>是通过遍历字符数组，寻找第一次出现的<code>'\0'</code>结束符来计算字符串长度的。当字符串长度固定时，<code>strlen</code>函数返回的值也是固定的值。如果每次循环都要重新计算一次这个值，那就要白白地多遍历字符串<code>strlen(str)</code>趟，显然是不必要的操作。</p><p>因此，可以在遍历字符串前，先声明一个变量待存字符串的长度，使用一次<code>strlen</code>函数计算长度并存入变量中，然后在遍历字符串时，使用这个变量的值作为循环的判断条件。这样就能减少不必要的操作，提高代码效率：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>] = &#123;&#125;;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果字符串<code>str</code>的长度在每次循环中都可能发生变化时，使用<code>i &lt; strlen(str)</code>作为判断条件就没什么问题了。</p><h2 id="逻辑表达式的短路求值性质在访问字符数组中的应用">逻辑表达式的短路求值性质在访问字符数组中的应用</h2><p>我们知道：逻辑表达式具有<strong>短路求值</strong>的性质。逻辑表达式从左往右执行，对两个以逻辑与运算<code>&amp;&amp;</code>连接的关系语句，当左面的关系语句为假（值为<code>0</code>）时，右面的关系语句不需要计算，可以直接得出整个逻辑表达式为假（值为<code>0</code>）的结果。</p><p>因此，当要在一个<code>if</code>条件里使用逻辑与运算<code>&amp;&amp;</code>，实现 判断数组下标是否越界、在不越界时取出该下标位置中的元素判断该元素是否满足某条件 时，最好将判断下标是否越界的关系语句写在左面。这样，当下标越界时左面的语句值为假，就不会执行右面的语句访问越界的位置，有助于培养大家对访问数组前先检查下标是否越界的好习惯：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>] = &#123;&#125;;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str);<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span>&lt;=i&amp;&amp;i&lt;len) &amp;&amp; str[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>    <span class="hljs-comment">//将</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><hr /><p>作者：逐月的游星、梁秋月</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础第四周答疑要点整理</title>
    <link href="/2023/10/18/C4-E4%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2023/10/18/C4-E4%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="输入不定个数字符时不要通过换行符判断结尾">输入不定个数字符时，不要通过换行符''判断结尾</h2><p>有的同学在做<code>E4-B</code>《从十进制数到2421码》时，使用<code>while((c = getchar()) != '\n')</code>语句来实现不定个数字符输入，但提交上OJ会发现结果为<code>TLE</code>（超时）。这是因为OJ是通过读取测试点输入文件的方式实现输入的，<strong>题目中并没有规定以换行符<code>'\n'</code>作为输入的结尾</strong>，那么输入文件的最后就不一定会有<code>'\n'</code>，当代码始终读不到<code>'\n'</code>时，就会一直循环执行循环体代码块，导致超时。</p><p>正确的做法是使用<code>while ((c = getchar()) != EOF)</code>或<code>while (scanf("%c", &amp;c) !=EOF)</code>。</p><h2 id="不定组输入时怎么在本地调试">不定组输入时怎么在本地调试</h2><p>当题目中要求不定组数据输入时，常用读入方式为<code>while (scanf()!=EOF)&#123;&#125;</code>（其中<code>scanf</code>函数的括号里需要根据读入内容填入合适的格式字符串和变量序列），此时本地调试中如果要输出最终的结果，需要我们<strong>手动输入文件结束符</strong>表示输入结束，输入方式为<strong>在最后一行数据后输入回车，在下一行行首先按住<code>ctrl</code>键，再按下<code>Z</code>键，此时程序运行控制台中显示输入了<code>^Z</code>，然后再次输入回车，将上述内容送入自己编写的程序</strong>，这样就可以起到控制台输入文件结束符的作用。以<code>C4-E</code>《真实命中率》的样例输入为例：</p><p>输入样例数据操作展示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031038082.png" alt="image-20240103103822987" /><figcaption aria-hidden="true">image-20240103103822987</figcaption></figure><p>注意：此时输入控制台的最后一行为<strong>一个控制字符<code>ctrl Z</code></strong>，是通过<strong>先按住<code>ctrl</code>键然后按下<code>Z</code>键的方式输入</strong>的，而<strong>不是<code>^</code>与<code>Z</code>两个字符</strong></p><p>结束输入后，在<code>ctrl Z</code>后按下回车，输出结果：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031038238.png" alt="image-20240103103833175" /><figcaption aria-hidden="true">image-20240103103833175</figcaption></figure><h2 id="百分数字面值不存在要写成小数">百分数字面值不存在，要写成小数</h2><p>不存在形如<code>x%</code>的百分数字面值，应当使用百分数对应的浮点数字面值。</p><p>也就是说，没有这样的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> x=<span class="hljs-number">10</span>%;<br></code></pre></td></tr></table></figure><p>如需要用<code>10%</code>时应当使用<code>0.1</code>，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> x=<span class="hljs-number">0.1</span>;<br></code></pre></td></tr></table></figure><h2 id="不要以变量作为数组的大小">不要以变量作为数组的大小</h2><p>固定大小的数组在声明时，可以通过赋值的方式直接初始化，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a1[<span class="hljs-number">100</span>]=&#123;&#125;;<span class="hljs-comment">//a1是大小为100的int数组，通过赋值将数组中每个位置初始化为0</span><br><span class="hljs-type">int</span> a2[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//a2是大小为100的int数组，通过赋值将数组中前三个位置分别初始化为1,2,3，后面自动填充0</span><br></code></pre></td></tr></table></figure><p>有些同学使用变量作为数组长度，并且试图像上面一样初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-type">int</span> a[n]=&#123;&#125;;<br></code></pre></td></tr></table></figure><p>但是他们发现本地上可以运行，但是提交到OJ上显示编译失败，这是为什么呢？</p><p>事实上，编译失败的提示信息是：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">[Error] <span class="hljs-keyword">variable</span>-sized <span class="hljs-keyword">object</span> may not be initialized<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031038839.png" alt="image-20240103103846754" /><figcaption aria-hidden="true">image-20240103103846754</figcaption></figure><p>本地可以编译，但是提交上去却不通过，可能的原因是本地代码文件在新建后保存时<strong>默认为<code>cpp</code>类型，代码语法为C++</strong>，也就是说本地运行的代码实际上是C++代码。判断方式是查看当前打开代码文件的后缀名，若为<code>.c</code>则表示这个文件是C语言代码文件，若为<code>.cpp</code>则表示这个文件是C++语言代码文件：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031038314.png" alt="image-20240103103859246" /><figcaption aria-hidden="true">image-20240103103859246</figcaption></figure><p>为了避免出现代码本地编译运行正常而OJ上<code>CE</code>的问题，这里<strong>要求</strong>大家在新建代码文件并保存时必须将<strong>后缀名改为<code>.c</code></strong>，这样就可以在本地编译运行代码时发现上述问题。如下图所示，在“保存类型”一栏中选择<code>C source files(*.c)</code>选项后保存：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031039080.png" alt="image-20240103103907975" /><figcaption aria-hidden="true">image-20240103103907975</figcaption></figure><p>另外，<strong>强烈不建议</strong>在声明数组时以变量作为数组的大小。即：数组的长度必须要在程序开始运行之前确定。</p><p>建议根据数据范围上限，直接声明一个一定满足题目所有要求的<strong>固定大小数组</strong>，然后根据其他输入数据的范围使用这个数组的一部分或全部位置。</p><h2 id="switch-case语句的一些问题"><code>switch-case</code>语句的一些问题</h2><p><code>switch-case</code>结构中，当被<code>switch</code>语句判断的变量满足某个<code>case</code>分支的条件时就会使代码运行进入该分支。但<strong>与<code>if</code>不同</strong>的是：在该<code>case</code>分支中的语句执行完后，如果没有<code>break</code>语句来跳出<code>switch-case</code>结构，那么会继续执行后面<code>case</code>分支中的语句。举例如下：</p><p>带<code>break</code>的<code>switch-case</code>结构及其执行结果：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031039226.png" alt="image-20240103103919115" /><figcaption aria-hidden="true">image-20240103103919115</figcaption></figure><p>不带<code>break</code>的<code>switch-case</code>结构及其执行结果：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031039729.png" alt="image-20240103103929640" /><figcaption aria-hidden="true">image-20240103103929640</figcaption></figure><p>因此，我们建议：<code>switch</code>中的 <code>case</code>和 <code>default</code>必须以 <code>break</code>终止，如果存在极特殊的情况需要共用 <code>case</code> ，<strong>必须</strong>加以明确注释。</p><p>另外还发现有人在<code>case</code>里面用<code>continue</code>的，没有这样的用法，也不允许出现。</p><h2 id="整除运算和模运算的一点性质">整除运算和模运算的一点性质</h2><p>C99标准规定，整型除法的结果<strong>向0取整</strong>，也就是说，当对应实数除法的结果为正时，整除结果为实数除法结果向下取整，当对应实数除法的结果为负时，整除结果为实数除法结果向上取整。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">5</span> / <span class="hljs-number">3</span>);<span class="hljs-comment">//输出结果为1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">-5</span> / <span class="hljs-number">3</span>);<span class="hljs-comment">//输出结果为-1，而不是-2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">5</span> / <span class="hljs-number">-3</span>);<span class="hljs-comment">//输出结果为-1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">-5</span> / <span class="hljs-number">-3</span>);<span class="hljs-comment">//输出结果为1</span><br></code></pre></td></tr></table></figure><p>模运算的两个运算数<strong>只能是整型变量</strong>，当整型变量<code>a,b</code>都为正数时，模运算<code>a % b</code>的<strong>结果范围为<code>0 ~ b-1</code></strong></p><p>执行模运算时<strong>需要考虑待取模的数的符号</strong>。模运算<code>a % b</code>的结果并不总是非负的，当取模结果不为0时，<strong>结果的符号取决于<code>a</code> 的符号</strong>，<strong>结果的绝对值为：<code>a</code>的绝对值 对 <code>b</code>的绝对值 取模的值</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">5</span> % <span class="hljs-number">3</span>);    <span class="hljs-comment">//输出结果为2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">-5</span> % <span class="hljs-number">3</span>);    <span class="hljs-comment">//输出结果为-2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">5</span> % <span class="hljs-number">-3</span>);    <span class="hljs-comment">//输出结果为2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">-5</span> % <span class="hljs-number">-3</span>);    <span class="hljs-comment">//输出结果为-2</span><br></code></pre></td></tr></table></figure><h2 id="unsigned-int类型变量使用的一个隐蔽问题"><code>unsigned int</code>类型变量使用的一个隐蔽问题</h2><p><code>unsigned int</code>类型变量表示无符号整型，有的同学会认为当确保不会存入负数的时候就可以使用该类型，事实上这是不合适的。因为当<code>unsigned int</code>类型变量被用作和<code>int</code>类型变量比较时，会隐式地将<code>int</code>变量中存的数转换为<code>unsigned int</code>类型，当参与比较的<code>int</code>类型变量原本保存的值为负数时，这步转换会导致运行结果与预期完全不符，且很难发现问题所在。当对<code>unsinged int</code>类型变量的值进行修改时，如果该变量的新值为负数，同样会产生问题。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">5</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码会运行6次循环就结束吗？错了！事实上上面的代码是一个<strong>无限循环</strong>。因为<code>unsigned int</code>变量能表示的值中<strong>不存在负数</strong>，当<code>i == 0</code>时执行<code>i--</code>时，<code>i</code>变量空间中存储的二进制比特位会变成<code>-1</code>的补码形式，而由于变量<code>i</code>为<code>unsigned int</code>类型，此时变量<code>i</code>的值事实上是<code>unsigned int</code>类型变量所能表示的最大值。<strong>所以<code>i &gt;= 0</code>条件将永远满足</strong>，循环也将永远执行下去。</p><p>下面的代码输出了<code>unsigned int</code>类型的<code>0</code>减去<code>1</code>后得到的值的十进制与十六进制形式，也证实了上述情况：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202401031039058.png" alt="image-20240103103947968" /><figcaption aria-hidden="true">image-20240103103947968</figcaption></figure><p>综上所述：使用<code>unsigned int</code>类型变量时，需要慎重考虑变量可能的范围。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础第三周答疑要点整理</title>
    <link href="/2023/10/12/C3-E3%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2023/10/12/C3-E3%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="关于pow函数">关于<code>pow</code>函数</h2><p><code>math.h</code>里的<code>pow</code>函数虽然确实可以计算次幂，但它的参数和返回值均为 <strong>double</strong> 类型，当题目中需要<strong>计算整数的整数次幂</strong>时，<strong>建议使用循环累乘</strong>的朴素方法，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, x; <span class="hljs-comment">//计算a的x次方</span><br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; ++i) &#123;<br>ans = ans * a;<br>&#125;<br><span class="hljs-comment">//ans 是a的x次方</span><br></code></pre></td></tr></table></figure><p>或者<a href="https://oi-wiki.org/math/binary-exponentiation/">快速幂算法</a>（目前不作要求，有兴趣的同学可以自行学习）。</p><h2 id="关于优先级">关于优先级</h2><p>在混用位运算符和四则运算符、比较运算符时需要注意算符的<strong>优先级</strong>问题</p><p>例如条件语句 <code>if (x&amp;y == 0)</code> ，由于<strong>比较运算符的优先级高于位运算符</strong>，括号中的条件实际是<strong>将比较语句 <code>y == 0</code> 的结果计算出来</strong>（若满足则值为1，否则为0），然后<strong>使用这个结果再与 <code>x</code> 执行与运算 <code>&amp;</code></strong>，而<strong>不是</strong>先计算了 <code>x&amp;y</code> 的结果再与<code>0</code>作比较。</p><p>如果你按照《C1-E1答疑要点整理》中所说的打开了“显示全部警告信息（<code>-Wall</code>）”，那么就会看到如下的警告信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[警告] suggest parentheses around comparison in operand of &#x27;&amp;&#x27; [-Wparentheses]<br></code></pre></td></tr></table></figure><p>各种算符优先级划分记忆起来可能有些困难，推荐的做法是<strong>使用括号将想要先执行的运算步骤单独包括起来</strong>，这样就可以要求这步运算具有更高的优先级，例如 <code>if ((x &amp; y) == 0)</code> 。简而言之，你记不住优先级没关系，只要会加括号就行了。</p><hr /><p>作者：逐月的游星、梁秋月</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我会自己Debug</title>
    <link href="/2023/10/07/%E6%88%91%E4%BC%9A%E8%87%AA%E5%B7%B1Debug/"/>
    <url>/2023/10/07/%E6%88%91%E4%BC%9A%E8%87%AA%E5%B7%B1Debug/</url>
    
    <content type="html"><![CDATA[<p>随着程序设计题目越来越复杂，我们助教很有可能也无法在短时间内解决同学们的所有问题。例如为什么我输出的和答案不一样？为什么我的程序在中途异常终止了？等等。等到程序设计真正进入比较困难的阶段时，很有可能编码的时间只占据40%，而查错的时间要占据60%。因此，会自己查找解决错误是一项很重要的技能。接下来我将给大家介绍一些自主查错的技巧</p><p>###　一、构造数据，找出错误</p><p>为什么我本地样例测试都对，但是提交的时候总是<code>WA</code>呢？</p><p>这是因为样例是很有局限性的，没有涵盖题目涉及的所有情况。所以不要再说什么“本地样例是对的”了。</p><p>最典型的是《C2-G：解方程2023》，这一道题分类情况很多，需要同学们细心讨论。有的同学在写代码时没有考虑到<span class="math inline">\(a=b=0\)</span>的情况，有的同学没有考虑到<span class="math inline">\(a&lt;0\)</span>的情况，等等。这时就需要我们自己给自己构造出一些测试数据，来观察自己的程序运行结果是否和自己预料的一致，如果不一致，那么这组数据极有可能反映出你程序的某种错误。</p><p>可以说，如果把debug的过程比作在海边捡拾贝壳，那么构造出一组错误的数据，就像你在看到了一枚贝壳，而剩下需要做的只是弯下腰去把贝壳捡起来而已。</p><p>接下来，我们将以下面的题目为例，给大家介绍debug的具体步骤。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 大小写转换</span><br><br><span class="hljs-section">## 题目描述</span><br>给定一个长度未知的字符串 A（含空格），请你对它进行大小写转换操作后得到字符串 B 并输出。大小写转换操作定义如下：<br>对 A 的每个字符：<br><span class="hljs-bullet"> -</span> 若该字符为小写字母，将其转换为大写字母。<br><span class="hljs-bullet"> -</span> 若该字符为大写字母，将其转换为小写字母。<br><span class="hljs-bullet"> -</span> 若该字符既不为小写字母，又不为大写字母，则该字符保持不变。<br> <br><span class="hljs-section">## 输入</span><br>一行，长度若干的字符串 A （含空格）。<br><br><span class="hljs-section">## 输出</span><br>一行，字符串 A  经大小写转换操作后得到的字符串 B <br><br><span class="hljs-section">## 输入样例1</span><br>To be or not to be, that&#x27;s a question.<br><br><span class="hljs-section">## 输出样例1</span><br>tO BE OR NOT TO BE, THAT&#x27;S A QUESTION.<br><br><span class="hljs-section">## 输入样例2</span><br>abCDeFg1234567<br><br><span class="hljs-section">## 输出样例2</span><br>ABcdEfG1234567<br></code></pre></td></tr></table></figure><h3 id="二单步运行观察过程">二、单步运行，观察过程</h3><p>主流的IDE几乎都有单步运行调试的功能，接下来我以<code>dev-cpp</code>为例给大家讲解一下怎么用。</p><ol type="1"><li>在 工具-编译器选项-代码生成/优化-连接器 中打开“产生调试信息”开关。</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202310040937664.png" alt="image-20210925102646726" /><figcaption aria-hidden="true">image-20210925102646726</figcaption></figure><ol start="2" type="1"><li>单击你希望中断的行号，以此“设置断点”。</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202310040937672.png" alt="image-20210925102857415" /><figcaption aria-hidden="true">image-20210925102857415</figcaption></figure><ol start="3" type="1"><li>在左侧“调试”处选择“添加查看”，来查看一个变量在程序运行过程中的值。</li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202310040938033.png" alt="image-20210925103056866"  /></p><ol start="4" type="1"><li>点击下方的调试-调试，运行程序。</li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202310040938039.png" alt="image-20210925102938533" style="zoom: 67%;" /></p><ol start="5" type="1"><li>点击“下一步”，单步执行，观察变量的变化过程和程序的执行情况。</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202310040938476.png" alt="image-20210925103215538" /><figcaption aria-hidden="true">image-20210925103215538</figcaption></figure><h3 id="三输出调试理清逻辑">三、输出调试，理清逻辑</h3><p>由于咱们使用的IDE可能有些老旧，不太稳定，有时在调试时会出现异常的崩溃情况，这时候我们可以采取另一种更“简单粗暴”的方法，即输出调试法。</p><p>例如对《大小写转换》这题而言，示例的错误代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span>( ( c = getchar() ) != EOF ) &#123;<br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c<span class="hljs-number">-32</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c+<span class="hljs-number">32</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入<code>a</code>，输出<code>Aa</code>.</p><p>为了找到问题，我们可以在每个<code>if</code>里面加一个输出标签，来确定程序进入了哪个 <code>if</code> 语句块中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span>( ( c = getchar() ) != EOF ) &#123;<br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1:&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c<span class="hljs-number">-32</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2:&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c+<span class="hljs-number">32</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3:&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入<code>a</code>，输出<code>1:A3:a</code></p><p>这样一来，我们就知道程序进入了第一个if和最后一个else，可以据此来修改代码的逻辑。</p><p>当然，你也可以把关键变量的值在运行过程中就<code>print</code>出来，来观察这个变量的变化。</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//......</span><br><span class="hljs-type">double</span> a,b;<br><span class="hljs-comment">//......</span><br><span class="hljs-keyword">if</span>(a/b&lt;<span class="hljs-number">0.00001</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR!\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4lf&quot;</span>,a/b);<br></code></pre></td></tr></table></figure><p>在输入一组数据时，程序输出<code>-nan</code>。</p><p>此时，我们可以在第4行前输出a和b的值，发现<span class="math inline">\(a=b=0\)</span>，那么<span class="math inline">\(a/b\)</span>的运算自然不能正常运行了，于是我们就精准定位了错误。</p><h3 id="四模块测试稳扎稳打">四、模块测试，稳扎稳打</h3><p>有些复杂的题目，很可能由多个模块构成。我们可以在写完一个模块时，就构造一些数据，专门用来测试这个模块的运行情况。</p><p>这样debug，比整个程序都写完以后再慢慢定位问题，效率高很多。例如我要写一个四则运算计算器，那么写完加法部分后，就可以先测试测试加法的工作是否正常；当要输入字符时，如果你对不太有信心，可以输入以后立刻将被输入的东西输出，以此来查看是否正确进行了输入。</p><h3 id="五保持码风清晰易懂">五、保持码风，清晰易懂</h3><p>有些 IDE 有自动格式化代码的功能，例如 dev-cpp 可以按 <code>ctrl+shift+A</code> 来自动格式化代码。希望大家以后编程时都照着格式化后的这种格式来写，这样的话在编码时你的逻辑就很清晰了，不会自己把自己绕进去。</p><p>你觉得是看这种代码清楚呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span>( ( c = getchar() ) != EOF ) &#123;<br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)) <br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c<span class="hljs-number">-32</span>);<br><br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c+<span class="hljs-number">32</span>);<br>&#125; <span class="hljs-keyword">else</span> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br><br><br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>还是这种清楚呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span>( ( c = getchar() ) != EOF ) &#123;<br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>))<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c<span class="hljs-number">-32</span>);<br><span class="hljs-keyword">if</span>((c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>) &amp;&amp; (c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c+<span class="hljs-number">32</span>);<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我相信大家都有自己的判断。</p><p>此外，还有几个小建议：</p><ol type="1"><li><p><strong>写 <code>for,while,if,else</code> 这种语句时，无论后面写几行，都要加大括号。</strong></p><p>有的同学可能会说，如果我只写一行，不是不用加吗？其实按理来说确实不用加，但是有的人就会犯这种错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i, j, a, b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;i, &amp;j);<br>    a = i/j + <span class="hljs-number">1</span>;<br>    b = i/j;<br><span class="hljs-keyword">if</span> (i%j != <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, b); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到了吗？第8行的<code>if</code>后面多了一个分号。</p><p>如果你一直加大括号，那么<code>if</code>后面永远是<code>&#123;</code>。一旦你看到<code>if</code>后面没有<code>&#123;</code>,你就能提示自己，这里可能出错了。</p></li><li><p><strong>对于复杂的运算式，搞不清楚运算符优先级？加括号！</strong></p><p>这样可以保证运算的按照你想的顺序运行。凡是你自己不清楚的，那就加括号！</p><p>尤其是位运算的优先级问题，需要特别的注意。</p></li><li><p><strong>尽可能把表达式写简单，清晰。把一个很长的表达式拆分成多个简单的表达式。</strong></p><p>别写<code>a=(++i)+(++i)+(++i)+(i++)</code>了，求求你了，何苦自己为难自己呢？</p></li><li><p><strong>让编译器显示全部警告信息</strong></p><p>真的，可有用了，绝大多数低级错误都能发现。当然在使用<code>%lld</code>输入<code>long long int</code>型时会误报，忽略就行。</p></li></ol><h3 id="六寻求帮助学会提问">六、寻求帮助，学会提问</h3><p>前面写了这么多，并不是说就不让你提问了。如果真的自己也解决不了，百度也百度不到，一定要积极提问。但是在<strong>提问时</strong>，请至少<strong>包含以下内容</strong>：</p><ol type="1"><li><p><strong>题号</strong></p><p>比赛名称、题目编号或题目链接</p></li><li><p><strong>代码</strong></p><p><strong>别拍照，别截图</strong></p><p><img src="https://img1.imgtp.com/2023/10/04/Ew59pppl.jpg" alt="image" style="zoom: 25%;" /></p><p>（因为图片经常存在<strong>不够清晰</strong>的问题，不容易看到一些可能出问题的关键细节，另外图片中的代码在助教本地复现时需要耗费更多的时间，比较<strong>影响答疑效率</strong>）</p><p>推荐<strong>直接复制粘贴</strong>，使用https://pastebin.ubuntu.com/</p></li><li><p><strong>报错信息</strong></p><p>编译失败的报错信息、提交到OJ上没有AC的报错信息、代码评测得分，或者自己测试时遇到的错误等等，就是你遇到了什么问题</p></li></ol><p>还可以包括以下内容，可以让我们更快速的定位问题：</p><ol start="4" type="1"><li><strong>编程思路</strong></li><li>你自己debug的过程和成果</li></ol><p><strong>不推荐</strong>的提问方式：</p><ul><li>助教请问我这个代码为什么 CE 啊？</li><li>助教我本地样例是对的，但是提交到 OJ 上是 WA 。</li></ul><p><strong>推荐</strong>的提问方式：</p><ul><li>助教我的代码编译错误，编译器说<code>[错误] 'a' undeclared (first use in this function)</code>，请问为什么啊？</li><li>助教我的代码如果输入<code>a</code>，本来应该输出<code>A</code>，但是它实际上输出了<code>Aa</code>，我找不出来问题在哪，你能帮帮我吗？</li></ul><p>推荐阅读：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh*CN.md#%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%B8%8D%E8%83%BD%E4%BB%A3%E6%9B%BF%E4%BD%A0%E7%9A%84%E5%8A%9F%E8%AF%BE">提问的智慧</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础第一周答疑要点整理</title>
    <link href="/2023/10/06/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2023/10/06/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="scanf-里不要乱加其它符号"><code>scanf</code> 里不要乱加其它符号</h2><p>使用<code>scanf</code>读入数字并存入<code>int</code>类型变量时，不需要按照题目中的输入数据格式在格式字符串中加入空格或换行符<code>\n</code></p><p>因为<strong>使用<code>scanf</code>读入<code>int</code>类型的变量时</strong>，它会在开始读入时<strong>自动忽略空格、换行等字符</strong>，直到遇到第一个数，执行读入，然后在下一个空格/换行处停止，将读到的数存入参数列表中对应的第一个变量，再根据格式字符串中格式符<code>%d</code>的个数，继续执行读入。举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<span class="hljs-comment">//使用scanf读入3个数字，分别存入变量a,b,c中，%d之间没有空格</span><br></code></pre></td></tr></table></figure><p>使用上面的代码时，无论输入方式是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">11</span> <span class="hljs-number">22</span> <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>还是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">11</span> <span class="hljs-number">22</span><br><span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>或者是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">11</span><br><span class="hljs-number">22</span> <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>都可以实现分别读入数字<code>11,22,33</code>并按顺序存入变量<code>a,b,c</code>中</p><p>当需要读入格式中包含非空白字符的数时，可以在<code>scanf</code>的格式化字符串中加入其他字符用于匹配，实现格式化读入，后面遇到时会专门说明，此处先不考虑.</p><h2 id="变量要初始化">变量要初始化</h2><p>当我们在<code>main</code>函数中使用类似<code>int a;</code>这样的语句声明变量后，变量中的值是<strong>不确定的</strong>，如果直接向该变量中累加其他值，最后得到的结果也是未知的。因此，在使用一个变量前，一定要确保该变量存有确定的值。如在向计数变量中累加前，需要通过赋值的方法设置其初始值为<code>0</code></p><h2 id="关于多组输入输出问题">关于多组输入输出问题</h2><p>当题目中有<strong>多组数据</strong>时，可以<strong>每读入一组数据就进行处理、输出结果</strong>。OJ系统在评测时，<strong>只会读取</strong>我们提交上去的程序的<strong>输出结果，与测试点比对</strong>，而并不检查这些结果是在程序运行的哪个阶段输出的。所以只要每组数据输入后就立刻处理，并按照格式要求输出结果就可以。注意输出每组数据后的<strong>换行问题</strong>，如果缺少换行，那下一组数据的输出会直接接在上一组数据输出同一行的后面，导致代码不能通过评测（可能返回<code>PE</code>或<code>WA</code>的结果）</p><h2 id="关于不定个数据读入以特定值如-1结束的问题">关于不定个数据读入，以特定值（如<code>-1</code>）结束的问题</h2><p>参考 PPT 可知，可以使用如下的语句实现多组数据读入，遇到<code>-1</code>时结束：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> score;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;score);<span class="hljs-comment">//预先读入一次，若为-1则不会进入后面的循环，否则进入</span><br><span class="hljs-keyword">while</span> (score != <span class="hljs-number">-1</span>)&#123;<br>    <span class="hljs-comment">//do something，可以是处理读入的score值操作</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;score);<span class="hljs-comment">//在循环中再次读入，以下一个输入数据更新score变量的值，这样才能实现在读到-1之前不断循环读入</span><br>    <span class="hljs-comment">//若缺少该scanf，则score的值不会更新，保持原值，会导致该while循环的条件始终为真，无尽循环！</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="id-returned-1-exit-status-报错"><code>id returned 1 exit status</code> 报错</h2><p>使用 Dev-C++ 编写并调试代码的同学，如果在编译时出现了 <code>id returned 1 exit status</code>的报错，可能是因为上一次在 Dev-C++ 中运行的程序没有结束，或者是代码文件/文件夹被其余进程占用，关闭上一次程序运行的黑框或者重启 Dev-C++，重新编译运行即可</p><h2 id="关于输出字符串">关于输出字符串</h2><p>遇到题目要求输出字符串时，一定要将需要输出的字符串<strong>复制粘贴</strong>到代码中，自己输入的时候很可能会看错或切错输入法，从而导致代码无法通过评测的情况发生。如：<code>N0</code>与<code>NO</code>（前者为第<span class="math inline">\(14\)</span>个大写英文字母和第<span class="math inline">\(1\)</span>个自然数连接成的字符串），<code>YE5</code>与<code>YES</code>（前者为第<span class="math inline">\(25\)</span>个大写英文字母、第<span class="math inline">\(5\)</span>个大写英文字母和第<span class="math inline">\(6\)</span>个自然数连接成的字符串），<code>！</code>与<code>!</code>（前者为全角叹号，后者为半角叹号），<code>？</code>与<code>?</code>（同为全角半角区别）</p><h2 id="关于if语句">关于<code>if</code>语句</h2><h3 id="一个常见的语法错误">一个常见的语法错误</h3><p><strong>判断两数是否相等</strong>需要使用<strong>两个连续等号</strong>，即<code>a == b</code>，<strong>单个等号</strong>起到的是<strong>赋值</strong>作用，将等号右面的值赋给等号左面。</p><p>那么有人就问了：既然意思完全不对，那么为什么编译还能通过呢？</p><p>实际上，<code>if(...)</code>语句的行为是判断括号里面的表达式的值，<code>a==b</code>是逻辑判断表达式，它的数据类型为<code>int</code>，值为<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>。而<code>a=b</code>同样也是表达式，它叫做赋值表达式，它的值是<code>a</code>被赋值以后的值。而<code>if</code>只会判断括号里面的表达式的值是不是<span class="math inline">\(0\)</span>，所以编译是可以通过的。</p><p>在<code>E1</code>的题解中，出现了这样的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>t--</code>叫做“自减表达式”，在处理此表达式时，会将<code>t</code>原先的值作为表达式的值参与运算，然后使<code>t</code>减一。这样的写法实现的效果是将<code>//代码</code>部分执行<code>t(初始值)</code>遍。</p><h3 id="一个常见的逻辑错误">一个常见的逻辑错误</h3><p>使用<code>if</code>分支语句的时候，需要注意下面两种代码的区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这里使用if-else逻辑</span><br><span class="hljs-comment">//当满足上面的if条件时</span><br><span class="hljs-comment">//确定不会进入下面else的代码块</span><br><span class="hljs-comment">//修改过的a的值不会影响下面的代码块</span><br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>    a = a + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    a = a - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//这里使用的是2个if并列逻辑</span><br><span class="hljs-comment">//当满足上面的if条件时</span><br><span class="hljs-comment">//仍然会判断是否满足下面的if条件</span><br><span class="hljs-comment">//从而决定是否进入下面代码块</span><br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>    a = a + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在上一个if代码块中修改过的a的值，如果满足这个if的条件，会进入这个代码块，从而导致被第二次修改</span><br>    a = a - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个常见的写法错误">一个常见的写法错误</h3><p>使用<code>if</code>分支判断语句或<code>while</code>、<code>for</code>条件循环语句时，建议在后面加上大括号，明确在满足条件时会执行的（被它们所“管着”的）代码是哪部分。如果不使用大括号划定范围，那么在满足条件时会执行的只有紧随其后的一句以分号结尾的代码。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)&#123;<br>    a = a + <span class="hljs-number">1</span>;<br>b = b + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//上面代码执行结果为：a,b的值都增为2</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>    a = a + <span class="hljs-number">1</span>;<br>b = b + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//上面代码执行结果为：a值增为2，b值仍为1</span><br></code></pre></td></tr></table></figure><h2 id="避免诸多低级错误的小技巧">避免诸多低级错误的小技巧</h2><p>在在 工具-编译器选项-代码生成/优化-代码警告中，将“显示最多警告信息(<code>-Wall</code>)”右边的按钮切换为<code>Yes</code>，更为谨慎的同学，可以将下面的<code>-Wextra</code>也切换为<code>Yes</code>：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202309201525959.png" alt="image-20230920152524983" /><figcaption aria-hidden="true">image-20230920152524983</figcaption></figure><p><code>-Wall</code>是 gcc 编译器认可的、很有用的警告选项集合。对于这些警告，应该理解其含义，通过修改代码来消除警告。接下来通过具体实例说明它的用处：</p><ol type="1"><li><p><strong><code>scanf</code> 没加 <code>&amp;</code></strong></p><p>编写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，弹出编译警告：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">[警告] format <span class="hljs-string">&#x27;%d&#x27;</span> expects <span class="hljs-keyword">argument</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;int *&#x27;</span>, but <span class="hljs-keyword">argument</span> <span class="hljs-number">2</span> <span class="hljs-built_in">has</span> <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;int&#x27;</span> [-Wformat=]<br></code></pre></td></tr></table></figure><p>即： 格式<code>%d</code>的参数类型为<code>int *</code>，但参数 2 的类型为<code>int</code>。关于这句话是什么意思，涉及到我们日后会学习的“指针”概念。现在你只需要知道：编译器在警告你这句话写得有问题。</p></li><li><p><strong>变量没初始化</strong></p><p>编写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，弹出编译警告：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">[警告] <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">is</span> used uninitialized <span class="hljs-keyword">in</span> this <span class="hljs-keyword">function</span> <span class="hljs-title">[-Wuninitialized]</span><br></code></pre></td></tr></table></figure><p>即： <code>a</code>在该函数中未初始化</p></li><li><p><strong><code>if</code> 没写俩等号</strong></p><p>编写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>    <span class="hljs-keyword">if</span>(a=<span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;zero&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，弹出编译警告：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[警告] suggest parentheses <span class="hljs-keyword">around</span> assignment used <span class="hljs-keyword">as</span> truth value [-Wparentheses]<br></code></pre></td></tr></table></figure><p>即：建议在作为真值的赋值周围加上括号</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础第二周答疑要点整理</title>
    <link href="/2023/09/27/C2-E2%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2023/09/27/C2-E2%E7%AD%94%E7%96%91%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="格式符和数据类型要匹配">格式符和数据类型要匹配</h2><p>使用<code>scanf</code>读入或使用<code>printf</code>输出的时候一定要注意<strong>变量类型与格式符匹配</strong>：<code>int</code>类型对应<code>%d</code>，<code>long long int</code>类型对应<code>%lld</code>，<code>double</code>类型对应<code>%lf</code>（注意<code>double</code>类型的输出需要使用<code>%f</code>），需要输出字符时使用<code>%c</code>，<code>unsigned int</code>对应<code>%u</code>，<code>unsigned long long</code>对应<code>%llu</code></p><p>如果不匹配，在C99标准中属于“未定义行为”，编译器可以任意实现未定义的行为。是的，按理来说，如果出现未定义行为，编译器给你弹出一个俄罗斯方块游戏，那也是合理的！所以，不要试图讨论“未定义行为”的结果，无论它是对了，还是错了，都没有意义。</p><p>也就是说很有可能在你的电脑上，它按照你的想法运行，但是换一个环境，它就不按照你的想法运行了。</p><h2 id="学会使用字符字面值">学会使用字符字面值</h2><p>在编写代码时，如果需要使用字符的<code>ASCII</code>值，不必查表记忆，可以<strong>直接使用字符字面值</strong>，字符字面值为<strong>由单引号括起来的单个字符</strong>。这样做一来可以减少大家记忆的工作量，二来可以使得你的程序更易读。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">//判断 c 是不是数字字符</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<span class="hljs-comment">//判断 c 是不是小写字母</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;A&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<span class="hljs-comment">//判断 c 是不是大写字母</span><br></code></pre></td></tr></table></figure><p>再次强调：<strong>由单引号括起来的单个字符才是字符字面值</strong>，没有单引号括起来的字符是<strong>变量名</strong>，若该变量在此前未被声明，则编译时会报错（变量未定义），若该变量在此前已被声明和使用（但存入的值不是它对应的字符字面值），则编译时可能不会报错，但代码运行结果可能与期望的相差很远</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//char类型变量c与字符字面量&#x27;A&#x27;进行比较</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//char类型变量c与变量A进行比较</span><br><span class="hljs-comment">//若变量A未定义则会编译报错</span><br><span class="hljs-comment">//若已定义使用则编译可能不会报错，但结果可能非预期</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c);<br><span class="hljs-keyword">if</span> (c == A)&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环中变量的处理与重置">循环中变量的处理与重置</h2><p>在进入循环前定义的变量，如果在每趟循环开始或结束时不进行重置值操作，那么在进入下一趟循环后会保持原有值不变，从而导致存在多组数据的题目中产生输出出错的问题。<strong>此问题尤见于多组输入输出问题中。</strong></p><p>下面是一道例题，以及一种典型的<strong>错误</strong>写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">例题：给定n,m，分别计算n组输入中每组的m个数之和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//一种比较典型的错误写法如下</span><br><span class="hljs-type">int</span> n, m, sum = <span class="hljs-number">0</span>, tmp;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;tmp);<br>        sum = sum + tmp;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>错误的原因：<code>sum</code> 变量虽然在声明时被初始化置为 <span class="math inline">\(0\)</span> ，但在内层循环结束、输出 <code>sum</code> 的值后，<strong><code>sum</code> 并没有被重新置为 <span class="math inline">\(0\)</span></strong>，而是<strong>在进入下一次外层循环时保持原值</strong>，这就导致当外层循环跑后面的 <span class="math inline">\(n-1\)</span> 趟时，<code>sum</code> 变量的初始值不是 <span class="math inline">\(0\)</span>，从而每次累加 <code>tmp</code> 值都会出错</p><p>要避免这样的错误，就需要在每次跑 <span class="math inline">\(m\)</span> 趟循环累加之前，先将<code>sum</code>变量置为 <span class="math inline">\(0\)</span> ，或者在输出<code>sum</code>变量后，立刻将<code>sum</code>的值置<span class="math inline">\(0\)</span>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">例题：给定n,m，分别计算n组输入中每组的m个数之和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//正确写法之一</span><br><span class="hljs-type">int</span> n, m, sum = <span class="hljs-number">0</span>, tmp;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以在内层循环开始前，置sum为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;tmp);<br>        sum = sum + tmp;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>    <span class="hljs-comment">//也可以在输出sum后，在这里将sum置为0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，由于 C99 不要求所有的变量定义声明都写在<code>main</code>函数中的最上面，也可以在进入内层循环之前定义计数变量<code>sum</code>。这样，新定义的变量作用域就是本次外层循环，当外层循环的一趟结束时，在循环内定义的变量<code>sum</code>会被清理掉，在循环外无法使用该变量，进入下一趟外层循环时，又会重新定义声明一个新的<code>sum</code>变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">例题：给定n,m，分别计算n组输入中每组的m个数之和</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//正确写法之二</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//循环内定义并初始化sum变量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;tmp);<br>        sum = sum + tmp;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算过程中的数据类型问题">运算过程中的数据类型问题</h2><p><code>int</code>类型变量所能存入的整数是有大小范围的。当两个<code>int</code>类型变量执行运算时，如果结果超出了<code>int</code>变量所能存入的范围，就会<strong>立即发生溢出</strong>，即使将结果赋值给<code>long long int</code>变量也是将错误的值存入了变量。因此，当题给数据范围存在溢出风险时，要么<strong>直接使用<code>long long int</code></strong>类型变量存储和运算，要么在运算前将其中一个运算数使用<strong>强制类型转换</strong>先转为<code>long long int</code>，这样才能得到正确的结果。</p><p>举个例子，请大家猜一猜下面这个代码会输出什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a=<span class="hljs-number">2000000000</span>*<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它会输出正确答案<code>4000000000</code>吗？错了！它的运行结果是：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202309271653275.png" alt="image-20230927165310913" /><figcaption aria-hidden="true">image-20230927165310913</figcaption></figure><p>可以看到结果和我们预料到的不一样，因为出现了有符号整型数溢出的未定义行为。如果你看了上一期答疑要点，在编译选项里加入了<code>-Wall</code>，那么这段代码会有一个警告：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[警告]</span> integer <span class="hljs-attribute">overflow</span> in expression <span class="hljs-selector-attr">[-Woverflow]</span><br></code></pre></td></tr></table></figure><p>为了得到正确的结果，我们可以进行类型转换，在两个乘数后面加个<code>LL</code>，来表示它是<code>long long int</code>型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> a=<span class="hljs-number">2000000000LL</span>*<span class="hljs-number">2LL</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就对了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202309271658411.png" alt="image-20230927165807322" /><figcaption aria-hidden="true">image-20230927165807322</figcaption></figure><p>同样的道理，当除号的两个运算数都是整型时，本次执行的除法是整除，即使将结果赋给<code>double</code>类型变量也只是存入了错误的值。例如：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202309271714885.png" alt="image-20230927171426815" /><figcaption aria-hidden="true">image-20230927171426815</figcaption></figure><p>如果想要让除法成为浮点数除法，需要在执行除法前，先使用强制类型转换将运算数转为<code>double</code>类型。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202309271715559.png" alt="image-20230927171548493" /><figcaption aria-hidden="true">image-20230927171548493</figcaption></figure><p>我们的建议是：如果一个表达式，你希望它最终的结果是浮点数，那么其中的每个量都要是浮点数。变量，使用强制类型转换<code>(double)</code>或使用乘以 <code>1.0</code> 的方式转为浮点数；常量，不要写作 <code>2</code> 而是写作 <code>2.0</code> 来声明其为浮点数。</p><h2 id="数组的定义使用与全局数组">数组的定义使用与全局数组</h2><p>数组的定义方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">数组中元素的类型 数组名[数组大小];<br></code></pre></td></tr></table></figure><p>注意<strong>数组的下标范围</strong>是从<code>0 ~ 数组大小-1</code>，而不是<code>1 ~ 数组大小</code>，使用时一定要注意不要访问超出数组下标范围的位置</p><p>全局数组定义的位置在<code>main</code>函数的前面，和在<code>main</code>函数内定义的数组相比，一般可以有更大的容量。以经验来看，当所使用的<code>int</code>类型数组大小超过<code>100000</code>时，就需要改为在<code>main</code>函数前面定义全局数组，而不是在<code>main</code>函数里定义数组。<code>main</code>函数中过大的数组会导致栈溢出错误，进而直接使程序终止。</p><h2 id="循环结构的使用错误">循环结构的使用错误</h2><p>在<code>for</code>循环和<code>while</code>循环的圆括号后面，<strong>不能</strong>输入分号，否则会使这个循环在遇到分号后就会结束，无法“管住”后面花括号包裹的代码块，进而导致循环体在循环结束后才去执行（且只执行一次），或因为循环条件无法被打破而无尽循环、卡住代码执行的问题。</p><p>错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i);<br>&#123;<br>    <span class="hljs-comment">//需要循环执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正确：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-comment">//需要循环执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>作者：梁秋月，逐月的流星</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>程序设计基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理实验</title>
    <link href="/2023/07/03/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/07/03/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>这实验挺神秘的其实，有好多地方我都感觉不太对劲，但是鉴于成绩还可以，还是放出来给大家参考一下。</p><span id="more"></span><h2 id="实验一一二阶系统的电子模拟及时域响应的动态测试">实验一：一、二阶系统的电子模拟及时域响应的动态测试</h2><h3 id="实验目的">实验目的</h3><ol type="1"><li><p>了解一、二阶系统阶跃响应及其性能指标与系统参数之间的关系。</p></li><li><p>学习单位阶跃响应性能指标的测试方法。</p></li></ol><h3 id="实验内容">实验内容</h3><ol type="1"><li>建立一阶系统的模型，观测并记录时间常数<span class="math inline">\(T\)</span>不同时的单位阶跃响应曲线，测定其调整时间(即过渡过程时间) <span class="math inline">\(t_s\)</span>。</li><li>建立二阶系统的数学模型，观测并记录不同阻尼比ζ时的单位阶跃响应曲线，测定其超调量<span class="math inline">\(M_p\)</span>及过渡过程时间<span class="math inline">\(t_s\)</span>。</li></ol><h3 id="实验原理">实验原理</h3><ol type="1"><li><p>一阶系统系统传递函数为：<span class="math inline">\(T(s)=K/(Ts+1)\)</span>。在实验当中始终取<span class="math inline">\(K=1\)</span>，取不同的时间常数<span class="math inline">\(T\)</span>分别为：<span class="math inline">\(0.25,0.5,1.0\)</span>。记录不同时间常数下单位阶跃响应曲线，测量并纪录其过渡过程时间<span class="math inline">\(t_s\)</span>，给出在时间常数不同时理论计算和实测的<span class="math inline">\(t_s\)</span>以及相应的阶跃响应曲线。</p></li><li><p>二阶系统系统传递函数为： <span class="math display">\[T(s)=\frac{\omega_n^2}{s^2+2\xi\omega_ns+\omega_n^2}\]</span></p><p>在实验中始终取<span class="math inline">\(\omega_n=1\)</span>弧度/秒，<span class="math inline">\(\xi\)</span>取不同的值、分别为：<span class="math inline">\(0.25,0.5,0.707,1.0\)</span>，观察并画出相应的单位阶跃响应曲线，测量超调量<span class="math inline">\(M_p\)</span>，计算过渡过程时间<span class="math inline">\(t_s\)</span>。</p></li></ol><h3 id="实验结果和代码">实验结果和代码</h3><h4 id="一阶系统">一阶系统</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031914649.jpg" alt="一阶系统图像" /><figcaption aria-hidden="true">一阶系统图像</figcaption></figure><table><thead><tr class="header"><th>T</th><th>Ts理论</th><th>Ts实测</th><th>误差</th></tr></thead><tbody><tr class="odd"><td>0.25</td><td>0.75</td><td>0.749</td><td>0.13%</td></tr><tr class="even"><td>0.5</td><td>0.15</td><td>0.15</td><td>0</td></tr><tr class="odd"><td>1</td><td>3</td><td>3</td><td>0</td></tr></tbody></table><p>误差产生的原因可能有A/D、D/A转换可能会有分辨力约束及量化精度引入的误差。一阶系统的阶跃输入响应是时间的单调函数，其理论的稳态误差为0。而瞬态响应的主要参数是其时间常数<span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span>越小，上升过程越快，调节时间越短，系统稳定就越迅速。仿真实验的结果与理论分析基本吻合。</p><p>实验代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">K=<span class="hljs-number">1</span>;<br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span>;<br>Tss=[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> Ts = xis<br>    sys=tf(K,[Ts,<span class="hljs-number">1</span>]);<br>    u=stepfun(t,<span class="hljs-number">0</span>);<br>    step(sys);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="二阶系统">二阶系统</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304060023976.jpg" alt="二阶阶跃响应" /><figcaption aria-hidden="true">二阶阶跃响应</figcaption></figure><p>图中蓝色-橙色-黄色-紫色线条依次是<span class="math inline">\(\xi\)</span>为<span class="math inline">\(0.25,0.5,0.707,1\)</span>时的单位阶跃响应。</p><table><thead><tr class="header"><th><span class="math inline">\(\xi\)</span></th><th><span class="math inline">\(Mp\)</span>理论（%）</th><th><span class="math inline">\(Mp\)</span>实测（%）</th><th><span class="math inline">\(t_s\)</span>理论</th><th><span class="math inline">\(t_s\)</span>实测</th></tr></thead><tbody><tr class="odd"><td>0.25</td><td>44.4</td><td>44.3</td><td>12</td><td>10.8</td></tr><tr class="even"><td>0.5</td><td>16.3</td><td>16.3</td><td>6</td><td>5.29</td></tr><tr class="odd"><td>0.707</td><td>4.32</td><td>4.33</td><td>4.24</td><td>2.93</td></tr><tr class="even"><td>1</td><td>0</td><td>0</td><td>3</td><td>4.74</td></tr></tbody></table><p>对于二阶系统，其阶跃响应主要由阻尼比<span class="math inline">\(\xi\)</span>及无阻尼自然频率<span class="math inline">\(\omega_n\)</span>决定。随着阻尼比增大，阶跃响应由欠阻尼过渡到临界阻尼再到过阻尼。欠阻尼状态下，阻尼比<span class="math inline">\(\xi\)</span>越大，超调量<span class="math inline">\(M_p\)</span>越小，平稳性越好，而调整时间<span class="math inline">\(T_s\)</span>也随之减短。在阻尼比<span class="math inline">\(\xi=0.707\)</span>时，超调量和调整时间都较小，可以认为是比较理想的瞬态响应，称为准最佳系统。当阻尼比增大到1时，阶跃响应成为单调的上升过程，类似于一阶系统。</p><p>实验代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">omega=<span class="hljs-number">1</span>;<br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span>;<br>xis=[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.707</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> xi = xis<br>    sys=tf(omega*omega,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*xi*omega,omega*omega]);<br>    u=stepfun(t,<span class="hljs-number">0</span>);<br>    step(sys);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="实验二频率响应测试">实验二：频率响应测试</h2><h3 id="实验目的-1">实验目的</h3><ol type="1"><li><p>掌握频率特性的测试原理及方法</p></li><li><p>学习根据所测定出的系统的频率特性，确定系统传递函数的方法。</p></li></ol><h3 id="实验内容-1">实验内容</h3><ol type="1"><li><p>测定给定环节的频率特性。</p></li><li><p>系统传递函数为： <span class="math display">\[G(s)=\frac{200}{s^2+10s+200}\]</span> 或 <span class="math display">\[G(s)=\frac{500}{s^2+10s+500}\]</span> 若正弦输入信号为<span class="math inline">\(U_i(t)=A_1\sin(\omega t)\)</span>，则当输出达到稳态时，其输出信号为<span class="math inline">\(U_o(t)=A_2 \sin (\omega t+\psi)\)</span> 。改变输入信号频率<span class="math inline">\(f_i=\frac \omega{2\pi}\)</span>值，便可测得二组和<span class="math inline">\(\frac{A_2}{A_1}\)</span>随<span class="math inline">\(f\)</span>（或<span class="math inline">\(\omega\)</span>）变化的数值，这个变化规律就是系统的幅频特性和相频特性。</p></li></ol><h3 id="实验原理-1">实验原理</h3><ol type="1"><li><p>幅频特性即测量输入与输出信号幅值<span class="math inline">\(A_1\)</span>和<span class="math inline">\(A_2\)</span>，并计算比值</p></li><li><p>实验采用“李沙育图形” 法进行相频特性的测试。以下简单介绍一下这种测试方法的原 理。设有两个正弦信号 <span class="math inline">\(X(\omega t)=X_m \sin (\omega t)\)</span> 和 <span class="math inline">\(Y(\omega t)=Y_m \sin (\omega t+\psi)\)</span>, 若以 <span class="math inline">\(X(t)\)</span> 为横轴, <span class="math inline">\(Y(t)\)</span> 为纵轴, 而以 <span class="math inline">\(\omega\)</span> 作为参变量, 则随着 <span class="math inline">\(\omega t\)</span> 的变化, <span class="math inline">\(X(t)\)</span> 和 <span class="math inline">\(Y(t)\)</span> 所确定的点的轨迹, 将在 <span class="math inline">\(X-Y\)</span> 平面上描绘 出一条封闭的曲线, 这个图形在物理学上称为“李沙育图形”（或李萨如图形）, 如下图所示。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031927247.png" alt="李沙育图形" /><figcaption aria-hidden="true">李沙育图形</figcaption></figure></li><li><p>相位差角 <span class="math inline">\(\psi\)</span> 的求法: 对于 <span class="math inline">\(X(\omega t)=X_m \sin (\omega t)\)</span> 及 <span class="math inline">\(Y(\omega t)=Y_m \sin (\omega t+\psi)\)</span>, 当 <span class="math inline">\(\omega t=0\)</span> 时, 有 <span class="math inline">\(X(0)=0\)</span>; <span class="math inline">\(Y(0)=Y_m \sin (\psi)\)</span> 。即 <span class="math inline">\(\psi=\arcsin \frac{Y(0)}{Y_m}\)</span>, 显然仅当 <span class="math inline">\(0 \leq \psi \leq \frac{\pi}{2}\)</span> 时, 该式才是成立的。</p></li></ol><p>提示1：根据实验内容，自行安排实验步骤，根据需要可以对表2.1适当修改。</p><p>提示2：简单起见，可以将某次测试结果作为参考完成报告，见下表</p><table><thead><tr class="header"><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(f\)</span>(Hz)</td><td>0.477</td><td>0.796</td><td>1.114</td><td>1.432</td><td>1.751</td><td>2.069</td><td>2.387</td><td>2.865</td><td>3.979</td><td>4.775</td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span>(rad/s)</td><td>3.000</td><td>5.000</td><td>7.000</td><td>9.000</td><td>11.000</td><td>13.000</td><td>15.000</td><td>18.000</td><td>25.000</td><td>30.000</td></tr><tr class="odd"><td><span class="math inline">\(A_2/A_1\)</span></td><td>1.035</td><td>1.108</td><td>1.216</td><td>1.362</td><td>1.453</td><td>1.428</td><td>1.421</td><td>1.211</td><td>0.820</td><td>0.369</td></tr><tr class="even"><td><span class="math inline">\(Y(0)/Y(m)\)</span></td><td>0.198</td><td>0.300</td><td>0.466</td><td>0.663</td><td>0.894</td><td>0.999</td><td>0.996</td><td>0.976</td><td>0.741</td><td>0.370</td></tr><tr class="odd"><td><span class="math inline">\(\psi(0)\)</span></td><td>-11.430</td><td>-17.436</td><td>-27.761</td><td>-41.546</td><td>-63.382</td><td>-86.967</td><td>-94.808</td><td>-102.564</td><td>-132.177</td><td>-158.256</td></tr></tbody></table><h3 id="实验结果">实验结果</h3><h4 id="绘制李萨如图像">绘制李萨如图像</h4><p>取传递函数为 <span class="math display">\[G(s)=\frac {200}{s^2+10s+200}\]</span> 分别取<span class="math inline">\(\omega=3,9,15,30\)</span>，绘制李萨如图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031929309.jpeg" alt="李萨如图像" /><figcaption aria-hidden="true">李萨如图像</figcaption></figure><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab">t=<span class="hljs-number">0</span>:<span class="hljs-number">0.001</span>:<span class="hljs-number">1000</span>;<br>f=<span class="hljs-number">3</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br><br>f=<span class="hljs-number">9</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br><br>f=<span class="hljs-number">15</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br><br>f=<span class="hljs-number">30</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br></code></pre></td></tr></table></figure><h4 id="利用表格确定传递函数">利用表格确定传递函数</h4><p>设传递函数为 <span class="math display">\[G_0(\omega)=\frac{\omega_n^2}{s^2+2 \zeta \omega_n s+\omega_n^2}=\frac{1}{\sqrt{\left(1-\frac{\omega^2}{\omega_n^2}\right)^2+4 \zeta^2 \frac{\omega^2}{\omega_n^2}}} \exp \left(-\operatorname{arctg} \frac{2 \zeta \frac{\omega}{\omega_n}}{1-\frac{\omega^2}{\omega_n^2}}\right)\]</span> 假设传递函数是<span class="math inline">\(G(s)=\frac {200}{s^2+10s+200}\)</span>，理论上<span class="math inline">\(\omega_n=\sqrt{200}=14.14\)</span>时相移恰为-90°，实验测得的结果与理论基本一致。现在把<span class="math inline">\(\omega_n=14\)</span>代入，对于十个数据点计算<span class="math inline">\(\zeta\)</span>，有：</p><table><thead><tr class="header"><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td>0.355701</td><td>0.323482</td><td>0.337327</td><td>0.343293</td><td>0.364031</td><td>0.369706</td><td>0.321067</td><td>0.196532049</td><td>/</td><td>/</td></tr></tbody></table><p>有效数据的平均值为0.326，因此，计算出的传递函数为： <span class="math display">\[G(s)=\frac {196}{s^2+9.128s+196}\]</span> 实验测的的结果与理论基本吻合，但仍存在一定的误差，可能由下面的因素引起：</p><ol type="1"><li><p>A/D、D/A转换时存在转换及量化误差；</p></li><li><p>在MATLAB输出的李沙育图形上读取<span class="math inline">\(Y_0\)</span>和<span class="math inline">\(Y_m\)</span>时存在读数误差。<span class="math inline">\(\omega_n\)</span>附近的正椭圆一定程度上依靠主观判断。</p></li><li><p>测量数据时有读数偏差</p></li></ol><h2 id="实验三控制系统串联校正">实验三：控制系统串联校正</h2><h3 id="实验目的-2">实验目的</h3><ol type="1"><li><p>了解和掌握串联校正的分析和设计方法。</p></li><li><p>研究串联校正环节对系统稳定性及过渡过程的影响。</p></li></ol><h3 id="实验内容-2">实验内容</h3><ol type="1"><li><p>设计串联超前校正，验证和分析校正装置对系统稳定性及过渡过程的影响。</p></li><li><p>设计串联滞后校正，验证和分析校正装置对系统稳定性及过渡过程的影响。</p></li></ol><h3 id="实验原理-2">实验原理</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031936227.png" alt="系统结构图" /><figcaption aria-hidden="true">系统结构图</figcaption></figure><ol type="1"><li>系统结构图如上图所示, 校正装置 (环节) (传递函数为 <span class="math inline">\(G_c(s)\)</span> ) 串联在系统的 前向通道中, <span class="math inline">\(G_0(s)\)</span> 为末加矫正时原系统前向通道传递函数, 在本次实验中设定 <span class="math inline">\(G_0(s)=\frac{4}{s(s+1)}, H(s)=1\)</span>, 实验应用 MATLAB 软件实现。</li><li>末加矫正时, <span class="math inline">\(G_c(s)=1\)</span> 。</li><li>加串联超前校正时, <span class="math inline">\(G_c(s)=\frac{a T s+1}{T s+1},(a&gt;1)\)</span> 。在实验中, 给定 <span class="math inline">\(a=2.44, T=0.26\)</span>, 则 <span class="math inline">\(G_c(s)=\frac{0.63 s+1}{0.26 s+1}\)</span>, 计算系统性能指标参量, 分析校正环节对系统稳定性及过渡 过程的影响。</li><li>加串联滞后校正时, <span class="math inline">\(G_c(s)=\frac{b T s+1}{T s+1},(0&lt;\mathrm{b}&lt;1)\)</span> 。在实验中, 给定 <span class="math inline">\(b=0.12, T=83.33\)</span>, 则 <span class="math inline">\(G_c(s)=\frac{10 s+1}{83.33 s+1}\)</span>, 计算系统性能指标参量, 分析校正环节对系统稳定性及过渡过程的影响。</li></ol><h3 id="实验结果-1">实验结果</h3><p>阶跃响应图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305252210614.jpg" alt="三系统阶跃响应图" /><figcaption aria-hidden="true">三系统阶跃响应图</figcaption></figure><p>有：</p><table><thead><tr class="header"><th></th><th>超调量Mp/%</th><th>建立时间/s</th></tr></thead><tbody><tr class="odd"><td>原系统</td><td>44%</td><td>5.48</td></tr><tr class="even"><td>超前校正</td><td>23%</td><td>1.90</td></tr><tr class="odd"><td>滞后校正</td><td>20%</td><td>13.37</td></tr></tbody></table><p>波特图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305252210441.jpg" alt="波特图" /><figcaption aria-hidden="true">波特图</figcaption></figure><p>经计算，有：</p><table><thead><tr class="header"><th></th><th>截止频率/rad</th><th>稳定裕度/°</th></tr></thead><tbody><tr class="odd"><td>原系统</td><td>1.88</td><td>28</td></tr><tr class="even"><td>超前校正</td><td>2.38</td><td>47.4</td></tr><tr class="odd"><td>滞后校正</td><td>0.45</td><td>54.8</td></tr></tbody></table><p>由上述数据可以看出，进行了串联超前校正后，系统的调整时间<span class="math inline">\(ts\)</span>减小，系统响应的快速性改善；超调量<span class="math inline">\(Mp\)</span>降低，系统阻尼较大；系统的裕度增大，系统稳定性增强。进行了串联滞后校正后，系统的调整时间<span class="math inline">\(ts\)</span>增大，快速性减弱；但是系统超调量<span class="math inline">\(Mp\)</span>减小；提高了稳定裕量，稳定性增强，抑制高频干扰的能力改善。</p><p>实验代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;close all;<br><br>G0 = tf(<span class="hljs-number">4</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]);<br>G_lead = tf([<span class="hljs-number">0.63</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0.26</span>,<span class="hljs-number">1</span>]); <span class="hljs-comment">%超前校正</span><br>G_lag = tf([<span class="hljs-number">10</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">83.33</span>,<span class="hljs-number">1</span>]); <span class="hljs-comment">%滞后校正</span><br><br><span class="hljs-comment">%计算闭环传递函数</span><br>sys1_cl = G0/(<span class="hljs-number">1</span>+G0);<br>sys_lead_cl = (G0 * G_lead)/(<span class="hljs-number">1</span>+G0 * G_lead);<br>sys_lag_cl = (G0 * G_lag)/(<span class="hljs-number">1</span>+G0 * G_lag);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>step(sys1_cl);<span class="hljs-built_in">hold</span> on;<br>step(sys_lead_cl);<span class="hljs-built_in">hold</span> on;<br>step(sys_lag_cl);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;原系统&#x27;</span>,<span class="hljs-string">&#x27;超前校正&#x27;</span>,<span class="hljs-string">&#x27;滞后校正&#x27;</span>);<br><br><span class="hljs-comment">%计算开环传递函数</span><br>sys1_ol = G0;<br>sys_lead_ol= G0 * G_lead;<br>sys_lag_ol = G0 * G_lag;<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>bode(sys1_ol);<span class="hljs-built_in">hold</span> on;<br>bode(sys_lead_ol);<span class="hljs-built_in">hold</span> on;<br>bode(sys_lag_ol);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;原系统&#x27;</span>,<span class="hljs-string">&#x27;超前校正&#x27;</span>,<span class="hljs-string">&#x27;滞后校正&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="实验四采样控制系统研究">实验四：采样控制系统研究</h2><h3 id="实验目的-3">实验目的</h3><ol type="1"><li><p>了解信号的采样与恢复的原理及其过程，并验证香农定理。</p></li><li><p>掌握采样系统的瞬态响应与极点分布的对应关系。</p></li></ol><h3 id="实验原理-3">实验原理</h3><ol type="1"><li><p>采样：把连续信号转换成离散信号的过程叫采样。</p></li><li><p>采样定理：如果选择的采样角频率 <span class="math inline">\(\omega_s\)</span>, 满足 <span class="math inline">\(\omega_s \geq 2 \omega_{\max }\)</span> 条件 ( <span class="math inline">\(\omega_{\max }\)</span> 为连续信号频谱的上限频率), 那 么经采样所获得的脉冲序列可以通过理想的低通滤波器无失真地恢复原连续信号。</p></li><li><p>信号的复现: 零阶保持器是将采样信号转换成连续信号的元件, 是一个低通滤波器。其传递函数: <span class="math inline">\(\frac{1-e^{-T_s}}{s}\)</span>;</p></li><li><p>采样系统的极点分布对瞬态响应的影响: Z 平面内的极点分布在单位圆的不同位置, 其对应的瞬态分量是不同的。</p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031948590.png" alt="image-20230703194816495" /><figcaption aria-hidden="true">image-20230703194816495</figcaption></figure><h3 id="实验内容-3">实验内容</h3><p>在下图中, <span class="math inline">\(D(z)=U(z) / E(z)=1\)</span>, 系统被控对象脉冲传递函数为: <span class="math display">\[G(z)=\frac{Y(z)}{U(z)}=Z\left[\frac{1-e^{-T s}}{s} \frac{4}{s+1}\right]=\frac{4\left(1-e^{-T}\right)}{z-e^{-T}}\]</span> 系统闭环脉冲传递函数为: <span class="math display">\[\Phi(z)=\frac{G_w(z)}{1+G_w(z)}\]</span> 1. 改变采频率 <span class="math inline">\(T=0.01 s, 0.2 s, 0.5 s, 0.6 \mathrm{~s}\)</span>, 用 MATLAB 画出系统在阶跃信号作用下的过渡过程。</p><ol start="2" type="1"><li>在Z平面内讨论，当采样周期T变化时对系统稳定性的影响。</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031949836.png" alt="系统示意图" /><figcaption aria-hidden="true">系统示意图</figcaption></figure><h3 id="实验结果-2">实验结果</h3><p>采样周期<span class="math inline">\(T=0.01,0.2,0.5,0.6s\)</span>时对应的响应图如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306162101027.jpg" /></p><p>可以看出，当<span class="math inline">\(T=0.01,0.2\)</span>时，阶跃响应单调收敛，系统稳定。</p><p>当<span class="math inline">\(T=0.5s\)</span>时，阶跃响应震荡收敛，系统稳定。</p><p>当<span class="math inline">\(T=0.6s\)</span>时，阶跃响应震荡发散，系统不稳定。</p><p>系统闭环脉冲传递函数为： <span class="math display">\[\phi(z)=\frac{4-4e^{-T}}{z+4-5e^{-T}}\]</span> 特征根为 <span class="math display">\[z=5e^{-T}-4\]</span> 系统稳定的条件为<span class="math inline">\(|z|&lt;1\)</span>，即<span class="math inline">\(T&lt;0.51\)</span>。故当<span class="math inline">\(T=0.01,0.2,0.5s\)</span>时，系统是稳定的，而<span class="math inline">\(T=0.6s\)</span>时，系统是不稳定的。</p><p>根据分析可得：当闭环特征根位于单位圆内的正半轴上时，阶跃响应单调收敛，系统稳定；当闭环特征根位于单位圆内的负半轴上时，阶跃响应振荡收敛，系统稳定；当闭环特征根位于单位圆外时，阶跃响应发散，系统不稳定</p><p>在这个实验中，通过对具有开环传递函数的离散系统进行阶跃响应的分析，我得到了以下几点收获：</p><ol type="1"><li><p>离散系统稳定性条件：通过分析<span class="math inline">\(z\)</span>域稳定条件<span class="math inline">\(|z|&lt;1\)</span>，我们可以确定系统的稳定性范围。</p></li><li><p>采样时间对系统稳定性的影响：实验中使用了不同的采样时间T，观察到对应的阶跃响应特性。通过实验结果，我们发现只有当T满足一定条件时，系统才是稳定的。这进一步强调了合适的采样时间选择对系统稳定性的重要性。</p></li></ol><p>这个实验让我深入理解了离散控制系统的稳定性条件和阶跃响应特性。通过对离散系统的实验验证，加深了我对离散控制理论的理解和应用，同时也学习了Matlab的使用技巧。</p><p>实验代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 采样时间T分别为0.01秒，0.2秒，0.5秒，0.6秒</span><br>Ts = [<span class="hljs-number">0.01</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>];<br><span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> T = Ts<br>    syms z<br>    G = (<span class="hljs-number">4</span>*(<span class="hljs-number">1</span>-<span class="hljs-built_in">exp</span>(-T))/(z-<span class="hljs-built_in">exp</span>(-T)) );<br>    Phi = G/(<span class="hljs-number">1</span>+G);<br>    U = z/(z<span class="hljs-number">-1</span>);<br>    Y = U*Phi;<br>    y = iztrans(Y);<br>    fy = matlabFunction(y);<br>    t = <span class="hljs-number">0</span>:T:<span class="hljs-number">10</span>;<br>    n = t./T;<br>    y1=fy(n);<br>    y2=<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(n));<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>);<br>    <span class="hljs-built_in">plot</span>(t,y1,t,y2);<br>    <span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;响应&#x27;</span>,<span class="hljs-string">&#x27;激励&#x27;</span>);<br>    xlabel(<span class="hljs-string">&#x27;时间/s&#x27;</span>);ylabel(<span class="hljs-string">&#x27;响应&#x27;</span>);<br>    title(<span class="hljs-string">&quot;采样频率为T=&quot;</span>+num2str(T)+<span class="hljs-string">&quot;s时的响应&quot;</span>);<br>    <span class="hljs-built_in">i</span>=<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="实验五状态反馈与状态观测器">实验五：状态反馈与状态观测器</h2><h3 id="实验目的-4">实验目的</h3><ol type="1"><li><p>掌握用状态反馈进行极点配置的方法。</p></li><li><p>了解带有状态观测器的状态反馈系统。</p></li></ol><h3 id="实验原理-4">实验原理</h3><p>闭环系统的动态性能与系统的特征根密切相关，在状态空间的分析中可利用状态反馈来配置系统的闭环极点。这种校正手段能提供更多的校正信息，在形成最优控制率、抑制或消除扰动影响、实现系统解耦等方面获得广泛应用。在改善与提高系统性能时不增加系统零、极点，所以不改变系统阶数，实现方便。</p><p>考虑如下图所示的磁悬浮控制系统。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031953356.png" alt="磁悬浮控制系统" /><figcaption aria-hidden="true">磁悬浮控制系统</figcaption></figure><p>根据牛顿力学定律和回路电压定律, 可列写系统微分方程为: <span class="math display">\[\begin{gathered}M \ddot{y}=M g-K \frac{i^2}{y} &amp;(1)\\V=L \dot{i}+i R &amp;(2)\end{gathered}\]</span> 其中 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(M\)</span> 是小球的垂直位置和质量, <span class="math inline">\(g\)</span> 为重力加速度, <span class="math inline">\(K\)</span> 为反映磁力大小的常数, <span class="math inline">\(i 、 V\)</span> 、 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(L\)</span> 分别是回路电流、电压、电阻和电感。</p><p>式 (1) 为非线性微分方程, 需要对其进行线性化处理。假设小球的期望平衡点为 <span class="math inline">\(y_0\)</span>, 在 平衡点上小球保持静止, 其位置 <span class="math inline">\(y\)</span> 的各阶导数为零, 由式 (1) 可得对应的平衡电流为 <span class="math inline">\(i_0=\sqrt{\frac{M g}{K} y_0}\)</span>, 其对应的平衡电压为 <span class="math inline">\(V_0=i_0 R\)</span> 。在 <span class="math inline">\(\left(y_0, i_0\right)\)</span> 处对式 (1) 进行泰勒线性近似, 即: <span class="math display">\[M \ddot{y} \approx M g-\frac{K i_0^2}{y_0}-\left.\frac{2 K i}{y}\right|_{i_0, y_0} \Delta_i+\left.\frac{K i^2}{y^2}\right|_{i_0, y_0} \Delta_y \quad(3)\]</span> 其中 <span class="math inline">\(\Delta_i=i-i_0, \Delta_y=y-y_0\)</span> 。进一步定义 <span class="math inline">\(\Delta_V=V-V_0\)</span>, 可由式 (2) 和 (3) 得到: <span class="math display">\[\begin{gathered}M \ddot{\Delta}_y-\frac{K i_0^2}{y_0^2} \Delta_y+\frac{2 K i_0}{y_0} \Delta_i \approx 0 &amp;(4)\\\Delta_V=L \dot{\Delta}_i+R \Delta_i &amp;(5)\end{gathered}\]</span> 由此, 我们可以在期望平衡点 <span class="math inline">\(y_0\)</span> 附近, 采用线性控制方法进行系统设计, 其中控制变量 是在 <span class="math inline">\(V_0\)</span> 基础上的电压调节量 <span class="math inline">\(\Delta_V\)</span>, 输出变量是实际位置偏离期望平衡点 <span class="math inline">\(y_0\)</span> 的距离 <span class="math inline">\(\Delta_y\)</span> 。</p><h3 id="实验内容-4">实验内容</h3><p>仿真中的参数取值如下表所示。</p><table><thead><tr class="header"><th>变量</th><th>参数</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(y_0\)</span></td><td>0.01 m</td></tr><tr class="even"><td><span class="math inline">\(M\)</span></td><td>0.15 kg</td></tr><tr class="odd"><td><span class="math inline">\(g\)</span></td><td>9.81 <span class="math inline">\(m/s^2\)</span></td></tr><tr class="even"><td><span class="math inline">\(K\)</span></td><td>0.0001</td></tr><tr class="odd"><td><span class="math inline">\(R\)</span></td><td>1 <span class="math inline">\(\Omega\)</span></td></tr><tr class="even"><td><span class="math inline">\(L\)</span></td><td>1<span class="math inline">\(H\)</span></td></tr></tbody></table><h4 id="建立状态模型">建立状态模型</h4><p>针对式 (4) 和 (5), 选择状态变量为 <span class="math inline">\(\mathrm{x}=\left[\begin{array}{lll}\Delta_y &amp; \Delta_y &amp; \Delta_i\end{array}\right]^T\)</span>, 输入变量为 <span class="math inline">\(\Delta_V\)</span>, 输出变量为 <span class="math inline">\(\Delta_\nu\)</span>, 列写状态方程和输出方程。</p><p>状态方程： <span class="math display">\[x=Ax+Bu\]</span> 输出方程： <span class="math display">\[y=Cx+D\]</span> 由题中所给的<span class="math inline">\(\mathbf x=[\Delta_y,\dot{\Delta}_y,\Delta_i]^T\)</span>，且 <span class="math display">\[M \ddot{\Delta}_y-\frac{K i_0^2}{y_0^2} \Delta_y+\frac{2 K i_0}{y_0} \Delta_i \approx 0\]</span></p><p><span class="math display">\[\Delta _v=L\dot{\Delta}+R\Delta_i\]</span></p><p>得： <span class="math display">\[A=\left[\begin{array}{ccc}0 &amp; 1 &amp; 0 \\\frac{K \times i_0^2}{M \times y_0^2} &amp; 0 &amp; -\frac{2 \times K \times i_0}{M \times y_0} \\0 &amp; 0 &amp; -\frac{R}{L}\end{array}\right]\]</span></p><p><span class="math display">\[B=[0,0,1]^T,C=[1,0,0],D=0\]</span></p><p>编程计算：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y0=<span class="hljs-number">0.01</span>;<br>M=<span class="hljs-number">0.15</span>;<br>g=<span class="hljs-number">9.81</span>;<br>K=<span class="hljs-number">0.0001</span>;<br>R=<span class="hljs-number">1</span>;<br>L=<span class="hljs-number">1</span>;<br>i0=<span class="hljs-built_in">sqrt</span>(M*g*y0/K);<br>A=[ <span class="hljs-number">0</span>               <span class="hljs-number">1</span>  <span class="hljs-number">0</span>;<br>    K*i0^<span class="hljs-number">2</span>/(M*y0^<span class="hljs-number">2</span>) <span class="hljs-number">0</span> <span class="hljs-number">-2</span>*K*i0/(M*y0);<br>    <span class="hljs-number">0</span>               <span class="hljs-number">0</span> -R/L]<br>B=[<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;<span class="hljs-number">1</span>/L];<br>C=[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>];<br>D=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>得：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> =<br><br>         <span class="hljs-attribute">0</span>    <span class="hljs-number">1</span>.<span class="hljs-number">0000</span>         <span class="hljs-number">0</span><br>  <span class="hljs-attribute">981</span>.<span class="hljs-number">0000</span>         <span class="hljs-number">0</span>   -<span class="hljs-number">1</span>.<span class="hljs-number">6174</span><br>         <span class="hljs-attribute">0</span>         <span class="hljs-number">0</span>   -<span class="hljs-number">1</span>.<span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><h4 id="绘制输出曲线">绘制输出曲线</h4><p>将系统控制电压设为<span class="math inline">\(V_0\)</span>（即<span class="math inline">\(\Delta_v\)</span>和<span class="math inline">\(\Delta_i\)</span>初值为0）、用手将小球置于偏离预设位置0.01米处（即初值<span class="math inline">\(\Delta_y\)</span>为0.01），绘制系统输出曲线（即松手后小球相对预设位置的偏移量），并根据曲线说明系统稳定性？（提示：可使用lsim命令绘制输出曲线）</p><p>把<span class="math inline">\(\Delta_v,\Delta_i\)</span>初值设为零，<span class="math inline">\(\Delta_y\)</span>初值设为<span class="math inline">\(1\)</span>，绘制系统输出曲线：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031959393.jpeg" alt="系统输出曲线" /><figcaption aria-hidden="true">系统输出曲线</figcaption></figure><p>代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%上一部分的代码</span><br>x0 = [<span class="hljs-number">0.01</span>;<span class="hljs-number">0</span>;<span class="hljs-number">0</span>];     <span class="hljs-comment">%初始状态</span><br>t = <span class="hljs-number">0</span>:<span class="hljs-number">0.001</span>:<span class="hljs-number">1</span>;<br>u = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(t));  <span class="hljs-comment">%零输入</span><br>sys = ss(A,B,C,D);<br>[y,t,x] = lsim(sys,u,t,x0);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,y);<br>xlabel(<span class="hljs-string">&#x27;t(s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;y(m)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;原系统输出曲线&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="可控性分析">可控性分析</h4><p>可以利用<code>ctrb</code>函数求解可控矩阵，有：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">rank(ctrb(A,B))<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span><br><br>     <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>系统可控。</p><h4 id="极点配置">极点配置</h4><p>如果系统可控，假设所有状态变量可测定（即可测出小球的位置、速度和电流），参考输入为<span class="math inline">\(r=0.001m\)</span>，采用状态反馈方法进行系统设计，如下图所示，给出状态反馈向量？系统要求：调节时间小于0.5秒、超调小于5%。（提示：可使用place或acker进行极点配置）。考虑与实验内容2相同的初始状态，绘制系统输出曲线，并验证：</p><ol type="1"><li>是否满足设计要求？</li><li>小球能否稳定在参考位置处，测定稳态误差并分析原因？</li></ol><p>对于该三阶系统，设置一个极点远离虚轴，将系统简化为一个二阶系统。由于要求调节时间小于0.5s，超调量小于5%，故将超调量设为4%，由 <span class="math display">\[M_p=e^{-\frac{\pi\xi}{\sqrt{1-\xi^2}}}\]</span> 可求得<span class="math inline">\(\xi=1/\sqrt 2\)</span>。设置<span class="math inline">\(\omega_n=35\sqrt 2\)</span>，则<span class="math inline">\(t_s=0.114s\)</span>。</p><p>进行状态反馈后，用<code>place</code>函数进行极点配置，得到 <span class="math display">\[K=[-2.16e6,-4.54e4,1069]\]</span> 并在参考输入为<span class="math inline">\(r=0.001m\)</span>得到新的偏移量输出曲线如下:</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307032001124.jpeg" /></p><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%上一部分的代码</span><br>damp = <span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>);<br>wn = <span class="hljs-number">35</span>*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>);              <br>p1 = -damp*wn+wn*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>-damp^<span class="hljs-number">2</span>)*<span class="hljs-number">1</span><span class="hljs-built_in">i</span>;  <br>p2 = -damp*wn-wn*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>-damp^<span class="hljs-number">2</span>)*<span class="hljs-number">1</span><span class="hljs-built_in">i</span>;    <br>p3 = <span class="hljs-number">-1000</span>;<br>K = place(A,B,[p1 p2 p3]);    <span class="hljs-comment">%状态反馈向量</span><br>r = <span class="hljs-number">0.001</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(t));<br>sys_c = ss(A-B*K,B,C,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>lsim(sys_c,r,t,x0);<br>title(<span class="hljs-string">&#x27;极点配置后系统输出曲线&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="" alt="image-20230703200824021" /><figcaption aria-hidden="true">image-20230703200824021</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理Matlab软件作业</title>
    <link href="/2023/06/30/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86Matlab%E8%BD%AF%E4%BB%B6%E4%BD%9C%E4%B8%9A/"/>
    <url>/2023/06/30/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86Matlab%E8%BD%AF%E4%BB%B6%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>《通信原理》课程的实践部分包含了四次Matlab作业，两个Matlab仿真实验和两个上电路板的虚拟仿真实验。涉及到Matlab编程的部分在下面，虚拟仿真实验的文件和报告在全文最后供下载。</p><span id="more"></span><h2 id="matlab作业一线性调制">Matlab作业一：线性调制</h2><p>(同上机实验一)</p><p>分别用计算机仿真AM、DSB、SSB模拟调制、解调过程，其中，调制信号（基带信号）<span class="math inline">\(m(t)=\cos 2\pi f_mt\)</span>。调制信号与载波频率自定，要求调制信号频率远小于载波频率。信号时长为8个调制信号周期。</p><p>输出结果包括：</p><ol type="1"><li><p>输入信号波形；</p></li><li><p>载波波形；</p></li><li><p>已调信号波形及其包络；</p></li><li><p>已调信号功率谱；</p></li><li><p>相干解调下变频之后、低通滤波之前的信号波形；</p></li><li><p>相干解调低通滤波之后的信号波形。</p></li></ol><h3 id="实验结果">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302202166.png" alt="AM调制" /><figcaption aria-hidden="true">AM调制</figcaption></figure><p>AM调制相关的图像如上所示。已调信号的包络完全反映了调制信号的波形。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302202293.png" alt="DSB调制" /><figcaption aria-hidden="true">DSB调制</figcaption></figure><p>DSB调制相关的图像如上所示。已调信号的包络不能完全反映调制信号的波形。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302203053.png" alt="SSB调制" /><figcaption aria-hidden="true">SSB调制</figcaption></figure><p>SSB调制相关的图像如上所示。已调信号的包络也不能完全反映调制信号的波形。</p><h3 id="实验代码">实验代码</h3><h4 id="am">AM</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.001</span>;<br>fm=<span class="hljs-number">1</span>;<br>fc=<span class="hljs-number">100</span>;<br>T=<span class="hljs-number">4</span>;<br>t=<span class="hljs-number">0</span>:dt:T;<br>mt=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);<span class="hljs-comment">%信号源</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;调制信号&#x27;</span>)<br>s_dsb=modulate(mt,fc,<span class="hljs-number">1</span>/dt,<span class="hljs-string">&#x27;am&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t,<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t));<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;载波信号&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t,s_dsb,t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;已调信号波形及其包络&#x27;</span>);<br>rt=s_dsb.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调下变频之后、低通滤波之前的信号波形&#x27;</span>);<br>[f,rf]=T2F(t,rt);<br>[t,rt]=bpf(f,rf,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*fm);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调低通滤波之后的信号波形&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br>    dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>    T=t(<span class="hljs-keyword">end</span>);<br>    df=<span class="hljs-number">1</span>/T;<br>    N=<span class="hljs-built_in">length</span>(st);<br>    f=-N/<span class="hljs-number">2</span> * df : df : N/<span class="hljs-number">2</span>*df-df;<br>    sf = fft(st);<br>    sf=T/N * fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>    dt=<span class="hljs-number">1</span>/Fmx;<br>    N=<span class="hljs-built_in">length</span>(sf);<br>    T=dt*N;<br>    t=<span class="hljs-number">0</span>:dt:T-dt;<br>    sff=ifftshift(sf);<br>    st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">bpf</span><span class="hljs-params">(f,sf,B1,B2)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    T=<span class="hljs-number">1</span>/df;<br>    hf=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(f));<br>    bf=[<span class="hljs-built_in">floor</span>(B1/df):<span class="hljs-built_in">floor</span>(B2/df)];<br>    bf1=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)+bf;<br>    bf2=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)-bf;<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    yf=hf.*sf.*<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f*<span class="hljs-number">0.1</span>*T);<br>    [t,st]=F2T(f,yf);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="dsb">DSB</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.001</span>;<br>fm=<span class="hljs-number">1</span>;<br>fc=<span class="hljs-number">100</span>;<br>T=<span class="hljs-number">4</span>;<br>t=<span class="hljs-number">0</span>:dt:T;<br>mt=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);<span class="hljs-comment">%信号源</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;调制信号&#x27;</span>)<br>s_dsb=modulate(mt,fc,<span class="hljs-number">1</span>/dt,<span class="hljs-string">&#x27;amdsb-tc&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t,<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t));<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;载波信号&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t,s_dsb);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;已调信号波形&#x27;</span>);<br>rt=s_dsb.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调下变频之后、低通滤波之前的信号波形&#x27;</span>);<br>[f,rf]=T2F(t,rt);<br>[t,rt]=bpf(f,rf,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*fm);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调低通滤波之后的信号波形&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br>dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>T=t(<span class="hljs-keyword">end</span>);<br>df=<span class="hljs-number">1</span>/T;<br>N=<span class="hljs-built_in">length</span>(st);<br>f=-N/<span class="hljs-number">2</span> * df : df : N/<span class="hljs-number">2</span>*df-df;<br>sf = fft(st);<br>sf=T/N * fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>dt=<span class="hljs-number">1</span>/Fmx;<br>N=<span class="hljs-built_in">length</span>(sf);<br>T=dt*N;<br>t=<span class="hljs-number">0</span>:dt:T-dt;<br>sff=ifftshift(sf);<br>st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">bpf</span><span class="hljs-params">(f,sf,B1,B2)</span></span><br>df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>T=<span class="hljs-number">1</span>/df;<br>hf=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(f));<br>bf=[<span class="hljs-built_in">floor</span>(B1/df):<span class="hljs-built_in">floor</span>(B2/df)];<br>bf1=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)+bf;<br>bf2=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)-bf;<br>hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>yf=hf.*sf.*<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f*<span class="hljs-number">0.1</span>*T);<br>[t,st]=F2T(f,yf);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h4 id="ssb">SSB</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.001</span>;<br>fm=<span class="hljs-number">1</span>;<br>fc=<span class="hljs-number">100</span>;<br>T=<span class="hljs-number">4</span>;<br>t=<span class="hljs-number">0</span>:dt:T;<br>mt=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);<span class="hljs-comment">%信号源</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;调制信号&#x27;</span>)<br>s_dsb=modulate(mt,fc,<span class="hljs-number">1</span>/dt,<span class="hljs-string">&#x27;amssb&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t,<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t));<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;载波信号&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t,s_dsb);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;已调信号波形&#x27;</span>);<br>rt=s_dsb.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调下变频之后、低通滤波之前的信号波形&#x27;</span>);<br>[f,rf]=T2F(t,rt);<br>[t,rt]=bpf(f,rf,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*fm);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调低通滤波之后的信号波形&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br>    dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>    T=t(<span class="hljs-keyword">end</span>);<br>    df=<span class="hljs-number">1</span>/T;<br>    N=<span class="hljs-built_in">length</span>(st);<br>    f=-N/<span class="hljs-number">2</span> * df : df : N/<span class="hljs-number">2</span>*df-df;<br>    sf = fft(st);<br>    sf=T/N * fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>    dt=<span class="hljs-number">1</span>/Fmx;<br>    N=<span class="hljs-built_in">length</span>(sf);<br>    T=dt*N;<br>    t=<span class="hljs-number">0</span>:dt:T-dt;<br>    sff=ifftshift(sf);<br>    st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">bpf</span><span class="hljs-params">(f,sf,B1,B2)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    T=<span class="hljs-number">1</span>/df;<br>    hf=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(f));<br>    bf=[<span class="hljs-built_in">floor</span>(B1/df):<span class="hljs-built_in">floor</span>(B2/df)];<br>    bf1=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)+bf;<br>    bf2=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)-bf;<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    yf=hf.*sf.*<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f*<span class="hljs-number">0.1</span>*T);<br>    [t,st]=F2T(f,yf);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h2 id="matlab作业二非线性调制">Matlab作业二：非线性调制</h2><p>用计算机仿真FM调制，其中，调制信号（基带信号）<span class="math inline">\(m(t)=\cos 2\pi f_mt\)</span>。调制信号与载波频率、幅度、调制指数等参数自定，要求调制信号频率远小于载波频率。信号时长为4个调制信号周期。</p><p>画出以下结果：</p><ol type="1"><li><p>输入信号波形；</p></li><li><p>载波波形；</p></li><li><p>已调信号波形及其包络；</p></li><li><p>试用fft分析已调波形功率谱（附加题，只加分，不减分）。</p></li></ol><h3 id="实验结果-1">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232226555.jpg" alt="FM调制图像" /><figcaption aria-hidden="true">FM调制图像</figcaption></figure><h3 id="实验代码-1">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 参数设置</span><br>fm = <span class="hljs-number">100</span>;               <span class="hljs-comment">% 调制信号频率</span><br>fc = <span class="hljs-number">1000</span>;             <span class="hljs-comment">% 载波频率</span><br>kf = <span class="hljs-number">800</span>;               <span class="hljs-comment">% 调制指数</span><br>fs = <span class="hljs-number">20000</span>;            <span class="hljs-comment">% 采样率</span><br>t = <span class="hljs-number">0</span>: <span class="hljs-number">1</span>/fs :<span class="hljs-number">4</span>/fm<span class="hljs-number">-1</span>/fs;  <span class="hljs-comment">% 时间向量，4个调制信号周期</span><br><br><span class="hljs-comment">% 生成调制信号</span><br>m = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);    <span class="hljs-comment">% 基带信号</span><br><br><span class="hljs-comment">% 生成载波信号</span><br>c = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);    <span class="hljs-comment">% 载波信号</span><br><br><span class="hljs-comment">% FM 调制</span><br>s = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t + kf * <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * fm * t) / fm);<br><br><span class="hljs-comment">% 绘制输入信号波形</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t, m);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>title(<span class="hljs-string">&#x27;输入信号波形 (基带信号)&#x27;</span>);<br>grid on;<br><br><span class="hljs-comment">% 绘制载波波形</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t, c);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>title(<span class="hljs-string">&#x27;载波波形&#x27;</span>);<br>grid on;<br><br><span class="hljs-comment">% 绘制调制信号波形及其包络</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t, s);<br><span class="hljs-built_in">hold</span> on;<br>envelope = <span class="hljs-built_in">abs</span>(hilbert(s));    <span class="hljs-comment">% 计算调制信号包络</span><br><span class="hljs-comment">% plot(t, envelope, &#x27;r&#x27;);</span><br><span class="hljs-built_in">hold</span> off;<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>title(<span class="hljs-string">&#x27;调制信号波形及其包络&#x27;</span>);<br><span class="hljs-comment">% legend(&#x27;调制信号&#x27;, &#x27;包络&#x27;);</span><br>grid on;<br><br><span class="hljs-comment">% FFT 分析已调波形的功率谱</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>L = <span class="hljs-built_in">length</span>(s);                  <span class="hljs-comment">% 信号长度</span><br>f = (-fs/<span class="hljs-number">2</span>:fs/L:fs/<span class="hljs-number">2</span>-fs/L);     <span class="hljs-comment">% 频率向量</span><br>S = fftshift(fft(s));           <span class="hljs-comment">% 进行 FFT</span><br>P = <span class="hljs-built_in">abs</span>(S).^<span class="hljs-number">2</span> / L;              <span class="hljs-comment">% 计算功率谱</span><br><span class="hljs-built_in">plot</span>(f, P);<br>xlabel(<span class="hljs-string">&#x27;频率 (Hz)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;功率&#x27;</span>);<br>title(<span class="hljs-string">&#x27;已调波形功率谱&#x27;</span>);<br>grid on;<br></code></pre></td></tr></table></figure><h2 id="matlab作业三模拟信号数字化">Matlab作业三：模拟信号数字化</h2><p>用计算机仿真模拟信号数字化系统过程。量化器为均匀量化，量化范围<span class="math inline">\([-1,1]\)</span>V；输入信号假设服从均匀分布。二进制信道传输误比特率<span class="math inline">\(P=10^{-5}\)</span>。</p><p>分别仿真得到以下曲线，并将它们绘制在一张图中：</p><ol type="1"><li>量化比特<span class="math inline">\(N=11\)</span>（含符号位）、采用自然码编码时，作出输入信号平均功率从<span class="math inline">\(-60dBW\)</span>至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li><li>量化比特<span class="math inline">\(N=11\)</span>（含符号位）、采用折叠码编码时，作出输入信号平均功率从-60dBW至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li><li>量化比特<span class="math inline">\(N=12\)</span>（含符号位）、采用自然码编码时，作出输入信号平均功率从-60dBW至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li><li>量化比特<span class="math inline">\(N=12\)</span>（含符号位）、采用折叠码编码时，作出输入信号平均功率从-60dBW至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li></ol><p>关键：如何统计输出信噪比，关键是统计平均输出噪声功率按照输入信号平均功率生成多个（如10000）个样值，对每一个样值作为输入信号，进行量化、编码、信道传输（产生随机误码）和译码，将恢复出的样值与输入样值作差取平方得到样值误差功率。最后，取平均得到平均输出噪声功率。</p><h3 id="实验结果-2">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232235729.jpg" alt="仿真结果图" /><figcaption aria-hidden="true">仿真结果图</figcaption></figure><p>可以看出：在输入信号功率不大时，信噪比（dB）和功率（dB）成正比。当功率较大时，因为超出了量化范围，所以信噪比急剧减小。</p><h3 id="实验代码-2">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 信号数字化系统仿真模拟</span><br><br>P_in = <span class="hljs-built_in">logspace</span>(<span class="hljs-number">-3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">% 平均功率从-60dBW至0dBW（电阻1欧）间变化</span><br>SNR1=PCM(P_in,<span class="hljs-number">11</span>,<span class="hljs-number">0</span>);<br>SNR2=PCM(P_in,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>);<br>SNR3=PCM(P_in,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>);<br>SNR4=PCM(P_in,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>);<br>loglog(P_in,SNR1,<span class="hljs-string">&#x27;r.-&#x27;</span>,P_in,SNR2,<span class="hljs-string">&#x27;g.-&#x27;</span>,P_in,SNR3,<span class="hljs-string">&#x27;b.-&#x27;</span>,P_in,SNR4,<span class="hljs-string">&#x27;k.-&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;11位自然码&#x27;</span>, <span class="hljs-string">&#x27;11位折叠码&#x27;</span>,<span class="hljs-string">&#x27;12位自然码&#x27;</span>,<span class="hljs-string">&#x27;12位折叠码&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;输入信号功率&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;信噪比&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SNRs</span> = <span class="hljs-title">PCM</span><span class="hljs-params">(P_in,bits,TYPE)</span></span><br>    <span class="hljs-comment">% 编码，计算信噪比</span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">%   P_in：输入信号平均功率测试点</span><br>    <span class="hljs-comment">%   bits：量化比特数（含符号位）</span><br>    <span class="hljs-comment">%   TYPE：码型，0为自然码，1为折叠码</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">%   SNRs：对每个P_in的元素而言的平均噪声功率</span><br>    <br><br>    qrange = <span class="hljs-number">1</span>;  <span class="hljs-comment">% 量化范围</span><br><br>    L=<span class="hljs-built_in">length</span>(P_in);<br>    SNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L <span class="hljs-comment">%对每个功率P_in</span><br>    <br>        <span class="hljs-comment">% 生成符合功率要求的输入信号</span><br>        x_num=<span class="hljs-number">10000</span>;<br>        x = unifrnd(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,x_num);<br>        Px = sum(x .* x) / x_num;<br>        k = <span class="hljs-built_in">sqrt</span>(P_in(<span class="hljs-built_in">i</span>) / Px);<br>        x = x.*k;<br>        <br>        <span class="hljs-comment">%量化x</span><br>        delta = qrange / (<span class="hljs-number">2</span>^(bits<span class="hljs-number">-1</span>));<br>        x_level=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">abs</span>(x)./delta);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(x_level)<br>            <span class="hljs-keyword">if</span> x_level(<span class="hljs-built_in">j</span>)&gt;<span class="hljs-number">2</span>^(bits<span class="hljs-number">-1</span>)<br>                x_level(<span class="hljs-built_in">j</span>)=<span class="hljs-number">2</span>^(bits<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        x_q = <span class="hljs-built_in">sign</span>(x) .* (x_level .* delta + <span class="hljs-number">0.5</span>*delta);<br>        y_signal=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,x_num);<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:x_num <span class="hljs-comment">%对x信号中的每个点</span><br>            <span class="hljs-comment">%编码</span><br>            x_signal=x_q(<span class="hljs-built_in">j</span>);<br><br>            <span class="hljs-keyword">if</span>(x_signal&gt;<span class="hljs-number">0</span>)<br>                x_code=<span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-keyword">else</span><br>                x_code=<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">end</span><br>            x_bin=dec2bin(x_level(<span class="hljs-built_in">j</span>),bits<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">if</span>(TYPE==<span class="hljs-number">0</span>) <span class="hljs-comment">%自然码把对称码按位反转</span><br>                x_bin=flip(x_bin);<br>            <span class="hljs-keyword">end</span><br>            x_code=strcat(x_code,x_bin);<br>            <span class="hljs-comment">%传输</span><br>            BER = <span class="hljs-number">1e-5</span>;  <span class="hljs-comment">% 误比特率</span><br>            y_code=bsc(x_code,BER);<br>            <span class="hljs-comment">%译码</span><br>            y_bin=extractAfter(y_code,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(TYPE==<span class="hljs-number">0</span>) <span class="hljs-comment">%自然码把对称码按位反转</span><br>                y_bin=flip(y_bin);<br>            <span class="hljs-keyword">end</span><br>            y_level=bin2dec(y_bin);<br>            y_signal(<span class="hljs-built_in">j</span>)=y_level .* delta + <span class="hljs-number">0.5</span>*delta;<br>            <span class="hljs-keyword">if</span>(y_code(<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;0&#x27;</span>) <br>                 y_signal(<span class="hljs-built_in">j</span>) = y_signal(<span class="hljs-built_in">j</span>) * <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        error = y_signal - x;<br>        P_error = sum(error .* error) / x_num;<br>        SNR(<span class="hljs-built_in">i</span>)=P_in(<span class="hljs-built_in">i</span>) / P_error;<br>    <span class="hljs-keyword">end</span><br>    SNRs=SNR;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">bsc</span><span class="hljs-params">(x, BER)</span></span><br>    <span class="hljs-comment">% 二进制对称信道传输</span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">%   x：输入比特序列（0或1向量）</span><br>    <span class="hljs-comment">%   BER：误比特率</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">%   y：输出比特序列（0或1向量）</span><br>    s=<span class="hljs-built_in">size</span>(x);<br>    y=<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(x));<br>    y=char(y);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:s(<span class="hljs-number">2</span>)<br>        flag=<span class="hljs-built_in">rand</span>();<br>        <span class="hljs-keyword">if</span>(flag&gt;BER)<br>            y(<span class="hljs-built_in">i</span>)=x(<span class="hljs-built_in">i</span>);<br>        <span class="hljs-keyword">else</span><br>            temp=[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>];<br>            y(<span class="hljs-built_in">i</span>)=temp((x(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">flip</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-comment">%把01字符串序列反转</span><br>    <span class="hljs-comment">%输入：</span><br>    <span class="hljs-comment">%   x：原序列</span><br>    <span class="hljs-comment">%输出：</span><br>    <span class="hljs-comment">%   y：反转序列</span><br>    L=<span class="hljs-built_in">length</span>(x);<br>    y=x;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L<br>        <span class="hljs-keyword">if</span> x(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;1&#x27;</span><br>            y(<span class="hljs-built_in">i</span>)=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            y(<span class="hljs-built_in">i</span>)=<span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="matlab作业四数字信号基带传输">Matlab作业四：数字信号基带传输</h2><ol type="1"><li><p>用计算机画出升余弦滤波器时域、频域曲线；以及根升余弦滤波器时域、频域曲线。参数自定。</p></li><li><p>试用matlab仿真单极性非归零码、双极性非归零码的误码率，并将其误码率曲线绘制在一张图中。输入信噪比（x轴）变化范围为0:1:15dB，绘图函数<code>semilogy</code>，每个信噪比统计误码率时仿真的点数为1e5。（注：基本方法是随机产生1e5个二进制比特，然后进行码型映射，再给码型叠加噪声（按照信噪比计算噪声功率），最后进行判决，统计误码率）。</p></li></ol><h3 id="实验结果-3">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232242272.jpg" alt="滤波器" /><figcaption aria-hidden="true">滤波器</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232243276.jpg" alt="误码率" /><figcaption aria-hidden="true">误码率</figcaption></figure><h3 id="实验代码-3">实验代码</h3><h4 id="滤波器实验">滤波器实验</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear all;<br>Fs = <span class="hljs-number">100</span>;<br>Ts = <span class="hljs-number">0.1</span>;<br>t = <span class="hljs-number">-5</span>*Ts:<span class="hljs-number">1</span>/Fs:<span class="hljs-number">5</span>*Ts;<br><br><span class="hljs-built_in">beta</span> = <span class="hljs-number">0.5</span>; <span class="hljs-comment">%升余弦滤波器参数</span><br><br>sinc_t=sinc(t/Ts)/Ts; <span class="hljs-comment">%系数</span><br>rc_tnum=<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">pi</span>*<span class="hljs-built_in">beta</span>*t/Ts); <span class="hljs-comment">%分子</span><br>rc_tden=<span class="hljs-number">1</span>-(<span class="hljs-number">2</span>*<span class="hljs-built_in">beta</span>*t/Ts).^<span class="hljs-number">2</span>; <span class="hljs-comment">%分母</span><br>pn=<span class="hljs-built_in">find</span>(<span class="hljs-built_in">abs</span>(rc_tden)&lt;<span class="hljs-number">1e-8</span>); <span class="hljs-comment">%除以零特判</span><br>rc_tden(pn) = <span class="hljs-built_in">inf</span>;<br>rc_t = rc_tnum./rc_tden;<br>gt = sinc_t .* rc_t;<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,gt);<br>xlabel(<span class="hljs-string">&#x27;时间&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;h(t)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;升余弦滤波器时域波形&#x27;</span>);<br><br>[f,sf]=T2F(t,gt);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(f,<span class="hljs-built_in">abs</span>(sf));<br>xlabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;H(w)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;升余弦滤波器频域波形&#x27;</span>);<br><br>sf2=<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(sf)) .* <span class="hljs-built_in">exp</span>(<span class="hljs-built_in">i</span>*<span class="hljs-built_in">angle</span>(sf));<br>[t2,st2]=F2T(f,sf2);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t2,st2);<br>xlabel(<span class="hljs-string">&#x27;时间&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;h(t)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;根升余弦滤波器时域波形&#x27;</span>);<br><br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(f,<span class="hljs-built_in">abs</span>(sf2));<br>xlabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;H(w)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;根升余弦滤波器频域波形&#x27;</span>);<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br><span class="hljs-comment">%   时域转频域</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       t：时间</span><br><span class="hljs-comment">%       st：时间函数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%      f：频率</span><br><span class="hljs-comment">%      sf：频率函数</span><br>    <br>    dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>    T=t(<span class="hljs-keyword">end</span>)-t(<span class="hljs-number">1</span>);<br>    df=<span class="hljs-number">1.0</span>/T;<br>    N=<span class="hljs-built_in">length</span>(st);<br>    f=((-N/<span class="hljs-number">2</span>) * df):df:(((N/<span class="hljs-number">2</span>)*df)-df);<br>    sf = fft(st);<br>    sf=T/N*fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>    dt=<span class="hljs-number">1</span>/Fmx;<br>    N=<span class="hljs-built_in">length</span>(sf);<br>    T=dt*N;<br>    t=-T/<span class="hljs-number">2</span>:dt:T/<span class="hljs-number">2</span>-dt;<br>    sff=ifftshift(sf);<br>    st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="误码率实验">误码率实验</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 仿真参数设置</span><br>SNR_dB = <span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">15</span>;     <span class="hljs-comment">% 信噪比范围（dB）</span><br>numBits = <span class="hljs-number">1e5</span>;       <span class="hljs-comment">% 仿真比特数</span><br><br>BER_NRZ = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(SNR_dB));<br>BER_RZ = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(SNR_dB));<br><br><span class="hljs-comment">% 随机产生比特序列</span><br>bits = randi([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-number">1</span>, numBits);<br><br><span class="hljs-comment">% 进行误码率仿真</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(SNR_dB)<br>    <span class="hljs-comment">% 生成高斯噪声</span><br>    noisePower = <span class="hljs-number">10</span>^(-SNR_dB(<span class="hljs-built_in">i</span>)/<span class="hljs-number">10</span>);   <span class="hljs-comment">% 噪声功率</span><br>    noise = <span class="hljs-built_in">sqrt</span>(noisePower) * <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, numBits);<br>    <br>    <span class="hljs-comment">% 单极性非归零码</span><br>    signal_NRZ = bits;     <br>    receivedSignal_NRZ = signal_NRZ + noise;<br>    <span class="hljs-comment">% 判决</span><br>    decodedBits_NRZ = receivedSignal_NRZ &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">% 误码率</span><br>    BER_NRZ(<span class="hljs-built_in">i</span>) = sum(bits ~= decodedBits_NRZ) / numBits;<br>    <br>    <span class="hljs-comment">% 双极性非归零码</span><br>    signal_RZ = <span class="hljs-number">2</span>*bits - <span class="hljs-number">1</span>;   <br>    receivedSignal_RZ = signal_RZ + noise;<br>    <span class="hljs-comment">% 判决</span><br>    decodedBits_RZ = receivedSignal_RZ &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">% 统计误码率</span><br>    BER_RZ(<span class="hljs-built_in">i</span>) = sum(bits ~= decodedBits_RZ) / numBits;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 绘制误码率曲线</span><br>semilogy(SNR_dB, BER_NRZ, <span class="hljs-string">&#x27;b-o&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_dB, BER_RZ, <span class="hljs-string">&#x27;r-*&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">hold</span> off;<br><br>xlabel(<span class="hljs-string">&#x27;信噪比 (dB)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;误码率&#x27;</span>);<br>title(<span class="hljs-string">&#x27;单极性非归零码（NRZ）与双极性非归零码（RZ）误码率曲线&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;NRZ&#x27;</span>, <span class="hljs-string">&#x27;RZ&#x27;</span>);<br>grid on;<br></code></pre></td></tr></table></figure><h2 id="上机实验二pcm-编码调制的-matlab-实现">上机实验二：PCM 编码调制的 MATLAB 实现</h2><p>设模拟信号<span class="math inline">\(x(t)=0.1\cos(0.15t)+1.5\sin (2.5t)+0.5\cos(4t)\)</span>，选取适当的抽样频率（需要满足无失真采样要求）。</p><ol type="1"><li>采用均匀量化，量化层数为各自学号的后四位mod（4）+4（例如学号为 19835412，后四位5412除以4求余为0，再加4为4），请设计均匀量化编码程序。</li><li>采用非均匀量化，设计A律13折线法的PCM编码程序</li></ol><p>要求输出：</p><ol type="1"><li>原始输入信号</li><li>抽样后信号</li><li>量化输出信号</li><li>编码结果</li></ol><h3 id="实验结果-4">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304121656595.jpg" alt="均匀量化" /><figcaption aria-hidden="true">均匀量化</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304121656059.jpg" alt="A律13折线量化" /><figcaption aria-hidden="true">A律13折线量化</figcaption></figure><h3 id="实验代码-4">实验代码</h3><h4 id="均匀量化">均匀量化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.01</span>;<br>t=[<span class="hljs-number">0</span>:dt:<span class="hljs-number">20</span>];<br>xt=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,xt);<br>title(<span class="hljs-string">&quot;均匀量化原始输入信号&quot;</span>);<br><br><span class="hljs-comment">%抽样</span><br>fs=<span class="hljs-number">4</span>;<br>sdt=<span class="hljs-number">1</span>/fs;<br>t1=[<span class="hljs-number">0</span>:sdt:<span class="hljs-number">20</span>];<br>xt1=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t1)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t1)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t1);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>stem(t1,xt1,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化抽样后信号&quot;</span>);<br><br><span class="hljs-comment">%量化</span><br>N=<span class="hljs-built_in">mod</span>(<span class="hljs-number">5412</span>,<span class="hljs-number">4</span>)+<span class="hljs-number">4</span>; <span class="hljs-comment">%量化层数 为学号后四位%4+4</span><br>a=<span class="hljs-number">2.1</span>; <span class="hljs-comment">%幅度最大值</span><br>reg=[-a,a];<br>delta=(<span class="hljs-number">2</span>*a/N);<br>x_qt=xt1;<br>bit=<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(N));<br>code=<span class="hljs-string">&#x27;&#x27;</span>;<br>L=<span class="hljs-built_in">length</span>(t1);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>:N<br>        low=-a+<span class="hljs-built_in">j</span>*delta;<br>        high=low+delta;<br>        <span class="hljs-keyword">if</span> (low&lt;=xt1(<span class="hljs-built_in">i</span>) &amp;&amp; xt1(<span class="hljs-built_in">i</span>)&lt;=high)<br>            x_qt(<span class="hljs-built_in">i</span>)=low+delta/<span class="hljs-number">2</span>;<br>            code=strcat(code,dec2bin(<span class="hljs-built_in">j</span>,bit));<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>stem(t1,x_qt,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化输出信号&quot;</span>);<br>code<br><br>code_in_num=<span class="hljs-built_in">zeros</span>(bit*L);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:bit*L<br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>stem(<span class="hljs-number">1</span>:bit*L,code_in_num,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化输出编码&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="非均匀量化">非均匀量化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.01</span>;<br>t=[<span class="hljs-number">0</span>:dt:<span class="hljs-number">10</span>];<br>xt=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,xt);<br>title(<span class="hljs-string">&quot;A律13折线原始输入信号&quot;</span>);<br><br>fs=<span class="hljs-number">4</span>;<br>sdt=<span class="hljs-number">1</span>/fs;<br>t1=[<span class="hljs-number">0</span>:sdt:<span class="hljs-number">20</span>];<br>xt1=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t1)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t1)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t1);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>stem(t1,xt1,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;A律13折线抽样后信号&quot;</span>);<br><br>code=<span class="hljs-string">&#x27;&#x27;</span>;<br>a=<span class="hljs-number">2.1</span>;<br>L=<span class="hljs-built_in">length</span>(xt1);<br>x_qt=<span class="hljs-built_in">zeros</span>(L);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L<br>    codei=<span class="hljs-string">&#x27;&#x27;</span>;<br>    flag=<span class="hljs-number">0</span>;<br>    x=<span class="hljs-built_in">floor</span>(xt1(<span class="hljs-built_in">i</span>)/a*<span class="hljs-number">2048</span>);<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>)<br>        codei=strcat(codei,<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">%符号码</span><br>        flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        codei=strcat(codei,<span class="hljs-string">&#x27;0&#x27;</span>);<br>        x=-x;<br>        flag=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">end</span><br>    <br>    start_level=[<span class="hljs-number">0</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>,<span class="hljs-number">1024</span>,<span class="hljs-number">2048</span>]; <span class="hljs-comment">%段落码电平范围</span><br>    interval   =[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>,  <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>]; <span class="hljs-comment">%量化间隔</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:(<span class="hljs-built_in">length</span>(start_level)<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">if</span>(start_level(<span class="hljs-built_in">j</span>)&lt;x &amp;&amp; x&lt;=start_level(<span class="hljs-built_in">j</span>+<span class="hljs-number">1</span>))<br>            codei=strcat(codei,dec2bin(<span class="hljs-built_in">j</span>,<span class="hljs-number">3</span>));<span class="hljs-comment">%段落码</span><br>            temp=<span class="hljs-built_in">floor</span>( ( x-start_level(<span class="hljs-built_in">j</span>) )/interval(<span class="hljs-built_in">j</span>) );<br>            codei=strcat(codei,dec2bin(temp,<span class="hljs-number">4</span>));<span class="hljs-comment">%段内码</span><br>            x_qt(<span class="hljs-built_in">i</span>)=flag*(start_level(<span class="hljs-built_in">j</span>)+interval(<span class="hljs-built_in">j</span>)*(temp+<span class="hljs-number">0.5</span>))*(a/<span class="hljs-number">2048</span>);<br>            <span class="hljs-comment">%恢复量化电平</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">end</span>   <br>    <span class="hljs-keyword">end</span><br>    code=strcat(code,codei);<br><span class="hljs-keyword">end</span><br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>stem(t1,x_qt,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;A律13折线量化输出信号&quot;</span>);<br><br>bit=<span class="hljs-number">8</span>;<br>code_in_num=<span class="hljs-built_in">zeros</span>(bit*L);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:bit*L<br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>stem(<span class="hljs-number">1</span>:bit*L,code_in_num,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化输出编码&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="仿真实验资料">仿真实验资料</h2><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C.zip">通信原理虚拟仿真资料下载</a></p><p>提醒一下哈，这个软件很逆天，你直接双击这个文件是打不开的，得先到那个专用的网站里打开实验，然后等软件弹出，再在软件里面通过“打开文件”的方式才能打开这个文件。</p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理实验报告</title>
    <link href="/2023/06/30/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/06/30/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>数图成绩出来了，实验是满分，所以把报告和代码发出来给大家参考一下。</p><span id="more"></span><h2 id="实验一-图像变换实验">实验一 图像变换实验</h2><h3 id="实验目的">实验目的</h3><p>学会对图像进行傅立叶等变换，在频谱上对图像进行分析，增进对图像频域上的感性认识，并用图像变换进行压缩。</p><h3 id="实验内容">实验内容</h3><p>对Lena或cameraman图像进行傅立叶、离散余弦、哈达玛变换。在频域，对比他们的变换后系数矩阵的频谱情况，进一步，通过逆变换观察不同变换下的图像重建质量情况。</p><h3 id="实验要求">实验要求</h3><p>实验采用获取的图像，为灰度图像，该图像每象素由8比特表示。具体要求如下：</p><ol type="1"><li><p>对图像进行傅立叶变换、获得变换后的系数矩阵；</p></li><li><p>将傅立叶变换后系数矩阵的频谱用图像输出，观察频谱；</p></li><li><p>通过设定门限，将系数矩阵中95%的（小值）系数置为0，对图像进行反变换，获得逆变换后图像；</p></li><li><p>观察逆变换后图像质量，并比较原始图像与逆变后的峰值信噪比（PSNR）。</p></li><li><p>对输入图像进行离散余弦、哈达玛变换，重复步骤1-5；</p></li><li><p>比较三种变换的频谱情况、以及逆变换后图像的质量（PSNR）。</p></li><li><p>比较相同图像质量（PSNR）下，步骤（3）中三种变换的系数矩阵，最少需要保留的非零元素个数。一般而言，需要保留的非零元素越少，则将这种变换用于图像编码，越易于节省码率。</p></li></ol><h3 id="实验原理">实验原理</h3><p>图像傅里叶变换（Fourier Transform）是一种常用的信号处理技术，用于将图像从空域（时域）转换到频域。它基于傅里叶分析的原理，将图像表示为一系列频率分量的和，从而揭示了图像中不同频率的信息。</p><p>图像傅里叶变换的基本思想是，将一个图像视为不同频率的正弦和余弦波的叠加。通过将图像转换到频域，我们可以得到图像的频谱信息，即不同频率分量的幅度和相位。这使得我们能够分析图像中的高频、低频等特征，并进行一些相关的处理。、</p><p>离散余弦变换将一个图像从空域（时域）转换为频域。与傅里叶变换类似，它将图像表示为一系列频率分量的和，但DCT更适合于图像压缩应用，因为它将图像的大部分能量集中在较低频率分量上。</p><p>图像哈达玛变换的基本原理是基于哈达玛矩阵的线性变换。哈达玛矩阵是一种特殊的正交变换矩阵，具有正交、可逆和对称的性质。</p><h3 id="实验结果与分析">实验结果与分析</h3><p>首先将系数矩阵中95%的（小值）系数置为0，对图像进行反变换，获得逆变换后图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302028143.jpg" alt="e1" /><figcaption aria-hidden="true">e1</figcaption></figure><table><thead><tr class="header"><th>变换类型</th><th>离散傅里叶变换</th><th>离散余弦变换</th><th>哈达玛变换</th></tr></thead><tbody><tr class="odd"><td>峰值信噪比PSNR</td><td>30.2933</td><td>31.5249</td><td>28.5448</td></tr></tbody></table><p>然后固定取门限后图像的峰值信噪比为PSNR=28.01，得各种变换需要置0的系数比例为：</p><table><thead><tr class="header"><th>变换类型</th><th>离散傅里叶变换</th><th>离散余弦变换</th><th>哈达玛变换</th></tr></thead><tbody><tr class="odd"><td>置0的系数比例</td><td>0.975</td><td>0.9825</td><td>0.9575</td></tr></tbody></table><p>可以看出，在三种变换中，离散余弦变换DCT是最适合进行图像压缩的一种。由频谱可以看出，傅里叶变换和离散余弦变换的频谱均有较明显的能量集中特性，变换域大值聚集在一小块区域，表现出来就是区域灰度值远高于其他区域，呈现亮色。由于这种特性，在变换域去掉 95%小值不至于对原图像效果产生太大影响</p><h3 id="实验代码">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">figure</span>=imread(<span class="hljs-string">&#x27;lena_std.tif&#x27;</span>); <br>gray_figure = rgb2gray(<span class="hljs-built_in">figure</span>);<span class="hljs-comment">%转换为灰度</span><br>gray_figure = im2uint8(gray_figure);<span class="hljs-comment">%转换为8bit</span><br>Size=<span class="hljs-built_in">size</span>(gray_figure);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>)<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>imshow(gray_figure);<br>title(<span class="hljs-string">&#x27;Lena 原图&#x27;</span>);<br><br>tic<br>fourier = fft2(gray_figure); <br>shiftf=fftshift(fourier); <span class="hljs-comment">%将零频分量移到频谱中心</span><br>toc<br>R=<span class="hljs-built_in">real</span>(shiftf); <span class="hljs-comment">% 傅立叶变换实部</span><br>I=<span class="hljs-built_in">imag</span>(shiftf); <span class="hljs-comment">% 傅立叶变换虚部</span><br>spec = <span class="hljs-built_in">sqrt</span>(R.^<span class="hljs-number">2</span>+I.^<span class="hljs-number">2</span>); <span class="hljs-comment">% 幅值</span><br>spec_norm =(spec-<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(spec)))/(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(spec))-<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(spec)))*<span class="hljs-number">255</span>; <span class="hljs-comment">% 归一化</span><br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>imshow(spec_norm); <span class="hljs-comment">% 显示原图像的频谱</span><br>title(<span class="hljs-string">&#x27;傅立叶变换的频谱图&#x27;</span>);<br><br>shiftf=threshold(shiftf,<span class="hljs-number">0.975</span>);<span class="hljs-comment">%0.975</span><br>refigure=ifft2(ifftshift(shiftf))/<span class="hljs-number">256</span> ;<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>imshow(refigure);<br>imwrite(refigure, <span class="hljs-string">&#x27;E1_output_image.tif&#x27;</span>, <span class="hljs-string">&#x27;tif&#x27;</span>);<br>title(<span class="hljs-string">&#x27;取门限后傅里叶变换还原图像&#x27;</span>);<br>PSNR = grayPSNR(gray_figure,<span class="hljs-number">256</span>*refigure,<span class="hljs-number">8</span>); <span class="hljs-comment">%计算 PSNR</span><br>PSNR<br><br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>imshow(gray_figure);<br>title(<span class="hljs-string">&#x27;Lena 原图&#x27;</span>);<br><br>tic<br>DCT=dct2(gray_figure); <span class="hljs-comment">%离散余弦变换</span><br>toc<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>imshow(<span class="hljs-built_in">abs</span>(DCT),[<span class="hljs-number">0</span> <span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;离散余弦变换&#x27;</span>)<br><br>DCT=threshold(DCT,<span class="hljs-number">0.9825</span>);<span class="hljs-comment">%0.9825</span><br>refigure=idct2(DCT);<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<br>imshow(refigure,[<span class="hljs-number">0</span> <span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;取门限后离散余弦变换还原图像&#x27;</span>);<br>PSNR = grayPSNR(gray_figure,refigure,<span class="hljs-number">8</span>); <span class="hljs-comment">%计算 PSNR</span><br>PSNR<br><br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>);<br>imshow(gray_figure);<br>title(<span class="hljs-string">&#x27;Lena 原图&#x27;</span>);<br><br>tic<br>H=<span class="hljs-built_in">hadamard</span>(Size(<span class="hljs-number">1</span>));<span class="hljs-comment">%哈达玛矩阵</span><br>gray_figure=double(gray_figure);<br>DHT=H*gray_figure*H./(<span class="hljs-number">512</span>^<span class="hljs-number">2</span>);<br>toc<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>);<br>imshow(DHT*<span class="hljs-number">2</span>^<span class="hljs-number">10</span>,[<span class="hljs-number">0</span>,<span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;哈达玛变换&#x27;</span>)<br><br>DHT=threshold(DHT,<span class="hljs-number">0.9575</span>);<span class="hljs-comment">%0.9575</span><br>refigure=H*DHT*H;<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>);<br>imshow(refigure,[<span class="hljs-number">0</span>,<span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;取门限后哈达玛变换还原图像&#x27;</span>);<br>PSNR = grayPSNR(gray_figure,refigure,<span class="hljs-number">8</span>); <span class="hljs-comment">%计算 PSNR</span><br>PSNR<br><br><span class="hljs-comment">% fourier = fft2(gray_figure); </span><br><span class="hljs-comment">% shiftf=fftshift(fourier); </span><br><span class="hljs-comment">% P=0.9:0.005:1.0;</span><br><span class="hljs-comment">% PSNRs=zeros(size(P));</span><br><span class="hljs-comment">% S=size(P);</span><br><span class="hljs-comment">% for i=1:S(2)</span><br><span class="hljs-comment">%     shiftf_temp=threshold(shiftf,P(i));</span><br><span class="hljs-comment">%     refigure=ifft2(ifftshift(shiftf_temp))/256 ;</span><br><span class="hljs-comment">%     PSNRs(i)=grayPSNR(gray_figure,256*refigure,8);</span><br><span class="hljs-comment">% end</span><br><span class="hljs-comment">% subplot(4,3,10);</span><br><span class="hljs-comment">% plot(P,PSNRs);</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PSNR</span> = <span class="hljs-title">grayPSNR</span><span class="hljs-params">(img1,img2,bit)</span></span><br><span class="hljs-comment">%   计算图像的峰值信噪比PSNR</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       img1：标准图像</span><br><span class="hljs-comment">%       img2：待比较图像</span><br><span class="hljs-comment">%       bit：图像每像素比特数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       PSNR：峰值信噪比（dB）</span><br>    Size=<span class="hljs-built_in">size</span>(img1);<br>    h=Size(<span class="hljs-number">1</span>);<br>    w=Size(<span class="hljs-number">2</span>);<br>    MAX=<span class="hljs-number">2</span>^bit<span class="hljs-number">-1</span>;<br>    img1=double(img1);<br>    img2=double(img2);<br>    MSE=sum(sum((img1-img2).^<span class="hljs-number">2</span>))/(h*w);     <span class="hljs-comment">% 均方差  </span><br>    PSNR=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(MAX/<span class="hljs-built_in">sqrt</span>(MSE));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matrix</span> = <span class="hljs-title">threshold</span><span class="hljs-params">(mat,P)</span></span><br><span class="hljs-comment">%   保留矩阵一定比例的数值而把其它点置零</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       mat：待操作矩阵，复数按幅值算</span><br><span class="hljs-comment">%       P：保留的比例（前P大的数值将被保留）</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       matrix：操作后的矩阵</span><br>    matrix=mat;<br>    Size=<span class="hljs-built_in">size</span>(mat);<br>    height=Size(<span class="hljs-number">1</span>);<br>    width=Size(<span class="hljs-number">2</span>);<br>    R=<span class="hljs-built_in">real</span>(mat); <span class="hljs-comment">% 傅立叶变换实部</span><br>    I=<span class="hljs-built_in">imag</span>(mat); <span class="hljs-comment">% 傅立叶变换虚部</span><br>    spec = <span class="hljs-built_in">sqrt</span>(R.^<span class="hljs-number">2</span>+I.^<span class="hljs-number">2</span>); <span class="hljs-comment">% 幅值</span><br>    spec_sort=<span class="hljs-built_in">sort</span>(<span class="hljs-built_in">reshape</span>(spec,[<span class="hljs-number">1</span>,width*height]));<span class="hljs-comment">%排序，取阈值</span><br>    limit=spec_sort(<span class="hljs-built_in">round</span>(width*height*P)); <span class="hljs-comment">%门限</span><br>    matrix(spec&lt;limit)=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题">问题</h3><p>在本实验中，助教会要求你就某一个变换为例，作出取门限的保留比例和图像PSNR的折线图，也就是上面代码中注释掉的那一部分。</p><p>备注：期末考试中考了哈达玛变换的编程题。</p><hr /><h2 id="实验二-图像增强复原实验">实验二 图像增强复原实验</h2><h3 id="实验目的-1">实验目的</h3><p>利用空间均值滤波和空间中值滤波对降质图像进行复原，比较不同滤波器处理后的图像间的差异与滤波器大小对结果的影响。</p><h3 id="实验内容-1">实验内容</h3><ol type="1"><li><p>利用空间均值滤波方法进行图像增强复原；</p></li><li><p>利用空间中值滤波方法进行图像增强复原。</p></li></ol><h3 id="实验要求-1">实验要求</h3><ol type="1"><li><p>输入图像采用实验1所获取的图像，编程实现为输入图像添加高斯噪声与椒盐（脉冲）噪声，程序需要能够指定噪声的均值和方差或两个噪声分量中每一个的概率。</p></li><li><p>对每一种方法通过计算复原出来的图像的峰值信噪比，比较不同空间掩码的大小的选择对去噪效果的影响。</p></li><li><p>将降质图像和利用最优参数恢复后的图像同时显示出来，以便比较。</p></li><li><p>实验部分应包括高斯噪声和椒盐噪声的生成过程，原始图像和添加噪声后的图像；加噪图像通过均值和中值滤波器后的结果及比较不同滤波器处理后的图像之间的差异，滤波器大小对结果的影响。</p></li></ol><h3 id="实验原理-1">实验原理</h3><p>空间均值滤波算法的基本思想是，对于图像中的每个像素，将其与周围像素的灰度值进行平均，然后用平均值来替代原始像素的灰度值。这样可以消除图像中的高频噪声，并减少图像中的细节信息。</p><p>空间中值滤波算法的基本思想是，在给定的邻域窗口内，将窗口内的像素按照灰度值进行排序，然后选择排序后的中间值作为当前像素的新值。这种方法能够有效地消除图像中的椒盐噪声和其他类型的离群值，同时保留图像的边缘信息。</p><h3 id="实验结果与分析-1">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301039108.png" alt="实验2图像结果" /><figcaption aria-hidden="true">实验2图像结果</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301040454.jpg" alt="加高斯噪声图像PSNR随滤波器卷积核大小变化" /><figcaption aria-hidden="true">加高斯噪声图像PSNR随滤波器卷积核大小变化</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301040209.jpg" alt="加椒盐噪声图像PSNR随滤波器卷积核大小变化" /><figcaption aria-hidden="true">加椒盐噪声图像PSNR随滤波器卷积核大小变化</figcaption></figure><p>从结果上来看，在椒盐噪声上，中值滤波的效果一般来说好于均值滤波；在高斯噪声上，两者性能差不多。</p><h3 id="实验代码-1">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear all;<br>img=imread(<span class="hljs-string">&#x27;E1_output_image.tif&#x27;</span>); <br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>);<br>imshow(img);<br>title(<span class="hljs-string">&#x27;原图&#x27;</span>);<br><br><span class="hljs-built_in">mean</span> = <span class="hljs-number">0</span>;  <span class="hljs-comment">% 均值</span><br>variance = <span class="hljs-number">100</span>;  <span class="hljs-comment">% 方差</span><br>noise = <span class="hljs-built_in">mean</span> + <span class="hljs-built_in">sqrt</span>(variance) * <span class="hljs-built_in">randn</span>(<span class="hljs-built_in">size</span>(img));  <span class="hljs-comment">% 高斯噪声</span><br>noisy_img = double(img) + noise;  <span class="hljs-comment">% 添加噪声</span><br>noisy_img = uint8(noisy_img);  <span class="hljs-comment">% 转回uint8类型</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>);<br>imshow(noisy_img);<br>title(<span class="hljs-string">&#x27;添加高斯噪声后图像&#x27;</span>);<br>grayPSNR(img,noisy_img,<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">% 定义滤波器大小</span><br>filter_size = <span class="hljs-number">3</span>;<br><span class="hljs-comment">% 对图像进行均值滤波</span><br>avg_filtered_img = imfilter(noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);<br>imshow(avg_filtered_img);<br>title(<span class="hljs-string">&#x27;高斯噪声-均值滤波&#x27;</span>);<br><br>mid_filtered_img = medfilt2(noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);<br>imshow(mid_filtered_img);<br>title(<span class="hljs-string">&#x27;高斯噪声-中值滤波&#x27;</span>);<br><br>MAX_FLITER=<span class="hljs-number">50</span>;<br>avg_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br>mid_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:MAX_FLITER<br>    filter_size=<span class="hljs-built_in">i</span>;<br>    avg_filtered_img = imfilter(noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>    mid_filtered_img = medfilt2(noisy_img, [filter_size filter_size]);<br>    avg_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,avg_filtered_img,<span class="hljs-number">8</span>);<br>    mid_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,mid_filtered_img,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">end</span><br><br>filter_size=<span class="hljs-number">5</span>;<br>mid_filtered_img = medfilt2(noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);<br>imshow(mid_filtered_img);<br>title(<span class="hljs-string">&#x27;高斯噪声-最优参数恢复效果（size=5，中值滤波）&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>imshow(img);<br>title(<span class="hljs-string">&#x27;原图&#x27;</span>);<br><br><span class="hljs-comment">% 添加椒盐噪声</span><br>density = <span class="hljs-number">0.05</span>;  <span class="hljs-comment">% 椒盐噪声比例</span><br>salt_pepper = <span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(img));  <span class="hljs-comment">% 随机数矩阵</span><br>sp_noisy_img=img;<br>sp_noisy_img(salt_pepper &lt; density) = <span class="hljs-number">0</span>;  <span class="hljs-comment">% 添加椒噪声</span><br>sp_noisy_img(salt_pepper &gt; <span class="hljs-number">1</span> - density) = <span class="hljs-number">255</span>;  <span class="hljs-comment">% 添加盐噪声</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>);<br>imshow(sp_noisy_img);<br>title(<span class="hljs-string">&#x27;添加椒盐噪声后图像&#x27;</span>);<br>grayPSNR(img,sp_noisy_img,<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">% 定义滤波器大小</span><br>filter_size = <span class="hljs-number">3</span>;<br><span class="hljs-comment">% 对图像进行均值滤波</span><br>sp_avg_filtered_img = imfilter(sp_noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);<br>imshow(sp_avg_filtered_img);<br>title(<span class="hljs-string">&#x27;椒盐噪声-均值滤波&#x27;</span>);<br><br>sp_mid_filtered_img = medfilt2(sp_noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>);<br>imshow(sp_mid_filtered_img);<br>title(<span class="hljs-string">&#x27;椒盐噪声-中值滤波&#x27;</span>);<br><br>MAX_FLITER=<span class="hljs-number">50</span>;<br>sp_avg_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br>sp_mid_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:MAX_FLITER<br>    filter_size=<span class="hljs-built_in">i</span>;<br>    sp_avg_filtered_img = imfilter(sp_noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>    sp_mid_filtered_img = medfilt2(sp_noisy_img, [filter_size filter_size]);<br>    sp_avg_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,sp_avg_filtered_img,<span class="hljs-number">8</span>);<br>    sp_mid_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,sp_mid_filtered_img,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">end</span><br><br>filter_size=<span class="hljs-number">3</span>;<br>sp_mid_filtered_img = medfilt2(sp_noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<br>imshow(sp_mid_filtered_img);<br>title(<span class="hljs-string">&#x27;椒盐噪声-最优参数恢复效果（size=3，中值滤波）&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:MAX_FLITER,avg_PSNR,<span class="hljs-string">&#x27;r.-&#x27;</span>,<span class="hljs-number">1</span>:MAX_FLITER,mid_PSNR,<span class="hljs-string">&#x27;g.-&#x27;</span>);<br>title(<span class="hljs-string">&#x27;高斯噪声-PSNR随滤波器卷积核大小变化&#x27;</span>)<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;AVG&#x27;</span>,<span class="hljs-string">&#x27;MID&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:MAX_FLITER,sp_avg_PSNR,<span class="hljs-string">&#x27;r.-&#x27;</span>,<span class="hljs-number">1</span>:MAX_FLITER,sp_mid_PSNR,<span class="hljs-string">&#x27;g.-&#x27;</span>);<br>title(<span class="hljs-string">&#x27;椒盐噪声-PSNR随滤波器卷积核大小变化&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;AVG&#x27;</span>,<span class="hljs-string">&#x27;MID&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PSNR</span> = <span class="hljs-title">grayPSNR</span><span class="hljs-params">(img1,img2,bit)</span></span><br><span class="hljs-comment">%   计算图像的峰值信噪比PSNR</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       img1：标准图像</span><br><span class="hljs-comment">%       img2：待比较图像</span><br><span class="hljs-comment">%       bit：图像每像素比特数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       PSNR：峰值信噪比（dB）</span><br>    Size=<span class="hljs-built_in">size</span>(img1);<br>    h=Size(<span class="hljs-number">1</span>);<br>    w=Size(<span class="hljs-number">2</span>);<br>    MAX=<span class="hljs-number">2</span>^bit<span class="hljs-number">-1</span>;<br>    img1=double(img1);<br>    img2=double(img2);<br>    MSE=sum(sum((img1-img2).^<span class="hljs-number">2</span>))/(h*w);     <span class="hljs-comment">% 均方差  </span><br>    PSNR=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(MAX/<span class="hljs-built_in">sqrt</span>(MSE));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题-1">问题</h3><p>在本实验中，助教会根据空间域滤波的基本原理进行提问，你需要了解卷积核和原图相互作用的过程。然后，助教会问如果卷积核的大小为偶数时，卷积的结果会放在哪里。事实上，如果指定偶数大小的核 <a href="https://ww2.mathworks.cn/help/images/ref/imfilter.html?searchHighlight=imfilter&amp;s_tid=srchtitle_imfilter_1#btsmcj2-1-h"><code>h</code></a>，则核的中心是 <code>floor((size(h) + 1)/2)</code>。例如，四元素滤波器 <code>[0.25 0.75 -0.75 -0.25]</code> 的中心是第二个元素 <code>0.75</code>。此滤波器与五元素滤波器 <code>[0 0.25 0.75 -0.75 -0.25]</code> 的滤波结果相同。</p><hr /><h2 id="实验三-图像分割处理实验">实验三 图像分割处理实验</h2><h3 id="实验目的-2">实验目的</h3><ol type="1"><li><p>了解图像分割的基本原理，并利用图像分割算法进行图像分割处理；</p></li><li><p>掌握数学形态学的基本运算。</p></li></ol><h3 id="实验内容-2">实验内容</h3><ol type="1"><li><p>利用类间方差阈值算法实现图像的分割处理；</p></li><li><p>利用形态学处理进行处理结果修正。</p></li></ol><h3 id="实验要求-2">实验要求</h3><ol type="1"><li>实验用图如图6.2所示；</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301044776.png" alt="实验3原始图像" /><figcaption aria-hidden="true">实验3原始图像</figcaption></figure><ol start="2" type="1"><li><p>对输入图像进行平滑处理，以减小噪声对分割处理的影响，比较中值滤波范围取不同值时对图像滤波的效果；</p></li><li><p>利用类间方差阈值算法对滤波处理后图像进行分割处理，获取分割图像；</p></li><li><p>利用数学形态学中的腐蚀和膨胀运算处理，剔除分割处理结果中的一些细小的残余误分割点，在进行腐蚀和膨胀运算时可采用半径为r的圆形结构元素，注意比较选取不同r值时的处理结果（r分别取1、3、5）。</p></li></ol><h3 id="实验原理-2">实验原理</h3><p>大津法的基本思想是遍历所有可能的阈值，并计算每个阈值下的类间方差。类间方差是衡量图像分割质量的指标，它衡量了不同类别之间的差异程度。通过最大化类间方差，可以找到最佳阈值，以便将图像分成背景和目标两个类别。它的优点在于它是一种自适应的阈值选择方法，不需要预先指定阈值，而是根据图像的特性自动选择最佳阈值。它在处理具有双峰直方图的图像（例如目标和背景明显不同的图像）时表现良好，并且适用于各种类型的图像分割任务。</p><p>腐蚀操作通过对图像进行局部最小化来缩小或腐蚀图像中物体的边界，这种操作使图像中的物体边界变得更加平滑，并且可以用于去除小的噪声、分离物体之间的连接以及减小物体的尺寸。膨胀操作通过对图像进行局部最大化来扩展或膨胀图像中物体的边界，这种操作可用于连接物体、填充物体内的空洞、增大物体的尺寸以及消除图像中的小孔洞。</p><p>开闭运算是腐蚀和膨胀操作的组合。开运算先进行腐蚀操作，然后再进行膨胀操作。它可以用于平滑图像的轮廓、去除小的物体以及分离连接的物体。闭运算先进行膨胀操作，然后再进行腐蚀操作。它可以用于填充物体内的小孔洞、连接物体以及平滑图像的背景。</p><h3 id="实验结果与分析-2">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301044255.jpg" alt="实验3各图像结果" /><figcaption aria-hidden="true">实验3各图像结果</figcaption></figure><p>由实验结果可以看出，中值滤波效果抑制了图像中大部分噪声，而图像也被一定程度地模糊；经过图像分割之后，目标的轮廓被提取出来。开操作方向向外的角变圆滑了，但是方向向内的角未受影响。闭运算方向向内的角变圆滑了，方向向外的角未受影响。</p><h3 id="实验代码-2">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs matlab">img = imread(<span class="hljs-string">&quot;shiyan3.bmp&quot;</span>);<br>img = rgb2gray(img);<br>img = im2uint8(img);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>imshow(img);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>medianFilteredImages = cell(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>filterSizes = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];  <span class="hljs-comment">% 不同的滤波范围</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(filterSizes)<br>    medianFilteredImages&#123;<span class="hljs-built_in">i</span>&#125; = medfilt2(img, [filterSizes(<span class="hljs-built_in">i</span>), filterSizes(<span class="hljs-built_in">i</span>)]);<br>    subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br>    imshow(medianFilteredImages&#123;<span class="hljs-built_in">i</span>&#125;);<br>    title([<span class="hljs-string">&#x27;中值滤波 (&#x27;</span>, num2str(filterSizes(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27;x&#x27;</span>, num2str(filterSizes(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27;)&#x27;</span>]);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%选择PSNR最大的3x3进行后续操作</span><br>medianFilteredImage = medfilt2(img,[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]);<br>segmentedImage = imbinarize(medianFilteredImage);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>imshow(segmentedImage);<br>title(<span class="hljs-string">&#x27;分割后图像&#x27;</span>);<br><br><span class="hljs-comment">%形态学处理</span><br>cleanedSegmentedImages = cell(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>radius = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(radius)<br>    se = strel(<span class="hljs-string">&#x27;disk&#x27;</span>,radius(<span class="hljs-built_in">i</span>));<br>    erodedImage = imerode(segmentedImage, se);<span class="hljs-comment">%腐蚀</span><br>    cleanedSegmentedImages&#123;<span class="hljs-built_in">i</span>&#125; = imdilate(erodedImage,se);<span class="hljs-comment">%膨胀</span><br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>+<span class="hljs-built_in">i</span>);<br>    imshow(cleanedSegmentedImages&#123;<span class="hljs-built_in">i</span>&#125;);<br>    title([<span class="hljs-string">&#x27;开运算，半径为&#x27;</span>,num2str(radius(<span class="hljs-built_in">i</span>))]);<br><span class="hljs-keyword">end</span><br><br>se = strel(<span class="hljs-string">&#x27;disk&#x27;</span>,<span class="hljs-number">3</span>);<br>dilatedImage = imdilate(segmentedImage,se);<br>cleanedImage = imerode(dilatedImage,se);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>);<br>imshow(cleanedImage);<br>title(<span class="hljs-string">&#x27;闭运算，半径为3&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PSNR</span> = <span class="hljs-title">grayPSNR</span><span class="hljs-params">(img1,img2,bit)</span></span><br><span class="hljs-comment">%   计算图像的峰值信噪比PSNR</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       img1：标准图像</span><br><span class="hljs-comment">%       img2：待比较图像</span><br><span class="hljs-comment">%       bit：图像每像素比特数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       PSNR：峰值信噪比（dB）</span><br>    Size=<span class="hljs-built_in">size</span>(img1);<br>    h=Size(<span class="hljs-number">1</span>);<br>    w=Size(<span class="hljs-number">2</span>);<br>    MAX=<span class="hljs-number">2</span>^bit<span class="hljs-number">-1</span>;<br>    img1=double(img1);<br>    img2=double(img2);<br>    MSE=sum(sum((img1-img2).^<span class="hljs-number">2</span>))/(h*w);     <span class="hljs-comment">% 均方差  </span><br>    PSNR=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(MAX/<span class="hljs-built_in">sqrt</span>(MSE));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题-2">问题</h3><p>在本实验中，助教会问大津法的基本原理，类间方差和类内方差的概念，腐蚀与膨胀和开闭运算的基本知识，以及开闭运算的功能。</p><hr /><h2 id="实验四-用hough变换进行曲线的参数提取">实验四 用Hough变换进行曲线的参数提取</h2><h3 id="实验目的-3">实验目的</h3><ol type="1"><li><p>了解边缘检测算子的原理，并利用边缘算子对图像进行检测；</p></li><li><p>掌握Hough变换的基本原理。</p></li></ol><h3 id="实验内容-3">实验内容</h3><ol type="1"><li><p>分别将原始图像及加高斯噪声、椒盐噪声后的图像中圆形边缘检测出来；</p></li><li><p>用Hough变换对边缘进行参数提取。</p></li></ol><h3 id="实验要求-3">实验要求</h3><ol type="1"><li>实验用图像文件：原始图像（houghorg.bmp）、加高斯噪声后图像（houghgau.bmp）和加椒盐噪声后图像（houghsalt.bmp）；</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301054271.png" alt="原始图像" /><figcaption aria-hidden="true">原始图像</figcaption></figure><ol start="2" type="1"><li><p>在含有噪声的背景下，先对图像中值滤波，再进行边缘检测；</p></li><li><p>将目标的边界提取出来。边缘检测算子可利用自带函数实现，使用Robert、Sobel和Laplacian算子；</p></li><li><p>利用Hough变换提取的参数绘制曲线，并叠加在噪声图像上。</p></li></ol><h3 id="实验原理-3">实验原理</h3><p>Robert、Sobel和Laplacian是常用的边缘检测算子，分别运用梯度或二阶微分等原理来对图像的边缘进行检测。</p><p>在<span class="math inline">\((x,y)\)</span>空间中，圆的方程为：</p><p><span class="math display">\[(x - a)^{2} + (y - b)^{2} = r^{2}\]</span></p><p>取<span class="math inline">\((a,b)\)</span>做变换空间，也因此在<span class="math inline">\((x,y)\)</span>空间中圆上任意一点<span class="math inline">\(\left( x_{i},y_{i} \right)\)</span>与<span class="math inline">\((a,b)\)</span>空间中的圆相对应：</p><p><span class="math display">\[\left( a - x_{i} \right)^{2} + \left( b - y_{i} \right)^{2} = r^{2}\]</span></p><p>在<span class="math inline">\((x,y)\)</span>空间中所有共圆的点在<span class="math inline">\((a,b)\)</span>空间中对应的曲线交于<span class="math inline">\(\left( a_{0},b_{0} \right)\)</span>，利用Hough变换的步骤，最终可以在累加数组中找到<span class="math inline">\(\left( a_{0},b_{0} \right)\)</span>点出现峰值，从而检测出在<span class="math inline">\((x,y)\)</span>空间中有一个以<span class="math inline">\(\left( a_{0},b_{0} \right)\)</span>为半径的圆</p><h3 id="实验结果与分析-3">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301055801.jpg" alt="加高斯噪声实验结果" /><figcaption aria-hidden="true">加高斯噪声实验结果</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301055749.jpg" alt="加椒盐噪声实验结果" /><figcaption aria-hidden="true">加椒盐噪声实验结果</figcaption></figure><p>观察实验结果，三种算子都能有效提取边界。</p><h3 id="实验代码-3">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;close all;<br><br>imgOrg = imread(<span class="hljs-string">&#x27;houghorg.bmp&#x27;</span>);<br>imgOrg = rgb2gray(imgOrg);<br>imgOrg = mat2gray(imgOrg);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>make(imgOrg);<br><br>imgSalt = imread(<span class="hljs-string">&#x27;houghsalt.bmp&#x27;</span>);<br>imgSalt = mat2gray(imgSalt);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>make(imgSalt);<br><br>imgGau = imread(<span class="hljs-string">&#x27;houghgau.bmp&#x27;</span>);<br>imgGau = mat2gray(imgGau);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br>make(imgGau);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge</span> = <span class="hljs-title">edgeRobert</span><span class="hljs-params">(image)</span></span><br><span class="hljs-comment">%Robert算子边缘提取</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       image：待处理图像</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       edge：提取的边缘</span><br>    Gx = [ <span class="hljs-number">1</span>  <span class="hljs-number">0</span>; <br>           <span class="hljs-number">0</span> <span class="hljs-number">-1</span>];<br>    Gy = [ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>; <br>          <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>];   <br><br>    edgeX = conv2(double(image), Gx, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    edgeY = conv2(double(image), Gy, <span class="hljs-string">&#x27;same&#x27;</span>);<br><br>    edgeMagnitude = <span class="hljs-built_in">sqrt</span>(edgeX.^<span class="hljs-number">2</span> + edgeY.^<span class="hljs-number">2</span>);<br>    edgeMagnitude = mat2gray(edgeMagnitude);<br>    edge = imbinarize(edgeMagnitude);<br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge</span> = <span class="hljs-title">edgeStobel</span><span class="hljs-params">(image)</span></span><br><span class="hljs-comment">%Stobelt算子边缘提取</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       image：待处理图像</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       edge：提取的边缘</span><br>    Gx = [<span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>; <br>          <span class="hljs-number">-2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2</span>; <br>          <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>];<br>    Gy = [ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">1</span>; <br>           <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>; <br>          <span class="hljs-number">-1</span> <span class="hljs-number">-2</span> <span class="hljs-number">-1</span>];<br><br>    edgeX = conv2(double(image), Gx, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    edgeY = conv2(double(image), Gy, <span class="hljs-string">&#x27;same&#x27;</span>);<br><br>    edgeMagnitude = <span class="hljs-built_in">sqrt</span>(edgeX.^<span class="hljs-number">2</span> + edgeY.^<span class="hljs-number">2</span>);<br>    edgeMagnitude = mat2gray(edgeMagnitude);<br>    edge = imbinarize(edgeMagnitude);<br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge</span> = <span class="hljs-title">edgeLaplacian</span><span class="hljs-params">(image)</span></span><br><span class="hljs-comment">%Laplacian算子边缘提取</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       image：待处理图像</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       edge：提取的边缘</span><br>    H = fspecial(<span class="hljs-string">&#x27;laplacian&#x27;</span>);<br>    edgeResponse = conv2(double(image), H, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    edgeMagnitude = <span class="hljs-built_in">abs</span>(edgeResponse);<br>    edgeMagnitude = mat2gray(edgeMagnitude);<br>    edge = imbinarize(edgeMagnitude);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span><span class="hljs-params">(img)</span></span><br>    imgO=img;<br>    img = medfilt2(img, [<span class="hljs-number">9</span> <span class="hljs-number">9</span>]);<br>    edgeR=edgeRobert(img);<br>    edgeS=edgeStobel(img);<br>    edgeL=edgeLaplacian(img);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>    imshow(edgeR);<br>    title(<span class="hljs-string">&#x27;Robert算子边缘提取&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>    imshow(edgeS);<br>    title(<span class="hljs-string">&#x27;Stobel算子边缘提取&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>    imshow(edgeL);<br>    title(<span class="hljs-string">&#x27;Laplacian算子边缘提取&#x27;</span>);<br><br><span class="hljs-comment">%以下是Hough变换</span><br>    radiusRange = [<span class="hljs-number">20</span> <span class="hljs-number">500</span>]; <span class="hljs-comment">% 圆的半径范围</span><br><br>    [centersR, radiiR, metricR] = imfindcircles(edgeR, radiusRange,<span class="hljs-string">&#x27;Sensitivity&#x27;</span>,<span class="hljs-number">0.9</span>);<br>    <span class="hljs-comment">%Sensitivity是敏感度因子，随着敏感度因子的增大，imfindcircles 会检测到更多圆形目标，包括弱圆形和部分模糊圆形。更高的敏感度值也会增加错误检测的风险。</span><br>    [centersS, radiiS, metricS] = imfindcircles(edgeS, radiusRange,<span class="hljs-string">&#x27;Sensitivity&#x27;</span>,<span class="hljs-number">0.9</span>);<br>    [centersL, radiiL, metricL] = imfindcircles(edgeL, radiusRange,<span class="hljs-string">&#x27;Sensitivity&#x27;</span>,<span class="hljs-number">0.9</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>    imshow(imgO);<br>    viscircles(centersR, radiiR,<span class="hljs-string">&#x27;EdgeColor&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>    imshow(imgO);<br>    viscircles(centersS, radiiS,<span class="hljs-string">&#x27;EdgeColor&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<br>    imshow(imgO);<br>    viscircles(centersL, radiiL,<span class="hljs-string">&#x27;EdgeColor&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h3 id="问题-3">问题</h3><p>在本实验中，助教会问你关于Hough变换提取圆形的基本原理。</p><hr /><h2 id="实验五-手写数字识别">实验五 手写数字识别</h2><h3 id="实验目的-4">实验目的</h3><p>掌握分类、识别问题的实质，了解各种分类问题的机器学习方法，并至少掌握一种</p><h3 id="实验内容-4">实验内容</h3><p>对实验提供含噪声的手写数据库（MNIST）进行训练和测试，最终能够较为准确的识别数据库中的手写体数字。</p><h3 id="实验要求-4">实验要求</h3><p>编写一完整的程序，选取一种合适的机器学习方法，对实验提供的手写数据库（MNIST）进行训练和测试，最终能够较为准确的识别数据库中的手写体数字。</p><p>数据文件共分为训练集和测试集：</p><p>训练数据集：</p><p>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</p><p>Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</p><p>测试数据集：</p><p>Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</p><p>Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</p><h2 id="实验原理-4">实验原理</h2><p>卷积神经网络（Convolutional Neural Network，CNN）是一种深度学习模型，主要用于图像识别、目标检测和图像分类等任务。CNN的组成和原理如下：</p><p>卷积层：是CNN的核心组件。它通过使用一系列可学习的卷积核对输入图像进行卷积操作。</p><p>激活函：在卷积层的输出特征图上应用非线性激活函数，如ReLU，用于引入非线性变换。ReLU函数将负值置为零，并保留正值。这种非线性变换能够增强网络的表达能力，使其能够学习更复杂的特征。</p><p>池化层：用于降低特征图的空间尺寸，减少参数数量，并提取出重要的特征。常用的池化操作是最大池化，它从输入的局部区域中选择最大值作为输出。池化层还可以提供一定程度的平移不变性，使网络对输入的微小变化更加稳定。</p><p>全连接层：是在卷积层和输出层之间的一层。它将之前的卷积层或池化层的输出特征图展平为一维向量，并与权重相乘并进行偏置，最后通过激活函数得到最终的分类结果。全连接层能够学习到输入特征之间的复杂关系，用于分类和预测。</p><p>输出层：是CNN的最后一层，通常使用softmax函数将网络的输出转换为概率分布，用于多分类问题的预测。</p><p>CNN通过多个卷积层、激活函数、池化层和全连接层的堆叠，可以提取图像中的高级特征，并通过反向传播算法进行端到端的训练。通过大规模的数据集训练，CNN能够学习到复杂的特征表示，并在新的未见过的图像上进行准确的分类和预测。</p><h3 id="实验结果与分析-4">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301100419.png" alt="训练过程示意图" /><figcaption aria-hidden="true">训练过程示意图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301100378.png" alt="加噪声前识别示例" /><figcaption aria-hidden="true">加噪声前识别示例</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301100006.jpg" alt="加噪声后识别示例" /><figcaption aria-hidden="true">加噪声后识别示例</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301101857.jpg" alt="预测准确率随噪声变化" /><figcaption aria-hidden="true">预测准确率随噪声变化</figcaption></figure><h3 id="实验代码-4">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;close all;<br><br>digitDatasetPath = fullfile(matlabroot,<span class="hljs-string">&#x27;toolbox&#x27;</span>,<span class="hljs-string">&#x27;nnet&#x27;</span>,<span class="hljs-string">&#x27;nndemos&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;nndatasets&#x27;</span>,<span class="hljs-string">&#x27;DigitDataset&#x27;</span>);<br>imds = imageDatastore(digitDatasetPath, ...<br>    <span class="hljs-string">&#x27;IncludeSubfolders&#x27;</span>,<span class="hljs-built_in">true</span>,<span class="hljs-string">&#x27;LabelSource&#x27;</span>,<span class="hljs-string">&#x27;foldernames&#x27;</span>);<br><span class="hljs-comment">% figure;</span><br><span class="hljs-comment">% perm = randperm(10000,20);</span><br><span class="hljs-comment">% for i = 1:20</span><br><span class="hljs-comment">%     subplot(4,5,i);</span><br><span class="hljs-comment">%     imshow(imds.Files&#123;perm(i)&#125;);</span><br><span class="hljs-comment">% end</span><br><br>labelCount = countEachLabel(imds)<br>img = readimage(imds,<span class="hljs-number">1</span>);<br>imageSize = <span class="hljs-built_in">size</span>(img);<br><br>numTrainFiles = <span class="hljs-number">750</span>;<br>[imdsTrain,imdsValidation] = splitEachLabel(imds,numTrainFiles,<span class="hljs-string">&#x27;randomize&#x27;</span>);<br><br>layers = [<br>    imageInputLayer([<span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">%图像输入层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">%卷积层</span><br>    batchNormalizationLayer <span class="hljs-comment">%批量归一化层</span><br>    reluLayer <span class="hljs-comment">%ReLU层</span><br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">%最大池化层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>)<br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    fullyConnectedLayer(<span class="hljs-number">10</span>) <span class="hljs-comment">%全连接</span><br>    softmaxLayer<br>    classificationLayer]; <span class="hljs-comment">%分类</span><br><br>options = trainingOptions(<span class="hljs-string">&#x27;sgdm&#x27;</span>, ... <span class="hljs-comment">%随机梯度下降法</span><br>    <span class="hljs-string">&#x27;InitialLearnRate&#x27;</span>,<span class="hljs-number">0.01</span>, ... <span class="hljs-comment">%学习率</span><br>    <span class="hljs-string">&#x27;MaxEpochs&#x27;</span>,<span class="hljs-number">4</span>, ... <span class="hljs-comment">%训练轮数</span><br>    <span class="hljs-string">&#x27;Shuffle&#x27;</span>,<span class="hljs-string">&#x27;every-epoch&#x27;</span>, ... <span class="hljs-comment">%随机化</span><br>    <span class="hljs-string">&#x27;ValidationData&#x27;</span>,imdsValidation, ... <span class="hljs-comment">%验证集</span><br>    <span class="hljs-string">&#x27;ValidationFrequency&#x27;</span>,<span class="hljs-number">30</span>, ... <span class="hljs-comment">%每隔30个训练迭代时进行一次验证</span><br>    <span class="hljs-string">&#x27;Verbose&#x27;</span>,<span class="hljs-built_in">false</span>, ...<br>    <span class="hljs-string">&#x27;Plots&#x27;</span>,<span class="hljs-string">&#x27;training-progress&#x27;</span>); <span class="hljs-comment">%显示训练过程的进度图</span><br><br>net = trainNetwork(imdsTrain,layers,options);<br>YPred = classify(net,imdsValidation);<br>YValidation = imdsValidation.Labels;<br><br><span class="hljs-comment">%显示20个无噪声识别示意图</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>perm = randperm(<span class="hljs-number">2500</span>,<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">20</span><br>    subplot(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-built_in">i</span>);<br>    imshow(imdsValidation.Files&#123;perm(<span class="hljs-built_in">i</span>)&#125;);<br>    title(<span class="hljs-string">&#x27;预测值&#x27;</span>+string(YPred(perm(<span class="hljs-built_in">i</span>))));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%无噪声准确率</span><br>accuracy = sum(YPred == YValidation)/<span class="hljs-built_in">numel</span>(YValidation)<br><br>newImgArray = <span class="hljs-built_in">ones</span>([imageSize,<span class="hljs-number">2500</span>]);<br>newImgArray2 = <span class="hljs-built_in">ones</span>([imageSize,<span class="hljs-number">2500</span>]);<br><br><br><span class="hljs-comment">%复制测试集</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2500</span><br>    newImgArray(:,:,<span class="hljs-built_in">i</span>) = imread(imdsValidation.Files&#123;<span class="hljs-built_in">i</span>&#125;);<br><span class="hljs-keyword">end</span><br>Densitys = <span class="hljs-number">0</span>:<span class="hljs-number">0.005</span>:<span class="hljs-number">0.05</span>; <span class="hljs-comment">%椒盐噪声概率</span><br>accuracys = <span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(Densitys));<br><span class="hljs-comment">%加噪声</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(Densitys)<br>    <span class="hljs-built_in">i</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2500</span><br>        p=Densitys(<span class="hljs-built_in">i</span>);<br>        newImgArray2(:,:,<span class="hljs-built_in">j</span>) = addSaltAndPepperNoise(newImgArray(:,:,<span class="hljs-built_in">j</span>),p);<br>        YPred(<span class="hljs-built_in">j</span>,:)=classify(net,newImgArray2(:,:,<span class="hljs-built_in">j</span>));<br>    <span class="hljs-keyword">end</span><br>    accuracys(<span class="hljs-built_in">i</span>) = sum(YPred == YValidation)/<span class="hljs-built_in">numel</span>(YValidation);<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(Densitys,accuracys);<br>title(<span class="hljs-string">&#x27;预测准确率随椒盐噪声的概率变化的图像&#x27;</span>);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2500</span><br>    p=<span class="hljs-number">0.01</span>;<br>    newImgArray2(:,:,<span class="hljs-built_in">j</span>) = addSaltAndPepperNoise(newImgArray(:,:,<span class="hljs-built_in">j</span>),p);<br>    YPred(<span class="hljs-built_in">j</span>,:)=classify(net,newImgArray2(:,:,<span class="hljs-built_in">j</span>));<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br>perm = randperm(<span class="hljs-number">2500</span>,<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">20</span><br>    subplot(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-built_in">i</span>);<br>    imshow(newImgArray2(:,:,perm(<span class="hljs-built_in">i</span>)));<br>    title(<span class="hljs-string">&#x27;预测值&#x27;</span>+string(YPred(perm(<span class="hljs-built_in">i</span>)))+<span class="hljs-string">&#x27;,实际值&#x27;</span>+string(YValidation(perm(<span class="hljs-built_in">i</span>))));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noisyImage</span> = <span class="hljs-title">addSaltAndPepperNoise</span><span class="hljs-params">(image, noiseDensity)</span></span><br>    <span class="hljs-comment">% image: 输入的图像</span><br>    <span class="hljs-comment">% noiseDensity: 椒盐噪声概率</span><br>    <br>    salt_pepper = <span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(image)); <br>    noisyImage=image;<br>    noisyImage(salt_pepper &lt; noiseDensity) = <span class="hljs-number">0</span>;  <span class="hljs-comment">% 添加椒噪声</span><br>    noisyImage(salt_pepper &gt; <span class="hljs-number">1</span> - noiseDensity) = <span class="hljs-number">255</span>;  <span class="hljs-comment">% 添加盐噪声</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题-4">问题</h3><p>在本实验中，助教会问关于CNN基本原理的问题</p><h2 id="感悟与总结">感悟与总结</h2><p>在进行图像处理实验的过程中，我通过实践掌握了图像变换、图像增强复原、图像分割、曲线参数提取以及手写数字识别等五个部分的基本技术和方法。这次实验给我带来了许多收获和感悟。</p><p>在图像变换方面，我学会了使用离散傅立叶变换、离散余弦变换等方法对图像进行频域分析和压缩。通过观察变换后的系数矩阵的频谱情况，我更深入地理解了图像在频域上的特征表达。</p><p>在图像增强复原方面，我学习了空间均值滤波、中值滤波等技术，可以有效地去除图像噪声和模糊，并提升图像的质量和清晰度。这对于图像处理和分析来说非常重要，尤其在实际应用中能够提升图像的可视化效果。</p><p>在图像分割方面，我掌握了基于阈值分割和基于边缘检测的方法。通过调整阈值和应用边缘检测算子，我成功地将感兴趣的目标进行提取和分析。</p><p>通过学习和实践边缘检测算法和Hough变换，我了解到它在曲线参数提取方面的强大能力。通过投票累加器和阈值设定，我成功地从图像中提取出了曲线的参数。</p><p>手写数字识别让我简单认识了深度学习模型（如CNN）在图像分类和识别任务中的卓越性能。通过搭建并训练CNN模型，我能够准确地对手写数字进行分类和识别。</p><p>图像处理实验和课内知识结合紧密，通过完成上述五个实验，我对于课内各知识的掌握在实践中得以提升，同时也加强了对Matlab语言的理解和运用能力，提升了自己的综合能力。</p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理·采样系统和状态空间</title>
    <link href="/2023/06/17/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%C2%B7%E9%87%87%E6%A0%B7%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/06/17/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%C2%B7%E9%87%87%E6%A0%B7%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这两部分之间其实没啥太大联系，写在一起只是为了方便，就这样。</p><h2 id="采样系统分析">采样系统分析</h2><p>在前面讨论的系统中，信号都是连续时间信号，系统都是连续时间系统。在本节，将对有一处或者数处的信号是离散的（数码或者脉冲序列）的系统进行讨论。</p><p>关于奈奎斯特采样定理，已经提过非常非常多遍了，这里就略过了。只提一点：用<span class="math inline">\(f(t),G(s)\)</span>表示采样前的信号，系统；用<span class="math inline">\(f^*(t),G^*(s)\)</span>表示采样后的信号（冲击串）、系统。</p><h3 id="保持器">保持器</h3><p>由采样定理得，采样频率是输入信号频率的两倍以上时，可以通过理想低通滤波器把信号恢复出来。但是理想滤波器是不存在的，于是我们转而使用保持器来恢复信号。</p><ul><li><p>零阶保持器</p><p>零阶保持器是把采样时刻<span class="math inline">\(nT\)</span>的采样值恒定不变地保持到下一个采样时刻<span class="math inline">\((n+1)T\)</span>的电路。它的系统函数是 <span class="math display">\[G_h(s)=\frac{1-e^{Ts}}{s}\]</span></p></li><li><p>一阶保持器</p><p>一阶保持器是一种按线性规律外推的保持器，其外推规律是： <span class="math display">\[x_h(t)=x(kT)+\frac{x(kT)-x[(k-1)T]}{T}(t-kT)\]</span> 即：每个区间是线性函数，斜率是上一个区间的平均斜率</p><p>其传递函数是 <span class="math display">\[G_h(s)=T(1+Ts)\left(\frac{1-e^{Ts}}{Ts}\right)^2\]</span></p></li></ul><h3 id="z变换">Z变换</h3><p>Z变换是拉普拉斯变换的一种变形，也学过很多遍了。</p><h3 id="脉冲传递函数">脉冲传递函数</h3><p>类似于以前的系统传递函数，离散时间系统的特性可以用脉冲传递函数<span class="math inline">\(H(z)\)</span>来描述。对于开环系统</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20230617164044343.png" alt="image-20230617164044343" /><figcaption aria-hidden="true">image-20230617164044343</figcaption></figure><p>有： <span class="math display">\[C(s)=G(s)R^*(s)\]</span> 和 <span class="math display">\[C^*(s)=G^*(s)R^*(s)\]</span> 写成脉冲传递函数的形式，就是 <span class="math display">\[C(z)=G(z)R(z)\]</span> 一般来说，由连续部分求得脉冲传递函数的步骤是：</p><ol type="1"><li>由<span class="math inline">\(H(s)\)</span>求得<span class="math inline">\(h(t)\)</span></li><li>确定单位冲激响应序列<span class="math inline">\(h[nT]\)</span></li><li>求<span class="math inline">\(h[nT]\)</span>的Z变换，得<span class="math inline">\(H(z)\)</span></li></ol><p>在实际操作上，并没有这么麻烦。在进行接下来的说明之前，首先要辨析两个表达式： <span class="math display">\[G_1(z)G_2(z)\]</span> 指的是<span class="math inline">\(G_1(z)\)</span>和<span class="math inline">\(G_2(z)\)</span>两个表达式的乘积，两个系统之间通过采样开关串联，即：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306171550274.png" alt="image-20230617155047199" style="zoom:25%;" /></p><p>而 <span class="math display">\[G_1G_2(z)\]</span> 指的是先把两个连续时间系统级联，得到<span class="math inline">\(G_1G_2(s)=G_1(s)G_2(s)\)</span>，然后求出<span class="math inline">\(G_1G_2(s)\)</span>对应的Z变换形式，即为<span class="math inline">\(G_1G_2(z)\)</span>，即：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306171550672.png" alt="image-20230617154959581" style="zoom:25%;" /></p><p>这两种情况一般是不一样的。比如<span class="math inline">\(G_1(s)=1/(s+a),G_2(s)=1/(s+a)\)</span>，对于第一个串联系统，有： <span class="math display">\[G(z)=\frac{z^2}{(z-e^{-aT})(z-e^{-bT})}\]</span> 对于第二个串联系统，则有： <span class="math display">\[G(s)=\frac 1{b-a}\left(\frac{1}{s+a}+\frac{1}{s+b}\right)\]</span> 从而 <span class="math display">\[G(z)=\mathscr Z[G(s)]=\frac{\mathrm{e}^{-a T}-\mathrm{e}^{-b T}}{b-a} \frac{z}{\left(z-\mathrm{e}^{-a T}\right)\left(z-\mathrm{e}^{-b T}\right)}\]</span> 在分析闭环系统时，系统函数有时候不能直接求出（详见下面的例题），所以会转而求输出函数<span class="math inline">\(C(z)\)</span>，可以遵循以下步骤：</p><ol type="1"><li>从<span class="math inline">\(C(z)\)</span>开始逆着前向通道找到最靠近比较器的采样器，采样信号设为<span class="math inline">\(X(z)\)</span>；</li><li>利用前向通道和回路分别写出<span class="math inline">\(C(z)\)</span>和<span class="math inline">\(X(z)\)</span>的表达式，联立解出<span class="math inline">\(C(z)\)</span>。</li></ol><p>如果系统有多个反馈环，则：</p><ol type="1"><li>从比较器最靠近<span class="math inline">\(C(z)\)</span>的回路开始，每个回路找到一个<span class="math inline">\(X(z)\)</span>（没有则先归并该连续回路为一个连续环节），即<span class="math inline">\(X_n(z), \cdots , X_1(z)\)</span>；</li><li>用前向通道写出<span class="math inline">\(C(z)\)</span>的表达式，从<span class="math inline">\(n\sim 1\)</span>依次用各回路写出<span class="math inline">\(X(z)\)</span>表达式，联立<span class="math inline">\(n+1\)</span>个方程解出<span class="math inline">\(C(z)\)</span>。</li></ol><p>在实际操作时，先写<span class="math inline">\(C(s)\)</span>和<span class="math inline">\(X(s)\)</span>方程，再加星得到<span class="math inline">\(C^*(s)\)</span>和<span class="math inline">\(X^*(s)\)</span>方程，然后得到<span class="math inline">\(C(z)\)</span>和<span class="math inline">\(X(z)\)</span>方程.</p><blockquote><p>【例1】求以下系统的<span class="math inline">\(C(z)\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306171645961.png" alt="image-20230617164506904" /><figcaption aria-hidden="true">image-20230617164506904</figcaption></figure><p>【解】<span class="math inline">\(X(z)\)</span>已经在图中标好了。</p><ol type="1"><li><p>列方程： <span class="math display">\[\begin{cases}C(s)=G_2(s)X^*(s)\\X(s)=G_2(s)R(s)-G_1(s)H(s)G_2(s)X^*(s)\end{cases}\]</span></p></li><li><p>加星号（采样）：在加星号时，要分清楚一个表达式里面是系统、连续时间还是离散时间。对级联的系统、连续时间信号传入连续系统的部分合并为整体然后加星号，对离散时间信号传入系统的部分，只给系统加星号，离散时间信号保持不变，也不合并： <span class="math display">\[\begin{cases}C(s)=G_2^*(s)X^*(s)\\X(s)=G_2R^*(s)-G_1HG_2^*(s)X^*(s)\end{cases}\]</span></p></li><li><p>Z变换，就是把星号都去了，然后把<span class="math inline">\(s\)</span>换成<span class="math inline">\(z\)</span> <span class="math display">\[\begin{cases}C(z)=G_2(z)X(z)\\X(z)=G_2R(z)-G_1HG_2(z)X(z)\end{cases}\]</span></p></li><li><p>消元求解，有： <span class="math display">\[C(z)=\frac{G_2(z)G_1R(z)}{1+G_1HG_2(z)}\]</span></p></li></ol></blockquote><p>可以看出，在上面这个例子中，<span class="math inline">\(R\)</span>的存在形式是<span class="math inline">\(G_1R(z)\)</span>，并不能单独分出来，所以只能求到<span class="math inline">\(C(z)\)</span>，而不能求出系统函数。</p><h3 id="系统稳定性判定">系统稳定性判定</h3><p>采样系统稳定的充要条件是闭环系统的特征根全部都在<span class="math inline">\(z\)</span>平面的单位圆内，即<span class="math inline">\(|z|&lt;1\)</span>。为了复用以前的劳斯判据，需要找到一个变换<span class="math inline">\(z\to w\)</span>，把<span class="math inline">\(z\)</span>屏幕的单位圆映射到<span class="math inline">\(w\)</span>平面的虚轴之左。有： <span class="math display">\[z=\frac{w+1}{w-1}\]</span> 在应用时，把特征方程的<span class="math inline">\(z\)</span>全都替换成这个，然后对<span class="math inline">\(w\)</span>使用劳斯判据即可。</p><h3 id="系统的稳态误差">系统的稳态误差</h3><p>首先我们研究的是稳态误差，所以系统首先要有稳态，也就是稳定。所有不讨论稳定性而直接对稳态误差进行讨论的都没有意义。</p><p>则根据终值定理，系统稳态误差为 <span class="math display">\[e^*(\infty)=\lim_{z\to 1}(1-z^{-1})\frac {R(z)}{1+G(z)}\]</span> 如果是阶跃输入，即<span class="math inline">\(R(z)=z/(z-1)\)</span>，则 <span class="math display">\[e^*(\infty)=\frac 1{1+K_P}\]</span> 如果是斜坡输入，<span class="math inline">\(R(z)=Tz/(z-1)^2\)</span>，则 <span class="math display">\[e^*(\infty)=\frac T{K_v}\]</span> 如果是加速输入，<span class="math inline">\(r(t)=0.5t^2\)</span>，<span class="math inline">\(R(z)=T^2z(z+1)/2(z-1)^2\)</span>，则 <span class="math display">\[e^{*}(\infty)=\frac{T^2}{K_a}\]</span></p><p>总结如下：</p><table><thead><tr class="header"><th>输入</th><th>0</th><th>I</th><th>II</th><th>III</th><th>静态误差系数</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(r(t)=1\)</span></td><td><span class="math inline">\(\frac{1}{1+K_p}\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K_p=\lim_{z\to 1}G(z)\)</span></td></tr><tr class="even"><td><span class="math inline">\(r(t)=t\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(T/K_v\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K_v=\lim_{z\to 1}(z-1)G(z)\)</span></td></tr><tr class="odd"><td><span class="math inline">\(r(t)=0.5t^2\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(T^2/K_a\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K_a=\lim_{z\to 1}(z-1)^2G(z)\)</span></td></tr></tbody></table><p>型别指<span class="math inline">\(G(z)\)</span>分母包含<span class="math inline">\((z-1)\)</span>因子的个数，即<span class="math inline">\(z=1\)</span>处极点的个数</p><blockquote><p>【例】对采样周期<span class="math inline">\(T=0.2s\)</span>的系统 <span class="math display">\[G(z)=\frac{0.24z-0.16}{(z-1)^2}\]</span> 求输入为<span class="math inline">\(r(t)=1+t+0.5t^2\)</span>时的稳态误差</p><p>【解】有： <span class="math display">\[e^*(\infty)=\frac 1{K_p+1}+\frac T{K_v}+\frac{T^2}{K_a}\]</span> 其中<span class="math inline">\(K_p=K_v=\infty\)</span>，而 <span class="math display">\[\lim_{z\to 1}(z-1)^2G(z)=0.08\]</span> 所以稳态误差为 <span class="math display">\[e^*(\infty)=0+0+\frac{0.2^2}{0.08}=0.5\]</span></p></blockquote><h2 id="状态空间分析方法">状态空间分析方法</h2><p>状态空间分析方法是一种和前面讲的所有方法都不一样的方法。用传递函数描述系统只能反映系统输出和输入变量的关系，而不了解系统内部的变化情况，而且是建立在零初始状态的基础上的。而状态空间分析方法会客服这些困难。在介绍状态空间分析法前，需要定义：</p><ul><li><p>状态变量：如果以最少的<span class="math inline">\(n\)</span>个变量<span class="math inline">\(x_1(t),\cdots,x_n(t)\)</span>就能完整描述一个系统的行为，这<span class="math inline">\(n\)</span>个变量就称为一组状态变量</p></li><li><p>状态向量：把上面这<span class="math inline">\(n\)</span>个状态变量拼成一个列向量，就叫做状态向量</p></li><li><p>状态空间：以各状态变量为轴的空间是状态空间，状态向量是状态空间里的一个点</p></li><li><p>状态方程：描述状态变量和输入之间关系的一阶微分方程组： <span class="math display">\[\mathbf{\dot x}=A\mathbf x+B\mathbf {u}\]</span> 其中<span class="math inline">\(\mathbf x\)</span>是状态向量，<span class="math inline">\(\mathbf u\)</span>是<span class="math inline">\(r\)</span>维输入向量，<span class="math inline">\(A\)</span>是<span class="math inline">\(n\times n\)</span>矩阵，叫系统矩阵，<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times r\)</span>矩阵，叫输入控制阵</p></li><li><p>输出方程：描述系统输出和输入之间关系的方程组： <span class="math display">\[\mathbf y=C\mathbf x+D\mathbf u\]</span> 其中<span class="math inline">\(y\)</span>是<span class="math inline">\(m\)</span>维输出向量，<span class="math inline">\(C\)</span>是<span class="math inline">\(m\times n\)</span>输出矩阵，<span class="math inline">\(D\)</span>是<span class="math inline">\(m\times r\)</span>矩阵。<strong>一个线性时不变系统可用<span class="math inline">\((A,B,C,D)\)</span>直接描述。</strong></p></li></ul><h3 id="求解系统状态方程和输出方程">求解系统状态方程和输出方程</h3><p>对状态方程左右两边做拉普拉斯变换，有： <span class="math display">\[sX(s)-X(0)=AX(s)+BU(s)\]</span> 化简一下： <span class="math display">\[X(s)=(sI-A)^{-1}[X(0)+BU(s)]\]</span> 设预解矩阵 <span class="math display">\[\phi(s)=(sI-A)^{-1}=\frac{(sI-A)^*}{|sI-A|}\]</span> 所以系统的特征方程为<span class="math inline">\(|sI-A|=0\)</span>。则 <span class="math display">\[X(s)=\phi(s)X(0)+\phi(s)BU(s)\]</span> 同理，对输出方程有： <span class="math display">\[Y(s)=C\phi(s)X(0)+[C\phi(s)B+D]U(s)\]</span> 如果是零状态，则<span class="math inline">\(C\phi(s)B+D\)</span>在这里就起到了传递函数的作用，所以定义传递函数矩阵： <span class="math display">\[G(s)=C\phi(s)B+D\]</span></p><h3 id="可控和可观">可控和可观</h3><h4 id="概念和基本判别方法">概念和基本判别方法</h4><p>对于任意初始状态，如果存在一个控制量能在有限时刻将状态转译为零状态，则称系统状态可控。定义系统可控性阵为： <span class="math display">\[Q_c=[B\quad AB\quad A^2B\cdots\quad A^{n-1}B]\]</span> 如果有<span class="math inline">\(|Q_c|\neq0\)</span>，即<span class="math inline">\(Q_c\)</span>满秩，那么系统可控。</p><p>如果<span class="math inline">\(u(t)\)</span>已知，能由一段时间内的输出测量值唯一确定任意时刻的状态，称为系统可控。定义系统可控性阵为 <span class="math display">\[Q_o=[C\quad CA\cdots CA^{n-1}]^T\]</span> 如果它是满秩的，那么系统可观。</p><h4 id="标准型">标准型</h4><p>如果一个<span class="math inline">\(n\)</span>阶单输入系统可控，则一定存在一个可逆线性变换，将其变为可控标准型。系统的可控标准型为： <span class="math display">\[A_c=\begin{pmatrix}0&amp;1&amp;0&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\ddots&amp;\ddots&amp;\vdots\\0&amp;0&amp;\cdots&amp;\cdots&amp;0\\0&amp;0&amp;\cdots&amp;\cdots&amp;1\\-a_0&amp;-a_1&amp;\cdots&amp;\cdots&amp;-a_{n-1}\end{pmatrix},B_c=\begin{pmatrix}0\\\vdots\\0\\1\end{pmatrix},C_c=(\beta_0,\cdots,\beta_{n-1})\]</span> 此时，对应的系统函数为： <span class="math display">\[G(s)=\frac{\beta_{n-1} s^{n-1}+\cdots+\beta_1 s+\beta_0}{s^n+a_{n-1} s^{n-1}+\cdots+a_1 s+a_0}\]</span> 类似的，有可观测标准型： <span class="math display">\[A_o=\left[\begin{array}{ccccc}0 &amp; 0 &amp; \cdots &amp; 0 &amp; -a_0 \\1 &amp; \cdots &amp; \cdots &amp; 0 &amp; -a_1 \\0 &amp; \ddots &amp; &amp; \vdots &amp; \vdots \\\vdots &amp; &amp; \ddots &amp; \vdots &amp; \vdots \\0 &amp; \cdots &amp; 0 &amp; 1 &amp; -a_{n-1}\end{array}\right], \quad B_o=\left[\begin{array}{c}\gamma_0 \\\gamma_1 \\\vdots \\\gamma_{n-1}\end{array}\right]，C_o=[0,0,\cdots,1]\]</span> 对应的单输入单输出系统传递函数： <span class="math display">\[G(s)=\frac{\gamma_{n-1} s^{n-1}+\cdots+\gamma_1 s+\gamma_0}{s^n+a_{n-1} s^{n-1}+\cdots+a_1 s+a_0}\]</span> 把一个系统的一般形式化成可控标准型，遵循以下步骤：</p><ol type="1"><li><p>计算可控性矩阵<span class="math inline">\(Q_c\)</span></p></li><li><p>计算<span class="math inline">\(Q_c^{-1}\)</span>，记其最后一行为<span class="math inline">\(h^T\)</span></p></li><li><p>构造矩阵<span class="math inline">\(P\)</span>，并求逆 <span class="math display">\[\boldsymbol{P}=\left[\begin{array}{c}\boldsymbol{h}^T \\\boldsymbol{h}^T \boldsymbol{A} \\\boldsymbol{h}^T \boldsymbol{A}^2 \\\vdots \\\boldsymbol{h}^T \boldsymbol{A}^{n-1}\end{array}\right]\]</span></p></li><li><p>得<span class="math inline">\(\overline A=PAP^{-1},\overline B=PB,\overline C=CP^{-1},\overline D=D\)</span></p></li></ol><blockquote><p>【例】把以下系统化为可控标准型 <span class="math display">\[\dot{\boldsymbol{x}}=\left[\begin{array}{ccc}-2 &amp; 2 &amp; -1 \\0 &amp; -2 &amp; 0 \\1 &amp; -4 &amp; 0\end{array}\right] \boldsymbol{x}+\left[\begin{array}{l}0 \\1 \\1\end{array}\right] u\]</span> 【解】有： <span class="math display">\[Ab=\left[\begin{array}{c}1 \\-2 \\-4\end{array}\right],A^2b=\left[\begin{array}{c}-2 \\4 \\9\end{array}\right]\]</span> 得 <span class="math display">\[Q_c=[b\quad Ab\quad A^2b]=\left[\begin{array}{ccc}0 &amp; 1 &amp; -2 \\1 &amp; -2 &amp; 4 \\1 &amp; -4 &amp; 9\end{array}\right]\]</span> 求逆，有： <span class="math display">\[Q_c^{-1}=\left[\begin{array}{ccc}2 &amp; 1 &amp; 0 \\5 &amp; -2 &amp; -2 \\2 &amp; -1 &amp; 1\end{array}\right]\]</span> 取最后一行： <span class="math display">\[h^T=[2\quad -1\quad -1]\]</span> 所以 <span class="math display">\[P=\left[\begin{array}{c}h^T \\h^TA \\h^TA^2\end{array}\right]=\left[\begin{array}{ccc}2 &amp; -1 &amp; 1\\-3 &amp;2 &amp; -2 \\4 &amp; -2 &amp; 3\end{array}\right]\]</span> 所以 <span class="math display">\[\overline A=PAP^{-1}=\left[\begin{array}{ccc}0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\-2 &amp; -5 &amp; -4\end{array}\right]\]</span></p></blockquote><h3 id="状态反馈和极点配置">状态反馈和极点配置</h3><p>对于定常系统 <span class="math display">\[\begin{cases}\dot x=Ax+Bu\\y=Cx\end{cases}\]</span> 如果系统的输入<span class="math inline">\(u\)</span>和<span class="math inline">\(x\)</span>有关系，即 <span class="math display">\[u=hx+r\]</span> 这就叫做状态反馈系统。</p><p>对于系统<span class="math inline">\((A,B,C,0)\)</span>来说，其极点为特征方程<span class="math inline">\(|sI-A|=0\)</span>的根，如果系统不能达到设计指标，那么就需要修改系统的极点的位置，可以适当选取状态反馈变量<span class="math inline">\(h\)</span>，使得状态反馈系统的特征方程<span class="math inline">\(|sI-(A+Bh)|=0\)</span>的根满足性能要求。这样的过程就是极点配置过程。</p><p>只有系统<span class="math inline">\((A,B,C,0)\)</span>完全可控时，才能进行极点配置。</p><blockquote><p>【例】系统 <span class="math display">\[\begin{cases}\dot x=Ax+\begin{bmatrix}2\\1\end{bmatrix}u\\y=[1\quad 1]x\end{cases}\]</span> 的状态转移矩阵 <span class="math display">\[\phi(t)=\begin{bmatrix}e^{-t} &amp; 0\\\beta(e^{-t}-e^{-2t}) &amp; e^{-2t}\end{bmatrix}\]</span></p><ol type="1"><li>求<span class="math inline">\(A\)</span></li><li>计算传递函数，写出可控标准型</li><li>设<span class="math inline">\(\beta=1\)</span>，考虑状态反馈<span class="math inline">\(u=hx\)</span>，设计<span class="math inline">\(h\)</span>使得闭环系统极点为<span class="math inline">\(-1,-3\)</span></li></ol><p>【解】</p><ol type="1"><li><p>做拉普拉斯变换，有： <span class="math display">\[\phi(s)=\begin{bmatrix}\frac 1{s+1} &amp; 0\\\frac \beta{s+1}-\frac \beta{s+2} &amp; \frac 1{s+2}\end{bmatrix}\]</span> 由<span class="math inline">\(\phi=(sI-A)^{-1}\)</span>，先求<span class="math inline">\(\phi^{-1}\)</span>: <span class="math display">\[\phi^{-1}={(s+1)(s+2)}\begin{bmatrix}\frac 1{s+2} &amp; 0\\\frac{-\beta}{(s+1)(s+2)} &amp; \frac 1{s+1}\end{bmatrix}=\begin{bmatrix}{s+1} &amp; 0\\{-\beta} &amp; {s+2}\end{bmatrix}=sI-A\]</span> 所以 <span class="math display">\[A=\begin{bmatrix}-1 &amp; 0\\\beta &amp; -2\end{bmatrix}\]</span></p></li><li><p>传递函数(法1) <span class="math display">\[G(s)=C\phi(s)B=\frac{2\beta+2}{s+1}-\frac{2\beta-1}{s+2}\]</span> 即 <span class="math display">\[G(s)=\frac{s+2\beta+5}{s^2+3s+2}\]</span> 所以 <span class="math display">\[A=\begin{bmatrix}0 &amp; 1\\-2 &amp; -3\end{bmatrix},B=\begin{bmatrix}0\\1\end{bmatrix},C=[2\beta+5\quad 1]\]</span></p></li><li><p>有： <span class="math display">\[\begin{aligned}|sI-(A+BH)|&amp;=\det\begin{bmatrix}s-2H_1+1 &amp; -2H_2\\-H_1-1 &amp; s-H_2+2\end{bmatrix}\\&amp;=s^2+(3-2H_1-H_2)s+2-4H_1-3H_2\end{aligned}\]</span> 要达到题设要求的极点，则要求特征方程为 <span class="math display">\[(s+1)(s+3)=s^2+4s+3\]</span> 对比系数，解方程，得 <span class="math display">\[H=[-1\quad 1]\]</span></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理笔记·数字通信</title>
    <link href="/2023/06/09/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%C2%B7%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/06/09/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%C2%B7%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>虽然这里名叫数字通信，但是需要注意的是，数字通信实际包含三部分内容，即</p><ul><li><a href="https://suzumiyaakizuki.github.io/2023/05/23/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93/">数字信号基带传输</a></li><li>数字调制</li><li>差错控制编码</li></ul><p>但是因为如果单个文件太大、公式太多，写起来会有点卡顿，看起来也比较费劲，所以拆成两篇文章。这篇文章的主要内容是数字调制和差错控制编码。</p><h2 id="数字调制">数字调制</h2><h3 id="二进制调制ook">二进制调制OOK</h3><p>把幅度为<span class="math inline">\(2A\)</span>的单极性非归零码按DSB方式进行调制，得到的就是单极性二进制幅移键控（2ASK），也叫二进制启闭键控（OOK），系统框图如下（其实就是DSB调制的框图）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101922269.png" alt="OOK框图" style="zoom:25%;" /></p><p>即： <span class="math display">\[s(t)=a(t)\sqrt 2 \cos(2\pi f_ct+\phi)\]</span> 调制信号波形示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101926854.png" alt="OOK波形" /><figcaption aria-hidden="true">OOK波形</figcaption></figure><p>波形功率谱密度为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101930718.png" alt="OOK功率谱" /><figcaption aria-hidden="true">OOK功率谱</figcaption></figure><p>可以看出，这个功率谱旁瓣比较高，不是很好。那咋办呢？一种常见的设计就是加个成形滤波。我们采用根升余弦成形滤波，则波形图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101932719.png" alt="根升余弦OOK波形图" /><figcaption aria-hidden="true">根升余弦OOK波形图</figcaption></figure><p>功率谱如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101932930.png" alt="根升余弦功率谱" style="zoom:50%;" /></p><p>看着是不是顺眼多了。其带宽为 <span class="math display">\[\frac{1+\alpha}{T_b}\]</span> 里面的<span class="math inline">\(\alpha\)</span>是根升余弦滤波器的滚降因子。频谱效率为<span class="math inline">\(1/(1+\alpha)\)</span></p><p>在解调时，因为是DSB信号，所以可以用DSB信号的解调方法，比如相干解调</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101941159.png" alt="相干解调" /><figcaption aria-hidden="true">相干解调</figcaption></figure><p>其中MF是匹配滤波器，如果<span class="math inline">\(g(t)\)</span>是矩形窗，那么MF是积分清零器。</p><p>B点基带输入信号、噪声功率谱密度与上一章匹配滤波器输入信号、噪声功率谱密度完全一致，C点判决误符号率为 <span class="math display">\[p_s=Q\left(\frac A{\sqrt{n_0/2}}\right)\]</span> 因为<span class="math inline">\(E_b=E_s=\frac 12(0+4A^2)\)</span>，所以 <span class="math display">\[p_b=Q\left(\sqrt{\frac{E_b}{n_0}}\right)\]</span></p><p>此外，还可以使用包络检波器进行非相干解调。非相干解调的误比特率比相干解调略高，信噪比差在匹配滤波上。</p><h3 id="其余二进制调制">其余二进制调制</h3><h4 id="bpsk">BPSK</h4><p>对单极性非归零码进行相位调制，得到BPSK信号，框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102009621.png" alt="BPSK框图" /><figcaption aria-hidden="true">BPSK框图</figcaption></figure><p>信号表达式为： <span class="math display">\[s(t)=A\sqrt 2cos [2\pi f_ct+\pi  a(t)]\]</span> 其波形是在两种相反的相位（<span class="math inline">\(0,\pi\)</span>）之间切换的正弦波，即：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102010341.png" alt="BPSK波形" /><figcaption aria-hidden="true">BPSK波形</figcaption></figure><p>它也可以理解为一个DSB信号，即：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102011550.png" alt="BPSK调制（DSB版）" /><figcaption aria-hidden="true">BPSK调制（DSB版）</figcaption></figure><p>它和前面的OOK都是2ASK，不过其中一个的幅度是<span class="math inline">\(\{0,A\}\)</span>,而另一个是<span class="math inline">\(\{-A,A\}\)</span></p><p>与OOK相比，其功率谱中没有冲击分量，其余的形状和参数基本类似。</p><p>在解调上，包络检波器显然是不能用了，所以只能相干解调。输出判决误符号率是 <span class="math display">\[p_s=Q\left(\frac A{\sqrt{n_0/2}}\right)\]</span> 但是因为<span class="math inline">\(E_b=E_s=\frac 12 (A^2+A^2)\)</span>，所以： <span class="math display">\[p_b=Q\left(\sqrt{\frac{2E_b}{n_0}}\right)\]</span> 在相同<span class="math inline">\(E_b/n_0\)</span>的条件下，BPSK的误比特率比OOK更低.</p><h4 id="二进制频移键控2fsk">二进制频移键控2FSK</h4><p>把单极性非归零码进行FM调制，就得到2FSK。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102024865.png" alt="image-20230610202459784" style="zoom:25%;" /></p><p>信号表达式为： <span class="math display">\[s(t)=A \sqrt{2} \cos \left[2 \pi f_c t+2 \pi K_{F M} \int_{-\infty}^t a(\tau) d \tau\right]\]</span> 波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102025565.png" alt="2FSK波形" /><figcaption aria-hidden="true">2FSK波形</figcaption></figure><p>当然，如果至少为了实现频率切换，其实还有更方便的方法：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102027135.png" alt="更方便的2FSK" /><figcaption aria-hidden="true">更方便的2FSK</figcaption></figure><p>特别注意：这两个框图并不等价，主要差别在相位是否连续。第二个框图的表达式为 <span class="math display">\[s(t)=\left\{\begin{array}{l}s_1(t)=A \sqrt{2} \cos \left(2 \pi f_1 t+\phi_1\right), a(t)=0 \\s_2(t)=A \sqrt{2} \cos \left(2 \pi f_2 t+\phi_2\right), a(t)=1\end{array}\right.\]</span> 波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102032579.png" alt="image-20230610203256495" /><figcaption aria-hidden="true">image-20230610203256495</figcaption></figure><p>在实践中，一般要求这两个载波信号相互正交，具体来说，就是： <span class="math display">\[\frac{1}{T_s} \int_{k T_s}^{(k+1) T_s} s_1(t) s_2(t) d t=0\]</span> 满足要求的最小频差为<span class="math inline">\(1/2T_b\)</span></p><p>对于上面的那个表达式，可以改写为： <span class="math display">\[s(t)=  {[1-a(t)] A \cdot \sqrt{2} \cos \left(2 \pi f_1 t+\phi_1\right)+}a(t) A \cdot \sqrt{2} \cos \left(2 \pi f_2 t+\phi_2\right)\]</span> 这就是两个OOK之和</p><p>所以它的功率谱密度也是两个OOK之和，即：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102036246.png" alt="image-20230610203610136" /><figcaption aria-hidden="true">image-20230610203610136</figcaption></figure><p>主瓣带宽为<span class="math inline">\(2R_b+\Delta f\)</span></p><p>2FSK一般不用根升余弦脉冲来改善旁瓣，因为这是因为2FSK系统具有恒定的包络，而根号升余弦脉冲成形后的信号包络不是常数（恒包络调制容易实现高发射功率）。</p><p>因为是两个OOK之和，所以既可以用相干解调，也可以用非相干解调，误比特率也和OOK一样，为： <span class="math display">\[p_b=Q\left(\sqrt{\frac{E_b}{n_0}}\right)\]</span> 在相同<span class="math inline">\(E_b/n_0\)</span>的条件下，2FSK和OOK有相同的抗噪声性能</p><p>但如果载波幅度𝐴相同，则OOK的平均比特能量比2FSK小一半，此时OOK的误比特率比2FSK高</p><h4 id="二进制差分相移键控2dpsk">二进制差分相移键控2DPSK</h4><p>若将输入的比特序列先进行差分编码，然后进行BPSK调制，如下图所示，便形成了二进制差分相移键控.</p><p>波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102050391.png" alt="2DPSK" /><figcaption aria-hidden="true">2DPSK</figcaption></figure><p>图中是传号差分，即<span class="math inline">\(d=0\)</span>时相位不变，<span class="math inline">\(d=1\)</span>时相位翻转。</p><p>因为2DPSK从本质上来说还是BPSK，所以可以相干解调。但是2DPSK信息携带在前后两个比特的已调信号相位差上，因此其解调也可以直接检测这个相位差。这种方法叫差分相干解调，如下图所示。因为不需要提取载波，故其属于非相干解调。</p><p>差分译码器的输出是 <span class="math display">\[\hat d_k=\hat c_k \oplus \hat c_{k-1}\]</span> 所以2DPSK相干解调误比特率是 <span class="math display">\[P_s=P_b=2 Q\left(\sqrt{\frac{2 E_b}{n_0}}\right)\left[1-Q\left(\sqrt{\frac{2 E_b}{n_0}}\right)\right]\]</span> 近似为BPSK的两倍，而且会出现误码传播情况。</p><p>直观看一下各个二进制调制的误比特率：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102101982.png" alt="误比特率曲线" /><figcaption aria-hidden="true">误比特率曲线</figcaption></figure><blockquote><p>【例（2022期末）】某二进制数字信号码元传输速率是<span class="math inline">\(2\times 10^6baud\)</span>，分别采用2ASK、2PSK、2FSK系统传输，载波频率100MHz，FSK系统两个频率分别为<span class="math inline">\(f_1=95MHz,f_0=105MHz\)</span>，输入接收端解调器的信号振幅为<span class="math inline">\(A=40\mu V\)</span>，信道噪声是加性高斯白噪声，单边功率谱密度<span class="math inline">\(n_0=5\times 10^{-18} W/Hz\)</span>，求</p><ol type="1"><li>2ASK、2PSK、2FSK频带宽度</li><li>相干接收时，2ASK、2PSK、2FSK误码率</li></ol><p>【解】</p><ol type="1"><li><p>频带宽带，有：<span class="math inline">\(BW_{ASK}=BW_{PSK}=2R_b=4MHz\)</span></p><p><span class="math inline">\(BW_{FSK}=2R_b+\Delta f=14MHz\)</span></p></li><li><p><strong>对2ASK：</strong></p><p><span class="math inline">\(P_1=\frac 12 A^2=8\times 10^{-10}\)</span>，<span class="math inline">\(P_0=0\)</span></p><p>所以平均符号功率：<span class="math inline">\(P_s=\frac 12(P_1+P_0)=4\times 10^{-10}\)</span></p><p>时间为<span class="math inline">\(T_s=1/R_s=5\times 10^{-7}\)</span></p><p>则平均符号能量为<span class="math inline">\(E_s=P_sT_s=2\times 10^{-16}\)</span></p><p>代入 <span class="math display">\[P_e=Q\left(\sqrt{\frac{E_s}{n_0}}\right)=Q(2\sqrt{10})\]</span> <strong>对2PSK：</strong></p><p><span class="math inline">\(P_s=\frac 12A^2=8\times 10^{-10}\)</span></p><p>时间为<span class="math inline">\(T_s=1/R_s=5\times 10^{-7}\)</span></p><p>则平均符号能量为<span class="math inline">\(E_s=P_sT_s=4\times 10^{-16}\)</span></p><p>代入： <span class="math display">\[P_e=Q\left(\sqrt{\frac{2E_s}{n_0}}\right)=Q(4\sqrt{10})\]</span> <strong>对2FSK</strong>：</p><p><span class="math inline">\(P_s=\frac 12A^2=8\times 10^{-10}\)</span></p><p>时间为<span class="math inline">\(T_s=1/R_s=5\times 10^{-7}\)</span></p><p>则平均符号能量为<span class="math inline">\(E_s=P_sT_s=4\times 10^{-16}\)</span></p><p>代入： <span class="math display">\[P_e=Q\left(\sqrt{\frac{E_s}{n_0}}\right)=Q(4\sqrt{5})\]</span></p></li></ol></blockquote><h3 id="正交相移键控qpsk">正交相移键控QPSK</h3><p>可在BPSK的基础上叠加另一个正交载波的BPSK，两个BPSK各传一半数据，如下图所示，这种方式称为正交相移键控（QPSK）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102126707.png" alt="QPSK" /><figcaption aria-hidden="true">QPSK</figcaption></figure><p>在QPSK中，因为数据被串并转换了，所以符号间隔<span class="math inline">\(T_s=2T_b\)</span>。</p><p>发送单个符号<span class="math inline">\((a_{I,k},a_{Q,k})\)</span>时QPSK的数学表达式为： <span class="math display">\[\begin{aligned}s(t)=  \sqrt{2} A a_{I, k} g\left(t-k T_s\right) \cos \left(2 \pi f_c t+\phi\right)-  \sqrt{2} A a_{Q, k} g\left(t-k T_s\right) \sin \left(2 \pi f_c t+\phi\right)\end{aligned}\]</span> 化简得： <span class="math display">\[s(t)=2 g\left(t-k T_s\right) \cos \left(2 \pi f_c t+\phi+\theta_k\right)\]</span> 其中信号控制的是<span class="math inline">\(\theta_k\)</span>，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102145570.png" alt="QPSK相位数据对应表" /><figcaption aria-hidden="true">QPSK相位数据对应表</figcaption></figure><p>星座图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102145947.png" alt="image-20230610214557879" /><figcaption aria-hidden="true">image-20230610214557879</figcaption></figure><p>其功率谱密度是BPSK的两倍。</p><p>对QPSK的解调可以用I/Q两路BPSK解调器组合而成，每个BPSK的误比特率是 <span class="math display">\[p_b=Q\left(\sqrt{\frac{2E_b}{n_0}}\right)\]</span> 所以QPSK的误符号率是 <span class="math display">\[p_s=1-(1-p_b)^2\]</span> 当信噪比较高时，误符号率近似是误比特率的2倍</p><h4 id="oqpsk">OQPSK</h4><p>在普通QPSK中，有时候会出现包络起伏比较严重的情况。为了降低包络起伏程度，可以把两路信号在时间上错开，错开零点，这就叫OQPSK</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102151092.png" alt="QPSK和OQPSK" /><figcaption aria-hidden="true">QPSK和OQPSK</figcaption></figure><p>在发送端，将Q路的信号延迟<span class="math inline">\(T_b=T_s/2\)</span>即可。其功率谱、误码率等和QPSK相同。</p><h4 id="恒包络调制msk">恒包络调制MSK</h4><p>为了降低非线性失真的影响，希望数字调制的输出信号有较低的包络起伏。OQPSK就是为此目的提出的，它通过将Q路错开𝑇𝑏时间使包络的起伏显著减小。包络起伏最小的情况是无起伏，即包络是常数。包络是常数的调制称为恒包络调制。</p><p>在2FSK中，若FM调制的设计能使2FSK信号的两个频率的频差成为保持正交的最小间隔<span class="math inline">\(1/2T_s\)</span>，那就得到了最小频移键控MSK。</p><p>有： <span class="math display">\[s(t)==A \cos \left[2 \pi f_{\mathrm{c}} t+2 \pi K_{\mathrm{FM}} \int_{-\infty}^t a(\tau) \mathrm{d} \tau\right]\]</span> 其相位有： <span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} t} \varphi(t)=\frac{\pi}{2 T_{\mathrm{b}}} \cdot a(t)=\frac{\pi}{2 T_{\mathrm{b}}} \cdot \sum_{i=-\infty}^{\infty} b_i g\left(t-i T_{\mathrm{b}}\right)\]</span> 其中<span class="math inline">\(a(t)\)</span>是取值于<span class="math inline">\(\pm1\)</span>的双极性NRZ信号，<span class="math inline">\(g(t)\)</span>是持续时间为<span class="math inline">\([0,Ts]\)</span>,高度为1的矩形脉冲。<span class="math inline">\(b\in\{±1\}\)</span>代表双极性NRZ信号所携带的二进制数据。</p><p>MSK是用FM形成的，而不是用开关形成的，相位是连续的，而且可以绘出相位路径：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102212833.png" alt="MSK相位路径" /><figcaption aria-hidden="true">MSK相位路径</figcaption></figure><p>其在每一个比特间隔中都是连续线性变化，往上走还是往下走取决于<span class="math inline">\(b_i\)</span>的取值。如果<span class="math inline">\(b_i\)</span>是<span class="math inline">\(1\)</span>，那就是往上走，否则如果<span class="math inline">\(b_i=-1\)</span>就是往下走。</p><p>事实上如果OQASK使用了一种特殊的成型脉冲：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102216057.png" alt="特殊地成型脉冲" style="zoom:25%;" /></p><p>那它就是MSK。所以MSK的功率谱可以从OQPSK得到。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102217064.png" alt="MSK和QPSK的功率谱" /><figcaption aria-hidden="true">MSK和QPSK的功率谱</figcaption></figure><p>MSK的主瓣带宽是<span class="math inline">\(1.5/𝑇_𝑏\)</span>，QPSK的主瓣带宽是<span class="math inline">\(1/𝑇_𝑏\)</span></p><h3 id="高阶调制">高阶调制</h3><h4 id="mask">MASK</h4><p>类比于2ASK，其中M是符号数。在功率谱上，双极性MASK信号与BPSK一致（没有线谱），单极性MASK信号与OOK一致（有线谱）。MASK的误符号率已经在“数字信号基带传输”里分析过了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102154836.png" alt="双极性MASK误符号率曲线" /><figcaption aria-hidden="true">双极性MASK误符号率曲线</figcaption></figure><h4 id="qam">QAM</h4><p>类似于用俩载波正交BPSK构成QPSK，也可以用俩载波正交ASK构成QAM。</p><p>MQAM是由两路<span class="math inline">\(\sqrt M\)</span>ASK组成的：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102157477.png" alt="16QAM" /><figcaption aria-hidden="true">16QAM</figcaption></figure><p>误符号率： <span class="math display">\[p_s=1-\left(1-p_{s, \mathrm{ASK}}\right)^2 \approx \frac{4(\sqrt{M}-1)}{\sqrt{M}} Q\left(\sqrt{\frac{3}{M-1} \frac{E_s}{n_0}}\right)\]</span></p><h4 id="mfsk">MFSK</h4><p>MFSK的星座图是在M维欧氏空间的每个坐标轴上放一个点。</p><p>对某一个载频来说，开关时而接通，时而断开，形成一个OOK。因此可将MFSK信号看成是M个OOK信号的叠加。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102202551.png" alt="MFSK框图" /><figcaption aria-hidden="true">MFSK框图</figcaption></figure><p>主瓣带宽为： <span class="math display">\[B=\left|f_M-f_1\right|+2 R_s\]</span> 在频差按最佳设计的情况下，相邻载波的频差是1/(2𝑇𝑠 )=𝑅𝑠/2，主瓣带宽为 <span class="math display">\[B=\frac{M-1}{2} R_s+2 R_s=\frac{M}{2} R_s+1.5 R_s\]</span></p><h4 id="mpsk">MPSK</h4><p>MPSK的星座分布在圆上</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102209338.png" alt="MPSK" /><figcaption aria-hidden="true">MPSK</figcaption></figure><h2 id="差错控制编码">差错控制编码</h2><p>在实际信道上传输数字信号时，由于信道传输特性不理想及加性噪声的影响，接收端所收到的数字信号不可避免地会发生错误。为了在给定信噪比情况下达到一定的误比特率指标，应该合理设计基带信号，选择调制解调方式，采用时域、频域均衡，使误比特率尽可能降低。但若误比特率仍不能满足要求，则必须采用信道编码（即差错控制编码），将误比特率进一步降低。</p><p>差错控制的基本思路是：在发送端给被传送的信息附带一些冗余的监督码元，这些监督码元和信息码元之间以某种规则建立联系，然后在接收端检验收到的信息是否符合这样的联系，如果不符合，那么就可以断定传输中出现了错误。</p><p>常用的差错控制方式主要有三种：检错重发（实时性不好），前向纠错（效率高，实时性好，可靠性低），混合ARQ。其中检错重发又有停发等候重发、返回重发、选择重发。</p><h3 id="检错和纠错的基本原理">检错和纠错的基本原理</h3><p>之前已经说了差错控制的基本思路，接下来举例说明一下。</p><p>比如三位二进制码共有八种，即：<code>000</code>,<code>001</code>,<code>010</code>,<code>011</code>,<code>100</code>,<code>101</code>,<code>110</code>,<code>111</code></p><p>如果都用来传递信息，那么不能检错。</p><p>但是如果只使用四个码<code>000</code>,<code>011</code>,<code>101</code>,<code>110</code>，其中前两位是要传递的信息，而最后一位是前两位的模2和，其它四个码是禁用码字。如果接收端接收到了禁用码字，那么就可以断言传输过程中出现了错误。这就是检错的过程。</p><p>在信道编码中，定义码组中非零位的数目为码组的重量，简称<strong>码重</strong>。</p><p>把两个码组中对应码位上具有不同二进制位的位数定义为两码组的距离，称为<strong>汉明距</strong>，简称<strong>码距</strong>。</p><p>如果要在一个码组内检测<span class="math inline">\(e\)</span>个误码，要求最小码距 <span class="math display">\[d_{min}\geq e+1\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092042269.png" alt="示意图" /></p><p>如图所示，如果误码个数不超过<span class="math inline">\(e\)</span>，则说明码组的位置移动不会离开半径为<span class="math inline">\(e\)</span>的多维球中。这意味着其它码组必须位于以<span class="math inline">\(C\)</span>为圆心，以<span class="math inline">\(e+1\)</span>为半径的圆上或圆外。</p><p>如果要在一个码组内纠正<span class="math inline">\(t\)</span>个误码，要求最小码距 <span class="math display">\[d_{min}\geq 2t+1\]</span> 示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092045497.png" alt="纠错示意图" /><figcaption aria-hidden="true">纠错示意图</figcaption></figure><p>只要这两个码字的移动范围不相交，那么就可以进行纠正。</p><p>如果要在一个码组内纠正<span class="math inline">\(t\)</span>个误码，同时检测<span class="math inline">\(e\)</span>个误码，则要求最小码距 <span class="math display">\[d_{min}\geq t+e+1\]</span> 示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092047657.png" alt="纠错检错示意图" /><figcaption aria-hidden="true">纠错检错示意图</figcaption></figure><h3 id="线性分组码">线性分组码</h3><p>将信息码分组，为每组信息位附加若干监督位，且信息位和监督位间的关系可由线性方程组表示的编码，称为线性分组码。这些码字构成一个群，性质有：</p><ul><li>任意两个码字的逐位模2和仍然是码字</li><li>码的最小距离等于非零码的最小重量</li></ul><p>比如前面提到的奇偶校验码，就是一种最简单的线性分组码，其偶校验关系为： <span class="math display">\[a_0\oplus a_1\cdots a_{n-1}=0\]</span> 接收时，计算 <span class="math display">\[s=a_1+a_2+\cdots+a_{n-1}\]</span> 这里的<span class="math inline">\(s\)</span>称为校正子或者伴随式，如果<span class="math inline">\(s=0\)</span>表示没有错误。</p><p>对于码总长为<span class="math inline">\(n\)</span>，信息位长度为<span class="math inline">\(k\)</span>，校验长度为<span class="math inline">\(r=n-k\)</span>的线性分组码，一般记作<span class="math inline">\((n,k)\)</span>线性分组码。例如上面的奇偶校验码就是<span class="math inline">\((n,n-1)\)</span>线性分组码。如果满足<span class="math inline">\(2^r-1\geq n\)</span>，则有可能构造出纠正一位甚至更多错误的分组码。</p><p>下面通过一个更加一般的例子来说明如何构造线性分组码。设<span class="math inline">\((n,k)\)</span>分组码中<span class="math inline">\(n=7\)</span>，要求校正一位错误，则<span class="math inline">\(r\geq 3\)</span>。现取<span class="math inline">\(r=3,k=4\)</span>，即为<span class="math inline">\((7,4)\)</span>分组码。用<span class="math inline">\(a_0a_1a_2a_3a_4a_5a_6\)</span> 表示一个码字，用<span class="math inline">\(s_1s_2s_3\)</span>表示三个校正子，假设<span class="math inline">\(s_1s_2s_3\)</span>和误码位置的关系如下表：</p><table><thead><tr class="header"><th>s1s2s3</th><th>误码位置</th><th>s1s2s3</th><th>误码位置</th></tr></thead><tbody><tr class="odd"><td>001</td><td>a0</td><td>101</td><td>a4</td></tr><tr class="even"><td>010</td><td>a1</td><td>110</td><td>a5</td></tr><tr class="odd"><td>100</td><td>a2</td><td>111</td><td>a6</td></tr><tr class="even"><td>011</td><td>a3</td><td>000</td><td>无误码</td></tr></tbody></table><p>先看<span class="math inline">\(s_1\)</span>，当误码位置为<span class="math inline">\(a_2,a_4,a_5\)</span>或<span class="math inline">\(a_6\)</span>时，<span class="math inline">\(s_1=1\)</span>，因此，有： <span class="math display">\[s_1=a_2+a_4+a_5+a_6\]</span> 如法炮制，对<span class="math inline">\(s_2\)</span>有： <span class="math display">\[s_2=a_1+a_3+a_5+a_6\]</span> 对<span class="math inline">\(s_3\)</span>有： <span class="math display">\[s_3=a_6+a_4+a_3+a_0\]</span> 假设<span class="math inline">\(a_3a_4a_5a_6\)</span>是用来承载信息的位，<span class="math inline">\(a_0a_1a_2\)</span>是校验位，则有： <span class="math display">\[\begin{cases}a_6+a_5+a_4+a_2=0\\a_6+a_5+a_3+a_1=0\\a_6+a_4+a_3+a_0=0\end{cases}\]</span> 移项一下，就是： <span class="math display">\[\left\{\begin{array}{l}a_2=a_6+a_5+a_4 \\a_1=a_6+a_5+a_3 \\a_0=a_6+a_4+a_3\end{array}\right.\]</span> 由此可以生成16个许用码字：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092207213.png" alt="（7，4）分组码" /><figcaption aria-hidden="true">（7，4）分组码</figcaption></figure><p>如果把检验方程式写成比较完整的形式，有： <span class="math display">\[\left\{\begin{array}{l}1 \cdot a_6+1 \cdot a_5+1 \cdot a_4+0 \cdot a_3+1 \cdot a_2+0 \cdot a_1+0 \cdot a_0=0 \\1 \cdot a_6+1 \cdot a_5+0 \cdot a_4+1 \cdot a_3+0 \cdot a_2+1 \cdot a_1+0 \cdot a_0=0 \\1 \cdot a_6+0 \cdot a_5+1 \cdot a_4+1 \cdot a_3+0 \cdot a_2+0 \cdot a_1+1 \cdot a_0=0\end{array}\right.\]</span> 写成矩阵形式，有： <span class="math display">\[\left[\begin{array}{lllllll}1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{lllllll}a_6 &amp; a_5 &amp; a_4 &amp; a_3 &amp; a_2 &amp; a_1 &amp; a_0\end{array}\right]^T=\left[\begin{array}{l}0 \\0 \\0\end{array}\right]\]</span> 即： <span class="math display">\[Ha=0\]</span></p><p>这里的<span class="math inline">\(r\times n\)</span>矩阵<span class="math inline">\(H\)</span>​称为<strong>校验矩阵</strong>，信息位与校验位之间的校验关系完全由<span class="math inline">\(H\)</span>决定。矩阵中元素1表示相应位之间存在偶校验关系. <span class="math display">\[\mathbf{H}=\left[\begin{array}{llllllll}1 &amp; 1 &amp; 1 &amp; 0 &amp; \vdots &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 &amp; \vdots &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 &amp; \vdots &amp; 0 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{ll}\mathbf{P} &amp; \mathbf{I}_r\end{array}\right]\]</span> 其中<span class="math inline">\(P\)</span>是<span class="math inline">\(r\times k\)</span>阶矩阵，表示实际校验关系，而<span class="math inline">\(I\)</span>是<span class="math inline">\(r\)</span>阶单位阵，表示校验位是<span class="math inline">\(a_2a_1a_0\)</span>这三位。具有上面形式的校验矩阵称为<strong>系统形式校验矩阵</strong>。</p><p>对于生成方程，也可以写出其矩阵形式： <span class="math display">\[\left[\begin{array}{lll}a_2 &amp; a_1 &amp; a_0\end{array}\right]=\left[\begin{array}{llll}a_6 &amp; a_5 &amp; a_4 &amp; a_3\end{array}\right]\left[\begin{array}{lll}1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1\end{array}\right]=\left[\begin{array}{llll}a_6 &amp; a_5 &amp; a_4 &amp; a_3\end{array}\right] \mathbf{Q}\]</span> 其中<span class="math inline">\(Q\)</span>是<span class="math inline">\(k\times r\)</span>矩阵，是<span class="math inline">\(P\)</span>的转置。如果给<span class="math inline">\(Q\)</span>的左边加上一个<span class="math inline">\(k\)</span>阶单位阵，那么就形成了一个新的矩阵<span class="math inline">\(G\)</span>，这个<span class="math inline">\(G\)</span>叫做<strong>“生成矩阵”</strong> <span class="math display">\[\mathbf{G}=\left[\begin{array}{ll}\mathbf{I}_k &amp; \mathbf{Q}\end{array}\right]=\left[\begin{array}{lllllll}1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\end{array}\right]\]</span> 那么如何利用生成矩阵生成码字呢？有： <span class="math display">\[\mathbf{a}^T=\left[\begin{array}{llll}a_6 &amp; a_5 &amp; a_4 &amp; a_3\end{array}\right] \mathbf{G}\]</span></p><blockquote><p>【例】某<span class="math inline">\((n,k)\)</span>线性分组码的监督（校验）矩阵是： <span class="math display">\[H=\left[\begin{array}{lllllll}1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span></p><ol type="1"><li>求<span class="math inline">\(n,k\)</span></li><li>求生成矩阵</li><li>现在要传输信息<code>110</code>，请写出生成码字</li><li>假设接收到了<code>B=1000011</code>，请纠正</li></ol><p>【解】</p><ol type="1"><li><p>因为<span class="math inline">\(H\)</span>是<span class="math inline">\(4\times 7\)</span>矩阵，所以<span class="math inline">\(n=7,k=n-r=3\)</span></p></li><li><p>因为 <span class="math display">\[H=[P\quad I_4]\]</span> 所以 <span class="math display">\[Q=P^T=\left[\begin{array}{lll}1&amp;1 &amp; 1 &amp; 0 \\0&amp;1 &amp; 1 &amp; 1 \\1&amp;1 &amp; 0 &amp; 1\end{array}\right]\]</span> 所以 <span class="math display">\[G=[I_k Q]=\left[\begin{array}{lllllll}1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1\end{array}\right]\]</span></p></li><li><p>当信息为<code>110</code>时，有： <span class="math display">\[A=[110]G=[1101001]\]</span> 所以信息是<code>1101001</code></p></li><li><p>由校正子： <span class="math display">\[S=BH^T=(1000011)\left[\begin{array}{llll}1 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 1 \\1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]=(1101)\]</span> 因为 <span class="math display">\[S=EH^T\]</span> 得校正子为<code>0010000</code>，所以纠错后的码字为<code>1010011</code></p></li></ol></blockquote><h3 id="汉明码">汉明码</h3><p>汉明码是最早发现，最知名的分组码之一。它有以下特点：</p><ul><li>码长<span class="math inline">\(n=2^m-1\)</span></li><li>信息码位<span class="math inline">\(k=2^m-m-1\)</span></li><li>校验码位：<span class="math inline">\(r=n-k=m\)</span></li></ul><p>根据系统需要，有时有必要对现有的码进行修改，使其码长、信息位数目等参数的取值更为灵活，以提高实用性。对码进行修改的方法有多种，最常用的是码的扩展与缩短，从而得到扩展码和缩短码</p><p>如果要加上一位对所有位进行整体校验的校验位，则汉明码变成<span class="math inline">\((2^m,2^m-m-1)\)</span>扩展汉明码，这会在校验矩阵<span class="math inline">\(H\)</span>的最右侧添加一列全0，然后在最上面（或者最下面）添加一行全1。此时信息位数目不变但是校验位数目增大，能够纠正的错误图样也会增大。</p><p>除了扩展，也可以通过删除信息位的方式来提升纠错能力。如果把<span class="math inline">\(H\)</span>矩阵最左侧的<span class="math inline">\(s\)</span>列删除，则相当于把<span class="math inline">\(G\)</span>矩阵中的左侧的单位阵删除<span class="math inline">\(s\)</span>列，然后把这些列中非零元对应的行也一并删除。示意图如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101019812.png" alt="删除码示意图" />、</p><h3 id="循环码">循环码</h3><p>循环码是一种满足任何许用码字经过循环移位一行的码字还是许用码字的线性分组码，同样具有线性分组码的封闭性。</p><p>为了用代数学理论研究循环码，可将码字用多项式来表示，称为码多项式。码字<span class="math inline">\(A=\left(a_{n-1} a_{n-2} \cdots a_1 a_0\right)\)</span>可表示为 <span class="math display">\[A(D)=a_{n-1} D^{n-1}+a_{n-2} D^{n-2}+a_{n-3} D^{n-3}+\cdots+a_1 D+a_0\]</span> 这里的<span class="math inline">\(D\)</span>叫做哑元，它本身没什么意义，但是它的幂次很有意义。</p><p>那么如果把码字向左循环移位记作<span class="math inline">\(A^{(i)}\)</span>，那么： <span class="math display">\[A^{(i)}(D) \equiv D^i A(D) \quad \bmod \quad\left(D^n+1\right)\]</span> 对于二元码，码多项式的系数只能从0和1中选取。0和1组成一个集合，并在该集合中定义两种运算：加法和乘法，运算规则如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101047937.png" alt="GF(2)上的运算" /><figcaption aria-hidden="true">GF(2)上的运算</figcaption></figure><p><span class="math inline">\(\{0,1,\oplus,\times\}\)</span>构成一个代数系，称为二元域，它是最小的有限域（伽罗华域），记作<span class="math inline">\(GF(2)\)</span></p><p>循环码完全由其码长<span class="math inline">\(𝑛\)</span>及生成多项式<span class="math inline">\(𝑔(𝐷)\)</span>所决定.<span class="math inline">\(g(D)\)</span>是一个能整除<span class="math inline">\(D^n+1\)</span>的<span class="math inline">\(r=n-k\)</span>阶多项式，也就是说，<span class="math inline">\(g(D)\)</span>是<span class="math inline">\(D^n+1\)</span>的一个因式。所有阶数低于<span class="math inline">\(n\)</span>并且能被<span class="math inline">\(g(D)\)</span>整除（即：是<span class="math inline">\(g(D)\)</span>的倍式）的多项式就构成一个<span class="math inline">\((n,k)\)</span>循环码。</p><p>例如，对于<span class="math inline">\((7,3)\)</span>循环码，<span class="math inline">\(g(D)=D^4+D^3+D^2+1\)</span>是<span class="math inline">\(D^7+1\)</span>的一个因子，有： <span class="math display">\[\begin{aligned} 0&amp;=g(D) \cdot 0 \\ D^4+D^3+D^2+1&amp;=g(D) \cdot 1 \\ D^5+D^4+D^3+D&amp;=g(D) \cdot D \\ D^6+D^5+D^4+D^2&amp;=g(D) \cdot D^2 \\ D^5+D^2+D+1&amp;=g(D) \cdot(D+1) \\ D^6+D^3+D^2+D&amp;=g(D) \cdot\left(D^2+D\right) \\ D^6+D^5+D^3+1&amp;=g(D) \cdot\left(D^2+1\right) \\ D^6+D^4+D+1&amp;=g(D) \cdot\left(D^2+D+1\right) \\\end{aligned}\]</span> 那么这八个多项式就构成一个有八个码组的<span class="math inline">\((7,3)\)</span>循环码。</p><p>循环码的生成矩阵，可以很容易地由生成多项式得到。先写出多项式矩阵 <span class="math display">\[G(D)=\left[\begin{array}{c}D^{k-1} g(D) \\D^{k-2} g(D) \\\vdots \\D^0 g(D)\end{array}\right]\]</span> 因为 <span class="math display">\[A(D)=M(D)G(D)\]</span> 对应于前面的 <span class="math display">\[a^T=a_c^TG\]</span> 所以对应的生成矩阵就是 <span class="math display">\[\mathbf{G}=\left[\begin{array}{lcccccc}g_{n-k} &amp; g_{n-k-1} &amp; \cdots &amp; g_0 &amp; 0 &amp; \cdots &amp; 0 \\0 &amp; g_{n-k} &amp; g_{n-k-1} &amp; \cdots &amp; g_0 &amp; \cdots &amp; 0 \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\0 &amp; \cdots &amp; 0 &amp; g_{n-k} &amp; g_{n-k-1} &amp; \cdots &amp; g_0\end{array}\right]\]</span> 这是一个循环移位矩阵。可以看出，这个矩阵很可能不是系统形式矩阵，因为左边不一定是单位阵。系统码码字的最左<span class="math inline">\(k\)</span>位是信息位，随后是<span class="math inline">\(r=n-k\)</span>位校验位，也就是说码多项式是 <span class="math display">\[A(D)=M(D)D^{n-k}+r(D)\]</span> 这里 <span class="math display">\[r(D)=r_{n-k-1} D^{n-k-1}+\cdots+r_0\]</span> 是校验多项式。那么<span class="math inline">\(A(D)\)</span>能被<span class="math inline">\(g(D)\)</span>整除的条件就是 <span class="math display">\[r(D)=M(D) D^{n-k} \bmod g(D)\]</span> 于是，构造系统循环码的步骤是先把信息多项式乘以<span class="math inline">\(D^{n-k}\)</span>，然后对<span class="math inline">\(g(D)\)</span>求余生成校验多项式，然后链接在一起。</p><p>系统形式的生成矩阵<span class="math inline">\(G=[I_k\quad Q]\)</span>，每行对应的信息多项式为<span class="math inline">\(m_i(D)=D^{k-i}\)</span></p><p>对应的校验多项式是 <span class="math display">\[r_i(D)=D^{n-i}\bmod g(D)\]</span> 因此系统循环码生成矩阵多项式的一般表示为 <span class="math display">\[G(D)=\left[\begin{array}{c}A_1(D) \\A_2(D) \\\vdots \\A_k(D)\end{array}\right]=\left[\begin{array}{c}D^{n-1}+r_1(D) \\D^{n-2}+r_2(D) \\\vdots \\D^{n-k}+r_k(D)\end{array}\right]\]</span> 对于所有线性分组码，非系统形式的生成矩阵经过高斯消元(初等行变换）运算也一定能够可以化为系统形式.</p><p>循环码的编码器可以用带反馈的线性移位寄存器来实现，如下图所示，以<span class="math inline">\(g(D)=D^6+D^5+D^4+D^3+1\)</span>为例：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101505555.png" alt="线性移位寄存器" /><figcaption aria-hidden="true">线性移位寄存器</figcaption></figure><p>生成多项式哪一项有值，就在寄存器的第几个模块的后面增加一个异或门，这就是内接异或门触发电路的构成方法。</p><p>循环码的译码主要分三步进行：</p><ol type="1"><li><p>由接收到的码多项式𝐵(𝐷)计算校正子（伴随式）多项式𝑆(𝐷)： <span class="math display">\[S=BH^T\]</span> 对于循环码来说： <span class="math display">\[S(D) \equiv B(D) \bmod g(D) \equiv E(D) \bmod g(D)\]</span> 因此，循环码的校正子多项式<span class="math inline">\(S(D)\)</span>就是用接收到的码多项式除以生成多项式<span class="math inline">\(g(D)\)</span>所得到的余式</p></li><li><p>由校正子多项式<span class="math inline">\(S(D)\)</span>确定错误图样<span class="math inline">\(E(D)\)</span></p></li><li><p>将错误图样<span class="math inline">\(E(D)\)</span> 与<span class="math inline">\(B(D)\)</span>相加，纠正错误</p></li></ol><blockquote><p>【例】已知<span class="math inline">\((7,4)\)</span>循环码的生成多项式是<span class="math inline">\(g(D)=D^3+D+1\)</span>,求：</p><ol type="1"><li>系统生成矩阵</li><li>系统监督矩阵</li><li>信息码为<code>1101</code>，请编码</li></ol><p>【解】</p><ol type="1"><li><p>有多项式矩阵： <span class="math display">\[G(x)=\left[\begin{array}{c}x^3 g(x) \\x^2 g(x) \\x g(x) \\g(x)\end{array}\right]=\left[\begin{array}{c}x^6+x^4+x^3 \\x^5+x^3+x^2 \\x^4+x^2+x \\x^3+x+1\end{array}\right]\]</span> 即： <span class="math display">\[G=\left[\begin{array}{l}1011000 \\0101100 \\0010110 \\0001011\end{array}\right]\]</span> 经矩阵初等行变换，即给第一行加第三行和第四行，给第二行加第四行，有： <span class="math display">\[G=\left[\begin{array}{l}1000101 \\0100111 \\0010110 \\0001011\end{array}\right]\]</span></p></li><li><p>由<span class="math inline">\(H=[PI_r]\)</span>，有： <span class="math display">\[\mathbf{H}=[\mathbf{P} \mathbf{I} _r]=\left[\begin{array}{l}1110100 \\0111010 \\1101001\end{array}\right]\]</span></p></li><li><p><span class="math inline">\(A=MG\)</span>=<code>1101001</code></p></li></ol></blockquote><h3 id="分组码的误码性能">分组码的误码性能</h3><p>下面仅就二进制对称信道及加性白色高斯噪声信道的情形，对一些常用的线性分组码进行讨论。</p><h4 id="二进制对称信道">二进制对称信道</h4><p>意思即是把0误为1和把1误为0的概率一样，都是<span class="math inline">\(p_e\)</span>的信道。（忘了的话去看信息论）</p><p>不加纠错的误字率： <span class="math display">\[P_w=\sum_{i=1}^n p(i, n)=\sum_{i=1}^n\left(\begin{array}{l}n \\i\end{array}\right) p_e^i\left(1-p_e\right)^{n-i}\]</span> 加了纠错以后，如果纠错能力是<span class="math inline">\(t\)</span>，误字率的上界： <span class="math display">\[P_{w c}\leq\sum_{i=t+1}^n\left(\begin{array}{l}n \\i\end{array}\right) p_e^i\left(1-p_e\right)^{n-i}\]</span> 注意看<span class="math inline">\(\Sigma\)</span>符号的下面。</p><p>一般来说，对于译码后的误比特率取决于特定的码及译码器，可近似地有 <span class="math display">\[P_b \leq \sum_{i=t+1}^n \frac{i}{n}\left(\begin{array}{l}n \\i\end{array}\right) p_e^i\left(1-p_e\right)^{n-i}\]</span></p><h4 id="加性高斯白噪声信道">加性高斯白噪声信道</h4><p>考虑BPSK，原始误码率为： <span class="math display">\[p_b=Q\left(\sqrt{\frac{2E_c}{n_0}}\right)\]</span> 其中，<span class="math inline">\(E_c\)</span>为单位调制符号能量，<span class="math inline">\(n_0\)</span>为噪声单边功率谱密度。定义单位信息比特的能量为<span class="math inline">\(E_b\)</span>。如果没有差错控制编码，本来应该是<span class="math inline">\(E_c=E_b\)</span>的，所以前一节里面的BPSK误码率里面写的是<span class="math inline">\(E_b\)</span>。但是现在有了差错控制编码，有： <span class="math display">\[E_b=E_c\frac nk\]</span> 所以 <span class="math display">\[p_e=Q\left(\sqrt{\frac{2 E_b}{n_0} \frac{k}{n}}\right)\]</span></p><hr /><p>通信原理的笔记到这里就结束了。关于后面的同步、多址和复用，请收看：</p><p><a href="https://github.com/FuryMartin/EE-Notes/tree/master/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">FuryMartin的笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息论笔记·信道和编码</title>
    <link href="/2023/05/26/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0%C2%B7%E4%BF%A1%E9%81%93%E5%92%8C%E7%BC%96%E7%A0%81/"/>
    <url>/2023/05/26/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0%C2%B7%E4%BF%A1%E9%81%93%E5%92%8C%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="离散信道及其容量">离散信道及其容量</h2><h3 id="信道的分类">信道的分类</h3><p>根据信道的输入输出特性，可以分为：</p><ol type="1"><li>离散信道：输入输出空间都是离散的</li><li>连续信道：输入输出空间都是连续的</li><li>半连续信道：输入输出空间中一个是离散的，而另一个是连续的</li><li>波形信道：输入输出都是时间的实函数</li></ol><p>根据信道的统计特性，可以分为：</p><ol type="1"><li>恒参信道：统计特性不随时间变化</li><li>变参信道：统计特性随时间变化</li></ol><p>根据信道的记忆特性，可以分为：</p><ol type="1"><li>无记忆信道：信道输出仅仅和当前的输入有关</li><li>有记忆信道：信道的输出还和过去的输入有关</li></ol><p>还有几种比较特殊的信道：</p><p>满足以下条件之一（其实三个条件等价）的信道称为无损信道，无损信道的输出完全由输入决定：</p><ol type="1"><li>总存在输出符号集合<span class="math inline">\(b_1,\cdots b_k\)</span>，满足<span class="math inline">\(P(Y\in b_i|x=x_i)=1\)</span></li><li>对于所有的输入分布，只要<span class="math inline">\(p(y_j)\neq 0\)</span>，则总有一个<span class="math inline">\(x_i\)</span>使得<span class="math inline">\(p(x_i|y_j)=0\)</span></li><li>对于所有的输入分布，已知<span class="math inline">\(Y\)</span>时，<span class="math inline">\(X\)</span>的不确定度为零，即<span class="math inline">\(H(X|Y)=0\)</span></li></ol><p>满足以下条件之一（其实两个条件等价）的信道称为无噪信道，无噪信道中不存在随机干扰：</p><ol type="1"><li>对于所有的<span class="math inline">\(x_i\)</span>，都存在一个<span class="math inline">\(y_j\)</span>，使得<span class="math inline">\(p(x_i|y_j)=1\)</span></li><li><span class="math inline">\(H(Y|X)=0\)</span></li></ol><p>既无损又无噪的信道叫做确定信道。</p><h3 id="离散无记忆信道">离散无记忆信道</h3><p>首先来讨论单符号离散信道。假设信道输入随机变量（总体）为<span class="math inline">\(X\)</span>，其取值为<span class="math inline">\(x\)</span>， <span class="math inline">\(x\in A=\{a_1 ,a_2 ,……,a_r\}\)</span>；输出随机变量为<span class="math inline">\(Y\)</span>，取值为<span class="math inline">\(y\)</span>， <span class="math inline">\(y\in B={b_1 ,b_2 , ……,b_s }\)</span>。信道传递概率为 <span class="math display">\[p(y|x)=P(Y=b_j|X=a_i)=p(b_j|a_i)\]</span> 于是，可以用一个<span class="math inline">\(p\)</span>组成的矩阵来描述这个信道，有： <span class="math display">\[\mathbf P=\begin{pmatrix}p_{11} &amp; p_{12} &amp; \cdots &amp;p_{1s}\\p_{21} &amp; p_{22} &amp; \cdots &amp;p_{2s}\\\cdots &amp; \cdots &amp; \cdots &amp;\cdots\\p_{r1} &amp; p_{r2} &amp; \cdots &amp;p_{rs}\end{pmatrix}\]</span> 其中<span class="math inline">\(p_{ij}=p(b_j|a_i)\)</span>。这个矩阵的每个元素都大于等于零，而且行和都是<span class="math inline">\(1\)</span>。</p><p>接下来介绍几个后面常用的名词，以免产生困扰：</p><ul><li><p>先验概率：指的是信源的统计特性，即： <span class="math display">\[p(a_i)=p(X=a_i)\]</span></p></li><li><p>前向概率：即信道传递概率，也就是上面那个矩阵里面的元素，表示已经收到信源为<span class="math inline">\(a_i\)</span>时信道输出<span class="math inline">\(b_j\)</span>的概率，即 <span class="math display">\[p(b_j|a_i)=p(Y=b_j|X=a_i)\]</span></p></li><li><p>输出符号概率：指的是输出的统计特性，即： <span class="math display">\[p(b_j)=p(Y=b_j)\]</span></p></li><li><p>后向概率：指的是目前已经知道输出是<span class="math inline">\(b_j\)</span>，在这个情况下信源是<span class="math inline">\(a_i\)</span>的概率，即： <span class="math display">\[p(a_i|b_j)=p(X=a_i|Y=b_j)\]</span></p></li><li><p>联合概率：指的是输入为<span class="math inline">\(a_i\)</span>而且输出为<span class="math inline">\(b_j\)</span>的概率，即： <span class="math display">\[p(a_ib_j)=p(X=a_i,Y=b_j)\]</span> 有： <span class="math display">\[p(a_ib_j)=p(b_j)p(a_i|b_j)=p(a_i)p(b_j|a_i)\]</span></p></li></ul><p>定义“信道疑义度”(损失熵)为： <span class="math display">\[\begin{aligned}H(X|Y) &amp;= E[H(X|b_j)]\\&amp;= \sum_{j=1}^s p(b_j)\cdot \left(\sum_{i=1}^r-p(a_i|b_j)\log p(a_i|b_j)\right)\\&amp;= -\sum_{j=1}^s\sum_{i=1}^r p(a_ib_j)\log p(a_i|b_j)\end{aligned}\]</span> 其物理意义为信宿收到全部符号Y后，对输入符号X尚存在的平均不确定程度。那么有：<span class="math inline">\(H(X|Y)\leq H(X)\)</span>，意思就是说，信宿接收到输出信号以后，总是要消除一些对信源的不确定度的。而平均互信息量就是来表征这一部分被消除的不确定度的： <span class="math display">\[I(X;Y)=H(X)-H(X|Y)\]</span> 平均互信息量是输入信源概率分布的上凸函数，是信道传递概率<span class="math inline">\(p(y|x)\)</span>的下凸函数。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305262226162.png" alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure><h3 id="无记忆扩展信道">无记忆扩展信道</h3><p>对于单符号无记忆信道来说，输入和输出的都是一个符号。如果一个信道的输入是单符号信道的信源的N次扩展（也就是长度为N的序列），输出是单符号信道信宿的N次扩展，那么这个信道就是单符号信道的N次扩展信道。</p><p>在一般的信道中，传输长度为N的信息，有如下的定理：</p><ol type="1"><li><p>如果输入和输出是<span class="math inline">\(N\)</span>长序列<span class="math inline">\(\mathbf {X,Y}\)</span>，且信道是无记忆的，亦即信道传递概率为： <span class="math display">\[p(\mathbf{y} \mid \mathbf{x})=\prod_{i=1}^N p\left(y_i \mid x_i\right)\]</span> 或者 <span class="math display">\[p\left(\beta_h \mid \alpha_k\right)=\prod_{i=1}^N p\left(b_{h_i} \mid a_{k_i}\right), k=1,2, \cdots, r^N, h=1,2, \cdots, s^N\]</span> 则有： <span class="math display">\[I(\mathbf{X} ; \mathbf{Y}) \leq \sum_{i=1}^N I\left(X_i ; Y_i\right)\]</span></p></li><li><p>如果输入和输出是<span class="math inline">\(N\)</span>长序列<span class="math inline">\(\mathbf {X,Y}\)</span>，且信源是无记忆的，即： <span class="math display">\[p(\boldsymbol{x})=\prod_{i=1}^N p\left(x_i\right)\]</span> 或者 <span class="math display">\[p\left(\alpha_k\right)=p\left(a_{k_1}\right) p\left(a_{k_2}\right) \cdots p\left(a_{k_N}\right), k=1,2, \cdots, r^N\]</span> 则： <span class="math display">\[I(\mathbf{X} ; \mathbf{Y}) \geq \sum_{i=1}^N I\left(X_i ; Y_i\right)\]</span></p></li></ol><h3 id="信道的组合">信道的组合</h3><p>级联信道的模型如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305262247587.png" alt="级联信道" /><figcaption aria-hidden="true">级联信道</figcaption></figure><p>对于级联信道中的互信息，有：</p><ol type="1"><li><p>级联信道中的平均互信息满足： <span class="math display">\[I(XY;Z)\geq I(Y;Z)\]</span> 等号取得的充要条件： <span class="math display">\[p(z|xy)=p(z|y)\]</span> 也就是说，输出变量<span class="math inline">\(z\)</span>只和<span class="math inline">\(y\)</span>有关，而和<span class="math inline">\(x\)</span>无关。进一步，<span class="math inline">\(X,Y,Z\)</span>构成了一个一阶马尔可夫链。</p><p>把上面两式右边的<span class="math inline">\(y\)</span>换成<span class="math inline">\(x\)</span>，定理仍然成立。</p></li><li><p>如果<span class="math inline">\(X,Y,Z\)</span>构成了一个一阶马尔可夫链，有： <span class="math display">\[I(X;Z)\leq I(X;Y)\]</span></p><p><span class="math display">\[I(X;Z)\leq I(Y;Z)\]</span></p><p>也就是说，在任意信息传输系统中，最后获得的信息至多是信源提供的信息，如果在传输过程中丢失了信息，而且以后的系统不触及输入端，那么丢失的信息就不能再恢复。</p></li></ol><h3 id="信道容量">信道容量</h3><p>对一个特定的信道而言，其信道容量是平均互信息量随输入符号集变化时的最大值： <span class="math display">\[C=\max _{p(x)}\{I(X;Y)\}\]</span> 相应的使得平均互信息量最大的信源概率分布称为最佳输入分布。信道容量<span class="math inline">\(C\)</span>仅和信道本身的统计特性有关，而和信源无关，其表征了信道传送信息的最大能力。例如，对于最简单的二元对称信道（输入输出符号集都是<span class="math inline">\(\{0,1\}\)</span>，传输过程中符号翻转的概率为<span class="math inline">\(p\)</span>），信源符号为<span class="math inline">\(1\)</span>的概率是<span class="math inline">\(\omega\)</span>，有： <span class="math display">\[I(X;Y)=H(\omega \overline p+\overline \omega p)-H(p)\]</span> 则： <span class="math display">\[C=1-H(p)\]</span> 事实上，研究信道的核心问题就是研究信道容量以及最佳输入分布，但是这其实比较困难，接下来会对几个特殊的信道进行分析。</p><h4 id="离散无噪信道">离散无噪信道</h4><ol type="1"><li><p>无损信道</p><p>无损信道的一个输入对应多个不相交的输出，输出端接收到<span class="math inline">\(Y\)</span>以后一定能知道发射端<span class="math inline">\(X\)</span>的状态，示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305271122498.png" alt="无损信道示意图" /><figcaption aria-hidden="true">无损信道示意图</figcaption></figure><p>一个典型的无损信道矩阵如下： <span class="math display">\[\mathbf{P}_{Y \mid X}=\left[\begin{array}{cccccc}\frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{6}{10} &amp; \frac{3}{10} &amp; \frac{1}{10} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span> 它的行“不相互重叠”，且行和为一。</p><p>其信道疑义度（损失熵）<span class="math inline">\(H(X|Y)=0\)</span>。因为并不能根据输入<span class="math inline">\(a_i\)</span>断定输出会是哪一个<span class="math inline">\(b_i\)</span>，所以其噪声熵<span class="math inline">\(H(Y|X)&gt;0\)</span>。其信道容量为： <span class="math display">\[C=\max _{p(x)}H(X)=\log r\]</span> 最佳输入分布是等概分布。</p></li><li><p>确定信道</p><p>确定信道是一个输出对应多个互不相交的输入的信道，即发出信源<span class="math inline">\(a_i\)</span>，就一定能知道信道的输出<span class="math inline">\(b_j\)</span>。示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305271131747.png" alt="确定信道示意图" /><figcaption aria-hidden="true">确定信道示意图</figcaption></figure><p>一个典型的确定信道矩阵如下： <span class="math display">\[\mathbf{P}_{Y \mid X}=\left[\begin{array}{lll}1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\]</span> 信道矩阵中每一行只有一个<span class="math inline">\(1\)</span>，其余元素都是<span class="math inline">\(0\)</span>。</p><p>其噪声熵<span class="math inline">\(H(Y|X)=0\)</span>。因为并不能根据输出<span class="math inline">\(b_j\)</span>断定输入是哪一个<span class="math inline">\(a_i\)</span>，所以其损失熵<span class="math inline">\(H(X|Y)&gt;0\)</span>。</p><p>其信道容量为： <span class="math display">\[C=\max _{p(x)} H(Y)=\log s\]</span> 最佳输入分布是能让输出呈现等概分布的输入分布。</p></li><li><p>无损确定信道</p><p>既无损又确定的信道是无损确定信道。其矩阵是单位阵，输入输出之间有一一对应关系。</p></li></ol><h4 id="离散对称信道">离散对称信道</h4><p>若一个离散无记忆信道的信道矩阵中，每一行都是其它行的同一组元素的不同排列，则称此类信道为<strong>离散输入对称信道</strong>，一个典型的离散输入对称信道矩阵为： <span class="math display">\[\mathbf{P}=\left[\begin{array}{cccc}\frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{6} \\\frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{3}\end{array}\right]\]</span> 若一个离散无记忆信道的信道矩阵中，每一列都是其它列的同一组元素的不同排列，则称此类信道为<strong>离散输出对称信道</strong>，一个典型的离散输出对称信道矩阵为： <span class="math display">\[\mathbf{P}=\left[\begin{array}{ll}0.4 &amp; 0.6 \\0.6 &amp; 0.4 \\0.5 &amp; 0.5\end{array}\right]\]</span> 如果同时满足以上两个条件，则称之为<strong>离散对称信道</strong>，例如： <span class="math display">\[\mathbf{P}=\left[\begin{array}{ccc}\frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{6} \\\frac{1}{6} &amp; \frac{1}{2} &amp; \frac{1}{3} \\\frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{2}\end{array}\right]\]</span> 若一个离散无记忆信道，按照信道矩阵的行（即信道的输出集）可以将信道矩阵划分成<span class="math inline">\(n\)</span>个子矩阵，且每个子矩阵中的每一行（列）都是其它行（列）的同一组元素的不同排列，则称此类信道为<strong>离散准对称信道</strong>。例如下面的矩阵： <span class="math display">\[\mathbf{P}_2=\left[\begin{array}{lll}0.7 &amp; 0.1 &amp; 0.2 \\0.2 &amp; 0.1 &amp; 0.7\end{array}\right]\]</span> 可以划分为： <span class="math display">\[\left[\begin{array}{ll}0.7 &amp; 0.2 \\0.2 &amp; 0.7\end{array}\right]\left[\begin{array}{l}0.1 \\0.1\end{array}\right]\]</span> 离散准对称信道的最佳输入分布是等概分布。</p><p>如果一个离散对称信道有<span class="math inline">\(r\)</span>个输入符号和<span class="math inline">\(s\)</span>个输出符号，则输入是等概分布时达到信道容量<span class="math inline">\(C\)</span>，且： <span class="math display">\[C=\log s-H\left(p_1^{\prime}, p_2^{\prime}, \cdots, p_s^{\prime}\right)\]</span> 其中<span class="math inline">\(p&#39;_1,p&#39;_2,\cdots,p&#39;_s\)</span>是信道矩阵中的任何一行。</p><p>达到信道容量<span class="math inline">\(C\)</span>的概率分布是使输出为等概分布的信道输入分布。求离散对称信道的信道容量，实质是求一种输入分布<span class="math inline">\(p(x)\)</span>，它使输出熵<span class="math inline">\(H(Y)\)</span>达最大。<strong>对于对称信道，只有信道输入分布是等概分布时，输出才为等概分布。</strong></p><p>对于<strong>离散无记忆 <span class="math inline">\(N\)</span>次扩展信道</strong>，其信道容量等于单变量信道的信道容量的 <span class="math inline">\(N\)</span>倍,即： <span class="math display">\[C^N=NC\]</span></p><h2 id="无失真信源编码">无失真信源编码</h2><p>将信源产生的全部信息无损地送给信宿，这种信源编码称无失真信源编码。编码可以分为：</p><ul><li>定长码：所有码字长度相等的码</li><li>变长码：码字长度可能不相等的码</li></ul><p>或者</p><ul><li>奇异码：码组中有相同的码字</li><li>非奇异码：码组中没有相同的码字</li></ul><h3 id="分组码">分组码</h3><p>分组码指的是把信源符号集中的每一个符号<span class="math inline">\(s_i\)</span>都映射成一个固定的码字<span class="math inline">\(w_i\)</span>的编码规则。</p><p>设信源符号<span class="math inline">\(s_i\)</span>映射为一个固定的码字<span class="math inline">\(w_i\)</span>，则码<span class="math inline">\(\alpha_j=(s_{j_1},s_{j_2}\cdots s_{j_n})\)</span>映射为<span class="math inline">\(W_j=(w_{j_1},w_{j_2},\cdots,w_{j_n})\)</span>的分组码称为原分组码的<span class="math inline">\(N\)</span>次扩展码。</p><p>分组码能正确译码的必要条件是非奇异，这很直观，但是并不是充分的。</p><p>如果一个分组码对于任意的正整数<span class="math inline">\(N\)</span>，其<span class="math inline">\(N\)</span>次扩展码都是非奇异的，那么这样的分组码叫做<strong>唯一可译码</strong>，这是分组码能正确译码的充要条件。</p><p>虽然都是唯一可译码，但是译码方式仍有不同。考虑以下两种码：</p><table><thead><tr class="header"><th>符号</th><th>码1</th><th>码2</th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>2</td><td>10</td><td>01</td></tr><tr class="odd"><td>3</td><td>100</td><td>001</td></tr><tr class="even"><td>4</td><td>1000</td><td>0001</td></tr></tbody></table><p>对于码1来说，我接收到一个消息，比如<code>10</code>，此时我并不知道符号是<code>2</code>、<code>3</code>还是<code>4</code>。直到下一个符号到达，我接收到的消息变成<code>101...</code>，我才知道前面的符号是<code>2</code>。但是对于码2，当我接收到<code>01</code>时，我立刻就能知道这个符号是<code>2</code>。 把像码2这种接收到一个码字就能立刻译码的唯一可译码称为“<strong>即时码</strong>”。一个唯一可译码是即时码的充要条件是其中任何一个码都不是其它码的前缀。</p><h3 id="定长码">定长码</h3><h4 id="唯一可译定长码">唯一可译定长码</h4><p>对于有<span class="math inline">\(q\)</span>个符号的简单信源的<span class="math inline">\(N\)</span>次扩展信源，其存在基本码符号数为<span class="math inline">\(r\)</span>，扩展信源<span class="math inline">\(S^N\)</span>定长编码码长为<span class="math inline">\(L\)</span>的唯一可译码的条件为： <span class="math display">\[q^N\leq r^L\]</span> 这个定理更常用的形式是：唯一可译定长码的最短码长为： <span class="math display">\[L\geq N\frac{\log q}{\log r}\]</span></p><h4 id="定长信源编码定理">定长信源编码定理</h4><p>引理：设离散无记忆信源的熵为<span class="math inline">\(H(S)\)</span>，用码符号集<span class="math inline">\(X=(x_1,x_2\cdots x_r)\)</span>对<span class="math inline">\(S^N\)</span>进行长度为<span class="math inline">\(L\)</span>的定长编码，<span class="math inline">\(\forall \epsilon &gt;0,\delta&gt;0\)</span>，如果 <span class="math display">\[\frac LN \log r\geq H(s)+\epsilon\]</span> 则<span class="math inline">\(N\)</span>足够大时，译码错误率小于<span class="math inline">\(\delta\)</span>，反之，如果 <span class="math display">\[\frac LN \log r\leq H(s)-2\epsilon\]</span> 则<span class="math inline">\(N\)</span>足够大时，译码错误趋向于<span class="math inline">\(1\)</span>.</p><p>也就是说，当 <span class="math display">\[L\log r&gt;NH(s)\]</span> 即码长为<span class="math inline">\(L\)</span>的符号序列能携带的最大信息量大于<span class="math inline">\(N\)</span>次扩展信源的信息熵时，<span class="math inline">\(N\)</span>足够大时，就可以近似实现无失真传输。</p><p>对于定长编码，定义编码速率: <span class="math display">\[R=\frac{L\log r}{N}\]</span> 编码效率： <span class="math display">\[\eta = \frac {H(s)}{R}\]</span> 由定长信源编码定理知道，最佳编码效率为： <span class="math display">\[\eta = \frac{H(s)}{H(s)+\epsilon}\]</span> 如果允许错误概率<span class="math inline">\(p_e&lt;\delta\)</span>，信源长度<span class="math inline">\(N\)</span>要满足： <span class="math display">\[N\geq \frac{D[I(s_i)]}{\epsilon^2\delta}\]</span> 其中<span class="math inline">\(D[I(s_i)]\)</span>是自信息量的方差。代入，有： <span class="math display">\[N\geq \frac{D[I(s_i)]}{H^2(s)}\frac{\eta^2}{(1-\eta)^2\delta}\]</span></p><blockquote><p>【例】现有离散无记忆信源： <span class="math display">\[\begin{bmatrix}S\\P\end{bmatrix}=\begin{bmatrix}s_1 &amp; s_2\\\frac 34 &amp; \frac 14\end{bmatrix}\]</span> 对其采取等长二元编码，编码效率<span class="math inline">\(\eta = 0.96\)</span>，允许错误概率不大于<span class="math inline">\(10^{-5}\)</span>，求<span class="math inline">\(N\)</span>最少是多少</p><p>【解】信源信息熵为 <span class="math display">\[H(s)=\frac 34\log_2 \frac 43+\frac 14+\log_24=0.811\]</span> 自信息量的方差为： <span class="math display">\[\begin{aligned}D[I(s_i)]&amp;=E[I^2(s_i)]-E^2[I(s_i)]\\&amp;=\sum_{i=1}^2p_i(\log_2 p_i)^2-[H(s)]^2\\&amp;=0.4715\end{aligned}\]</span> 则 <span class="math display">\[N\geq \frac{0.4615}{0.811^2}\frac{0.96^2}{0.04^2\times 10^{-5}}=4.13\times 10^7\]</span></p></blockquote><h3 id="变长码">变长码</h3><p>变长码无需很长的码长就能实现高效率的无失真信源编码。关于信源符号数、码字长度之间应该满足什么条件，才能构成唯一可译码，有：</p><p>设信源符号集为<span class="math inline">\(S=(s_1\cdots s_q)\)</span>，码符号集为<span class="math inline">\(X=(x_1\cdots x_r)\)</span>，对信源进行编码，对应的码字为<span class="math inline">\(W=(W_1\cdots W_q)\)</span>，每个码的码长为<span class="math inline">\(l_1\cdots l_q\)</span>，则唯一可译即时码存在是充要条件是： <span class="math display">\[\sum_{i=1}^q r^{-l_i}\leq 1\]</span> 这叫“<strong>克拉夫特不等式</strong>”。</p><p>如果把上面的定理中的“唯一可译即时码”换成“唯一可译码”，其它都不变，定理仍然成立。</p><h4 id="变长编码定理">变长编码定理</h4><p>如果传输一个码符号需要<span class="math inline">\(t\)</span>秒，那么编码后信道每秒传输的信息量为： <span class="math display">\[R_t=\frac{H(s)}{\overline L t}\]</span> 则平均码长越短，<span class="math inline">\(R_t\)</span>越大，信息传输的速率越快。因此，人们感兴趣的码是平均码长最短的码。</p><p>对于固定的信源和码符号集，如果有一种唯一可译码的平均码长小于所有其它唯一可译码，则称其为紧致码。</p><p>对于离散无记忆信源<span class="math inline">\(S\)</span>及其<span class="math inline">\(N\)</span>次扩展信源<span class="math inline">\(S^N\)</span>，码符号集中有<span class="math inline">\(r\)</span>个符号，对<span class="math inline">\(S^N\)</span>进行编码，则总可以找到一种编码方式构成唯一可译码，而且码字平均长度满足： <span class="math display">\[\frac{H(S)}{\log r}+\frac 1N&gt;\frac{\overline L_N}{N}\geq \frac{H(S)}{\log r}\]</span> 当<span class="math inline">\(N\to \infty\)</span>，有： <span class="math display">\[\lim _{N\to \infty}\frac{\overline L_N}{N}=\frac{H(s)}{\log r}\]</span> 以下记： <span class="math display">\[H_r(S)=\frac{H(S)}{\log r}\]</span> 把这个结论推广到平稳遍历的有记忆信源，一般离散信源，马尔可夫信源，有： <span class="math display">\[\lim _{N\to \infty}\frac{\overline L_N}{N}=\frac{H_{\infty}}{\log r}\]</span> 类似的，定义变成编码的编码速率： <span class="math display">\[R=\frac{\overline L_N}{N}\log r\]</span> 编码效率： <span class="math display">\[\eta =\frac{H(S)}{R}=\frac{H_r(S)}{\overline L}\]</span></p><h4 id="变长码的编码方法">变长码的编码方法</h4><h5 id="香农编码">香农编码</h5><p>香农编码的编码方式如下：</p><ol type="1"><li><p>把信源发出的<span class="math inline">\(N\)</span>个符号按概率递减的顺序从上到下排列</p></li><li><p>按下式计算第<span class="math inline">\(i\)</span>个消息的二进制代码组的码长<span class="math inline">\(l_i\)</span>，并取整： <span class="math display">\[-\log p(s_i)\leq l_i&lt;-\log p(s_i)+1\]</span></p></li><li><p>计算第<span class="math inline">\(i\)</span>个消息的累加概率 <span class="math display">\[P_i =\sum_{k=1}^{i-1}p(s_k)\]</span></p></li><li><p>把累加概率转换成二进制小数，并截取小数点后的前<span class="math inline">\(l_i\)</span>位作为第<span class="math inline">\(i\)</span>个消息的编码。</p></li></ol><blockquote><p>【例】对以下信源进行香农编码</p><table><thead><tr class="header"><th>消息</th><th>s1</th><th>s2</th><th>s3</th><th>s4</th><th>s5</th><th>s6</th><th>s7</th></tr></thead><tbody><tr class="odd"><td>概率</td><td>0.2</td><td>0.19</td><td>0.18</td><td>0.17</td><td>0.15</td><td>0.1</td><td>0.01</td></tr></tbody></table><p>【解】香农编码表如下：</p><table><thead><tr class="header"><th>消息序号</th><th>消息概率</th><th>累加概率</th><th><span class="math inline">\(-\log p(s_i)\)</span></th><th>码组长度</th><th>二进制代码</th></tr></thead><tbody><tr class="odd"><td>s1</td><td>0.2</td><td>0</td><td>2.3</td><td>3</td><td>000</td></tr><tr class="even"><td>s2</td><td>0.19</td><td>0.2</td><td>2.4</td><td>3</td><td>001</td></tr><tr class="odd"><td>s3</td><td>0.18</td><td>0.39</td><td>2.4</td><td>3</td><td>011</td></tr><tr class="even"><td>s4</td><td>0.17</td><td>0.57</td><td>2.5</td><td>3</td><td>100</td></tr><tr class="odd"><td>s5</td><td>0.15</td><td>0.74</td><td>2.7</td><td>3</td><td>101</td></tr><tr class="even"><td>s6</td><td>0.1</td><td>0.89</td><td>3.3</td><td>4</td><td>1110</td></tr><tr class="odd"><td>s7</td><td>0.01</td><td>0.99</td><td>6.6</td><td>7</td><td>1111110</td></tr></tbody></table></blockquote><h5 id="霍夫曼编码">霍夫曼编码</h5><p>霍夫曼编码是一种紧致码，它的编码过程为：</p><ol type="1"><li>把<span class="math inline">\(q\)</span>个符号按概率分布从大到小的顺序排列</li><li>用<code>0</code>,<code>1</code>分别代表概率最小的两个信源，把这两个符号合并成一个新符号，从而得到包含<span class="math inline">\(q-1\)</span>个符号的缩减信源</li><li>把缩减信源的符号概率仍从大到小排序</li><li>重复2~3，直到信源只剩下两个符号为止，把这最后两个符号用<code>0</code>和<code>1</code>表示，然后从最后一级缩减信源开始向前返回，得到编码。</li></ol><blockquote><p>【例】对以下信源进行霍夫曼编码：</p><table><thead><tr class="header"><th>符号</th><th>s1</th><th>s2</th><th>s3</th><th>s4</th><th>s5</th></tr></thead><tbody><tr class="odd"><td>概率</td><td>0.4</td><td>0.2</td><td>0.2</td><td>0.1</td><td>0.1</td></tr></tbody></table><p>【解】</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306122233893.png" alt="image-20230612223226884" /><figcaption aria-hidden="true">image-20230612223226884</figcaption></figure></blockquote><h5 id="费诺码">费诺码</h5><p>费诺码的编码过程如下：</p><ol type="1"><li>把<span class="math inline">\(q\)</span>个符号按概率分布从大到小的顺序排列</li><li>把依次排列的信源符号依概率分为两大组，使两个组的概率和尽可能相等，然后给各组赋予一个二进制码符号<code>0</code>和<code>1</code></li><li>把上面这两大组中每一大组的符号再分成两部分，使得划分后两小组的概率和尽可能相等，然后给各组赋予一个二进制码符号<code>0</code>和<code>1</code></li><li>重复2~3，直到每个组都只剩下一个符号为止</li></ol><blockquote><p>【例】对以下信源进行费诺编码</p><table><thead><tr class="header"><th>符号</th><th>s1</th><th>s2</th><th>s3</th><th>s4</th><th>s5</th><th>s6</th><th>s7</th></tr></thead><tbody><tr class="odd"><td>概率</td><td>0.2</td><td>0.19</td><td>0.18</td><td>0.17</td><td>0.15</td><td>0.1</td><td>0.01</td></tr></tbody></table><p>【解】</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306122246232.png" alt="费诺码" /><figcaption aria-hidden="true">费诺码</figcaption></figure><p>平均码长为 <span class="math display">\[\overline L=2.74\]</span> 信息速率 <span class="math display">\[R=\frac{H(s)}{\overline{L}}=0.953\quad bit/\text{码元}\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理·数字信号基带传输</title>
    <link href="/2023/05/23/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93/"/>
    <url>/2023/05/23/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<p>在之前的调制部分，我们解决了信号的调制和编码的问题。接下来，我们将对数字信号如何在信道中更高效地传输的问题进行讨论。</p><p>传输分为两种，即基带传输和通带传输。基带传输无需进行进一步调制，只需要直接在信道中传输编码后的数字脉冲信号（即<code>01</code>串方波），一般多用于非带限信道，有线传输。</p><p>通带传输需要借调制进行频谱搬移，用于带限信道，一般是无线传输，但是也可以用于有线传输，比如DVB-C。</p><p>数字信号传输的方框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306061558358.png" alt="数字信号传输方框图" /><figcaption aria-hidden="true">数字信号传输方框图</figcaption></figure><h2 id="非带限信道码型设计">非带限信道码型设计</h2><p>码型设计是数字信息的电脉冲表示过程，其主要目的是使数字信息变换为适合于给定信道传输特性的频谱结构。其设计的基本原则有：</p><ul><li><p>尽量避免含有直流分量</p></li><li><p>码型变换过程应对任何信源具有透明性，和信源的统计特性无关</p></li><li><p>便于从基带信号中提取定时信息</p></li><li><p>具有检错能力</p></li><li><p>无误码扩散现象</p></li><li><p>当采用分组形式的传递码型时（如5B6B、4B3T码等），在接收端不但要从基带信号中提取位定时信息，</p><p>而且要恢复出分组同步信息，以便将收到的信号正确地划分成固定长度的码组</p></li><li><p>减少基带信号中的高频分量</p></li><li><p>编译码设备简单</p></li></ul><h3 id="二元码">二元码</h3><p>二元码的意思就是基带信号的幅度取值只有两种电平。常用的二元码有：</p><ul><li><p>单极性非归零码：</p><p>两个电平分别为<code>1</code>和<code>0</code>，传完一个符号后不归零</p></li><li><p>双极性非归零码：</p><p>两个电平分别为<code>1</code>和<code>-1</code>，传完一个符号后不归零</p></li><li><p>单极性归零码：</p><p>两个电平分别为<code>1</code>和<code>0</code>，每个符号前一半时间传输码，后一半时间归零</p></li><li><p>差分码：</p><p>差分码的传输依赖于当前符号和前一个符号的变化关系。</p><ul><li>传号差分码：电平从<code>0</code>开始，如果当前符号是<code>1</code>就翻转电平，如果是<code>0</code>则保持电平</li><li>空号差分码：电平从<code>0</code>开始，如果当前符号是<code>0</code>就翻转电平，如果是<code>1</code>则保持电平</li></ul></li></ul><p>各二元码的时域波形示例如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305241049672.png" alt="image-20230524104926672" /><figcaption aria-hidden="true">image-20230524104926672</figcaption></figure><p>其中非差分码的低频分量丰富，不适用于交流耦合的有线信道；非归零码的连续符号不适合提取定时信息；不具备检错能力；仅适用于近距离传输。</p><p>还有一些更高级的二元码：</p><ul><li><p>数字双相码（曼彻斯特码）</p><p>其特点是<code>1</code>和<code>0</code>的波形反向。生成方法是用单极性非归零码和时钟信号做模二和。</p></li><li><p>信号反转码</p><p><code>1</code>交替用确定相位的方波（<code>11</code>,<code>00</code>）表示，<code>0</code>用<code>01</code>表示</p><p>方便提取定时信息，有检错能力</p></li><li><p>米勒码</p><p><code>1</code>在码元中间跳变；单<code>0</code>不跳变；多个<code>0</code>在从第2个<code>0</code>起始跳变</p></li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305241103542.png" alt="高级二元码" /><figcaption aria-hidden="true">高级二元码</figcaption></figure><h3 id="三元码">三元码</h3><p>在三元码数字基带信号中，信号幅度取值有三个：<code>+1</code>、<code>0</code>、<code>-1</code>。</p><ul><li><p>AMI码</p><p>其实就是符号<code>1</code>交替变换为<code>+1</code>、<code>-1</code>的双极性归零码。</p><p>AMI码具有检错能力，其性能和信源的统计特性关系很密切，如果长时间出现连续<code>0</code>，会对定时提取造成困难。所以，使用AMI码前需要进行随机化操作，以使<code>1</code>、<code>0</code>出现的概率一致。</p></li><li><p>HDBn码</p><p>为了改进AMI码，提出HDBn码的概念。HDBn码是<span class="math inline">\(n\)</span>阶高密度双极性码的缩写，在HDBn码中信息<code>1</code>也交替地变换为<code>+1</code>与<code>-1</code>的归零码，但与AMI码不同的是：HDBn码中的连<code>0</code>数被限制为小于或等于<span class="math inline">\(n\)</span>。</p><p>当信息中出现<span class="math inline">\(n+1\)</span>个连<code>0</code>码时就用特定码组来取代，这种特定码组称为取代节。为了在接收端识别</p><p>出取代节，人为地在取代节中设置“破坏点”，在这些“破坏点”处传号极性交替规律受到破坏。</p><p>一般来说，用的最广泛的是HDB3码。其生成步骤如下：</p><ul><li>加<code>V</code>：检查4连<code>0</code>的情况，如果出现，将4连<code>0</code>编为一组，用<code>V</code>取代<code>0000</code>的最后一个<code>0</code>，变成<code>000V</code></li><li>加<code>B</code>：检查相邻的<code>V</code>中间非零符号的个数，如果是奇数，那么记为<code>000V</code>，如果是偶数，则记为<code>B00V</code></li><li>对信码加符号：将<code>1</code>和<code>B</code>看做整体，保证这个整体按正负交替的规律变化。此时可把<code>B</code>恢复为<code>1</code>或<code>-1</code></li><li>对<code>V</code>加符号：保证<code>V</code>和其前一个信码的符号一致。此时可把<code>V</code>恢复为<code>1</code>或<code>-1</code></li></ul><blockquote><p>【例】将信息<code>0100001100000101</code>进行HDB3编码。</p><p>【解】编码步骤如下：</p><ol type="1"><li>加V：<code>01 000V 11 000V 0101</code></li><li>加B：<code>01 000V 11 B00V 0101</code></li><li>对信码加符号：<code>0 +1 000V -1 +1 -100V 0 +1 0 -1</code></li><li>对V加符号：<code>0 +1 000 +1 -1 +1 -1 00 -1 0 +1 0 -1</code></li></ol></blockquote></li></ul><h2 id="符号映射与波形设计">符号映射与波形设计</h2><p>数字通信中，所需传输的往往是一个比特流，因此就需要一个符号序列去承载这个比特流。我们让这些符号在时间轴上，以<span class="math inline">\(Ts\)</span>为间隔均匀的排布，因此将其称为符号间隔/符号周期。由此，可定义符号速率为：<span class="math inline">\(R_s=1/T_s\)</span>。数字通信的比特速率为：<span class="math inline">\(R_b=R_s\log_2 M\)</span>，其中<span class="math inline">\(M\)</span>是数字通信的符号进制，就常用的二进制而言，符号速率等于比特速率。</p><p>比特需要转换为符号，这个过程称为符号映射。但是符号作为离散时间、离散幅度信号，不能直接传输，需要转换为连续时间、连续幅度的信号，一般是转换成准方波。这个过程叫做波形设计。</p><p>数字通信波形的统一数学表达式为： <span class="math display">\[a(t)=\sum_{k=-\infty}^\infty a_k g(t-kT_s)\]</span> 其中 <span class="math inline">\(g(t)\)</span>​称为成型脉冲，将离散的符号映射为通信波形。每一个符号周期内，以<span class="math inline">\(a_k\)</span>为幅度，独立产生一个成形脉冲；并将所有符号周期形成的脉冲进行叠加，得到最终的波形。如果<span class="math inline">\(g(t)\)</span>是矩形窗函数，那么就会得到一个方波，也就是之前非带限信道传输中的波形。</p><p>但是矩形窗函数是频域无限宽的信号，因此不能在带限信道中使用。带限信道中只能通过频域有限宽，时域无限宽的信号，那么既然时域无限宽，就有可能出现码间串扰。只有经过特别设计的<span class="math inline">\(g(t)\)</span>才没有码间串扰，比如之前采样定理中用到的信号核重建函数 <span class="math display">\[g(t)=\frac{\sin (\omega_0t)}{\omega_0 t}\]</span> 如果信号经传输后整个波形发生了变化，但只要其特定点的抽样值保持不变，那么用再次抽样的方法仍然可以准确无误地恢复原始信码。于是，有<strong>采样点无失真定理（也叫奈奎斯特第一准则）</strong>：</p><p>数字通信波形满足采样点无失真，即：<span class="math inline">\(a(kT_s)=a_k\)</span>，当且仅当： <span class="math display">\[\sum_{n=-\infty}^{\infty} G\left(f+\frac{n}{T_S}\right)=T_S\]</span> 即以<span class="math inline">\(R_s=1/T_s\)</span>为周期对其频谱进行延拓，其和为常数。</p><p>在验证时，一般将其频域响应<span class="math inline">\(G(\omega)\)</span>按照<span class="math inline">\(2\pi/T_s\)</span>为单位进行分段，然后把各分段都沿横轴的方向平移到<span class="math inline">\([-\pi/T_s,\pi/T_s]\)</span>之间，并把它们叠加起来。如果实部是常数，虚部是零，那么就符合条件。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305241608451.png" alt="验证示意图" /><figcaption aria-hidden="true">验证示意图</figcaption></figure><p>更进一步，只需验证其频域函数是否以<span class="math inline">\(R_s/2=1/2T_s\)</span>为中心互补对称即可。</p><p>频谱效率指的是单位频谱上所承载的通信速率，即 <span class="math display">\[\eta=\frac {R_b}{W}=\frac{R_s}{W}\log _2 M\]</span> 由奈奎斯特第一准则知，频谱效率有上界，即 <span class="math display">\[\eta \leq 2\log_2 M\]</span></p><h3 id="升余弦成形滤波器">升余弦成形滤波器</h3><p>理想低通滤波器是最好的，可是无法实现。在实际工程中，我们一般使用升余弦成型滤波器。其频域表达式为： <span class="math display">\[G(f)=\left\{\begin{array}{cl}T_s &amp; 0 \leq|f| \leq \frac{1-\alpha}{2 T_s} \\\frac{T_s}{2}\left\{1+\cos \left[\frac{\pi T_s}{\alpha}\left(|f|-\frac{1-\alpha}{2 T_s}\right)\right]\right\} &amp; \frac{1-\alpha}{2 T_s} \leq|f| \leq \frac{1+\alpha}{2 T_s} \\0 &amp; |f|&gt;\frac{1+\alpha}{2 T_s}\end{array}\right.\]</span> 可以看出：它是一个偶对称的函数，其下降沿起始于<span class="math inline">\(W=(1-\alpha)/(2T_s)\)</span>，终止于<span class="math inline">\(W=(1+\alpha)/(2T_s)\)</span>，带宽为 <span class="math display">\[W=\frac{1+\alpha}{2T_s}\]</span> 上面的式子太抽象了，看个图就清楚了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306061538840.png" alt="升余弦滤波器" /><figcaption aria-hidden="true">升余弦滤波器</figcaption></figure><p>直观来说，滚降系数<span class="math inline">\(\alpha\)</span>给出了下降沿的相对陡峭程度，其越小，下降沿越陡峭，频谱效率越高，物理上越难实现。一般不使用<span class="math inline">\(\alpha\leq 0.2\)</span>的升余弦滤波器。</p><h2 id="最佳接收与匹配滤波">最佳接收与匹配滤波</h2><p>在之前，我们假设了接收到的信号就是发射的信号，即信道的响应是<span class="math inline">\(H(f)=1\)</span>​。但是实际上，接收机前端会引入高斯白噪声，必须进行滤波处理，否则有大量带外噪声引入，影响通信质量。</p><p>在分析噪声时，因为主要的噪声来源是接收机本身的热噪声，所以采取加性高斯白噪声模型。其双边功率谱为： <span class="math display">\[P_N(f)=\frac{n_0}{2}\]</span> 此时，考虑传输一个符号<span class="math inline">\(a\)</span>，成形脉冲是<span class="math inline">\(g(t)\)</span>，那么我们能够观测和处理的信号是 <span class="math display">\[Y(t)=ag(t)+N(t)\]</span> 最直接想到的方法就是在<span class="math inline">\(g(t)\)</span>的最高点进行直接采样，但是这并不是最优的，因为这是因为信号能量遍布整个<span class="math inline">\(g(t)\)</span>的非零区域。最佳的接受方案应该是尽可能的接收<span class="math inline">\(g(t)\)</span>的能量，同时尽可能不接受<span class="math inline">\(N(t)\)</span>的能量。我们可以用一个权函数<span class="math inline">\(h(t)\)</span>对信号<span class="math inline">\(Y(t)\)</span>进行加权，然后进行积分，即： <span class="math display">\[\hat{a}=\int_{-\infty}^{\infty} Y(t) h(t) d t=a \int_{-\infty}^{\infty} g(t) h(t) d t+\int_{-\infty}^{\infty} h(t) N(t) d t\]</span> 于是我们的问题就变成了怎么设计这个<span class="math inline">\(h(t)\)</span>。有定理：</p><p>当且仅当<span class="math inline">\(h(t)=g(t)\)</span>时，信噪比 <span class="math display">\[S N R=\frac{\left[a \int_{-\infty}^{\infty} h(t) g(t) d t\right]^2}{E\left[\int_{-\infty}^{\infty} h(t) N(t) d t\right]^2}\]</span> 取得最大值，为： <span class="math display">\[S N R=\frac{a^2}{n_0 / 2} \int_{-\infty}^{\infty} g^2(t) d t\]</span></p><blockquote><p>【例】证明上面这个定理。</p><p>【解】从函数空间的角度来看，<span class="math inline">\(N(t)\)</span>是白噪声，在各个方向上均匀分布，因此和任何方向的函数做内积，结果输出的平均能量都是相同的。有： <span class="math display">\[\begin{aligned}&amp;E\left[\left|\int_{-\infty}^{\infty} N(t) h(t) d t\right|^2\right]\\&amp;=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} E[N(t) N(\tau)] h(t) h(\tau) d t d \tau\\&amp;=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} \frac{1}{2} n_0 \delta(t-\tau) h(t) h(\tau) d t d \tau\\&amp;=\frac{1}{2} n_0 \int_{-\infty}^{\infty} h^2(t) d t\end{aligned}\]</span> 于是，问题变成了求 <span class="math display">\[\frac{\left|\int_{-\infty}^{\infty} h(t) g(t) d t\right|^2}{\int_{-\infty}^{\infty} h^2(t) d t}\]</span> 的最大值的问题。也即，给定函数<span class="math inline">\(h(t)\)</span>的2-范数为1，最大化<span class="math inline">\(|\int h(t)g(t)dt|^2\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="本文中，所有省略了积分上下界的积分，都表示积分是从负无穷到正无穷。">[1]</span></a></sup>，那么显然当<span class="math inline">\(h(t)\)</span>和<span class="math inline">\(g(t)\)</span>在函数空间中同方向时，这个内积最大。严格来说，根据柯西-施瓦茨不等式 <span class="math display">\[\left(\int_a^b f(x) g(x) d x\right)^2 \leq \int_a^b f^2(x) d x \int_a^b g^2(x) d x\]</span> 有： <span class="math display">\[\frac{\left|\int_{-\infty}^{\infty} h(t) g(t) d t\right|^2}{\int_{-\infty}^{\infty} h^2(t) d t} \leq \frac{\int_{-\infty}^{\infty} h^2(t) d t \int_{-\infty}^{\infty} g^2(t) d t}{\int_{-\infty}^{\infty} h^2(t) d t}=\int_{-\infty}^{\infty} g^2(t) d t\]</span> 证毕。</p></blockquote><p>于是，最佳接收的系统框图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306062207714.png" alt="最佳接收系统框图" /><figcaption aria-hidden="true">最佳接收系统框图</figcaption></figure><p>我们可将此过程等效为<span class="math inline">\(Y(t)\)</span>通过一个线性系统，并对输出在<span class="math inline">\(t_0\)</span>时刻进行采样。因为上面这个线性系统蕴含了“匹配”的思想，因此被称为“匹配滤波器”。其冲激响应为： <span class="math display">\[h_m(t)=g(t_0-t)\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306062229034.png" alt="匹配滤波器和发送滤波器响应镜像对称" /></p><h3 id="匹配滤波器的信噪比分析">匹配滤波器的信噪比分析</h3><p>如果从一般的视角来分析匹配滤波器的信噪比增益，我们会发现是无穷大，因为<span class="math inline">\(Y(t)=s(t)+N(t)\)</span>​中噪声的功率是无穷大（因为功率谱密度是常数），因此它的信噪比是零，但是这显然没有什么意义。为了方便分析，我们将匹配滤波器等效为它本身与和它本身带宽相等理想低通滤波器的串联系统：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306062243827.png" alt="匹配滤波器信噪比增益计算模型" /><figcaption aria-hidden="true">匹配滤波器信噪比增益计算模型</figcaption></figure><p>记匹配滤波器、成形滤波器和理想低通滤波器的带宽都是<span class="math inline">\(W\)</span>，然后可以用理想低通滤波器作为基准，来分析匹配滤波器对信噪比的增益。</p><p><span class="math inline">\(Y(t)\)</span>通过理想滤波器以后，噪声的功率就被限制在了<span class="math inline">\(Wn_0\)</span>，注意到<span class="math inline">\(a^2\int g^2(t)dt\)</span>是一个符号的能量，而符号的速率是<span class="math inline">\(R_s\)</span>，所以信噪比为： <span class="math display">\[S N R_{i n}=\frac{R_s}{W} \frac{a^2}{n_0} \int_{-\infty}^{\infty} g^2(t) d t\]</span> 由前面的分析，匹配滤波后的信噪比是： <span class="math display">\[S N R=\frac{a^2}{n_0 / 2} \int_{-\infty}^{\infty} g^2(t) d t\]</span> 于是得到匹配滤波的增益是： <span class="math display">\[\lambda=\frac{2W}{R_s}\]</span> 可以看到：频谱效率越低，匹配滤波的信噪比增益越高。如果采取升余弦波形，那么它的增益和滚降系数有关，即： <span class="math display">\[\frac{2W}{R_s}=1+\alpha\]</span></p><h3 id="根号奈奎斯特准则">根号奈奎斯特准则</h3><p>在上述讨论中，我们仅仅传输了一个符号，而数字通信需要源源不断的传输间隔为<span class="math inline">\(T_s\)</span>的符号序列。此时，系统设计需要同时满足以下两个条件:</p><ol type="1"><li>采样点无失真</li><li>采样点信噪比最大</li></ol><p>回顾一下数字信号传输的框图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306061606404.png" alt="数字信号传输方框图" /><figcaption aria-hidden="true">数字信号传输方框图</figcaption></figure><p>实际上，我们需要让<span class="math inline">\(\hat G(f)=G(f)H(f)\)</span>满足奈奎斯特第一准则。</p><p>因为匹配滤波器的频响是<span class="math inline">\(H(f)=G^*(f)\)</span>，所以有： <span class="math display">\[\hat G(f) = |G(f)|^2\]</span> 那么只需要这个等效的频响函数满足奈奎斯特第一准则，就能同时满足采样点无失真和采样点信噪比最大了。有： <span class="math display">\[\sum_{n=-\infty}^{\infty}\left|G\left(f+\frac{n}{T_s}\right)\right|^2=T_s\]</span> 这叫<strong>根号奈奎斯特准则</strong>。</p><p>特别的，对于升余弦滤波器来说，如果<span class="math inline">\(G^2(f)\)</span>是升余弦滤波器，那么<span class="math inline">\(G(f)\)</span>叫做“根升余弦滤波器”。</p><h3 id="等效基带模型">等效基带模型</h3><p>为了对前两节（即应用根号奈奎斯特准则）的基带调制解调系统进行一个总体抽象，我们来看一下经过匹配滤波后<span class="math inline">\(kT_s\)</span>时刻的采样值： <span class="math display">\[Y(kT_s)=a_k \int_{-\infty}^{\infty} g^2(t) d t+\int_{-\infty}^{\infty} g(t) N\left(t+k T_s\right) d t\]</span> 等号两边同时除以<span class="math inline">\(E_g=\int g^2(t)dt\)</span>，并令： <span class="math display">\[n_k=\frac{\int_{-\infty}^{\infty} g(t) N\left(t+k T_s\right) d t}{\int_{-\infty}^{\infty} g^2(t) d t}\]</span> 则有： <span class="math display">\[y_k=\frac {Y(kT_S)}{E_g}=a_k+n_k\]</span> 其中<span class="math inline">\(n_k\)</span>符合高斯分布，均值为<span class="math inline">\(0\)</span>，方差为 <span class="math display">\[\frac{n_0}{2E_g}\]</span> 我们希望符号<span class="math inline">\(a_k\)</span>越大越好，但是发射机的平均功率有限制。其功率为： <span class="math display">\[P_s=E_sR_s\]</span> 即每个符号的能量乘以单位时间内传输符号的数目。有： <span class="math display">\[E_S=E[a_k^2]E_g\]</span> 令<span class="math inline">\(E_g=1\)</span>，则<span class="math inline">\(a_k\)</span>的取值满足： <span class="math display">\[E[a_k^2]=P_sT_s\]</span> 在等效基带模型中，<span class="math inline">\(y_k=a_k+n_k\)</span>，<span class="math inline">\(E[a_k^2]=E_s\)</span>，噪声能量<span class="math inline">\(E[n_k^2]=n_0/2\)</span>，平均信噪比<span class="math inline">\(2E_s/n_0\)</span>。</p><h2 id="最佳判决与差错概率">最佳判决与差错概率</h2><p>回忆一下等效基带模型： <span class="math display">\[y_k=a_k+n_k\]</span> 观察到的是有噪声/干扰信号<span class="math inline">\(𝑦_𝑘\)</span>，需要根据观测值推断发送的符号<span class="math inline">\(𝑎_𝑘\)</span>，该过程称为判决。其中噪声满足<span class="math inline">\(n\sim N(\mu=0,\sigma^2=n_0/2)\)</span>，符号满足<span class="math inline">\(E[a^2]=E_s\)</span>。</p><p>注意到<span class="math inline">\(y\)</span>的分布是整个实数域，而符号集合是一个离散的有限集合，所以符号判决的规范表达式为： <span class="math display">\[\varphi: \mathbb R \mapsto \mathbb{A}\]</span> 显然这是一个多对一的映射，其实和量化挺像的。</p><h3 id="各种判决准则">各种判决准则</h3><p>判决的根本目标是最小化错判概率，即： <span class="math display">\[p_e=\sum_{m=1}^M p_m\mathbf {Pr}\{\varphi(y)\neq a_m|a=a_m\}\]</span></p><ol type="1"><li><p>极大似然准则</p><p>极大似然准则的基本思想是在众多的<span class="math inline">\(a\)</span>中寻找一个<span class="math inline">\(a_m\)</span>，使得当发射的符号是<span class="math inline">\(a_m\)</span>时接收端观察到<span class="math inline">\(y\)</span>的可能性最大。即： <span class="math display">\[\varphi(y)=\underset{a_m \in \mathcal{A}}{\arg \max } \operatorname{Pr}\left\{y \mid a=a_m\right\}\]</span></p></li><li><p>最小距离准则</p><p>基于通信信号的收发关系模型<span class="math inline">\(𝑦 = 𝑎 + 𝑛\)</span>，我们可以对ML准则做进一步的简化，得到最小距离准则 <span class="math display">\[\varphi(y)=\arg \min_{a_m\in A}|y-a_m|\]</span> 也就是选择和<span class="math inline">\(y\)</span>距离最近的<span class="math inline">\(a_m\)</span>。</p><p>把相邻两个许用符号的中点称作“判决门限”，把各个判决门限中间的区域称为“判决域”。</p></li></ol><h3 id="m元ask星座">M元ASK星座</h3><p>符号集合<span class="math inline">\(𝔸\)</span>直观地被称为星座图，对其的设计在数字通信中又被称为星座设计。在一维空间上，最佳的<span class="math inline">\(M\)</span>元星座是零均值、等概分布的，这样可以使得平均差错概率最小化。</p><p>双极性ASK星座可以表示为： <span class="math display">\[\mathbb A =\{-(M-1)A,\cdots,-3A,-A,A,3A,\cdots,(M-1)A\}\]</span> 其中符号半间隔为 <span class="math display">\[A=\sqrt{\frac{3E_s}{M^2-1}}\]</span></p><h3 id="数字基带传输的差错分析方法">数字基带传输的差错分析方法</h3><p>首先来点基础知识：标准正态截尾分布函数 <span class="math display">\[Q(u)=\int ^{\infty}_u \frac 1{\sqrt{2\pi}}\exp\left(\frac{-x^2}{2}\right) \mathbf dx\]</span> 这是把标准整体分布函数从一个点<span class="math inline">\(u\)</span>开始往后作积分，也就是一个符合标准正态分布的变量大于<span class="math inline">\(u\)</span>的概率。</p><p>以前面的“双极性ASK星座”为例，进行分析。</p><p>第一步，对于在两边的星座点<span class="math inline">\(-(M-1)A\)</span>和<span class="math inline">\((M-1)A\)</span>来说，以<span class="math inline">\(-(M-1)A\)</span>为例，当噪声<span class="math inline">\(n&gt;A\)</span>时，<span class="math inline">\(y&gt;-(M-2)A\)</span>，此时就会产生误判。于是条件差错概率为： <span class="math display">\[\int^\infty_A\frac{1}{\sqrt{\pi n_0}}\exp \left(-\frac {x^2}{n_0}\right) \mathbf dx\]</span> 针对任何概率形式，我们都需要将其标准正态变量(也就是<span class="math inline">\(A/\sqrt{n_0/2}\)</span>)的统计函数，在上式中，令<span class="math inline">\(z=x/\sqrt{n_0/2}\)</span>，则有： <span class="math display">\[p_1=\int^{\infty}_{\frac {A}{\sqrt{n_0/2}}} \frac 1{\sqrt {2\pi}}\exp\left(-\frac{z^2}{2}\right)\mathbf dz=Q\left(\frac{A}{\sqrt {n_0/2}}\right)\]</span> 对于在中间的星座点，如果噪声<span class="math inline">\(n\)</span>取值过大（<span class="math inline">\(n&gt;A\)</span>）或者过小（<span class="math inline">\(n&lt;-A\)</span>），都会出错，所以出错的概率为： <span class="math display">\[p_2=2Q\left(\frac{A}{\sqrt {n_0/2}}\right)\]</span> 第二步，综合一下，就得到平均误符号率： <span class="math display">\[p_s=\frac 1M (2p_1+(M-2)p_2)=\frac {2(M-1)}{M}Q\left(\frac A{\sqrt{n_0/2}}\right)\]</span> 第三步，计算<span class="math inline">\(A\)</span>和<span class="math inline">\(E_s\)</span>之间的关系，有： <span class="math display">\[E_s=\frac 2M\sum_{i=0}^{2i+1\leq M-1} [(2i+1)A]^2=\frac{M^2-1}{3}A^2\]</span> 于是 <span class="math display">\[A=\sqrt{\frac{3E_s}{M^2-1}}\]</span> 代入，有： <span class="math display">\[p_s=\frac {2(M-1)}{M}Q\left(\sqrt{\frac{6E_s}{(M^2-1)n_0}}\right)\]</span> 然后计算误比特率BER，一般来说，比特和符号之间的映射采用格雷码，信噪比较高时有： <span class="math display">\[p_b=\frac {p_s}{\log _2M}\]</span></p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>本文中，所有省略了积分上下界的积分，都表示积分是从负无穷到正无穷。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理（轨迹分析）</title>
    <link href="/2023/05/21/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2023/05/21/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>轨迹分析主要包含两部分内容，即根轨迹分析和频域分析（即奈奎斯特图和波特图）。</p><h2 id="根轨迹分析法">根轨迹分析法</h2><p>闭环系统的根轨迹指的是闭环系统特征方程的根随着系统开环增益<span class="math inline">\(K\)</span>从零变化到正无穷时变化的轨迹。得到根轨迹图后，就有一一对应的一组系统闭环极点分布，再考虑到系统的闭环零点分布和输入函数等，就可以完成系统的性能分析。</p><p>我们知道，稳定的充要条件就是闭环系统的极点，也就是闭环系统特征方程的根都在<span class="math inline">\(s\)</span>坐标系的左半平面（也就是实部小于零），可以根据不同<span class="math inline">\(K\)</span>取值对应的根轨迹位置，来观察<span class="math inline">\(K\)</span>对系统稳定性的影响。</p><h3 id="根轨迹方程和幅值相角条件">根轨迹方程和幅值相角条件</h3><p>闭环系统的特征方程为： <span class="math display">\[G(s)H(s)=-1\]</span> 那么我们可以写出根轨迹方程： <span class="math display">\[K \cdot \frac{\prod_{i=1}^m\left(s-z_i\right)}{\prod_{j=1}^n\left(s-p_j\right)}=-1\]</span> 凡是满足根轨迹方程的<span class="math inline">\(s\)</span>点都在系统的根轨迹上，其中<span class="math inline">\(K\)</span>是根轨迹增益。对于每个<span class="math inline">\(K\)</span>，都有一组对应的闭环极点，当<span class="math inline">\(K:0\to \infty\)</span>时，不同的<span class="math inline">\(s\)</span>点就形成<span class="math inline">\(n\)</span>条系统根轨迹（其中<span class="math inline">\(n\)</span>是分母的次数）</p><p>把根轨迹方程写出幅值和相角形式，即： <span class="math display">\[K \cdot \frac{\prod_{i=1}^m\left(s-z_i\right)}{\prod_{j=1}^n\left(s-p_j\right)}=1\angle (2k+1)\pi\]</span> 进一步，可以写出幅值条件： <span class="math display">\[\frac{\prod_{j=1}^n\left|s-p_j\right|}{\prod_{i=1}^m\left|s-z_i\right|}=K\]</span> 相角条件： <span class="math display">\[\sum_{i=1}^m \angle (s-z_i)-\sum_{j=1}^n \angle (s-p_j)=(2 k+1) \pi \quad(k=0, \pm 1, \pm 2, \cdots)\]</span></p><h3 id="绘制根轨迹图的基本规则">绘制根轨迹图的基本规则</h3><h4 id="根轨迹的对称性">根轨迹的对称性</h4><p>因为特征方程的根不是实数就是共轭复数，所以根轨迹是关于实轴对称的，所以画的时候只用画上半平面（或者下半平面）的就行了。</p><h4 id="根轨迹的起始点和终止点">根轨迹的起始点和终止点</h4><p>根轨迹起始于开环极点，终止于开环零点。</p><h4 id="根轨迹的条数">根轨迹的条数</h4><p>对于<span class="math inline">\(n\)</span>阶系统，根轨迹有<span class="math inline">\(n\)</span>个起始点，因此有<span class="math inline">\(n\)</span>条。在这<span class="math inline">\(n\)</span>条中，有<span class="math inline">\(m\)</span>（零点数）条终止于有限零点，其余的终止于无穷远点（无限零点）。</p><h4 id="根轨迹在实轴上的分布规律">根轨迹在实轴上的分布规律</h4><p>对于实轴上的一段，如果其右边的开环零极点数目之和是奇数，那么这段实轴是根轨迹的一部分。</p><h4 id="根轨迹的渐近线">根轨迹的渐近线</h4><p>有<span class="math inline">\((n-m)\)</span>条根轨迹终止于无穷远点，描述它们的方法就是用渐近线。确定渐近线的方法很简单，即首先确定其斜率，然后确定其在实轴（横轴）上的截距。</p><p>其斜率（与正实轴的夹角）满足： <span class="math display">\[\varphi_{\mathrm{A}}=\frac{ \pm(2 k+1) \pi}{n-m} \quad(k=0,1,2, \cdots)\]</span> 截距（和实轴的交点）满足： <span class="math display">\[\sigma_{\mathrm{A}}=\frac{\sum_{j=1}^n p_j-\sum_{i=1}^m z_i}{(n-m)}\]</span></p><h4 id="实轴上根轨迹的分离点和汇合点">实轴上根轨迹的分离点和汇合点</h4><p>根轨迹在实轴上的某个点分叉或者相会，这个点就称为分离点或者汇合点，而且这个点一定是重极点。算分离点和汇合点的方法有两种。</p><p>其一是解方程： <span class="math display">\[\sum_{i=1}^m \frac{1}{\sigma_{\mathrm{B}}-z_i}=\sum_{j=1}^n \frac{1}{\sigma_{\mathrm{B}}-p_j}\]</span> 得到的<span class="math inline">\(\sigma_b\)</span>们即为分离点或汇合点。</p><p>其二是解联立方程： <span class="math display">\[\begin{cases}&amp; 1+G(s) H(s)=0 \\&amp; \frac{\mathrm{d}}{\mathrm{d} s}[G(s) H(s)]=0\end{cases}\]</span> 得到的<span class="math inline">\(s\)</span>即为分离点或汇合点。当然解这个方程不是硬解，因为里面有个常数<span class="math inline">\(K\)</span>。一般是先解下面的那个，然后检验解是不是在根轨迹上就行了。</p><h4 id="根轨迹的起始角和终止角">根轨迹的起始角和终止角</h4><p>起始角就是开环极点处根轨迹的切线和正实轴的夹角；终止角就是开环零点处根轨迹和正实轴的夹角。</p><p><span class="math inline">\(p_1\)</span>极点处起始角为： <span class="math display">\[\theta_{p1}=\pm (2k+1)\pi+\sum_{i=1}^m\angle (p_1-z_i)-\sum_{j=2}^n \angle(p_1-p_j)\]</span> <span class="math inline">\(z_1\)</span>零点处终止角为： <span class="math display">\[\theta_{z1}=\pm (2k+1)\pi+\sum_{i=1}^n\angle (z_1-p_i)-\sum_{j=2}^m \angle(z_1-z_j)\]</span></p><h4 id="根轨迹的分离角和会合角">根轨迹的分离角和会合角</h4><p>根轨迹在<span class="math inline">\(s\)</span>平面上相遇后分开，分离角指的是根轨迹离开重极点处的切线和正实轴的夹角；会合角指的是根轨迹进入重极点处的切线和正实轴的夹角。有： <span class="math display">\[\theta = \frac{360^\circ}{q}\]</span></p><h4 id="根轨迹和虚轴的交点">根轨迹和虚轴的交点</h4><p>根轨迹最重要的部分就是在靠近虚轴和原点的那一部分，因为判定系统稳定的依据就是根是否都在<span class="math inline">\(s\)</span>坐标系的左半平面。</p><p>利用系统闭环特征方程，令<span class="math inline">\(s=j\omega\)</span>代入后满足特征方程实部虚部均为零，则<span class="math inline">\(\omega\)</span>就是根轨迹和虚轴的交点 <span class="math display">\[1+G(s)H(s)=0\]</span></p><blockquote><p>【例】已知单位反馈系统开环传递函数是 <span class="math display">\[\frac{k}{s (0.05 s+1) (0.05 s^2+0.2 s+1)}\]</span> 画出根轨迹图。</p><p>【解】第一步：将其化成零极点形式 <span class="math display">\[G(s)=\frac{K}{s(s+20)(s+2+4j)(s+2-4j)}\]</span> 其中<span class="math inline">\(K=400k\)</span>。系统没有开环零点，<span class="math inline">\(m=0\)</span>；有四个开环极点，<span class="math inline">\(n=4\)</span>，四个极点分别为<span class="math inline">\(p_0=0,p_2=20,p_3=-2+4j,p_4=-2-4j\)</span>。</p><p>第二步：根轨迹总共有四条，起始点分别为<span class="math inline">\(p_{1,2,3,4}\)</span>，终止点都是无穷远点。</p><p>第三步：根轨迹渐近线的实轴截距为： <span class="math display">\[\sigma_{\mathrm{A}}=\frac{\sum_{j=1}^n p_j-\sum_{i=1}^m z_i}{(n-m)}=-6\]</span> 斜率为 <span class="math display">\[\varphi_{\mathrm{A}}=\frac{ \pm(2 k+1) \pi}{4}\]</span> 取<span class="math inline">\(k=0,1\)</span>，得夹角为<span class="math inline">\(\pm 45^\circ,\pm135^\circ\)</span></p><p>第四步：求复数极点处的起始角 <span class="math display">\[\begin{aligned}\theta_{p_3}&amp;=\pm (2k+1)\pi-\sum_{j=1,j\neq 3}^4 \angle(p_3-p_j)\\&amp;=\pm(2k+1)\times 180^\circ -116.6^\circ -12.5^\circ - 90^\circ\\&amp;=-39.1^\circ\end{aligned}\]</span> （取<span class="math inline">\(k=0\)</span>）。则<span class="math inline">\(\theta_{p_4}=39.1^\circ\)</span></p><p>第五步：求实轴上分离点坐标和分离角 <span class="math display">\[\frac 1{\sigma_b}+\frac 1{\sigma_b+20}+\frac 1{\sigma_b+2+4j}+\frac 1{\sigma_b+2-4j}=0\]</span> 解得<span class="math inline">\(\sigma_b=-15.1\)</span>，分离角为<span class="math inline">\(\pm 90^\circ\)</span></p><p>第六步：求根轨迹和虚轴的交点。闭环特征方程为： <span class="math display">\[s(s+20)(s^2+4s+20)+k=0\]</span> 令<span class="math inline">\(s=j\omega\)</span>，代入： <span class="math display">\[j\omega(j\omega+20)(-\omega^2+4j\omega+20)+k=0\]</span> 令实部虚部都是零，有： <span class="math display">\[\begin{cases}\omega^4-100\omega^2+k=0\\-24\omega^2+400\omega=0\end{cases}\]</span> 得<span class="math inline">\(\omega=\pm 4.1,k=1391\)</span>。</p><p>于是，可以画出根轨迹图了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306072231198.png" alt="根轨迹图" /><figcaption aria-hidden="true">根轨迹图</figcaption></figure><p>上面这张图是用<code>Mathematica</code>画的，代码为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">RootLocusPlot</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">s</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">0.05</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">0.05</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.2</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">k</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">80</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <br> <span class="hljs-built_in">PlotStyle</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-built_in">AbsoluteThickness</span><span class="hljs-punctuation">[</span><span class="hljs-number">5.`</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="频域分析法">频域分析法</h2><p>系统的频率响应函数就是把<span class="math inline">\(G(s)\)</span>里面的<span class="math inline">\(s\)</span>换成<span class="math inline">\(j\omega\)</span>，即<span class="math inline">\(G(j\omega)\)</span>。</p><p>在进行频域分析法时，有两件事是无论如何都要注意的：</p><ol type="1"><li><p>对开环系统函数进行分析</p></li><li><p>要把系统函数各个因子的系数化为1，即： <span class="math display">\[G(s)=\frac{K_0(\tau_1s+1)\cdots(\tau_2s^2+2\xi_2\tau_2s+1)\cdots}{s^v(T_1s+1)\cdots(T_2s^2+2\xi_2T_2s+1)\cdots}\]</span></p></li></ol><h3 id="奈奎斯特图">奈奎斯特图</h3><p>奈奎斯特图就是在复平面上<span class="math inline">\(G(j\omega)\)</span>的值随<span class="math inline">\(\omega\)</span>从<span class="math inline">\(0\)</span>变化到<span class="math inline">\(+\infty\)</span>时的参数图像。在介绍奈奎斯特图的画法时，我将介绍两种方法。首先介绍一种公式法，然后来说明公式法的本质。</p><h4 id="公式法">公式法</h4><p>按照下面几个步骤，可以画出奈奎斯特图。</p><ol type="1"><li><p>确定起点</p><p>起点按照以下公式确定： <span class="math display">\[G(0+)=\begin{cases}0_+\angle(-v\frac \pi2+\angle K_0) &amp; v&lt;0\\[2ex]|K_0|\angle K_0 &amp; v=0\\[2ex]\infty\angle(-v\frac \pi2+\angle K_0) &amp; v&gt;0\end{cases}\]</span> 其中<span class="math inline">\(v\)</span>是传递函数分母里面单个<span class="math inline">\(s\)</span>的指数，<span class="math inline">\(K_0\)</span>是分子上提出来的系数。</p><p>然后，看（分母中<span class="math inline">\(s\)</span>一次项的系数之和-分子中<span class="math inline">\(s\)</span>一次项的系数之和），如果这个值大于零，那么就在前进方向的坐标轴的左侧，否则在右侧。</p><p>以 <span class="math display">\[G(s)=\frac 1{s(s+1)(2s+1)}\]</span> 为例，有<span class="math inline">\(v=1&gt;0\)</span>，所以<span class="math inline">\(G(0+)=\infty\angle (-\frac \pi2+0)=\infty\angle -90^\circ\)</span></p><p>分母中<span class="math inline">\(s\)</span>的系数之和为<span class="math inline">\(1+1+2=3\)</span>，分子中<span class="math inline">\(s\)</span>的系数之和为零，所以在前进方向坐标轴的左侧，即正向纵轴的左侧，即从第四象限起笔</p></li><li><p>确定终点</p><p>终点按以下公式确定： <span class="math display">\[G(j\infty)=\begin{cases}|K^*|\angle\left[-(n&#39;+m&#39;)\frac \pi2+\angle K_0\right] &amp; n=m\\[2ex]0_+\angle\left[-(n&#39;+m&#39;)\frac \pi2+\angle K_0\right] &amp;n&gt;m\end{cases}\]</span> 其中<span class="math inline">\(m\)</span>是分子的总次数，<span class="math inline">\(n\)</span>是分母的总次数，<span class="math inline">\(m&#39;=m_a-m_b\)</span>，<span class="math inline">\(n&#39;=n_a-n_b\)</span></p><p><span class="math inline">\(*_a\)</span>代表分子/分母中最小相位环节（就是<span class="math inline">\(s\)</span>前面系数是正的）的总阶数，<span class="math inline">\(*_b\)</span>代表分子/分母中非最小相位环节的总阶数。</p><p>继续以上面的系统为例，分子中次数为零，最小相位环节阶数为零；分母中次数为3，最小相位环节总阶数也是3，所以 <span class="math display">\[G(j\infty)=0_+\angle\left[-(3-0)\frac \pi2+0\right]=0_+\angle -270^\circ\]</span> 于是，知道了起点和终点，我们就可以初步画出<span class="math inline">\(0_+\to\infty\)</span>的图像了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306142222129.png" alt="初步图像" /><figcaption aria-hidden="true">初步图像</figcaption></figure><p>绘图代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">ParametricPlot</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Re</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <br>  <span class="hljs-built_in">Im</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">w</span><span class="hljs-operator">,</span> <span class="hljs-number">0.01</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure></li><li><p>补充虚圆</p><p>为什么说上面的是初步呢？因为还有<span class="math inline">\(0\to0_+\)</span>这部分的没有画，而且这部分还很重要。</p><p>如果<span class="math inline">\(v=0\)</span>，那么不用画。</p><p>如果<span class="math inline">\(G(s)\)</span>在原点上有重根，即<span class="math inline">\(v&gt;0\)</span>，那么以<span class="math inline">\(\angle K_0\)</span>为开始，半径无穷大，顺时针转<span class="math inline">\(+v\frac \pi2\)</span>，接到上面那个图像的起点处。</p><p>*如果<span class="math inline">\(G(s)\)</span>在虚轴上有<span class="math inline">\(n\)</span>重共轭极点<span class="math inline">\(\pm j\omega_n\)</span>，则： <span class="math display">\[G(s)=\frac 1{(s^2+\omega_n^2)^u}G_2(s)\]</span> 其中<span class="math inline">\(G_2(s)\)</span>是没有<span class="math inline">\(n\)</span>重共轭极点的。那么从<span class="math inline">\(G_2(j\omega_n)\)</span>开始，以半径为无穷大，顺时针转<span class="math inline">\(+u\pi\)</span>，接到起点处。</p><p>还是对于上面这个例子，属于第二种情况，于是可以画出：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306142232168.png" alt="img" style="zoom:25%;" /></p></li></ol><h4 id="定义法">定义法</h4><ol type="1"><li><p>确定起点</p><p>说起起点，就是计算 <span class="math display">\[\lim_{\omega\to 0+}G(j\omega)\]</span> 不就行了吗？先来看模长部分，那当然是<span class="math inline">\(v&gt;0\)</span>就是无穷大，因为分母是零；<span class="math inline">\(v&lt;0\)</span>是零，因为分子是零，这是显然的。然后看相位，众所周知复数相乘就是相位相加，复数相除就是相位相减，所以相位就是分子的相位减去分母的相位之和了。考虑一个<span class="math inline">\((\tau j\omega+1)\)</span>，当<span class="math inline">\(\omega\to 0_+\)</span>时，这玩意就趋向于<span class="math inline">\(1\)</span>，对应的相位就是<span class="math inline">\(0\)</span>，所以不用管，只看<span class="math inline">\(j\omega\)</span>单独的那一项，一个它的相位是<span class="math inline">\(90^\circ\)</span>，总共有<span class="math inline">\(v\)</span>个它，这就是公式法里面的 <span class="math display">\[-v\frac \pi2+\angle K_0\]</span> 的来历。</p></li><li><p>确定终点</p><p>终点就是 <span class="math display">\[\lim_{\omega\to \infty}G(j\omega)\]</span> 幅值分析略，看相位。最小相位系统就是<span class="math inline">\((j\omega+1)\)</span>，非最小相位系统就是<span class="math inline">\((-j\omega+1)\)</span>，当<span class="math inline">\(\omega\to \infty\)</span>的时候他俩分别就是<span class="math inline">\(j,-j\)</span>，对应的相位就是<span class="math inline">\(90^\circ,-90^\circ\)</span>。这就是公式法里面的 <span class="math display">\[-(n&#39;+m&#39;)\frac \pi2+\angle K_0\]</span></p></li><li><p>画出虚圆</p><p>这里只说第二种情况。如果<span class="math inline">\(\omega=0\)</span>了，那么值显然是<span class="math inline">\(sgn[K_0]\infty\)</span>，实数，所以要从<span class="math inline">\(\angle K_0\)</span>开始。但是从<span class="math inline">\(0+\)</span>开始那它就不是实数，就有一个“确定起点”的那个角度，这时候虚圆就是把这俩连起来就行。</p></li></ol><p>画图完成以后，还要计算一个点，那就是图像和横轴的交点，名叫穿越点，对应的频率叫穿越频率。</p><h4 id="奈奎斯特稳定判据">奈奎斯特稳定判据</h4><p>利用奈奎斯特图判断闭环系统的稳定性，需要计算 <span class="math display">\[Z=P-2N\]</span> 如果<span class="math inline">\(Z=0\)</span>，那么稳定。</p><p>其中，<span class="math inline">\(P\)</span>是开环中实部大于零的极点的个数，也可以对分母用劳斯表，看第一列的符号改变次数。</p><p><span class="math inline">\(N\)</span>是曲线穿越<span class="math inline">\((-\infty,-1)\)</span>这段横轴的总次数，但是有正有负：</p><ul><li>虚圆穿越，总是负的</li><li>实线穿越，以<span class="math inline">\((-1,0)\)</span>作为视点，看它是顺时针（负）还是逆时针（正）</li><li>如果起始点、终止点在轴上，算<span class="math inline">\(0.5\)</span>次</li></ul><h3 id="波特图">波特图</h3><p>波特图由两张半对数坐标图组成，其中一张表征幅频特征，一张表征相频特征。其横坐标是频率，为对数坐标；幅频纵坐标是dB，相频纵坐标是线性。绘制波特图首先要记住两个原则</p><ol type="1"><li>如果两个传递函数互为倒数，那么波特图关于横轴镜像对称</li><li>如果两个传递函数互为共轭（即<span class="math inline">\(s\)</span>换成<span class="math inline">\(-s\)</span>），那么幅频曲线相同，相频关于横轴镜像对称</li></ol><p>然后记住两个典型环节：</p><ol type="1"><li><p>惯性环节 <span class="math display">\[\frac 1{\frac{s}{\omega_n}+1}\]</span> 对应的幅频斜率为<span class="math inline">\(-20\)</span>dB/十倍频，对应的相频变化量为<span class="math inline">\(-90^\circ\)</span></p></li><li><p>震荡环节 <span class="math display">\[\frac 1{\left(\frac s {\omega_n}\right)^2+2\xi\frac s{\omega_n}+1}\]</span> 对应的幅频斜率为<span class="math inline">\(-40\)</span>dB/十倍频，对应的相频变化量为<span class="math inline">\(-180^\circ\)</span></p></li></ol><p>然后可以开始画了。画的步骤如下。在下面的例子中，传递函数为： <span class="math display">\[G(s)=\frac{100(1+\sqrt{10}s)}{(-100s^2+20s+1)(-0.001s^2+\frac{\sqrt{10}}{3000}s+1)}\]</span></p><ol type="1"><li><p>把系统函数按转折频率从低到高排列，并把因子写成上面的那种形式，然后在横轴上标出转折频率 <span class="math display">\[G(s)=100\cdot \frac{1}{\left(\frac{s}{0.1}\right)^2+2\frac{s}{0.1}+1}\cdot \left(\frac{s}{\frac{1}{\sqrt{10}}}+1\right)\cdot \frac{1}{\frac{s}{10\sqrt {10}}^2+\frac 1{30}\frac{s}{10\sqrt {10}}+1}\]</span> 所以转折频率为<span class="math inline">\(0.1,1/\sqrt {10},10\sqrt{10}\)</span></p></li><li><p>低频段（即比最低的转折频率还低的一段）：幅频斜率为<span class="math inline">\(-20v\)</span>dB/十倍频，相位起点为<span class="math inline">\(-v\cdot 90^\circ+\angle K_0\)</span>，然后根据幅频曲线一定经过<span class="math inline">\((|K_0|^{1/v},0)\)</span>或者<span class="math inline">\((1,20\lg|K_0|)\)</span>来确定幅频曲线的位置</p><p>在本例中，<span class="math inline">\(v=0,\angle K_0=0\)</span>，<span class="math inline">\(-20v=0\)</span>，<span class="math inline">\(20\lg K_0=40\)</span></p></li><li><p>幅频图中，每段以转折频率为界限，调整斜率，在原有斜率的基础上增加目前环节对应的斜率。</p></li><li><p>相频图中，每个转折频率代表相频图在<span class="math inline">\(0.1\omega_c,10\omega_c\)</span>上变化了<span class="math inline">\(\Delta \varphi\)</span>，不同的转折频率之间相互叠加</p></li><li><p>（可选）在二阶环节对应的转折频率处补充一个高度为<span class="math inline">\(20\lg |1/2\xi|\)</span>的尖峰</p></li><li><p>计算幅频曲线和<span class="math inline">\(\omega\)</span>轴的交点</p></li></ol><h4 id="对数判据">对数判据</h4><p>要用波特图判断闭环系统的稳定性，同样要计算 <span class="math display">\[P-2N\]</span> 其中<span class="math inline">\(P\)</span>是开环中实部大于零的极点的个数，<span class="math inline">\(N\)</span>是在<span class="math inline">\(L(\omega)&gt;0\)</span>即幅频图为正值的部分中，相频曲线穿过<span class="math inline">\((2k+1)\pi\)</span>的次数之和，向上穿越算正数，向下穿越算负数</p><h4 id="稳定裕度">稳定裕度</h4><p>稳定裕度是衡量系统相对稳定性质的量，分为相位裕度和增益裕度。</p><p>相位裕度的定义是在幅频波特图和横轴的交点<span class="math inline">\(\omega_c\)</span>处，使系统达到临界稳定状态的附加相移，有： <span class="math display">\[\gamma=180^\circ+\angle G(j\omega_c)H(\omega_c)\]</span> 在奈奎斯特图中，相位裕度<span class="math inline">\(\gamma\)</span>指的是曲线和单位圆的交点和原点的连线与负实轴之间的夹角。</p><p>增益裕度<span class="math inline">\(K_g\)</span>的定义是在相频波特图和<span class="math inline">\(-180^\circ\)</span>的交点<span class="math inline">\(\omega_g\)</span>处，使得系统达到临界稳定状态所需增大的增益倍数，一般用dB表示，有： <span class="math display">\[K_g=-20\lg|G(j\omega_g)H(j\omega_g)|\]</span> 在奈奎斯特图中，增益裕度是曲线和负实轴的交点离原点的距离的倒数。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理笔记（时域分析）</title>
    <link href="/2023/05/20/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2023/05/20/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="控制系统基础知识">控制系统基础知识</h2><p>在本节，将对自动控制原理中的一些基础概念给出定义，以方便后续的讨论。</p><h3 id="控制系统的性能要求">控制系统的性能要求</h3><p>自动控制系统的目标是使得被控量按照指定规律变化。系统受到外加信号作用之后，被控量随着时间变化并趋于一定规律的全过程被称为系统的动态特性。</p><p>系统的<strong>稳定性</strong>指的是系统进入稳态或者恢复工作状态的能力，即瞬态响应是否会随着时间的延续而趋向于0。系统的<strong>平稳性</strong>指的是当系统稳定时，要求<span class="math inline">\(c(t)\)</span>即输出信号的振荡小，在时域分析中通常用超调量<span class="math inline">\(M_p\)</span>表示。系统的“<strong>快速</strong>”指的是动态过程（即瞬态响应）持续的时间长短。系统的<strong>准确度</strong>指的是过渡到新的平衡状态后最终保持的精度。</p><h3 id="控制系统的数学模型">控制系统的数学模型</h3><p>控制系统通常用微分（差分）方程、方框图等形式表示。一个一般的闭环系统的方框图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112045896.png" alt="闭环系统方框图" /><figcaption aria-hidden="true">闭环系统方框图</figcaption></figure><p>其中<span class="math inline">\(G(s)\)</span>称为前向传递函数，<span class="math inline">\(G(s)H(s)\)</span>称为开环传递函数，当<span class="math inline">\(H(s)=1\)</span>时，开环传递函数和前向传递函数相等。而 <span class="math display">\[T(s)=\frac {C(s)}{R(s)}=\frac{G(s)}{1+G(s)H(s)}\]</span> 称为闭环传递函数，它也是整个闭环系统的传递函数。</p><p>对于一般的控制系统，其控制元件的数学模型都是由几种简单的因子或者典型单元结构组成的，常称为“典型环节”。常见的典型环节有：</p><ol type="1"><li><p>放大环节</p><p>微分方程为 <span class="math display">\[y(t)=Kx(t)\]</span> 传递函数为 <span class="math display">\[G(s)=K\]</span></p></li><li><p>惯性环节</p><p>微分方程为 <span class="math display">\[T\frac{dy(t)}{dt}+y(t)=x(t)\]</span> 传递函数为 <span class="math display">\[G(s)=\frac{1}{Ts+1}\]</span> 其中<span class="math inline">\(T\)</span>叫做时间常数，典型的惯性环节是RC网络。</p></li><li><p>一阶微分环节</p><p>微分方程为 <span class="math display">\[y(t)=\tau \frac {dx(t)}{dt}+x(t)\]</span> 传递函数为 <span class="math display">\[G(s)=\tau s +1\]</span></p></li><li><p>积分环节</p><p>微分方程为 <span class="math display">\[\frac{dy(t)}{dt}=x(t)\]</span> 传递函数为 <span class="math display">\[G(s)=\frac 1s\]</span></p></li><li><p>理想微分环节</p><p>微分方程为 <span class="math display">\[y(t)=\frac{dx(t)}{dt}\]</span> 传递函数为 <span class="math display">\[G(s)=s\]</span></p></li></ol><p>此外，还有震荡环节、二阶微分环节等。</p><h2 id="时域分析法">时域分析法</h2><p>在时域分析法中，往往选择典型的初始状态（零状态，即<span class="math inline">\(t=0-\)</span>时，<span class="math inline">\(c(t)\)</span>的任意阶导数为零），典型的输入信号（如阶跃、斜坡、加速度、冲击、正弦信号），求出典型的时间响应，然后考察系统的性能。</p><h3 id="一阶系统时域分析">一阶系统时域分析</h3><p>一个典型的闭环一阶系统的框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112112739.png" alt="一阶系统" /><figcaption aria-hidden="true">一阶系统</figcaption></figure><p>其闭环传递函数为 <span class="math display">\[T(s)=\frac{1}{\frac 1Ks+1}=\frac{1}{Ts+1}\]</span> 在<span class="math inline">\(-K=-1/T\)</span>处有一个极点。</p><p>其单位阶跃响应为： <span class="math display">\[c(t)=\left(1-e^{-\frac 1T t}\right)u(t)\]</span> 其时域性能只由一个参数决定，即<span class="math inline">\(-1/T\)</span>，其中<span class="math inline">\(T\)</span>也叫时间常数，它表示系统响应达到稳态值的<span class="math inline">\(63.2\%\)</span>所需的时间。时间常数越小，系统的速度越快。其调整时间一般取<span class="math inline">\(t_s=3T(5\%\Delta)\)</span>或<span class="math inline">\(t_s=4T(2\%\Delta)\)</span>，稳态误差为零。</p><p>其单位斜坡响应为 <span class="math display">\[c(t)=(t-T)+Te^{-t/T}\]</span> 所以具有稳态误差，为<span class="math inline">\(T\)</span>。</p><h3 id="二阶系统时域分析">二阶系统时域分析</h3><p>一个典型的二阶系统如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112126058.png" alt="二阶系统" /><figcaption aria-hidden="true">二阶系统</figcaption></figure><p>其闭环传递函数为 <span class="math display">\[T(s)=\frac{K}{Ts^2+s+K}\]</span> “标准形式”为： <span class="math display">\[T(s)=\frac{\omega_n^2}{s^2+2 \xi \omega_n s+\omega_n^2}=\frac{\omega_n^2}{\left(s-s_1\right)\left(s-s_2\right)}\]</span> 之所以要写成看起来这么复杂的样子，是因为其中的参数<span class="math inline">\(\xi,\omega_n\)</span>等有其物理意义。其中<span class="math inline">\(\omega_n=\sqrt{K/T}\)</span>叫做“无阻尼振荡频率”，<span class="math inline">\(\xi =1/(2\sqrt{KT})\)</span>叫做“阻尼比”。阻尼比决定了系统阶跃响应的模式。</p><ol type="1"><li><p>欠阻尼系统（<span class="math inline">\(\xi \in (0,1)\)</span>）</p><p>两个极点<span class="math inline">\(s_1,s_2\)</span>互为共轭复根。阻尼自然频率<span class="math inline">\(\omega_d=\omega_n\sqrt{1-\xi^2}\)</span>。欠阻尼系统的阶跃响应时域波形大概是这个样子：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112143198.png" alt="欠阻尼阶跃响应" /><figcaption aria-hidden="true">欠阻尼阶跃响应</figcaption></figure></li></ol><p>可以看到里面有很多参数。下面介绍几个比较重要的</p><ul><li><p>上升时间<span class="math inline">\(t_r\)</span></p><p>指的是从稳态值的<span class="math inline">\(10\%\)</span>上升到<span class="math inline">\(90\%\)</span>所需的时间。有： <span class="math display">\[t_r=\frac{\pi-\beta}{\omega_d}\]</span></p></li><li><p>峰值时间<span class="math inline">\(t_p\)</span></p><p>指的是系统达到最大值所需的时间。有： <span class="math display">\[t_p=\frac \pi {\omega_d}\]</span></p></li><li><p>最大超调量<span class="math inline">\(M_p\)</span></p><p>指的是响应峰值和稳态值之间的归一化差值。有： <span class="math display">\[M_p=\frac{c(t_p)-c(\infty)}{c(\infty)}=e^{-\frac{\pi \xi}{\sqrt{1-\xi^2}}}\]</span></p></li><li><p>调节时间<span class="math inline">\(t_s\)</span></p><p>调节时间指的是满足： <span class="math display">\[\forall t&gt;t_s,|c(t)-c(\infty)|\leq \Delta c(\infty)\]</span> 的最小<span class="math inline">\(t_s\)</span>。有： <span class="math display">\[t_s= \begin{cases}\frac{4}{\xi \omega_n} &amp; 2 \% \Delta \\ \frac{3}{\xi \omega_n} &amp; 5 \% \Delta\end{cases}\]</span></p></li></ul><ol start="2" type="1"><li><p>过阻尼系统（<span class="math inline">\(\xi &gt;1\)</span>）和临界阻尼系统（<span class="math inline">\(\xi=1\)</span>）</p><p>这两种情况下，<span class="math inline">\(c(t)\)</span>是单调上升过程，系统近似为一阶系统，单位阶跃响应近似表示为： <span class="math display">\[c(t)=1-\exp [-(\xi -\sqrt{\xi ^2-1})\omega_n t]\]</span></p></li></ol><h3 id="稳定性分析">稳定性分析</h3><p><span class="math inline">\(H(s)\)</span>的极点如果全部位于左半平面，则系统稳定。当虚轴存在一阶零点时，称为边界稳定或者震荡稳定；当右半平面有极点，或者虚轴上有高阶极点时，称系统不稳定。</p><ol type="1"><li><p>首先基于<span class="math inline">\(H(s)=N/D\)</span>的阶次进行分析。其中<span class="math inline">\(N\)</span>是<span class="math inline">\(m\)</span>阶多项式，<span class="math inline">\(D\)</span>是<span class="math inline">\(n\)</span>阶多项式。</p><p>如果<span class="math inline">\(m&gt;n\)</span>，系统一定存在一个无穷远点处的极点。基于这个事实，有以下系统稳定的必要条件：</p><ol type="1"><li><span class="math inline">\(m\leq n\)</span>是系统稳定的必要条件</li><li><span class="math inline">\(m&gt;n+1\)</span>时，系统一定不稳定</li></ol></li><li><p>基于分母多项式（也叫特征多项式）的根的分布判别</p><ol type="1"><li><p>必要条件</p><ol type="1"><li><span class="math inline">\(D(s)\)</span>的所有系数都同号</li><li><span class="math inline">\(D(s)\)</span>不缺项，或者缺全部的奇次或偶次项</li></ol><p>上面两个条件是必要条件，只要任一条件不被满足，系统就不是稳定的。但是即使全部满足，系统也不一定稳定。例如： <span class="math display">\[D(s)=2s^3+s^2+3s+9\]</span></p></li><li><p>劳斯判据</p><p>劳斯判据就是列劳斯表，然后看第一列是不是全同号。劳斯表是这样列的：</p><p>前两行，第一行从前往后是<span class="math inline">\(a_n,a_{n-2},a_{n-4},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>；第二行，是<span class="math inline">\(a_{n-1},a_{n-3},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>。设劳斯表第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素是<span class="math inline">\(m_{ij}\)</span>，在第三行之后，有： <span class="math display">\[m_{ij}=-\frac{1} {m_{i-1,1} }\begin{vmatrix}m_{i-2,1} &amp; m_{i-2,j+1}\\m_{i-1,1} &amp; m_{i-1,j+1}\\\end{vmatrix}\]</span> 单看这些下标可能还比较抽象。实际上就是说，第三行以后的劳斯表的元素都是一个二阶行列式的相反数除以它上一行的第一个数。这个二阶行列式的左侧一列是它上一行和上上一行的第一个数，右侧一列从上一行和上上一行的第二个数开始，随着当前要算的这个元素在自己的行中向右移动而向右移动。</p><p>在计算过程中，可能会出现两种特殊情况。</p><p>其一是某一行的第一个数是零，但其余各项不全为零。这时候只需要把它用一个很小的正数<span class="math inline">\(\epsilon\)</span>代替然后继续算就行。</p><p>其二是某一行的所有数都是零，这代表着系统可能存在互为相反数的实根，或者共轭虚根，或者关于原点对称的共轭复根。这时可以把全零行的上一行的系数构造一个辅助多项式（最高次是行号，然后每个系数降2次），对其求导，并把求导结果带入全零行，然后继续算。需要注意：辅助多项式的根也是原方程的根。</p></li></ol></li></ol><h3 id="稳态误差分析">稳态误差分析</h3><p>如果输入信号<span class="math inline">\(r(t)\)</span>和输出信号<span class="math inline">\(c(t)\)</span>是同量纲、同数量级的，那么系统误差定义为： <span class="math display">\[e(t)=r(t)-c(t)\]</span> 但是实际上这并不可能，因为很多系统都是用电压输入，而输出的被控量很可能是温度，速度等物理量。这就需要用一个传感器把被控量转换为和输入量同量纲同数量级的量，并放在反馈支路。此时系统误差定义为： <span class="math display">\[e(t)=r(t)-b(t)\]</span> 为计算稳态误差，考虑终值定理（使用条件：<span class="math inline">\(E(s)\)</span>极点都在<span class="math inline">\(s\)</span>左半平面），有： <span class="math display">\[\lim _{t\to \infty}e(t)=e_s=\lim_{s\to 0}sE(s)=\lim _{s \rightarrow 0} s \cdot \frac{R(s)}{1+G(s) H(s)}\]</span> 注意到，系统稳态误差和输入信号以及开环传递函数<span class="math inline">\(G(s)H(s)\)</span>有关。稳态误差仅对稳定系统才有意义。</p><p>系统开环传递函数一般为： <span class="math display">\[G(s) H(s)=\frac{K\left(\tau_1 s+1\right) \cdots\left(\tau_2^2 s^2+2 \xi \tau_2 s+1\right) \cdots}{s^N\left(T_1 s+1\right) \cdots\left(T_2^2 s^2+2 \xi T_2 s+1\right) \cdots}\]</span> 注意：这里的系数<span class="math inline">\(K\)</span>的提出是为了把后面的每一项的常数项都设置为<span class="math inline">\(1\)</span>，称为系统的开环放大倍数。分母里的<span class="math inline">\(s^N\)</span>的指数<span class="math inline">\(N\)</span>表示系统开环串联的积分环节的个数，决定了系统的型别，即“<span class="math inline">\(N\)</span>型系统”</p><p>接下来就输入信号和系统型别来讨论稳态误差：</p><ol type="1"><li><p>输入<span class="math inline">\(R(s)=1/s\)</span></p><p>此时有： <span class="math display">\[e_{ss}=\lim _{\mathrm{s} \rightarrow 0} \frac{1}{1+G(s) H(s)}=\frac{1}{1+\lim _{\mathrm{s} \rightarrow 0} G(s) H(s)}=\frac{1}{1+K_p}\]</span> 其中<span class="math inline">\(K_p=\lim _{s\to 0}G(s)H(s)\)</span>称为阶跃误差系数，也叫静态位置误差系数。</p><ul><li>0型系统：<span class="math inline">\(K_p=K,e_{ss}=1/(1+K)\)</span></li><li><span class="math inline">\(0\)</span>型以上系统：<span class="math inline">\(K_p=\infty,e_{ss}=0\)</span></li></ul></li><li><p>输入<span class="math inline">\(R(s)=1/s^2\)</span></p><p>此时有： <span class="math display">\[e_{s r}=\lim _{s \rightarrow 0} \frac{1}{s+s G(s) H(s)}=\frac{1}{\lim _{s \rightarrow 0} s G(s) H(s)}=\frac{1}{K_v}\]</span> <span class="math inline">\(K_v\)</span>叫做斜坡误差系数，也叫静态速度误差系数。</p></li></ol><table><thead><tr class="header"><th>系统型别</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(K_v\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td><span class="math inline">\(e_{sr}\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(1/K\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td></tr></tbody></table><ol start="3" type="1"><li><p>输入<span class="math inline">\(R(s)=1/s^3\)</span></p><p>此时有： <span class="math display">\[e_{s p}=\lim _{s \rightarrow 0} \frac{1}{s^2+s^2 G(s) H(s)}=\frac{1}{\lim _{s \rightarrow 0} s^2 G(s) H(s)}=\frac{1}{K_a}\]</span> <span class="math inline">\(K_a\)</span>叫做抛物线误差系数，也叫静态加速度误差系数。</p></li></ol><table><thead><tr class="header"><th>系统型别</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(K_a\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td><span class="math inline">\(e_{sp}\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(1/K\)</span></td><td><span class="math inline">\(0\)</span></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息论笔记</title>
    <link href="/2023/05/18/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/18/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="信息的统计度量">信息的统计度量</h2><h3 id="信息量">信息量</h3><h4 id="自信息量">自信息量</h4><p>从信源中获取信息的过程就是其不确定性缩减的过程，在统计分析中，使用概率作为衡量不确定性的一种度量。因此，信息量和概率是紧密相关的。任意事件的自信息量的定义为该事件发生的概率的对数的负值，即：</p><p>在总体<span class="math inline">\(X\)</span>中，事件<span class="math inline">\(x_i\)</span>发生的信息量为： <span class="math display">\[I(x_i)=-\log p(x_i)\]</span> 可见：小概率事件包含的不确定性大，所以它带来的信息量也大。</p><p>信息量所用的单位随着对数的底变化而变化，常用的有：</p><table><thead><tr class="header"><th>底数</th><th>单位</th></tr></thead><tbody><tr class="odd"><td>2</td><td>比特(bit)</td></tr><tr class="even"><td>e</td><td>奈特(nat)</td></tr><tr class="odd"><td>10</td><td>哈特(hat)</td></tr></tbody></table><p>需要说明的是，信息量本身是纯数，没有量纲。这里的“单位”只是为了表示不同底的对数值。</p><p>二维联合总体<span class="math inline">\(XY\)</span>上的元素的信息量为： <span class="math display">\[I(x_iy_i)=-\log p(x_iy_i)\]</span> 在二维联合总体中，事件<span class="math inline">\(x_i\)</span>在事件<span class="math inline">\(y_i\)</span>给定的条件下的条件自信息量为： <span class="math display">\[I(x_i\mid y_j)=-\log p(x_i\mid y_j)=-\log \frac {p(x_iy_j)}{p(y_j)}\]</span></p><h4 id="互信息量">互信息量</h4><p>对于一个信息传输系统来说，如果信道中没有干扰，那么信源发出信号<span class="math inline">\(x_i\)</span>以后，信宿一定可以准确地收到消息，此时获得的信息量就是<span class="math inline">\(x_i\)</span>的不确定度<span class="math inline">\(I(x_i)\)</span>，即信源发出的<span class="math inline">\(x_i\)</span>所含有的全部信息。但是实际上信道不可能没有干扰，这时候<span class="math inline">\(x_i\)</span>通过信道会产生污染，信宿收到的消息<span class="math inline">\(y_i\)</span>将不同于<span class="math inline">\(x_i\)</span>，只能通过条件概率<span class="math inline">\(p(x_i\mid y_i)\)</span>推测信源发出<span class="math inline">\(x_i\)</span>的概率。</p><p>对于两个离散随机总体<span class="math inline">\(XY\)</span>，事件<span class="math inline">\(y_j\)</span>的出现给出关于事件<span class="math inline">\(x_i\)</span>的信息量定义为互信息量，为： <span class="math display">\[I(x_i;y_j)=\log\frac{P(x_i\mid y_j)}{p(x_i)}=I(x_i)-I(x_i\mid y_j)\]</span> 意思是，互信息量是一种不确定性的度量，等于先验的不确定性减去尚存在的不确定性。</p><p>互信息量有以下性质：</p><ol type="1"><li><p>互易性： <span class="math display">\[I(x_i;y_j)=I(y_j;x_i)\]</span></p></li><li><p>可以为0：当<span class="math inline">\(x_i,y_j\)</span>相互独立时，互信息量为零</p></li><li><p>可正可负：正值意味着事件<span class="math inline">\(y_j\)</span>的出现有助于肯定事件<span class="math inline">\(x_i\)</span>的出现，反之则是不利。</p></li><li><p>任何两个事件之间的互信息量不大于其中任意一个事件的自信息量</p></li></ol><p>在联合总体<span class="math inline">\(XYZ\)</span>中，给定<span class="math inline">\(z_k\)</span>的条件下，<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_j\)</span>的互信息量叫做条件互信息量，即： <span class="math display">\[I(x_i;y_j\mid z_k)=\log \frac{p(x_i\mid y_jz_k)}{p(x_i\mid z_k)}\]</span> 在上述联合总体上，还有<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_jz_k\)</span>之间的互信息量，有： <span class="math display">\[I(x_i;y_jz_k)=I(x_i;y_j)+I(x_i;z_k\mid y_j)\]</span> 意思是：<span class="math inline">\(y_jz_k\)</span>同时出现提供的有关<span class="math inline">\(x_i\)</span>的信息量等于<span class="math inline">\(y_j\)</span>提供的信息量和给定<span class="math inline">\(y_j\)</span>的条件下，<span class="math inline">\(z_k\)</span>提供的信息量之和。</p><h4 id="离散集总体的平均自信息量">离散集（总体）的平均自信息量</h4><p>之前讨论的自信息量都是对于一个事件<span class="math inline">\(x_i\)</span>来说的。为了讨论整个<span class="math inline">\(X\)</span>总体，需要定义平均自信息量： <span class="math display">\[H(X)=E[I(x_i)]=-\sum_{i=1}^n p(x_i)\log p(x_i)\]</span> 平均自信息量也叫做总体<span class="math inline">\(X\)</span>的<strong>信息熵</strong>。因为信息熵仅仅是总体的概率分布的函数，所以又可以记作： <span class="math display">\[H(X)=H(\mathbf P)=H(p_1,p_2,\cdots,p_n)=-\sum_{i=1}^n p_i\log p_i\]</span> 其中<span class="math inline">\(\sum_{i=1}^np_i=1\)</span>，所以它实际上是一个<span class="math inline">\(n-1\)</span>元函数。</p><p>在联合集<span class="math inline">\(XY\)</span>上，条件自信息量<span class="math inline">\(I(y\mid x)\)</span>的概率的加权平均值定义为条件熵，即： <span class="math display">\[H(Y\mid X)=\sum_{xy}p(x_i,y_j)I(y_j\mid x_i)\]</span> 对于条件熵，有： <span class="math display">\[\begin{aligned}&amp; H(Y \mid X) \leq H(Y) \\&amp; H(X \mid Y) \leq H(X)\end{aligned}\]</span> 在联合集<span class="math inline">\(XY\)</span>上，每对元素的自信息量的概率加权平均值定义为联合熵，即： <span class="math display">\[H(X,Y)=\sum_{xy}p(x_iy_j)I(x_i,y_j)\]</span> 对于联合熵，有： <span class="math display">\[H(X,Y)\leq H(X)+H(Y)\]</span> 当X和Y统计独立时，取得等号。</p><p>熵函数有以下特征：</p><ol type="1"><li><p>对称性：指无论如何改变概率矢量<span class="math inline">\(\mathbf P\)</span>中的元素排列顺序，<span class="math inline">\(H(\mathbf P)\)</span>保持不变</p></li><li><p>非负性：<span class="math inline">\(H(X)\geq 0\)</span>，当且仅当<span class="math inline">\(\mathbf P\)</span>中有且只有一个<span class="math inline">\(1\)</span>，其它全是<span class="math inline">\(0\)</span></p></li><li><p>扩展性： <span class="math display">\[\lim _{\epsilon \to 0}H_{n+1}(p_1,\cdots,p_n,\epsilon)=H_{n}(p_1,\cdots,p_n)\]</span> 意思是：一个事件的概率同总体中其它事件相比极小时，它对于总体熵的贡献可以忽略不计。</p></li><li><p>可加性： <span class="math display">\[H(X,Y)=H(X)+H(Y\mid X)=H(Y)+H(X\mid Y)\]</span></p></li><li><p>极值性 <span class="math display">\[H(\mathbf P)\leq H(\frac 1n,\cdots,\frac 1n)=\log n\]</span></p></li><li><p>上凸性：<span class="math inline">\(H(\mathbf P)\)</span>是<span class="math inline">\(\mathbf P\)</span>的严格上凸函数，即：</p><p>对于两个概率矢量<span class="math inline">\(\mathbf{P,P&#39;}\)</span>，有： <span class="math display">\[\forall \alpha \in (0,1),H[\alpha \mathbf P+(1-\alpha)\mathbf P&#39;]&gt;\alpha H(\mathbf P)+(1-\alpha)H(\mathbf P&#39;)\]</span></p></li></ol><h4 id="离散集的平均互信息量">离散集的平均互信息量</h4><p>在联合集<span class="math inline">\(XY\)</span>上，由<span class="math inline">\(y_j\)</span>提供的关于集<span class="math inline">\(X\)</span>的<strong>平均条件互信息量</strong>是由<span class="math inline">\(y_j\)</span>提供的关于元素<span class="math inline">\(x_i\)</span>的互信息量<span class="math inline">\(I(x_i;y_j)\)</span>的加权平均，即： <span class="math display">\[I(X;y_j)=\sum_{x_i\in X}p(x_i\mid y_j)I(x_i;y_j)\]</span> 平均条件互信息量在<span class="math inline">\(Y\)</span>上的加权平均是两个总体的<strong>平均互信息量</strong>，即： <span class="math display">\[I(X;Y)=\sum_{y_j\in Y}p(y_j)I(X;y_j)\]</span> 平均互信息量非负、互易，而且和通信熵具有如下的关系：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304152136046.png" alt="image-20230415213620301" /><figcaption aria-hidden="true">image-20230415213620301</figcaption></figure><h2 id="离散信源">离散信源</h2><h3 id="离散无记忆信源">离散无记忆信源</h3><p>离散无记忆信源可以用下面的概率分布描述： <span class="math display">\[\left[\begin{array}{l}X \\P\end{array}\right]=\left[\begin{array}{cccc}\alpha_1 &amp; \alpha_2 &amp; \cdots &amp; \alpha_q \\p\left(x_1\right) &amp; p\left(x_2\right) &amp; \cdots &amp; p\left(x_q\right)\end{array}\right]\]</span> 其<span class="math inline">\(N\)</span>次扩展信源<span class="math inline">\(X^N\)</span>是具有<span class="math inline">\(q^N\)</span>个符号的离散无记忆信源，为： <span class="math display">\[\left[\begin{array}{c}X^N \\p\end{array}\right]=\left[\begin{array}{cccc}\alpha_1 &amp; \alpha_2 &amp; \cdots &amp; \alpha_{q^N} \\p\left(\alpha_1\right) &amp; p\left(\alpha_2\right) &amp; \cdots &amp; p\left(\alpha_{q^N}\right)\end{array}\right]\]</span> <span class="math inline">\(N\)</span>次扩展信源的熵为原信源的<span class="math inline">\(N\)</span>倍，即： <span class="math display">\[H(X^N)=NH(X)\]</span></p><h3 id="离散平稳信源">离散平稳信源</h3><p>如果一个信源产生的随机序列<span class="math inline">\(X_i,i=1,2,\cdots\)</span>满足：</p><ol type="1"><li><p>所有<span class="math inline">\(x_i\)</span>都取值于有限的信源符号集合<span class="math inline">\(A=\{a_1,a_2\cdots,a_q\}\)</span></p></li><li><p>对所有的非负整数<span class="math inline">\(N,i_1,i_2,\cdots,i_N,h\)</span>，对所有的<span class="math inline">\(x_1,x_2,\cdots\in A\)</span>，有： <span class="math display">\[P(X_{i_1}=x_1,\dots,X_{i_N}=x_n)=P(X_{i_1+h}=x_1,\cdots,X_{i_N+h}=x_n)\]</span></p></li></ol><p>也就是说，这个信源发出的符号序列的概率分布和时间起点无关，那么这个信源称为离散平稳信源。</p><p>如果有 <span class="math display">\[P(X_i=x)=P(X_j=x)\]</span> 即任意时刻信源发出单个符号的概率相同，那么叫做“一维平稳信源”；如果随机序列的二维联合分布也和时间起点无关，称为二维平稳信源。如果对任意正整数<span class="math inline">\(N\)</span>，其联合分布都和时间起点无关，称为完全平稳信源，简称为平稳信源。</p>对二维平稳信源来说，有联合熵： <span class="math display">\[H(\mathbf{X})=H\left(X_1 X_2\right)=-\sum_{i=1}^q \sum_{j=1}^q p\left(a_i a_j\right) \log p\left(a_i a_j\right)\]</span> 条件熵： <span class="math display">\[H\left(X_2 \mid X_1\right)=-\sum_{i=1}^q \sum_{j=1}^q p\left(a_i a_j\right) \log p\left(a_j \mid a_i\right)\]</span> 因为 <span class="math display">\[p(a_ia_j)=p(a_j|a_i)p(a_i)\]</span> 所以 $$<span class="math display">\[\begin{aligned}H(X_1,X_2)&amp; =-\sum_{i=1}^q\left[\sum_{j=1}^q p\left(a_i a_j\right) \right] \log p\left(a_i\right)-\sum_{i=1}^q\sum_{j=1}^q p\left(a_i, a_j\right) \log p\left(a_j \mid a_j\right) \\&amp; =-\sum_{i=1}^q p\left(a_i\right) \log p\left(a_i\right)-H(X_1|X_2)\\&amp; =H(X_1)-H(X_1|X_2)\\\end{aligned}\]</span><p>$$ 即：联合熵＝前一个符号的信息熵＋前一个符号已知时信源发出下一个符号的条件熵。</p><p>对于平稳有记忆N次扩展信源，有平均符号熵： <span class="math display">\[H_N(X) \stackrel{\text { def }}{=} \frac{1}{N} H\left(X^N\right)=\frac{1}{N} H\left(X_1, X_2, \cdots X_N\right)\]</span> 当信源符号序列长度趋于无穷时，有极限熵： <span class="math display">\[H_{\infty}(X) \stackrel{\text { def }}{=} \lim _{N \rightarrow \infty} H_N(X)=\lim _{N \rightarrow \infty} \frac{1}{N} H\left(X^N\right)\]</span> N次扩展信源熵的性质有：</p><ol type="1"><li>条件熵<span class="math inline">\(H\left(X_N \mid X_1 X_2 \cdots X_{N-1}\right)\)</span>随<span class="math inline">\(N\)</span>增加非递增</li><li>平均符号熵<span class="math inline">\(H_N(X)\)</span>随<span class="math inline">\(N\)</span>增加非递增</li><li>极限熵存在，且<span class="math inline">\(H_\infty(X)=\lim _{N \rightarrow \infty} H\left(X_N \mid X_1 X_2 \cdots X_{N-1}\right)\)</span></li><li><span class="math inline">\(H_N(X) \geq H\left(X_N \mid X_1 X_2 \cdots X_{N-1}\right)\)</span></li></ol><h3 id="马尔可夫信源">马尔可夫信源</h3><p>如果系统在时刻<span class="math inline">\(n-1\)</span>处于状态<span class="math inline">\(S_{i_{n-1}}\)</span>，那么将来时刻<span class="math inline">\(n\)</span>的状态<span class="math inline">\(S_n\)</span>和过去的<span class="math inline">\(1,2,3,\cdots,n-2\)</span>都无关，只和现在时刻<span class="math inline">\(n-1\)</span>的状态有关，这样的特性叫做马尔可夫特性，这样的系统叫做马尔可夫链（有限状态一阶马尔可夫链），用数学语言描述，就是： <span class="math display">\[\begin{aligned}&amp; P\left(X_n=S_{i_n} \mid X_{n-1}=S_{i_{n-1}}, X_{n-2}=S_{i_{n-2}}, \cdots, X_1=S_{i_1}\right) \\= &amp; P\left(X_n=S_{i_n} \mid X_{n-1}=S_{i_{n-1}}\right)\end{aligned}\]</span> 引入转移概率： <span class="math display">\[P_{ij}(m,n)\]</span> 意思是已知时刻<span class="math inline">\(m\)</span>系统处于状态<span class="math inline">\(S_i\)</span>，经过<span class="math inline">\(n-m\)</span>步后系统转移到状态<span class="math inline">\(S_j\)</span>的概率。在有限状态一阶马尔可夫链中，我们主要关注<span class="math inline">\(P_{ij}(m,m+1)\)</span>，简记为<span class="math inline">\(P_{ij}(m)\)</span>，即： <span class="math display">\[p_{i j}(m)=P\left(X_{m+1}=S_j \mid X_m=S_i\right)\]</span> 类似地，定义<span class="math inline">\(k\)</span>步转移概率为<span class="math inline">\(P_{ij}^{(k)}(m)=P_{ij}(m,m+k)\)</span>。</p><p>因为系统在任意时刻都可能处于任意状态，所以一般用状态转移矩阵来描述，<span class="math inline">\(m\)</span>时刻的<span class="math inline">\(k\)</span>步转移矩阵定义为： <span class="math display">\[\mathbf P^{(k)}(m)=\{p_{ij}^{(k)}(m),i,j\in S\}\]</span> 如果在马尔科夫链中，<span class="math inline">\(p_{ij}(m)=p_{ij}\)</span>，即转移概率和<span class="math inline">\(m\)</span>无关，那么称之为<strong>齐次马尔可夫链</strong>,也叫遍历的马尔可夫链。齐次马尔科夫链的转移矩阵可以表示为： <span class="math display">\[\mathbf{P}=\left[\begin{array}{cccc}p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1 j} \\p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2 j} \\\vdots &amp; \vdots &amp; &amp; \vdots \\p_{j 1} &amp; p_{j 2} &amp; \cdots &amp; p_{jj}\end{array}\right]\]</span> 且有C-K方程： <span class="math display">\[\mathbf{P}^{(n+m)}=\mathbf{P}^{(n)} \cdot \mathbf{P}^{(m)}\]</span> 若齐次马尔可夫链对一切<span class="math inline">\(i,j\)</span>存在不依赖于<span class="math inline">\(i\)</span>的极限： <span class="math display">\[\lim _{n \rightarrow \infty} p_{i j}^{(n)}=p_j\]</span> 且满足：</p><ol type="1"><li><p><span class="math display">\[p_j\geq 0\]</span></p></li><li><p><span class="math display">\[p_j=\sum_{i=1}^\infty p_ip_{ij}\]</span></p></li><li><p><span class="math display">\[\sum_j p_j=1\]</span></p></li></ol><p>那么称其有平稳性，<span class="math inline">\(p_j\)</span>称为平稳分布，其中<span class="math inline">\(p_i\)</span>是马尔科夫链的初始分布。意思是，无论系统从哪个状态出发，当转移的步数足够多时，转移到特定状态的概率都近似等于一个常数。稳态分布存在的充要条件是：存在一个正整数<span class="math inline">\(N\)</span>，使得<span class="math inline">\(P^N\)</span>中的所有元素都大于零。</p><p>如果稳态分布存在，那么可以设稳态分布矢量<span class="math inline">\(\mathbf W=[w_1,w_2,\cdots,w_n]\)</span>，其中<span class="math inline">\(w_j\)</span>表示稳态分布中的<span class="math inline">\(p_j\)</span>，通过解方程 <span class="math display">\[\mathbf{W=WP}\]</span> 可以求解稳态分布，且稳态分布具有唯一性。</p><p>具有<span class="math inline">\(m\)</span>阶马尔可夫特性（即下一个时刻输出的符号仅和前<span class="math inline">\(m\)</span>个符号有关，和更前的符号无关）的信源称为<span class="math inline">\(m\)</span>阶马尔可夫信源。遍历的<span class="math inline">\(m\)</span>阶马尔可夫信源的极限熵为其<span class="math inline">\(m\)</span>阶条件熵，即： <span class="math display">\[H_\infty=H_{m+1}=H\left(X_{m+1} \mid X_1 X_2 \cdots X_m\right)\]</span></p><h3 id="相关性和冗余度">相关性和冗余度</h3><p>信源输出符号间的依赖关系越强，信源熵就会减小。这就是信源的相关性。当信源输出符号间的相关程度越长，信源的实际熵越小，趋于极限熵；当信源输出符号之间不存在相互依存关系且为等概分布，信源实际熵趋于最大熵<span class="math inline">\(H_0=\log q\)</span>，其中<span class="math inline">\(q\)</span>是信源输出符号集的符号数目。定义信源剩余度： <span class="math display">\[R=1-\frac{H_{\infty}}{H_0}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理· 调制之章</title>
    <link href="/2023/05/16/%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/"/>
    <url>/2023/05/16/%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="模拟调制">模拟调制</h2><p>调制是对信源（编码）产生的信号进行符号映射、频谱搬移、滤波等处理，以适配信道传输的过程。其意义在于便于设计小型发射机和提高无线资源的利用率。调制的基本框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304242218773.png" alt="调制" /><figcaption aria-hidden="true">调制</figcaption></figure><p>其中<span class="math inline">\(m(t)\)</span>是要传输的信号，叫做调制信号或基带信号，<span class="math inline">\(c(t)\)</span>是载波信号，<span class="math inline">\(s(t)\)</span>是已调信号。其基本方程为： <span class="math display">\[c(t)=A\cos(\omega_c t+\theta_c)\]</span> 如果基带信号<span class="math inline">\(m(t)\)</span>加在幅度<span class="math inline">\(A\)</span>上，叫做调幅；如果基带信号<span class="math inline">\(m(t)\)</span>加在频率<span class="math inline">\(\omega_c\)</span>上，叫做调频；如果基带信号<span class="math inline">\(m(t)\)</span>加在相位<span class="math inline">\(\theta_c\)</span>，叫做调相。</p><p>当<span class="math inline">\(s(t)\)</span>和<span class="math inline">\(m(t)\)</span>有线性关系时，叫做线性调制，例如调幅；当是非线性关系时，叫做非线性调制，例如调频或者调相。</p><h3 id="带通信号">带通信号</h3><p>在分析模拟调制之前，我们首先来分析一下带通信号。带通信号也叫窄带信号，是指频谱集中在某个载频<span class="math inline">\(f_c\)</span>附近的信号。本章提到的带通信号如无特别说明，一般指实信号，其频谱满足共轭对称性：<span class="math inline">\(X(f)=X^*(-f)\)</span>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305072217995.png" alt="带通信号" /><figcaption aria-hidden="true">带通信号</figcaption></figure><p>定义带通信号<span class="math inline">\(s(t)\)</span>的“解析信号”<span class="math inline">\(z(t)\)</span>为： <span class="math display">\[z(t)=s(t)+j\hat s(t)\]</span> 其中<span class="math inline">\(\hat s(t)\)</span>是<span class="math inline">\(s(t)\)</span>的希尔伯特变换，具体来说： <span class="math display">\[\hat s(t)=s(t)\bigotimes \frac {1}{\pi t}=\frac 1\pi \int_{-\infty}^\infty x(\tau)\frac {1}{t-\tau}\mathbf d t\]</span> 希尔伯特变换是一个<span class="math inline">\(90\degree\)</span>移相器，它把输入的实信号中的每一个频率分量按照各自的周期延迟<span class="math inline">\(1/4\)</span>周期。信号经过希尔伯特变换后功率谱密度不变，功率不变，自相关函数不变。其传递函数如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305072223694.png" alt="希尔伯特变换传递函数" /><figcaption aria-hidden="true">希尔伯特变换传递函数</figcaption></figure><p>那么考察<span class="math inline">\(z(t)\)</span>和<span class="math inline">\(s(t)\)</span>的频域，我们可以发现： <span class="math display">\[Z(f)= \begin{cases}2 S(f), &amp; f&gt;0 \\ 0, &amp; f&lt;0\end{cases}\]</span> 即其频谱为<span class="math inline">\(s(t)\)</span>的正频率的部分乘以二：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305072225260.png" alt="解析信号的频谱" /><figcaption aria-hidden="true">解析信号的频谱</figcaption></figure><p>设 <span class="math inline">\(f_{\mathrm{c}}&gt;0\)</span> 是任意一个落在实带通信号 <span class="math inline">\(s(t)\)</span> 频带内或者附近的频率值 ， 假设 <span class="math inline">\(s(t)\)</span> 的最高频率不超过 <span class="math inline">\(2 f_{\mathrm{c}}\)</span>, 也就是说, <span class="math inline">\(s(t)\)</span> 的傅里叶变换 <span class="math inline">\(S(f)\)</span> 在 <span class="math inline">\(f&lt;-2 f_{\mathrm{c}}\)</span> 以及 <span class="math inline">\(f&gt;2 f_c\)</span> 处为零。令 <span class="math inline">\(\phi\)</span> 是任意固定的相位, 则 <span class="math inline">\(s(t)\)</span> 的<strong>复包络</strong>定义为： <span class="math display">\[s_{\mathrm{L}}(t)=[s(t)+\mathrm{j} \hat{s}(t)] \mathrm{e}^{-\mathrm{j}\left(2 \pi f_{\mathrm{c}} t+\phi\right)}\]</span> 称上面式子的指数项为“参考复载波”。复包络和解析信号都是复信号。其功率谱和原信号的关系为： <span class="math display">\[P_{s_{\mathrm{L}}}(f)=P_z\left(f+f_{\mathrm{c}}\right)= \begin{cases}4 P_s\left(f+f_{\mathrm{c}}\right), &amp; |f| \leqslant f_{\mathrm{c}} \\ 0, &amp; |f|&gt;f_{\mathrm{c}}\end{cases}\]</span> 定义<span class="math inline">\(s_{I}(t)=Re\{s_L(t)\},s_Q(t)=Im\{s_L(t)\}\)</span>，则<span class="math inline">\(s(t)\)</span>可以表示为： <span class="math display">\[s(t)=s_I(t) \cos \left(2 \pi f_{\mathrm{c}} t+\phi\right)-s_Q(t) \sin \left(2 \pi f_{\mathrm{c}} t+\phi\right)\]</span> 如果把复数<span class="math inline">\(s_L\)</span>以极坐标方式表示： <span class="math display">\[\begin{gathered}A(t)=\left|s_{\mathrm{L}}(t)\right|=\sqrt{s_1^2(t)+s_Q^2(t)} \\\varphi(t)=\angle s_{\mathrm{L}}(t)=\arctan \frac{s_{\mathrm{Q}}(t)}{s_1(t)}\end{gathered}\]</span> 可以得到带通信号的三种表示方法： <span class="math display">\[\begin{aligned}s(t) &amp; =\operatorname{Re}\left\{s_{\mathrm{L}}(t) \mathrm{e}^{j\left(2 \pi j_e t+\phi\right)}\right\} \\&amp; =A(t) \cos \left[2 \pi f_{\mathrm{c}} t+\phi+\varphi(t)\right] \\&amp; =s_1(t) \cos \left(2 \pi f_{\mathrm{c}} t+\phi\right)-s_0(t) \sin \left(2 \pi f_{\mathrm{c}} t+\phi\right)\end{aligned}\]</span> 给定参考载波 <span class="math inline">\(\cos \left(2 \pi f_c t+\phi\right)\)</span> 时, 从带通信号 <span class="math inline">\(s(t)\)</span> 能唯一确定复包络 <span class="math inline">\(s_{\mathrm{L}}(t)\)</span>, 从复包络 <span class="math inline">\(s_{\mathrm{L}}(t)\)</span> 也 能唯一确定带通信号 <span class="math inline">\(s(t)\)</span> 。带通信号由复包络和参考载波共同决定, 参考载波决定带通信号的 频谱位置, 带通信号的其余信息都包含在复包络中。复包络是一个基带信号, 便于进行数学分析以及计算机仿真。</p><h3 id="模拟线性调制">模拟线性调制</h3><h4 id="常规双边带调幅am">常规双边带调幅AM</h4><p>AM的基本公式为： <span class="math display">\[c(t)=[A_0+m(t)]\cos \omega_c t\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021549898.png" alt="AM调制示意图" style="zoom:50%;" /></p><p>其中<span class="math inline">\(m(t)\)</span>的范围是<span class="math inline">\([-A_m,A_m]\)</span>，那么调幅系数定义为： <span class="math display">\[\beta=\frac {A_m} {A_0}\]</span> 其频谱为： <span class="math display">\[S_{AM}(f)=\frac 12\left(M(f+f_c)+M(f-f_c)\right)\]</span> AM信号的频谱和基带信号<span class="math inline">\(A_0+m(t)\)</span>的频谱的关系如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021549264.png" alt="image-20230502154705675" /><figcaption aria-hidden="true">image-20230502154705675</figcaption></figure><p><strong>可见：AM信号的频谱由载频分量和上下两个边带组成。上边带的频谱结构和原调制信号相同，下边带是上边带的镜像。</strong>如果说基带信号的带宽为<span class="math inline">\(B_b=f_H\)</span>，那么AM信号的带宽为<span class="math inline">\(2f_H=2B_b\)</span>.</p><p>AM信号的解调方法有两种，即包络检波法和相干解调法。相干解调法的框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021608521.png" alt="相干解调" /><figcaption aria-hidden="true">相干解调</figcaption></figure><p>其频谱变化过程示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021608073.png" alt="相干解调频谱" /><figcaption aria-hidden="true">相干解调频谱</figcaption></figure><p>AM调制的功率利用率比较低，而且占用频带较宽。为了解决这个问题，可以采用抑制载波双边带调制（DSB）</p><h4 id="双边带调制dsb">双边带调制DSB</h4><p>抑制载波双边带调制（DSB-SC）简称双边带调制（DSB）。其基本公式为： <span class="math display">\[s_{DSB}(t)=m(t)\cos \omega_c t\]</span> DSB信号的包络不再与调制信号的变化规律一致，因此包络检波法不再可用，只能使用相干解调法。相干解调法和AM基本相同，只是不需要隔直。有： <span class="math display">\[m(t)\cos \omega_c t\cdot\cos \omega_c t=\frac 12m(t)(1+\cos 2\omega_c t)\]</span> 因此通过低通滤波器后，有： <span class="math display">\[m_o(t)=\frac 12 m(t)\]</span> 虽然DSB节省了载波频率，提高了功率利用率，但是频带宽度仍然是调制信号带宽的2倍，与AM的相同。</p><h4 id="单边带调制ssb">单边带调制SSB</h4><p>单边带调制就是将DSB信号的频谱上只保留一个边带：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021644115.png" alt="单边带调制" /><figcaption aria-hidden="true">单边带调制</figcaption></figure><p>保留红色的叫上边带（USB），保留蓝色的叫下边带（LSB）。</p><p>单边带调制信号可以用DSB信号通过一个低通（高通）滤波器来生成，也可以通过移相法实现： <span class="math display">\[s_{LSB}(t)=\frac 12\left(m(t)\cos \omega_c t+\hat m(t)\sin \omega_c(t)\right)\]</span> 其中<span class="math inline">\(\hat m(t)\)</span>是<span class="math inline">\(m(t)\)</span>的希尔伯特变换。证明可以直接对比左右两式的频域表达式。</p><p>SSB信号的解调，可以采用相干解调，如果一定要采取包络检波，则要插入强载波。</p><h4 id="残留边带调制vsb">残留边带调制VSB</h4><p>SSB调制对滤波器的要求有点过高了。在残留边带调制中，除了传送一个边带外，还保留了另外一个边带的一部分。对于具有低频及直流分量的调制信号，用滤波法实现单边带调制时所需要的过渡带无限陡的理想滤波器，在残留边带调制中已不再需要。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305022044405.png" alt="VSB频谱" /><figcaption aria-hidden="true">VSB频谱</figcaption></figure><p>其对滤波器传递函数的要求为： <span class="math display">\[H(f+f_c)+H(f-f_c)=C\]</span> 即<span class="math inline">\(H(f)\)</span>在<span class="math inline">\(f_c\)</span>两侧互补对称。</p><h3 id="非线性调制角度调制">非线性调制（角度调制）</h3><h4 id="相位调制pm">相位调制PM</h4><p>使相位随调制信号线性变化，即： <span class="math display">\[s_{PM}(t)=A\cos \left[\omega_ct+\varphi_0+K_{PM}m(t)\right]\]</span> 其中的<span class="math inline">\(K_{PM}\)</span>叫做调相灵敏度，瞬时相位为： <span class="math display">\[\varphi_0+K_{PM}m(t)\]</span> 瞬时相位偏移为 <span class="math display">\[K_{PM}m(t)\]</span> 其最大值定义为调相指数： <span class="math display">\[M_p=K_{PM}A_m\]</span></p><h4 id="频率调制fm">频率调制FM</h4><p>使瞬时频率随着调制信号线性变化，叫做频率调制。即： <span class="math display">\[\omega(t)=\omega_c +K_{FM}m(t)\]</span> 更进一步，调频的实质其实是让角度的导数和调制信号成正比，即瞬时频率偏移是调制信号的线性函数： <span class="math display">\[\frac d{dt}\varphi(t)=2\pi K_{FM}m(t)\]</span> 因此，调频的表达式为： <span class="math display">\[s_{FM}(t)=A\cos \left[\omega_ct+\varphi_0+K_{FM}\int _{-\infty}^tm(\tau)d\tau\right]\]</span> 其中<span class="math inline">\(m(t)\)</span>的范围是<span class="math inline">\([-A_m,A_m]\)</span>.</p><p>瞬时频率偏离<span class="math inline">\(f_c\)</span>的最大值叫做最大频偏，即： <span class="math display">\[\Delta f=\frac 1{2\pi}\left| \frac d{dt}\varphi(t)\right|_{max}=K_{FM}A_m\]</span> 最大频偏按消息信号的带宽<span class="math inline">\(W\)</span>归一化的值代表调频波的最大相对偏移，叫做调频指数： <span class="math display">\[M_f=\beta_{FM}=\frac{K_{FM}A_m}{W}\]</span> <span class="math inline">\(M_f\)</span>和<span class="math inline">\(\beta_{FM}\)</span>都是调频指数，是同一个事物的两个名字，我也不知道为什么会这样。</p><p>对于单频调制而言，假设调制信号为余弦波 <span class="math display">\[m(t)=A_m\cos \omega_m t\]</span> 调相，有： <span class="math display">\[s_{PM}(t)=A\cos(\omega_ct+K_{PM}A_m\cos \omega_mt)\]</span> 其中调相指数<span class="math inline">\(M_p=K_{PM}A_m\)</span>，就是相位部分的振幅值，代表最大相位偏移。</p><p>调频，有： <span class="math display">\[\begin{aligned}s_{F M}(t) &amp; =A \cos \left(\omega_c t+K_{F M} \int_{-\infty}^t A_m \cos \omega_m \tau d \tau\right) \\&amp; =A \cos \left(\omega_c t+\frac{K_{F M} A_m}{\omega_m} \sin \omega_m t\right) \\&amp; =A \cos \left(\omega_c t+M_f \sin \omega_m t\right)\end{aligned}\]</span> 其中 <span class="math display">\[M_f=\frac{K_{FM}A_m}{\omega_m}\]</span> 为调频知数，代表调频波的最大相对偏移。调频波的最大频率偏移为： <span class="math display">\[\Delta \omega_m=K_{FM}A_m=M_f\omega_m\]</span> 可以看出，最大频偏就是把表达式相位部分的幅值和角频率乘起来。</p><p>所以也可以说： <span class="math display">\[M_f=\frac{\Delta \omega_{m}}{\omega_m}\]</span> 即调频最大频偏/调制信号频率。请注意，上面这部分的频率都是角频率，也即<span class="math inline">\(\omega\)</span>，如果要算<span class="math inline">\(f\)</span>，需要除以<span class="math inline">\(2\pi\)</span></p><p>当<span class="math inline">\(A_m\)</span>不变，调制信号频率<span class="math inline">\(\omega_m\)</span>增大时：</p><ul><li>FM中的<span class="math inline">\(\Delta f\)</span>不变，<span class="math inline">\(M_f\)</span>成反比例地减小</li><li>PM中的<span class="math inline">\(\Delta f\)</span>成正比例增大，<span class="math inline">\(M_p\)</span>不变</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305022146037.png" alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure><blockquote><p>【例】用基带信号对载波进行调频得到 <span class="math display">\[s(t)=10\cos(2\pi f_ct+5\cos 200\pi t)\]</span></p><ol type="1"><li>求最大频偏、调频指数、带宽</li><li>固定<span class="math inline">\(K_{FM},f_m\)</span>，把<span class="math inline">\(A_m\)</span>提高一倍，求（1）</li><li>固定<span class="math inline">\(K_{FM},A_m\)</span>，把<span class="math inline">\(f_m\)</span>提高一倍，求（1）</li></ol><p>【解】</p><ol type="1"><li><p>最大频偏(相位部分表达式幅度乘以频率) <span class="math display">\[\Delta f_m=5\times 200\pi/2\pi=500\]</span> 调频指数(相位部分表达式的幅度) <span class="math display">\[M_f=\frac{\Delta f_m}{f_m}=5\]</span> 带宽 <span class="math display">\[B=2(\Delta f_m+f_m)=1200\]</span></p></li><li><p>调频指数 <span class="math display">\[M_f=\frac{K_{FM}A_m}{\omega_m}=10\]</span> 最大频偏 <span class="math display">\[\Delta f_m=1000\]</span> 带宽 <span class="math display">\[B=2(\Delta f_m+f_m)=2200\]</span></p></li><li><p>仍旧从调频指数定义式出发，有：<span class="math inline">\(\Delta f_m=500,M_f=2.5,B=1400\)</span></p></li></ol></blockquote><p>如果将调制信号先积分，而后进行调相，则得到的是调频波，这种方式叫间接调频。也就是说，PM和FM的区别其实就是更换了调制信号。下面，主要对FM进行讨论。</p><p>经过分析，可以知道已调信号的带宽实际上是无穷，但是其能量主要集中在<span class="math inline">\(f_c\)</span>附近的一个范围内。其频带宽度可以大致用卡森公式估计： <span class="math display">\[B_{FM}=2(1+M_f)f_m=2(\Delta f+f_m)\]</span></p><blockquote><p>【例】2MHz载波受10KHz单频正弦调频，峰值频偏为10KHz，求：</p><ol type="1"><li>调频信号带宽</li><li>调制信号幅度加倍时，调频信号的带宽</li><li>调制信号频率加倍时，调频信号的带宽</li><li>如果峰值频偏减为1KHz，分别计算123</li></ol><p>【解】由卡森公式：<span class="math inline">\(B_{FM}=2(1+M_f)f_m=2(\Delta f+f_m)\)</span>，调频指数：<span class="math inline">\(M_f=AK_{fm}/\omega_m=\Delta f_{\max}/f_m\)</span></p><ol type="1"><li><span class="math inline">\(M_f=\Delta f_{\max}/f_m=10k/10k=1\)</span>，则<span class="math inline">\(B_{fm}=2\times (1+1)\times 10=40\text {kHz}\)</span></li><li>幅度加倍，则最大频偏加倍，则<span class="math inline">\(M_f\)</span>加倍，<span class="math inline">\(B_{fm}=2\times (2+1)\times 10=60\text{kHz}\)</span></li><li>频率加倍，则<span class="math inline">\(B_{fm}=2(20+10)=60\text{kHz}\)</span></li><li>则<span class="math inline">\(\Delta f_m=1kHz\)</span>，对（1）有：<span class="math inline">\(B_{fm}=2\times (0.1+1)\times 10=22\text{kHz}\)</span>，其余略</li></ol></blockquote><p>要进行调频，有直接法和倍频法。直接法又叫VCO调频，就是用调制信号直接控制压控振荡器的频率，使其按调制信号的规律线性变化。其缺点是载频<span class="math inline">\(f_c\)</span>可能会产生漂移。</p><p>倍频法是先对调制信号积分后再进行相位调制，从而产生窄带调频信号，然后利用倍频器把它变成宽带调频信号。</p><h3 id="模拟调制的噪声分析">模拟调制的噪声分析</h3><p>在分析噪声时，认为噪声是加性<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="叠加在信号上的噪声。与此相对，乘性噪声是乘在信号上的。">[1]</span></a></sup>各态历经<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="各态历经的意思是统计平均等于时间平均，$E[x(t)]=\bar x(t)$​。直观理解就是“一次性投100枚硬币”和“把一枚硬币投100次”是等效的。">[2]</span></a></sup>平稳<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="平稳的意思是概率密度函数和时间无关">[3]</span></a></sup>高斯<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="高斯的意思是概率密度分布是高斯分布">[4]</span></a></sup>白<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="白噪声的意思是功率谱是常数">[5]</span></a></sup>噪声。</p><table><thead><tr class="header"><th>调制方式</th><th>通带</th><th><span class="math inline">\(S_i/N_i\)</span></th><th><span class="math inline">\(S_o/N_o\)</span></th><th><span class="math inline">\(G_m\)</span></th><th>复杂度</th></tr></thead><tbody><tr class="odd"><td>DSB</td><td><span class="math inline">\(2f_m\)</span></td><td><span class="math inline">\(\frac{P_m/2}{2f_mn_0}\)</span></td><td><span class="math inline">\(\frac{P_m}{2f_mn_0}\)</span></td><td>2</td><td>中</td></tr><tr class="even"><td>SSB</td><td><span class="math inline">\(f_m\)</span></td><td><span class="math inline">\(\frac{P_m/4}{f_mn_0}\)</span></td><td><span class="math inline">\(\frac{P_m}{4f_mn_0}\)</span></td><td>1</td><td>难</td></tr><tr class="odd"><td>VSB</td><td>略大于<span class="math inline">\(f_m\)</span></td><td>同上</td><td>同上</td><td>同上</td><td>难</td></tr><tr class="even"><td>AM</td><td><span class="math inline">\(2f_m\)</span></td><td><span class="math inline">\(\frac{(A^2+P_m)/2}{2f_mn_0}\)</span></td><td><span class="math inline">\(P_m/2f_mn_0\)</span></td><td><span class="math inline">\(2\eta_{AM}\)</span></td><td>易</td></tr><tr class="odd"><td>FM</td><td><span class="math inline">\(2(M_f+1)f_m\)</span></td><td><span class="math inline">\(\frac{A^2}{2B_{FM}n_0}\)</span></td><td><span class="math inline">\(3M_f^2\frac{P_mA^2/2}{A_m^2n_0f_m}\)</span></td><td><span class="math inline">\(6\beta^2(1+\beta)\frac{P_m}{A_m^2}\)</span></td><td>中</td></tr></tbody></table><blockquote><p>【例（2022期末）】已知信号<span class="math inline">\(m(t)\)</span>是带宽为20kHz的低频信号，分别经过以下两种方式调制以后得到调制信号，调制信号经过信道传输，解调后输出。如果要求输出信号的信噪比为40dB，设信道传输损耗为50dB，信道引入的加性高斯白噪声双边功率谱密度<span class="math inline">\(n_0/2=10^-12 W/Hz\)</span>，求以下两种情况的最小发射功率。</p><ol type="1"><li>DSB-SC</li><li>AM，<span class="math inline">\(\eta=0.2\)</span></li></ol><p>【解】</p><ol type="1"><li><p>由题知，<span class="math inline">\(SNR_o=10^4,SNR_i=SNR_o/ G=2\times 10^3\)</span></p><p>先假设信道没有衰减，那么有 <span class="math display">\[P_s=SNR_i\cdot 2n_0f_m=2\cdot10^3\times 2\cdot 10^{-12}\times20k=4\times10^{-4}W\]</span> 加上信道衰减，发射功率为<span class="math inline">\(P_s\times 10^5=40W\)</span></p></li><li><p>由题知，<span class="math inline">\(SNR_o=10^4,SNR_i=SNR_o/G=SNR_o/(2\eta)=2.5\cdot 10^{4}\)</span></p><p>假设没有衰减，那么有 <span class="math display">\[P_s=SNR_i\cdot2n_0f_m=2\cdot 10^{-3}W\]</span> 加上信道衰减，发射功率为<span class="math inline">\(P_s\times 10^5=200W\)</span></p></li></ol></blockquote><p>在上面这个例子中，有些同学可能会有一个疑问，那就是dB不是<span class="math inline">\(20\lg(\cdot)\)</span>吗？为什么40dB是<span class="math inline">\(10^4\)</span>呢？实际上，因为这里是基于功率定义的dB。由于功率跟幅度的平方成正比，所以在基于幅度定义的dB的对数运算后前面又乘以2，变成了“20lg”。</p><blockquote><p>【例（2022期末）】对某一信号进行FM调制传输，设加到接收机的调制信号功率谱密度是 <span class="math display">\[P_m(f)=\left\{\begin{array}{cc}\frac{n_m}{2} \times \frac{|f|}{f_m} &amp; |f| \leq f_m \\0 &amp; |f|&gt;f_m\end{array}\right.\]</span> 其中<span class="math inline">\(f_m=5kHz,n_m=2V^2/Hz\)</span>。载波振幅100V，频率100MHz，<span class="math inline">\(k_f=500\pi\ rad/(s\cdot V)\)</span>，最大频偏<span class="math inline">\(\Delta f_{max}=75kHz\)</span>，噪声功率谱均匀，单边功率谱是<span class="math inline">\(p_n(f)=10^-3 W/Hz\)</span>，求</p><ol type="1"><li>调制信号带宽</li><li>解调器输入信噪功率比</li><li>系统的解调增益和输出信噪功率比</li></ol><p>【解】</p><ol type="1"><li><p>有卡森公式： <span class="math display">\[B=2(f_m+\Delta f)=2(5k+75k)=160 kHz\]</span></p></li><li><p>有：<span class="math inline">\(S_i=(A/\sqrt 2)^2=(100/\sqrt 2)^2=5000\)</span></p><p><span class="math inline">\(N_i=p_n\cdot W=10^{-3}\times 160k=160\)</span></p><p>所以<span class="math inline">\(SNR_i=31.25\)</span></p></li><li><p>由于 <span class="math display">\[G=6\beta_{fm}^2(\beta_{fm}+1)\frac{P_m}{A_m^2}\]</span> 其中<span class="math inline">\(\beta_{fm}=\Delta f/f_m=15\)</span> <span class="math display">\[P_m=2\int_{0}^{f_m}p_m(f)\mathbf df=\frac 12 f_mn_m=5000\]</span></p><p><span class="math display">\[A_m=\frac{\Delta f}{k_f}=\frac{75k}{250}=300\]</span></p><p>代入，有：<span class="math inline">\(G=1.2\cdot 10^{3}\)</span></p><p>所以 <span class="math display">\[SNR_o=SNR_i\times G=3.75\times 10^4\]</span></p></li></ol></blockquote><blockquote></blockquote><h2 id="模拟信号数字化">模拟信号数字化</h2><h3 id="采样">采样</h3><p>采样就是把时间上连续的模拟信号变成一系列时间上离散的采样值的过程。如果对一个频带有限的连续时间信号进行采样，当采样速率满足某些条件时，它的原信号就能由采样信号唯一地恢复出来，这是模拟信号数字化的理论依据。</p><h4 id="低通采样定理">低通采样定理</h4><p>一个频带限制在<span class="math inline">\((0,f_H)\)</span>范围内的连续时间信号<span class="math inline">\(m(t)\)</span>，如果以<span class="math inline">\(T_s\leq 1/(2f_H)\)</span>的时间间隔进行等间隔采样，则<span class="math inline">\(m(t)\)</span>被所得到的采样序列完全确定。换句话说，在信号最高频分量的一个周期内应该至少采样两次。</p><p>以下是对这个结论的简单证明：</p><p>假设采样脉冲为： <span class="math display">\[\delta_{T_s}(t)=\sum_{-\infty}^\infty\delta(t-nT_s)\]</span> 即一个周期为<span class="math inline">\(T_s\)</span>的冲激串。那么有： <span class="math display">\[\mathscr F[\delta_{T_s}(t)]=\frac {2\pi}{T_s}\sum_{n=-\infty}^\infty\delta(\omega-n\omega_s)=\frac{2\pi}{T_s}\delta_{\omega_s}(\omega)\]</span> 那么采样的过程是： <span class="math display">\[m_s(t)=m(t)\cdot \delta_{T_s}(t)\]</span> 因为时域相乘就是频域卷积，所以： <span class="math display">\[M(\omega)=\frac 1{2\pi}M(\omega)\bigotimes \delta_{T_S}(\omega)=\frac 1 {T_s}\sum_{n=-\infty}^\infty M(\omega-n\omega_s)\]</span> 那么就相当于把无数个间隔为<span class="math inline">\(\omega_s\)</span> 的 <span class="math inline">\(M(\omega)\)</span> 叠加而成：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122109921.png" alt="低通采样" /><figcaption aria-hidden="true">低通采样</figcaption></figure><p>那么对<span class="math inline">\(T_s\)</span>的限制条件就是显而易见的了。</p><h4 id="带通采样">带通采样</h4><p>一个带通信号<span class="math inline">\(m(t)\)</span>,其频率限制在<span class="math inline">\(f_L\)</span>与<span class="math inline">\(f_H\)</span>之间，带宽为<span class="math inline">\(B=f_L-f_H,\)</span>如果最小采样速率<span class="math inline">\(f=2f_H/m\)</span>,<span class="math inline">\(m\)</span>是一个不超过<span class="math inline">\(f_H/B\)</span>的最大整数，那么<span class="math inline">\(m(t)\)</span>可完全由其采样值确定。</p><h4 id="实际采样">实际采样</h4><p>前面两个理想采样用的采样函数都是冲激串，实际上当然不可能用冲激串，而是采用矩形串。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122147282.png" alt="矩形串" /><figcaption aria-hidden="true">矩形串</figcaption></figure><p>实际采样主要有两种。</p><p>其一是自然采样，意思是采样所得的每个“矩形”的顶都不是平顶，而是按照<span class="math inline">\(m(t)\)</span>的形状变化的。自然采样的波形和频谱如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122148557.png" alt="自然采样的波形和频谱" /><figcaption aria-hidden="true">自然采样的波形和频谱</figcaption></figure><p>自然采样和理想（低通）采样的不同之处是：理想采样的频谱被常数<span class="math inline">\(1/T_s\)</span>加权，因而信号带宽为无穷大；而自然采样频谱的包络按<span class="math inline">\(sinc\)</span>函数随频率增高而下降，带宽与脉宽<span class="math inline">\(\tau\)</span>有关。</p><p>其二是平顶采样，顾名思义和自然采样不同，这里的采样得到的每个“矩形”的顶都是平顶，如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122151229.png" alt="平顶采样示意图" /><figcaption aria-hidden="true">平顶采样示意图</figcaption></figure><p>其频谱不再是原信号频谱直接搬移，而是在搬移的同时，出现了失真，此种失真称为孔径失真。</p><h3 id="量化">量化</h3><p>在采样以后，虽然时间域上信号变成了离散的，但是从幅度上来说依然是连续的，也就是说幅度是多少都有可能，所以没办法之间数字化。为了数字化，需要对采样后的信号进行进一步的量化处理，也就是利用预先规定的有限个电平来表示模拟信号的采样值的过程。量化是从无穷多连续电平到有限个离散电平的不可逆映射过程，所以一定会产生失真。</p><p>一般来说，量化就是把<span class="math inline">\((x_k,x_{k+1}]\)</span>范围内的电平映射为<span class="math inline">\(y_k\)</span>的过程。其中<span class="math inline">\(x_k\)</span>叫做分层电平，<span class="math inline">\(y_k\)</span>叫做量化电平，<span class="math inline">\((x_k,x_{k+1}]\)</span>叫做量化区间，一个量化区间对应一个量化电平。用<span class="math inline">\(y=Q(x)\)</span>来表示采样电平<span class="math inline">\(x\)</span>经量化的结果为<span class="math inline">\(y\)</span>。</p><p>那么量化误差定义为： <span class="math display">\[q=x-Q(x)\]</span> 因为<span class="math inline">\(x\)</span>是随机变量，所以<span class="math inline">\(q\)</span>也是随机变量。一般用均方误差（平均功率）来衡量量化误差的大小： <span class="math display">\[\sigma_q^2=E[x-Q(x)]^2=\int_{-\infty}^\infty [x-Q(x)]^2p_x(x)dx\]</span> 即： <span class="math display">\[\sigma_q^2=\sum_{k=1}^L \int_{x_k}^{x_{k+1}}\left(x-y_k\right)^2 p_x(x) d x\]</span> 一般用量化信噪比来衡量量化器的性能，信噪比越大，性能越好： <span class="math display">\[SNR=S/\sigma_q^2\]</span></p><h4 id="均匀量化">均匀量化</h4><p>把输入信号的取值域按等间隔分割的量化称为均匀量化。在均匀量化中，每个量化区间的量化电平的取值在各区间的中点。如果量化范围为<span class="math inline">\([-V,V]\)</span>，量化层数为<span class="math inline">\(L\)</span>，那么：</p><ul><li><p>量化间隔为<span class="math inline">\(\Delta V=2V/L\)</span></p></li><li><p>分层电平为<span class="math inline">\(x_k=-V+(k-1)\Delta V\)</span></p></li><li><p>量化电平为<span class="math inline">\(y_k=-V+(k-1/2)\Delta V\)</span></p></li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122225164.png" alt="均匀量化示意图" /><figcaption aria-hidden="true">均匀量化示意图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122234010.png" alt="均匀量化误差示意图" /><figcaption aria-hidden="true">均匀量化误差示意图</figcaption></figure><p>如果忽略过载区，即假设输入信号是<span class="math inline">\([-V,V]\)</span>中的均匀分布，那么量化噪声功率为： <span class="math display">\[\sigma_q^2=\frac{\Delta V^2}{12}=\frac{V^2}{3 L^2}\]</span> 假设输入信号为正弦信号，幅度为<span class="math inline">\(A_m\leq V\)</span>，那么有：</p><ul><li><p>信号功率<span class="math inline">\(S=A_m^2/2\)</span></p></li><li><p>噪声功率<span class="math inline">\(\sigma_q^2=V^2/(3L^2)\)</span></p></li><li><p>信噪比 <span class="math display">\[S N R=\frac{S}{\sigma_q^2}=\frac{A_m^2 / 2}{V^2 /\left(3 L^2\right)}=\frac{3 A_m^2 L^2}{2 V^2}\]</span></p></li></ul><p>进一步，如果定义归一化有效值为<span class="math inline">\(D=A_m/(\sqrt 2 V)\)</span>，设量化间隔数<span class="math inline">\(L=2^n\)</span>称为<span class="math inline">\(n\)</span>比特量化，有：</p><ul><li><p>信噪比 <span class="math display">\[S N R=\frac{S}{\sigma_q^2}=\frac{3 A_m^2 L^2}{2 V^2}=3 D^2 L^2=3 D^2 2^{2 n}\]</span></p></li><li><p>用分贝表示的信噪比 <span class="math display">\[SNR=10\lg 3+20\lg D+20\lg 2^n\]</span></p></li></ul><h4 id="非均匀量化">非均匀量化</h4><p>非均匀量化是一种在输入信号的动态范围内量化间隔不相等的量化方式。在信号取值小的区间，量化间隔小；在信号取值大的区间，量化间隔大。在改善小信号量化信噪比的同时，不影响大信号量化信噪比。相当于压缩信号的动态范围（容忍更大动态范围）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162144263.png" alt="非均匀量化流程图" /><figcaption aria-hidden="true">非均匀量化流程图</figcaption></figure><p>实现非均匀量化一般采取压缩法，即使用一个上凸函数对输入信号进行压缩，以期放大小信号，缩小大信号，然后再对变换后的信号进行均匀量化。</p><p>𝐿 ≫ 1（分层很密）时，每一量化级中的压缩特性曲线可以近似看做直线，有： <span class="math display">\[\sigma_q^2=\frac{1}{12} \int_{-V}^V\left[\Delta_k(x)\right]^2 p_x(x) d x\]</span> 设压缩特性为<span class="math inline">\(y=f(x)\)</span>，且压缩后的量化间隔为等间隔，即<span class="math inline">\(\Delta_z=2V/L\)</span>，那么有： <span class="math display">\[\sigma_q^2=\frac{\Delta^2}{6} \int_0^V\left[f^{\prime}(x)\right]^{-2} p_x(x) d x\]</span> 对于理想的对数量化器，即： <span class="math display">\[y=f(x)=\frac 1B \ln x\]</span> 有量化信噪比为： <span class="math display">\[\frac{S}{\sigma_q^2}=\frac{12}{B^2 \Delta^2}=\frac{3 L^2}{B^2 V^2}\]</span> 可见其量化信噪比是常数，和信号的分布、D（归一化有效值）等变量无关，是一种最平稳的状态。</p><p>但是实际上对数压缩无法实现，因为<span class="math inline">\(y\)</span>随着<span class="math inline">\(x\)</span>的减小而趋向于无穷大。在应用中，常用的量化有A律和<span class="math inline">\(\mu\)</span>律量化两种，它们的区别是压扩函数不同。</p><p>A律的压扩函数为： <span class="math display">\[y= \begin{cases}\frac{A x}{1+\ln A} &amp; 0 \leqslant x \leqslant \frac{1}{A} \\ \frac{1+\ln A x}{1+\ln A} &amp; \frac{1}{A} \leqslant x \leqslant 1\end{cases}\]</span> 其中<span class="math inline">\(x,y\)</span>都是归一化<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="归一化的意思是当前值和最大值之比">[6]</span></a></sup>电平值，在<span class="math inline">\([0,1]\)</span>之间，国际标准中<span class="math inline">\(A=87.6\)</span>。</p><p><span class="math inline">\(\mu\)</span>律的压扩函数为： <span class="math display">\[y=\frac{\ln (1+\mu x)}{\ln (1+\mu)} \quad 0 \leqslant x \leqslant 1\]</span> 其中<span class="math inline">\(\mu\)</span>越大，压缩效果越明显，国际标准中<span class="math inline">\(\mu=255\)</span>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162159933.png" alt="两种常用非均匀量化器压缩函数图像" /><figcaption aria-hidden="true">两种常用非均匀量化器压缩函数图像</figcaption></figure><p>由公式： <span class="math display">\[\sigma_q^2=\frac{\Delta^2}{6} \int_0^V\left[f^{\prime}(x)\right]^{-2} p_x(x) d x\]</span> 知，量化信噪比比均匀量化改造<span class="math inline">\([f&#39;(x)]^2\)</span>倍，具体地，对于A律，有： <span class="math display">\[\left.f^{\prime}(x)\right|_{x \rightarrow 0}=\frac{87.6}{1+\ln 87.6}=16\]</span> 改善<span class="math inline">\(20\lg 16=24\mathbf {dB}\)</span>。对<span class="math inline">\(\mu\)</span>律，有： <span class="math display">\[\left.f^{\prime}(x)\right|_{x \rightarrow 0}=\left.\frac{\mu}{\ln (1+\mu)}\right|_{\mu=255}=46\]</span> 改善<span class="math inline">\(20\lg 46=33.3\mathbf {dB}\)</span>。</p><h3 id="编码脉冲编码调制">编码（脉冲编码调制）</h3><p>PCM（脉冲编码调制）简称脉码调制，是一种用一组二进制数字代码（码字）来代替连续信号的采样值，从而实现数字通信的方式。首先，我们来明确几个基本概念，即码组、码字、码型。</p><p>对于<span class="math inline">\(L\)</span>个量化电平的采样值，可以用<span class="math inline">\(N=\log _2 L\)</span>​位二进制的<strong>码组</strong>进行唯一表示。一个𝑁位二进制码组称为一个<strong>码字</strong>，一个码字对应一个量化电平。而码型指的是编码的规律，也就是把十进制数变成01序列的过程，常用的码型有自然码，折叠码，格雷码等。</p><p>自然码就是量化级序号十进制正整数的二进制表示，例如用四位码表示从低往高第六个量化级，就是<code>0110</code></p><p>折叠码的第一位是符号位（也叫极性码），后面的位表示幅度<strong>绝对值的大小</strong>。从编码效果来看，对于正样值，自然码和折叠码相同；对于负样值，除了符号位以外，折叠码是自然码按位取反的结果。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162246446.png" alt="常用码型" /><figcaption aria-hidden="true">常用码型</figcaption></figure><p>对于非均匀量化，为了在编码时比较方便，需要对压缩函数进行折线近似。折线近似的基本思想就是在<span class="math inline">\(y\)</span>坐标上，把纵轴等分成<span class="math inline">\(N\)</span>份，然后把曲线分成（不超过）<span class="math inline">\(N\)</span>个曲线段，把每个曲线段近似为折线，然后再进行。例如对于<span class="math inline">\(A\)</span>律，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162253217.png" alt="A律折线近似" /><figcaption aria-hidden="true">A律折线近似</figcaption></figure><p>其中最靠近原点的第1、2段的斜率是一样的，所以他俩其实是一条线，这也是我前面说“不超过<span class="math inline">\(N\)</span>个”的原因。这样一来，A律正负双向共有13段折线（本来16段，1、2、-1、-2合为1段），所以叫做“A律13折线近似”。</p><p>在对A律13折线进行编码时，采用八位二进制码，即<span class="math inline">\(256\)</span>个量化级，正负样值各<span class="math inline">\(128\)</span>个。于是需要把8个折线段中的每个再分为16份，按折叠码型，这八位安排如下：</p><table><thead><tr class="header"><th>极性码</th><th>段落码</th><th>段内码</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(C_1\)</span></td><td><span class="math inline">\(C_2C_3C_4\)</span></td><td><span class="math inline">\(C_5C_6C_7C_8\)</span></td></tr></tbody></table><p>具体编码规则如下：</p><table><thead><tr class="header"><th>量化段序号</th><th>电平范围/<span class="math inline">\(\Delta\)</span></th><th>段落码</th><th>段落起始电平</th><th>量化间隔<span class="math inline">\(\Delta_i/\Delta\)</span></th></tr></thead><tbody><tr class="odd"><td>8</td><td>1024~2048</td><td>111</td><td>1024</td><td>64</td></tr><tr class="even"><td>7</td><td>512~1024</td><td>110</td><td>512</td><td>32</td></tr><tr class="odd"><td>6</td><td>256~512</td><td>101</td><td>256</td><td>16</td></tr><tr class="even"><td>5</td><td>128~256</td><td>100</td><td>128</td><td>8</td></tr><tr class="odd"><td>4</td><td>64~128</td><td>011</td><td>64</td><td>4</td></tr><tr class="even"><td>3</td><td>32~64</td><td>010</td><td>32</td><td>2</td></tr><tr class="odd"><td>2</td><td>16~32</td><td>001</td><td>16</td><td>1</td></tr><tr class="even"><td>1</td><td>0~16</td><td>000</td><td>0</td><td>1</td></tr></tbody></table><p>注意：每个段落都不含其起始电平，例如电平64应该属于段落3而不是段落4。接下来举例说明：</p><blockquote><p>【例】若13折线A律编码器的不过载量化范围为（−5𝑉, +5𝑉 ），输入抽样脉冲幅度为−1.6875𝑉。设量化器的最小量化间隔为1个单位，最大分层电平为2048个单位。求编码器的输出码组，并计算量化误差。</p><p>【解】</p><p>先把输入信号归一化 <span class="math display">\[[\frac {-1.6875}{5}\cdot 2048]=-691\]</span> 符号位：因为是负样值，所以是<code>0</code></p><p>段落码：因为<span class="math inline">\(691\in (2^9,2^{10}]\)</span>，所以是第七段，段落码为<code>110</code></p><p>段内码： <span class="math display">\[[\frac {691-2^9}{32}]=5\]</span> 所以段内码为<code>0101</code></p><p>所以编码结果是<code>01100101</code></p><p>恢复出的电平为<span class="math inline">\(-[512+32(5+0.5)]=-688\)</span>，量化误差为： <span class="math display">\[(|-691.2+688|)\cdot \frac{5}{2048}=0.0078V\]</span></p></blockquote><h3 id="pcm的抗噪声性能">PCM的抗噪声性能</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305171507673.png" alt="PCM系统示意图" /><figcaption aria-hidden="true">PCM系统示意图</figcaption></figure><p>在PCM系统中，噪声主要有两个来源，其一是量化过程引入的量化噪声，其二是二进制信道传输过程中产生的误码引入的误码失真噪声。</p><p>假设输入信号为 [−𝑉, +𝑉] 均匀分布的随机变量，<span class="math inline">\(𝐿 = 2^𝑁&gt;&gt;1\)</span> 级均匀量化，二进制信道传输误码率为<span class="math inline">\(P_e&lt;&lt;1\)</span>。那么信号平均功率为： <span class="math display">\[S=\frac {V^2} 3=\frac{(\Delta VL/2)^2}{3}\]</span> 量化噪声功率： <span class="math display">\[\sigma_q^2=\frac{\Delta V^2}{12}\]</span> 误码失真噪声功率和码型有关，以自然码为例，有： <span class="math display">\[\sigma_e^2=E\left\{n_e^2(t)\right\}=\sum_{i=1}^N P_e\left(2^{i-1} \Delta V\right)^2=P_e \Delta V^2 \frac{2^{2 N}-1}{3} \approx P_e \Delta V^2 \frac{2^{2 N}}{3}\]</span> 所以总输出信噪比为： <span class="math display">\[S N R_o=\frac{S}{\sigma_q^2+\sigma_e^2}=\frac{S}{S / 2^{2 N}+4 P_e S}=\frac{2^{2 N}}{1+4 P_e 2^{2 N}}\]</span></p><blockquote><p>【例（2022期末）】已知信号<span class="math inline">\(m(t)\)</span>最高频率4kHz，幅度范围为<span class="math inline">\((-5.12,5.12)V\)</span>，采取13折线A律编码进行数字化，求：</p><ol type="1"><li>采样值为-1.7V时的输出码组、输出量化电平、量化误差</li><li>输出码组为<code>11011001</code>时代表的量化电平值，写出与之对应的均匀量化11位码</li><li>输出速率<span class="math inline">\(R_b\)</span></li><li>使用64QAM传输的最小带宽</li></ol><p>【解】</p><ol type="1"><li><p>先把输入信号归一化： <span class="math display">\[\left[\frac{-1.7}{5.12}\times 2048\right]=-680\]</span> 符号位：<code>0</code></p><p>段落码：因为<span class="math inline">\(680\in (512,1024]\)</span>，所以是第七段，即<code>110</code></p><p>段内码： <span class="math display">\[\left[\frac{680-512}{32}\right]=5\]</span> 所以段内码为<code>0101</code></p><p>所以整个码组为<code>01100101</code></p><p>恢复出的电平为<span class="math inline">\(-[512+32(5+0.5)]=-688\)</span>，恢复成原始电平就是<span class="math inline">\(1.72V\)</span>，量化误差为<span class="math inline">\(0.02V\)</span></p></li><li><p>正数，段落码是第第六段（256~512），段内码为<span class="math inline">\(16\times 9.5=152\)</span>，所以对应成归一化量化电平为408，对应原始电平1.02V，对应的11位均匀量化为 <span class="math display">\[(408)_{10}=(00110011000)_2\]</span></p></li><li><p><span class="math inline">\(R_b=8f_s=64kbps\)</span></p></li><li><p>有： <span class="math display">\[R_s=\frac{R_b}{\log_{2}64}=10666.67baud\]</span> 所以带宽为<span class="math inline">\(10.67kHz\)</span></p></li></ol></blockquote><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>叠加在信号上的噪声。与此相对，乘性噪声是乘在信号上的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>各态历经的意思是统计平均等于时间平均，<span class="math inline">(E[x(t)]=x(t))</span>​。直观理解就是“一次性投100枚硬币”和“把一枚硬币投100次”是等效的。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>平稳的意思是概率密度函数和时间无关 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>高斯的意思是概率密度分布是高斯分布 <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>白噪声的意思是功率谱是常数 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>归一化的意思是当前值和最大值之比 <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最美好的前途</title>
    <link href="/2023/02/02/%E5%B9%A1%E7%84%B6%E6%82%94%E6%82%9F%EF%BC%88%E6%9A%82%E5%AE%9A%EF%BC%89/"/>
    <url>/2023/02/02/%E5%B9%A1%E7%84%B6%E6%82%94%E6%82%9F%EF%BC%88%E6%9A%82%E5%AE%9A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>自己写的软科幻小说，献丑献丑，这两天持续连载。</p><span id="more"></span><h2 id="第一节-失踪">第一节 失踪</h2><p>刺耳的警报声从耳机里传出，宪贞才从神游中惊醒。不用说，他又在想那些十几年前的怪事了。</p><p>十几年前，庆田宪贞还是一个意气风发的少年，一切都是那么地幸福，少年和少女一起逛灯会，一起共进晚餐，每晚在电话里互诉衷肠，还有青涩的第一次拥抱和初吻.....她发色鲜红，热烈奔放，是火一样的少女。一切都那么地美好，直到宪贞的一场车祸夺走了这一切。一开始，宪贞几乎就要死掉了。可是经过抢救，宪贞竟然基本痊愈了，连主刀的老教授也只能感叹一声医学奇迹。但是，自此之后，她就消失了，就只留下了一张纸条，上面写着“对不起”，而另一面则写着“别来找我”。</p><p>一开始宪贞被愤怒冲昏了头脑，但过了两个月就被疑惑取代。如果只是因为担心车祸后的我拖累自己于是离开也就算了，直接人间蒸发是闹哪样呢？在这两个月里，宪贞问遍了朋友、家人、同学、老师，甚至警察，但是都没有得到任何回答。</p><p>时间在滚滚向前，像一把利刃一样切开了一切。十几年前迷梦也在慢慢地成为过眼云烟。其信然耶？其梦耶？宪贞有时也有些恍惚。不过宪贞毕业以后就进入了警局，做到了分管失踪人口的小队长，这是千真万确的。</p><p>宪贞看了一眼电脑，是紧急警务通告。</p><p>科技发达的现在，一般的事件并不会被推上宪贞的案头。先不说还在试运行的AI追查系统，单单是遍布全城的天眼，找回几个偷偷从后门溜进黑网吧的高中生也不是什么难事。于是宪贞这个小队长的工作，渐渐也从全城到处开着车巡逻，变成了坐在办公室里敲敲键盘鼠标。上周宪贞他们所接了一个幼儿坠楼的警，不过等人到了以后黄花菜都凉了。而像这样发紧急通告的，一年满打满算在这座城市也就两三起。</p><p>这是一个人鱼纪念中学女生的失踪案，孩子名叫星奈花，成绩平平，但也算得上乖巧，只是最近一个月放学回家越来越晚，直到有一天放学后再也没回来，父母吓得直接报了警。</p><p>宪贞心里一紧，他也知道现在科技的强大，而如果连科技也找不到的人，用人力找无异于大海捞针，更别说最新的AI追查系统只有在面对失踪几年乃至十几年的对象，才会表现出明显优势。</p><p>宪贞操作天眼查询这个女孩子的行踪，发现在失踪那天，她放学后直接去了一家咖啡店，自己一人进了包间，然后不知所踪，记录就此消失。宪贞到了咖啡店，一边问老板有没有注意到有人只进来了却没出去。老板被问得一头雾水，回应说店里人来人往，实在难以注意。那么，有人没付账走了么？宪贞又问。“没有啊，现在都是扫码点单了，哪还有没付账一说。”老板回答。宪贞道了谢，转身离开了咖啡厅。</p><p>说来也奇怪，宪贞自从当上了小队长以后，只遇到过三起能被摆上案头的失踪案件，其中一件顺利解决了，而另一件的线索，恰恰也是在这间咖啡厅断掉的。有一瞬间，宪贞怀疑这个咖啡厅可能大有问题，但转念一想，这里是离中学区最近的咖啡厅之一，学生想谈谈事情，大多也会选择这里，人流量相当大，几乎成了学校的第二食堂：从概率论的角度来说，似乎并不足以判定咖啡厅就是有问题。</p><p>宪贞坐上车，输入了失踪少女的家的位置。少女的家坐落在一片老旧小区里，宪贞把警车停到巷口，一个人挤进昏暗而狭窄的小巷，找到了少女的家。</p><p>按响门铃，开门的是一对夫妻，年纪不轻，估摸着有四五十岁了。男主人头上有了些许银点，而女主人则一直是担忧而后悔的表情。他们的衣服虽说整洁，但也略有发白，看样子经历过的年岁不少。打眼一看，就知道他们是最典型的工薪家庭，有些收入，但也绝供不起挥霍浪费。客厅没有墙纸，一面墙上贴着几张奖状。勤勤恳恳的普通父母，拖拽着家庭走在还算有希望的道路上——本来应该是这样的。</p><p>“啊，是庆田警官吧，请进请进”。父亲先开了口，把宪贞迎进了客厅，还给他倒了一杯茶水。</p><p>“三天以前，她就和往常一样出去上学，再也没回来过。”女主人垂着头说道。宪贞拿出笔记本假装做起了笔记，但实际上，这句话已经在案卷中被他看了不下十遍了。</p><p>“当天她有什么异样呢？有闹情绪之类的吗？”宪贞追问道。</p><p>“没有啊，就是和往常一样出门，然后就没有回来了。”女主人低声答道，男主人接起了话茬：“说到异样，最近一个月里她确实有时候很晚回来，有时候夜不归宿。问她去干什么了，基本都是说和同学一起玩游戏去了。我给她同学打电话，也确实得到了相同的回答，说是在玩最近很火的那个什么《圆神》。我们寻思着玩游戏不算什么大事，只要把学习搞好，平时放松一下也不是不行，就没有细问。”</p><p>“但是上周开始女儿身上有时候开始出现了伤痕，也不大，问就说是磕了碰了，不要紧。而且第二天起来就好了，我们也就没细问。谁知道……哎！”</p><p>“不都是怪你不操心吗！女儿只有这一个月成天不回来，你就光打打电话就算完事了？你怎么就不知道拦一下……现在可好！都是你的错！”女主人突然站起来，边哭边捶打着男主人。宪贞拉开他俩，坐定以后，又确认了她的学校，班级之后，留下联系方式便离去了。</p><p>宪贞坐进车里，整理了一下思绪。好吧，至少出现了一点点有意思的线索，也就是那些伤痕。女孩身上出现不大的伤痕，那么女孩是不是有一个崇尚暴力的男朋友呢？然后女孩害怕父母反对，总之就是和男友私奔了。多半是被高年级的海王骗了吧！这个傻女子。“小度，去人鱼中学！”宪贞下了决定。</p><p>正在为您规划路线，预计时间十分钟。</p><p>挺近的，估计为这房子也花了不少钱，宪贞心想。人鱼纪念中学是当地相当有名的升学高中，坊间向来有踏进人鱼就等于半只脚踏进名牌大学的说法，学费不高，而且从来只看考试成绩录取，交钱不顶用，市长批条子也不顶用。至于这个诡异的名字，据说是赞助商的癖好吧。宪贞查了查赞助商，叫佐仓基金会，而其主要投资人也姓佐仓，是当地一家科技企业：美冬科技的总裁。</p><p>人鱼中学最近安装了“学生大数据系统”，是全国十所试点的中学之一。学生大数据系统已经在大学全面铺开了，在中学还只在试点阶段。它除了能记录学生的姓名、班级、成绩、奖惩等基本信息以外，还可以针对成绩下滑严重、沉迷网络游戏、迟到早退、上课打瞌睡的同学作出预警，甚至可以通过学生们在食堂、浴室、图书馆等地的刷卡签到进行大数据聚类分析，形成学生们的关系图谱。虽然这系统在刚刚推行时引起了很大的关于隐私方面的争议，但它也做到了校内各种资源的整合，带来了很大的生活便利，再加上试点的学校也不多，大家久而久之也就默认它的存在了。</p><p>宪贞调取了星奈花的大数据，所有警告项目前面都是一个绿色的对勾，也不知道是幸运还是不幸。只有沉迷网络游戏和上课打瞌睡这两项数值最近有增长趋势，印证了父母的证词，但增长缓慢，数值也不高，还没到触发警报的程度。接下来就是分析关系图谱了。如果最近有很强的关系形成，甚至是恋爱关系，那么就可以沿着“暴力海王”的思路继续追查了。</p><p>宪贞把关系图谱的数据下载下来，导入警方专用的绘图软件中，输入密码后，便生成了可视化的动态关系图谱。计算显示，她最近在和人恋爱的概率不超过2%——不管是男的还是女的。星奈花在一个月前的社交圈子很稳定，在一个月之内的社交圈子也很稳定。更蹊跷的是，这两个圈子似乎很不一样。</p><p>宪贞把图谱保存下来，又问了星奈花的朋友，也没有得到什么异样的回答，她最近既没有闹情绪，也没有和之前的圈子决裂，总之一切看起来都很正常，除了上课有些打不起精神以外。至于第二个圈子，显得也很正常，只是里面的同学都在玩《圆神》，这看起来就像是星奈花游戏刚入坑，找“大佬”带一样。宪贞问完以后，就离开了人鱼中学。</p><h2 id="第二节-圆神">第二节 圆神</h2><p>“哎哟我真是草了，怎么又摊上这档子事。”回到办公室的宪贞刚坐到椅子上就开始头大。他整理了一下目前能确定的疑点，首先就是莫名其妙又能迅速痊愈的伤痕，第二个疑点就是一个月前社交圈子的变动。宪贞抱怨道：“真是邪乎到家了！打个游戏能打出伤来，还能把人打没了？我倒要看看这个‘圆神’是个什么东西！”</p><p>同事听到了宪贞的话，便随口接道：“圆神你都不知道？恁游戏最近红得发紫了都，那个开发商，美冬（Mifuyu）科技，以前还名不见经传的，好像是做快递的，去年发布了圆神，一跃成为了咱们市的重点企业嘞”，同事打了两下键盘，“诺，美冬科技，光它的增长就占了咱市去年经济增长总量的25%！纳税大户，好得很呐。你要想入坑可以加下我好友，我回头带你哈~”</p><p>宪贞下班后，并没有像往常一样去居酒屋，而是直接向自己的公寓奔去。“550W啊，帮我搜一下这个圆神”，宪贞对他的智能音箱说道。</p><p>好的，正在为您搜索相关信息：</p><blockquote><p>《圆神》是由美冬科技（Mifuyu）自主开发的一款全新开放世界VR冒险游戏。游戏发生在一个被称作“银之庭”的幻想世界，在这里，被神选中的人将被授予“灵魂宝石”，导引魔法之力。玩家将扮演一位名为“魔法少女”的神秘角色，在自由的旅行中邂逅性格各异、能力独特的少女同伴们，和她们一起击败魔女，找回失散的亲人——同时，逐步发掘“灵魂”的真相。</p><p>——维基百科</p></blockquote><p>“那你能给我下一个么？”，宪贞心想，我倒要看看这游戏有什么魔力。</p><p>“下载完成，请戴上眼镜，进入VR游戏室体验游戏”智能音箱提示道。宪贞带上眼镜，走上跑步机，系上安全带后，进入了《圆神》的世界。</p><p>首先映入宪贞眼帘的是游戏的登录界面，一座在云上的城市，道路上铺满了略显突兀的鲜花，一位没有面目的白衣女神从天上驾着马车降下，粉色的长发延伸到屏幕之外，似乎有无限长。待游戏加载完成后，这位女神来到他的面前，他点击进入了游戏。</p><p>游戏一开始，黄色卷发的loli麻美（宪贞控制的主角）和父母一起乘车郊游，忽然不知道从哪儿窜出来一辆大货车，向主角一行人的车径直撞过去。主角的父母当场去世，主角的视角也在慢慢变成深红色。正当视野即将变成全黑色时，不知道从哪儿窜出来一只明亮的白色生物。从某种意义上来说，这个生物体态和猫有点类似。但是它的嘴是“<span class="math inline">\(\omega\)</span>”形，有两大片从白色到粉红色的，像头巾一样的结构从耳朵中冒出来，而它的尾巴也比猫大得多。</p><p>这个生物说话了，却没有开口：“和我签订契约，成为魔法少女吧！麻美，你的愿望是什么？”</p><p>“请，请让我活下去。”屏幕上只有这一个选项。</p><p>“好了，接受它吧，这就是你的命运。”白色生物的“头巾”伸长并且插入了麻美的胸口。麻美的视野恢复了正常，并发现眼前有一个闪着金黄色光芒的宝石。</p><p>伸手摘下了这颗宝石，游戏正式开始了。</p><p>麻美活了下来，她的父母却没有这么幸运。</p><p>她在白色生物的引导下慢慢往家所在的小城走去。小城的风格是三十年前的画风，看起来有些古朴的质感。一路上，麻美和白色生物边走边聊。白色生物说自己叫做“丘比”，和著名的沙拉酱同名，自己的使命就是来拯救处于危难或彷徨中的少女们，实现她们的愿望并带领她们适应新的生活。</p><p>快到城市时，宪贞看到了一个奇怪的生物。在写实画风的游戏中，这个生物却像是从纸上剪下来直接贴在视野里的一样。而且画风相当潦草，边缘还在不停地抖动。这时，丘比说话了：“轻轻地念‘变身’，然后跟着那个生物。”</p><p>宪贞用只有自己和麦克风能听到的声音轻轻地念了一声“变身”，手中的黄色宝石飞了出去，闪烁着金色的光芒。麻美身上的便服也变成了一身华丽的衣装，手中拿着一柄短剑，身边还漂浮着明黄色的缎带。麻美放轻脚步，慢慢地跟着那个神秘的生物。尽管城市中道路错综复杂，但是当她的方向正确，或者靠近“猎物”时，宝石的闪光频率便会加大，所以找到“猎物”的位置倒也不难。终于，麻美把猎物逼到了一条断头路上，她挥动身边的缎带，把猎物绑缚起来，又用手上的短剑结束了猎物的生命。这时，系统界面弹出一个提示，说这种猎物叫做“使魔”，属于“魔女”的仆役。</p><p>“是魔女的仆役？那么魔女是什么？”，宪贞问。丘比答道：“其实魔女才是你们要打的主要目标哦~如果见到使魔就打的话，不仅会浪费自己的魔力，还很难通过它找到魔女的踪影。”</p><p>“在你使用魔法时，你的魔力就会损耗。魔力越损耗，灵魂宝石就越污浊。当灵魂宝石完全浑浊时，会有相当不好的事情发生也说不定...而击杀魔女以后，掉落的物品除了升级素材以外，最重要的就是这个东西，悲叹之种”，丘比向宪贞眼前投送了一张图片，悲叹之种就像一根被银针穿过的葡萄。丘比继续说道：“悲叹之种可以清洁你的灵魂宝石，只要把它们放在一起就行了。”</p><p>“那么，如果我一直不战斗，只是在大世界里面逛街，是不是就没事了？”宪贞抛出了自己的疑问。</p><p>丘比似乎早有准备，立刻答道：“减少战斗确实能延缓灵魂宝石的浑浊，但是并不能完全避免。你的负面情绪，负面的身体状态，灵魂宝石都会自动用魔法帮你修复，而且这个功能你并不能自主选择开启或关闭，所以久而久之你的灵魂宝石还是会浑浊。接下来教你几招常用的技能吧......那么，如果没有其他问题的话，我就走咯。如果有问题就叫我，我会马上出现的。”丘比说完，从麻美肩膀上跳下去，消失不见了。</p><p>“哦...”宪贞有些迷茫。他并不是没有问题，倒不如说满脑子都是问题。“算啦，走一步看一步吧！”他下定决心。</p><p>麻美变回了普通少女的形态，一边把玩着自己的灵魂宝石，一边在城市里逛街。在一个小巷子的转角处，她发现了一个用银针穿过的紫色球体，钉在墙面上。“这不是那个什么悲叹之种吗，在这里是可以直接拿的意思吗？”</p><p>麻美伸手把悲叹之种拔了下来。紧接着，她周围的世界扭曲并折叠，变成了一个旋涡，被吸进了那个悲叹之种留下的小小窟窿里。取代世界的，是另一幅光怪陆离的光景。这个奇异的世界和版画有些类似，色彩相当鲜艳，而且画风相当潦草，边缘还在不停地抖动，就像是那个小孩子的涂鸦。之前遇到的“使魔”，放在大世界里确实很突兀，放在这个奇幻的空间倒是毫无违和感。现在麻美似乎身处一个走廊里，走廊的墙壁上布满了会动的画，描述着不知道是哪个少女的短暂的一生，走廊的地上铺着鲜艳的鲜花，尽管踩起来丝毫没有鲜花的柔软。</p><p>麻美继续沿着走廊往前走，途中遇到了很多使魔，大多数并没有纠缠她太久，她也没有一直和使魔战斗。又走了几十步，空间一下子变大了起来，直到变成了一个大厅。处于大厅之中的，除了许多使魔之外，还有一个巨大的怪物。只见这怪物有三四个人那么高，通体黑红色，好像将熄未熄的木炭；她的周围，有无数鲜红色的蝴蝶飞舞，好似木炭往四周抛洒的火星。一条提示出现在了麻美面前：</p><blockquote><p>Lv.30 烈焰之魔女，性质是挥霍。泪水和歌喉被耗尽后，她决定挥霍一切生命之火，烧尽世界的救赎。</p></blockquote><p>魔女！宪贞眼中只看到了这个词，原来这就是自己的主要敌人：魔女。麻美立刻变身，提起缎带和短剑冲了上去，丝毫没有意识到自己只有5级。</p><p>刚靠近烈焰之魔女，麻美首先感到的是刺骨的严寒，进而是难以言说的酷热。黑红的炭山对她吐出火舌，她只得左右腾挪躲闪。在火舌和冰柱之间，麻美渐渐地体力不支。魔女似乎也不耐烦了，从身体中掏出一根冒着火舌的长鞭举到空中，对着麻美迎面劈下来。麻美见躲闪不及，硬着头皮受了这一击。区区5级的麻美，又哪里是30级的魔女的敌手？</p><p>麻美只见自己的视野又变黑了，她知道这是“濒死”的现象。她吓得暂停了游戏，从背包中找到能回血的食品胡吃海塞。就这样，麻美一边可怜地往魔女身边凑近，用她的缎带和短剑抛光；一边转身腾挪躲避火舌和冰柱，一边不停地按暂停键，吃应急食品来回血。但是食品终究有吃完的时候，而此时魔女的血量还有五分之四。就当麻美准备放弃，闷着头挨下一击时，她的眼前突然弹出一个提示：</p><p>“玩家：福蒂娅 正申请加入你的世界”</p><p>就像在洪水中摸到救命稻草一般，宪贞立刻同意了她的申请。90级的福蒂娅来到了麻美身边，只一击，就杀死了烈焰的魔女。</p><p>“诺，悲叹之种，你拿走吧，反正我还有好多。”福蒂娅开口了。麻美好像是还没缓过劲来，只是走上前去，拿起了悲叹之种。</p><p>“喂喂，我问你啊，你是刚刚才入坑的吧？怎么找到这里来了？”福蒂娅又问道，“这里可不是新人该来的地方。”</p><p>“啊，我，我就是在城里瞎转了转，不知道怎么就来了……”宪贞也不知道怎么回答。</p><p>“哦...这样啊。”福蒂娅不知道怎么，好像有点失望。但她又迅速恢复了刚刚的热情，继续说道“我给你说啊，打怪之前先看一眼等级，Ok？这种Boss不能打就不要乱打。还有就是，你这个角色的技能是可以升级的吧，升到五级以后就能用枪哦，比你现在用的短剑好用多了吧……”她又讲了讲游戏最基本的机制和技巧，就离开了宪贞的世界。</p><p>“是这样啊……”宪贞缓了缓，照着福蒂娅说的找了几个等级低的怪物打了打，又给自己的角色升了几级，也就下线了。</p><p>摘下眼镜，离开VR游戏室，宪贞躺在床上回味着自己的《圆神》时光。不得不承认，这游戏能火确实有它的原因的，在其他这种二次元游戏都是氪金抽卡片的换皮游戏的时候，圆神居然有如此奇妙的画风以及宽广的地图,以及精细的细节。剧情设定到现在倒是没看出什么端倪，看着像上世纪末流行的经典子供向魔法少女。但这一切和失踪案有什么关系呢？罢了，先睡觉吧……宪贞关掉了灯。</p><h2 id="第三节-福蒂娅">第三节 福蒂娅</h2><p>尽管灯关了，头放到枕头上了，被子也放到身体上了，却怎么也睡不着觉，就感觉心脏上压着一块大石头一样。往日柔和的月光，今天却显得有些刺眼了。宪贞不断地在脑子中整理着昨天一整天的所见所闻。先是咖啡店，然后是身上莫名其妙的伤痕，再是社交圈子的微妙变化，最后是——《圆神》。圆神中又有两个人物，丘比应该是机器人先不说了，这个福蒂娅倒是让人印象颇为深刻，毕竟算是救人于水火之中嘛。火一样的性格，可能也是自己喜欢的类型。</p><p>……等等！</p><p>宪贞彻底睡不着了。无论是福蒂娅说话的声音，还是说话的方式，都让宪贞越想越不对劲。宪贞从床上挣扎起来，又进入游戏室，调取了游戏过程的录音，截取了最后福蒂娅出现的那一段以后，拷贝到了自己的U盘里。</p><p>宪贞躺回了床上，一遍又一遍地咂摸着这短短的两句话。不是内容，而是语调和声音。最终他还是和着这段声音进入了梦乡。在梦里，他屡次感觉马上就要捅破那层窗户纸了，但是最终还是没有结果。</p><p>第二天早上，宪贞按时上班时，没有忘记带着他的U盘。宪贞知道，虽然手上这个星奈花的案子暂时还没有头绪，但是论起找人，在市里他说自己的第二，也没人敢说自己是第一。他刚到局里，就溜进了超算机房。而这台超算上，正运行着还在调试的AI追查系统。这套AI追查系统脱胎于宪贞自己大学的科创项目，在大学时期为他带来了倚叠如山的荣誉，基本上来说也是宪贞能如此顺利的当上警察并如坐火箭一般升职的敲门砖。它不仅仅能根据面部、声纹、虹膜等等生物特征在高效地查找人物信息，更厉害的是，一旦知道了一个人的DNA信息，以及任意一个时刻的生物特征，它便能使用人工智能推演出未来某个时刻的特征，包括说话的声音，以及面容等等。它在刚刚投入使用的那一年，便一举帮助几十个被拐卖的儿童找到了父母，而所需要的信息只是出生时的一张照片和一滴血。</p><p>宪贞颤抖着输入了系统的登录密码，然后试着把U盘插到电脑上。当然第一下肯定是插反了的，他又把U盘倒过来，还是插不进去，直到第三次，U盘才精准地滑进了USB口。宪贞深吸一口气，擦了擦手上的汗，把那一段音频拖进了AI追查系统的输入框里，再深吸一口气，按下“确定”：</p><blockquote><p>找到0个目标：第0个/共0个。</p></blockquote><p>这套AI追查系统还没见到过这样的惨败，甚至于宪贞都没有想起来做一个没找到的时候的UI界面。毕竟...一个人怎么可能是不存在的呢？宪贞之前一直是这样想的。</p><p>宪贞现在才想起来把自己扔进椅子里，又给自己倒了杯冷水，喝了一大口。一个人怎么可能是不存在的呢？宪贞在问自己。已经死了？不可能，死人也有记录。失踪了？同理。不对不对，这都是一个人消失的情况，而不是一个不存在的人冒出来的情况。反过来想，如果这个人一开始就没有登记过呢？这样的话不就找不到了吗？但是如果连他的父母、兄弟姐妹都匹配不出来，是不是有点太过分了？总不可能一整个家族都没登记吧？</p><p>宪贞把那杯水一口喝完，锁上电脑，又离开了超算房。他决定先冷静冷静。</p><p>上午，专案组里召开了关于星奈花失踪事件的会议，宪贞讲解了一下昨天调查时的记录，讲了讲自己遇到的几个疑点以后就结束了，他的同事们也没有提出什么太有价值的见解。局长似乎有点生气，说要是两天以内再找不到就只能全城搜查了。</p><p>散会以后，宪贞又溜进了超算房。就在屁股刚挨到椅子上时，一个念头突然划过——怎么就没考虑到“福蒂娅”用了伪声器的可能呢？毕竟以前所有使用AI追查系统的目标都相当的“配合”——至少不会蓄意捣乱。现在的伪声器已经非常高级了，只需要给波形上加上一个很微弱但是经过精心设计的噪音，就能达成扰乱基于神经网络的识别系统的效果，而人耳则完全察觉不了。宪贞将那段录音先用降噪器还原，又轻车熟路地拖到了追查系统的输入框里，按下了enter键。此时，屏幕上出现了结果。</p><p>一张宪贞熟悉得不能再熟悉的面孔出现在了屏幕上。从某种意义上来说，“显示这张照片”就是这套AI追查系统在宪贞大学时被写出来时的终极意义——没错，那就是宪贞日思夜想了十几年的那个她。</p><p>宪贞的心脏漏跳了一拍，瞬间感觉四肢冰冷，呼吸加速，有无数鲜血涌上大脑。尽管他在梦中见到过无数次这个画面，但是要说在现实中突然冷不丁地出现，他并没有做好心理准备。正当他准备开心地大喊时，他注意到了图片右下角的匹配度：只有12%。</p><p>12%的匹配度，系统认为“福蒂娅”有88%的可能性并不是宪贞曾经的女友。但是，系统并没有给出匹配度更高的人选。这代表着，在全国以及世界上共享了数据库的国家的范围内，AI追查系统还是没有找出“福蒂娅”的真身。同时，系统提示：“福蒂娅”，这名据推断为19岁零五个月正负两个月的少女，有46%的可能性是她的妹妹，另有41%的可能性是她的女儿，剩下的1%则是其他从实际上可以忽略的可能，比如克隆人。自从大陆那边搞人类转基因的贺教授锒铛入狱，全世界都加强了关于人类生物技术的监管。</p><p>她有妹妹吗？宪贞可以肯定地回答，没有。不仅仅是在恋爱中的交谈得知，系统中也没有关于她的妹妹的任何信息。那也可能是她失踪后才出生的妹妹，而且基于各种各样的原因没有登记呢？宪贞也迅速排除了这个可能。首先不去登记在这个时代已经是相当困难的事情了，基本等同于黑户，没有身份信息也很难登录游戏；其次，即使这位妹妹是宪贞车祸当天出生的，到现在也不过十八岁三个月零五天，和AI推断的年龄并不相符。那么是女儿吗？呃……宪贞打心眼里不愿意去想象这个可能性。但是依旧是年龄对不上。</p><p>排除了AI给出的两个最有可能的情况，似乎又陷入了死胡同。但一个巨大的进展已经出现了，那就是“福蒂娅”肯定和她有说不清道不明的关系。</p><p>宪贞仔细咂摸着“19岁零五个月”这个年龄，他的脑中莫名有一道光出现。这道光接管了宪贞身体的控制权，操纵着宪贞的手，在AI追查系统的“生理信息预测”功能上点了一下“×”。这个功能本来是宪贞的得意之作，是他付出了无数精力和心血的最终结晶。而如果关闭了这个功能，也就意味着系统将暂时失去按时间流逝推演的能力。接着，这道光继续操纵着宪贞的手按下了“查询”。</p><p>两分钟后，结果出现了。</p><p>屏幕上还是那个女孩，不过这时，右下角的匹配度变成了99.99%。当然，还有一个黄色的警告符号，指示着生理信息预测功能未在运行。</p><p>看到这个结果，宪贞反而像是释然了一般，长出一口气，坐回了椅子里。这个结果意味着什么呢？显然，它意味着十八年前的，宪贞的初恋女友，不知道是经过时空旅行还是怎样，突然出现在了现在这个世界，她现在也在玩《圆神》，用户名是“福蒂娅”。</p><p>十八年的追寻终于有了结果，但是却又带来了一系列问题，其中最大的问题就是：时间旅行并不可能实现，这是常识中的常识。</p><p>宪贞觉得自己的脑子快要被这两个女人的失踪案搅和成一团乱麻了。首先是星奈花的失踪案，然后是自己十八年前的女友的失而复得案，两个事件都疑点重重。星奈花的神秘伤痕，社交圈子的变动，“圆神”，以及“圆神”中“福蒂娅”——也就是宪贞十八年前人间蒸发的女友。有一句话说得好，你手里攥着千头万绪，工作是千头万绪，攥着一千个线头，但是一次针眼只能穿过一条线。宪贞决定还是从自己的女友入手比较好，说没有私心的成分是不可能的，而且他感觉，自己和（前？）女友打交道，应该也比较熟练。那就下班回到家以后继续玩玩《圆神》吧，应该还能在游戏里见到她。在让同事调取一下福蒂娅的实名认证信息后，宪贞就下班回家了。</p><p>宪贞刚回到家，屁股还没坐到沙发上，电话突然响了。一边祈祷着不是新的警情通报，宪贞一边拿起了电话。是一个外国号码，不知道是哪个国家的，看着像是什么南太平洋岛国，和电话一起来的还有反诈骗中心的警告短信。作为一名警察，逗逗骗子扮猪吃老虎也算是乐趣之一，于是宪贞接起了电话。</p><p>“喂，你是宪贞吧，我是福蒂娅。按我对你的了解，你现在大概知道我是谁了吧，要是知道了就来咖啡厅见一面，偶哇！”</p><p>怎么说呢，还是熟悉的热情似火。当然，宪贞也是很乐意见上一见的，不如说是非常想见一面的。于是宪贞直接让AI管家预订了出租车，一边快步往小区大门跑去。</p><h2 id="第四节-意料之外的相遇">第四节 意料之外的相遇</h2><p>宪贞乘车来到了咖啡厅，服务员告知他已经有一个叫福蒂娅的女孩在等他。宪贞三步并做二步走到了服务员指引的包间，打开门，见到了他朝思暮想的那张脸。</p><p>“呀，你来了，坐吧。”福蒂娅微微一笑，作出了一个“请”的姿势。</p><p>宪贞动了动嘴，他当然有很多的问题想问，但是看着福蒂娅，又一时间说不出话来，只得拉开椅子先坐下。福蒂娅已经给他放好了一杯咖啡，他拿起来抿了一小口，既为了平复自己的心情，也为了组织一下自己的语言。</p><p>“星奈花很安全，你不要再追查了。”没想到，福蒂娅先开口了，而且这一句话就能惊掉宪贞的下巴。</p><p>宪贞的下巴当然没有掉，因为他正在喝咖啡。听到福蒂娅的话，他似乎被呛到了一般咳嗽了几声，但又迅速平静了下来。“什么？”宪贞一头雾水。</p><p>“我说啊，你现在是不是在追查一个叫星奈花的孩子的失踪案？星奈花还活着，非常安全，而且被我们保护得很好，过两天等事情结束了我们就把她还给父母，你就不要再管了。”福蒂娅补充道。</p><p>可惜，福蒂娅的补充并没有减少宪贞脑袋里的问号数量。她怎么知道星奈花的？她和星奈花有什么关系？为什么时隔十几年的重逢是在说这些？什么叫“保护得很好”？是劫匪吗？“事情结束了”是什么事情？福蒂娅这两句话，直接把宪贞打蒙了。愣了半天，出于职业习惯，宪贞还是决定问问什么叫保护得很好。</p><p>“呃，保护得很好的意思就是她在我们手里...呃，不是，我不是那个意思。总之就是她可能生了些...病，然后我们怕她受到更多伤害，就在保护她。”福蒂娅显然有点紧张，说话断断续续的。</p><p>“好吧，我们先不说这个。查不查她真不是我说了能算的。亲爱的，你这几年都去哪儿了？为什么突然消失了？‘我们’是什么？”宪贞显然回过了神来。</p><p>“嗯，那个...哎呀，总之你就不要查星奈花了！我,,,很好，希望我们还能再见。”福蒂娅把头低下去，脸色一红，支支吾吾地说。说完，福蒂娅竟然凭空消失了。</p><p>“今天真是见了鬼...”宪贞瞪大了眼睛，然后，他发现福蒂娅的座位上有一个奇怪的装置。</p><p>宪贞乘车回到所里，找到值班的警察，拿出这个装置，问道：“你知道这是个什么东西么？”值班警察对着它端详了半天，也没说出个所以然来，只能明天找专家看看了。</p><p>宪贞带着满脑子的问题跑出了家门，带着更多的问题和一个奇怪的装置回到了家中。</p><p>宪贞把这装置在手中细细揣摩，只见它呈一个从小到大的圆台形，约莫有五六厘米高，顶部是一系列玻璃镜子，就像相机镜头，底部有个USB接口和两张存储卡。看到这里，宪贞小松了一口气：至少它是我们能理解的科技，顶多是哪个高科技公司的试验机，不是什么天外来物，毕竟这两天发生的怪事要说是外星人在搞鬼也不是没有可能。宪贞把这两张存储卡拔出来，发现是VR设备专用的。这么说，这个设备应该是某种VR成像投影仪，而今天在咖啡店的，应该是福蒂娅的VR投影，宪贞作出了推测。</p><p>他把存储卡带进自己的VR室，塞进终端。其中一张卡里的文件格式系统并不认识，可是对于另一张卡，系统提示这是“圆神”的游戏录屏存档。宪贞急忙带上VR眼镜，把这个文件用“圆神”打开，看看里面到底有什么。</p><p>刚进游戏，宪贞变成了一个十六七岁的普通JK少女，而不是他进游戏时所扮演的金发小学萝莉，视野右上角的闪烁着“记录模式”，在这个模式下宪贞并不能操纵角色，只能用这个角色的眼睛观察着世界。</p><p>似乎与平常不同，少女的生活并没有像宪贞扮演的麻美一样突然出现什么重大的变故。她只是在日复一日地上学，上课，聊天，放学，写作业，打游戏，就像这个国家里的无数少女一样。聊的天也无外乎谁和谁谈恋爱了，哪个男明星长得帅了，以及现在最火的游戏——《圆神》。其中她尤其和一个高三年级的学姐关系非常密切，连吃饭都要一起。</p><p>通过聊天的内容得知，学姐来自大陆那边，因为对岛上的文化什么的更感兴趣才在上个月转来的。五年前，大陆那边对他们的宝岛发动了统一国家的战争，日本也被胁迫派兵去帮助宝岛。结果自卫队的队员发现，东京比北京好打得多。日本水兵抹了美国大兵的脖子，战舰在海上兜了一圈又回到了东京湾，一声炮响，自民党下台。这起事件在当时并没有让多少民众的生活受到直接影响，似乎和历史上的那些兵变没什么区别，都是老爷们的游戏。但是这五年里大陆那边和岛上的往来是越来越密切了，岛上很多学校的外语课程从英语换成了普通话，人鱼纪念中学就是其中最积极的一个；大陆那边用日语参加高考的人也越来越多了，而学姐原本就是其中之一。谈吐间，也能看出学姐是个挺优秀的人，学识还算渊博，气质还算温柔优雅，总之给人的感觉不是什么坏人。</p><p>随着关系日益亲密，少女终于决定去学姐家做客了。因为是留学来的，所以学姐是一个人住。为了不那么孤单，学姐养了个宠物。这宠物不是别的，正是那丘比。丘比就像一只小猫一样，时不时低头觅食，时不时在家里跳来蹦去。学姐拿好零食坐下，小丘比灵活地跳进学姐的怀里，学姐则轻柔地抚摸着丘比的毛发。</p><p>“小花，快坐吧！这是从我家带回来的，西湖龙井，今年的新茶，你快尝尝！”学姐拿起桌面上的紫砂壶，招呼少女坐下。宪贞这时才得知，少女似乎叫做小花。</p><p>小花端起茶杯，轻轻吹了几口气，又抿了一口。可惜VR设备还没强大到模拟味觉的地步，宪贞没能尝到“今年的新龙井”的味道。随后，她们又聊了一会儿女孩子们的话题。学姐忽然猛地咽了一口水，似乎下了很大的决心，正色道：“小花，你想不想看看我的世界呢？”</p><p>“诶……学姐的世界...是什么意思呢？”小花呆呆地回应道。</p><p>“来吧，来了你就知道了！”学姐看起来很热情，一旁的丘比开心地甩着尾巴。</p><p>“诶……好吧。”小花依旧呆呆地同意了。</p><p>学姐抱起丘比，拿起小花的手，脚步轻盈地拉着小花走到了大街上。紧接着，学姐从裙子的口袋里掏出了一个水滴状的小饰品，大概有食指那么长，浑身透亮而带点幽幽的蓝色，以不快不慢的频率闪着光，上面有纷繁复杂的镶嵌和装饰。宪贞看出来了，这东西是个灵魂宝石。</p><p>学姐一手拿着灵魂宝石，根据宝石闪烁的频率来判定方向，一手牵着一头雾水的小花，丘比静静地趴在学姐的肩上。“小花，你看，这就是我的世界哦。我在学校里没有多少朋友，也就只有你可以倾诉了...”学姐自顾自地说起话来。</p><p>宝石的闪烁频率仍然在不断地加大，这说明她们离目标越来越近了。这是一个郊外的立交桥，专用于自动驾驶的，虽然不太繁忙，但是看起来依然非常雄壮。唯一不和谐的因素是，有一个绝不应该存在在这里的东西，出现在了视野中，那是一个人！他径直往立交桥上走去，手上还带着一把钳子，应该是用来剪开路旁的铁丝围栏用的。他步履蹒跚，似乎已经非常疲惫了，但是依然昂着头，向着立交桥走去。自动驾驶的速度很快，基本来说都有时速二百多码，虽然现在车并不多，但是他一旦进入了立交桥，也基本意味着死亡。</p><p>“小花，我们快去把他拦下来！”学姐急切地叫道。“诶，可是我们都是女孩子....”小花似乎依然有点犹豫。</p><p>“来不及了，变身！”学姐手中的灵魂宝石飞了出去，发出了蓝色的光芒。学姐身上的校服也变成了华丽的甲胄，看起来好像是中世纪的骑士。她一下跳到那人面前，三两下打晕了他，并夺走了他手中的钳子。这下他应该没有那个本事闯入立交桥了。小花赶上前去，看到他的脖子上有一颗奇怪的印记。“这是魔兽的咬痕”，学姐解释说，“这世界上存在一种叫做‘魔兽’的恶魔，他们会通过这种方式引诱人们自杀，精神不稳定的人、小孩子或者老年人最容易受它们的侵蚀。我的世界，说白了就是和它们作战。”</p><p>“魔兽一般都成群结队出现，今天这只竟然落了单，这是猎杀的好时机！”学姐补充道。</p><p>“来吧，跟上我！”学姐站了起来。这时，小花周围的正常世界忽然开始融化，天空幻化成融化的蜡烛滴落下来，取而代之的是一个光怪陆离，像拼贴画一样的世界。宪贞知道，这就是结界。结界中，小花、学姐和丘比在一条小径中快步前行，学姐不时用钳子幻化而成剑劈砍着冲上来的使魔，一边安慰小花说，“不要害怕，有我在呢。”</p><p>渐行数十步，豁然开朗，一行人来到了一个大厅，大厅半空中有一个面容扭曲的布偶，时不时发出凄厉的嘶吼，它大概就是魔兽的真身。学姐挥动手中的绸缎，只见它变成了一根细线，向大厅的上方飞去。啪嗒一声，绸缎好似有抓钩一般固定在了天花板上。另有一条绸缎飞出把小花和学姐绑在了一起。“抓稳了哟！”学姐提示道，紧接着，小花、学姐和丘比一起顺着绸缎向它的末端飞去。在途经魔女时，学姐拔出剑，对着它砍将过去。一剑下去，那玩偶便爆出雪白色的棉花来。</p><p>一行人顺着绸缎飞到了天花板上，学姐叫一声“小心了！”松开抓钩，向那玩偶落去，而宝剑直对着它的天灵盖。一剑下去，那玩偶像泄了气的气球一样四处乱飞，紧接着拼贴画的世界渐渐淡出，天空又恢复了本来的面貌。</p><p>学姐变回了原来穿着校服的样子，宝剑和绸缎也消失了。小花跑到那个被打晕了的男人面前，摇醒了他，确认他没事之后，轻声安慰了他两句。男人倒也不是坏人，搞清楚状况后道了谢就离开了。这时小花还特意观察了男人的脖子，“魔兽的咬痕”已经消失了。</p><p>学姐走了过来，对小花说：“这就是我的世界。嗯...不知道你喜不喜欢呢...”学姐低下头，似乎有点紧张。</p><p>“哇！学姐也太帅了吧！”小花跳起来，抱住了学姐。“没想到在学校里安安静静的学姐，竟然还有这么帅气的一面吗！而且还可以帮助别人，要是我也能像学姐一样就好了！”学姐愣了愣神，旋即脸上恢复了笑意，拉起小花的手说，“那真是太好了，我们快回去吧。”</p><p>回到家里，学姐重新坐下，叹了一口气，说：“其实我今天特别的害怕，总是怕你觉得我是什么怪物，或者是什么暴力狂……所以我也一直不敢对别人说，但是一直这样下去，我心中就像有一团淤积的火一样，又想说，又不敢说，直到我遇见了你...总之非常感谢你能认可我！”学姐红着脸说道。</p><p>小花笑了：“哪里...像学姐这样又帅气又有爱心的人，不要这么自卑啦！我觉得大家都能认可你哦，即使没有大家，我也是你的忠实粉丝啦！”她们聊了一会儿天后，小花就回到自己家里去了。</p><p>看到游戏告一段落，宪贞把VR眼镜取下来，想要休息一下，接口水喝，顺便捋捋思路。宪贞知道福蒂娅在游戏中的造型和人设，和录像存档里的学姐根本不一样。也就是说，这个录像带并不是福蒂娅本人的，至少不是她昨天使用的账号。而小花则很有意思，本来宪贞很想看看小花长什么样子，可是游戏里是第一人称，而且并没有照镜子的机会。真的没有么？宪贞打开了游戏的帮助菜单，找到“录像与存档”。里面说，这里的游戏录像并不是直接截取画面，而是获取了游戏内部的存档数据，在播放时再实时演算出来，因此大大降低了所占用的存储空间。“既然是实时演算，那么应该就能切换视角！”宪贞心想。果不其然，开发者早考虑到了有能之士的破解，游戏内就提供了视角切换工具，倒带回看工具，速率缩放工具等等一系列扩展插件，就是每个要...呃...1000日元一个月。“钱不是问题，装！”宪贞对AI助手说道。等“录像存档专用插件包”安装好后，宪贞迫不及待地进入了游戏。</p><h2 id="第五节-还是人吗">第五节 还是人吗</h2><p>刚进入录像，宪贞就打开了视角切换工具，结果提示：“目前视线内无可供切换的角色，请找到好友玩家后再试。”想想也对，毕竟这时的小花正在睡大觉呢，视线内什么也没有呀，话说游戏里也要睡觉么，宪贞嘀咕道。</p><p>不一会儿天就亮了，小花也起床去上学了。在上学途中，小花遇上了她的另一个同学。宪贞又打开了视角切换工具，但是仍然提示“目前视线内无可供切换的角色，请找到好友玩家后再试。”，原来如果是NPC的话，也不能切换视角。好吧，宪贞心想，今天你（我）总还要见学姐的吧，我就不信学姐也是NPC。一转眼儿，小花就到了课堂。正在她盯着窗外发呆时，却看见了学姐的那只宠物：丘比。一下课，小花就出去，对着丘比又摸又抱。丘比灵活地从她的怀里挣脱，跳到了地上，尾巴一晃，说话了，却没有开口：“和我签订契约，成为魔法少女吧！”</p><p>“诶，那，那个....像我这样的人，真的可以吗？”小花说道。“没问题的哦，我在你的身上看到了羁绊。”丘比摇着尾巴。“能让我考虑考虑吗？”小花怯生生地问道。“当然没问题，你也可以问问学姐啦，我随时都在，你只要默念我的名字‘丘比’就可以啦 ”丘比又摇了摇尾巴，“此外，如果你愿意当魔法少女，我还可以实现你的一个愿望哟！”说完，丘比就一溜烟跑了。</p><p>中午吃午饭时，小花果不其然去找到了学姐。她们刚刚坐定，宪贞就启动了视角切换工具，这次工具成功启用了，宪贞用视线选择了学姐，按下确定 。</p><p>眼前出现的，是自己日夜追查的星奈花的脸。</p><p>宪贞知道，现在先进一些的VR设备是可以扫描用户的面部特征并导入支持定制角色样貌的游戏里的。</p><p>也就是说，这个录像存档，大概是星奈花的。看日期，也就是星奈花失踪前几天的记录。“这么说来，我更得看看了”，宪贞心想，“这不仅和福蒂娅有关，也和星奈花有关。”</p><p>宪贞把视角调回星奈花，也就是小花，然后继续播放。在吃午饭时，小花告诉学姐，自己被丘比邀请成为魔法少女的事。学姐很开心，因为这样就可以和自己最信任的后辈并肩作战了。沉默了一会儿，学姐又补充道：“嗯...我建议你还是再仔细考虑考虑吧。毕竟这是在战斗，可能是会受伤的！你好好考虑吧，就我而言肯定是希望你能来啦，多个朋友多个帮手嘛。”</p><p>小花显然陷入了思考，没有说太多话。时间到了放学时，小花又跑去找到了学姐，这时她似乎下定了决心：“学姐，我还是想当魔法少女！我这个人平时很懦弱...对什么都很害怕，也总是担心给别人添麻烦...如果能成为魔法少女的话，至少可以帮助到别人，而且还能实现一个梦想呢。”听完这话，学姐一把把小花抱住，边哭边说：“呜呜...小花你真是太好了...”小花难为情地嘿嘿笑了笑，说：“我还没想好愿望是什么呢……”</p><p>愿望这东西，平时说起来有很多，比如说我想中彩票，我想有很多很多的钱，我想不学习就能考到100分，我想让我喜欢的人也喜欢我，我想让我的全家人身体健康，我想让世界和平，我想让全人类飞向星空。但是当真的有你言出法随的机会摆在眼前时，你反而会纠结。不是因为有了这样的机会，而是因为这样的机会只有一次。</p><p>“学姐你的愿望是什么呢？”小花问道。但是学姐并没有正面回答，只是说：“你的愿望一定要直面自己的内心，千万不要搞弯弯绕，不然这会害了你的。比如你说你要次次考试都考一百分，但是你考试的目的是上大学，上好大学的目的是找好工作，找好工作的目的是赚钱，那你与其许愿考一百分，不如直接许愿好工作，或者赚好多钱哦~毕竟高考的满分是150分，嘿嘿。”星奈花认真听着，时不时地点点头表示赞许。</p><p>“那么我的愿望是什么呢...我感觉现在的生活就挺好的了，不如说我想当魔法少女就是为了帮助别人，这可怎么办呢...贸然许愿会不会打破现在平静但美好的生活？”星奈花小声嘀咕着。</p><p>这时，丘比从一旁窜了出来，跳到了学姐怀里，说：“想不到愿望的话，也没有关系的，我一直都在，想好了的话，我就会自动出现哦<sub>Q</sub>”</p><p>“诶，别走，我想好了！既然要成为魔法少女，那我就要成为超级——超级强大的魔法少女！这样既不会对我的日常生活产生影响，也能帮助我的战斗，学姐你觉得怎么样呢？”星奈花说。</p><p>“如果这真的是你的愿望的话，那当然最好啦！”学姐仍旧笑吟吟地看着星奈花。</p><p>“这当然没问题。你确定这是你的愿望吗？”丘比跳到了星奈花的对面。“嗯”，星奈花点了点头。</p><p>“好了，接受它吧，这就是你的命运。”丘比的“头巾”伸长并且插入了星奈花的胸口。并发现眼前有一个闪着鲜红色光芒的宝石。</p><p>接着，录像的时间加快了。内容大概都是一些星奈花和学姐去喝咖啡、并肩战斗、学姐帮助星奈花训练的场景，还是很温馨的。星奈花的魔力很强，但是使用得还是不够熟练，只能在训练中慢慢进步。当然，为了不过度使用魔力，《圆神》就成了她们训练的强力辅助。</p><p>直到那一天。</p><p>紫萱是五年前来岛上的大陆人之一。她在大陆的生活并不顺利，于是便想来岛上碰碰运气，她变卖了在大陆的房产，住进了一座普通的公寓，带着她的老公。在这五年里，她的人生稍有起色，其中最可喜的是在第二年获得了一个可爱的小女孩，名叫小寒。她在推特上开了个账号，记录她和孩子的温馨日常，收获的关注也颇丰。</p><p>这天孩子闹腾着要吃蛋挞，紫萱便下楼去给她买，顺便在蛋糕店旁边的驿站取个快递，那是给孩子买的换装娃娃。刚回单元楼，紫萱便看见邻居火急火燎地找上门，说：“你娃好像刚刚在窗台玩，摔下去了！你赶紧去看看！”。紫萱似乎一下子并没有理解邻居的意思，仍旧提着东西往电梯里走。她一边想着：“这孩子是该多教育教育”，一边按下电梯的13楼按钮。</p><p>一进家门，紫萱高声叫道：“小寒~来吃蛋挞啦！”但是并没有收到想象中的回应。她扔下东西，在家里四处寻找起来。终于，她在窗台上找到了一辆小汽车玩具，这是上周一家人一起去商场时，小寒闹着让买的。往下看去，她看到了最熟悉的花纹，那花纹是紫萱的妈妈最擅长的。新年时，妈妈从大陆给紫萱寄了满满一包东西，其中就有一件饱含着温柔和爱意的小小新衣，上面还有亲手缝制的不那么规整的针脚。</p><p>现在这件新衣静静地躺在十三楼下的水泥地上，上面好像还有一些暗红色的东西。</p><p>紫萱尖叫一声，从楼梯冲了下去。</p><p>13楼的楼梯说长不长，可是对这天的紫萱来说，它长得像二万五千里长征。</p><p>她终于跑到了一楼，看见了暗红色的斑块在她最熟悉的新衣和灰白的水泥地上慢慢扩散。</p><p>与紫萱同时跑来的，还有星奈花和学姐。学姐看到了紫萱，也看到了趴在地上的小孩的脖子上有一块奇怪的印记，这是魔兽的咬痕。</p><p>学姐惊叫一声，直接变身，拉着星奈花进入了魔兽的结界。在结界中歇斯底里地左劈右砍，丝毫不在意砍的是魔兽、使魔还是别的什么东西。学姐的招式里只有永无止境的进攻，丝毫没有格挡与防守。渐渐地，她的身上多出许多伤口，鲜红的血液随着学姐突刺劈砍的身形一起挥洒。星奈花眼见大事不好，催动魔力，释放无数缎带缚住了学姐，硬是把她拉离了结界。</p><p>学姐即使被束缚住，仍然在不停地挣扎，大声喊叫：“小花你在做什么？！你难道不去打魔兽吗？你难道还要让它害死更多的人吗！”直到星奈花把学姐放在公园的长椅上，学姐的动静才渐渐小了起来，渐渐地转化为哭泣：“都怪我不好……都怪我不好！我单知道年轻人会被魔兽盯上，我不知道小孩子也会...我明明昨晚还在推上看过她的....”</p><p>这是一座小公园的深处，半坏的路灯闪着昏暗的白光，树枝在微风中轻轻摇曳。</p><p>星奈花一把把学姐拉近自己的怀里，不知道要说些什么，只好紧紧搂着学姐，一边检查着学姐的伤势。在结界里看起来很严重的伤，现在看来却没有那么严重了。正当星奈花抱着学姐时，她却突然停止了哭泣，晕了过去。</p><p>“学姐！学姐！你醒一醒！”星奈花轻轻推动着学姐，然而并没有得到任何回应。她摸了摸学姐的脉搏，也没有感受到应有的跳动。“喂，喂，醒一醒啊……”星奈花越来越害怕，越来越心急。</p><p>她背起学姐，一脚深一脚浅地往马路边走去，应该是准备叫救护车。这时，丘比出现了：</p><p>“你不要你的学姐了吗？”</p><p>星奈花愣住了：“什么意思？学姐不是在我背上吗？”</p><p>丘比灵巧地跃出，几秒之后又轻轻跳了回来，嘴里叼着暗蓝色的灵魂宝石：</p><p>“学姐她刚刚从身体里掉出来了，所以身体自然就不会动啦。下次可不要这么粗心了哟<sub>Q</sub>”</p><p>与此同时，学姐也醒了过来。她从星奈花背上下来，一把抓起丘比的脖子，诘问道：“喂，刚才是怎么回事？你给我解释清楚！”</p><p>丘比虽然被捏着脖子，声音却丝毫没有变化：“你们魔法少女控制身体的范围只有100米，超过了这个范围，身体自然就成一具空壳了，平时一定要看好自己，不要再让它从身体里掉出来了哟。”</p><p>“一具空壳？什么意思？！”</p><p>“我可不会让你们用原来的身体去战斗，那样也太危险了。对你们魔法少女而言，原先的身体就是身外之物了。作为你们本体的灵魂，已经被精简成了能更安全高效地使用魔力的安全形态。”</p><p>丘比的语调依然没有任何变化，像英语听力一样标准而平缓。</p><p>“和你们签订契约的我，就是抽取你们的灵魂，把它变成灵魂宝石哦<sub>Q</sub>”</p><p>星奈花站在一旁惊慌失措地看着，不知道该想些什么，也不知道该做些什么，好像大脑突然断网进入了“loading”状态一样，她只能在一旁静静地看着。</p><p>学姐掏出剑来，一剑把丘比劈成两半：“你他妈瞎说什么呢？”</p><p>两片丘比的遗体像落叶一般飘落在地上，似乎没有什么重量。</p><p>“那我们不全是僵尸了吗？”</p><p>从树林的阴影处，又一只丘比慢慢地走了出来：</p><p>“你要硬是这么说也不能说就是错的啦。不过这样做可全是为了你们好哦。”</p><p>“够了！够了！不要再说了！！”</p><p>学姐又向新的丘比投掷了几枚匕首，然而并没有击中目标。新的丘比走到原先丘比的尸体旁边，开始啃食起来。</p><p>“这不是更方便了吗？即使心脏被打穿了，只要灵魂宝石还在，就能立刻修复身体继续战斗，比起满是弱点，还会随着时间推移老化的人体，这不是对战斗更有利吗？”</p><p>“你们还真是一个样呢。告诉你们真相后都是这种反应，真不知道你们人类是怎么想的。”</p><p>学姐双腿一软，跪倒在了地上。对着丘比冷冷地说：</p><p><strong>“你他妈的，还算是个人吗？”</strong></p><p><strong>“我不是，你也不是。”</strong>丘比一转身，消失在了阴影之中。</p><p>学姐手中拿着的，是失去了光泽的灵魂宝石，或者说，是她自己。</p><p>比起一开始像天空一样澄澈的灵魂宝石，现在的它已经污浊不堪，里面飘着紫黑色的絮状物，好像是暴雨前的天空，表面更有杂乱无章的裂隙，仿佛一碰就要崩解。</p><p>星奈花见到了，大惊失色，急忙从身上找悲叹之种。但是宪贞知道她不可能找得见，因为屏幕左上角提示星奈花的悲叹之种余量是0。</p><p>学姐轻轻按落星奈花翻找的手，淡淡地说：“没必要了。”</p><p>星奈花在这个仲秋的夜里，急得满头大汗。</p><p>“像我这样的人，既没法拯救别人，甚至连自己都变成怪物了……你说我们，怎么如此滑稽啊？”学姐的声音在颤抖。</p><p>“学姐你不要这样说，你还是救过很多人的！振作起来！”星奈花摇着学姐的肩膀，眼中充满了真挚和急切。</p><p>学姐把手指头轻轻放到星奈花的嘴边，做了一个“嘘”的手势，叹了口气，说：</p><p>“祈求多大的希望，最终就会换回同等的绝望。我们魔法少女，可能就是这样的结构吧。我真傻，真的……”</p><p>天边，一道桃红色的闪光撕破如胶一般粘腻的深夜。那道光好似从大洋彼岸发射的一支利箭，带着使命和神圣，终于来到了学姐的面前。</p><p>学姐轻轻笑了笑，闭上了眼睛。</p><p>蓝黑色的灵魂宝石其中的污浊被桃红色的神圣光箭完全吸收，宝石又恢复成了一开始的澄澈透明。紧接着，宝石破碎了，桃红色的光芒也消失了，随之一同消失的还有学姐的身体。</p><p>学姐好像从来没有在这个世界上存在过。</p><p>星奈花仍然保持着扶着学姐肩膀的姿势，可是她扶着的肩膀已经不存在了。</p><p>她顺势趴在地上，开始呜呜地哭了起来。</p><p>她只看到了学姐的离去，还没有来得及仔细体会丘比说的话到底是什么意思。但是宪贞注意到，系统显示，星奈花灵魂宝石的污染程度已经超过了70%，处于即将崩溃的边缘。</p><p>路灯闪烁，发出滋滋的电流声。树叶摇曳，发出沙沙的撞击声。如果没有少女的哭声，那么这将是普普通通的秋夜。忽然，急切的跑动声和魔法瞬移自带的咻咻声闯了进来。</p><p>星奈花抬头看去，眼前也是一位魔法少女，一头鲜红色的短发，面色通红，喘着粗气，显然是急忙赶来的。她的穿着并不像学姐和星奈花一样复古，而是以普通校服打底，外面穿了一套充满了现代化风格的战术装具，头上戴着鸭舌帽和耳麦，以及一副看起来很复杂的眼镜，手上戴着半指手套，还端着一把自动步枪，手肘膝盖上都戴着护具，身上还穿着一件战术背心，脚下蹬着一双皮靴，至少看起来是这样。</p><p>“巡逻小队285-7报告！找到人了，大的没来得及，小的还在……位置073，021，魔兽1，魔兽幼体4，使魔27，魔法少女1，OVER！”来人对着耳麦说道。</p><p>星奈花的系统显示，这位现代化的魔法少女名字叫做：福蒂娅。</p><p>福蒂娅一把抓起星奈花的手，往其中塞了三颗悲叹之种，说：“快跟我走，你现在情况很危急，周围还有魔兽在活动，先赶紧净化灵魂宝石，别说话，别问，我们边走边解释！”</p><p>星奈花慢慢地把灵魂宝石拿出来，用悲叹之种靠了上去。瞬间，灵魂宝石清澈了不少。</p><p>“对了，就是这样，好孩子！现在我们快走吧！”福蒂娅拉着星奈花的手，一边跑步一边催动魔力瞬移，没命一般地猛跑，跑出了三个街道，福蒂娅才停下喘了口气。福蒂娅抚摸着跑脱力了的星奈花的后背，安慰道：</p><p>“好孩子，不要害怕，我是来保护你的。对你朋友的遭遇，我也非常的悲伤。但是刚才你的灵魂宝石污染已经非常高了，我们需要对你进行全面的检查，希望你能配合我们！”</p><p>星奈花也跟着喘着粗气，她显然没有搞清楚这是怎么回事，不过她知道面前的福蒂娅并不是什么坏人，于是就答应了下来。</p><p>“你还能跑得动吗？现在离魔兽也远了，我们可以慢点走”福蒂娅说。</p><p>“没关系的，走吧。但是那个魔兽怎么办？”星奈花回应道。</p><p>“我已经让我的队友们前去处理了，你不要担心。”尽管如此，福蒂娅还是多少放慢了速度。终于，她们来到了一个诊所门口，诊所并没有通电，看起来就像是下班停业了一样。“冬的诊所”，牌匾上这样写道。福蒂娅和星奈花一个瞬移，就进入了诊所里面的一间病房。</p><p>“叮”一声提示音响起，录屏记录就此中断。</p><p>宪贞取下VR眼睛，也大口地喘着气，顺手擦了擦头上的汗，拿起桌边的瓶装水猛灌了一口。不得不说，宪贞之前真的小看了这款游戏，无论从细节，建模还是渲染上来说，这游戏都有点真实得过分了，简直就像用摄像机拍摄出来的一样，甚至比普通摄像机还要真实，不如说就像是自己真的用眼睛在看。</p><p>游戏录像看完了，那么星奈花和福蒂娅到底在哪呢？宪贞决定先从最后的“冬之诊所”查起。因为这里是记录消失的地方。</p><p>宪贞进入了自己的游戏，来到了地图上的“冬之诊所”。不出意料，系统并没有让他进去。于是，他便在周围散起了步。冬之诊所并不是什么大医院，因此也只在一幢摩天楼的一二楼门面房里。这座摩天楼所在的区域非常的繁华，好像是市中心一样，楼旁的马路中间有个小小的广场公园，好像是哪个古迹的遗址。</p><p>这场景让宪贞有点眼熟。</p><p>非常眼熟。</p><p>宪贞一把抓下了VR眼镜，从裤兜里掏出手机，打开地图APP，在搜索框中输入了“冬之诊所”，按下了确认。</p><p>果不其然，地图给出了结果。冬之诊所就在宪贞所居住的市，而那幢摩天楼正是美冬科技的总部。宪贞调出游戏的大地图，发现这地图竟然和现实完美重合。宪贞一拍脑壳，痛骂自己刚才怎么没有看出来。</p><p>宪贞没有任何一天像今天一样着急去上班，他看向窗外，果不其然，地平线上出现了意料之中的鱼肚白。</p><p>跳上智能车，他火急火燎地到了派出所。刚钻出车舱，就遇见了刚下班的，昨晚值夜班的警察。他拦住宪贞，给了他一封文件。</p><p>“这是美冬科技昨晚给咱们所发的传真，说是丢了一件VR终端实验品让帮忙找找，你看看是不是你昨天拿过来的那个？要是的话，你今天拿给人家，咱也就不用立案了，麻烦。”</p><p>宪贞定睛一看，正是昨天福蒂娅留下的那个装置。宪贞应了下来，就进了警局，换上衣服准备出发了。</p><h2 id="第六节-最美好的前途">第六节 最美好的前途</h2><p>宪贞走进了冬之诊所。乍一看，它和全国几千个大大小小的诊所完全相同，来就诊的患者不多不少，一切都在有序运行，总而言之一句话：正常得都有点异常了。</p><p>宪贞向分诊台的护士出示了警官证和搜查令，叫来了诊所的负责人。负责人是一个中老年的男性，头发花白，面色慈祥，穿着白大褂，挂着听诊器。除了脸上有一道刀疤以外完全就是“老专家”的形象。</p><p>宪贞给他看了星奈花和福蒂娅的照片，问问他有没有看到过这两个人。</p><p>“第一个人没有一点印象，第二个人应该是在头顶这座大厦上班的。”老专家回答道。</p><p>“我能在这里四处走走吗？”</p><p>“当然可以，不过有些房间是无菌的，您要进去恐怕得先做个消杀才行。”</p><p>宪贞道了谢，便在这诊所的一二两层四处转了起来。同之前一样，他也没有发现任何异常，这个诊所和平常的小医院没有任何不同，要硬说有异状，那就是冬之诊所的设备很先进，完全有三甲医院的水平，从专业的医疗器械，到医生桌面上摆的电脑，没有一个是差劲的。这也难怪，说不定人家是美冬科技资助的呢，离得那么近还有个冬字，宪贞心想。</p><p>在二层的走廊尽头，宪贞看到了一个紧锁的房间。老专家说，那个房间从他接手以来就从来没有用过，他都不知道是不是属于这个诊所的。虽然租赁合同上是有，但是房东没给这间房的钥匙，也嘱咐过不要动这房间。</p><p>说着说着，老专家一拍大腿：“哎呀，我才想起来我要出诊了，警官您慢慢查着，有问题了随时叫我哈！”说完，他就跑下了楼。</p><p>宪贞从口袋里摸出万能钥匙，在锁眼里捅了两三下，门就开了。</p><p>映入眼帘的，是和外面没什么不同的病房装潢。两张病床，一堆仪器，一个病人和一个陪护。不同的是，这里面的仪器和外面的有很大区别，不是心电仪，血压血氧仪等常规仪器，病人身上也没有插着各种管子。</p><p>躺着的人看不清，但是坐着的人看得很清楚，那人就是福蒂娅。</p><p>没等宪贞有所反应，福蒂娅就来到了宪贞眼前。</p><p>“宪贞！你是怎么找到这里的？”她开口问道。</p><p>宪贞从口袋中拿出了那枚“VR试验品”，“你总不会是不小心留给我的吧。”，宪贞说道。</p><p>“既然你都看完了，那我也没什么隐瞒的必要了。”少女拉起宪贞的手，另一只手指着病床，“诺，那就是你正在找的星奈花，现在正在睡觉呢，我们小声一点。”，又指了指仪器。</p><p>宪贞凑近去看，仪器的中心，是一块明红色的宝石，那宝石不是别的，正是灵魂宝石。而灵魂宝石上则插着各种各样的导线和接口，整个仪器都是围绕着这宝石工作的。</p><p>“啊？这，这……”宪贞惊讶得说不出话来。</p><p>女孩打开了一扇暗门，招呼着宪贞，有啥事咱出去说。</p><p>宪贞走进了暗门，来到了一个电梯里。等两人站定，电梯便开始缓缓上升。</p><p>“该说你聪明呢？还是笨呢？”福蒂娅责怪着说，“你难道就没有发现那片录像存档芯片里，记录的不是游戏里的内容吗？”</p><p>“什么？那记录的是什么？”宪贞还没有反应过来。</p><p>“事实”，福蒂娅说，“提示很简单。第一，游戏中你们战斗的目标叫‘魔女’，而不叫‘魔兽’。第二，那起幼儿坠楼案，接处警的就是你们所，我还以为你会有点印象。”</p><p>经这么一说，宪贞似乎确实想起来了点东西。不过他还是不太明白，事实是怎么被写在录像存储芯片上的，难道是拍电影吗？</p><p>“从灵魂宝石里提取的。你也应该知道，灵魂宝石才是我们的本体，所以自然能从那里面提取记忆。脑机接口我们做不出来，但是对灵魂宝石的研究突破还是一件接一件。”</p><p>“这...算不算是某种人体实验？”宪贞想幽一默，化解一下尴尬的气氛。</p><p>“……”福蒂娅没有回答。</p><p>电梯停下了。她把宪贞带到外面，那是一片纯白色的大厅，点着几盏白色的灯。“来吧，既然来都来了，那就带你看看我们的实验室。”</p><p>少女指着玻璃墙里面的一号实验室，与其说是实验室，更像是一个制衣工厂，而成品就是福蒂娅在游戏中穿着的现代化战术装具。少女介绍到：“这是魔法少女战术装具。在普通装具的基础上，加入了对灵魂宝石的凯夫拉纤维特种保护，就是被迫击炮弹正面击中，也能保障石头的完好无损。”福蒂娅撕开胸前的一个口袋的尼龙搭扣，透亮的宝石在里面发出温柔而坚定的红光。灵魂宝石周围，接着几根导线，她解释说，这是监测污染程度用的。如果污染程度超过了50%，战术装具就会自动弹出这里悲叹之种来进行净化，福蒂娅指了指灵魂宝石上面的口袋。</p><p>二号实验室看起来也不像是通常意义的实验室，倒像是网吧。福蒂娅说，这是指挥调度中心。大屏幕上监测的是全市范围内的魔兽活动情况。绿色的是巡逻小队，她们主要由能空间移动的魔法少女组成，主要是在市里查找魔兽。“我就是巡逻小队的一员”，福蒂娅补充道。</p><p>找到魔兽后，巡逻小队要上报指挥中心，也就是这里的二号实验室。中心会派出一支四人小队，标准的编制是移动师、战斗师、增幅师和治疗师。“调度中心给魔兽分了五大类，会针对类型分别派遣战斗小队，当然这主要是为了适配小队里的增幅师。每次战斗基本都有固定的流程和套路，再辅以小队长的自行决断，我们这里已经很久没有出现战斗减员了”，福蒂娅听起来有点得意地介绍着，“现在也有监测新签约的魔法少女的装置，但是还不成熟，反应有点慢，定位也不是非常的准。星奈花就是被这个试制系统找到的。”</p><p>三号实验室看起来有点像实验室了，里面有一台大型计算机，比宪贞所里的只大不小。“这是OGAS，总裁起的名字，我也不知道是什么含义。它的作用是对悲叹之种进行分配。”福蒂娅说。宪贞知道，悲叹之种可谓是魔法少女的命门了，而如何对其进行分配，也是至关重要的。福蒂娅继续介绍道：“以前魔法少女各自为战，战斗力强的赚得盆满钵满，而战斗力弱的只能独自消失。OGAS出现以后，所有悲叹之种的生成、获取、分配、消耗，都是由它计算的。基本上来说，它实现了按需分配。”</p><p>“按需分配？那怎么可能呢？如果我现在需要100个怎么办？”</p><p>“这是你对按需分配的狭隘理解。”福蒂娅轻轻笑了一下，“你根本不需要100个悲叹之种，对吧？事实上你连1个都不需要。所以它自然不会给你发，你说的这叫‘按欲分配’而不是‘按需分配’。你说你想要100个，只是因为你认为悲叹之种是一种需要囤积的稀缺资源。几十年前大陆那边的人不也囤积了很多盐，到现在不也没吃完吗？看了前两个实验室，你就应该知道：每一个我们这里的魔法少女的污浊度，都有实时联网记录，这样的话谁什么时候需要多少悲叹之种就一目了然了。”</p><p>宪贞震撼得说不出话来。</p><p>四号实验室看起来更像一个实验室了，宪贞是这么认为的，因为从玻璃墙壁看进去，里面有很多试管，反应皿，还有很多示波器和工业机。福蒂娅说，这是用来研究灵魂宝石的性质的实验室，它最大的成就之一就是灵魂宝石的记忆提取技术和污浊度监测技术。实验室里现在没什么人，只有电器运行的嗡嗡声，因为目前愿意把自己贡献出来以供研究的魔法少女在出外勤。</p><p>五号实验室没有玻璃外墙了，门也换成了严实的铁门。福蒂娅说，她只知道这座实验室名叫“新生命实验室”，里面研究的似乎是关于人体细胞和脑科学的东西。“我们都不是人了，研究体细胞有什么用？有啥病变大不了切掉重新长一个。”福蒂娅表现得有些不屑。</p><p>走廊走到了尽头，福蒂娅刚带着宪贞回头，没想到在他们的面前出现了另一个人。来人一头紫黑色的长发，紫黑色的眼珠下面有一张冷峻的脸，她上身穿着领口和袖口有黑色装饰的白衬衫，下身穿着黑底紫花的裤袜，约莫十四五岁的样子。当然宪贞知道，现在看人脸识别出的年龄已经不靠谱了。</p><p>来人伸出了手：“庆田警官，福蒂娅，你们好，我是晓美焰，美冬科技的副总裁。幸会幸会。”</p><p>宪贞和晓美焰握了手，福蒂娅则显得有点惊慌：“焰！那，那个...我不是故意带外人进来的...他就是我给您提到过的庆田宪贞，所以我才...真的对不起！”</p><p>“没关系，我都知道了，小福你不要老是这么害怕我的。庆田警官，您是为星奈花的事来的吧？”</p><p>“啊，是的。”</p><p>“那麻烦您跟我上楼吧，总裁会给您一个详细的解释。另外，还请麻烦您把你上衣口袋、以及公文包里的录音机拿出来吧，我们用不到这个。”</p><p>晓美焰张开了握住的手，里面果真躺着两个微型录音机。宪贞再去上衣口袋里摸时，已经摸不到了。</p><p>“没事，我都已经帮你拿出来了。没有别的问题我们就走吧”晓美焰淡淡地说。</p><p>总裁的办公室比实验室还要高一楼，但是并没有通电梯，晓美焰和宪贞通过楼梯到了楼上。晓美焰给宪贞递过一张名片，上面印着“晓美焰，美冬科技集团副总裁，东京大学公共管理学院硕士研究生毕业”的字样。</p><p>“门后面就是佐仓总裁的办公室了，我就送到这里吧，回见。”晓美焰指了指面前的门，转身走了。</p><p>宪贞敲了敲门，门自动打开了，眼前的就是美冬科技集团总裁的办公室。装潢并不十分华丽，也不像下面的实验室那样有科技感，就是普普通通的感觉。右边的墙上是一个书架，堆满了书，其中还有翻开的，应该不是假书。办公桌的背后是一块顶天立地的巨大屏幕，屏幕上显示着《圆神》的登录画面，圣洁的粉白色女神正低头俯视着这一切。音响里播放着一首小提琴曲，是《最美好的前途》，上世纪的一首苏联歌。</p><p>总裁端坐在椅子上，面对着屏幕时不时敲两下键盘。她穿着西装，暗红色的头发在脑后束起高马尾，显得很简洁干练，也是十四五岁的面容。看到门开了，总裁站起来，对走到办公桌前的宪贞微微点了下头，也递上一张名片。</p><p>“佐仓杏子，美冬科技集团总裁，东京大学公共管理学院硕士研究生毕业”，上面写道。</p><p>“请坐吧，需要喝水吗？还是喝饮料？茶，咖啡，还是可乐？”佐仓杏子招呼道。</p><p>“啊，喝茶吧。”宪贞随便选了一个。</p><p>佐仓杏子走到书架前，从抽屉里取出一套茶具，紫砂的，花样繁多，有盖碗，茶海，闻香杯，茶杯，茶滤，茶夹，茶托，茶盘，茶巾等等一整套，看得宪贞眼花缭乱。她又取出了一个小小的银罐，从里面倒出些许茶叶。</p><p>经过了一系列工序，杏子亲手为宪贞泡了一杯茶。“今年的新龙井，应该挺好喝的。”杏子说。</p><p>宪贞拿起杯子，回应道：“您也喝，您也喝。”</p><p>杏子从桌子底下的冰箱里拿出一罐红黑色的东西，撬开，倒进了茶杯，里面还咕嘟咕嘟冒着气。</p><p>“哈哈，我就这样。大陆有句话说‘山猪吃不了细糠’，我就喝可乐就行了。”杏子笑了笑，说：“星奈花的事情，你应该了解得差不多了吧，记忆芯片都看了。”</p><p>“是的”</p><p>“里面的东西都是真的”</p><p>“福蒂娅也是这么和我说的”，宪贞似乎有点不置可否。</p><p>“别怀疑啦，都是真的，毕竟魔法什么的，一下子接受不了也是正常的。小福这孩子不会说话。现在她已经恢复得挺好了，咱们聊完你就能把她领走，给她父母一个交代，这事你放一万个心！”杏子察觉到了宪贞的纠结。</p><p>“啊，好的，那多谢您了。只是如果只有这件事，似乎不用劳您大驾吧？”宪贞答道。</p><p>“聪明”，杏子又笑了一下，“福蒂娅以前是你的女朋友吧？她经常和我说起你”。</p><p>“是的，您能告诉我她这些年都经历了什么吗？”宪贞这才意识到已经进入了正题。</p><p>“你之前出过车祸，对吧？当时你都快死了，福蒂娅天天为你祈祷，于是丘比就找上了她”，杏子喝了一口可乐，“她当时就许了愿，许的就是你的健康。后来就是以前每个魔法少女都会经历的事，什么发现自己不是人了什么的。她怕你以为她是怪物，就悄悄离开了你。当时是小焰在路旁捡到的她，就把她带回来了，然后她就一直跟着我们做事，大概就是这么回事。”</p><p>“我真的搞不懂这些小女孩，不是就不是了呗，崩溃啥呀？咋滴，是舌头尝不出味儿了，还是耳朵听不见声音了，还是眼睛看不见东西了，还是胃不能消化了，还是〇没法〇了？一切正常，该咋就咋嘛，真是的。”杏子吐槽道，“哈哈，你别看我现在这样说，当时刚发现这事的时候也挺崩溃的，我现在是老阿姨喽~”</p><p>“您还年轻着呢。”宪贞接下话茬。</p><p>“哈哈，年轻？我们魔法少女最不缺的就是年轻！你把悲叹之种管够，我到一百年之后还是这张脸，这具身体，这个脑子！别说一百年，就是二百年，三百年，高山重新变成海洋，沙漠重新变成绿洲，天空重新变成蓝色，鲜花重新挂上枝头，我们的身体也不会变了。”</p><p>“那么历史上为什么没有关于长寿少女的记载呢？”宪贞提出了疑问。</p><p>“为什么没有？傻呗！就我刚当上魔法少女那时候吧，每个城里的魔法少女都单打独斗，一派一派的。魔兽魔兽打不过，打起魔法少女来倒是一打一个准的，内斗呗，抢来的悲叹之种和打来的悲叹之种不都是悲叹之种。还有大把大把死在第一场战斗上的。过去的人真笨，过去的人真难呐。”</p><p>背景音乐轻声唱道：</p><blockquote><p>有个声音来自最美好的远处，它在黎明时分含着晨露。</p><p>灿烂的前景令人心驰向往，如同当初美好理想的模样。</p><p>……</p></blockquote><p>“我是幸运的，不如说我们是幸运的。我，小焰和麻美，都活到了大学毕业。当时我们就觉得，魔法少女不能再这样下去了。然后麻美就去大陆留学了，我们在这边攒钱。虽然我现在是总裁，不过最厉害的还是人家麻美”，杏子停下，又倒了一杯可乐：“人家在大陆那边留了几年学，回来满嘴什么‘组织’，‘分配’，‘唯物’，还有什么‘标准化’的，给我们讲了一整晚，把我们说得一愣一愣的。虽然愣，但我们知道它行，就这样搞！”</p><p>“花开两朵各表一枝吧，我们这边呢，先是继续读了研，然后开始创业。当时我们做得可多了，什么快递（当然是用魔法瞬移）呀，什么私人侦探呀，搬运工呀，啥活都干，几年下来也算是攒下一笔钱。”</p><p>“后来就干呗，我们就是最初的‘四人小队’，不过只有三个人。你看这本书”，杏子抽出一本薄书，白色封面，上面印着《猎杀魔兽完全指南》，“这就是我们一开始搞的初稿”。杏子轻轻地抚摸着这本书，沉浸在了回忆之中。</p><p>“后来又打了几场仗，和别的魔法少女。我刚在批判内斗，但是有时候真没办法。我们不杀人，也不抢悲叹之种，只是诚挚地要求她们加入我们。一遍行了那就加入，一遍不行就多打几遍，总会同意的。一开始人多的帮派打不过，我们就一个一个拉拢人少的，或者落单的。”</p><p>“再后来啊，我们也慢慢壮大。注册了个公司，叫美冬。主业当时还是送快递，对吧警官”</p><p>“啊，对的”，宪贞赶紧回忆了一下。</p><p>“当时我们的快递干得可好啦，全国次日达，而且既不用买车也不用租飞机，找几个空间系魔法少女接力就行。”</p><p>“再后来啊，麻美她一直在捣鼓电路板，说是能读取灵魂宝石上的信息，还手把手教我们操作。灵魂宝石可是我们的命，一开始谁也不敢轻举妄动，她竟然把自己的灵魂宝石装上去做实验。我到现在都记得污浊度读取成功的那一刻，我们四个人在麻美的小作坊里相拥而泣，我的胳膊上还被没冷下来的烙铁烫了个泡，诺，这就是她当时用的烙铁”杏子指了指书柜。“小焰把这个系统命名为圆环之理 0.1”</p><blockquote><p>……</p><p>有个声音来自最美好的远处，她在召唤我去奇妙的国度。</p><p>我听见那声音向我严正发问，我为明天尽些什么义务？</p><p>……</p></blockquote><p>“科学实验总不是一帆风顺的。有一天晚上大家都下班回家了，麻美还在实验室泡着，我们也没管她。第二天醒来却找不见她人了，查了监控才知道是实验做得不太成功，把自己的灵魂宝石弄浑了。这不是啥大事，放悲叹之种的仓库就在旁边。但是她不愿停下实验，为了获取半浑浊的灵魂宝石的数据，竟然把宝石留在实验台上，自己去拿悲叹之种了。实验室和仓库说远不远，只有120米，可就是这多出来的20米要了她的命。哎，怎么那么不小心啊，明明是这么聪明的人。”杏子长长地叹了口气，语气里充满了惋惜。她又从书架上取下两本书。这次的书不是打印的，而是手写的。封面上用娟秀的字体写着“巴 マミ”，不用说，这是麻美的笔记了。一本是科学研究的记录，一本是组织的经验。</p><p>“幸好她留下来了这两本东西。她以前经常说，要从实践中总结出理论，才不致于人亡事息。没想到‘人亡’得这么快啊……唉。”杏子把这两本笔记放回了书架，接着说：“不过我们两个都不是学理的。小焰上中学的时候学过一点，后来也用得不太熟练，科学实验的笔记是真的看不懂。组织经验的笔记还能照猫画虎继续搞搞，但我们都知道不发展技术，徒有组织是走不远的。那天小福来找我办事，一眼就看到了麻美的实验笔记，她的眼睛里立刻就放着光，问我能不能借回家去看。我当然很开心了，就同意了。我知道小福以前是学工学的，虽然中途辍学了，总比我们这些文科生好得多。”</p><p>“第二天，小福给我们拿来一份文件，题目叫‘实验室操作流程规范’，从怎么不被电烙铁烫到手，到怎么不因为灵魂宝石的崩溃而死，一条一条列得清清楚楚。我请了个施工队，按着她的要求把实验室翻修了一遍。然后她就住进了实验室。我还是有点不放心她的安全，就在实验室寸步不离得陪着她。”</p><p>“大概过了半个月吧，小福终于有了进展。她把自己的灵魂宝石放进系统的卡槽里，大屏幕上竟然显示出来她自己的视野，能随着她的头转动而转动。她说这叫‘感官的流式传输’，现在还只做了视觉。但我们都知道，这是了不起的突破。后来小福给系统加上了存储器，制成了首个记忆芯片，看，就是这个”杏子指着书柜上层的一个水晶展示盒说。盒子里面有一张平平无奇的TF卡。“我们把这个命名为圆环之理 0.5”</p><blockquote><p>……</p><p>我发誓要变得格外善良纯朴，誓和同志分挑患难幸福。</p><p>我要飞快朝那声音奔驰而去，踏上人们没有走过的路。</p><p>……</p></blockquote><p>“再后来，小福做了嗅觉，触觉的流式传输，她又找了个VR设备的公司，把这些数据和VR设备做了适配。过了半年多吧，我们的训练就全进VR了，毕竟在现实世界打魔兽，流程再规范，还是有可能受伤的。这就是圆环之理1.0了。麻美和小焰看出了这里面的商机，就改了改作为游戏发行了，这就是市面上的《圆神》。小焰说这名字和她的一位故交有关。”杏子盯着座椅背后的LED屏幕。</p><p>“这本书也是我们的成果之一”，杏子指着书架上的一本厚厚的书。宪贞走进书架把它抽了出来，封面写着《魔法少女学》。他粗略地翻了翻目录，里面有关于“希望相变焓”、“新人魔法少女心理疏导”、“收割魔兽战斗流程解析”、“灵魂宝石的机械性能”、“灵魂宝石的数据读取方法和数据输入研究”、“利用丘比转发进行的思维共享尝试”、“魔兽诞生机理的几种猜想”等等内容。</p><p>“慢慢的魔法少女活得也越来越久了，也有进社会的，进自卫队的，都有。好在她们都没暴露，都是好孩子啊。”杏子结束了这段讲述，长出了一口气。</p><p>宪贞和杏子都沉默着，只有音乐仍在轻轻唱道：</p><blockquote><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p></blockquote><p>“为什么不能暴露呢？”长长的沉默后，宪贞又提了一个问题。</p><p>“愚问。”杏子眼睛都不眨地回答道，“为什么不能暴露？你说说我们为什么不能暴露？五百年前欧洲人是怎么对待印第安人的？他们还都是人呢，我们连人都不是，他们，或者说，你们能对我们做出什么事来，嗯？”杏子转过身，直直地盯着宪贞。“我们年轻，聪明，漂亮，身体素质强，不会受伤，甚至还会魔法，甚至不用天天吃饭喝水，甚至永远不会老。你猜我们能给社会带来多么巨大的变革？你猜猜你们社会要是发现了我们会做什么？嗯？人类的历史，你我都读过，不用的多说了吧？”</p><p>“不过我相信，我的孩子相信，孩子的孩子相信，终有一天，我们和人类能和谐共处，把酒言欢，同处一片阳光之下。当然，前提是我们能活到那时候。所以我才找到了你，庆田宪贞警官。”杏子坐回了办公椅。</p><p>“你能问出刚才这个问题，也挺好的。至少比那些一看到我们就叫着‘怪物’跑开的人好。其实小福这些年一直都记着你，但是她老害怕你说她是怪物。有你这句话，我就放心了。”杏子又恢复了笑意。</p><p>“小福进来吧！”杏子对着麦克风说。门开了，进来的是那位红色头发，热烈奔放，火一样的少女。现在的福蒂娅没有穿战术装具，只穿了一身水手服，看起来青春烂漫。</p><p>“宪贞...对不起”福蒂娅低下头轻声说。</p><p>宪贞一把把福蒂娅搂在怀里，用手轻轻摸着她那柔顺的头发，一句话也说不出来。</p><p>“你真的老了，胡子扎得我好疼。”福蒂娅在宪贞耳边轻声说，然后从宪贞怀里像小猫一样钻出来，只是手还握在一起。</p><p>“你真傻，为什么不和我说？”宪贞看着福蒂娅的眼睛。</p><p>“我怕……”福蒂娅的脸红了。</p><p>“别怕，我在，我一直都在。”宪贞温柔地回答道。这是暂停了十八年三个月的情愫。</p><p>“咳咳，你俩调情差不多就得了”，杏子在一旁尴尬地说。“庆田警官，我们想拜托你的是，以后帮忙注意一下像这种失踪啊之类的情况，然后给我们也行行方便，有事儿了知会一声。毕竟我们找新魔法少女的手段还不够成熟，将来还要拜托小福呢。”</p><p>宪贞满口答应了下来：“哈哈，那是自然。不过我还是有最后一个问题，您的名字是真名吗？”</p><p>杏子做了个鬼脸：“你猜？”然后她又转向了福蒂娅，说：“虽然我们这还有任务，但是休息也是必须的，你休一个月的假吧，和你的男朋友一起。工资照发，悲叹之种也照发。”杏子笑吟吟地把二人推出了办公室。</p><p>回到座椅上，杏子轻轻地抚摸着办公桌上的一张照片。那是一个穿着白斗篷，蓝衣服的蓝发少女，脸上露出傻傻的憨笑，手上拿着一把西洋剑，海蓝色的灵魂宝石裸露着放在肚脐眼上。</p><p>“你怎么这么傻啊？真是个笨蛋呐……”杏子自言自语道。</p><h2 id="尾声">尾声</h2><p>流浪地球号正在无垠的星空间默默地航行。这个名字是为了致敬五百年前的一位中国科幻作家，在它的笔下，小小的人儿们把地球装上发动机，开到了比邻星的身边。而在这位作家的暮年起航流浪地球号核聚变辐射推进恒星际飞船，也将抵达他笔下的目标：半人马座三星。</p><p>虽然流浪地球号是最早起航的恒星际飞船，但是它一度可能不是最早抵达的。在它启航的一百五十年后，哈珀-摇光光速曲率引擎取得了突破性进展，并在五十年后大规模投入了使用。七十二岁的理查德·哈珀教授，和他的博士生导师，看起来是十七岁少女的李摇光院士出席了首航仪式。哈珀教授在讲话中说，李摇光院士用着十七岁的大脑进行着天马行空般灵动的想象，同时拥有着长达二百年的知识储备和经验沉淀，这让她在科研事业上无往不利。有一句话说“隔行如隔山”，在曲率引擎的研制工作中，李摇光院士从隔着两个喜马拉雅山的完全不同的数学和物理门类中发现了匪夷所思的联系，最终成为了曲率引擎的关键理论基础。在实验遇到瓶颈时，李摇光院士谕示机一般恐怖的直觉也能准确地找出问题出在哪里。面对这样的赞誉，李院士只是笑着摆摆手，说：“熟能生巧而已”。</p><p>一时间，安装着哈珀-摇光引擎的恒星际飞船们像放射线一样，以太阳为中心飞向各种各样的恒星系。最终，人类用二百年的时间，证明了至少在一百光年的半径内，自己在宇宙中是孤独的存在。而其中只有一个星系还没有人染指，那就是离太阳系最近的半人马座三星。“我们要给予我们的先驱者最大限度的尊重”，星际殖民部部长说道，“这尊重就是让她们成为首个完成启航时的目标的人”。</p><p>流浪地球号与以往人们想象中的飞船是不同的，它里面并没有通常意义上的“人”，取而代之的是几个由严密机械保护的鸡蛋大小的宝石。这就是乘员们的灵魂宝石，休眠状态。在日常的航行时，由舰载人工智能自行组织、自行决策，而在飞船遭遇重大事故、或者即将抵达目的地时，才会将这些灵魂宝石唤醒。机械臂从飞船的超低温贮存舱中取出五枚细心保管的空白卵细胞，开始将量子存储器中的DNA序列翻译为脱氧核糖核酸长链，再和同样是打印出来的蛋白质结合后形成染色体，注入细胞核中。</p><p>十七年后，流浪地球号成功泊入了半人马座三星的轨道，五具十七岁少女的身体也在培养皿中日趋成型。机械臂取出灵魂宝石，将其分别靠近对应的身体，少女脸上的眼睛慢慢地出现了光芒。前人追求几百年的人体冬眠技术，以这种看起来离经叛道的原因成为了现实。</p><p>指令长佐仓杏子穿好了舱内航天服，趴在窗前，静静地看着梦了五百年的半人马座三星。这个星系并不像小说家所写的一样处于永恒的混沌之中：中间的两颗和太阳差不多大小的恒星相隔不远地互相绕转，在宇宙中上演着一曲永恒的华尔兹，而比邻星的质量只有太阳的八分之一，在离前两颗恒星1.2万天文单位的圆轨道上缓缓地绕转。这是一个美丽的星系。</p><p>舰载AI发出了提示，在星系中发现了五颗行星，两颗离中心太近，一颗离中心太远，还有一颗落在宜居带中。佐仓杏子指示，首先探索宜居带的那一颗。</p><p>聚变引擎开启，不过输出功率被限制在了很小的范围内，在如此小的输出功率下，人体甚至不会被加速度压坏。飞船静静地向宜居行星飞去，初步分析显示，那是一颗和地球质量类似的岩石行星，拥有大气层，而且在大气层中检测出来了氧气和水蒸气。</p><p>毫无疑问，这说明这颗行星简直就是一个翻版的地球，而它上面，非常有可能存在着生命。</p><p>在随船科学家福蒂娅仔细研读初步分析报告时，舰载AI发现了从那颗行星上面发出的导航电磁波。这么一来，连初步分析报告也没必要看了，星球上存在技术文明是板上钉钉的事。福蒂娅扔下分析报告，开始译解起导航信号来。信号的开头是几组短促的高音，即“2，3，5，7，11，13，17，19”，这是素数序列，昭示着这条电波的主人是技术文明。紧接着，是欧氏平面几何的基本公理和牛顿三定律。就这样，这组信号用最最基本的数学和物理形式构建了一种语言，用来写诗是差了点，但是用作飞船的导航是绰绰有余了。</p><p>飞船已经近到能用肉眼观察行星了。这颗星球有着深蓝色的海洋，浅蓝色的森林和草原，雪白的冰原，悠长的河流，但是唯独少了一样东西：灯光。一个能指导外星飞船降落的文明，为什么夜晚没有灯光呢？</p><p>跟随着引导，飞船的着陆器，以及福蒂娅、晓美焰两位成员缓缓地着陆在了星球表面。这是在一片浅蓝色的草原上，几头不知道是像马还是像河马的动物在水边吃草。在飞船着陆的地表上，有一块黑曜石做成的方碑，上面刻着一些看不懂的文字。</p><p>福蒂娅拿出了从导航信号中提取出来的翻译系统，轻轻念道：“为了忘却的纪念”。</p><p>方碑似乎发现了来人，像一扇门一样打开了。它的下方，是一个隧道。晓美焰和福蒂娅走上了隧道的阶梯。隧道两侧，似乎镌刻着这个文明的历史。他们也有原始时期，有封建领主，有工业革命，当然，也有魔法少女。</p><p>不同于人类在和平时期发现了魔法少女，比邻星文明的魔法少女则亮相于战争年代。这次战争的技术水平略高于人类的第二次世界大战，交战双方都已经掌握了核子武器的使用，但是谁也不敢大面积地轰炸。这时，其中一方的情报组织报告了魔法少女的存在。这条消息转眼间就被间谍送到了对方的案头。它如同炸雷一样引爆了交战双方，他们都意识到了，魔法少女们所蕴含的军事价值，于是紧接着就是大搜捕，年轻的少女们被一个个保家卫国的誓言引诱，对着自己（原本的）同类举起了魔法凝结成的屠刀。</p><p>因为魔法少女的共享心灵特质，旷日持久的战争的天平逐渐翻倒。</p><p>是的，不是倾斜，而是翻倒。战争逐渐从人（我们就把这个文明的主体民族叫做人吧）与人的战争，演变成了人-魔法少女和人-魔法少女的战争，最终则演变成了人类和魔法少女的战争。越来越多的魔法少女们被他们的人类战友视作怪物，越来越多的魔法少女也意识到了战争的目的或许并不像人类所许诺的那样单纯，于是他们慢慢地把枪口对准了彼此。这是一场真正意义上的科技与魔法的较量，一边是超音速战斗机和核子武器，一边是瞬移魔法和时停魔法。</p><p>战争进行了十年，仍然没有结果，只导致天空和大海都变成了黑色，也导致了再也没有人往天空上看一眼。当人们从天文望远镜上发现那颗还有五十年就要正对比邻星的，正从两极发射着死亡的伽马射线的中子星之时，一切已经太晚了。</p><p>五十年很长，正如签订辛丑条约时的中国人不会意识到五十年的时间足以让中国发展出一支把十六国联军抵挡于国门之外的英雄军队。五十年也很短，正如比邻星上可怜的文明发现自己文明的丧钟即将敲响时，它们的英雄飞行员正在忙着朝长得像自己女儿的“异类”少女们投下重磅炸弹，而不是致力于踏上自己行星的月亮。</p><p>战争结束了，没有胜负，只留下了满地的断壁残垣，和一个静静流逝的倒计时。</p><p>核能没有用来驱动辐射引擎，而是用来杀灭了万千生灵。</p><p>当倒计时只剩下十五年的时候，人们才发射了第一颗人造卫星。</p><p>十四年，第一艘载人飞船（不带维生装置的，魔法少女专用）。</p><p>十年，第一支核裂变火箭。</p><p>来不及了！来不及了！！来不及了！！！</p><p>终于，人们停止了所有的努力。是啊，确实来不及了。于是，这座墓穴便被修建了起来，这是整个文明的墓碑。</p><p>5、4、3、2、1......</p><p>伽马射线暴如期，精准地扫过了比邻星和这颗小小行星，行星的整个天空上出现了狂乱鲜红的北极光。但是这并不是这场灾难的终点，而只是这场灾难的序章。在被伽马射线直射后，比邻星加速老化，急速膨胀，在几个小时里走完了几亿年的路，终于，氦闪被点燃了，天空又重新变回了白色，但是红色没有消失，只是转移到了大地上横流的岩浆中。</p><p>人，确实是死完了。但是魔法少女的灵魂宝石，似乎从氦闪中幸存了下来。</p><p>晓美焰和福蒂娅看到这里，不忍继续想下去，因为她们知道将会发生什么。</p><p>纵然灵魂宝石有修复身体的功能，但是面对完全损毁的身体依然无能为力。灵魂宝石们只会消耗魔力，不断化合空气中的碳氢氧，试图组建蛋白质，再组建细胞和菌群，再组建组织，组建器官，最后试图重组人体。但是这一过程实在太复杂，不可能成功。走得最远的，也仅仅到器官这一步。融化的大地上，散落的灵魂宝石周边不断地涌现出几缕肌肉或半个心脏，只是跳动两下就又被熔岩焚毁，而灵魂宝石凭借着强大的机械性能没有被摧毁，依然在忠实地履行着职责，直到全部污浊的那一刻，才能从这永恒的痛苦中解脱。</p><p>百年之后，地面重新凝固，天空重新变成蓝色。这时，最后一颗灵魂宝石也终于耗尽了魔力，或许是因为她生前把守着悲叹之种的仓库，或许是因为着别的原因。它在重组人体的第几千次尝试中失败了，最终只留下了一个心脏、半个骨架和半个肺。</p><p>而现在星球上多姿多彩的生态系统，或许就是这最后一位魔法少女留给行星的最后一件礼物。</p><p>这时，丘比不知道从哪里跳了出来。</p><p>“嘛，孵化总不可能是一帆风顺的。有成功自然有失败，你们地球人还算成功，可是其它文明可能就没这么好运了。这才是孵化者嘛，孵化星际文明的使者。”</p><p>“技术给到手里，怎么用就是自己的事情咯~总之，欢迎你们地球人加入银河系碳基文明联邦啦，我们的总部设在第二悬臂，离你们还挺远的，不过我相信，你们总有一天能到那里去的！”</p><p>“那么，就让我们在某年某月某某有的没的时候再度相见吧！”</p><p>丘比摆了摆尾巴，又消失不见了。</p><p>在轨道上看着直播的佐仓杏子，脑中响起了几百年前她最喜欢的那首有点忧伤的歌曲：</p><blockquote><p>有个声音来自最美好的远处，它在黎明时分含着晨露。</p><p>灿烂的前景令人心驰向往，如同当初美好理想的模样。</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p><p>...</p><p>有个声音来自最美好的远处，她在召唤我去奇妙的国度。</p><p>我听见那声音向我严正发问，我为明天尽些什么义务？</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p><p>...</p><p>我发誓要变得格外善良纯朴，誓和同志分挑患难幸福。</p><p>我要飞快朝那声音奔驰而去，踏上人们没有走过的路。</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p><p>...</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p></blockquote><p>【完】</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科幻</tag>
      
      <tag>同人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我为什么要学习数学</title>
    <link href="/2022/12/30/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6/"/>
    <url>/2022/12/30/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>在这学期，我终于完成了数学二学位的学习，<del>也算是拿到理学学士学位了</del>。借此机会，我想来谈一谈，我，以及我们，为什么要学习数学。我为什么要每周花费8个课时的时间，来搞这个又不加综测又不保研又没有奖的东西呢？</p><p>设想一下，我们初中的课本是这样介绍三角函数的：</p><blockquote><p>【三角函数】亲爱的小朋友们，我们今天来介绍三角函数。首先，我们来给出三角函数的定义： <span class="math display">\[\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdots\]</span></p><p><span class="math display">\[\cos x = 1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots\]</span></p><p>我们管这样的函数叫做三角函数，小朋友们学会了吗？接下来，我们做几个练习题巩固一下吧！</p><p>【练习1】计算以下三角函数的数值</p><ol type="1"><li><span class="math inline">\(\sin 1\)</span></li><li><span class="math inline">\(\sin 10\)</span></li><li><span class="math inline">\(\sin \frac \pi 2\)</span></li><li><span class="math inline">\(\cos 17.25\)</span></li><li><span class="math inline">\(\cos 3.14159\)</span></li></ol></blockquote><p>于是，我学了一学期的“三角函数”，知道了各种求多项式加法的技巧，我还会根据周期性调整自变量的值，经过海量的练习，已经能在一分钟以内算出五位小数的三角函数数值了，我已经神功大成，是三角函数大师了！直到我接触到了一门名叫“物理”的科目，里面赫然出现了这么一张图：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212301736742.png" alt="力的正交分解" style="zoom:50%;" /></p><p>我一看到我最熟悉的<span class="math inline">\(\sin ,\cos\)</span>，整个就是一个大惊喜，这不是我最会算的三角函数吗？可是，我又马上蒙蔽了：为什么<span class="math inline">\(F_x=F\cos \theta\)</span>呢？难道说 <span class="math display">\[F_x=F-\frac{F\theta^2}{2!}+\frac{F\theta^4}{4!}-\frac{F\theta^6}{6!}+\cdots\]</span> 是成立的吗？为什么这两个力线的夹角的数值能被塞进一个长得这么奇怪的多项式里面呢？啊，大自然多么的神奇啊！总之我只管记住就行了。可是，我在日后的学习中，在各个地方总是摆脱不了这两个神秘多项式的魅影，渐渐的，我开始感觉到奇怪：为什么大自然就这么不约而同地把这些值设置成 <span class="math display">\[x-\frac{x^3}{6}+\frac{x^5}{120}-\frac{x^7}{5040}+\cdots\]</span> 这些系数真的这么刚好吗？为什么不是 <span class="math display">\[x-\frac{x^{3.1}}{5.7}+\frac{x^{4.8}}{119.98}-\frac{x^{7.2}}{5040.01}+\cdots\]</span> 呢？</p><hr /><p>网上有句话说：“不学数理化，生活处处是魔法”。上面这个例子看起来似乎非常地奇幻，但是它是真实发生的，不过它的主角不是“三角函数”，而是“行列式”。在进入大学的第一个月，我就接触了这个叫做“行列式”的魅影，以及它的逆序数、求和......看起来似乎非常的简单，完全只用到了加减乘除（正如前面的“三角函数”一样），然后我又学会了各种花式计算行列式的办法。但是，我渐渐地发现了，“行列式”这个玩意似乎无处不在，它的魅影笼罩在了许多地方，比如说，为什么我把一个方程的系数像这样加加乘乘，它就能说明这个方程的解的情况呢？</p><p>这个问题一直困惑着我，直到有一天我发现平行四边形的面积的计算方法和<span class="math inline">\(ad-bc\)</span>好像，有那么点关系。那么三维度的平行六面体，以至于多维的超立方体是不是也有这样的关系？为什么那些数字加加乘乘就能判断矩阵的秩序？因为向量们张成的空间的体积如果是零，它们自然线性相关了。在发现这一点以后，我有一种像“任督二脉被打通”一般的强烈的快感，正所谓：</p><blockquote><p>洞天石扉，訇然中开</p></blockquote><p>在发现了方程、向量、超矩体之间的关系以后，我第一次感到了“数学”这门学科的魅力，这是那种“看似毫不相干的事物却通过某种关系紧紧绑缚在一起”的感觉。同时，我也预见到了自己未来的无知：现在我可以灵光一现想到这些东西，但是我这人并不聪明，没有那么多灵光，将来如果继续遇到无数地这些“三角函数”或者“行列式”，怎么办呢？我是不是要继续再这些“换一个方向就很简单”的问题上再花那么多时间和精力呢？</p><p>后来，我在刷B站的时候，又看到了一些讲数学的UP主（其中以“3Blue1Brown”为代表），这更加提升了我对于数学这门学科的热情。</p><p>通过三年多的学习，我也确实从一门又一门的课程中学习到了很多东西。从在各专业课中被频繁使用的常微分方程，到以“抽象”为名且名副其实的抽象代数；从联系了分析、代数、拓扑三大领域的“实变函数与泛函分析”，到和生活紧密相关的数学建模、数理统计和运筹学：数学二学位的学习开阔了我的眼界，满足了我对数学学科的兴趣，反哺了主专业课程的学习，更使我在生活中多了一份应用数学的头脑。</p><p>我再举一个例子吧，比如说傅里叶变换 <span class="math display">\[F(\omega)=\int_{-\infty}^{\infty}f(t)e^{-i\omega t}dt\]</span> 为什么帕塞瓦尔定理是成立的呢？说一句“能量守恒”，似乎有点干巴巴。可是如果把函数看作是一个空间中的向量，傅里叶变换不过是把这个函数换了一个标准正交基来描述，帕塞瓦尔定理的成立就非常显然了——因为它似乎有一个我们更亲切的别名：勾股定理。</p><p>数学在我们的生活中，看似是不在任何地方（毕竟，“买菜不用微积分”），但是同时又无处不在。贝叶斯推断能使我们对事物进行更加准确的判断和预测，数理统计的知识能让我不再对浩如烟海的统计数据感到畏惧，从而从数据中发掘更深层次的真相，运筹学也能从理论层面指导我在两难时作出抉择。</p><p>以上就是我参加数学辅修学位的根本原因，以及学习了三年以来的收获。虽然课程结束了，学习却永无止境，我们且学且珍惜吧。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·滤波器之章</title>
    <link href="/2022/12/24/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%C2%B7%E6%BB%A4%E6%B3%A2%E5%99%A8%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/24/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%C2%B7%E6%BB%A4%E6%B3%A2%E5%99%A8%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="数字滤波器设计">数字滤波器设计</h2><p>数字滤波器设计是通过幅频响应<span class="math inline">\(|H(e^{j\omega})|\)</span>设计系统函数<span class="math inline">\(H(z)\)</span>，在数字系统中编程实现。利用模拟滤波器设计数字滤波器，就是要寻求某种映射，把<span class="math inline">\(s\)</span>平面映射到<span class="math inline">\(z\)</span>平面，为了因果稳定性，这个映射应该满足以下两个条件：</p><ol type="1"><li><span class="math inline">\(s\)</span>平面的虚轴<span class="math inline">\(j\Omega\)</span>映射为<span class="math inline">\(z\)</span>平面的单位圆</li><li><span class="math inline">\(s\)</span>平面的左半平面映射为<span class="math inline">\(z\)</span>平面的单位圆内</li></ol><h3 id="冲激响应不变法设计iir滤波器">冲激响应不变法设计IIR滤波器</h3><p>冲激响应不变法的根本思想是从系统的冲激响应出发，保证数字系统的冲激响应是模拟系统的冲激响应的采样，即： <span class="math display">\[h[n]=h_c(t)|_{t=nT_s}=h_c(nT_s)\]</span> 其中<span class="math inline">\(T_s\)</span>是采样周期。</p><p>对模拟系统冲激响应进行理想采样，有： <span class="math display">\[h_s(t)=\sum_{n=-\infty}^{\infty} h_c\left(n T_s\right) \delta\left(t-n T_{\mathrm{s}}\right)\]</span> 其拉普拉斯变换为： <span class="math display">\[H_s(s)=\sum_{n=-\infty}^\infty h[n]e^{-snT_s}\]</span> 数字系统冲激响应的<span class="math inline">\(z\)</span>变换为： <span class="math display">\[H(z)=\sum_{n=-\infty}^\infty h[n]z^{-n}\]</span> 所以，有： <span class="math display">\[H_s(s)=H(z)|_{z=e^{sT_s}}\]</span> 把模拟信号的拉普拉斯变换在<span class="math inline">\(s\)</span>平面上沿着虚轴以<span class="math inline">\(\Omega_s=2\pi/T_s\)</span>为周期进行周期延拓后，按照<span class="math inline">\(z=e^{sT_s}\)</span>，即<span class="math inline">\(s=\ln z/T_s\)</span>的规则替换变元，即可得到<span class="math inline">\(H(z)\)</span>。需要注意，和<span class="math inline">\(H(z)\)</span>有关的并不是一开始的系统函数<span class="math inline">\(H(s)\)</span>，而是它周期延拓后的结果<span class="math inline">\(H_s(s)\)</span>，如果只知道系统函数，那么要么从冲激响应的路径解决问题，要么先进行周期延拓。</p><p>这个映射可以保证把<span class="math inline">\(s\)</span>左半平面映射到<span class="math inline">\(z\)</span>平面单位圆的内部，保证稳定的模拟滤波器能变换出稳定的数字滤波器。</p><p>因为上述过程中存在周期延拓，因此需要保证模拟滤波器是带限的，但是实际上这并不可能做到，因此用冲激响应不变法必定产生频域混叠。</p><blockquote><p>【例】现有系统： <span class="math display">\[H_c(s)=\sum_{k=1}^N \frac{A_k}{s-s_k}\]</span> 用冲激响应不变法设计数字滤波器，求其<span class="math inline">\(H(z)\)</span></p><p>【解】对系统函数作反变换，得冲激响应： <span class="math display">\[h_c(t)=\sum_{k=1}^N A_ke^{s_kt}u(t)\]</span> 采样，得： <span class="math display">\[h_s[n]=\sum_{k=1}^N T_n A_k\left(\mathrm{e}^{s_k T}\right)^n \mathrm{u}[n]\]</span> 作<span class="math inline">\(z\)</span>变换，得： <span class="math display">\[H(z)=\sum_{k=1}^N \frac{T_s A_k}{1-\mathrm{e}^{s_k T_s} z^{-1}}\]</span></p></blockquote><p>观察上例，<span class="math inline">\(s=s_k\)</span>处的极点变换成Z平面中<span class="math inline">\(e^{s_kT_s}\)</span>处的极点，所以左半S平面的极点可以映射到Z平面的单位圆内；但离散时间系统函数中的零点是部分分式展开式中的极点和系数的函数，通常并不按照与极点相同的方式进行映射，因此冲激响应不变法<strong>不能保证最小相位系统映射后的仍然是最小相位系统。</strong></p><h3 id="双线性变换法设计iir滤波器">双线性变换法设计IIR滤波器</h3><p>为了解决冲激响应不变法的频域混叠现象，需要研究双线性变换法。双线性变换法有两步：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241124288.png" alt="双线性变换法过程示意图" /><figcaption aria-hidden="true">双线性变换法过程示意图</figcaption></figure><p>第一步，把<span class="math inline">\(s\)</span>平面的<span class="math inline">\(j\Omega\)</span>轴压缩到<span class="math inline">\(s_1\)</span>平面的<span class="math inline">\(j\Omega_1\)</span>轴<span class="math inline">\([-\pi/T_s,\pi/T_s]\)</span>的一段。可以通过正切变换，即： <span class="math display">\[\Omega=c\tan \frac{\Omega_1T_s}{2}\]</span> 把这个关系拓展到整个<span class="math inline">\(s,s_1\)</span>平面，有： <span class="math display">\[s=\frac{2}{T_s}\frac{1-\mathrm{e}^{-s_1 T_s}}{1+\mathrm{e}^{-s_1 T_s}}=\frac{2}{T_{\mathrm{s}}} \tanh \frac{s_1 T_{s}}{2}\]</span> 再通过<span class="math inline">\(z=e^{s_1T_s}\)</span>变换到<span class="math inline">\(z\)</span>平面，有： <span class="math display">\[s=\frac 2{T_s}\frac{1-z^{-1}}{1+z^{-1}}\]</span> 或者说， <span class="math display">\[z=\frac{1+(T_s/2)s}{1-(T_s/2)s}\]</span> 如果<span class="math inline">\(z=re^{j\omega},s=\sigma+j\Omega\)</span>，有： <span class="math display">\[\begin{gathered}r=\left[\frac{\left(2 / T_{\mathrm{s}}+\sigma\right)^2+\Omega^2}{\left(2 / T_{\mathrm{s}}-\sigma\right)^2+\Omega^2}\right] \\\omega=\arctan \frac{\Omega}{2 / T_{\mathrm{s}}+\sigma}+\arctan \frac{\Omega}{2 / T_{s}-\sigma}\end{gathered}\]</span> 因为变换的过程中频率产生了畸变，所以设计时可以进行“预畸变”，根据 <span class="math display">\[\Omega=\frac{2}{T_s}\tan\frac{\omega}{2}\]</span> 双线性变换的零极点是按照同种方式映射的，因此可以保证最小相位、全通性质在映射前后不变。而且它完全规避了频域混叠，生成的离散滤波器和连续滤波器有一一对应的关系，这一点也是和冲激响应不变法不同的。</p><h3 id="窗函数法设计fir滤波器">窗函数法设计FIR滤波器</h3><h4 id="基本原理">基本原理</h4><p>FIR滤波器的设计任务是，选择有限长度的单位脉冲响应<span class="math inline">\(h[n]\)</span>，使得系统的频响<span class="math inline">\(H(e^{j\omega})\)</span>满足技术要求。</p><p>窗函数法的基本思想是，首先对理想零相位低通滤波器，画出其单位脉冲响应<span class="math inline">\(h[n]\)</span>（应该是一个偶序列），如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241411935.png" /></p><p>现在把这个<span class="math inline">\(h[n]\)</span>向右移动<span class="math inline">\(M/2\)</span>位，变成<span class="math inline">\(h[n-M/2]\)</span>，然后加一个窗函数<span class="math inline">\(w[n]=R_M[n]\)</span>，形成如下图所示的序列<span class="math inline">\(h_d[n]\)</span>：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241413206.png" /></p><p>由此可见，因果可实现的FIR系统的幅度函数<span class="math inline">\(|H(e^{j\omega})|\)</span>是理想滤波器的幅度函数和窗函数<span class="math inline">\(w[n]\)</span>的幅度函数<span class="math inline">\(W_g(e^{j\omega})\)</span>的卷积，而其相频响应来自于位移所产生的<span class="math inline">\(e^{-j\frac{\omega M}{2}}\)</span>.有以下结论：</p><ol type="1"><li>窗函数旁瓣影响通带内波纹</li><li>窗函数旁瓣影响阻带内波纹</li><li>主瓣宽度影响过渡带宽度</li><li>增加窗的长度可以减小主瓣宽度，从而减小过渡带，但是不能改变肩峰的相对值</li></ol><h4 id="常用窗函数">常用窗函数</h4><ol type="1"><li><p>矩形窗 <span class="math display">\[w[n]=R_M[n]\]</span></p><table><thead><tr class="header"><th style="text-align: center;">主瓣宽度</th><th style="text-align: center;">旁瓣峰值</th><th style="text-align: center;">过渡带宽度</th><th style="text-align: center;">通带阻带波纹最大起伏</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\frac{4\pi}{M+1}\)</span></td><td style="text-align: center;">-13dB</td><td style="text-align: center;"><span class="math inline">\(\frac{1.8\pi}{M+1}\)</span></td><td style="text-align: center;">-21dB</td></tr></tbody></table><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241445619.png" alt="矩形窗" style="zoom:50%;" /></p></li><li><p>Barlett窗 <span class="math display">\[w[n]= \begin{cases}2 n / M, &amp; 0 \leqslant n \leqslant M / 2 \\ 2-2 n / M, &amp; M / 2&lt;n \leqslant M \\ 0, &amp; \text {others}\end{cases}\]</span></p><table><thead><tr class="header"><th style="text-align: center;">主瓣宽度</th><th style="text-align: center;">旁瓣峰值</th><th style="text-align: center;">过渡带宽度</th><th style="text-align: center;">通带阻带波纹最大起伏</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\frac{8\pi}{M+1}\)</span></td><td style="text-align: center;">-25dB</td><td style="text-align: center;"><span class="math inline">\(\frac{4.1\pi}{M+1}\)</span></td><td style="text-align: center;">-25dB</td></tr></tbody></table><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241449010.png" alt="Barlett窗" style="zoom:50%;" /></p></li><li><p>Hanning窗 <span class="math display">\[w[n]= \begin{cases}0.5-0.5 \cos (2 \pi n / M), &amp; 0 \leqslant n \leqslant M \\ 0, &amp; \text {others}\end{cases}\]</span> | 主瓣宽度 | 旁瓣峰值 | 过渡带宽度 | 通带阻带波纹最大起伏 | | :----------------: | :------: | :------------------: | :------------------: | | <span class="math inline">\(\frac{8\pi}{M+1}\)</span> | -41dB | <span class="math inline">\(\frac{6.2\pi}{M+1}\)</span> | -44dB |</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241452792.png" alt="Hanning窗" style="zoom:50%;" /></p><p>它能使能量更有效地集中在主瓣，但主瓣更长</p></li><li><p>Kaiser窗 <span class="math display">\[w[n]= \begin{cases}\frac{I_0\left[\beta\left(1-[(n-\alpha) / \alpha]^2\right)^{\frac{1}{2}}\right]}{I_0(\beta)}, &amp; 0 \leqslant n \leqslant M \\ 0, &amp; \text {others}\end{cases}\]</span> 其中 <span class="math display">\[\beta= \begin{cases}0.1102(A-8.7), &amp; A&gt;50 \\ 0.5842(A-21)^{0.4}+0.07886(A-21), &amp; 21 \leqslant A \leqslant 50 \\ 0, &amp; A&lt;21\end{cases}\]</span></p><p><span class="math display">\[\begin{align}\alpha&amp;=\frac M2\\M&amp;=\frac{A-8}{2.285(\omega_s-\omega_p)}\\A&amp;=-20\lg \min\{\delta_1,\delta_2\}\end{align}\]</span></p><p><span class="math inline">\(I_0\)</span>是第一类零阶修正贝塞尔函数。于是，得到的因果滤波器为： <span class="math display">\[h_{\text {lpd }}[n]=\frac{\sin \left[\omega_c(n-M / 2)\right]}{\pi(n-M / 2)} w[n]\]</span> 其中 <span class="math display">\[\omega_c=\frac{\omega_s+\omega_p}{2}\]</span></p></li></ol><h3 id="频率采样法设计fir滤波器">频率采样法设计FIR滤波器</h3><p>这个方法的思想是，根据给定的性能确定系统的频响，然后频响进行采样得到采样值<span class="math inline">\(H[k]\)</span>，对其进行IDFT得到<span class="math inline">\(h[n]\)</span>。具体来说，步骤如下：</p><ol type="1"><li><p>根据阻带最小衰减选择过渡带采样点数<span class="math inline">\(m\)</span></p><p>有<span class="math inline">\(A=-20\lg\delta \mathrm{ dB}\)</span>，根据表：</p><table><thead><tr class="header"><th>过渡带采样点数</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td>阻带衰减/dB</td><td>44-54</td><td>54-75</td><td>85-95</td></tr></tbody></table><p>选择<span class="math inline">\(m\)</span></p></li><li><p>确定过渡带宽度<span class="math inline">\(\Delta \omega=\omega_s-\omega_p\)</span>，根据 <span class="math display">\[\Delta \omega \geq \frac{2\pi(m+1)}{M+1}\]</span> 确定滤波器长度<span class="math inline">\(M+1\)</span></p></li><li><p>根据待设计滤波器的性能指标，确定是第几类广义线性相位系统，有以下规则：</p><ul><li><span class="math inline">\(M\)</span>是偶数那么在I、III中选，否则在II、IV中选</li><li>第I类可做各种滤波器，第II类可做低通带通、第III类可做带通、第IV类可做高通带阻</li></ul></li><li><p>确定理想滤波器的幅频<span class="math inline">\(A(e^{j\omega})\)</span>，相频<span class="math inline">\(e^{j(\beta-\alpha \omega)}\)</span></p></li><li><p>对频响进行采样，对于不同的广义线性相位系统，有以下公式成立：</p><ol type="1"><li><p>第I类，<span class="math inline">\(M\)</span>是偶数，<span class="math inline">\(\beta=0\ or\ \pi\)</span> <span class="math display">\[H[k]= \begin{cases}A[k] \mathrm{e}^{-j \frac{M\pi k}{M+1}}, &amp; k \in\left[0, \frac{M}{2}\right] \\ H^*[M+1-k], &amp; k \in\left[\frac{M}{2}+1, M\right]\end{cases}\]</span></p></li><li><p>第II类，M是奇数，<span class="math inline">\(\beta = 0\ or\ \pi\)</span> <span class="math display">\[H[k]= \begin{cases}A[k] \mathrm{e}^{-j \frac{M\pi k}{M+1}}, &amp; k \in\left[0, \frac{M-1}{2}\right] \\ 0, &amp; k=\frac{M+1}{2} \\ H^*[M+1-k], &amp; k \in\left[\frac{M+3}{2}, M\right]\end{cases}\]</span></p></li><li><p>第III类，M是偶数。<span class="math inline">\(\beta = \pi/2 \ or \ 3\pi/2\)</span> <span class="math display">\[H[k]= \begin{cases}0, &amp; k=0 \\{jA}[k] \mathrm{e}^{-j\frac{M\pi k}{M+1}},&amp; k \in\left[1, \frac{M}{2}\right] \\ H^*[M+1-k], &amp; k \in\left[\frac{M}{2}+1, M\right]\end{cases}\]</span></p></li><li><p>第IV类，M是奇数，<span class="math inline">\(\beta = \pi/2 \ or \ 3\pi/2\)</span> <span class="math display">\[H[k]= \begin{cases}0, &amp; k=0 \\ {jA}[k] \mathrm{e}^{-j\frac{M\pi k}{M+1}}, &amp; k \in\left[1, \frac{M+1}{2}\right] \\ H^*[M+1-k], &amp; k \in\left[\frac{M+3}{2}, M\right]\end{cases}\]</span></p></li></ol></li><li><p>求<span class="math inline">\(H[k]\)</span>的<span class="math inline">\(M+1\)</span>点IDFT，得到<span class="math inline">\(h[n]\)</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路·组合与时序之章</title>
    <link href="/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E7%BB%84%E5%90%88%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E7%BB%84%E5%90%88%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="组合逻辑电路">组合逻辑电路</h2><h3 id="设计分析">设计分析</h3><p>略，无非是列功能表、真值表、画卡诺图、化简、转换形式、连电路。</p><h3 id="经典组合逻辑电路模块">经典组合逻辑电路模块</h3><h4 id="编码器">编码器</h4><ul><li><p>8（位）-3（线）编码器</p><p>其基本功能是输入8位中的一位表示被编码的十进制数，3条输出线表示这个十进制数的二进制形式。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162058622.png" alt="83编码器功能表" /><figcaption aria-hidden="true">83编码器功能表</figcaption></figure></li><li><p>优先编码器</p><p>相比于83编码器，优先编码器的输出取决于最高为1的那一位。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162100464.png" alt="优先编码器功能表" /><figcaption aria-hidden="true">优先编码器功能表</figcaption></figure></li><li><p>74HC148优先编码器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162102678.png" alt="电路图" /><figcaption aria-hidden="true">电路图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162102372.png" alt="逻辑符号" /><figcaption aria-hidden="true">逻辑符号</figcaption></figure><p>其中的<span class="math inline">\(A_i,Y_i\)</span>是完成基本功能的输入输出端，此外，它还有一些其它的端口，能进行扩展功能：</p><ul><li><span class="math inline">\(\overline S\)</span>选通输入端，当且仅当<span class="math inline">\(\overline S=0\)</span>，电路正常工作，否则，所有输出都被封锁在高电平。</li><li><span class="math inline">\(\overline {Y_S}\)</span>选通输出端，当它为0时表示：电路工作但无编码输入</li><li><span class="math inline">\(\overline {Y_{EX}}\)</span>扩展输出端，它为0时表示：电路工作且有编码输入</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162110457.png" alt="74HC148功能表" /><figcaption aria-hidden="true">74HC148功能表</figcaption></figure></li></ul><h4 id="译码器">译码器</h4><p>译码器就是编码器的逆，输入三个信号表示一个二进制数，输出八个信号中的一个表示那个二进制数的十进制表示。</p><p>常用的译码器是74138译码器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162113986.png" alt="74138逻辑图" /><figcaption aria-hidden="true">74138逻辑图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162114347.png" alt="功能表" /><figcaption aria-hidden="true">功能表</figcaption></figure><p>它有三个附加控制器：<span class="math inline">\(S_1,\overline S_{2},\overline S_3\)</span>。当<span class="math inline">\(S_1=1,\overline S_{2}=\overline S_3=0\)</span>时，电路正常工作，否则，所有输出端为高电平。</p><p>使用多个译码器进行串接时，往往可以在第二个译码器上对高位取反，以此来达到串联效果。</p><h4 id="数据选择器">数据选择器</h4><p>数据选择器有若干个输入信号，一个选择信号（可能有多位）和一个输出。由选择信号决定输出接哪个输入信号。</p><p>常用的数据选择器是74HC153双四选一数据选择器。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162121574.png" alt="74HC153逻辑图" /><figcaption aria-hidden="true">74HC153逻辑图</figcaption></figure><p>其中<span class="math inline">\(D\)</span>表示输入信号，<span class="math inline">\(A_1A_0\)</span>共同表示一个二进制数，是选择信号，<span class="math inline">\(Y\)</span>是输出信号，<span class="math inline">\(S\)</span>是选通输入端。有时候我们只用单四选一，这时候把其它管脚留空即可，但是不能把这个片劈成两半。</p><h4 id="数值比较器">数值比较器</h4><p>略，没啥说的，都差不多。</p><p>常用的数值比较器是7485数值比较器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162137127.png" alt="7485逻辑图" /><figcaption aria-hidden="true">7485逻辑图</figcaption></figure><p>其中<span class="math inline">\(A,B\)</span>是待比较的数值，<span class="math inline">\(F\)</span>是输出。而<span class="math inline">\(I\)</span>则是当数值比较器扩展时，来自低位的比较结果。比如说，要实现八位数值的比较，我们可以这样级联：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162139534.png" alt="数值比较器扩展" /><figcaption aria-hidden="true">数值比较器扩展</figcaption></figure><p>首先比较高四位。如果高四位出现了不同，那么自然可以直接输出。如果高四位相同，那么就需要另接入一个数值比较器来比较下四位，然后把下四位的比较结果通过<span class="math inline">\(I\)</span>端反馈到高位的比较器，再由负责高位的比较器来输出最终的结果。</p><p>也就是说，当<span class="math inline">\(AB\)</span>不相等时，输出和<span class="math inline">\(I\)</span>无关，直接输出<span class="math inline">\(AB\)</span>的关系，否则，直接输出<span class="math inline">\(I\)</span>。</p><h4 id="加法器">加法器</h4><p>全加器有三个输入<span class="math inline">\(A,B,CI\)</span>，其中<span class="math inline">\(AB\)</span>表示两个加数，<span class="math inline">\(CI\)</span>表示上个全加器产生的进位信号。有两个输出：<span class="math inline">\(S,CO\)</span>，<span class="math inline">\(S\)</span>表示和，<span class="math inline">\(CO\)</span>表示有无进位。</p><p>这个功能很简单就能描述：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> &#123;CO,S&#125;=A+B+CI<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162127862.png" alt="全加器功能表" /><figcaption aria-hidden="true">全加器功能表</figcaption></figure><h2 id="半导体存储电路">半导体存储电路</h2><p>基本的半导体存储电路有锁存器、触发器、寄存器、存储器等。其中触发器可按结构分为基本、同步、主从、边沿触发器，按触发方式分为电平、脉冲、脉冲边沿触发器，按逻辑功能分为RS、JK、D和T触发器等。</p><h3 id="sr锁存器">SR锁存器</h3><p>SR锁存器是最基本的半导体存储电路。一般来说，我们所谓的锁存器，都指的是SR锁存器。其电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271054295.png" alt="或非门SR锁存器" /><figcaption aria-hidden="true">或非门SR锁存器</figcaption></figure><p>由于或非门可以被“锁定”的特性，这个电路具有了锁存的功能。其状态转移图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271052715.png" alt="image-20221127105256632" /><figcaption aria-hidden="true">image-20221127105256632</figcaption></figure><p>状态方程如下： <span class="math display">\[\left\{\begin{array}{c}Q^{n+1}=S_{\mathrm{D}}+\overline{R_{\mathrm{D}}} \cdot Q^n \\R_{\mathrm{D}} S_{\mathrm{D}} \equiv 0\end{array}\right.\]</span> 状态表如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271107647.png" alt="或非门SR锁存器状态表" /><figcaption aria-hidden="true">或非门SR锁存器状态表</figcaption></figure><p>状态转移图、状态方程、状态表，说的都是一件事，那就是这个元件的状态如何变化。在SR触发器中，记住状态表是最高效的分析方法。</p><p>在状态表中，我们观察最后两行，这是状态转移图和状态方程中没有考虑到的。这里的“不定”有两种含义。第一种，当电路正常工作时，如果施加<span class="math inline">\(S_D=1,R_D=1\)</span>的输入，会有<span class="math inline">\(Q=\overline{Q}=0\)</span>的状态，这既<strong>不</strong>是<strong>定</strong>义的“1”状态，也<strong>不</strong>是<strong>定</strong>义的“0”状态，所以叫“<strong>不定</strong>”。第二种是，当电路本来就是上一个状态时，如果同时把<span class="math inline">\(S,R\)</span>置<span class="math inline">\(0\)</span>，那么电路的输出状态<strong>不</strong>能确<strong>定</strong>（这个照着电路图推一推就明白了），于是叫做“<strong>不定</strong>”。</p><p>观察状态转换方法，我们有时将<span class="math inline">\(S_D\)</span>叫做“直接置位端”，意思是直接把状态置为1；将<span class="math inline">\(R_D\)</span>叫做“直接复位端”，意思是把状态复位为0，于是这个电路叫做“Ser-Reser Latch”，即“SR锁存器”。</p><p>SR锁存器也可以用与非门构造，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271115837.png" alt="与非门SR锁存器" /><figcaption aria-hidden="true">与非门SR锁存器</figcaption></figure><p>不同的是，这里的<span class="math inline">\(S_D,R_D\)</span>都变成了低电平有效。</p><h3 id="触发器">触发器</h3><h4 id="电平触发">电平触发</h4><p>电平触发的意思，就是当且仅当<code>clk</code>信号是有效信号时，触发器的输出状态随着输入信号变化。如果不是有效信号，则保持之前的输出状态。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271609270.png" alt="电平触发SR触发器" /><figcaption aria-hidden="true">电平触发SR触发器</figcaption></figure><p>电平触发有时会因为一些短暂的噪声而影响整个输出，因此我们要考虑其它触发方式</p><h4 id="脉冲触发">脉冲触发</h4><p>首先来考虑主从SR触发器（也叫“脉冲触发的SR触发器”）。主从SR触发器的结构和符号如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271644991.png" alt="主从SR触发器" /><figcaption aria-hidden="true">主从SR触发器</figcaption></figure><p>可以看出，一个脉冲触发的SR触发器，是由两个电平触发的SR触发器接成的。<span class="math inline">\(FF_1\)</span>叫主触发器，<span class="math inline">\(FF_2\)</span>叫从触发器，主触发器的输出直接接入从触发器的输入。在分析时，应该在高电平先对<span class="math inline">\(Q_1\)</span>进行分析，之后，再在低电平（注意，从触发器接的时钟信号是翻转的）对<span class="math inline">\(Q\)</span>进行分析。显然，主触发器在一个高电平时间段内，可以随着输入信号的变化而翻转多次。</p><p>接下来我们考虑JK触发器。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272038848.png" alt="JK触发器" /><figcaption aria-hidden="true">JK触发器</figcaption></figure><p>这里在输出端和输入端之间接了一个反馈。即： <span class="math display">\[S=\overline{Q}J,R=QK\]</span> 带入，有： <span class="math display">\[Q^{n+1}=J \cdot \overline{Q^n}+\overline{K} \cdot Q^n\]</span> 这就是JK触发器的状态转移方程，可以写出状态转移图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272045222.png" alt="JK触发器的状态转移图" /><figcaption aria-hidden="true">JK触发器的状态转移图</figcaption></figure><p>状态表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272106517.png" alt="JK触发器状态表" /><figcaption aria-hidden="true">JK触发器状态表</figcaption></figure><p>接下来，我们讨论一下JK触发器是怎么进行状态转移的。JK的主触发器仍然是一个电平触发的SR触发器，但是由于JK触发器的反馈机制，当<span class="math inline">\(Q=0\)</span>时，因为<span class="math inline">\(R=QK=0\)</span>，主触发器只能接受“置1输入信号”；当<span class="math inline">\(Q=1\)</span>时，因为<span class="math inline">\(S=\overline QJ=0\)</span>，主触发器只能接受“置0（复位）输入信号”，所以这个主触发器在<span class="math inline">\(CLK=1\)</span>期间至多翻转一次，这就是所谓的“JK触发器的一次性变化现象”。</p><p>于是，我们可以知道所谓“脉冲触发”到底是什么意思。</p><ol type="1"><li>触发器的翻转分两步动作，首先，在<span class="math inline">\(CLK=1\)</span>时，主触发器接收输入信号，进行动作，而从触发器不动。第二步，<span class="math inline">\(CLK=1\)</span>的信号消失时（有的人把这个动作表述为“下降沿来临时”），从触发器根据主触发器的状态进行动作。由于输出信号是从触发器的输出信号，我们看起来，脉冲触发的触发器进行动作总是发生在<span class="math inline">\(CLK\)</span>信号的下降沿。</li><li>主触发器本来是一个电平触发的SR触发器，所以在<span class="math inline">\(CLK=1\)</span>的全部时间，输入信号都会对主触发器起作用。</li></ol><h4 id="边沿触发">边沿触发</h4><p>边沿触发是最简单的，它的次态仅仅取决与<span class="math inline">\(CLK\)</span>信号的上升沿或下降沿来临的瞬间，输入信号的状态。在分析时，只用对触发的边沿那几个有限的点进行分析就行了。</p><h4 id="按逻辑功能的分类">按逻辑功能的分类</h4><p>SR触发器和JK触发器的逻辑功能前面已经讲了。接下来介绍两种其它的触发器：</p><ol type="1"><li><p>T触发器</p><p>T触发器的功能简单来说是：“0保持，1取反”，即： <span class="math display">\[Q^{n+1}=T\overline{Q}+\overline{T}Q\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(T\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(Q^{n+1}\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>0</td></tr></tbody></table></li><li><p>D触发器</p><p>D触发器的功能简单来说是：“延迟一位”，即： <span class="math display">\[Q^{n+1}=D\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(D\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(Q^{n+1}\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table></li></ol><h3 id="存储器">存储器</h3><p>首先明确一个概念：怎么表达一个存储器的大小呢？书上说：“通常写成（字数）x（每个字的位数）”的形式。什么是字？字就是这个存储器输出的东西。存储器每读入一个地址，就会输出一个01串，这个01串就是一个“字”，这个01串的长度就是“每个字的位数”。那么有人说，假设每个字的位数是<span class="math inline">\(n\)</span>，那么字数难道不会自动是<span class="math inline">\(2^n\)</span>吗？不是这样的。因为我们可以在不同的地址里存相同的字，也可以不在存储器中存储所有字，这是显而易见的。存储器的每个地址中存法一个字，所以所谓的“字数”其实是有效的地址数。</p><h4 id="随机存取存储器ram">随机存取存储器RAM</h4><p>可以随时从任何一个指定的地址读出数据，也可以随时将数据写入任何一个指定的存储单元中去，但是掉电后数据会丢失。其基本结构如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272202657.png" alt="RAM结构" /><figcaption aria-hidden="true">RAM结构</figcaption></figure><h4 id="只读存储器rom">只读存储器ROM</h4><p>ROM的基本结构如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272204218.png" alt="ROM" /><figcaption aria-hidden="true">ROM</figcaption></figure><p>我们可以考察一下二极管ROM的详细结构。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272205218.png" alt="二极管ROM" /><figcaption aria-hidden="true">二极管ROM</figcaption></figure><p>在地址译码器中，看纵列，每个纵列构成了一个二极管与门。于是： <span class="math display">\[\begin{aligned}W_0=\overline{A_0}\ \overline{A_1}\\W_1=A_0 \overline{A_1}\\W_2=\overline{A_0}A_1\\W_3=A_0A_1\end{aligned}\]</span> 这样一来，就实现了一个译码器，这就是地址译码器。它将输入的二位二进制地址码翻译成<span class="math inline">\(W_i\)</span>的其中一个信号。</p><p>现在看存储矩阵，看横行，每个横行构成了一个二极管或门，比如<span class="math inline">\(D_3=W_1+W_3,D_2=W_0+W_2+W_3,\cdots\)</span>，这样一来，输出端<span class="math inline">\(D\)</span>就能根据<span class="math inline">\(W\)</span>的选通而输出对应的信号<span class="math inline">\(\{D_3D_2D_1D_0\}\)</span>了。这就是二极管ROM的工作原理。根据这个原理，我们也可以使用ROM来实现多输出端逻辑函数，不再赘述了。</p><h4 id="存储器容量的扩展">存储器容量的扩展</h4><ol type="1"><li><p>位扩展</p><p>当字数够用而每个字的位数不够时，可以使用位扩展。位扩展很简单，只需要把所有地址线、读写控制线、<span class="math inline">\(CS&#39;\)</span>线（CS‘线就是片选输入端，当<span class="math inline">\(\overline{CS}=0\)</span>时，这个片才工作）统统拧在一起就行了，如下是把8个1024x1位存储器位扩展为一个1024x8位存储器的过程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272225535.png" alt="位扩展" /><figcaption aria-hidden="true">位扩展</figcaption></figure></li><li><p>字扩展</p><p>当位数够用而字数不够时，可以使用字扩展。字扩展的接法是：首先把每个片的每个输出端，每个低位地址端，读写控制线并联起来，然后在新的地址位上加入一个译码器，通过译码器和CS端来控制不同的片工作与否，以达到扩展字数的目的。如下图是把4个256x8存储器接成一个1024x8存储器的过程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272232639.png" alt="字扩展" /><figcaption aria-hidden="true">字扩展</figcaption></figure></li></ol><h2 id="时序逻辑电路">时序逻辑电路</h2><p>时序逻辑电路的特点是：任意时刻的输出状态不仅仅和当前的输入有关，还和电路之前的状态有关。其基本结构是由存储器电路和组合逻辑电路组成的。如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062052681.png" alt="时序逻辑电路结构" /><figcaption aria-hidden="true">时序逻辑电路结构</figcaption></figure><p>描述时序逻辑，一般用三个方程。下面所说的“Q状态”指的是存储电路中各触发器的输出端状态：</p><ul><li><p>状态方程 <span class="math display">\[Q^{n+1}=H(Z,Q^n)\]</span> 状态方程描述的是前一次的<span class="math inline">\(Q\)</span>状态和后一次的<span class="math inline">\(Q\)</span>状态的关系。</p></li><li><p>驱动方程 <span class="math display">\[Z=Q(X,Q^n)\]</span> 驱动方程描述的是触发器各输入端口和电路的<span class="math inline">\(Q\)</span>状态以及输入信号的关系。</p></li><li><p>输出方程 <span class="math display">\[Y=F(X,Q^n)\]</span> 输出方程描述的是电路的输出信号和输入信号以及<span class="math inline">\(Q\)</span>状态的关系。</p></li></ul><p>时序逻辑电路按照电路状态转换情况不同，分为同步时序逻辑电路（所有触发器共用一个时钟信号）、异步时序逻辑电路（有些触发器的时钟信号可能是其它触发器的输出或者其它信号，总之不是共用一个时钟信号）。</p><p>按照输出变量是否和输入变量直接相关，分为Mealy型（外部输出和触发器的状态以及输入信号有关）和Moore型（外部输出仅与触发器的状态有关）。</p><h3 id="时序逻辑电路的分析">时序逻辑电路的分析</h3><p>分析时序逻辑电路的基本纲领是：</p><ol type="1"><li>根据电路逻辑图写出各个触发器的<strong>驱动方程</strong>（基本形式为：<span class="math inline">\(\text{触发器输入端信号}=f(Q^n,\text{输入信号})\)</span>）和输出方程</li><li>把各驱动方程带入触发器的特性方程，得到电路的状态方程（基本形式为：<span class="math inline">\(Q^{n+1}=f(Q^n,\text{输入信号})\)</span>）</li><li>列出逻辑转换表、逻辑转换图</li><li>分析电路功能</li></ol><p>以下以一些例子说明这个过程。</p><h4 id="同步时序逻辑电路分析">同步时序逻辑电路分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062120494.png" alt="同步时序逻辑电路" /><figcaption aria-hidden="true">同步时序逻辑电路</figcaption></figure><ol type="1"><li><p>列电路驱动方程： <span class="math display">\[\begin{cases}J_1=\overline{Q_2} \cdot Q_3 &amp; K_1=1 \\ J_2=Q_1 &amp; K_2=\overline{\overline{Q_1} \cdot \overline{Q_3}} \\ J_3=Q_1 \cdot Q_2 &amp; K_3=Q_2\end{cases}\]</span> 输出方程： <span class="math display">\[Y=Q_2Q_3\]</span></p></li><li><p>电路所用触发器是<span class="math inline">\(JK\)</span>触发器，其特性方程为：<span class="math inline">\(Q^{n+1}=J\bar Q+\bar KQ\)</span>，把驱动方程带入特性方程，有： <span class="math display">\[\begin{aligned}&amp; Q_1^{n+1}=\overline{Q_2} \cdot Q_3 \cdot \overline{Q_1} \\&amp; Q_2{ }^{n+1}=Q_1 \cdot \overline{Q_2}+\overline{Q_1} \cdot \overline{Q_3} \cdot Q_2 \\&amp; Q_3{ }^{n+1}=Q_1 \cdot Q_2 \cdot \bar{Q}_3+\overline{Q_2} \cdot Q_3\end{aligned}\]</span></p></li><li><p>列出状态转移表：</p><p>这个表有三部分：<span class="math inline">\(Q,Q^{n+1},Y\)</span>。其中<span class="math inline">\(Q\)</span>栏要预先穷举所有组合，<span class="math inline">\(Q^{n+1}\)</span>栏和<span class="math inline">\(Y\)</span>栏根据状态方程和输出方程书写。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062135331.png" alt="状态转移表" /><figcaption aria-hidden="true">状态转移表</figcaption></figure></li><li><p>分析，得这个电路是一个七进制加法计数器，<span class="math inline">\(Y\)</span>是进位信号。</p></li></ol><h4 id="同步mealy时序逻辑电路分析">同步Mealy时序逻辑电路分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062147191.png" alt="有输入的同步时序逻辑电路" /><figcaption aria-hidden="true">有输入的同步时序逻辑电路</figcaption></figure><ol type="1"><li><p>写驱动方程 <span class="math display">\[\begin{aligned}&amp; D_1=\overline{Q_1} \\&amp; D_2=A \oplus Q_1 \oplus Q_2\end{aligned}\]</span></p></li><li><p>由<span class="math inline">\(D\)</span>触发器的特性方程<span class="math inline">\(Q^{n+1}=D\)</span>，写状态方程： <span class="math display">\[\begin{aligned}&amp; Q_1^{n+1}=D_1=\bar{Q}_1 \\&amp; Q_2^{n+1}=D_2=A \oplus Q_1 \oplus Q_2\end{aligned}\]</span></p></li><li><p>写输出方程： <span class="math display">\[Y=\overline{\overline{\bar{A} Q_1 Q_2} \cdot \overline{A \overline{Q_1} \overline{Q_2}}}=\bar{A} Q_1 Q_2+A \overline{Q_1} \overline{Q_2}\]</span></p></li><li><p>写状态转移表：</p><table><thead><tr class="header"><th>A</th><th>Q2</th><th>Q1</th><th>Q2*</th><th>Q1*</th><th>Y</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></li><li><p>经分析，其是四进制加减计数器，输入控制加减。状态转换图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062155771.png" alt="状态转换图" /><figcaption aria-hidden="true">状态转换图</figcaption></figure></li></ol><h4 id="异步时序逻辑电路分析">异步时序逻辑电路分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062158972.png" alt="异步时序逻辑电路" /><figcaption aria-hidden="true">异步时序逻辑电路</figcaption></figure><ol type="1"><li><p>写出驱动方程： <span class="math display">\[\begin{cases}J_0=1 &amp; K_0=1 &amp; cp_0=CP\downarrow\\J_1=\overline{\overline{Q_2} \cdot \overline{Q_3}} &amp; K_1=1 &amp; cp_1=\bar Q_0\downarrow\\J_2=1 &amp; K_2=1 &amp; cp_2=\bar Q_1\downarrow\\J_3=\bar Q_1\bar Q_2 &amp; K_3=1 &amp; cp_3=\bar Q_0\downarrow\end{cases}\]</span></p></li><li><p>根据<span class="math inline">\(JK\)</span>触发器的特性方程<span class="math inline">\(Q^{n+1}=J\bar Q+\bar KQ\)</span>，写出状态方程： <span class="math display">\[\begin{cases}Q_0^{n+1}=\left.\overline{Q_0}\right|_{CP \downarrow}\\Q_1^{n+1}=Q_2 \overline{Q_1}+Q_3 \left.\overline{Q_1}\right| _{\bar Q_0 \downarrow}\\Q_2^{n+1}=\left.\overline{Q_2}\right|_{\overline{Q_1} \downarrow}\\Q_3^{n+1}=\overline{Q_1} \cdot \overline{Q_2} \cdot \left. \overline{Q_3} \right| _{\overline{Q_0} \downarrow}\end{cases}\]</span></p></li><li><p>写状态转换表。</p><p>首先画一张空表</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062216825.png" alt="空表" /><figcaption aria-hidden="true">空表</figcaption></figure><p>然后填写Q和已确定的<span class="math inline">\(cp_0\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062218665.png" alt="填写Q和cp0" /><figcaption aria-hidden="true">填写Q和cp0</figcaption></figure><p>写出可以写出的<span class="math inline">\(Q^{n+1}\)</span>，比如<span class="math inline">\(Q_0^{n+1}\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062220582.png" alt="填写Q0*" /><figcaption aria-hidden="true">填写Q0*</figcaption></figure><p>根据Q0*，写出由Q0*确定的时钟信号<span class="math inline">\(cp_1\)</span>,<span class="math inline">\(cp_3\)</span>.因为这两个信号都是<span class="math inline">\(\bar Q_0\downarrow\)</span>，所以在<span class="math inline">\(Q_0^{n+1}=1\)</span>的地方画下箭头</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062224507.png" alt="画cp1cp3" /><figcaption aria-hidden="true">画cp1cp3</figcaption></figure><p>根据已经确定的<span class="math inline">\(Q,cp_1,cp_3\)</span>,填写<span class="math inline">\(Q_1^{n+1},Q_3^{n+1}\)</span>.在<span class="math inline">\(cp\)</span>有下降沿时，根据状态方程计算状态；当<span class="math inline">\(cp\)</span>不是下降沿时，直接保持<span class="math inline">\(Q_1^n,Q_3^n\)</span>（原状态）的值</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062229881.png" /></p><p>根据<span class="math inline">\(Q_1^{n+1}\)</span>，写出<span class="math inline">\(cp_2\)</span>（连续1串的末尾处填写↓），仿照上面的过程填写<span class="math inline">\(Q_2^{n+1}\)</span>，最后填写<span class="math inline">\(Y\)</span>.</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062232556.png" /></p></li><li><p>根据表格画出状态转移图，发现其为模十减法计数器</p></li></ol><h3 id="时序逻辑电路设计">时序逻辑电路设计</h3><p>设计时序逻辑电路的纲领就是把分析的过程反过来</p><ol type="1"><li>根据设计要求设定状态，绘制状态转换图和表</li><li>根据触发器类型对状态方程进行逻辑化简</li><li>写出输出方程和驱动方程</li><li>根据输出方程和驱动方程画电路图</li><li>验证自启动性</li></ol><p>下面以一些例子说明这个过程：</p><h4 id="同步时序逻辑电路设计">同步时序逻辑电路设计</h4><p>【例】设计一个同步13进制加法计数器。</p><ol type="1"><li><p>绘制状态转换图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071028422.png" alt="状态转换图" /><figcaption aria-hidden="true">状态转换图</figcaption></figure><p>根据图列出状态转换表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071029063.png" alt="状态转换表" /><figcaption aria-hidden="true">状态转换表</figcaption></figure></li><li><p>进行逻辑化简，画卡诺图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071033299.png" alt="卡诺图" /><figcaption aria-hidden="true">卡诺图</figcaption></figure><p>在使用JK触发器时，因为JK触发器的特性方程是（以<span class="math inline">\(Q_3\)</span>为例子）： <span class="math display">\[Q_3^{n+1}=J\cdot \overline{Q_3^n}+\overline{K}\cdot Q_3^n\]</span> 所以我们终究是要化简成像这样的形式，才能进行下一步驱动方程的书写的。所以，在化简时，我们可以在卡诺图中画一条“鸿沟”，把<span class="math inline">\(Q_3\)</span>和<span class="math inline">\(\overline{Q_3}\)</span>的部分分割开，合并“1”格画卡诺圈时不跨越“鸿沟”，这样的话，化简出来就直接是上面式子的形式了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071055814.png" alt="“鸿沟法”" /><figcaption aria-hidden="true">“鸿沟法”</figcaption></figure><p>如图，可以写出各状态方程： <span class="math display">\[\begin{cases}Q_3^{n+1}=Q_2Q_1Q_0\cdot \overline{Q_3}+\overline{Q_2}\cdot Q_3\\Q_2^{n+1}=Q_1Q_0\cdot \overline{Q_2}+(\overline{Q_3}\ \overline{Q_1}\cdot Q_2+\overline{Q_3}\ \overline{Q_0}\cdot Q_2)\\Q_1^{n+1}=Q_0 \cdot \overline{Q_1}+\overline{Q_0} \cdot Q_1\\Q_0^{n+1}=(\overline{Q_3} \cdot \overline{Q_0}+\overline{Q_2} \cdot \overline{Q_0})\end{cases}\]</span></p></li><li><p>根据JK触发器的特性方程，可以直接写出驱动方程： <span class="math display">\[\begin{cases}J_3=Q_2Q_1Q_0 &amp; K_3=\overline{\overline{Q_2}}=Q_2\\J_2=Q_1Q_0 &amp; K_2=\overline{\overline{Q_3}(\overline{Q_1}+\overline{Q_0})}=Q_3+(Q_1Q_0)\\J_1=Q_0 &amp; K_1=Q_0\\J_0=\overline{Q_2}+\overline{Q_3} &amp; K_0=1\end{cases}\]</span></p></li><li><p>画出电路图</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071111134.png" alt="电路图" /><figcaption aria-hidden="true">电路图</figcaption></figure></li></ol><h4 id="异步时序逻辑电路设计">异步时序逻辑电路设计</h4><p>【例】用JK触发器设计一个异步五进制计数器</p><ol type="1"><li><p>绘制状态转换图（略），时序波形图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132041777.png" alt="波形图" /><figcaption aria-hidden="true">波形图</figcaption></figure></li><li><p>在保证状态变化的时候必有触发脉冲的前提条件下, 选择在状态不变的时候触发脉冲最少的, 使得 <span class="math inline">\(\mathrm{JK}\)</span> 的输入条件简化。根据以上准则，选定各触发器的触发信号源；列写状态转移表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132044245.png" alt="状态转移表" /><figcaption aria-hidden="true">状态转移表</figcaption></figure></li><li><p>把状态转换表变成卡诺图形式，逻辑化简，写出逻辑表达式 <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132046917.png" alt="卡诺图" /></p><p>状态方程： <span class="math display">\[\begin{cases}Q_2^{n+1}=Q_1Q_0\cdot\overline{Q_2}\\Q_1^{n+1}=\overline{Q_1}\\Q_0^{n+1}=\overline{Q_2}\cdot\overline{Q_0}\end{cases}\]</span> 驱动方程： <span class="math display">\[\begin{cases}J_2=Q_1Q_0 &amp; K_2=1\\J_1=1 &amp; K_1=1\\J_0=\overline{Q_2} &amp; K_0=1\end{cases}\]</span></p></li></ol><h3 id="计数器">计数器</h3><p>计数器是用以统计输入脉冲CP个数的电路。常用的计数器有以下这么几种：</p><ol type="1"><li><p>74161：4位二进制同步加法计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132138461.png" alt="74161的逻辑图和功能表" /><figcaption aria-hidden="true">74161的逻辑图和功能表</figcaption></figure></li><li><p>74191：四位二进制同步可逆计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132142262.png" alt="功能表" /><figcaption aria-hidden="true">功能表</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132143570.png" alt="符号" /><figcaption aria-hidden="true">符号</figcaption></figure></li><li><p>74160：十进制同步加法计数器</p><p>其逻辑符号和功能表和74161相同，仅靠上面的数字区分。</p></li></ol><h4 id="任意进制计数器的构成">任意进制计数器的构成</h4><p>假设已经有了<span class="math inline">\(N\)</span>进制计数器，要求通过链接、外加电路的方法得到<span class="math inline">\(M\)</span>进制计数器。</p><ol type="1"><li><p><span class="math inline">\(M&lt;N\)</span>时</p><p>主要方法有置零法和置数法两种。置零法是在电路从<span class="math inline">\(S_0\)</span>计数到<span class="math inline">\(S_M\)</span>时，外接一个<span class="math inline">\(M\)</span>的译码器，产生一个置零信号，接入置零端。因为电路一经过<span class="math inline">\(S_M\)</span>状态就会产生置零信号，进而被置入<span class="math inline">\(S_0\)</span>状态，因此<span class="math inline">\(S_M\)</span>并不会出现在稳定循环中。以上是异步置零的情况，如果是同步置零的话，需要在<span class="math inline">\(S_{M-1}\)</span>处进行译码，传回置零信号，然后在下一个时钟触发置零。其逻辑转换图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132232915.png" alt="置零法" /><figcaption aria-hidden="true">置零法</figcaption></figure><p>下图是用置零法把同步十进制计数器74160接成同步六进制计数器的电路图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132237765.png" alt="10-6" /><figcaption aria-hidden="true">10-6</figcaption></figure><p>这里的清零端是异步清零。此时标志“进位”这个动作发生的信号是进位输出信号的下降沿。这种接法的清零信号持续时间非常的短，有可能导致电路出错。可以在进位输出前加一个锁存器，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132241978.png" alt="改进的10-6" /><figcaption aria-hidden="true">改进的10-6</figcaption></figure><p>此时如果电路进入<span class="math inline">\(S_6(0110)\)</span>状态，在<span class="math inline">\(G_1\)</span>门后输出低电平，把与非门SR锁存器置1，<span class="math inline">\(\bar Q\)</span>端输出低电平，接入低电平有效置零端<span class="math inline">\(R_D\)</span>，把电路置零。而因为锁存器的存在，置零信号会维持一段时间，直到计数脉冲回到低电平，SR锁存器才被置零。</p><p>置位法是通过给计数器重复置入某个数值的方法跳过<span class="math inline">\(N-M\)</span>个状态，从而获得<span class="math inline">\(M\)</span>进制计数器的。其逻辑转换图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132234036.png" alt="置位法" /><figcaption aria-hidden="true">置位法</figcaption></figure><p>下图是一种用置数法构成的电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132257611.png" alt="在S5(0101)时置入0000" /><figcaption aria-hidden="true">在S5(0101)时置入0000</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132258697.png" alt="在S4(0100)时置入SN-1(1001)" /><figcaption aria-hidden="true">在S4(0100)时置入SN-1(1001)</figcaption></figure></li><li><p><span class="math inline">\(M&gt;N\)</span>时</p><p>应用多片N进制计数器进行组合。如果M可以因式分解成多个小于N的数之和，即：<span class="math inline">\(M=N_1N_2\cdots N_n\)</span>，那么可以把第<span class="math inline">\(i\)</span>片计数器接成<span class="math inline">\(N_i\)</span>进制，然后采用串行进位或者并行进位把他们链接起来。</p><p>串行进位指的是以低位片的进位输出信号作为高位片的时钟信号，如下图是把两个十进制计数器用串行接法接成一个一百进制计数器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261931290.png" alt="串行100进制计数器" /><figcaption aria-hidden="true">串行100进制计数器</figcaption></figure><p>在第9个<span class="math inline">\(CLK\)</span>信号来临时，第一个计数器的状态为<span class="math inline">\(1001\)</span>，进位输出<span class="math inline">\(C\)</span>出现高电平，第二片的时钟信号在低电平；当第10个<span class="math inline">\(CLK\)</span>信号到来时，第一个计数器的状态变为<span class="math inline">\(0000\)</span>，进位输出<span class="math inline">\(C\)</span>输出低电平，第二片的时钟信号出现一个上升沿，第二片的状态变成<span class="math inline">\(0001\)</span>，以此实现进位功能。</p><p>并行进位指的是以低位片的进位输出信号作为高位片的使能信号，两片的时钟同时接<span class="math inline">\(CLK\)</span>输入信号，如下图是把两个十进制计数器用并行接法接成一个一百进制计数器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261935682.png" alt="并行100进制计数器" /><figcaption aria-hidden="true">并行100进制计数器</figcaption></figure><p>在第9个<span class="math inline">\(CLK\)</span>信号来临时，第一个计数器的状态为<span class="math inline">\(1001\)</span>，进位输出<span class="math inline">\(C\)</span>出现高电平，第二片使能开启，开始工作；下个<span class="math inline">\(CLK\)</span>信号来临，第二片正在工作，状态变为<span class="math inline">\(0001\)</span>，第一片的状态变为<span class="math inline">\(0000\)</span>，进位输出低电平，第二片使能关闭。</p><p>如果M是素数，或者不能像这样因式分解，则必须采用整体置零/置数法。</p></li></ol><h4 id="移位寄存器型计数器">移位寄存器型计数器</h4><ol type="1"><li><p>环形计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261939073.png" alt="环形计数器" /><figcaption aria-hidden="true">环形计数器</figcaption></figure><p>有效循环为<span class="math inline">\(1000\to 0100\to0010\to0001\to 1000\)</span>，不能自启动</p></li><li><p>扭环形计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261940589.png" alt="扭环形计数器" /><figcaption aria-hidden="true">扭环形计数器</figcaption></figure><p>其状态转移图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261941367.png" alt="扭环形计数器状态转移图" /><figcaption aria-hidden="true">扭环形计数器状态转移图</figcaption></figure></li></ol><p>用<span class="math inline">\(n\)</span>位移位寄存器构成 环形计数器 可以得到<span class="math inline">\(n\)</span>个状态的有效循环；</p><p>用<span class="math inline">\(n\)</span>位移位寄存器构成 扭环形计数器 可以得到<span class="math inline">\(2n\)</span>个状态的有效循环。</p><h3 id="序列信号发生器">序列信号发生器</h3><h4 id="计数译码型">计数译码型</h4><p>其原理是由一个计数器和一个数据选择器连接，计数器的计数输出连在数据选择器的地址输入上。在数据选择器的信号输入端，预置已知的序列，然后用<span class="math inline">\(CLK\)</span>驱动计数器，数据选择器根据计数器的状态选择要输出的信号。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261954151.png" alt="计数译码型序列信号发生器" /><figcaption aria-hidden="true">计数译码型序列信号发生器</figcaption></figure><p>如上图，发生的序列是<span class="math inline">\(00010111\)</span>。</p><p>当然，上面的数据选择器也可以换成自己搭建的组合逻辑译码电路（输入计数信号，输出该信号对应的序列的值）</p><h4 id="反馈移位型">反馈移位型</h4><p>其一般电路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262002159.png" alt="反馈移位型序列发生器" /><figcaption aria-hidden="true">反馈移位型序列发生器</figcaption></figure><p>驱动方程为： <span class="math display">\[\begin{aligned}D_0&amp;=F(Q_0,Q_1,\cdots,Q_n)\\D_1&amp;=Q_0\\\cdots\\D_n&amp;=Q_{n-1}\end{aligned}\]</span> 在分析时，完全可以当成一般的同步时序逻辑电路分析，当然也可以用序列发生器的特点简化分析。在分析时，这两者的复杂度区别并不大。</p><p>在设计时，首先需要注意，在一个周期内状态编码不能重复；然后根据序列长度<span class="math inline">\(n\)</span>使用<span class="math inline">\(\log _2 n\)</span>个<span class="math inline">\(D\)</span>触发器。接下来以一个例子说明设计过程：</p><p>【例】设计反馈移位型序列发生器，序列为<span class="math inline">\(\{1111\ 0101\ 1001\ 000\}\)</span>（右侧的先出现）。</p><ol type="1"><li><p>检查是否有重复和确定触发器数目：</p><p>应用四个触发器</p></li><li><p>确定输出信号的位置</p><p>一般来说，选取最后一个触发器的输出端，即<span class="math inline">\(Q_3\)</span></p></li><li><p>设计组合逻辑反馈电路</p><p>这里，实际上就是要求写出<span class="math inline">\(D_0\)</span>和<span class="math inline">\(Q_3,Q_2,Q_1,Q_0\)</span>的函数关系式。</p><p>首先列出表，在<span class="math inline">\(Q_3\)</span>里填入要输出的序列：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262022013.png" /></p><p>然后因为“移位”的特点，把<span class="math inline">\(Q_3\)</span>整体向上提一格，填入<span class="math inline">\(Q_2\)</span>；把<span class="math inline">\(Q_2\)</span>整体往上提一格，填入<span class="math inline">\(Q_1\)</span>；......把<span class="math inline">\(Q_0\)</span>整体往上提一格填入<span class="math inline">\(D_0\)</span>（这里的“往上提”是含有循环意味的）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262025544.png" /></p><p>于是，我们就得到了逻辑关系表，然后画卡诺图化简，连电路就行了。</p></li><li><p>最终结果 <span class="math display">\[D_0=Q_0 \overline{Q_3}+\overline{Q_0} Q_3=Q_0\bigoplus Q_3\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262028019.png" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路·模拟之章</title>
    <link href="/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E6%A8%A1%E6%8B%9F%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E6%A8%A1%E6%8B%9F%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>为什么叫模拟之章呢？是因为这篇主要是涉及模拟电路的部分。</p><span id="more"></span><h2 id="门电路">门电路</h2><h3 id="cmos门电路">CMOS门电路</h3><p>要研究CMOS门电路，首先要认识MOS器件以及它们的特性。</p><h4 id="mos管的基本概念">MOS管的基本概念</h4><p>MOS管全名叫“结型场效应晶体管”，我们平常见到的有以下四种</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161943768.png" alt="常见MOS管符号" /><figcaption aria-hidden="true">常见MOS管符号</figcaption></figure><p>注意看：箭头方向决定是N还是P，线的虚实决定是增强还是耗尽。</p><p>MOS管的符号也有简化画法，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161944750.png" alt="MOS管符号的简化画法" /><figcaption aria-hidden="true">MOS管符号的简化画法</figcaption></figure><p>它们的特性按P、N和增强、耗尽，有所不同：</p><ul><li><strong>N沟道</strong>的，当<span class="math inline">\(V_{GS}\)</span>接足够大的正向电压时，<span class="math inline">\(DS\)</span>之间相当于联通。<strong>P沟道</strong>的，当<span class="math inline">\(V_{GS}\)</span>之间接足够大的反向电压，<span class="math inline">\(DS\)</span>之间相当于导通。</li><li><strong>增强型</strong>，开启电压为正。以<span class="math inline">\(N\)</span>沟道为例，当<span class="math inline">\(V_{GS}&gt;V_{GS(th)}&gt;0\)</span>时，<span class="math inline">\(DS\)</span>之间才能相当于联通。<strong>耗尽型</strong>，截止电压为负。以<span class="math inline">\(N\)</span>沟道为例，只要<span class="math inline">\(V&gt;V_{GS(off)}\)</span>，其中<span class="math inline">\(V_{GS(off)}&lt;0\)</span>，<span class="math inline">\(DS\)</span>之间就能导通，也就是说为了让N沟道耗尽型的DS之间不再导通，<span class="math inline">\(V_{GS}\)</span>需要一个足够大的负值电压才行。</li></ul><p>为了加深对这个特性的理解，我们来分析一下下面这个电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161954418.png" alt="未知的CMOS门电路" /><figcaption aria-hidden="true">未知的CMOS门电路</figcaption></figure><p>约定：<span class="math inline">\(V_{DD}\)</span>大于两管开启电源绝对值之和。</p><ul><li>当<span class="math inline">\(V_i=0\)</span>（接低电平）时，<span class="math inline">\(T_1\)</span>P沟道增强型MOS管的<span class="math inline">\(V_{GS}=-V_{DD}&lt;V_{GS(th)P}\)</span>，于是<span class="math inline">\(T_1\)</span>两端相当于连通，<span class="math inline">\(V_o=V_{DD}\)</span>，输出高电平。此时<span class="math inline">\(T_2\)</span>截止，两端相当于断路。</li><li>当<span class="math inline">\(V_i=V_{DD}\)</span>（接低电平）时，<span class="math inline">\(T_2\)</span>N沟道增强型MOS管的<span class="math inline">\(V_{GS}=V_{DD}&gt;V_{GS(th)N}\)</span>，于是<span class="math inline">\(T_2\)</span>导通，<span class="math inline">\(V_o\)</span>输出地（0V），此时<span class="math inline">\(T_1\)</span>截止，两端相当于断路。</li><li>综上所述，这是个非门。</li></ul><h4 id="经典门电路的mos管实现">经典门电路的MOS管实现</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162009771.png" alt="MOS门电路" /><figcaption aria-hidden="true">MOS门电路</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162009164.png" alt="MOS门电路" /><figcaption aria-hidden="true">MOS门电路</figcaption></figure><p>对于CMOS器件构成的门电路，不允许输入端悬空，输入端经电阻接地时和低电平等效，输入端经电阻接电源时和高电平等效。</p><h4 id="od门">OD门</h4><p>OD门全称为漏极开关输出门电路，它的电路长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162017294.png" alt="OD与非门电路详图" /><figcaption aria-hidden="true">OD与非门电路详图</figcaption></figure><p>其逻辑符号为门电路符号里面加一个带下划线的菱形，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162018140.png" alt="OD与非门逻辑符号" /><figcaption aria-hidden="true">OD与非门逻辑符号</figcaption></figure><p>OD门要正常工作，必须把输出端经过一个上拉电阻和电源相连。也就是电路详图中的<span class="math inline">\(R_L\)</span>，这样一来，输出的高电平具体是几伏，就取决于<span class="math inline">\(V_{DD2}\)</span>而不是<span class="math inline">\(V_{DD1}\)</span>了。</p><p>把多个OD门的输出端直接接在一起，可以构成“线与”逻辑，如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162022900.png" alt="线与接法" /><figcaption aria-hidden="true">线与接法</figcaption></figure><p>这时，有<span class="math inline">\(Y=Y_1Y_2\)</span>。有时，线与的与门符号省略，直接用圆点表示。</p><p>在选取<span class="math inline">\(R_L\)</span>时，应该注意以下原则：</p><ol type="1"><li><p><span class="math inline">\(R_L\)</span>不能太大，以保证<span class="math inline">\(V_{DD}-V_{R_L}\geq V_{OH}\)</span>。在这个条件下，有： <span class="math display">\[R_{\mathrm{L}}\leq\frac{V_{\mathrm{DD}}-V_{\mathrm{OH}}}{n \cdot I_{\mathrm{OH}}+m \cdot I_{\mathrm{IH}}}\]</span> 这里的<span class="math inline">\(V_{DD}\)</span>当然是<span class="math inline">\(R_L\)</span>连接的那个电源，其中<span class="math inline">\(n\)</span>是OD门的数目，<span class="math inline">\(m\)</span>是下一级输入端的数目（比如说，一个与非门一般有两个输入端），<span class="math inline">\(I_{OH}\)</span>是OD门截止时的漏电流，<span class="math inline">\(I_{IH}\)</span>是负载门每个输入端的高电平输入电流</p></li><li><p><span class="math inline">\(R_L\)</span>不能过小，以保证“灌入”的负载电流不大于单只OD门可承受的输入电流。有： <span class="math display">\[R_{\mathrm{L}} \geq \frac{V_{\mathrm{DD}}-V_{\mathrm{OL}}}{I_{\mathrm{OL}(\mathrm{OD})}-m \cdot I_{\mathrm{IL}}}\]</span> <span class="math inline">\(m\)</span>是下一级输入端的数目。</p></li></ol><h4 id="传输门">传输门</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162030714.png" alt="CMOS传输门电路和逻辑符号" /><figcaption aria-hidden="true">CMOS传输门电路和逻辑符号</figcaption></figure><p>其特性为：</p><ul><li><span class="math inline">\(C\)</span>接高电平而<span class="math inline">\(\overline{C}\)</span>接低电平，<span class="math inline">\(V_o=V_i\)</span>，相当于信号直接通过</li><li><span class="math inline">\(C\)</span>接低电平而<span class="math inline">\(\overline{C}\)</span>接高电平，相当于中间的电路断开，输出是高阻态。</li></ul><h4 id="三态门">三态门</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162032490.png" alt="三态门符号" /><figcaption aria-hidden="true">三态门符号</figcaption></figure><p>三态门是一个正常的门电路外加一个<span class="math inline">\(EN\)</span>信号，里面画一个倒三角。当<span class="math inline">\(EN\)</span>为有效信号（上图是低电平有效，也就是<span class="math inline">\(EN=0\)</span>）时，门电路正常工作，否则，输出高阻态。</p><h3 id="ttl门电路">TTL门电路</h3><p>我也不会分析，所以分析略。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162040271.png" /></p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162040028.png" /></p><p>这里这个OC门（集电极开路输出的门电路）就和前面那个OD门意思差不多，也有线与，也得算<span class="math inline">\(R_L\)</span>的范围。不同的是，当输出端含有与非门时，要按与非门的门数计算，而不是端数。</p><p>对于TTL门电路，输入端悬空等效于逻辑高电平；输入端经过几十千欧以内的电阻接电源，等效于逻辑高电平；输入端经过几十欧的小电阻接地等效于低电平，当电阻升高到一定程度（一般是几千欧）以后，等效为高电平。</p><h2 id="脉冲波形的产生和整形电路">脉冲波形的产生和整形电路</h2><h3 id="施密特触发器">施密特触发器</h3><p>施密特触发器是脉冲波形变换中的常用电路。它具有以下两个特点：</p><ol type="1"><li>输入信号本来是低电平，上升的过程中电路状态发生转换时对应的输入电平，和输入信号本来是高电平，下降的过程中电路状态发生转换时对应的输入电平不相等</li><li>在电路状态变化的过程中，电路内存在正反馈过程，从而使得电压波形非常陡峭</li></ol><p>施密特触发器的电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221543571.png" alt="施密特触发器" /><figcaption aria-hidden="true">施密特触发器</figcaption></figure><p>当<span class="math inline">\(v_1\)</span>从0开始逐渐上升，使得<span class="math inline">\(v_A=V_{TH}\)</span>时，<span class="math inline">\(G_1\)</span>门的输出端<span class="math inline">\(v_{O1}\)</span>下降，变成低电平，于是<span class="math inline">\(G_2\)</span>门的输出端<span class="math inline">\(v_O\)</span>抬升，变成高电平。因为对<span class="math inline">\(v_1-R_1-R_2-v_O\)</span>回路，有 <span class="math display">\[v_A=v_1-(v_1-v_O)\frac{R_1}{R_1+R_2}\]</span> 抬升的<span class="math inline">\(v_O\)</span>通过电阻<span class="math inline">\(R_2\)</span>反作用于<span class="math inline">\(v_A\)</span>，使得<span class="math inline">\(v_A\)</span>继续上升。于是，<span class="math inline">\(v_O\)</span>迅速地达到高电平<span class="math inline">\(V_{DD}\)</span>。</p><p>在上述过程中，状态转换发生的瞬间，此时<span class="math inline">\(v_o\)</span>还是低电平<span class="math inline">\(0\)</span>，有： <span class="math display">\[v_A=\frac{R_2}{R_1+R_2}V_{T+}=V_{TH}\]</span> 解得 <span class="math display">\[V_{T+}=\left(1+\frac {R_1}{R_2}\right)V_{TH}\]</span> 其中<span class="math inline">\(V_{T+}\)</span>是施密特触发器上升过程中电路状态转换瞬间对应的输入电平，<span class="math inline">\(V_{TH}\)</span>是逻辑门高低电平的分界线。</p><p>同理，当<span class="math inline">\(v_1\)</span>从高电平<span class="math inline">\(V_{DD}\)</span>开始下降，直到<span class="math inline">\(v_A=V_{TH}\)</span>时，<span class="math inline">\(G_1\)</span>门的输出端<span class="math inline">\(v_{O1}\)</span>抬升，变成高电平，于是<span class="math inline">\(G_2\)</span>门的输出端<span class="math inline">\(v_{O}\)</span>下降，根据上面的式子，下降的<span class="math inline">\(v_O\)</span>作用于<span class="math inline">\(v_A\)</span>形成正反馈，使得<span class="math inline">\(v_A\)</span>继续下降，于是<span class="math inline">\(v_O\)</span>迅速地达到0.</p><p>同样，有： <span class="math display">\[v_A=V_{T-}-(V_{T-}-V_{DD})\frac{R_1}{R_1+R_2}\]</span> 解得： <span class="math display">\[V_{T-}=\left(1-\frac{R_1}{R_2}\right)V_{TH}\]</span> 其中<span class="math inline">\(V_{T-}\)</span>是施密特触发器下降过程中电路状态转换瞬间对应的输入电平。</p><p>于是，可以得到施密特触发器的电压传输特性：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221613215.png" alt="电压传输特性" /><figcaption aria-hidden="true">电压传输特性</figcaption></figure><p>中间的部分叫做回差电压： <span class="math display">\[\Delta V_T=V_{T+}-V_{T-}=2\frac{R_1}{R_2}V_{TH}\]</span> 如果施密特触发器要正常工作，那么<span class="math inline">\(R_1&lt;R_2\)</span>，否则会发生互锁。</p><p>施密特触发器的电路符号如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221620747.png" alt="施密特触发器的符号" /><figcaption aria-hidden="true">施密特触发器的符号</figcaption></figure><p>上面的同相输出，下面的是反相输出。</p><h3 id="单稳态电路">单稳态电路</h3><p>单稳态电路具有以下特点：</p><ol type="1"><li>具有稳态、暂稳态两个不同的工作状态</li><li>在外界脉冲的触发下，从稳态进入暂稳态，并在暂稳态停留一段时间后恢复稳态。这段时间的长度只和电路本身的参数有关，和触发脉冲的持续时间，强度无关。</li></ol><p>这个工作特性可以类比声控灯，触发脉冲就是声音，无论你拍个手，还是长时间地播放声音，无论声音多大，只要能触发，它一次就亮那么长时间。</p><h4 id="微分型单稳态电路">微分型单稳态电路</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221652036.png" alt="微分型单稳态电路图" /><figcaption aria-hidden="true">微分型单稳态电路图</figcaption></figure><p>如图，微分型单稳态电路由一些电阻、电容、或非门和非门构成。其前级由<span class="math inline">\(C_d-R_d\)</span>构成一个微分电路，环路内由<span class="math inline">\(C-R\)</span>构成一个微分电路。</p><p>输入端本来是低电平，当向输入端<span class="math inline">\(v_I\)</span>加入一个脉冲时，因为<span class="math inline">\(C_d\)</span>两端电压不可以突变，所以<span class="math inline">\(v_d\)</span>会被拉高，于是<span class="math inline">\(R_d\)</span>上产生一个向下的电流，负电荷流向<span class="math inline">\(C_d\)</span>，<span class="math inline">\(C_d\)</span>开始充电，<span class="math inline">\(v_d\)</span>开始下降。总的来说，微分电路<span class="math inline">\(C_d-R_d\)</span>会产生一个尖刺，就像下图一样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221710310.png" alt="vd随vi的变化" /><figcaption aria-hidden="true">vd随vi的变化</figcaption></figure><p>当<span class="math inline">\(v_d\)</span>上升达到<span class="math inline">\(V_{TH}\)</span>时，<span class="math inline">\(v_{O1}\)</span>会下降的低电平，因为<span class="math inline">\(C\)</span>两端的电压差不能突变，于是<span class="math inline">\(v_{I2}\)</span>也跟着下降到低电平，于是<span class="math inline">\(v_O\)</span>跳变到高电平，电路进入了暂稳态。</p><p>这时，<span class="math inline">\(R\)</span>上产生了向下的电流，正电荷流入<span class="math inline">\(C\)</span>，电容<span class="math inline">\(C\)</span>开始充电。随着充电的进行，<span class="math inline">\(v_{I2}\)</span>逐渐抬升，直到其抬升到<span class="math inline">\(V_{TH}\)</span>，此时<span class="math inline">\(v_O\)</span>下降为低电平，低电平反馈回<span class="math inline">\(G_1\)</span>（因为此时<span class="math inline">\(v_d\)</span>已经回到低电平），使得<span class="math inline">\(v_{O1}\)</span>抬升为高电平，进而使得<span class="math inline">\(v_{I2}\)</span>抬升。此时，电容<span class="math inline">\(C\)</span>通过电阻<span class="math inline">\(R\)</span>和门<span class="math inline">\(G_2\)</span>的输入保护电路向<span class="math inline">\(V_{DD}\)</span>放电，直至电容上的电压为<span class="math inline">\(0\)</span>，电路恢复稳态。</p><p>全过程的电压波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221728138.png" alt="全过程电压波形" /><figcaption aria-hidden="true">全过程电压波形</figcaption></figure><p>我们考察<span class="math inline">\(R-C\)</span>回路充电的过程。从充电开始到变化到<span class="math inline">\(V_{TH}\)</span>的耗时为： <span class="math display">\[t=RC\ln \frac{v_c(\infty)-v_c(0)}{v_c(\infty)-V_{TH}}\]</span> 把<span class="math inline">\(v_c(\infty)=V_{DD}\)</span>带入，有： <span class="math display">\[t_w=RC\ln 2=0.69RC\]</span> 这就是暂稳态持续的时间。</p><p>当<span class="math inline">\(v_o\)</span>恢复稳态后，<span class="math inline">\(C\)</span>还要经历一个放电的过程。放电的时间为： <span class="math display">\[t_{re}=(3\sim 5)R_{ON}C\]</span> 其中<span class="math inline">\(R_{ON}\)</span>是<span class="math inline">\(G_1\)</span>的输出电阻。整个电路两个相邻触发脉冲的最小时间间隔为 <span class="math display">\[t_d=t_w+t_{re}\]</span></p><h4 id="积分型">积分型</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221749651.png" alt="积分型单稳态电路图" /><figcaption aria-hidden="true">积分型单稳态电路图</figcaption></figure><p>如图是用与非门、非门、积分电路构成的积分型单稳态电路。</p><p>当输入正脉冲时，<span class="math inline">\(v_{O1}\)</span>变成低电平，但是因为<span class="math inline">\(C\)</span>两端的电压不能突变，所以<span class="math inline">\(v_A\)</span>仍然维持在高电平。<span class="math inline">\(G_2\)</span>的输入端是两个高电平，<span class="math inline">\(v_O\)</span>输出低电平，电路进入暂稳态。</p><p>此时，电容开始放电。随着电容的放电，<span class="math inline">\(v_A\)</span>不断降低，直到低过<span class="math inline">\(v_{TH}\)</span>。此时，与非门的其中一个输入变成低电平，<span class="math inline">\(v_O\)</span>回到高电平。等到输入端的脉冲结束以后，<span class="math inline">\(v_{O1}\)</span>又变成高电平，给电容充电，经过一段时间以后，电容充满电，电路恢复稳态。</p><p>全过程电压波形图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221949659.png" alt="全过程电压波形" /><figcaption aria-hidden="true">全过程电压波形</figcaption></figure><p>在计算电容放电过程时，有放电等效电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222001589.png" alt="放电等效电路" /><figcaption aria-hidden="true">放电等效电路</figcaption></figure><p>放电时，相当于<span class="math inline">\(R\)</span>和<span class="math inline">\(R_O\)</span>串联，有： <span class="math display">\[t_=\left(R+R_{\mathrm{O}}\right) C \ln \frac{V_{\mathrm{OL}}-V_{\mathrm{OH}}}{V_{\mathrm{OL}}-V_{\mathrm{TH}}}\]</span> 充电时，有： <span class="math display">\[t_{re}=(3\sim 5)(R+R_O&#39;)C\]</span> 整个电路两个相邻触发脉冲的最小时间间隔为： <span class="math display">\[t_d=t_w+t_{re}\]</span></p><h3 id="多谐振荡器">多谐振荡器</h3><h4 id="对称式多谐振荡器">对称式多谐振荡器</h4><p>对称式多谐振荡器的电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222144835.png" alt="对称式多谐振荡器" /><figcaption aria-hidden="true">对称式多谐振荡器</figcaption></figure><p>那么有人就说了：这也不对称啊？其实，它可以画成这样的形式：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222145042.png" alt="“对称”式多谐振荡器" /><figcaption aria-hidden="true">“对称”式多谐振荡器</figcaption></figure><p>对称式多谐振荡器是没有“稳态”的，<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>被反馈电阻偏置到放大状态。在一开始的“不平衡稳定态”，门工作在转折区，有：<span class="math inline">\(v_{I1}=v_{O1}=v_{I2}=v_{O2}\)</span>。</p><p>现在，因为某些原因，给<span class="math inline">\(v_{I1}\)</span>上加一个微小的扰动，使其有一个正跳变。那么，<span class="math inline">\(v_{O1}\)</span>会下降，因为电容<span class="math inline">\(C_1\)</span>的存在，<span class="math inline">\(v_{I2}\)</span>跟着一起下降，于是<span class="math inline">\(v_{O2}\)</span>上升，经过电容<span class="math inline">\(C_2\)</span>而继续带动<span class="math inline">\(v_{I1}\)</span>的上升，进入一个正反馈过程，此时电路进入了暂稳态。</p><p>需要注意的一点是，在接下来的分析里，我们要明确哪些电压是有外界电源保持的，哪些电压是纯数字（只有两个状态的），哪些电压是没有外界电源保持的，哪些电压是模拟（可以连续变化的）。因为这样才能知道是谁在对谁充电、画波形图时也比较方便。</p><p>有外界电源保持的电压，是纯数字的，作为门的输出端口电压出现；没有外界电源保持的电压，是模拟的，作为门的输入端口的形式出现。</p><p>对于<span class="math inline">\(C_1\)</span>，因为<span class="math inline">\(v_{O2}\)</span>上升而<span class="math inline">\(v_{I2}\)</span>下降，电流从<span class="math inline">\(R_{F2}\)</span>流入<span class="math inline">\(C_1\)</span>，对其进行充电。这时，实际上是<span class="math inline">\(G_2\)</span>的外接电源通过<span class="math inline">\(v_{O2}\)</span>，来对<span class="math inline">\(C_1\)</span>进行充电。此外，流入<span class="math inline">\(C_1\)</span>的还有门<span class="math inline">\(G_2\)</span>输入级的电流。因为<span class="math inline">\(v_{O1}\)</span>是有外界电源保持的，所以充电的效果是：<span class="math inline">\(v_{I2}\)</span>缓慢抬升。</p><p>对于<span class="math inline">\(C_2\)</span>，因为<span class="math inline">\(v_{I1}\)</span>上升而<span class="math inline">\(v_{O1}\)</span>下降，<span class="math inline">\(C_2\)</span>向电阻<span class="math inline">\(R_{F1}\)</span>放电。因为一开始给了<span class="math inline">\(v_{I1}\)</span>的一个向上的微扰，当<span class="math inline">\(v_{O2}\)</span>反馈回来时，<span class="math inline">\(v_{I1}&gt;v_{O2}\)</span>，但是<span class="math inline">\(v_{I1}\)</span>是没有外界电源保持的，因此<span class="math inline">\(C_2\)</span>会放电，把<span class="math inline">\(v_{I1}\)</span>放下去。于是，放电的效果就是<span class="math inline">\(v_{I1}\)</span>缓慢下降。那么有人就问了，既然一开始的所谓“不稳定的平衡态”，这四个电压都一样，<span class="math inline">\(C_2\)</span>上本来就没有电。那么<span class="math inline">\(C_2\)</span>放电的“电”来自于何处呢？是来自于<span class="math inline">\(v_{I1}\)</span>一开始的正跳变后引发的正反馈过程。</p><p>电路的充放电回路示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222158087.png" alt="充放电回路示意图" /><figcaption aria-hidden="true">充放电回路示意图</figcaption></figure><p>接下来，我们详细分析一下充放电过程。</p><p>对于<span class="math inline">\(C_1\)</span>:</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222218443.png" alt="C1充电等效回路" /><figcaption aria-hidden="true">C1充电等效回路</figcaption></figure><p>由戴维南定理，首先把所有电源接地，看进去等效于两个电阻并联，于是有： <span class="math display">\[R_{\mathrm{E} 1}=\frac{R_1 R_{\mathrm{F} 2}}{R_1+R_{\mathrm{F} 2}}\]</span> 接着运用叠加定理，或者说以<span class="math inline">\(V_{OH2}\)</span>为基准进行分析，得到等效电源： <span class="math display">\[V_{\mathrm{E} 1}=V_{\mathrm{OH}}+\frac{R_{\mathrm{F} 2}}{R_1+R_{\mathrm{F} 2}}\left(V_{\mathrm{CC}}-V_{\mathrm{OH}}-V_{\mathrm{BE}}\right)\]</span> 对于<span class="math inline">\(C_2\)</span>:</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222221917.png" alt="C2放电等效回路" /><figcaption aria-hidden="true">C2放电等效回路</figcaption></figure><p>因为同时有两个电源伺候<span class="math inline">\(C_1\)</span>，所以它冲的比较快，<span class="math inline">\(v_{I2}\)</span>抢先一步达到<span class="math inline">\(V_{TH}\)</span>，此时<span class="math inline">\(v_{O2}\)</span>下降为低电平，连带着<span class="math inline">\(v_{I1}\)</span>一起下降，然后通过<span class="math inline">\(G_1\)</span>使得<span class="math inline">\(v_{O_1}\)</span>上升。<span class="math inline">\(v_{O1}\)</span>的上升又通过电容<span class="math inline">\(C_1\)</span>传递给<span class="math inline">\(v_{I2}\)</span>，此时，电路进入第二个暂稳态，<span class="math inline">\(C_2\)</span>开始充电使得<span class="math inline">\(v_{I2}\)</span>下降，<span class="math inline">\(C_1\)</span>开始放电使得<span class="math inline">\(v_{I_1}\)</span>上升。从开始到<span class="math inline">\(v_{I2}\)</span>达到<span class="math inline">\(V_{TH}\)</span>的时间为： <span class="math display">\[T_1=R_{\mathrm{E} 1} C_1 \ln \frac{V_{\mathrm{E} 1}-V_{\mathrm{IK}}}{V_{\mathrm{E} 1}-V_{\mathrm{TH}}}\]</span> 因为还是有两个电源伺候<span class="math inline">\(C_2\)</span>，所以这次轮到<span class="math inline">\(v_{I1}\)</span>先上升到<span class="math inline">\(V_{TH}\)</span>，使得<span class="math inline">\(v_{O1}\)</span>下降到低电平，因为电容<span class="math inline">\(C_1\)</span>的存在，<span class="math inline">\(v_{I2}\)</span>跟着一起下降，于是<span class="math inline">\(v_{O2}\)</span>上升，经过电容<span class="math inline">\(C_2\)</span>而继续带动<span class="math inline">\(v_{I1}\)</span>的上升，又回到了第一个暂稳态。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222234255.png" alt="电压波形图" /><figcaption aria-hidden="true">电压波形图</figcaption></figure><h4 id="非对称式多谐振荡器">非对称式多谐振荡器</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231056601.png" alt="非对称式多谐振荡器" /><figcaption aria-hidden="true">非对称式多谐振荡器</figcaption></figure><p>非对称式多谐振荡器如上图所示，相比于对称式，非对称式少了一个电容、一个反馈电阻，多了一个<span class="math inline">\(R_p\)</span>的<span class="math inline">\(G_1\)</span>输入端保护电阻。静态时，<span class="math inline">\(G_1,G_2\)</span>工作在电压传输特性图的中点（转折区），即<span class="math inline">\(v_{I1}=v_{O1}=v_{I2}=v_{O2}=V_{DD}/2\)</span>。其中<span class="math inline">\(v_{O1}\equiv v_{I2}\)</span>和<span class="math inline">\(v_{O}\)</span>是有外界电源保持的数字信号，而<span class="math inline">\(v_{I1}\)</span>是没有外界电源保持的模拟信号。</p><p>由于某种扰动，使得<span class="math inline">\(v_{I1}\)</span>上升，那么<span class="math inline">\(v_{O1}\)</span>下降，<span class="math inline">\(v_{O2}\)</span>上升，通过电容<span class="math inline">\(C\)</span>反过来作用到<span class="math inline">\(v_{I1}\)</span>使其继续上升，进入了正反馈过程。当<span class="math inline">\(v_{O2}\)</span>提升到高电平<span class="math inline">\(V_{DD}\)</span>，<span class="math inline">\(v_{I1}\)</span>提升到<span class="math inline">\(V_{TH}+V_{DD}\)</span>时，电路进入第一个暂稳态。</p><p>在第一个暂稳态，电容<span class="math inline">\(C\)</span>经过<span class="math inline">\(R_F\)</span>把电放到<span class="math inline">\(G_1\)</span>门的地中，放电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231114936.png" alt="放电回路" /><figcaption aria-hidden="true">放电回路</figcaption></figure><p>因为<span class="math inline">\(R_F\)</span>远大于<span class="math inline">\(R_{ON}\)</span>，有： <span class="math display">\[t=R C \ln \frac{v_R(\infty)-v_R(0)}{v_R(\infty)-v_R(t)}\]</span> 由终了态电容等效于断路，得<span class="math inline">\(v_R(\infty)=0\)</span>，第一暂稳态将在<span class="math inline">\(v_R=V_{TH}\)</span>时发生改变，得： <span class="math display">\[\begin{aligned}T_1 &amp; \approx R_{\mathrm{F}} C \ln \frac{0-\left(V_{\mathrm{TH}}+V_{\mathrm{DD}}\right)}{0-V_{\mathrm{TH}}} \\&amp; =R_{\mathrm{F}} C \ln 3\end{aligned}\]</span> 当<span class="math inline">\(v_{I1}=v_R(t)\)</span>下降到<span class="math inline">\(V_{TH}\)</span>时，<span class="math inline">\(v_{O1}\)</span>拉高，<span class="math inline">\(v_{O2}\)</span>降低，反过来作用于<span class="math inline">\(v_{I1}\)</span>使得它继续下降，<span class="math inline">\(v_{I1}\)</span>下降到<span class="math inline">\(V_{TH}-V_{DD}\)</span>时，电路进入第二暂稳态。为什么之前对称的多谐振荡器只能下降到<span class="math inline">\(V_{IK}\)</span>，而这里却能下降到<span class="math inline">\(V_{TH}-V_{DD}\)</span>呢？是因为有<span class="math inline">\(R_p\)</span>的存在.</p><p>这时，电容<span class="math inline">\(C\)</span>进行充电，<span class="math inline">\(v_{I1}\)</span>开始上升，充电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231132758.png" alt="充电回路" /><figcaption aria-hidden="true">充电回路</figcaption></figure><p>计算充电时间，有： <span class="math display">\[\begin{aligned}T_2 &amp; \approx R_{\mathrm{F}} C \ln \frac{V_{\mathrm{DD}}-\left(V_{\mathrm{TH}}-V_{\mathrm{DD}}\right)}{V_{\mathrm{DD}}-V_{\mathrm{TH}}} \\&amp; =R_{\mathrm{F}} C \ln 3\end{aligned}\]</span> 当电容冲电，<span class="math inline">\(v_{I1}\)</span>上升到<span class="math inline">\(V_{TH}\)</span>后，电路又会回到第一暂稳态，如此循环，于是，一个循环的周期是： <span class="math display">\[T=T_1+T_2=R_FC\cdot 2\ln 3\]</span></p><h4 id="环形振荡电路">环形振荡电路</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231448009.png" alt="基本环形振荡电路" /><figcaption aria-hidden="true">基本环形振荡电路</figcaption></figure><p>上图是基本环形振荡电路，由3个非门首尾相连构成，利用非门之间的传输延时<span class="math inline">\(t_{pd}\)</span>来进行振荡，它的周期是 <span class="math display">\[T=2nt_{pd}\]</span> 但是这个周期太短了，而且不可控，于是可以通过加阻容的方式增大这个延时：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231450308.png" alt="实用环形振荡器" /><figcaption aria-hidden="true">实用环形振荡器</figcaption></figure><p>当<span class="math inline">\(v_{I2}\)</span>发生负跳变时，这个负跳变由电容<span class="math inline">\(C\)</span>传递到<span class="math inline">\(v_{I3}\)</span>，使得<span class="math inline">\(v_{I3}\)</span>也被下拉。但是<span class="math inline">\(G_2\)</span>的输出口上呈现出高电平，于是电容开始充电直到达到<span class="math inline">\(V_{TH}\)</span>。电容的充电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231454667.png" alt="充电回路" /><figcaption aria-hidden="true">充电回路</figcaption></figure><p>主要是由<span class="math inline">\(V_{OH2}\)</span>和<span class="math inline">\(G_3\)</span>的外接电源<span class="math inline">\(V_{CC}\)</span>来对<span class="math inline">\(C\)</span>进行充电的。有： <span class="math display">\[R_E=\frac{R(R_1+R_s)}{R+R_1+R_s}\]</span></p><p><span class="math display">\[V_E=V_{OH}+(V_{CC}-V_{BE}-V_{OH})\frac{R}{R+R_1+R_s}\]</span></p><p>因此，从<span class="math inline">\(v_{I3}=V_{TH}-V_{OH}+V_{OL}\)</span>充电到<span class="math inline">\(V_{TH}\)</span>的时间为： <span class="math display">\[T_1=R_{\mathrm{E}} C \ln \frac{V_{\mathrm{E}}-\left[V_{\mathrm{TH}}-\left(V_{\mathrm{OH}}-V_{\mathrm{OL}}\right)\right]}{V_{\mathrm{E}}-V_{\mathrm{TH}}}\]</span> <span class="math inline">\(v_{I3}\)</span>达到<span class="math inline">\(V_{TH}\)</span>以后，引发<span class="math inline">\(G_3\)</span>输出端<span class="math inline">\(v_{O},v_{I1}\)</span>跳变到低电平，<span class="math inline">\(v_{I2}\)</span>跳变到高电平，进一步拉高<span class="math inline">\(v_{I3}\)</span>到<span class="math inline">\(V_{TH}+V_{OH}-V_{OL}\)</span>，然后<span class="math inline">\(C\)</span>开始放电，放电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231506341.png" alt="放电回路" /><figcaption aria-hidden="true">放电回路</figcaption></figure><p>放电时间为： <span class="math display">\[T_2=R C \ln \frac{V_{\mathrm{OL}}-\left[V_{\mathrm{TH}}+\left(V_{\mathrm{OH}}-V_{\mathrm{OL}}\right)\right]}{V_{\mathrm{OL}}-V_{\mathrm{TH}}}\]</span> 充放电时间之和即为振荡周期，有： <span class="math display">\[T=T_1+T_2 \approx R C \ln \left(\frac{2 V_{\mathrm{OH}}-V_{\mathrm{TH}}}{V_{\mathrm{OH}}-V_{\mathrm{TH}}} \cdot \frac{V_{\mathrm{OH}}+V_{\mathrm{TH}}}{V_{\mathrm{TH}}}\right)\]</span> 这里约等于的条件是<span class="math inline">\(R_1+R_s&gt;&gt;R,V_{OL}=0\)</span>，进而<span class="math inline">\(V_E=V_{OH},R_E=R\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231520051.png" alt="波形图" /><figcaption aria-hidden="true">波形图</figcaption></figure><h4 id="施密特触发器多谐振荡器">施密特触发器多谐振荡器</h4><p>其原理是让电压在施密特触发器的滞回线<span class="math inline">\(V_{T+},V_{T-}\)</span>之间来回摆动，在输出端得到矩形波，</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231515840.png" alt="基本电路" style="zoom:33%;" /></p><p>一开始，<span class="math inline">\(v_I=0\)</span>，输出<span class="math inline">\(v_O\)</span>是高电平，通过<span class="math inline">\(R\)</span>向<span class="math inline">\(C\)</span>充电。设<span class="math inline">\(V_{OH}=V_{DD},V_{OL}=0\)</span>，充电时间为： <span class="math display">\[T_0=RC\ln \frac{V_{DD}}{V_{DD-V_{T+}}}\]</span> 达到<span class="math inline">\(V_{T+}\)</span>后，<span class="math inline">\(v_{O}\)</span>转化为低电平，<span class="math inline">\(C\)</span>开始放电，放电时间为： <span class="math display">\[T_2=RC\ln \frac{V_{T+}}{V_{T-}}\]</span> 放到<span class="math inline">\(V_{T-}\)</span>后，<span class="math inline">\(v_O\)</span>再次变成高电平，<span class="math inline">\(C\)</span>又开始充电，有： <span class="math display">\[T_1=R C \ln \left(\frac{V_{\mathrm{DD}}-V_{\mathrm{T}-}}{V_{\mathrm{DD}}-V_{\mathrm{T}+}}\right)\]</span> 系统周期振荡的周期为 <span class="math display">\[T=T_1+T_2\]</span> 占空比为 <span class="math display">\[p=\frac {T_1}{T}\]</span> 于是，只要我们通过两个二极管，使得电容充放电时的时间常数不同，就能控制占空比了，改进电路如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231521147.png" alt="image-20221223152142047" style="zoom:33%;" /></p><p>波形图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231522032.png" alt="施密特振荡器波形图" /><figcaption aria-hidden="true">施密特振荡器波形图</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波技术·路之章</title>
    <link href="/2022/12/17/%E5%BE%AE%E6%B3%A2%C2%B7%E8%B7%AF%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/17/%E5%BE%AE%E6%B3%A2%C2%B7%E8%B7%AF%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="微波网络">微波网络</h2><p>微波网络研究的对象是微波系统中的“不均匀区”（也叫微波结），如下图所示，可以由左图等效为右图分析问题</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212051713899.png" alt="微波网络" /><figcaption aria-hidden="true">微波网络</figcaption></figure><p>其基本思想是：把单模波导等效为双导线，把各种微波元件等效为微波网络。</p><h3 id="单模波导等效为双导线">单模波导等效为双导线</h3><ol type="1"><li><p>等效复功率、电压、电流</p><p>如果用电磁场表示的复功率，和用电压电流表示的复功率相等，有： <span class="math display">\[\dot{P}=\frac{1}{2} \int_S\left(\dot{\vec{E}}_{\mathrm{T}} \times \dot{\vec{H}}_{\mathrm{T}}^*\right) \cdot \hat{i}_z \mathrm{~d} S=\frac{1}{2} \dot{U} \dot{I}^*\]</span> 将电磁场纵横分离，有： <span class="math display">\[\dot{\vec{E}}_{\mathrm{T}}(u, v, z)=\vec{e}_{\mathrm{T}}(u, v) \cdot \dot{U}(z)\]</span></p><p><span class="math display">\[\dot{\vec{H}}_{\mathrm{T}}(u, v, z)=\vec{h}_{\mathrm{T}}(u, v) \cdot \dot{I}(z)\]</span></p><p>其中<span class="math inline">\(e,h\)</span>叫矢量模式函数。满足： <span class="math display">\[\int_S\left(\vec{e}_{\mathrm{T}} \times \vec{h}_{\mathrm{T}}\right) \cdot \hat{i}_z \mathrm{~d} S=1\]</span></p></li><li><p>等效特性阻抗<span class="math inline">\(Z_0\)</span></p><p>设波导等效特性阻抗<span class="math inline">\(Z_0\)</span>，被等效的波导模式的波阻抗<span class="math inline">\(\eta_w\)</span>，有： <span class="math display">\[\frac{|\vec e_T|}{|\vec h_T|}=\frac{\eta_w}{Z_0}\]</span></p></li><li><p>相位常数</p><p>取被等效的波导模式的轴向相位常数。</p></li></ol><h3 id="不均匀区等效为网络">不均匀区等效为网络</h3><p>电路参量，也就是反映参考平面上电压和电流的关系的网络参量。</p><ol type="1"><li><p>阻抗参量</p><p>由方程 <span class="math display">\[\dot{U}_i=\sum_{j=1}^n Z_{i j} \dot{I}_j,(i=1,2, \cdots, n)\]</span> 得： <span class="math display">\[[\dot{\boldsymbol{U}}]=[\boldsymbol{Z}][\dot{\boldsymbol{I}}]\]</span> 其中<span class="math inline">\(Z_{ij}\)</span>是比例系数，称为阻抗。<span class="math inline">\(i=j\)</span>时叫自阻抗，否则叫互阻抗。 详细地来说：</p><ul><li><span class="math inline">\(Z_{ii}\)</span>表示其余端口开路时，端口<span class="math inline">\(i\)</span>的输入阻抗。</li><li><span class="math inline">\(Z_{ij}\)</span>表示端口<span class="math inline">\(i\)</span>开路时，端口<span class="math inline">\(j\)</span>到端口<span class="math inline">\(i\)</span>的转移阻抗。</li></ul></li><li><p>导纳参量 <span class="math display">\[\dot{I}_i=\sum_{j=1}^n Y_{i j} \dot{U}_j,(i=1,2, \cdots, n)\]</span> 即： <span class="math display">\[[\dot{\mathbf{I}}]=[\boldsymbol{Y}][\dot{\boldsymbol{U}}]\]</span> 其中的<span class="math inline">\([Y]\)</span>就是导纳参量矩阵。其物理意义为：</p><ul><li><span class="math inline">\(Y_{ii}\)</span>表示其它端口短路时，端口<span class="math inline">\(i\)</span>的输入导纳。</li><li><span class="math inline">\(Y_{ij}\)</span>表示端口<span class="math inline">\(i\)</span>短路时，端口<span class="math inline">\(j\)</span>到端口<span class="math inline">\(i\)</span>的转移导纳。</li></ul></li></ol><h3 id="归一化参量">归一化参量</h3><p>因为反射系数是一个很直观而且容易测量的量，仿照“传输线理论”，定义归一化阻抗： <span class="math display">\[\bar{Z}=\frac{Z}{Z_0}=\frac{1+\Gamma}{1-\Gamma}\]</span> 于是，可以直接导出归一化电压、电流，有： <span class="math display">\[\bar{Z}=\frac{Z}{Z_0}=\frac{\dot{U} / \dot{I}}{Z_0}=\frac{\dot{U} / \sqrt{Z_0}}{\dot{I} \sqrt{Z_0}}=\frac{\bar{U}}{\bar{I}}\]</span> 即： <span class="math display">\[\begin{cases}\bar U=\dot U/\sqrt{Z_0}\\\bar I=\dot I\sqrt{Z_0}\end{cases}\]</span> 传输线理论中所有关系式都成立，可以应用史密斯圆图.用归一化电压和电流，可以导出归一化阻抗、导纳参量。</p><h3 id="散射参量">散射参量</h3><p>在传输线理论中，我们学习了入射波和反射波的概念，这是研究散射参量的出发点 。散射参量描述的是进入网络的电压波和离开网络电压波的关系。 定义<span class="math inline">\(a\)</span>为进入网络的归一化电压波，定义<span class="math inline">\(b\)</span>为离开网络的归一化电压波。</p><p>有： <span class="math display">\[\left\{\begin{array}{l}a_i=\frac{1}{2}\left(\bar{U}_i+\bar{I}_i\right) \\b_i=\frac{1}{2}\left(\bar{U}_i-\bar{I}_i\right)\end{array}\right.\]</span></p><p>对<span class="math inline">\(n\)</span>端口的微波网络，我们可以把出波表示为入波的响应，也就是线性组合的形式。 <span class="math display">\[b_i=\sum_{j=1}^n S_{i j} a_j(i=1,2 \ldots n)\]</span> 即： <span class="math display">\[[b]=[S][a]\]</span> 其中的<span class="math inline">\([S]\)</span>就是散射参量矩阵。</p><p>在讨论散射参量矩阵的物理意义之前，首先要明确端口匹配负载和端口匹配的概念。</p><p>端口接匹配负载的意思是指端口接负载，并且所接的负载和端口传输线匹配，负载的反射波为零，即对该端口的进波为零。如果说第<span class="math inline">\(i\)</span>个端口接匹配负载，则<span class="math inline">\(a_i=0\)</span>.</p><p>端口匹配的意思是，在其它端口接负载的情况下，从该端口看进去的网络本身作为终端等效负载时和端口传输线匹配，网络反射波为零，即端口出波为零，即<span class="math inline">\(b_i=0\)</span>.</p><p>那么<span class="math inline">\([S]\)</span>矩阵的物理意义是：在除了波源所在的第<span class="math inline">\(j\)</span>端口以外的其余各端口均接匹配负载，散射矩阵的非对角线元素<span class="math inline">\(S_{ij}\)</span>是<strong>第<span class="math inline">\(j\)</span>端口到第<span class="math inline">\(i\)</span>端口</strong>（注意是反的）的电压传输系数，其对角线元素<span class="math inline">\(S_{jj}\)</span>是波源所在的第<span class="math inline">\(j\)</span>端口的电压反射系数。</p><h4 id="用散射参量描述网络性质">用散射参量描述网络性质</h4><ol type="1"><li><p>互易性</p><p>当微波元件内部为各向同性均匀媒质,即媒质极化、磁化、传导性质与外加场方向无关，进而与电磁波的传播方向无关时,其等效网络的任意两个端口都是可逆的，该网络称为可逆网络或互易网络。</p><p>可以证明，互易网络的<span class="math inline">\(S\)</span>矩阵是转置不变的，即： <span class="math display">\[S^T=S\]</span></p></li><li><p>无耗性</p><p>无耗网络的<span class="math inline">\(S\)</span>矩阵是酉矩阵<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，即： <span class="math display">\[S^+S=1\]</span></p></li><li><p>对称性</p><p>如果微波网络具有对称性，例如第<span class="math inline">\(i\)</span>端口和第<span class="math inline">\(j\)</span>端口是对称的，那么 <span class="math display">\[S_{ii}=S_{jj}\]</span></p></li></ol><h4 id="散射参量和阻抗导纳参量的转换">散射参量和阻抗导纳参量的转换</h4><p><span class="math display">\[[\bar{Z}]=([1]+[S])([1]-[S])^{-1}\]</span></p><p><span class="math display">\[[S]=([\bar{Z}]-[1])([\bar{Z}]+[1])^{-1}\]</span></p><p><span class="math display">\[[\bar{Y}]=([1]-[S])([1]+[S])^{-1}\]</span></p><p><span class="math display">\[[S]=([1]-[\bar{Y}])([1]+[\bar{Y}])^{-1}\]</span></p><h4 id="参考平面移动对s矩阵的影响">参考平面移动对S矩阵的影响</h4><p>对于<span class="math inline">\(n\)</span>端口网络，各端口参考面外移长度为<span class="math inline">\(l_1,l_2\cdots l_n\)</span>时，移动后的<span class="math inline">\(S&#39;\)</span>矩阵和原来的<span class="math inline">\(S\)</span>矩阵的关系为： <span class="math display">\[S&#39;=PSP\]</span> 其中<span class="math inline">\(P\)</span>是一个<span class="math inline">\(n\)</span>阶对角阵，满足： <span class="math display">\[P_{kk}=e^{-j\beta l_k}\]</span></p><h3 id="二端网络">二端网络</h3><p>二端网络的阻抗、导纳参量、散射参量、传输参量没有什么特别值得说的。矩阵各元素的物理意义已经在前面给出了。</p><h4 id="二端网络的性质">二端网络的性质</h4><ul><li><p>互易性 <span class="math display">\[\begin{aligned}&amp; \bar{Z}_{12}=\bar{Z}_{21} \\&amp; \bar{Y}_{12}=\bar{Y}_{21} \\&amp; S_{12}=S_{21}\end{aligned}\]</span></p></li><li><p>对称性 <span class="math display">\[\begin{aligned}&amp; \bar{Z}_{11}=\bar{Z}_{22} \\&amp; \bar{Y}_{11}=\bar{Y}_{22} \\&amp; S_{11}=S_{22}\end{aligned}\]</span></p></li><li><p>无耗性 <span class="math display">\[\begin{aligned}\overline{\boldsymbol{Z}}^{+}&amp;=-\overline{\boldsymbol{Z}} \\\bar{Y}^{+}&amp;=-\bar{Y} \\S^{+}S &amp;=I\end{aligned}\]</span></p><blockquote><p>这个无耗性是从能量守恒定理出发的。如果我们把这个共轭转置展开，有以下四个式子： <span class="math display">\[\begin{gathered}S_{11}^{*} S_{11}+S_{21}^{*} S_{21}=\left|S_{11}\right|^2+\left|S_{21}\right|^2=1 \\S_{12}^* S_{12}+S_{22}^{\cdot} S_{22}=\left|S_{12}\right|^2+\left|S_{22}\right|^2=1 \\S_{11}^* S_{12}+S_{21}^* S_{22}=0 \\S_{22}^* S_{14}+S_{22}^* S_{21}=0\end{gathered}\]</span></p></blockquote><blockquote><p>根据 <span class="math inline">\(S\)</span> 参量物理意义有 <span class="math display">\[\begin{array}{ll}\left|S_{11}\right|^2=\left.\frac{\left|b_1\right|^2}{\left|a_1\right|^2}\right|_{a_2=0}=\left.\frac{\left(P^{-}\right)_1}{\left(P^{+}\right)_1}\right|_{a_2=0}  \\\left|S_{21}\right|^2=\left.\frac{\left|b_2\right|^2}{\left|a_1\right|^2}\right|_{a_2=0}=\left.\frac{\left(P^{-}\right)_2}{\left(P^{+}\right)_1}\right|_{a_2=0} \end{array}\]</span> 式中, <span class="math inline">\(\left(P^{-}\right)_1\)</span> 表示端口 1 输出功率大小, <span class="math inline">\(\left(P^{-}\right)_2\)</span> 表示端口 2 输出功率大小, <span class="math inline">\(\left(P^{+}\right)\)</span>，表示端口 1 输人功率大小。 <span class="math inline">\(\left|S_{11}\right|^2\)</span> 表示端口 1 接波源, 端口 2 接匹配负载时, 端口 1 的功率反射系数, <span class="math inline">\(\left|S_{21}\right|^2\)</span> 表示此时从端口 1 到端口 2 的功率传输系数。 式 <span class="math inline">\(\left|S_{11}\right|^2+\left|S_{21}\right|^2=1\)</span> 表示当端口 2 接匹配负载时, 从端口 1 输人的功率分为 两部分：一部分被系统反射 <span class="math inline">\(\left(\left|S_{11}\right|^2\right)\)</span>, 另一部分被系统传输到端口 <span class="math inline">\(2\left(\left|S_{21}\right|^2\right)\)</span> 并被负载吸收。</p><p>式 <span class="math inline">\(\left|S_{12}\right|^2+\left|S_{22}\right|^2=1\)</span> 表示当端口 1 接匹配负载时, 从端口 2 输人的能量分为 两部分： 一部分被系统反射 <span class="math inline">\(\left(\left|S_{22}\right|^2\right)\)</span>, 另一部分被系统传输到端口 <span class="math inline">\(1\left(\left|S_{12}\right|^2\right)\)</span> 并被负载吸收。</p></blockquote></li></ul><p>二端口网络中，有：</p><ul><li>如果一个端口匹配，那么另一个端口匹配</li><li>如果网络完全匹配，那么完全传输</li></ul><h4 id="用散射参量表示网络外特性">用散射参量表示网络外特性</h4><ul><li><p>电压传输系数：输出端口出波和输入端口入波之比 <span class="math display">\[T=\left.\frac{b_2}{a_1}\right|_{a_2=0}=S_{21}\]</span></p></li><li><p>插入衰减：输出端接匹配负载，输入端进波功率和输出端出波功率之比 <span class="math display">\[L=\left.\frac{\left(P^*\right)_1}{\left(P^{-}\right)_2}\right|_{a_2=0}=\left.\frac{\left|a_1\right|^2}{\left|b_2\right|^2}\right|_{a_2=0}=\frac{1}{\left|S_{21}\right|^2}=\frac{1}{T^2}\]</span> 它可以分解为两项： <span class="math display">\[L=\frac{1-\left|S_{11}\right|^2}{\left|S_{21}\right|^2} \cdot \frac{1}{1-\left|S_{11}\right|^2}\]</span> 前一项叫吸收衰减，记作<span class="math inline">\(L_a\)</span>，由网络本身引起；后项叫反射衰减，记作<span class="math inline">\(L_r\)</span>，由输入端和外接输入线不匹配引起。</p></li><li><p>插入相移：出端接匹配负载，输入端进波和输出端出波相位差 <span class="math display">\[\phi=\theta_{21}=\arg T=\arg S_{21}\]</span></p></li><li><p>输入驻波比：出端接匹配负载，输入端测得驻波比 <span class="math display">\[L=\frac{1}{\left|S_{21}\right|^2}=\frac{1}{1-\left|S_{11}\right|^2}=\frac{(\rho+1)^2}{4 \rho}\]</span></p></li><li><p>回波损耗：出端接匹配负载，输入端入射波功率和反射波功率之比 <span class="math display">\[R L=\left.10 \lg \frac{\left(P^{+}\right)_1}{\left(P^{-}\right)_1}\right|_{a_2=0}=\left.10 \lg \frac{\left|a_1\right|^2}{\left|b_1\right|^2}\right|_{a_2=0}=-20 \lg \left|S_{11}\right|\]</span></p></li></ul><h4 id="二端口网络的互联">二端口网络的互联</h4><ol type="1"><li><p>串联</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182232843.png" alt="二端网络串联" /><figcaption aria-hidden="true">二端网络串联</figcaption></figure><p>有： <span class="math display">\[Z=Z_1+Z_2\]</span> 可以类比为电阻（阻抗）串联，阻值相加。</p></li><li><p>并联</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182235435.png" alt="二端网络并联" /><figcaption aria-hidden="true">二端网络并联</figcaption></figure><p>有： <span class="math display">\[Y=Y_1+Y_2\]</span> 可以类比导纳并联的电导等于各电导之和</p></li><li><p>级联</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182237317.png" alt="二端网络级联" /><figcaption aria-hidden="true">二端网络级联</figcaption></figure><p>有 ： <span class="math display">\[T=T_1\cdot T_2\]</span></p></li></ol><h4 id="转移参量">转移参量</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182248801.png" alt="二端口网络示意图" /> <span class="math display">\[\left\{\begin{array}{l}\dot{U}_1=a \dot{U}_2+b\left(-\dot{I}_2\right) \\\dot{I}_1=c \dot{U}_2+d\left(-\dot{I}_2\right)\end{array}\right.\]</span> 即： <span class="math display">\[\left[\begin{array}{l}\dot{U}_1 \\\dot{I}_1\end{array}\right]=\left[\begin{array}{ll}a &amp; b \\c &amp; d\end{array}\right]\left[\begin{array}{c}\dot{U}_2 \\-\dot{I}_2\end{array}\right]=[A]\left[\begin{array}{c}\dot{U}_2 \\-\dot{I}_2\end{array}\right]\]</span> 其中<span class="math inline">\(A\)</span>称为转移矩阵，其中的各个元素称为转移参量。</p><p>归一化转移参量：把上面式子中的电压电流都换成归一化的，有： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\bar{a} &amp; \bar{b} \\\bar{c} &amp; \bar{d}\end{array}\right]=\left[\begin{array}{cc}a \sqrt{\frac{Z_{02}}{Z_{01}}} &amp; \frac{b}{\sqrt{Z_{01} Z_{02}}} \\c \sqrt{Z_{01} Z_{02}} &amp; d \sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p><p>转移参量和其它参量的关系：</p><ol type="1"><li><p>散射参量 <span class="math display">\[[S]=\frac{1}{\bar{a}+\bar{b}+\bar{c}+\bar{d}}\left[\begin{array}{cc}\bar{a}+\bar{b}-\bar{c}-\bar{d} &amp; 2|\bar{A}| \\2 &amp; -\bar{a}+\bar{b}-\bar{c}+\bar{d}\end{array}\right]\]</span> 反过来，有： <span class="math display">\[[\bar{A}]=\frac{1}{2 S_{21}}\left[\begin{array}{ll}1-|S|+S_{11}-S_{22} &amp; 1+|S|+S_{11}+S_{22} \\1+|S|-S_{11}-S_{22} &amp; 1-|S|-S_{11}+S_{22}\end{array}\right]\]</span></p></li><li><p>阻抗参量 <span class="math display">\[[\bar{Z}]=\frac{1}{c}\left[\begin{array}{cc}\bar{a} &amp; |\bar{A}| \\1 &amp; \bar{d}\end{array}\right]\]</span> 反过来，有： <span class="math display">\[[\bar{A}]=\frac{1}{Z_{21}}\left[\begin{array}{cc}\bar{Z}_{11} &amp; |\bar{Z}| \\1 &amp; \bar{Z}_{22}\end{array}\right]\]</span></p></li><li><p>导纳参量 <span class="math display">\[[\bar{Y}]=\frac{1}{b}\left[\begin{array}{cc}\bar{d} &amp; -|\bar{A}| \\-1 &amp; \bar{a}\end{array}\right]\]</span> 反过来，有： <span class="math display">\[[\bar{A}]=-\frac{1}{\bar Y_{21}}\left[\begin{array}{cc}\bar{Y}_{22} &amp; 1 \\\mid \bar{Y}\mid &amp; \bar{Y}_{11}\end{array}\right]\]</span></p></li></ol><p>至于二端口网络的各种性质，也可以用转移参量描述：</p><ol type="1"><li><p>互易性： <span class="math display">\[|\bar A|=|A|=1\]</span></p></li><li><p>对称性： <span class="math display">\[\begin{array}{ll}\bar{a}=\bar{d}, &amp; |\bar{A}|=\bar{a} \bar{d}-\bar{b} \bar{c}=1 \\a=d, &amp; |A|=a d-b c=1\end{array}\]</span></p></li><li><p>无耗互易： <span class="math display">\[\bar a,\bar d\in \mathbb R\]</span></p><p><span class="math display">\[\bar b,\bar c\in \mathbb I\]</span></p></li></ol><h4 id="基本电路单元">基本电路单元</h4><ol type="1"><li><p>串联阻抗</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192031951.png" alt="串联阻抗" /><figcaption aria-hidden="true">串联阻抗</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{ll}1 &amp; 0 \\Y &amp; 1\end{array}\right]\]</span> 归一化： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\sqrt{\frac{Z_{02}}{Z_{01}}} &amp; 0 \\Y \sqrt{Z_{01} Z_{02}} &amp; \sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p></li><li><p>不同阻抗的传输线相连</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192040220.png" alt="不同阻抗的传输线相连" /><figcaption aria-hidden="true">不同阻抗的传输线相连</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{ll}1 &amp; 0 \\0 &amp; 1\end{array}\right]\]</span> 归一化转移矩阵： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\sqrt{\frac{Z_{02}}{Z_{01}}} &amp; 0 \\0 &amp; \sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p></li><li><p>理想变压器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192041717.png" alt="理想变压器" /><figcaption aria-hidden="true">理想变压器</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{ll}n^{-1} &amp; 0 \\0 &amp; n\end{array}\right]\]</span> 归一化： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\frac{1}{n} \sqrt{\frac{Z_{02}}{Z_{01}}} &amp; 0 \\0 &amp; n\sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p></li><li><p>一段均匀传输线：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192045931.png" alt="均匀传输线" /><figcaption aria-hidden="true">均匀传输线</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{cc}\cos \beta l &amp; \mathrm{j} Z_0 \sin \beta l \\\frac{\mathrm{j} \sin \beta l}{Z_0} &amp; \cos \beta l\end{array}\right]\]</span> 归一化： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\cos \beta l &amp; j \sin \beta l \\j \sin \beta l &amp; \cos \beta l\end{array}\right]\]</span></p></li></ol><h3 id="无耗三端口网络">无耗三端口网络</h3><p>具有以下性质：</p><ol type="1"><li>无耗互易三端口网络不可能完全匹配。如果端口1、2匹配，那么端口3和网络完全隔离，即<span class="math inline">\(S_{13}=S_{23}=0\)</span></li><li>任何完全匹配的无耗三端口网络一定是非互易的。</li><li>对称互易无耗的三端口网络，输入驻波比不低于2</li><li>无耗互易三端口网络中任意端口接短路活塞，总可以找到活塞的一个位置，使其它两个端口互相隔离。</li><li>如果无耗互易三端口网络对于接有短路活塞的端口是对称的，则总可以找到活塞的一个位置，使其它两个端口之间可以无耗的传输。</li></ol><h3 id="无耗四端口网络">无耗四端口网络</h3><p>具有以下性质：</p><ol type="1"><li>如果一个无耗互易四端口网络的任意三个端口匹配，则第四个端口自动匹配，且该网络构成一个定向耦合器。所谓的定向耦合器是指对四端口元件，当某个端口接波源、其余端口接匹配负载时，必然和其中一个端口理想隔离。理想定向性要求接波源的端口无反射，即输入端口匹配。</li><li>有理想定向性的无耗互易四端口网络不一定四个端口都匹配。</li><li>有两个端口匹配且互相隔离的无耗互易四端口网络一定是完全匹配的定向耦合器。</li></ol><h2 id="微波元件">微波元件</h2><h3 id="一端口元件">一端口元件</h3><ol type="1"><li><p>短路负载</p><p>扼流式短路负载的基本原理是：利用传输线的<span class="math inline">\(\lambda/4\)</span>波长阻抗变换特性，把有高频电流流过，需要良好电接触的地方，恰好安排在电压波节点（电流波腹点）处，从而得到等效短路。</p></li><li><p>匹配负载</p><p>它可以几乎无反射地吸收入射波的全部功率，在传输系统中建立行波状态。</p></li><li><p>失配负载</p><p>它具有某一个固定的驻波比，在微波测量中作为标准终端负载。</p></li></ol><h3 id="二端口元件">二端口元件</h3><ol type="1"><li><p>波导接头</p><p>是用来把传输线接在一起的。有平接头、扼流接头等。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192224219.png" alt="波导接头" /><figcaption aria-hidden="true">波导接头</figcaption></figure><p>扼流接头在连接波导的法兰盘上有一个深为<span class="math inline">\(\lambda_g/4\)</span>的槽，这样可以保证接头处恰好是电流波腹点。</p></li><li><p>拐角、弯曲、扭转元件</p></li><li><p>调配元件</p><p>是一些电抗元件，放在传输线上，产生附加反射，使得传输线匹配。</p><ol type="1"><li>电抗膜片：分为感性膜片、容性膜片、谐振窗</li><li>销钉</li><li>螺钉匹配器</li></ol></li><li><p>衰减器</p><p>吸收式衰减器散射矩阵： <span class="math display">\[S=\begin{pmatrix}0 &amp; e^{-\alpha t}\\e^{-\alpha t} &amp; 0\end{pmatrix}\]</span> 截止式衰减器：插入一个比较小的传输线，使得电磁场在这一小段里面截止。其特点有：</p><ol type="1"><li>衰减量dB和距离呈线性关系</li><li>当<span class="math inline">\(\lambda_c&lt;&lt;\lambda\)</span>，衰减系数<span class="math inline">\(\alpha\)</span>很大，移动较小的距离就可以得到很大的衰减量</li><li>衰减是由于反射产生，输入端和输出端严重失配</li></ol><p>还有极化衰减器</p></li><li><p>相移器</p><p>其S矩阵为： <span class="math display">\[S=\begin{pmatrix}0 &amp; e^{-j\beta l}\\e^{-j\beta l} &amp; 0\end{pmatrix}\]</span></p></li></ol><hr /><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>酉矩阵也叫幺正矩阵，即它的共轭转置和它的乘积是单位矩阵。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变泛函笔记·泛函分析之章</title>
    <link href="/2022/12/15/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD%E7%AC%94%E8%AE%B0%C2%B7%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/15/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD%E7%AC%94%E8%AE%B0%C2%B7%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="度量空间和赋范线性空间">度量空间和赋范线性空间</h2><h3 id="度量距离空间">度量（距离）空间</h3><p>如果<span class="math inline">\(X\)</span>是一个非空集合，对于<span class="math inline">\(X\)</span>中的任何两个元素<span class="math inline">\((x,y)\)</span>，都有一个实数<span class="math inline">\(d(x,y)\)</span>与之对应，且满足：</p><ol type="1"><li><span class="math inline">\(d(x,y)\geq 0\)</span>，等号仅在<span class="math inline">\(x=y\)</span>时取得</li><li><span class="math inline">\(d(x,y)=d(y,x)\)</span></li><li><span class="math inline">\(d(x,z)\leq d(x,y)+d(y,z)\)</span>，也就是“三角形两边之和大于第三边”</li></ol><p>那么称函数<span class="math inline">\(d\)</span>是<span class="math inline">\(X\)</span>上的一个距离（度量），<span class="math inline">\((X,d)\)</span>是距离空间。</p><p>事实上，对于任何非空集合，我们都可以让他变成距离空间，大不了定义<code>d(x,y)=(x==y)?0:1</code>嘛。</p><h4 id="常用的距离空间">常用的距离空间</h4><ol type="1"><li><p><span class="math inline">\(R\)</span>，<span class="math inline">\(d(x,y)=|y-x|\)</span></p></li><li><p><span class="math inline">\(R^n\)</span>，有很多种<span class="math inline">\(d\)</span>的定义，列举三种： <span class="math display">\[\begin{aligned}&amp; d_1(x, y)=\sum_{i=1}^n\left|x_i-y_i\right| \\&amp; d_2(x, y)=\left(\sum_{i=1}^n\left|x_i-y_i\right|^2\right)^{1 / 2} \\&amp; d_3(x, y)=\max _{\forall i}\left|x_i-y_i\right|^2\end{aligned}\]</span></p></li><li><p><span class="math inline">\(C[a,b]\)</span>，指<span class="math inline">\([a,b]\)</span>上的连续函数构成的集合 <span class="math display">\[d(x, y)=\max _{a \leq t \leq b}|x(t)-y(t)|, \forall x, y \in C[a, b]\]</span> 距离定义为定义域内两个函数垂直距离的最大值</p></li><li><p>所有序列构成的集合<span class="math inline">\(S\)</span></p><p>如果<span class="math inline">\(x=\{\xi_i\},y=\{\eta_i\}\)</span>，则 <span class="math display">\[d(x, y)=\sum_{i=1}^{\infty} \frac{1}{2^i} \frac{\left|\xi_i-\eta_i\right|}{1+\left|\xi_i-\eta_i\right|}\]</span> 提示：验证第三条公理只需考察函数<span class="math inline">\(f(x)=\frac{x}{1+x}\)</span>的单调性</p></li><li><p>有界序列空间<span class="math inline">\(l^\infty\)</span> <span class="math display">\[d(x, y)=\sup _{\forall i}\left|\xi_i-\eta_i\right|\]</span></p></li><li><p>收敛序列空间<span class="math inline">\(c\)</span></p><p>距离的定义同有界数列空间一样</p></li><li><p><span class="math inline">\(p\)</span>次可和序列空间<span class="math inline">\(l^p\)</span> <span class="math display">\[l^p=\left\{x=\left\{\xi_i\right\}\left|\sum_{i=1}^{\infty}\left| \xi_i\right|^p&lt;\infty\right.\right\}, 1 \leq p&lt;\infty\]</span> 距离： <span class="math display">\[d(x, y)=\left(\sum_{i=1}^{\infty}\left|\xi_i-\eta_i\right|^p\right)^{\frac{1}{p}}\]</span></p></li><li><p>本质有界可测函数空间<span class="math inline">\(L^\infty[a,b]\)</span></p><p>本质有界：指除了一个零测集<span class="math inline">\(E\)</span>以外都有界</p><p>距离： <span class="math display">\[d(x,y)=\inf _{m(E)=0}\left\{\sup _{t \in[a, b] \backslash E}|x(t)-y(t)|\right\}\]</span> 意思是：先遍历零测集<span class="math inline">\(E\)</span>，再对每个<span class="math inline">\(E\)</span>沿着<span class="math inline">\(x\)</span>轴找到两个函数垂直距离最大的点，再找这个最小的“最大的垂直距离”。</p></li><li><p><span class="math inline">\(p\)</span>次可积函数空间<span class="math inline">\(L^p\)</span> <span class="math display">\[d(x, y)=\left(\int_a^b|x(t)-y(t)|^p \mathrm{~d} t\right)^{1 / p}\]</span></p></li></ol><h4 id="距离空间中的拓扑">距离空间中的拓扑</h4><p>既然我们定义了距离，那么什么都好办了，距离空间中的拓扑可以对照<span class="math inline">\(R^n\)</span>中的拓扑的相关定义，包括开球、邻域、内点外点边界点、聚点、开集导集闭包等等。这些定义都是相同的。</p><p><strong>【连续映射】</strong>设<span class="math inline">\((X,d),(Y,p)\)</span>都是距离空间，<span class="math inline">\(T:X\to Y\)</span>，如果对于给定的<span class="math inline">\(x_0\in X,\forall \epsilon &gt;0,\exists\delta&gt;0,s.t. x\in X,d(x,x_0)&lt;\delta,p(T_x,T_{x_0})&lt;\epsilon\)</span>，也就是说，如果<span class="math inline">\(X\)</span>中的两点足够近，那么其映射的像在<span class="math inline">\(Y\)</span>中也足够近，那么称映射<span class="math inline">\(T\)</span>在点<span class="math inline">\(x_0\)</span>处连续。如果<span class="math inline">\(T\)</span>在<span class="math inline">\(X\)</span>的每一点都连续，称<span class="math inline">\(T\)</span>是<span class="math inline">\(X\)</span>上的连续映射。</p><p>连续有两个充要条件，可以辅助判别：</p><ol type="1"><li><span class="math inline">\(\forall x_0\in X\)</span>当<span class="math inline">\(X\)</span>中的点列<span class="math inline">\(x_n\to x_0\)</span>（距离意义上），相应<span class="math inline">\(Y\)</span>中的像点列<span class="math inline">\(Tx_n\to Tx_0\)</span>（海涅定理）</li><li>对<span class="math inline">\(Y\)</span>中的任何开集<span class="math inline">\(O\)</span>，<span class="math inline">\(T^{-1}O\)</span>是<span class="math inline">\(X\)</span>中的开集</li></ol><p><strong>【稠密性】</strong>设<span class="math inline">\((X,d)\)</span>是距离空间，<span class="math inline">\(A\subset X\)</span>，对<span class="math inline">\(\forall x\in X,x\)</span>的任何球中后含有<span class="math inline">\(A\)</span>中的点，称<span class="math inline">\(A\)</span>在<span class="math inline">\(X\)</span>中稠密</p><p><strong>【可分性】</strong>设<span class="math inline">\((X,d)\)</span>是距离空间，如果<span class="math inline">\(X\)</span>中存在可数的稠密子集，那么称<span class="math inline">\(X\)</span>是可分的。</p><blockquote><p>例如：<span class="math inline">\(R^n,l^p,s,C[a,b],P[a,b],L^p[a,b]\)</span>都是可分的。</p><p>但是<span class="math inline">\(l^\infty\)</span>是不可分的。</p></blockquote><h4 id="完备距离空间">完备距离空间</h4><p>满足“所有基本列（柯西列）都收敛”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="所有收敛列都是基本列是永远成立的。">[1]</span></a></sup>的距离空间叫做完备距离空间。</p><blockquote><p>反例1：对距离空间<span class="math inline">\((Q,d(x,y)=|x-y|)\)</span>，有基本列<span class="math inline">\(x_n=(1+1/n)^n\)</span>，在<span class="math inline">\(Q\)</span>上不收敛。</p><p>反例2：对距离空间<span class="math inline">\((X=(0,1),d(x,y)=|x-y|)\)</span>，有基本列<span class="math inline">\(x_n=1/(n+1)\)</span>，在<span class="math inline">\((0,1)\)</span>上不收敛</p></blockquote><p>典型的完备距离空间有：<span class="math inline">\(R^n,L^P,l^p,C[a,b]\)</span></p><p><strong>【等距映射】</strong>设<span class="math inline">\((X,d),(\hat X,\rho)\)</span>都是距离空间，如果存在一个映射<span class="math inline">\(T:X\to \hat X\)</span>，使得 <span class="math display">\[d(x,y)=\rho (Tx,Ty)\]</span> 称<span class="math inline">\(T\)</span>是等距映射。<span class="math inline">\(X,\hat X\)</span>称为等距同构空间。</p><p><strong>【完备化】</strong> 对距离空间<span class="math inline">\((X,d)\)</span>，如果有完备距离空间<span class="math inline">\((\hat X,\rho)\)</span>，使得这两个空间等距同构，那么称<span class="math inline">\(\hat X\)</span>是<span class="math inline">\(X\)</span>的完备化空间。每个距离空间都有自己的完备化空间。</p><h3 id="线性空间">线性空间</h3><p>在数域<span class="math inline">\(K\)</span>，集合<span class="math inline">\(X\)</span>上定义加法、数乘，满足前文提到的“线性运算加法和数乘8条性质”的集合<span class="math inline">\(X\)</span>称作向量空间或线性空间。</p><p>线性空间的性质，我们在线性代数中已经学了很多，这里仅仅列举</p><ul><li>零向量唯一</li><li>一个向量的负向量唯一</li><li>线性子空间的定义（X的子集对加法和数乘封闭）</li><li>线性组合</li><li>生成子空间</li><li>线性无关</li><li>维数</li><li>线性子空间的直和<span class="math inline">\(X=M\bigoplus N=\{m+n|\forall m\in M,\forall n\in N,M\cap N=\emptyset\}\)</span>，有<span class="math inline">\(\dim X=\dim M+\dim N\)</span></li><li>补子空间：<span class="math inline">\(X=M\bigoplus N\)</span>，称<span class="math inline">\(N\)</span>是<span class="math inline">\(X\)</span>的补。对于一个线性空间<span class="math inline">\(X\)</span>和它的一个子空间<span class="math inline">\(M\)</span>，<span class="math inline">\(M\)</span>的补一定存在。</li></ul><h4 id="赋范线性空间">赋范线性空间</h4><p>设<span class="math inline">\(X\)</span>是线性空间，且<span class="math inline">\(\forall x\in X\)</span>，存在一个非负实数<span class="math inline">\(||x||\)</span>，且</p><ol type="1"><li><span class="math inline">\(\|x\| \geq \mathbf{0},\|x\|=0 \Leftrightarrow x=\theta\)</span></li><li><span class="math inline">\(\|\alpha x\|=|\alpha| \cdot\|x\|, \forall \alpha \in C\)</span> (或 <span class="math inline">\(R)\)</span></li><li><span class="math inline">\(\|x+y\| \leq\|x\|+\|y\|, \forall x, y \in X \quad\)</span> (三角不等式）</li></ol><p>那么称<span class="math inline">\(||x||\)</span>是<span class="math inline">\(x\)</span>的范数，<span class="math inline">\((X,||\cdot||)\)</span>为赋范线性空间。</p><p>例如：在<span class="math inline">\(R^n\)</span>空间中的常用范数：</p><ol type="1"><li><p>p-范数： <span class="math display">\[\|x\|_p=\left(\sum_{i=1}^n\left|x_i\right|^p\right)^{1 / p}\]</span></p></li><li><p>无穷范数： <span class="math display">\[||x||_\infty=\max |x_i|\]</span></p></li><li><p>1-范数： <span class="math display">\[||x||_1=\sum_{i=1}^n |x_i|\]</span></p></li></ol><p>任何赋范线性空间都能诱导出一种距离： <span class="math display">\[d(x,y)=||x-y||\]</span> 但距离空间不一定能诱导出一种范数。</p><p><strong>【依范数收敛】</strong> <span class="math display">\[\lim_{n\to \infty}||x_n-x_0||=0\]</span> <strong>【范数的等价】</strong>对于不同的范数，如果存在<span class="math inline">\(C_1,C_2&gt;0\)</span>，使得 <span class="math display">\[C_1||x||_2&lt;||x||_1&lt;C_2||x||_2\]</span> 那么称这两个范数等价</p><p><strong>【巴拿赫空间】</strong>如果一个赋范线性空间按照它的范数诱导出来的距离构成的距离空间是完备距离空间，那么称这个赋范线性空间为巴拿赫空间。</p><p><strong>【有限维赋范线性空间】</strong>有如下性质：</p><ol type="1"><li>维数相等的赋范线性空间都同构</li><li>有限维线性赋范线性空间必完备且可分</li><li>赋范线性空间<span class="math inline">\(X\)</span>是列紧的，和它是有限维等价</li><li>在其上定义的各种范数都等价</li><li>从有限维到有限维的线性算子都有界</li></ol><h2 id="有界线性算子和连续线性泛函">有界线性算子和连续线性泛函</h2><p>在泛函分析中，把具有一定性质的元素的集合称为空间，把空间到空间的映射称为算子。算子的概念可以类比于平常所说的映射，也有值域、单、满、双、逆的概念。</p><p><strong>【线性算子】</strong>如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，有： <span class="math display">\[T(\alpha_1x_1+\alpha_2x_2)=\alpha_1Tx_1+\alpha_2Tx_2\]</span> 则称这个算子<span class="math inline">\(T\)</span>是线性算子。</p><p><strong>【连续算子】</strong> 如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，有： <span class="math display">\[\text{当}||x-x_0||_1\to 0\text{有}||Tx-Tx_0||_2\to 0\]</span> 称<span class="math inline">\(T\)</span>在<span class="math inline">\(x_0\)</span>处连续。如果<span class="math inline">\(T\)</span>在<span class="math inline">\(X\)</span>的每个点都连续，称其为连续算子。</p><p><strong>【同构同胚】</strong> 如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，线性</p><ol type="1"><li>如果<span class="math inline">\(T\)</span>是双射，那么称<span class="math inline">\(T\)</span>是线性同构的</li><li>进一步，如果<span class="math inline">\(T\)</span>和它的逆都是连续的，那么称<span class="math inline">\(T\)</span>是线性同胚的</li></ol><p><strong>【有界】</strong>如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，存在常数<span class="math inline">\(C\)</span>，使得对任意<span class="math inline">\(x\)</span> <span class="math display">\[||T_x||_2\leq C||x||_1\]</span> 则称 <span class="math inline">\(T\)</span>是有界的。有界当且仅当其把任意有界集映射为有界集。</p><p><strong>【算子的范数】</strong>如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>的线性有界算子，称 <span class="math display">\[||T||=\sup_{\forall x\neq \theta}\frac{||Tx||_2}{||x||_1}\]</span> 为算子<span class="math inline">\(T\)</span>的范数。</p><p>如果在上述“算子”的描述中，<span class="math inline">\(Y\)</span>是数集，那么这个算子也可以叫做“泛函”。</p><h3 id="有界线性算子空间和共轭空间">有界线性算子空间和共轭空间</h3><h4 id="有界线性算子空间">有界线性算子空间</h4><p>设全体<span class="math inline">\(T:X\to Y\)</span>构成一个集合，记作<span class="math inline">\(\mathcal L(X,Y)\)</span>。则它按范数是赋范线性空间。其中 <span class="math display">\[(A+B)x=Ax+Bx,(\alpha A)x=\alpha(Ax)\]</span> 如果<span class="math inline">\(X\)</span>是赋范线性空间，<span class="math inline">\(Y\)</span>是巴拿赫空间（按照它的范数诱导出来的距离构成的距离空间是完备距离空间的赋范线性空间），那么<span class="math inline">\(\mathcal L(X,Y)\)</span>也是巴拿赫空间。</p><p>如果<span class="math inline">\(A,B\in \mathcal L(X,Y)\)</span>，则<span class="math inline">\(AB\in L(X,Y)\)</span>，且<span class="math inline">\(||AB||\leq ||A||\cdot||B||\)</span>。进一步，有：<span class="math inline">\(||A^n||\leq ||A||^n\)</span></p><p><strong>【范数的强弱】</strong> 对于同一个集合上的两个范数，如果： <span class="math display">\[(||x_n||_1\to 0)\to (||x_n||_2\to 0)\]</span> 称范数1比范数2更强。</p><h4 id="算子的逆">算子的逆</h4><p>设 <span class="math inline">\(X, Y\)</span> 都是线性赋范空间, <span class="math inline">\(A: X \rightarrow Y\)</span> 是线性映射. 那么 <span class="math inline">\(A\)</span> 是单射, 且定义在 <span class="math inline">\(R(A)\)</span> 上的算子 <span class="math inline">\(A^{-1}\)</span> 是连续的 <span class="math inline">\(\Leftrightarrow\)</span> 存在常数 <span class="math inline">\(m&gt;0\)</span>, 使 <span class="math inline">\(\|A x\| \geq m\|x\|, \forall x \in X\)</span>.</p><p>设 <span class="math inline">\(X\)</span> 为 Banach空间, <span class="math inline">\(A \in \mathcal{L}(X)\)</span>, 且 <span class="math inline">\(\|A\|&lt;1\)</span>, 则 <span class="math inline">\(I-A\)</span> 是有界可逆的, 且 <span class="math display">\[(I-A)^{-1}=\sum_{n=0}^{\infty} A^n, \quad\left\|(I-A)^{-1}\right\| \leq \frac{1}{1-\|A\|},\]</span> 其中 <span class="math inline">\(A^0=I, I\)</span> 是恒等算子.</p><h4 id="对偶空间">对偶空间</h4><p>如果<span class="math inline">\(X\)</span>是数域<span class="math inline">\(C\)</span>上的赋范线性空间，集合 <span class="math display">\[X^{\prime}=\mathcal{L}(X, C)=\left\{x^{\prime} \mid x^{\prime}: X \rightarrow C \text { 是连续线性泛函 }\right\}\]</span> 规定：</p><ol type="1"><li><span class="math inline">\(\left(x_1^{\prime}+x_2^{\prime}\right)(x)=x_1^{\prime}(x)+x_2^{\prime}(x)\)</span>，<span class="math inline">\((\lambda x&#39;)(x)=\lambda(x&#39;(x))\)</span></li><li><span class="math inline">\(\left\|x^{\prime}\right\|=\sup _{\|x\| \leq 1}\left|x^{\prime}(x)\right|\)</span></li></ol><p>称<span class="math inline">\(X&#39;\)</span>是<span class="math inline">\(X\)</span>的对偶空间/共轭空间。</p><p>如果<span class="math inline">\(X\)</span>可分，那么<span class="math inline">\(X&#39;\)</span>可分。</p><h4 id="常见空间上的连续线性泛函">常见空间上的连续线性泛函</h4><ol type="1"><li><p><span class="math inline">\(l^1\)</span>空间</p><p>其上的连续线性泛函可以表现为： <span class="math display">\[f(x)=\sum_{k=1}^{\infty} \xi_k \eta_k, \forall x=\left\{\xi_k\right\} \in l^1\]</span> 就是序列中的各项按由<span class="math inline">\(f(x)\)</span>唯一确定的权重<span class="math inline">\(y=\{\eta_i\}\)</span>线性组合。且： <span class="math display">\[||f(x)||=\sup|\eta_k|=||y||_{l^1}\]</span></p></li><li><p><span class="math inline">\(l^p\)</span>空间 <span class="math display">\[f(x)=\sum_{k=1}^{\infty} \xi_k \eta_k, \forall x=\left\{\xi_k\right\} \in l^1\]</span> 其中<span class="math inline">\(y\in l^q\)</span>，满足<span class="math inline">\(p^{-1}+q^{-1}=1\)</span>。也就是说：<span class="math inline">\((l^p)&#39;=l^q\)</span></p></li><li><p><span class="math inline">\(L^p[a,b]\)</span>空间： <span class="math display">\[f(x)=\int_a^b x(t) y(t) \mathrm{d} t, \forall x=x(t) \in L^p[a, b]\]</span> 其中<span class="math inline">\(y=y(t)\in L^q[a,b]\)</span>，<span class="math inline">\(q=\frac{p}{p-1}\)</span>。</p></li></ol><h2 id="内积空间和希尔伯特hilbert空间">内积空间和希尔伯特（Hilbert）空间</h2><p>设 <span class="math inline">\(X\)</span> 是数域 <span class="math inline">\(K\)</span> (实或复数域)上的线性空间, 若 <span class="math inline">\(\forall x, y \in X\)</span> 存在唯一的数 <span class="math inline">\((x, y) \in K\)</span>, 满足下列三条内积公理:</p><ul><li>正定性: <span class="math inline">\((x, x) \geq 0,(x, x)=0 \Leftrightarrow x=\theta\)</span>;</li><li>对第一变元的线性性:<span class="math inline">\((\alpha x+\beta y, z)=\alpha(x, z)+\beta(y, z), \forall z \in X, \forall \alpha, \beta \in K\)</span></li><li>共轭对称性: <span class="math inline">\((x, y)=\overline{(y, x)}\)</span>,</li></ul><p>则称 <span class="math inline">\((x, y)\)</span> 为 <span class="math inline">\(x, y\)</span> 的内积, <span class="math inline">\(X\)</span> 为内积空间。如果是复内积空间，对第二变元有共轭线性，即： <span class="math display">\[(x, \alpha y+\beta z)=\bar{\alpha}(x, y)+\bar{\beta}(x, z)\]</span> 两个向量内积为零，称为正交。如果一个集合<span class="math inline">\(\{x_i\}\)</span>满足<span class="math inline">\((x_i,x_j)=\delta_{ij}\)</span>，称为正规正交集。</p><p><strong>【勾股定理】</strong> <span class="math inline">\(X\)</span>是内积空间，<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>正交，则有： <span class="math display">\[\|x+y\|^2=\|x\|^2+\|y\|^2\]</span> 其中<span class="math inline">\(||x||=\sqrt{(x,x)}\)</span>称为向量<span class="math inline">\(x\)</span>的范数。</p><p>如果<span class="math inline">\(\{x_i\}\)</span>是正规正交集，则<span class="math inline">\(\forall x\in X\)</span> <span class="math display">\[\|x\|^2=\sum_{j=1}^n\left|\left(x, x_j\right)\right|^2+\left\|x-\sum_{j=1}^n\left(x, x_j\right) x_j\right\|^2\]</span> <strong>【贝塞尔不等式】</strong>如果<span class="math inline">\(\{x_i\}\)</span>是正规正交集，则<span class="math inline">\(\forall x\in X\)</span> <span class="math display">\[\sum_{j=1}^n\left|\left(x, x_j\right)\right|^2 \leq\|x\|^2\]</span> <strong>【柯西-施瓦茨不等式】</strong> <span class="math display">\[|(x, y)| \leq\|x\| \cdot\|y\|\]</span></p><h3 id="内积的性质">内积的性质</h3><p><strong>【连续性】</strong>内积对两个变元都是连续泛函。即<span class="math inline">\(x_n\to x,y_n\to y\)</span>时，<span class="math inline">\((x_n,y_n)\to (x,y)\)</span></p><blockquote><p>证明时先用三角不等式，再用柯西-施瓦茨不等式。 <span class="math display">\[\begin{aligned}\left|\left(x_n, y_n\right)-(x, y)\right| &amp; \leq\left|\left(x_n, y_n\right)-\left(x_n, y\right)\right|+\left|\left(x_n, y\right)-(x, y)\right| \\&amp; =\left|\left(x_n, y_n-y\right)\right|+\left|\left(x_n-x, y\right)\right| \\&amp; \leq\left\|x_n\right\| \cdot\left\|y_n-y\right\|+\left\|x_n-x\right\| \cdot\|y\|\end{aligned}\]</span></p></blockquote><p><strong>【平行四边形公式】</strong> <span class="math display">\[\|x+y\|^2+\|x-y\|^2=2\left(\|x\|^2+\|y\|^2\right)\]</span> 如果赋范线性空间的范数满足这个式子，那么它可以成为内积空间，反之亦然。</p><p><strong>【极化恒等式】</strong> <span class="math display">\[(x, y)=\frac{1}{4}\left(\|x+y\|^2-\|x-y\|^2\right)+\frac{i}{4}\left(\|x+i y\|^2-\|x-i y\|^2\right)\]</span></p><h3 id="希尔伯特空间">希尔伯特空间</h3><p>完备（所有基本列都是收敛的）的内积空间被称为希尔伯特空间。</p><ol type="1"><li><p><span class="math inline">\(n\)</span>维实/复向量空间 <span class="math display">\[(x, y)=\bar{y}^{\mathrm{T}} x=\sum_{i=1}^n x_i \bar{y}_i\]</span></p></li><li><p><span class="math inline">\(l^2\)</span>平方可和序列空间 <span class="math display">\[(x, y)=\sum_{j=1}^{\infty} \xi_j \bar{\eta}_j\]</span></p></li><li><p><span class="math inline">\(L^2[a,b]\)</span>平方可积函数空间 <span class="math display">\[(x, y)=\int_a^b x(t) \cdot \bar{y}(t) \mathrm{d} t\]</span></p></li></ol><h3 id="正规正交基">正规正交基</h3><p><strong>【施密特正交化】</strong>对于任意线性无关组<span class="math inline">\(\{x\}\)</span>，有以下过程可以构造一个正规正交集： <span class="math display">\[\begin{aligned}&amp; y_1=x_1 \Rightarrow e_1=\frac{y_1}{\left\|y_1\right\|} \\&amp; y_2=x_2-\left(x_2, e_1\right) e_1 \Rightarrow e_2=\frac{y_2}{\left\|y_2\right\|} \\&amp; y_3=x_3-\left(x_3, e_1\right) e_1-\left(x_3, e_2\right) e_2 \Rightarrow e_3=\frac{y_3}{\left\|y_3\right\|}, \cdots \\&amp; y_n=x_n-\sum_{i=1}^{n-1}\left(x_n, e_i\right) e_i \Rightarrow e_n=\frac{y_n}{\left\|y_n\right\|}, \cdots\end{aligned}\]</span> 得到的正规正交集为<span class="math inline">\(\{e\}\)</span>,</p><p><strong>【正规正交基】</strong>在希尔伯特空间中，不是任何其它正规正交集的子集的正规正交集，叫做正规正交基。</p><p>也即：在空间中，如果一个向量和正规正交基的每个元素都正交，那么这个向量是零向量。这说明了正规正交基的完全性。</p><p>设 <span class="math inline">\(H\)</span> 为无穷维Hilbert空间, 则</p><ol type="1"><li>若 <span class="math inline">\(H\)</span> 可分, 则 <span class="math inline">\(H\)</span> 有一个可数的正规正交基</li><li>每个非零的 <span class="math inline">\(H\)</span> 都有正规正交基</li></ol><p>设 <span class="math inline">\(S=\left\{e_\alpha\right\}_{\alpha \in \mathrm{A}}\)</span> 是 <span class="math inline">\(H\)</span> 的一个正规正交基, 则对 <span class="math inline">\(\forall x \in H\)</span>, 有</p><ol type="1"><li>【傅里叶系数】<span class="math inline">\(x=\sum_{\alpha \in \mathrm{A}}\left(x, e_\alpha\right) e_\alpha\)</span></li><li>【帕塞瓦尔定理（勾股定理），完备性】<span class="math inline">\(\|x\|^2=\sum_{\alpha \in \mathbb{A}}\left|\left(x, e_\alpha\right)\right|^2\)</span></li></ol><h3 id="射影定理">射影定理</h3><p><strong>【射影定理】</strong> 设 <span class="math inline">\(M\)</span> 是Hilbert空间 <span class="math inline">\(H\)</span> 中闭的线性子空间 则 <span class="math inline">\(\forall x \in H\)</span>, 必存在唯一的 <span class="math inline">\(y \in M, z \in M^{\perp}\)</span>, 使得 <span class="math display">\[x=y+z\]</span> 其中<span class="math inline">\(y\)</span>就是<span class="math inline">\(x\)</span>在<span class="math inline">\(M\)</span>上的射影。</p><p><strong>【Frechet-Riesz表示定理】</strong> 设 <span class="math inline">\(H\)</span> 是Hilbert空间, 对 <span class="math inline">\(\forall f \in H^*, \exists ! z_f \in H\)</span>, 使得 <span class="math inline">\(f(x)\)</span> 可表示为 <span class="math display">\[f(x)=\left(x, z_f\right), \quad \forall x \in H,\]</span> 并且 <span class="math inline">\(\|\boldsymbol{f}\|=\left\|z_f\right\|\)</span>.</p><blockquote><p>例如，对<span class="math inline">\(R^3\)</span>而言， <span class="math display">\[f(x)=a x_1+b x_2+c x_3=\vec{x} \cdot \vec{n}\]</span> 其中 <span class="math inline">\(\vec{x}=\left\{x_1, x_2, x_3\right\}, \vec{n}=\{a, b, c\}\)</span>.要找的 <span class="math inline">\(z_f\)</span> 就是 <span class="math inline">\(\vec{n}\)</span>, 它是平面 <span class="math inline">\(f(x)=0\)</span> 的法向量.</p></blockquote><h2 id="巴拿赫banach空间的基本定理">巴拿赫（Banach）空间的基本定理</h2><h3 id="hahn-banach定理">Hahn-Banach定理</h3><p>【Hahn-Banach定理】 对于线性赋范空间 <span class="math inline">\(X\)</span> 中线性子空间 <span class="math inline">\(G\)</span> 上的连续线性泛函 <span class="math inline">\(f(x)\)</span>, 恒有 <span class="math inline">\(X\)</span> 上的连续线性泛函 <span class="math inline">\(F(x)\)</span>, 使得 1. <span class="math inline">\(F(x)=f(x), x \in G\)</span>, 2. <span class="math inline">\(\|\boldsymbol{F}\|=\|f\|_G\)</span>.</p><p>【推论1】设 <span class="math inline">\(X\)</span> 是线性赋范空间, 任给非零的 <span class="math inline">\(x_0 \in X\)</span>, 总存在 <span class="math inline">\(X\)</span> 上的 连续线性泛函 <span class="math inline">\(f\)</span>, 满足 1. <span class="math inline">\(\|f\|=1\)</span>, 2. <span class="math inline">\(f\left(x_0\right)=\left\|x_0\right\|\)</span>.</p><p>【推论1的几何形式】 任意球面<span class="math inline">\(S\)</span>上的任意一点<span class="math inline">\(x_0\)</span>，必定存在一个支撑超平面。</p><p>【推论2】设 <span class="math inline">\(X\)</span> 是线性赋范空间, <span class="math inline">\(E\)</span> 是 <span class="math inline">\(X\)</span> 的闭子空间, <span class="math inline">\(x_0 \notin E\)</span>, 则存在 <span class="math inline">\(X\)</span> 上的有界线性泛函 <span class="math inline">\(f\)</span>, 满足 1. <span class="math inline">\(f(x)=0, \forall x \in E\)</span> 2. <span class="math inline">\(f\left(x_0\right)=d\)</span>, 3. <span class="math inline">\(\|f\|=1, d \triangleq \operatorname{dist}\left(x_0, E\right)&gt;0\)</span>.</p><p>【Hahn-Banach定理的几何形式】若<span class="math inline">\(X\)</span>中的线性流形<span class="math inline">\(g\)</span>与开球<span class="math inline">\(B\)</span>不相交，则有超平面<span class="math inline">\(H\)</span>包含<span class="math inline">\(g\)</span>且与<span class="math inline">\(B\)</span>不相交</p><h3 id="banach逆算子定理">Banach逆算子定理</h3><p>【纲集】可数个稀疏并叫第一纲集，不是第一纲的叫第二纲集。</p><p>完备距离空间是第二纲集。</p><p>【开映射定理】 设 <span class="math inline">\(X, Y\)</span> 都是Banach空间, <span class="math inline">\(T \in \mathcal{L}(X, Y)\)</span>. 如果 <span class="math inline">\(\mathcal{R}(T)\)</span> 是第二纲集, 则 <span class="math inline">\(T\)</span> 为开映射.</p><p>【Banach逆算子定理】 设 <span class="math inline">\(X, Y\)</span> 都是Banach空间, <span class="math inline">\(T \in \mathcal{L}(X, Y)\)</span>. 如果 <span class="math inline">\(T\)</span> 既单又满, 则 <span class="math inline">\(T\)</span> 是有界可逆的, 即 <span class="math inline">\(T^{-1} \in \mathcal{L}(Y, X)\)</span>.</p><p>【等价范数定理】设线性空间 <span class="math inline">\(X\)</span> 上赋予了两个范数 <span class="math inline">\(\|\|_1,\|\|_2\)</span>, 它们都使 <span class="math inline">\(X\)</span> 成为Banach空间, 如果 <span class="math inline">\(\|\cdot\|_1\)</span> 强于 <span class="math inline">\(\|\cdot\|_2\)</span>, 则两个范数等价.</p><h3 id="闭图像定理">闭图像定理</h3><p>【闭算子】 设 <span class="math inline">\(X, Y\)</span> 是赋范线性空间, <span class="math inline">\(M\)</span> 是 <span class="math inline">\(X\)</span> 中的线性子空间， <span class="math inline">\(T: M \rightarrow Y\)</span> 线性算子, <span class="math inline">\(M\)</span> 称为 <span class="math inline">\(T\)</span> 的定义域, 记为 <span class="math inline">\(\mathcal{D}(T)\)</span>. 如果由 <span class="math display">\[x_n \in \mathcal{D}(T), x_n \rightarrow x_0 \text {, 与 } T x_n \rightarrow y_0,\]</span> 可推知 <span class="math inline">\(x_0 \in \mathcal{D}(T), T x_0=y_0\)</span>, 则称 <span class="math inline">\(T\)</span> 为闭算子.</p><p>【图像】设 <span class="math inline">\(X, Y\)</span> 是赋范线性空间, <span class="math inline">\(T: \mathcal{D}(T) \subset X \rightarrow Y\)</span> 线性算子, 定义其图像为： <span class="math display">\[\mathcal{G}(T)=\{(x, y) \in X \times Y: x \in \mathcal{D}(T), y=T x\},\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212171143426.png" alt="image-20221217114236831" /><figcaption aria-hidden="true">image-20221217114236831</figcaption></figure><p>若对 <span class="math inline">\((x, y) \in X \times Y\)</span>, 引进范数 <span class="math display">\[\|(x, y)\|=\|x\|+\|y\| \text {. }\]</span> 则 <span class="math inline">\(T\)</span> 是闭算子 <span class="math inline">\(\Leftrightarrow \mathcal{G}(T)\)</span> 是 <span class="math inline">\(X \times Y\)</span> 中的闭集.</p><p>【闭图像定理】 设 <span class="math inline">\(X, Y\)</span> 是Banach空间, <span class="math inline">\(T: X \rightarrow Y\)</span> 闭算子, 则 <span class="math inline">\(T\)</span> 为有界的.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>所有收敛列都是基本列是永远成立的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实变泛函</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·傅里叶之章</title>
    <link href="/2022/12/08/DSP3/"/>
    <url>/2022/12/08/DSP3/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="离散傅里叶变换dft">离散傅里叶变换DFT</h2><p>我们之前已学过很多“变换”了，例如连续时间信号傅里叶变换FT、连续时间信号傅里叶级数FS、离散时间序列傅里叶变换DTFT、离散时间序列傅里叶级数FS。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212081540465.png" alt="各个变换" /><figcaption aria-hidden="true">各个变换</figcaption></figure><p>因为数字系统只能处理离散序列，而这其中只有DFS同时在时域和频域是离散的。但是DFS又是周期无限长序列，而现有的数字系统仍然不能实现。因此我们必须考虑用有限长序列建立时域离散和频域离散的关系。</p><p>设<span class="math inline">\(\widetilde{x}[n]\)</span>是周期为<span class="math inline">\(N\)</span>的周期序列，那么称 <span class="math display">\[x[n]=\widetilde x[n]R_N[n]\]</span> 为“主值序列”，也就是原序列的第<span class="math inline">\(0\sim N-1\)</span>个值。</p><p>设<span class="math inline">\(x[n]\)</span>是长度为<span class="math inline">\(N\)</span>的有限长序列，那么为了将其周期性延拓，有： <span class="math display">\[\widetilde  {x}[n]=\sum_{r=-\infty}^{\infty} x[n+r N]\]</span></p><p>记作： <span class="math display">\[\widetilde{x}[n]=x[((n))_N]\]</span> 其中<span class="math inline">\(((n))_N\)</span>称作取模运算，设<span class="math inline">\(n=mN+n_1\)</span>，则<span class="math inline">\(((n))_N=n_1\)</span>。</p><p>周期序列<span class="math inline">\(\widetilde x[n],\widetilde X[k]\)</span>可以看作有限长序列<span class="math inline">\(x[n],X[k]\)</span>的周期延拓，因此只需计算主值区间中的DFS，即可对周期序列进行恢复。有DFT的定义： <span class="math display">\[\begin{gathered}x[n]=\frac{1}{N} \sum_{k=0}^{N-1} X[k] \mathrm{e}^{\frac{2\pi k n}{N}} \\X[k]=\sum_{n=0}^{N-1} x[n] \mathrm{e}^{j \frac{-2 \pi k n}{N}}\end{gathered}\]</span> 我们可以看出：DFT并不是一个新的变换形式，而是DFS在实频域的主值序列，因此其很多性质和DFS有类似性。</p><h3 id="几大变换之间的关系">几大变换之间的关系</h3><p>以下：将Z变换记作<span class="math inline">\(X(z)\)</span>，将DTFT（离散时间序列傅里叶变换）记作<span class="math inline">\(X(e^{j\omega})\)</span>，将DFS（离散时间序列傅里叶级数）记作<span class="math inline">\(\widetilde X[k]\)</span>，将DFT（离散傅里叶变换）记作<span class="math inline">\(X[k]\)</span>。</p><h4 id="z变换和dtft">Z变换和DTFT</h4><p><span class="math inline">\(x[n]\)</span>的DTFT是其Z变换在单位圆上的采样。即： <span class="math display">\[X\left(\mathrm{e}^{j w}\right)=\left.X(z)\right|_{z=e^{j\omega}}\]</span></p><h4 id="dtft和dfs">DTFT和DFS</h4><p>对<span class="math inline">\(X(e^{j\omega})\)</span>在<span class="math inline">\(\omega \in [0,2\pi)\)</span>的等间隔频率点进行<span class="math inline">\(N\)</span>点采样得到周期序列<span class="math inline">\(\widetilde X[k]\)</span>。对<span class="math inline">\(\widetilde X[k]\)</span>作IDFS（离散时间序列傅里叶级数逆变换），得到序列<span class="math inline">\(\widetilde x_N[n]\)</span>。</p><p>由： <span class="math display">\[\tilde{X}[k]=\left.X\left(\mathrm{e}^{j \omega}\right)\right|_{\omega=\frac{2 \pi i}{N}}=\sum_{n=-\infty}^{\infty} x[n] \mathrm{e}^{-j \frac{2 \pi}{N} k n}\]</span> 和 <span class="math display">\[\tilde{x}_N[n]=\operatorname{IDFS}[\tilde{X}[k]]=\frac{1}{N} \sum_{k=0}^{N-1} \widetilde {X}[k] \mathrm{e}^{j\frac{2 \pi}{N} k n}\]</span> 把上式带入下式，有： <span class="math display">\[\widetilde x_N[n]=\sum_{m=-\infty}^{\infty} x[m]\left[\frac{1}{N} \sum_{k=0}^{N-1} \mathrm{e}^{-j \frac{2 \pi}{N} k(m-n)}\right]\]</span> 有复指数函数的正交性和周期性，有： <span class="math display">\[\begin{aligned}\tilde{x}_N[n]&amp;=\sum_{m=-\infty}^{\infty} x[m]\left[\sum_{r=-\infty}^{\infty} \delta[m-n-r N]\right]\\&amp;=\cdots+x[n+N]+x[n]+x[n-N]+\cdots\end{aligned}\]</span> 可以看到，<span class="math inline">\(\widetilde x_N[n]\)</span>是<span class="math inline">\(x[n]\)</span>的周期移位。也就是说，正如<strong>时域采样会导致频域周期延拓，频域采样也会导致时域周期延拓</strong>。下面按<span class="math inline">\(x[n]\)</span>的长度<span class="math inline">\(L\)</span>和频域采样数<span class="math inline">\(N\)</span>分情况讨论：</p><ol type="1"><li>非周期序列<span class="math inline">\(x[n]\)</span>不是有限长序列，则频域采样一定会造成混叠</li><li><span class="math inline">\(N&lt;L\)</span>时，仍会产生时域混叠失真。混叠的长度就是<span class="math inline">\(L-N\)</span>，参考上面的式子</li><li><span class="math inline">\(N\geq L\)</span>时，才能由频域采样<span class="math inline">\(\tilde X[k]\)</span>恢复出<span class="math inline">\(x[n]\)</span></li></ol><h4 id="dfs和dft">DFS和DFT</h4><p>如前文所说，DFT和DFS本质上来说是一种变换，不过DFS的离散时间序列是周期的，变换得到的频域也是周期的，DFT是DFS的主值序列。</p><h3 id="dft的性质和定理">DFT的性质和定理</h3><p>在研究DFT的性质时，需要时刻注意DFT的有限定长度性以及循环周期性。当涉及到两个长度不同的序列时，要通过补0的方式使其长度均为<span class="math inline">\(N\geq max(N_1,N_2)\)</span>。</p><ol type="1"><li><p>线性</p></li><li><p>时域循环位移性质</p><p>这里的循环移位是圆周移位，在序列中，从左（右）边移出多少位，就会从右（左）边移入相同位的序列值。 <span class="math display">\[x\left[\left(\left(n+n_d\right)\right)_N\right] R_N[n] \underset{N-\mathrm{IDFT}}{\stackrel{N-\mathrm{DFT}}{\longrightarrow}} \mathrm{e}^{j\left(2 \pi kn_d / N\right)} X[k]\]</span></p></li><li><p>频域循环位移性质 <span class="math display">\[\mathrm{e}^{\mathrm{j}(2 \pi k / N) l n} x[n] \underset{N-\mathrm{IDFT}}{\stackrel{N-\mathrm{DFT}}{\rightleftarrows}} X\left[((k-l))_N\right] R_N[n]\]</span></p></li><li><p>时间倒置性质 <span class="math display">\[x[-n] \underset{N-\mathrm{IDFT}}{\stackrel{N-\mathrm{DFT}}{\rightleftarrows}} X[-k]\]</span></p></li><li><p>此外，还有实频域循环卷积、对偶、帕塞瓦尔等性质。</p></li></ol><h3 id="dft的对称性">DFT的对称性</h3><p>和DFS的基本相同。重点是：DFT的对称都是“圆周对称”。对于圆周共轭对称序列，有： <span class="math display">\[x[n]=x^*[N-n]\]</span> 对于圆周共轭反对称序列，有： <span class="math display">\[x[n]=-x^*[N-n]\]</span> 如果<span class="math inline">\(x[n]\)</span>是实信号，那么它的DFT<span class="math inline">\(X[k]\)</span>是圆周共轭对称的。也就是说它的实部<span class="math inline">\(X_{Re}[k]\)</span>是圆周偶对称，虚部是圆周奇对称。</p><h3 id="用dft实现线性卷积">用DFT实现线性卷积</h3><p>这是我们之前几章经常用的线性卷积： <span class="math display">\[y_l[n]=x[n] * h[n]=\sum_{m=-\infty}^{+\infty} h[m] x[n-m]\]</span> 这是我们DFT里经常用的N点循环卷积： <span class="math display">\[y_c[n]=x[n] N h[n]=\left(\sum_{m=0}^{N-1} h[m] x\left[((n-m))_N\right]\right) R_N[n]\]</span> 把<span class="math inline">\(x\left[((n-m))_N\right]=\sum_{i=-\infty}^{+\infty} x[n-m+i N]\)</span> 带入，有： <span class="math display">\[\begin{aligned}y_c[n] &amp; =\left(\sum_{m=0}^{N-1} x[m] h\left[((n-m))_N\right]\right) R_N[n] \\&amp; =\left(\sum_{m=0}^{N-1} h[m] \sum_{i=-\infty}^{+\infty} x[n-m+i N]\right) R_N[n] \\&amp; =\left(\sum_{i=-\infty}^{+\infty} \sum_{m=0}^{N-1} h[m] x[n-m+i N]\right) R_N[n] \\&amp; =\left(\sum_{i=-\infty}^{+\infty} y_l[n+i N]\right) R_N[n]\end{aligned}\]</span> 于是，我们可以证明：循环卷积的结果是线性卷积以<span class="math inline">\(N\)</span>为周期的周期延拓的序列的主值序列。因为线性卷积序列的长度是<span class="math inline">\(L+P-1\)</span>，于是循环卷积的点数必须满足<span class="math inline">\(N\geq L+P-1\)</span>时，才不会发生混叠，取主值序列时才满足<span class="math inline">\(y_c[n]=y_l[n]\)</span></p><p>根据上述推理，我们可以利用DFT来实现卷积，计算框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212081757914.png" alt="DFT实现线性卷积" /><figcaption aria-hidden="true">DFT实现线性卷积</figcaption></figure><h4 id="dft实现线性系统块卷积方法">DFT实现线性系统（块卷积方法）</h4><p>在实际的操作中，输入序列<span class="math inline">\(x[n]\)</span>的长度远远大于冲激响应<span class="math inline">\(h[n]\)</span>的长度<span class="math inline">\(P\)</span>，所以计算效率比较低，所以需要分段处理，把输入序列分成长度为<span class="math inline">\(L\)</span>的块，再进行计算。有两种方法，分别是重叠相加法和重叠保留法。</p><p><strong>重叠相加法：</strong></p><p>把输入序列按顺序直接切割成若干个长度为<span class="math inline">\(L\)</span>的段序列<span class="math inline">\(x_r[n]\)</span>，即： <span class="math display">\[x_r[n]= \begin{cases}x[n+r L], &amp; 0 \leqslant n \leqslant L-1 \\ 0, &amp; \text { 其他 }\end{cases}\]</span> 对每个分段信号，和<span class="math inline">\(h[n]\)</span>进行线性卷积： <span class="math display">\[y_r[n]=x_r[n] * h[n]\]</span> 其中<span class="math inline">\(y_r[n]\)</span>是长度为<span class="math inline">\(L+P-1\)</span>的序列。由卷积的性质，有： <span class="math display">\[y[n]=\sum_{r=0}^{\infty} x_r[n-r L] * h[n]\]</span> 则： <span class="math display">\[y[n]=\sum_{r=0}^{\infty} y_r[n-r L]\]</span> 也就是说，尽管相邻两段<span class="math inline">\(y_r\)</span>会有重叠部分，但是加的时候不要管，直接叠加就行了。所以，这种方法叫做重叠相加法。</p><p><strong>重叠保留法：</strong></p><p>重叠保留法在对<span class="math inline">\(x[n]\)</span>分割成<span class="math inline">\(x_r[n]\)</span>时，两个相邻的<span class="math inline">\(x_r[n]\)</span>之间存在<span class="math inline">\(P-1\)</span>长度的重叠，即： <span class="math display">\[x_r[n]=x[n+r(L-P+1)-P+1], 0 \leqslant n \leqslant L-1\]</span> 有： <span class="math display">\[y[n]=\sum_{r=0}^{\infty} y_r[n-r(L-P+1)+P-1]\]</span> 把每个序列段和<span class="math inline">\(h[n]\)</span>的线性卷积记作<span class="math inline">\(y_{rp}[n]\)</span>则： <span class="math display">\[y_r= \begin{cases}y_{rp}[n], &amp; P-1 \leqslant n \leqslant L-1 \\ 0, &amp; \text { 其他 }\end{cases}\]</span> 意思是，在拼接时，每个<span class="math inline">\(y_r\)</span>序列都应该去掉<span class="math inline">\(0\leq n\leq P-2\)</span>和<span class="math inline">\(L\leq n\leq L+P-1\)</span>的部分。但是，明明拼接时去掉了一部分，为什么要叫“重叠保留”呢？哈哈。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212081959819.png" alt="块卷积方法" /><figcaption aria-hidden="true">块卷积方法</figcaption></figure><h2 id="快速傅里叶变换fft">快速傅里叶变换FFT</h2><p>一般的DFT，其时间复杂度是<span class="math inline">\(O(N^2)\)</span>，难以处理很长的数据。FFT把计算复杂度降低到了<span class="math inline">\(\frac N2 \log_2 N\)</span>次，大大提高了计算效率。FFT的实质是分治算法，把一个长度为<span class="math inline">\(N\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="在本节中，进行FFT的序列长度默认为2的整数次幂，不足则用0补齐。">[1]</span></a></sup>的序列不断地分拆成长度为<span class="math inline">\(N/2\)</span>，再利用旋转因子<span class="math inline">\(W_N^{nk}\)</span>（即<span class="math inline">\(\exp(-j\frac{2\pi kn}{N})\)</span>）的性质由子序列的DFT来合成整个序列的DFT。</p><h3 id="时间抽取ditfft">时间抽取（DIT）FFT</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082052669.png" alt="时间抽取FFT" /><figcaption aria-hidden="true">时间抽取FFT</figcaption></figure><p>这是DIT-FFT的基本框图。把长度为<span class="math inline">\(N\)</span>的序列<span class="math inline">\(x[n]\)</span>按奇偶分为两个长度为<span class="math inline">\(N/2\)</span>的序列<span class="math inline">\(g[n],h[n]\)</span>。接下来我们来<strong>推导“组合成长序列”这一步</strong>究竟是如何进行的。</p><p>由傅里叶变换定义式： <span class="math display">\[{X}[{k}]=\sum_{n=0}^{N-1} {x}[{n}] \cdot e^{-j \frac{2 \pi k}{N} n}\]</span> 把<span class="math inline">\(x[n]\)</span>分解为奇数偶数两部分： <span class="math display">\[ {X}[ {k}]=\sum_{ {r}=0}^{\frac{N}{2}-1}  {x}[2  {r}] e^{-j \frac{2 \pi k}{N} 2  {r}}+\sum_{r=0}^{\frac{N}{2}-1}  {x}[2  {r}+1] e^{-j \frac{2 \pi k}{N}(2  {r}+1)}\]</span> 把等式右侧的<span class="math inline">\(\exp [-j\frac{2\pi k}{N}(2r+1)]\)</span>分解开，有： <span class="math display">\[X[k]=\sum_{r=0}^{\frac{N}{2}-1}  {g}[ {r}] e^{-j \frac{2 \pi k}{N} 2 r}+\sum_{r=0}^{\frac{N}{2}-1}  {h}[ {r}] e^{-j \frac{2 \pi k}{N} 2 r} e^{-j \frac{2 \pi k}{N}}\]</span> 再回忆一下傅里叶变换的定义： <span class="math display">\[G[k]=\sum_{r=0}^{\frac N2-1}g[r]e^{-j\frac{2\pi k}{N/2}r}\]</span></p><p><span class="math display">\[H[k]=\sum_{r=0}^{\frac N2-1}h[r]e^{-j\frac{2\pi k}{N/2}r}\]</span></p><p>我们惊喜地发现：可以代换了。有： <span class="math display">\[X[k]=G[k]+e^{-j\frac{2\pi k}{N}}H[k]\]</span> 只要再注意到<span class="math inline">\(G,H\)</span>都是以<span class="math inline">\(N/2\)</span>为周期的，那么“组合成长序列”的方法已经昭然若揭了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082117370.png" alt="组合成长序列" /><figcaption aria-hidden="true">组合成长序列</figcaption></figure><p>当然，这个图还可以继续优化，只需要注意到： <span class="math display">\[e^{j\frac{2\pi N/2}{N}}=-1,e^{j\frac{2\pi}{N}(k+\frac N2)}=-e^{j\frac{2\pi}{N}k}\]</span> 有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082119083.png" alt="优化" /><figcaption aria-hidden="true">优化</figcaption></figure><p>接下来如法炮制，对<span class="math inline">\(g,h\)</span>进行分析，把它们分解为<span class="math inline">\(N/4\)</span>的序列，进行计算，直到序列的长度只有2为止。此时，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082125722.png" alt="序列长度只有2" /><figcaption aria-hidden="true">序列长度只有2</figcaption></figure><p>我们得到了计算这个长度为8的序列的FFT的全过程流图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082126128.png" alt="全过程流图" /><figcaption aria-hidden="true">全过程流图</figcaption></figure><h3 id="按频率抽取diffft">按频率抽取（DIF）FFT</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082132719.png" alt="按频率抽取" /><figcaption aria-hidden="true">按频率抽取</figcaption></figure>仿照上面的过程，我们来<strong>推导“组合成短序列”的过程</strong>。由DFT的定义： <span class="math display">\[X[k]=\sum_{n=0}^{N-1} x[n] \cdot e^{-j \frac{2 \pi k}{N} n}\]</span> 把它拆开： $$<span class="math display">\[\begin{aligned}{X}[{k}]&amp;=\sum_{n=0}^{N / 2-1} x[{n}] e^{-j \frac{2 \pi k}{N} n}+\sum_{n=N / 2}^{N-1} x[n] e^{-j \frac{2 \pi k}{N} n}\\&amp;=\sum_{n=0}^{\frac{N}{2}-1} {x}[{n}] e^{-j \frac{2 \pi k}{N} n}+\sum_{r=0}^{\frac{N}{2}-1} x\left[r+\frac{N}{2}\right] e^{-j \frac{2 \pi k}{N}\left(r+\frac{N}{2}\right)}\\&amp;=\sum_{n=0}^{\frac{N}{2}-1}  {x}[ {n}]  {e}^{-j \frac{2 \pi k}{N} n}+\sum_{n=0}^{\frac{N}{2}-1}  {e}^{-j \pi k}  {x}\left[ {n}+\frac{N}{2}\right] e^{-j \frac{2 \pi k}{N} n}\\&amp;=\sum_{n=0}^{\frac{N}{2}-1}\left(x[n]+e^{-j \pi k} x\left[n+\frac{N}{2}\right]\right) e^{-j \frac{2 \pi k}{N} n}\end{aligned}\]</span><span class="math display">\[然后，我们分别让$k=2r,2r+1$，有：\]</span><span class="math display">\[\begin{cases}X[2 r+1]=\sum_{n=0}^{\frac{N}{2}-1}\left(\left(x[n]-x\left[n+\frac{N}{2}\right]\right) e^{-j \frac{2 \pi}{N} n}\right) e^{-j \frac{2 \pi r}{N / 2} n}\\X[2 r]=\sum_{n=0}^{\frac{N}{2}-1}\left(x[n]+x\left[n+\frac{N}{2}\right]\right) e^{-j \frac{2 \pi r}{N / 2} n}\end{cases}\]</span><span class="math display">\[即：\]</span><span class="math display">\[\begin{cases}X[2r+1]=DFT\left\{x[n]-x[n+\frac N2]e^{-j\frac{2\pi}Nn}\right\}\\X[2r]=DFT\left\{x[n]+x[n+\frac N2]\right\}\end{cases}\]</span><p>$$ 于是，我们可以画出流图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082153498.png" alt="DIF流图" /><figcaption aria-hidden="true">DIF流图</figcaption></figure><p>如此重复，直到序列长度为2，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082154503.png" alt="长度为2的流图" /><figcaption aria-hidden="true">长度为2的流图</figcaption></figure><p>于是，全过程流图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082154066.png" alt="DIFFFT全过程流图" /><figcaption aria-hidden="true">DIFFFT全过程流图</figcaption></figure><h3 id="ifft">IFFT</h3><p>在不修改电路（程序）的情况下，直接借用FFT的模块实现IFFT，有两种操作方法。</p><ol type="1"><li>把蝶形运算中的旋转因子<span class="math inline">\(W_N^k\)</span>换成<span class="math inline">\(W_N^{-k}\)</span>，把<span class="math inline">\(X[k]\)</span>送进输入端，对输出的结果除以<span class="math inline">\(N\)</span></li><li>把<span class="math inline">\(X^*[k]\)</span>送入输入端，计算输出的共轭，然后除以<span class="math inline">\(N\)</span></li></ol><h3 id="实数序列的fft">实数序列的FFT</h3><p>前面所提到的序列都是复序列。如果要计算实数，当然可以把它当成虚部为零的复数，但是也有更简便的计算方法。</p><h4 id="n点fft计算两个n点实序列">N点FFT计算两个N点实序列</h4><p>构造复序列<span class="math inline">\(x[n]=x_1[n]+jx_2[n]\)</span>，则有： <span class="math display">\[X_1[k]=X_{e p}[k]= \begin{cases}X_{\mathrm{Re}}[0], &amp; k=0 \\ \frac{1}{2}\left(X[k]+X^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><p><span class="math display">\[X_2[k]=X_{\text {op }}[k]= \begin{cases}X_{1 \mathrm{~s}}[0], &amp; k=0 \\ -\frac{\mathrm{j}}{2}\left(X[k]-X^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><h4 id="n点fft计算2n点实序列">N点FFT计算2N点实序列</h4><p>构造复序列<span class="math inline">\(x[n]=g[n]+jh[n]\)</span>，其中<span class="math inline">\(g\)</span>是原实序列的偶数项，<span class="math inline">\(h\)</span>是原实序列的奇数项。则有： <span class="math display">\[G[k]=Y_{e p}[k]= \begin{cases}Y_{\mathrm{k}_*}[0], &amp; k=0 \\ \frac{1}{2}\left(Y[k]+Y^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><p><span class="math display">\[H[k]=Y_{\text {ap }}[k]= \begin{cases}Y_{1 \mathrm{~m}}[0], &amp; k=0 \\ -\frac{\mathrm{j}}{2}\left(Y[k]-Y^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><p><span class="math display">\[X[k]= \begin{cases}G[k]+W_{2 v}^k H[k], &amp; k=0,1, \cdots, N-1 \\ G[k-N]-W_{2 N}^{k-N} H[k-N], &amp; k=N, N+1, \cdots, 2 N-1\end{cases}\]</span></p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>在本节中，进行FFT的序列长度默认为2的整数次幂，不足则用0补齐。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·系统之章</title>
    <link href="/2022/12/08/DSP2/"/>
    <url>/2022/12/08/DSP2/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="离散系统变换域分析">离散系统变换域分析</h2><p>表示LTI系统有很多方法，我们常用三种：</p><ul><li>单位脉冲响应 <span class="math inline">\(h[n]\)</span></li><li>单位脉冲响应的频谱密度函数（DTFT） <span class="math inline">\(H(e^{j\omega})\)</span></li><li>系统函数（单位脉冲响应的Z变换） <span class="math inline">\(H(z)\)</span></li></ul><h3 id="lti系统的频域表示">LTI系统的频域表示</h3><h4 id="特征函数和频率响应">特征函数和频率响应</h4><p>对于LTI系统，对于某些输入序列，输出序列是输入序列和某个复常数的乘积。这样的输入序列叫做特征函数，复常数叫做系统的特征值。</p><p>由于输入序列为<span class="math inline">\(x[n]=e^{j\omega n}\)</span>时，有 <span class="math display">\[y[n]=x[n]*h[n]=\sum_{k=-\infty}^\infty e^{j\omega(n-k)}h[k]=e^{j\omega n}H(e^{j\omega})\]</span> 所以LTI系统的其中一个特征函数就是<span class="math inline">\(x[n]=e^{j\omega n}\)</span>（事实上，所有的指数型函数，例如<span class="math inline">\(5^n\)</span>等，都是特征函数，而且，指数型函数和指数型函数的有限项乘积也是特征函数，但是形容<span class="math inline">\(e^{j\omega n}u[n]\)</span>这种就不行），其对应的特征值为<span class="math inline">\(H(e^{j\omega})\)</span>。</p><p>而且，由傅里叶变换，我们知道：序列<span class="math inline">\(x[n]\)</span>往往可以表示为<span class="math inline">\(e^{j\omega n}\)</span>的线性组合，即<span class="math inline">\(x[n]=\frac{1}{2\pi}\int_{-\pi}^\pi X(e^{j\omega})e^{j\omega n}d\omega\)</span>。于是，我们将其中的每一项乘以对应的特征值，就得到了输出<span class="math inline">\(y[n]=\frac{1}{2\pi}\int_{-\pi}^\pi X(e^{j\omega})H(e^{j\omega})e^{j\omega n}d\omega\)</span>。于是我们得到了： <span class="math display">\[Y(e^{j\omega})=X(e^{j\omega})H(e^{j\omega})\]</span> 如果LTI系统的相频响应满足<span class="math inline">\(\angle H(e^{j\omega})=-\omega n_d\)</span>，那么称这样的系统为线性相位系统。线性相位系统对所有频率分量<span class="math inline">\(e^{j\omega n}\)</span>造成的延迟均为<span class="math inline">\(n_d\)</span>。一般来说，我们用群延时衡量相位变化对信号的影响，有： <span class="math display">\[\tau(\omega)=-\frac{d}{d\omega}\angle H(e^{j\omega})\]</span> 如果群延时不是常数，那么会造成输出信号的失真，这称为色散。</p><h4 id="lti系统的z变换分析">LTI系统的Z变换分析</h4><p>对于以下差分方程表示的系统： <span class="math display">\[y[n]=\sum_{k=1}^N a_ky[n-k]+\sum_{k=0}^Mb[k]x[n-k]\]</span> 在有初始松弛条件（零状态）时，是因果LTI系统。其系统函数为： <span class="math display">\[H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^M b_kz^{-k}}{1-\sum_{k=1}^N a_kz^{-k}}\]</span> 也可以把它表示为因式的形式： <span class="math display">\[H(z)=\frac{b_0}{a_0}\frac{\prod_{m=1}^M(1-c_mz^{-1})}{\prod_{n=1}^N (1-d_nz^{-1})}\]</span> 关于系统的因果和稳定性，有如下结论：</p><ul><li>LTI系统是因果的 等价于 <span class="math inline">\(H(z)\)</span>的收敛域包含无穷远点</li><li>LTI系统是稳定的 等价于<span class="math inline">\(H(z)\)</span>在单位圆上是收敛的</li></ul><p>关于系统的零极点和幅频响应的关系，有如下结论：</p><ul><li>对于单零点系统，零点为<span class="math inline">\(c\)</span>，当<span class="math inline">\(\omega=\theta_c\)</span>时，幅频响应是极小值，零点越靠近单位圆，幅频响应的极小值越小，当零点在单位圆上时，这个极小值为<span class="math inline">\(0\)</span>(如果采用对数坐标则为负无穷)</li><li>对于单极点系统，极点为<span class="math inline">\(d\)</span>，当<span class="math inline">\(\omega=\theta_d\)</span>时，幅频响应是极大值，极点越靠近单位圆，幅频响应的极大值越大，当极点在单位圆上时，这个极大值为正无穷。极点在单位圆上或单位圆外，则系统不稳定。</li></ul><h4 id="有理系统的全通分解">有理系统的全通分解</h4><ul><li><p>幅频特性相同的系统</p><p>若有一个有理实系统，把其中的若干个零点或极点用它的共轭倒数代替，新系统的幅频响应和原来的系统相同。于是，如果设计好一个系统的幅频特性，一定存在符合要求的因果稳定LTI系统，其极点都在单位圆内。</p></li><li><p>全通系统</p><p>全通指的是<span class="math inline">\(|H(e^{j\omega})|\equiv1\)</span>的系统，仅有相频特性随频率变化而变化。全通系统的零极点相对单位圆是镜像共轭成对的。也就是说：如果<span class="math inline">\(a_i\)</span>是系统的零点，那么<span class="math inline">\((a_i^*)^{-1}\)</span>，即<span class="math inline">\(a_i\)</span>的共轭的倒数，定是全通系统的极点。而且，对于有理实系数系统来说，零点和极点本身也是共轭成对的，即如果<span class="math inline">\(b_i\)</span>是零点或极点，那么它的共轭一定也是零点或极点。</p><p>全通系统具有以下性质：</p><ul><li><p>相位特性随频率单调下降，即 <span class="math display">\[\frac{\rm d\theta(\omega)}{\rm d\omega}&lt;0\]</span></p></li><li><p>输入信号<span class="math inline">\(x[n]\)</span>和输出信号<span class="math inline">\(y[n]\)</span>的能量相同，即 <span class="math display">\[\sum_{n=-\infty}^\infty\lvert x[n]\rvert^2=\sum_{n=-\infty}^\infty\lvert y[n]\rvert^2\]</span></p></li><li><p>当频率<span class="math inline">\(\omega\)</span>从<span class="math inline">\(0\)</span>变化到<span class="math inline">\(\pi\)</span>时，<span class="math inline">\(N\)</span>阶全通系统的相位改变为<span class="math inline">\(N\pi\)</span></p></li></ul><p>全通系统的应用主要在作相位均衡器，或者通过级联全通系统的方法提高系统的稳定性。</p></li><li><p>最小相位系统</p><p>对于一个离散时间因果稳定系统，它的极点都在单位圆内。如果在此基础上，零点也都在单位圆内，那么这样的系统叫做最小相位系统<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="也就是说最小相位系统的意思就是零极点都在单位圆内。">[3]</span></a></sup>；如果零点全在单位圆外，叫最大相位系统；如果零点在单位圆内外都有，叫混合相位系统。</p><p>最小相位系统有以下性质：</p><ul><li>在所有幅频响应相同的因果稳定系统中，最小相位系统的相位延迟最小</li><li>在所有幅频响应相同的实系数因果稳定系统中，最小相位系统的群延时最小</li><li>最小相位系统的逆系统也是最小相位系统</li></ul><blockquote><p>【例】因果序列<span class="math inline">\(x[n]\)</span>的<span class="math inline">\(z\)</span>变换为 <span class="math display">\[X(z)=\frac{\left(1-\frac 12 z^{-1}\right)\left(1-\frac 14 z^{-1}\right)\left(1-\frac 15 z\right)}{\left(1-\frac 16 z\right)}\]</span> 又已知<span class="math inline">\(\alpha^nx[n]\)</span>是一个最小相位系统，求<span class="math inline">\(\alpha\)</span>的范围。</p><p>【解】只有不在单位圆内的有一个零点<span class="math inline">\(5\)</span>和一个极点<span class="math inline">\(6\)</span>。记<span class="math inline">\(y[n]=\alpha^nx[n]\)</span>，则有 <span class="math display">\[Y(z)=\sum_{n=-\infty}^\infty\alpha^nx[n]z^{-n}=X\left(\frac z\alpha\right)\]</span> 如果<span class="math inline">\(a_i\)</span>是<span class="math inline">\(X(z)\)</span>的零点或极点，那么<span class="math inline">\(a_i\cdot\alpha\)</span>就是<span class="math inline">\(Y(z)\)</span>的零点或极点。为了让<span class="math inline">\(Y(z)\)</span>的所有零极点都在单位圆内，只需调整<span class="math inline">\(\alpha\)</span>，让<span class="math inline">\(6\alpha\)</span>在单位圆内即可。于是有： <span class="math display">\[\alpha&lt;\frac 16\]</span></p></blockquote></li><li><p>有理系统的全通分解</p><p>任何有理系统函数都可以分解为最小相位系统<span class="math inline">\(H_{min}(z)\)</span>和全通系统<span class="math inline">\(H_{ap}(z)\)</span>级联的形式。假设系统仅有一个单位圆外的零点<span class="math inline">\((c^*)^{-1}\)</span>，即： <span class="math display">\[H(z)=H_1(z)(z^{-1}-c^*)\]</span> 则<span class="math inline">\(H_1\)</span>的零极点都在单位圆内，是最小相位系统。上式可以进一步表示为： <span class="math display">\[H(z)=H_1(z)(z^{-1}-c^*)\frac{1-cz^{-1}}{1-cz^{-1}}=H_1(z)(1-cz^{-1})\frac{z^{-1}-c^*}{1-cz^{-1}}\]</span> 其中<span class="math inline">\(\frac{z^{-1}-c^*}{1-cz^{-1}}\)</span>的零点是<span class="math inline">\((c^*)^{-1}\)</span>，极点是<span class="math inline">\(c\)</span>，互为共轭倒数，是全通系统，记作<span class="math inline">\(H_{ap}(z)\)</span>。因为<span class="math inline">\(|z|&lt;1\)</span>，其余部分是最小相位系统，记作<span class="math inline">\(H_{min}(z)\)</span>，于是分解完成。</p><p>上述过程的实质是在单位圆外零点<span class="math inline">\((c^*)^{-1}\)</span>的共轭倒数<span class="math inline">\(c\)</span>的位置放置了一个零点和一个极点。<span class="math inline">\(c\)</span>上的极点和<span class="math inline">\((c^*)^{-1}\)</span>这个零点一起构成了全通系统；<span class="math inline">\(c\)</span>上的极点和原来系统的其它零极点构成了最小相位系统。</p><blockquote><p>【例】把以下系统分解成全通系统和最小相位系统的级联 <span class="math display">\[H(z)=\frac{1-3z^{-1}}{1+\frac 12 z^{-1}}\]</span> 【解】该系统有<span class="math inline">\(z=-1/2\)</span>的极点和<span class="math inline">\(z=3\)</span>的零点。即<span class="math inline">\((c^*)^{-1}=3\)</span>，得<span class="math inline">\(c=1/3\)</span>。则有： <span class="math display">\[\begin{align}H(z)&amp;=\frac{-3}{1+\frac 12 z^{-1}}\left(z^{-1}-\frac 13\right)\\&amp;=-3\left(\frac{1-\frac 13z^{-1}}{1+\frac 12 z^{-1}}\right)\left(\frac{z^{-1}-\frac 13}{1-\frac 13z^{-1}}\right)\end{align}\]</span> 于是： <span class="math display">\[H_{min}(z)=-3\left(\frac{1-\frac 13z^{-1}}{1+\frac 12 z^{-1}}\right)\]</span></p><p><span class="math display">\[H_{ap}(z)=\left(\frac{z^{-1}-\frac 13}{1-\frac 13z^{-1}}\right)\]</span></p></blockquote></li></ul><h4 id="广义线性相位系统">广义线性相位系统</h4><p>我们之前所说的经典频响是这样的： <span class="math display">\[H(e^{j\omega})=|H(e^{j\omega})|e^{j\angle H(e^{j\omega})}\]</span> 这时<span class="math inline">\(|H|\)</span>叫经典幅频响应，<span class="math inline">\(\angle H\)</span>叫经典相频响应.但是现在我们引入广义响应： <span class="math display">\[H(e^{j\omega})=A(e^{j\omega})e^{j\varphi(\omega)}\]</span> 这时候，<span class="math inline">\(A\)</span>叫做“广义幅频响应”，而<span class="math inline">\(\varphi\)</span>叫做“广义相频响应”。请注意“经典”和“广义”的不同：经典幅频响应永远是正的，而广义相频响应可以是负的。因此，广义相频响应和经典相频响应，在<span class="math inline">\(A\)</span>变成负数的时候，会有一个<span class="math inline">\(\pi\)</span>的差距。</p><p>所谓的线性相位的意思是，系统对不同频率的正弦信号所产生的相移和正弦信号的频率呈线性关系。即： <span class="math display">\[\angle H(e^{j\omega})=-\alpha \omega\]</span> 那么广义线性相位的意思就是，给这个加上一个常数，变成 <span class="math display">\[\angle H(e^{j\omega})=\beta-\alpha \omega\]</span> 经过一番数学推导，相频响应满足上面式子的系统的单位脉冲响应满足以下等式： <span class="math display">\[\sum_{n=-\infty}^\infty h[n]\sin(\omega(n-\alpha)+\beta)=0\]</span> 满足上面式子的情况的两组解如下：</p><ul><li><span class="math inline">\(\beta=0\)</span>或<span class="math inline">\(\pi\)</span>，<span class="math inline">\(2\alpha=M\in \mathbb N\)</span>，<span class="math inline">\(h[2\alpha-n]=h[n]\)</span></li><li><span class="math inline">\(\beta=\pi/2\)</span>或<span class="math inline">\(3\pi/2\)</span>，<span class="math inline">\(2\alpha=M\in \mathbb N\)</span>，<span class="math inline">\(h[2\alpha-n]=-h[n]\)</span></li></ul><p>于是，我们可以分出四种广义线性相位系统。</p><ul><li><p>第I类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>偶对称，而且<span class="math inline">\(M\)</span>是偶数。第I类的<span class="math inline">\(\beta=0,\pi\)</span>。所以相频响应是过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=m\pi,m\in \mathbb Z\)</span>偶对称，可用作各种滤波器。</p></li><li><p>第II类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>偶对称，而且<span class="math inline">\(M\)</span>是奇数。第II类的<span class="math inline">\(\beta=0,\pi\)</span>。所以相频响应是过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=2m\pi,m\in \mathbb Z\)</span>偶对称，关于<span class="math inline">\(\omega=(2m+1)\pi,m\in \mathbb Z\)</span>奇对称，幅度函数在<span class="math inline">\(\pi\)</span>时为零，不适合作高通、带阻滤波器。</p></li><li><p>第III类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=-h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>奇对称，而且<span class="math inline">\(M\)</span>是偶数。第III类的<span class="math inline">\(\beta=\pi/2,3\pi/2\)</span>。所以相频响应是不过原点的直线（过<span class="math inline">\((0,\pi/2)\)</span>或<span class="math inline">\((0,3\pi/2)\)</span>），斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=m\pi,m\in \mathbb Z\)</span>奇对称，只适合作带通滤波器。</p></li><li><p>第IV类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=-h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>奇对称，而且<span class="math inline">\(M\)</span>是奇数。第IV类的<span class="math inline">\(\beta=\pi/2,3\pi/2\)</span>。所以相频响应是不过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=2m\pi,m\in \mathbb Z\)</span>奇对称，关于<span class="math inline">\(\omega=(2m+1)\pi,m\in \mathbb Z\)</span>偶对称，幅度函数在<span class="math inline">\(\pi\)</span>时为零，不适合作低通、带通滤波器。</p></li></ul><p>由于第3、4类广义线性系统的相移特性，可以作希尔伯特变换器使用。</p><p>对于广义线性系统而言，如果<span class="math inline">\(z_0\)</span>是系统的零点，那么<span class="math inline">\(z_0^{-1},z_0^*,(z_0^*)^{-1}\)</span>也是系统的零点。第2、3类的零点一定包含-1，第3、4类的零点一定包含1.</p><h2 id="信号的采样和重建">信号的采样和重建</h2><h3 id="连续信号的理想采样">连续信号的理想采样</h3><p>设原连续信号为<span class="math inline">\(x_c(t)\)</span>，用来采样的理想冲击串为<span class="math inline">\(s(t)\)</span>，采样得的连续采样信号为<span class="math inline">\(x_s(t)\)</span>，采样得的离散时间序列为<span class="math inline">\(x[n]\)</span>。其中采样用的理想冲击串的周期为<span class="math inline">\(T_s\)</span>。</p><h4 id="x_s和x_c的关系"><span class="math inline">\(X_s\)</span>和<span class="math inline">\(X_c\)</span>的关系</h4><p>这一部分是《信号与系统》的内容，这里只简单提一下。</p><p>首先我们知道，冲击串的傅里叶变换还是冲击串，即： <span class="math display">\[S(j\Omega)=\frac{2\pi}{T_s}\sum_{k=-\infty}^{\infty}\delta(\Omega-k\Omega_s)\]</span> 由傅里叶变换的乘积性质，有： <span class="math display">\[X_s(j\Omega)=\frac 1 {T_s}\sum_{k=-\infty}^\infty X_c(j\Omega-jk\Omega_s)\]</span> 即：<span class="math inline">\(x_s(t)\)</span>的频谱<span class="math inline">\(X_s(j\Omega)\)</span>是连续时间信号<span class="math inline">\(x_c(t)\)</span>的频谱<span class="math inline">\(X_c(j\Omega)\)</span>以采样周期<span class="math inline">\(\Omega_s=2\pi/T_s\)</span>的周期延拓，并以<span class="math inline">\(\frac 1{T_s}\)</span>加权的结果。所以，为了不使得频域混叠，需满足<span class="math inline">\(\Omega_s&gt;2\Omega_N\)</span>，其中<span class="math inline">\(\Omega_N\)</span>是原信号所含有的最高频分量的频率。</p><h4 id="xejomega和x_cjomega的关系"><span class="math inline">\(X(e^{j\omega})\)</span>和<span class="math inline">\(X_c(j\Omega)\)</span>的关系</h4><p>有： <span class="math display">\[X_s(j\Omega)=\sum_{n=-\infty}^{\infty}x[n]e^{-j\Omega nT_s}\]</span> 令<span class="math inline">\(\omega=\Omega T_s\)</span>，有： <span class="math display">\[X_s\left(j\frac{\omega}{T_s}\right)=\sum_{n=-\infty}^\infty x[n]e^{-j\omega n}\]</span></p><p>可以发现：使用<span class="math inline">\(1/T_s\)</span>对<span class="math inline">\(X_c(j\Omega)\)</span>加权且频率按<span class="math inline">\(\Omega=\omega/T_s\)</span>尺度变换，得到函数<span class="math inline">\(X_c(j\omega/T_s)/T_s\)</span>，将其以<span class="math inline">\(2\pi\)</span>为周期进行延拓，得离散序列<span class="math inline">\(x[n]\)</span>频谱<span class="math inline">\(X(e^{j\omega})\)</span>.</p><h3 id="连续信号的理想重建">连续信号的理想重建</h3><p>重建系统的示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301039578.png" alt="连续信号重建系统" /><figcaption aria-hidden="true">连续信号重建系统</figcaption></figure><p>先把离散时间信号序列<span class="math inline">\(y[n]\)</span>转化为连续时间信号<span class="math inline">\(y_s(t)\)</span>，然后让<span class="math inline">\(y_s(t)\)</span>经过截止频率为<span class="math inline">\(\pi/T_s\)</span>，幅度<span class="math inline">\(T_s\)</span>的低通滤波器，得到重建信号<span class="math inline">\(y_r(t)\)</span>。</p><p>即： <span class="math display">\[H_r(j\Omega)=\begin{cases}T_s, &amp;|\Omega|&lt;\frac{\Omega_s}{2}\\0 , &amp;\text{others}\end{cases}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301112181.png" alt="重建过程" /><figcaption aria-hidden="true">重建过程</figcaption></figure><h3 id="余弦信号的采样">余弦信号的采样</h3><p>这一段没有什么新东西，主要内容是以对余弦信号采样举例来让人直观感受“频域混叠”的存在，尤其是在采样频率<span class="math inline">\(\Omega_s=2\Omega_0\)</span>时，可能会出现各种情况：当<span class="math inline">\(\varphi=0\)</span>时，才能恢复原信号；当其它情况时，都不能恢复原信号，极端时刻，甚至采样值全部为0，不包含任何信息。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:3" class="footnote-text"><span>也就是说最小相位系统的意思就是零极点都在单位圆内。 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变泛函·实变函数之章</title>
    <link href="/2022/12/04/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD/"/>
    <url>/2022/12/04/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>实变函数和泛函分析是一门广度极强的学科，融合了分析、代数、抽代、拓扑等数学各个方面的知识。在学习时要能建立起各个概念之间的联系。</p><span id="more"></span><h2 id="点集">点集</h2><h3 id="rn中的线性运算内积和范数"><span class="math inline">\(R^n\)</span>中的线性运算、内积和范数</h3><h4 id="n维欧氏空间rn"><span class="math inline">\(n\)</span>维欧氏空间<span class="math inline">\(R^n\)</span></h4><p><span class="math inline">\(R^n\)</span>指的是<span class="math inline">\(n\)</span>维向量组成的集合： <span class="math display">\[R^n=\{(x_1,x_2,\cdots,x_n):x_i\in R,i=1,2,\cdots n\}\]</span> 在这个集合上定义加法和数乘： <span class="math display">\[\begin{aligned}&amp;\forall x,y\in R^n,\lambda\in R\\&amp;x+y=(x_1+y_1,x_2+y_2,\cdots,x_n+y_n)\\&amp;\lambda x=(\lambda x_1,\lambda x_2,\cdots,\lambda x_n)\end{aligned}\]</span> 其满足所谓的“线性运算八条性质”：对任意的<span class="math inline">\(x,y\in R^n;\lambda,\mu\in R\)</span></p><ol type="1"><li><span class="math inline">\(x+y=y+x\)</span></li><li><span class="math inline">\(x+y+z=(x+y)+z=x+(y+z)\)</span></li><li><span class="math inline">\(x+0=x\)</span>;</li><li><span class="math inline">\(x+(-x)=0\)</span></li><li><span class="math inline">\(1x=x\)</span></li><li><span class="math inline">\(\lambda(x+y)=\lambda x+\lambda y\)</span></li><li><span class="math inline">\((\lambda+\mu) x=\lambda x+\mu x\)</span></li><li><span class="math inline">\((\lambda \mu) x=\lambda(\mu x)\)</span></li></ol><p>对于<span class="math inline">\(\forall x,y\in R^n\)</span>，定义<strong>内积</strong>： <span class="math display">\[(x,y)=\sum_{i=1}^n x_iy_i\]</span> 内积满足以下三条性质：对于任意的<span class="math inline">\(x,y,z\in R^n\)</span>，任意的<span class="math inline">\(\lambda,\mu\in R\)</span>，有：</p><ol type="1"><li>正定性：<span class="math inline">\((x,x)\geq 0\)</span></li><li>对称性：<span class="math inline">\((x,y)=(y,x)\)</span></li><li>对第一变元的线性：<ol type="1"><li><span class="math inline">\((x+y,z)=(x,z)+(y,z)\)</span></li><li><span class="math inline">\((\lambda x,y)=\lambda(x,y)\)</span></li></ol></li></ol><p>定义了内积的<span class="math inline">\(n\)</span>维向量空间被称为“<strong>内积空间</strong>”，也叫“<strong>欧几里得空间</strong>”.</p><p>对于一般的内积空间<span class="math inline">\(X\)</span>，总成立柯西-施瓦茨不等式： <span class="math display">\[|(x,y)|\leq ||x||\cdot||y||\]</span> 其中<span class="math inline">\(||x||=\sqrt{(x,x)}\)</span>，称之为向量的<strong>范数</strong>。范数满足以下三条性质：</p><ol type="1"><li>正定性：<span class="math inline">\(||x||\geq 0\)</span>，取到<span class="math inline">\(0\)</span>当且仅当<span class="math inline">\(x=0\)</span></li><li>齐次性：<span class="math inline">\(||\lambda x||=|\lambda|\cdot ||x||\)</span></li><li>三角不等式：<span class="math inline">\(||x+y||\leq||x||+||y||\)</span></li></ol><p>其实，只要<span class="math inline">\(f(x)\)</span>满足以上三个条件，那么它就可以被称作范数，范数不只有上面所提到的那一种定义。</p><p>对三角不等式的证明可以先对式子两边取平方，再运用柯西-施瓦茨不等式。</p><p>如果<span class="math inline">\(x,y\in R^n\)</span>且<span class="math inline">\(x,y\neq 0\)</span> ,则存在实数<span class="math inline">\(\theta\in[0,\pi]\)</span>，满足： <span class="math display">\[\cos \theta=\frac{(x,y)}{||x||\cdot ||y||}\]</span> 这个实数称为两个向量之间的<strong>夹角</strong>。</p><p>最后，我们定义<strong>两点间的距离</strong>：<span class="math inline">\(d(x,y)=||x-y||\)</span>。距离的本质是范数，满足范数的性质。</p><h4 id="rn中点列的极限"><span class="math inline">\(R^n\)</span>中点列的极限</h4><p>设<span class="math inline">\(\{x_k\}\)</span>是<span class="math inline">\(R^n\)</span>中的点列，如果<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall k&gt;N,||x_k-a||&lt;\epsilon\)</span>，称<span class="math inline">\(\{x_k\}\)</span>收敛于<span class="math inline">\(a\)</span>，记作： <span class="math display">\[\lim_{n\to \infty}x_k=a\]</span> 点列的极限满足以下四条性质：</p><ol type="1"><li>点列的极限如果存在，那么唯一</li><li>收敛点列必定有界</li><li><span class="math inline">\(\lim_{k\to \infty}(x_k+y_k)=a+b\)</span></li><li><span class="math inline">\(\forall \lambda \in R,\lim_{k\to \infty} (\lambda x_k)=\lambda a\)</span></li></ol><p>点列收敛等价于点列的每个分量都收敛（即按分量收敛）。</p><h3 id="rn中点集的基本概念和性质"><span class="math inline">\(R^n\)</span>中点集的基本概念和性质</h3><p><span class="math inline">\(a\in R^n,r&gt;0\)</span>，则称集合<span class="math inline">\(\{x\in R^n:||x-a||&lt;r\}\)</span>称为以<span class="math inline">\(a\)</span>为心，<span class="math inline">\(r\)</span>为半径的“<strong>开球</strong>”或者“<strong>球形邻域</strong>”，记作<span class="math inline">\(B_r(a)\)</span>.</p><p>令<span class="math inline">\(\bar B_r(a)=\{x\in R^n:||x-a||\leq r\}\)</span>，称作“<strong>闭球</strong>”</p><p>令<span class="math inline">\(B_r^o(a)=\{x\in R^n:0&lt;||x-a||&lt;r\}\)</span>，称作“<strong>去心开球</strong>”</p><p>若<span class="math inline">\(E\subset R^n,\exists r&gt;0,s.t. E\subset B_r(0)\)</span>，称<span class="math inline">\(E\)</span>是<strong>有界</strong>的。否则，称<span class="math inline">\(E\)</span>是<strong>无界</strong>的。</p><h4 id="点">点</h4><p>如果<span class="math inline">\(a\in E,\exists r&gt;0,s.t. B_r(a)\subset E\)</span>，则<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>内点</strong>，如果<span class="math inline">\(a\)</span>是<span class="math inline">\(E^c\)</span>(<span class="math inline">\(E\)</span>的补集)的内点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>外点</strong>。如果<span class="math inline">\(a\)</span>对<span class="math inline">\(E\)</span>来说既不是内点，也不是外点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>边界点</strong>。</p><p>换句话说：以<span class="math inline">\(a\)</span>为心的任意邻域内都存在属于<span class="math inline">\(E\)</span>的点，同时也存在不属于<span class="math inline">\(E\)</span>的点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的边界点。</p><p>如果以<span class="math inline">\(a\)</span>为心的任意球形邻域中都含有<span class="math inline">\(E\)</span>的无限多个点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>聚点</strong>，也叫<strong>极限点</strong>。聚点的定义可以简化，也就是说，只要以<span class="math inline">\(a\)</span>为心的任意球形邻域中都含有<span class="math inline">\(E\)</span>中不同于<span class="math inline">\(a\)</span>的一个点，那么<span class="math inline">\(a\)</span>就是<span class="math inline">\(E\)</span>的聚点。很显然，这两种说法实际上是等价的。还有一种等价的说法：从<span class="math inline">\(E\)</span>中选出互不相同的点组成点列<span class="math inline">\(\{x_k\}\)</span>，如果<span class="math inline">\(\lim_{k\to \infty}x_k=a\)</span>，那么<span class="math inline">\(a\)</span>是<span class="math inline">\(E\)</span>的聚点。<span class="math inline">\(E\)</span>中不是聚点的点叫做<strong>孤立点</strong>。</p><p>关于各种点之间的关系，有如下的结论：</p><ol type="1"><li>内点一定是聚点，外点一定不是聚点</li><li>聚点可以是内点，也可以是边界点，但不可能是外点</li><li>孤立点一定是边界点</li><li>边界点是聚点或孤立点</li><li>如果一个点既不是聚点，也不是边界点，那么一定是外点</li><li>内点必属于集合，外点必不属于集合，边界点不一定属于集合</li></ol><p>我们会发现：聚点不一定在集合内，例子很简单：对于<span class="math inline">\(R^1,E=Q,e=\lim_{k\to \infty}(1+1/n)^n,e\notin E\)</span></p><p>设<span class="math inline">\(A\subset R^n,\forall x\in R^n,\exist r,s.t. \exist a\in A,a\in B_r(x)\)</span>，那么称<span class="math inline">\(A\)</span>在<span class="math inline">\(R^n\)</span>中<strong>稠密</strong>。稠密等价于以下两个结论：</p><ol type="1"><li>对<span class="math inline">\(\forall x\in R^n\)</span>，总存在<span class="math inline">\(A\)</span>中的点列收敛于<span class="math inline">\(x\)</span>。</li><li><span class="math inline">\(R^n\)</span>中的点要么是<span class="math inline">\(A\)</span>中的点，要么是<span class="math inline">\(A\)</span>的聚点。</li></ol><h4 id="开集">开集</h4><p>点集<span class="math inline">\(E\)</span>的全体内点的集合叫做<span class="math inline">\(E\)</span> 的内部，记作<span class="math inline">\(E^o\)</span>。如果<span class="math inline">\(E=E^o\)</span>，那么称<span class="math inline">\(E\)</span>为<strong>开集</strong>。</p><p>几个经典的开集：空集、<span class="math inline">\(R^n\)</span>、数轴上的开区间、<span class="math inline">\(\{(x,y)|y&gt;0\}\)</span>、开球</p><p>任意多个开集的并还是开集，有限个开集的交还是开集</p><h4 id="闭集">闭集</h4><p>如果<span class="math inline">\(E\subset R^n\)</span>是开集，那么<span class="math inline">\(E^c\)</span>叫做<strong>闭集</strong>。</p><p>几个经典的闭集：数轴上的闭区间、<span class="math inline">\(R^2\)</span>的横轴和下半平面、有限个点的集合、开球的补</p><p>集合可以既不是开集也不是闭集。</p><p>任意个闭集的交还是闭集，有限个闭集的并还是闭集。</p><p>点集<span class="math inline">\(E\subset R^n\)</span>的全体聚点的集合叫做<span class="math inline">\(E\)</span>的<strong>导集</strong>，记作<span class="math inline">\(E&#39;\)</span>。如果<span class="math inline">\(\bar E=E\cup E&#39;\)</span>，那么<span class="math inline">\(\bar E\)</span>叫做<span class="math inline">\(E\)</span>的<strong>闭包</strong>。</p><p>如果<span class="math inline">\(E\)</span>是闭集，那么它的闭包是它自己。</p><p>内部是含于一个集合的最大开集，闭包是包含一个集合的最小闭集。</p><h3 id="rn中的基本定理"><span class="math inline">\(R^n\)</span>中的基本定理</h3><p>我们在学实数的时候经常提“六大定理”，即：</p><ol type="1"><li>确界存在定理</li><li>单调数列收敛定理</li><li>有界数列必有收敛子列</li><li>柯西收敛准则</li><li>闭区间套定理</li><li>有限覆盖定理</li></ol><p>在<span class="math inline">\(R^n\)</span>中，前两个定理不再成立，后面的继续成立。</p><ul><li><p><span class="math inline">\(R^n\)</span>中的有界点列必有收敛子列，也就是：任何无穷点集都含有聚点</p></li><li><p>如果<span class="math inline">\(\{x_k\}\)</span>是<span class="math inline">\(R^n\)</span>中的点列，如果<span class="math inline">\(\forall \varepsilon&gt;0,\exists N=N(\varepsilon)&gt;0,s.t. \forall k,l&gt;N,||x_k-x_l||&lt;\varepsilon\)</span>，称<span class="math inline">\(\{x_k\}\)</span>是基本列。“是基本列”和“收敛”等价。</p></li><li><p>设<span class="math inline">\(\{E_k\}\)</span>是一个闭集列，都不是空集，而且：</p><ul><li>后一项是前一项的子列</li><li><span class="math inline">\(\lim _{k\to \infty} diam(E_k)=0\)</span></li></ul><p>那么存在唯一的<span class="math inline">\(\xi \in \bigcap_{k=1}^{\infty} E_k\)</span>，其中<span class="math inline">\(diam(A)=\sup_{\forall x,y\in A}||x-y||\)</span>。</p></li><li><p>设<span class="math inline">\(E\in R^n,\{G_\alpha\}_{\alpha \in \Gamma}\)</span>是<span class="math inline">\(R^n\)</span>中的一个开集族，如果<span class="math inline">\(E\subset \bigcup G_\alpha\)</span>，称<span class="math inline">\(\{G\}\)</span>是<span class="math inline">\(E\)</span>的一个开覆盖。<span class="math inline">\(R^n\)</span>中的有界闭集的任意一个开覆盖都有有限子覆盖</p></li></ul><h3 id="距离">距离</h3><p>点<span class="math inline">\(x\)</span>和集合<span class="math inline">\(B\)</span>的距离为： <span class="math display">\[d(x,B)=\inf\{d(x,y):y\in B\}\]</span> 意思就是点到集合中每个点的距离的下确界</p><p>两个集合之间的距离为： <span class="math display">\[d(A,B)=\inf\{d(x,y):x\in A,y\in B\}\]</span> 意思就是从集合里面任选两个点，它们之间的距离的下确界</p><p>有以下结论：</p><ol type="1"><li>如果A是非空闭集，则<span class="math inline">\(\exists y\in A,s.t.d(x,y)=d(x,A)\)</span></li><li>如果AB是非空闭集，则<span class="math inline">\(\exists x\in A,y\in B,s.t. d(x,y)=d(A,B)\)</span></li><li><span class="math inline">\(F_1,F_2\)</span>是不相交的非空闭集，则存在<span class="math inline">\(R^n\)</span>上的连续函数，使得<ol type="1"><li><span class="math inline">\(0\leq f(x)\leq 1\)</span></li><li><span class="math inline">\(f(x)=0,x\in F_1\)</span>；<span class="math inline">\(f(x)=1,x\in F_2\)</span></li></ol></li></ol><h3 id="康托尔cantor三分集">康托尔（Cantor）三分集</h3><p>把<span class="math inline">\([0,1]\)</span>三等分，去掉中间的一部分，再把左右两个剩下的三等分，再各自去掉中间的一部分，重复无限次，剩下来的集合就是Cantor三分集（P）。</p><p>它：</p><ol type="1"><li>是闭集，完备集</li><li>没有内点</li><li>是疏朗集，即<span class="math inline">\(\bar P\)</span>(闭包)没有内点</li><li>基数是连续势</li><li>测度为零，外测度也为零</li></ol><p>康托尔函数<span class="math inline">\(\theta(x)\)</span>：把在构造康托尔集的过程中第<span class="math inline">\(n\)</span>次去掉的<span class="math inline">\(2^{n-1}\)</span>个开区间上依次取值为 <span class="math display">\[\frac {1}{2^n},\frac{3}{2^n},\cdots,\frac{2^n-1}{2^n}\]</span> 规定<span class="math inline">\(\theta(0)=0,\theta(1)=1\)</span></p><p>康托尔函数是<span class="math inline">\([0,1]\)</span>上的单调不减连续函数。</p><h2 id="测度论">测度论</h2><p>测度是“长度”、“面积”概念的扩展。</p><p>集合的测度<span class="math inline">\(m:E\to[0,+\infty]\)</span>应当满足：</p><ol type="1"><li><p>非负性</p></li><li><p>正则性：若<span class="math inline">\(I=(a,b)\)</span>，则<span class="math inline">\(m(I)=b-a\)</span></p></li><li><p>可数可加性：如果集合<span class="math inline">\(E_1,E_2\cdots\)</span>都有测度且两两不交，那么： <span class="math display">\[m\left(\bigcup_{k=1}^\infty E_k \right)=\sum_{k=1}^\infty m(E_k)\]</span></p></li></ol><p>这里主要讨论勒贝格测度。在定义测度时，先定义勒贝格外测度，然后在其基础上诱导出一个可测集合类，在其上的外测度就是一种期望的测度。</p><h3 id="外测度">外测度</h3><p>对于<span class="math inline">\(R^n\)</span>的子集<span class="math inline">\(E\)</span>，定义非负广义函数： <span class="math display">\[m^*(E)=\inf \left\{  \sum_{k=1}^\infty |I_k|:I_1,I_2\cdots\text{是开矩体,且}E\subset \bigcup_{k=1}^\infty I_k\right\}\]</span> 开矩体是<span class="math inline">\(n\)</span>个开区间的直积，其体积为每个开区间的长度之积。</p><p>外测度有以下性质：</p><ol type="1"><li><p>非负性</p></li><li><p>单调性：如果<span class="math inline">\(E_1\subset E_2\)</span>，则<span class="math inline">\(m^*(E_1)\leq m^*(E_2)\)</span></p></li><li><p>次可数可加性：如果集合<span class="math inline">\(E_1,E_2\cdots\)</span>都有测度且两两不交，那么： <span class="math display">\[m^*\left(\bigcup_{k=1}^\infty E_k \right)\leq \sum_{k=1}^\infty m^*(E_k)\]</span></p></li><li><p>平移不变性： <span class="math display">\[m^*(E+\{a\})=m^*(E)\]</span> 其中<span class="math inline">\(E+\{a\}=\{x+a,x\in E\}\)</span></p></li></ol><h3 id="可测集">可测集</h3><p>定义，如果<span class="math inline">\(E,T\in R^n\)</span>： <span class="math display">\[m^*(T)=m^*(T\cap E)+m^*(T\cap E^c)\]</span> 则称<span class="math inline">\(E\)</span>是勒贝格<strong>可测集</strong>，简称为可测集。此时<span class="math inline">\(m^*(E)\)</span>称为<span class="math inline">\(E\)</span>的测度，记作<span class="math inline">\(m(E)\)</span>。这个等式叫做卡特西奥多里条件。</p><p>这个条件可以等价于： <span class="math display">\[m^*(T)\geq m^*(T\cap E)+m^*(T\cap E^c)\]</span> 设<span class="math inline">\(R^n\)</span>上的可测集所构成的集族称为M，则：</p><ol type="1"><li>空集属于M</li><li>如果<span class="math inline">\(E\)</span>可测，那么<span class="math inline">\(E^c\)</span>可测</li><li>如果<span class="math inline">\(E_1,E_2\in M\)</span>，则它们的并、交、差都是可测</li><li>可测集的有限并也可测，而且满足可列可加</li></ol><p>区间可测，凡是开集或闭集都可测，外测度为零的集合可测且测度为零</p><p>零测集的子集、至多可数个零测集的并也是零测集。</p><h3 id="不可测集">不可测集</h3><p>存在不可测集。</p><h2 id="可测函数">可测函数</h2><h3 id="可测函数的定义和性质">可测函数的定义和性质</h3><p>设<span class="math inline">\(f(x)\)</span>是定义在可测集<span class="math inline">\(E\subset R^n\)</span>上的广义实值函数，若<span class="math inline">\(\forall a\in R\)</span>，<span class="math inline">\(E(f&gt;a)\)</span>（即<span class="math inline">\(\{x\in E:f(x)&gt;a\}\)</span>）都是可测集，则称<span class="math inline">\(f(x)\)</span>为<strong>可测函数</strong>。</p><p>以下条件相互等价：</p><ul><li><span class="math inline">\(f(x)\)</span>是可测函数，即<span class="math inline">\(\forall a\in R,E(f&gt; a)\)</span>可测</li><li><span class="math inline">\(\forall a\in R,E(f\geq a)\)</span>可测</li><li><span class="math inline">\(\forall a\in R,E(f&lt; a)\)</span>可测</li><li><span class="math inline">\(\forall a\in R,E(f\leq a)\)</span>可测</li></ul><p>如果<span class="math inline">\(f(x)\)</span>在可测集<span class="math inline">\(E\)</span>上是可测函数，那么在<span class="math inline">\(E\)</span>的每个可测子集上也是可测函数。</p><p>如果<span class="math inline">\(E=\bigcup_{k=1}^\infty E_k\)</span>，其中每一个<span class="math inline">\(E_k\)</span>都是可测集而且<span class="math inline">\(f(x)\)</span>在其上可测，那么<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上可测。</p><p>可测函数类关于确界、上下极限封闭。即：如果<span class="math inline">\(\{f_k\}\)</span>都是可测集<span class="math inline">\(E\)</span>上的函数，那么<span class="math inline">\(\sup_k f_k(x),\inf_k f_k(x),\overline{\lim}_{k\to \infty}f_k(x),\underline{\lim}_{k\to \infty}f_k(x)\)</span>都可测。</p><p>可测函数类关于加、减、乘、除、数乘、绝对值封闭。</p><p>如果<span class="math inline">\(P(x)\)</span>是一个和集合<span class="math inline">\(E\)</span>中元素<span class="math inline">\(x\)</span>有关的命题，如果存在一个<span class="math inline">\(E\)</span>的零测子集<span class="math inline">\(M\)</span>，使得<span class="math inline">\(P(x)\)</span>在<span class="math inline">\(E/M\)</span>上恒成立，称<span class="math inline">\(P(x)\)</span>在<span class="math inline">\(E\)</span>上<strong>几乎处处成立</strong>，记作<span class="math inline">\(a.e.\)</span></p><p>如果<span class="math inline">\(f(x),g(x)\)</span>都是<span class="math inline">\(E\)</span>上的广义实值函数，且<span class="math inline">\(f(x)=g(x)\ a.e. x\in E\)</span>，那么<span class="math inline">\(f(x)\)</span>可测是<span class="math inline">\(g(x)\)</span>可测的充要条件。</p><p>下面定义三种函数：</p><ol type="1"><li><p>设<span class="math inline">\(X=R\)</span>的一个子集<span class="math inline">\(E\)</span>，称： <span class="math display">\[\chi_E(x)=\begin{cases}1 &amp; x\in E\\0 &amp; x\in E^c\end{cases}\]</span> 为<span class="math inline">\(E\)</span>上的<strong>特征函数</strong>。如果<span class="math inline">\(E\)</span>可测，那么它的特征函数可测。</p></li><li><p>如果<span class="math inline">\(f(x)\)</span>的定义域<span class="math inline">\(E\)</span>可以分为有限个不相交的集合<span class="math inline">\(E_k\)</span>，且<span class="math inline">\(f(x)\)</span>在每个<span class="math inline">\(E_k\)</span>上取常值<span class="math inline">\(c_k\)</span>，那么称<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的<strong>简单函数</strong>。（简单理解：取有限个实数）</p></li><li><p>如果在简单函数的定义的基础上，每个<span class="math inline">\(E_k\)</span>都是矩体，称<span class="math inline">\(f(x)\)</span>为<strong>阶梯函数</strong>。</p></li></ol><h3 id="可测函数和简单函数的关系简单函数逼近定理">可测函数和简单函数的关系(简单函数逼近定理)</h3><p>如果<span class="math inline">\(f(x)\)</span>是可测集<span class="math inline">\(E\subset R\)</span>上的非负可测函数，当且仅当存在非负可测渐升简单函数列<span class="math inline">\(\{\phi_k(x)\}\)</span>，使得： <span class="math display">\[\lim_{k\to \infty}\phi_k(x)=f(x)\]</span> 如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上有界，那么上述收敛是一致的。</p><blockquote><p>事实上，作简单函数列<span class="math inline">\(\phi_k(x)\)</span>，使得： <span class="math display">\[\phi_k(x)=k\chi_{F_k}(x)+\sum_{i=1}^{k2^k}\frac{i-1}{2^k}\chi_{E_{ki}}(x)\]</span> 其中 <span class="math display">\[E_{ki}=E\left(\frac{i-1}{2^k}\leq f&lt;\frac i{2^k}\right),F_k=E(f\geq k)\]</span> 即满足上述定理的要求。</p></blockquote><p>如果<span class="math inline">\(f(x)\)</span>是可测集<span class="math inline">\(E\)</span>上的可测函数，当且仅当存在可测的简单函数列<span class="math inline">\(\{f_k(x)\}\)</span>，满足：</p><ol type="1"><li><span class="math inline">\(|f_k(x)|\leq|f(x)|\)</span></li><li><span class="math inline">\(\lim_{k\to \infty}f_k(x)=f(x)\)</span></li></ol><p>如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上有界，那么上述收敛是一致的。</p><blockquote><p>在证明时，可以把<span class="math inline">\(f(x)\)</span>分解成正负部之差，利用前面关于非负函数的定理，令 <span class="math display">\[f_k(x)=\phi^+_k(x)-\phi^-_k(x)\]</span></p></blockquote><h3 id="可测函数的收敛">可测函数的收敛</h3><p>设<span class="math inline">\(f(x),f_k(x)\)</span>都是定义在<span class="math inline">\(E\)</span>上的可测函数，有：</p><ol type="1"><li><p>处处收敛：<span class="math inline">\(\forall \epsilon&gt;0,\forall x\in E,\exists K=K(x,\epsilon)\)</span>当<span class="math inline">\(k&gt;K\)</span>时，有：<span class="math inline">\(|f_k(x)-f(x)|&lt;\epsilon\)</span>，记作 <span class="math display">\[\lim_{k\to \infty}f_k(x)=f(x)\]</span></p></li><li><p>几乎处处收敛：存在一个零测集，使得<span class="math inline">\(f_k(x)\)</span>在<span class="math inline">\(E\)</span>中除了这个零测集以外的点上收敛于<span class="math inline">\(f(x)\)</span></p></li><li><p>一致收敛：<span class="math inline">\(\forall \epsilon&gt;0,\forall x\in E,\exists K=K(\epsilon)\)</span>当<span class="math inline">\(k&gt;K\)</span>时，有：<span class="math inline">\(|f_k(x)-f(x)|&lt;\epsilon\)</span>。一致收敛等价于： <span class="math display">\[\lim_{k\to \infty}\sup_{x\in E}|f_k(x)-f(x)|=0\]</span></p></li></ol><p>有Egoroff（叶洛果夫）定理：设<span class="math inline">\(m(E)&lt; \infty\)</span>，如果<span class="math inline">\(\{f_k\}\)</span>在<span class="math inline">\(E\)</span>上几乎处处收敛，那么对于任意的<span class="math inline">\(\delta &gt; 0\)</span>，有<span class="math inline">\(E\)</span>的可测子集<span class="math inline">\(E_\delta,m(E_\delta)&lt;\delta\)</span>，使得<span class="math inline">\(\{f_k\}\)</span>在<span class="math inline">\(E/E_\delta\)</span>上一致收敛。也就是说，几乎处处收敛的函数列是“近一致收敛”的。</p><blockquote><p>例如，对于函数列<span class="math inline">\(\{f_k=x^k\}\)</span>，<span class="math inline">\(E=[0,1]\)</span>，其处处收敛于 <span class="math display">\[f(x)=\begin{cases}0,&amp;x\in[0,1)\\1,&amp;x=1\end{cases}\]</span> 因 <span class="math display">\[\beta_k=\sup_{x\in E}|f_k-f|=1\]</span> 不趋向于<span class="math inline">\(0\)</span>，所以它不是一致收敛的。然而只要去掉任意小的区域，把<span class="math inline">\(E\)</span>变成<span class="math inline">\([0,1-\delta]\)</span>，那么就一致收敛了。</p></blockquote><p>其实还有比几乎处处收敛更弱的收敛，叫做<strong>依测度收敛</strong>。如果<span class="math inline">\(\{f_k\},f\)</span>是可测集<span class="math inline">\(E\)</span>上的几乎处处有限的函数，如果对任意<span class="math inline">\(\varepsilon&gt;0\)</span>，有： <span class="math display">\[\lim _{k \rightarrow \infty} m\left(\left\{x \in E:\left|f_k(x)-f(x)\right|&gt;\varepsilon\right\}\right)=0\]</span> 即：<span class="math inline">\(f_k\)</span>与<span class="math inline">\(f\)</span>的差值比<span class="math inline">\(\varepsilon\)</span>大的集合的测度趋向于0，那么说<span class="math inline">\(\{f_k\}\)</span>依测度收敛于<span class="math inline">\(f\)</span>。</p><p>几乎处处收敛比依测度收敛更强，是因为<strong>几乎处处有限可以推出依测度收敛，反之不然</strong>。</p><p>如果函数列依测度收敛，那么存在函数列的子列<span class="math inline">\(\{f_{k_i}\}\)</span>几乎处处收敛，这叫做<strong>Riesz定理</strong>。</p><p>如果<span class="math inline">\(f\)</span>是可测集<span class="math inline">\(E\)</span>上的几乎处处有限的函数，<span class="math inline">\(\forall \delta&gt;0,\exists F,m(E/F)&lt;\delta\)</span>，使得<span class="math inline">\(f(x)\)</span>在闭集<span class="math inline">\(F\)</span>上连续，这叫做<strong>鲁津定理</strong>。</p><p>有关可测函数的常见结论和各种收敛的关系总结如下：</p><ul><li>可测函数与零测集无关.</li><li>可测函数是简单函数列处处收敛的极限.(当可测函数有界时, 可做到一致收敛)</li><li>可测函数关于一些运算的封闭性.</li><li>可测集 <span class="math inline">\(E\)</span> 上的连续函数是可测的.</li><li>可测集 <span class="math inline">\(E\)</span> 上的简单函数是可测的.</li><li><span class="math inline">\(R\)</span> 中可测集 <span class="math inline">\(E\)</span> 上的单调函数是可测的.</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212121534719.png" alt="各种收敛" /><figcaption aria-hidden="true">各种收敛</figcaption></figure><h2 id="勒贝格积分">勒贝格积分</h2><p>首先我们从简单函数出发：假设<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(E\subset R\)</span>上的非负简单函数，在<span class="math inline">\(E_i\)</span>上取值<span class="math inline">\(c_i\)</span>，且<span class="math inline">\(E=\bigcup E_i,E_i\cap E_j=\emptyset\)</span>。也就是说： <span class="math display">\[\varphi(x)=\sum_{i=1}^p c_i\chi_{E_i}(x)\]</span> 那么定义<span class="math inline">\(\varphi(x)\)</span>在<span class="math inline">\(E\)</span>上的勒贝格积分（下简称为L积分）为： <span class="math display">\[\int _E\varphi(x)dx=\sum_{i=1}^p c_im(E_i)\]</span> 根据简单函数逼近定理，我们可以把这个定义扩展到非负可测函数上：如果<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的非负可测函数，那么定义<span class="math inline">\(f(x)\)</span>的L积分： <span class="math display">\[\int_E f(x)dx=\sup_{\varphi(x)\leq f(x),x\in E}\left\{ \int_E \varphi(x)dx\right\}\]</span> 其中<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(E\)</span>上的非负可测简单函数。如果有： <span class="math display">\[\int_E f(x)dx&lt;\infty\]</span> 就称<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上可积的。</p><p>进一步，因为每个可测函数都可以分解成两个非负可测函数的差（即正部和负部），有： <span class="math display">\[f(x)=f^+(x)-f^-(x)\]</span> 定义可测函数上的L积分： <span class="math display">\[\int _Ef(x)dx=\int_Ef^+(x)dx-\int_E f^-(x)dx\]</span></p><h3 id="l积分的性质">L积分的性质</h3><h4 id="l积分的条件">L积分的条件</h4><p>以下，记<span class="math inline">\(L(E)\)</span>为在<span class="math inline">\(E\)</span>上L可积的函数构成的集合。</p><ol type="1"><li>【必要条件】：<span class="math inline">\(f(x)\in L(E)\to f(x)\)</span>在<span class="math inline">\(E\)</span>上几乎处处有界</li><li>【充分条件】：<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的有界可测函数，<span class="math inline">\(m(E)&lt;+\infty\)</span>，则<span class="math inline">\(f(x)\in L(E)\)</span></li><li>【充分条件】：<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的可测函数，<span class="math inline">\(g(x)\in L(E),|f(x)|&lt;g(x)\)</span>，则<span class="math inline">\(f(x)\in L(E)\)</span></li></ol><h4 id="l积分的基本性质">L积分的基本性质</h4><ol type="1"><li><p>线性，保序性</p><p>略，和黎曼积分（以下简称R积分）相同</p></li><li><p>有限可加性</p><p>如果<span class="math inline">\(f(x)\in L(E)\)</span>，那么<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>的子集上也L可积。</p><p>如果<span class="math inline">\(E=A\cup B,A\cap B=\emptyset,AB\)</span>可测，那么 <span class="math display">\[ \int_E f(x)dx=\int_Af(x)dx+\int_Bf(x)dx \]</span></p></li><li><p>集合意义</p><p>如果<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\subset R^n\)</span>上的非负实值函数，称： <span class="math display">\[ \underline{G}(f)=\underline{G}_E(f)=\left\{(x, y) \in R^{n+1}: x \in E, 0 \leq y \leq f(x)\right\} \]</span> 为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上的下方图形，如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上可测，那么他的下方图形在<span class="math inline">\(R^{n+1}\)</span>上也可测，有： <span class="math display">\[ m(\underline{G}(f))=\int_E f(x) d x \]</span> 如果<span class="math inline">\(E\)</span>可测，则<span class="math inline">\(G(f)\)</span>在<span class="math inline">\(R^{n+1}\)</span>上可测，<span class="math inline">\(f(x)\)</span>也 可测，且也有上面的结论</p></li></ol><h4 id="l积分的特殊性质">L积分的特殊性质</h4><ol type="1"><li><p>零测集上任何函数L积分为零，更进一步，如果两个函数只在一个零测集上有区别，那么这两个函数的L积分相等</p></li><li><p>函数<span class="math inline">\(f(x)\)</span>L可积和其绝对值<span class="math inline">\(|f(x)|\)</span>L可积等价，且积分的绝对值不大于绝对值的积分</p></li><li><p>绝对连续性：如果<span class="math inline">\(f(x)\in L(E)\)</span>，则<span class="math inline">\(\forall \varepsilon &gt;0,\exists \delta&gt;0,s.t. \forall e\in E,m(e)&lt;\delta\)</span>，有： <span class="math display">\[\left|\int_e f(x) \mathrm{d} x\right| \leq \int_e|f(x)| \mathrm{d} x&lt;\varepsilon\]</span></p></li><li><p>如果一个函数R可积，那么它L可积，且两个积分的值相等。</p><p>这说明，R积分的有关问题，可以转换为L积分，再利用马上就要说明的L积分的优良性质完成 。</p></li></ol><h4 id="l积分的优良性质">L积分的优良性质</h4><p>【勒贝格收敛控制定理】如果<span class="math inline">\(\{f_k(x)\}\)</span>是<span class="math inline">\(E\in R^n\)</span>上的可测函数列，且：</p><ol type="1"><li><span class="math inline">\(\lim _{k\to \infty}f_k(x)=f(x)\)</span></li><li><span class="math inline">\(\exists F(x)\in L(E),\forall k,|f_k(x)|\leq F(x)\ a.e.x\in E\)</span></li></ol><p>那么，<span class="math inline">\(f_k(x),f(x)\in L(E)\)</span>，且积分和极限可以交换次序，有： <span class="math display">\[\lim _{k \rightarrow \infty} \int_E f_k(x) \mathrm{d} x=\int_E f(x) \mathrm{d} x=\int_E \lim _{k \rightarrow \infty} f_k(x) \mathrm{d} x .\]</span></p><blockquote><p>相比之下，黎曼积分需要函数列一致收敛，才能交换顺序。一致收敛是一个非常强的条件。</p></blockquote><p>推论：如果<span class="math inline">\(\{f_k(x)\}\)</span>是<span class="math inline">\(E\in R^n\)</span>上的可测函数列，且：</p><ol type="1"><li><span class="math inline">\(\lim _{k\to \infty}f_k(x)=f(x)\)</span></li><li><span class="math inline">\(\exists M&gt;0,|f_k(x)|\leq M,a.e. x\in E\)</span></li><li><span class="math inline">\(m(E)&lt;\infty\)</span></li></ol><p>那么，<span class="math inline">\(f_k(x),f(x)\in L(E)\)</span>，且积分和极限可以交换次序，有： <span class="math display">\[\lim _{k \rightarrow \infty} \int_E f_k(x) \mathrm{d} x=\int_E f(x) \mathrm{d} x=\int_E \lim _{k \rightarrow \infty} f_k(x) \mathrm{d} x .\]</span> 推论：设<span class="math inline">\(u_i(x)\in L(E)\)</span>，且有： <span class="math display">\[\sum_{i=1}^{\infty} \int_E\left|u_i(x)\right| d x&lt;+\infty\]</span> 则：</p><ol type="1"><li><p><span class="math inline">\(\sum_{i=1}^n u_i(x)\)</span>几乎处处收敛</p></li><li><p>其和函数<span class="math inline">\(f(x)\in L(E)\)</span>，且 <span class="math display">\[\int_E f(x) \mathrm{d} x=\int_E\left[\sum_{i=1}^{\infty} u_i(x)\right] \mathrm{d} x = \sum_{i=1}^{\infty} \int_E u_i(x) d x\]</span></p></li></ol><blockquote><p>【例】求 <span class="math display">\[\lim _{n \rightarrow \infty}(R) \int_0^1 \frac{n x}{1+n^2 x^2} \sin n x d x\]</span></p><p>【解】因为原函数列不一致收敛，因此需要用L积分。</p><p>验证勒贝格收敛控制定理： <span class="math display">\[\left|f_n(x)\right| \leq\left|\frac{n x}{1+n^2 x^2}\right| \leq \frac{n x}{2 n x}=\frac{1}{2} \stackrel{\Delta}{=} F(x), x \in[0,1]\]</span></p><p>则有： <span class="math display">\[\begin{aligned}&amp; \lim _{n \rightarrow \infty}(R) \int_0^1 \frac{n x}{1+n^2 x^2} \sin n x d x \\&amp; =\lim _{n \rightarrow \infty}(L) \int_{[0,1]} \frac{n x}{1+n^2 x^2} \sin n x d x \\&amp; =(L) \int_{[0,1]}\left(\lim _{n \rightarrow \infty} \frac{n x}{1+n^2 x^2} \sin n x\right) d x \\&amp; =(L) \int_{[0,1]} 0 \mathrm{~d} x=0 .\end{aligned}\]</span></p></blockquote><p>有时候，问题中并不显式地出现极限、求和符号，但是可以通过把被积分展开成级数的和，再求解：</p><blockquote><p>【例】 <span class="math display">\[\int_{0}^1 \frac{\ln(1-x)}{x}dx\]</span> 【解】</p><p>首先展开成级数： <span class="math display">\[\frac{\ln (1-x)}{x}=-\sum_{n=1}^{\infty} \frac{x^{n-1}}{n}, x \in[0,1)\]</span></p><p>我们发现这不是一致收敛的，但是没关系，我们有勒贝格积分： <span class="math display">\[\begin{aligned}&amp;\ (R) \int_0^1 \frac{\ln (1-x)}{x} \mathrm{~d} x \\&amp; =(L) \int_{[0,1]} \frac{\ln (1-x)}{x} \mathrm{~d} x \\&amp; =(L) \int_{[0,1]}\left(-\sum_{n=1}^{\infty} \frac{x^{n-1}}{n}\right) \mathrm{d} x\\&amp; =-\sum_{n=1}^{\infty}(L) \int_{[0,1]} \frac{x^{n-1}}{n} d x \\&amp; =-\sum_{n=1}^{\infty} \frac{1}{n^2} \\&amp; =-\frac{\pi^2}{6} \end{aligned}\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实变泛函</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路·逻辑之章</title>
    <link href="/2022/11/16/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/16/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>你说得对，但是《数字电子技术基础》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作五（203）的幻想世界，在这里，被神选中的信号将被授予“门电路”，导引高低电平之力。玩家将扮演一位名为“学生”的神秘角色，在自由的课程中邂逅性格各异、能力独特的元件们，和他们一起分析逻辑，找回失散的导线——同时，逐步发掘“Verilog”的真相。</p><span id="more"></span><h2 id="数制和码制">数制和码制</h2><h3 id="数制">数制</h3><p>数制指的是数字每一位的构成方法，以及从低位到高位的进位规则。常用的数制有十进制、二进制、八进制、十六进制。</p><p>k进制数字的基本表示方式为： <span class="math display">\[(\cdots x_2x_1x_0.x_{-1}x_{-2}\cdots)_k=\sum_{i=-\infty}^{\infty}x_i\times k^i\]</span></p><h4 id="不同数制的转换方式">不同数制的转换方式</h4><ul><li><p>任意进制到十进制的转换</p><p>直接按上面的式子展开即可。</p><blockquote><p>【例】<span class="math inline">\((8FA.C)_{16}=8\times 16^2+F\times16^1+A\times16^0+C\times16^{-1}=(2298.75)_{10}\)</span></p></blockquote></li><li><p>十-二转换</p><p>整数部分用除二取余法，小数部分用乘二取整法。这成天写，我不展开了，忘了就随便拿个什么11啊这种数字推一下。</p></li><li><p>二-十六（八）转换</p><p>分组对应法最快。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161438587.png" alt="进制转换对应表" /><figcaption aria-hidden="true">进制转换对应表</figcaption></figure></li></ul><p>不同进制下四则运算的规则和方法和十进制一致。</p><h4 id="原码反码和补码">原码、反码和补码</h4><ul><li><p>原码</p><p>最高位（最左边的一位）表示正负号，0为+，1为-，其余各位表示数的绝对值。</p><p>表示范围为<span class="math inline">\(-(2^{n-1}-1)\sim (2^{n-1}-1)\)</span>，0的表示不唯一</p></li><li><p>反码</p><p>正数和原码的规则一样，有符号位和绝对值；负数是它的相反数整体（含符号位）取反，当然也可以理解成，负数的符号位是1，绝对值按位取反。</p><p>表示范围为<span class="math inline">\(-(2^{n-1}-1)\sim (2^{n-1}-1)\)</span>，0的表示不唯一</p></li><li><p>补码</p><p>正数和原码的规则一样；负数为“反码加一”，即符号位为1，绝对值按位取反，再加一。</p><p>表示范围为<span class="math inline">\(-(2^{n-1})\sim (2^{n-1}-1)\)</span>，0的表示唯一。</p><p>补码加减法运算，符号位参与运算，而且应该在相应位数表示的数值范围内进行，进位直接丢弃。</p><blockquote><p>【例】利用补码加法计算39-22</p><p>【解】<span class="math inline">\((39)_{10}=(0|010\ 0111)_{2},(-22)_{10}=(1|110\ 1010)_2\)</span>，两个二进制数相加后为<span class="math inline">\((1\ 0001\ 0001)_2\)</span>，舍弃溢出位，得结果为<span class="math inline">\((0|001\ 0001)_2=(17)_{10}\)</span></p></blockquote><p>补码的运算有模的特性。</p></li></ul><h3 id="码制">码制</h3><ul><li><p>BCD码</p><p>BCD码，即二-十进制代码，它是用二进制代码表示十进制数码的编码方法，也就是0~9这十个符号的二进制编码。分为恒权码和变权码等。</p><p>例如：8421码，就是从高位到低位的权依次是8421（和普通二进制一样），它的有效编码是0000<sub>1001，分别代表0</sub>9，其它的是非法码。</p><p>还有其他的编码，比如2421码、余3码、余3循环码等。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161527716.png" alt="常用BCD码" /><figcaption aria-hidden="true">常用BCD码</figcaption></figure></li><li><p>格雷码</p><p>格雷码的特性如下：</p><ul><li>单位距离：相邻码字仅有一个位元不同，其它位都相同。</li><li>循环相邻：对于n位循环码，如果从第0个码字开始，最大范围是第<span class="math inline">\((2^n-1)\)</span>个码字，而对<span class="math inline">\((2^n-1)\)</span>的编码一定是<span class="math inline">\(( 2^ {n-1})\)</span>的自然二进制码。</li><li>镜像反射</li></ul></li></ul><h2 id="逻辑代数">逻辑代数</h2><p>逻辑运算的大部分知识已经在“离散数学”课程中讲过了，这里仅进行补充。这里“<span class="math inline">\(\cdot\)</span>”表示与，"<span class="math inline">\(+\)</span>"表示或，<span class="math inline">\(\overline{X}\)</span>表示非，<span class="math inline">\(\oplus\)</span>表示异或，<span class="math inline">\(\odot\)</span>表示异或。</p><h3 id="逻辑函数的两种标准形式">逻辑函数的两种标准形式</h3><p>两种标准形式就是指标准与或表达式（也叫最小项之和，主析取范式），和标准或与表达式（也叫最大项之积，主合取范式）。</p><ul><li><p>标准与或表达式</p><p>形如下列式子的形式： <span class="math display">\[\begin{align}Y&amp;=AB\overline{C}+ABC+\overline{A}BC\\&amp;=m_{3}+m_{6}+m_{7}\\&amp;=\sum m(3,6,7)\end{align}\]</span> 这三个形式都是标准与或表达式。<span class="math inline">\(m\)</span>下面的下标由对应的最小项确定（没有取反的项记为1，有取反的项记为1，构成一个二进制串，转换为十进制即可）。</p></li><li><p>标准或与表达式</p><p>形如下面的式子： <span class="math display">\[\begin{align}Y&amp;=(A+B+C)(A+B+\overline{C})(\overline{A}+B+C)\\&amp;=M_0M_1M_4\\&amp;=\prod M(0,1,4)\end{align}\]</span> 和上面的一样，不赘述了。</p></li></ul><h3 id="逻辑化简">逻辑化简</h3><p>公式法略。</p><h4 id="卡诺图法">卡诺图法</h4><p>卡诺图法是一种从真值表出发得到最简与或表达式的方法。使用卡诺图的步骤如下：</p><ol type="1"><li><p>先记住这几个标准格式</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161607455.png" alt="卡诺图" /><figcaption aria-hidden="true">卡诺图</figcaption></figure><p>其实很好记的，横纵坐标就是格雷码的顺序，这也是为了利用单位距离性。</p></li><li><p>在逻辑函数为真的格子上填1，逻辑函数为假的格子填0</p></li><li><p>画卡诺圈（乘积项），合并最小项（1），反复利用互补律化简。卡诺圈的形状可以是日字形，田字形，而且有循环边界条件。</p><p>互补律：<span class="math inline">\(A\overline{A}=0,A+\overline{A}=1\)</span></p><p>画卡诺圈时应该遵循以下原则：</p><ol type="1"><li>“1”格不能漏圈</li><li>“1”格可以属于一个以上的圈</li><li>圈越大越好</li><li>圈越少越好</li><li>每个圈应该包含至少一个新的“1”格</li></ol></li></ol><h4 id="无关项">无关项</h4><p>有时候，输入逻辑变量的某些取值组合禁止出现，这种叫做“约束项”。有时候，一些取值组合出现时，输出逻辑值可以是任意的，这种叫做“任意项”。以上两个统称为无关项。在化简时，把无关项用X表示，在画卡诺圈时，X既可以被当作1，也可以被当作0，具体看你需要。</p><h4 id="逻辑函数形式的转换">逻辑函数形式的转换</h4><p>除了我们前面说的最简与或式以外，还有一些常用的形式。</p><ul><li><p>最简或与式</p><p>在画出<span class="math inline">\(Y\)</span>的卡诺图后，合并<span class="math inline">\(0\)</span>方格，求反函数的最简与或表达式，然后使用德摩根公式进行反演变换，得到原函数的最简或与表达式</p><p>德摩根公式： <span class="math display">\[\overline{AB}=\overline{A}+\overline{B},\overline{A+B}=\overline{A}\cdot\overline{B}\]</span></p><blockquote><p>【例】已知Y的反函数，求Y的最简或与式。 <span class="math display">\[\overline{Y}=AB+CD+B\overline{D}\]</span> 【解】 <span class="math display">\[\begin{align}Y&amp;=\overline{AB}\cdot\overline{CD}\cdot\overline{B\overline{D}}\\&amp;=(\overline{A}+\overline{B})(\overline{C}+\overline{D})(\overline{B}+{D})\end{align}\]</span></p></blockquote></li><li><p>或非-或非式</p><p>先求出最简或与式，对最简或与式求两次反，再对内侧（下面）的反用一次德摩根公式展开。</p><blockquote><p>【例】 <span class="math display">\[\overline{\overline{(A+B)(\overline{A}+C)}}\to \overline{\overline{A+B}+\overline{\overline{A}+C}}\]</span></p></blockquote><p>也可以在求出反函数的最简与或表达式的时候，直接对反函数两端求反，再对各个乘积项用德摩根公式</p><blockquote><p>【例】 <span class="math display">\[\begin{align}&amp;\overline Y=\overline A\cdot \overline B+A\overline C\\&amp;\to Y=\overline{\overline A\cdot \overline B+A\overline C}\\&amp;\to Y=\overline{\overline{A+B}+\overline{\overline A+C}}\end{align}\]</span></p></blockquote></li><li><p>与非-与非式</p><p>把与或表达式两次取反，再用德摩根公式即可。</p><blockquote><p>【例】 <span class="math display">\[\begin{aligned}Y &amp;={A C+\overline{A} B} \\&amp;=\overline{\overline{A C+\overline{A} B}} \\&amp;=\overline{\overline{A \cdot C} \cdot \overline{\overline{A} \cdot B}}\end{aligned}\]</span></p></blockquote></li><li><p>与或非式</p><p>先求反函数的最简与或表达式，再求反。</p><blockquote><p>【例】 <span class="math display">\[\begin{align}Y&amp;=A C+\overline{A} B \\\overline{Y}&amp;=\overline{A} \cdot \overline{B}+A \cdot \overline{C} \\Y&amp;=\overline{\overline{A} \cdot \overline{B}+A \cdot \overline{C}}\end{align}\]</span></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波技术·波之章</title>
    <link href="/2022/11/07/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/07/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《微波技术》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作五（303）的幻想世界，在这里，被神选中的信号将被授予“波导”，导引电磁波。玩家将扮演一位名为“传输线”的神秘角色，在自由的课程中邂逅性格各异、能力独特的圆图们，和他们一起分析阻抗，找回失散的能量——同时，逐步发掘“Black Magic”的真相。</p><span id="more"></span><p>[toc]</p><h2 id="传输线理论">传输线理论</h2><p>微波的工作频率为<span class="math inline">\(300MHz\sim 3000GHz\)</span>，对应的自由空间中的波长为<span class="math inline">\(1m\sim 0.1mm\)</span>，在这种条件下，日常尺度的导线以及具备很多异于理想导线的性质，被称作“长线”或者“传输线”，理想导线则被称作“短线”。具体来说，当系统的电长度<span class="math inline">\(l/\lambda \geq0.05\)</span>时，就要用传输线理论来分析问题，这种导线就被称作长线。</p><h3 id="传输线方程">传输线方程</h3><p>对于传输线上的一个微元<span class="math inline">\(dz\)</span>，有其等效集总参数模型：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211181534581.png" alt="image-20221118153336875" /><figcaption aria-hidden="true">image-20221118153336875</figcaption></figure><p>其中<span class="math inline">\(R_0\)</span>叫分布电阻，<span class="math inline">\(L_0\)</span>叫分布电感，<span class="math inline">\(G_0\)</span>叫分布电导，<span class="math inline">\(C_0\)</span>叫分布电容。理想导体的<span class="math inline">\(R_0=0\)</span>，理想介质的<span class="math inline">\(G_0=0\)</span>。</p><p>根据基尔霍夫定律列出方程，转换为复频域形式，则有我们所说的传输线方程，也叫频域电报方程 <span class="math display">\[\begin{aligned}&amp;\frac{\mathrm{d} \dot{U}(z)}{\mathrm{d} z}=-\left(R_0+j \omega L_0\right) \dot{I}(z)=-Z \dot{I}(z) \\&amp;\frac{\mathrm{d} \dot{I}(z)}{\mathrm{d} z}=-\left(G_0+\mathrm{j} \omega C_0\right) \dot{U}(z)=-Y \dot{U}(z)\end{aligned}\]</span> 其中<span class="math inline">\(Z=(R_0+j\omega L_0)\)</span>叫单位长度串联阻抗、<span class="math inline">\(Y=(G_0+j\omega C_0)\)</span>叫单位长度并联导纳。把上面两个式子对<span class="math inline">\(z\)</span>求导，再代换，有： <span class="math display">\[\begin{aligned}&amp;\frac{\mathrm{d}^2 \dot{U}(z)}{\mathrm{dz} z^2}-\gamma^2 \dot{U}(z)=0 \\&amp;\frac{\mathrm{d}^2 \dot{I}(z)}{\mathrm{d} z^2}-\gamma^2 \dot{l}(z)=0\end{aligned}\]</span> 其中 <span class="math display">\[\gamma=\sqrt{Z Y}=\sqrt{\left(R_0+\mathrm{j} \omega L_0\right)\left(G_0+\mathrm{j} \omega C_0\right)}=\alpha+\mathrm{j} \beta\]</span> 叫做传播常数，是一个取决于传输线物理性质的常数。于是，可以解出传输线方程的通解： <span class="math display">\[\dot{U}(z)=A_1 \mathrm{e}^{-\gamma z}+A_2 \mathrm{e}^{\gamma z}\]</span></p><p><span class="math display">\[I(z)=-\frac 1Z\frac{ \mathrm{~d} \dot{U}(z)}{ \mathrm{~d} z}=\frac{\gamma}{Z}\left(A_1 \mathrm{e}^{-\gamma z}-A_2 \mathrm{e}^{\gamma z}\right)=\frac{1}{Z_0}\left(A_1 \mathrm{e}^{-\gamma z}-A_2 \mathrm{e}^{\gamma z}\right)\]</span></p><p>其中<span class="math inline">\(Z_0\)</span>叫做传输线特性阻抗，有： <span class="math display">\[Z_0=\frac{Z}{\gamma}=\sqrt{\frac{Z}{Y}}=\sqrt{\frac{R_0+\mathrm{j} \omega L_0}{G_0+\mathrm{j} \omega C_0}}\]</span> <span class="math inline">\(A_1,A_2\)</span>是待定常数，要根据端口条件来确定。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211181630064.png" alt="完整电路" /><figcaption aria-hidden="true">完整电路</figcaption></figure><ol type="1"><li><p>终端条件</p><p>即已知终端<span class="math inline">\(\dot{U}_2,\dot{I}_2\)</span>。则有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{1}{2}\left(\dot{U}_2+Z_0 \dot{I}_2\right) \\A_2=\frac{1}{2}\left(\dot{U}_2-Z_0 \dot{I}_2\right)\end{array}\right.\]</span></p></li><li><p>始端条件</p><p>即已知<span class="math inline">\(\dot{U}_1,\dot{I}_1\)</span>。则有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{1}{2}\left(\dot{U}_1+Z_0 \dot{I}_1\right) \\A_2=\frac{1}{2}\left(\dot{U}_1-Z_0 \dot{I}_1\right)\end{array}\right.\]</span></p></li><li><p>波源阻抗条件</p><p>即已知<span class="math inline">\(\dot{E}_g,Z_g,Z_L\)</span>，有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{Z_0 \dot{E}_{\mathrm{g}} \mathrm{e}^{-\gamma l}}{Z_{\mathrm{g}}+Z_0} \\A_2=\frac{Z_0 \dot{E}_{\mathrm{g}} \mathrm{e}^{-\gamma l}}{Z_{\mathrm{g}}+Z_0} \Gamma_{\mathrm{L}}\end{array}\right.\]</span></p></li></ol><h3 id="传输线上的参量">传输线上的参量</h3><h4 id="一次特征参量">一次特征参量</h4><p><span class="math inline">\(R_0\)</span>分布电阻，<span class="math inline">\(L_0\)</span>分布电感，<span class="math inline">\(G_0\)</span>分布电导，<span class="math inline">\(C_0\)</span>分布电容</p><h4 id="二次特征参量">二次特征参量</h4><p>二次特征参量也叫传播特性参量，其中最主要的就是传播常数<span class="math inline">\(\gamma\)</span>和特征阻抗<span class="math inline">\(Z_0\)</span>，具体的计算式已经在上面给出了。还有一些其它的特征参量，可以由上面的导出。</p><ol type="1"><li><p>衰减常数和相位常数</p><p>若<span class="math inline">\(\gamma=\alpha+j\beta\)</span>，那么<span class="math inline">\(\alpha\)</span>叫做衰减常数，表示经过单位长度行波幅度衰减<span class="math inline">\(e^{-\alpha}\)</span>，<span class="math inline">\(\beta\)</span>叫做相位常数，表示单位长度行波滞后的幅度。对于无耗传输线，有： <span class="math display">\[\left\{\begin{array}{l}\gamma=\mathrm{j} \omega \sqrt{L_0 C_0} \\\alpha=0 \\\beta=\omega \sqrt{L_0 C_0}\end{array}\right.\]</span></p></li><li><p>相速度和相波长</p><p>相速度就是等相位面移动的速度，相波长就是等相位面在一个周期内移动的距离。有： <span class="math display">\[v_p=\frac \omega \beta\]</span></p><p><span class="math display">\[\lambda_p=\frac{2\pi}\beta\]</span></p><p>对于均匀无耗传输线，有： <span class="math display">\[v_p=\frac{c}{\sqrt{\varepsilon_r\mu_r}}\]</span></p><p><span class="math display">\[\lambda_p=\frac{\lambda_0}{\sqrt{\varepsilon_r\mu_r}}\]</span></p></li><li><p>特性阻抗</p><p>特性阻抗具有如下特点：</p><ul><li>同一时刻，传输线上行波电压不同，但是传输线上各点的入射波电压和入射波之比是一个定值，这个值就是特性阻抗</li><li>传输线特性阻抗仅取决于传输线的结构，和其长度无关</li><li>特性阻抗描述入射（或反射）波电压和电流的幅度相位关系。</li></ul></li></ol><h4 id="工作状态参量">工作状态参量</h4><ol type="1"><li><p>反射系数</p><p>定义电压反射系数： <span class="math display">\[\Gamma_U(z)=\frac{\dot U_r(z)}{\dot U_i(z)}\]</span> 电流反射系数可类似定义，但我们一般都用电压反射系数。</p><p>对于无耗传输线，有： <span class="math display">\[\Gamma_{U}(z)=\frac{A_2}{A_1} \mathrm{e}^{-\mathrm{j} 2 \beta z}\]</span> 若终端负载处反射系数为<span class="math inline">\(\Gamma_2\)</span>，则有： <span class="math display">\[\Gamma(z)=\Gamma_2 \mathrm{e}^{-j 2 \beta z}=\left|\Gamma_2\right| \mathrm{e}^{\mathrm{j}\left(\phi_2-2 \beta_2\right)}=\left|\Gamma_2\right| \mathrm{e}^{\mathrm{j} \phi}\]</span> 其中<span class="math inline">\(\phi_2\)</span>是<span class="math inline">\(\Gamma_2\)</span>的相角。</p></li><li><p>输入阻抗</p><p>输入阻抗是传输线上任何一点的总电压和总电流的比，即： <span class="math display">\[Z_{\mathrm{in}}(z)=\frac{\dot{U}(z)}{\dot{I}(z)}\]</span> 输入阻抗和线上反射系数可以互相转化： <span class="math display">\[Z_{in}(z)=Z_0 \frac{1+\Gamma(z)}{1-\Gamma(z)}\]</span></p><p><span class="math display">\[\Gamma(z)=\frac{Z_{\mathrm{in}}(z)-Z_0}{Z_{\mathrm{in}}(z)+Z_0}\]</span></p><p>需要提醒：上面两个式子对终端也适用，也就是说如果终端直接接入阻抗<span class="math inline">\(Z_L\)</span>，是可以直接计算终端反射系数<span class="math inline">\(\Gamma_2\)</span>的。进一步，有： <span class="math display">\[Z_{\mathrm{in}}(z)=Z_0 \frac{1+\Gamma_2 \mathrm{e}^{-\mathrm{j} 2 \beta z}}{1-\Gamma_2 \mathrm{e}^{-j 2 \beta z}}=Z_0 \frac{Z_{\mathrm{L}}+\mathrm{j} Z_0 \tan \beta z}{Z_0+\mathrm{j} Z_{\mathrm{L}} \tan \beta z}\]</span> 当然，我感觉这个用史密斯圆图更好算。</p></li></ol><h4 id="驻波参量">驻波参量</h4><p>当<span class="math inline">\(Z_L=Z_0\)</span>时，称传输线阻抗匹配，否则称传输线失配。我们用驻波参量来衡量失配程度。</p><ol type="1"><li><p>驻波比SWR（<span class="math inline">\(\rho\)</span>）</p><p>驻波比的定义是沿线电压最大值和最小值之比，它和反射系数是一一对应的。对于无耗传输线，有： <span class="math display">\[\begin{gathered}\rho=\frac{1+|\Gamma|}{1-|\Gamma|}=\frac{1+\left|\Gamma_2\right|}{1-\left|\Gamma_2\right|} \\|\Gamma|=\left|\Gamma_2\right|=\frac{\rho-1}{\rho+1}\end{gathered}\]</span> 当完全匹配时，驻波比为1，沿线电压最大值和最小值相等，<span class="math inline">\(\Gamma_2=0\)</span>。</p></li><li><p>行波系数<span class="math inline">\(K\)</span></p><p>就是驻波比的倒数。</p></li><li><p>驻波相位<span class="math inline">\(l_{min}\)</span></p><p>离终端最近的电压波节点到终端的距离</p></li></ol><p>无耗传输线上的波有三种传输模式：</p><ol type="1"><li><span class="math inline">\(Z_L=Z_0\)</span>，此时阻抗匹配，波形是行波</li><li><span class="math inline">\(Z_L\)</span> 开路、短路或是纯虚数，此时传输线处于全反射状态，波形是纯驻波。</li><li>其它情况，传输线处于部分反射状态，波形是行驻波。</li></ol><h3 id="史密斯圆图">史密斯圆图</h3><h4 id="归一化阻抗和导纳">归一化阻抗和导纳</h4><p>定义归一化阻抗： <span class="math display">\[\bar{Z}_L=\frac{Z_L}{Z_0}\]</span> 则有： <span class="math display">\[\bar{Z}_{\mathrm{in}}(z)=\frac{\bar{Z}_{\mathrm{L}}+\mathrm{j} \tan \beta z}{1+\mathrm{j} \bar{Z}_L \tan \beta z}\]</span> 再定义归一化电标度（电尺寸）： <span class="math display">\[\bar{z}=\frac z\lambda\]</span> 则有： <span class="math display">\[\bar{Z}_{\mathrm{in}}(\bar{z})=\frac{\bar{Z}_{\mathrm{L}}+\mathrm{j} \tan 2 \pi \bar{z}}{1+\mathrm{j} \bar{Z}_{\mathrm{L}} \tan 2 \pi \bar{z}}\]</span> 表达式中不再包含和传输线结构有关的参量，于是此表达式可以适用于任意传输线的分析。</p><p>由阻抗和反射系数的一对一转换关系： <span class="math display">\[\Gamma(\bar{z})=\frac{\bar{Z}_{\mathrm{in}}(\bar{z})-1}{\bar{Z}_{\mathrm{in}}(\bar{z})+1}\]</span> #### 阻抗圆图</p><p>把<span class="math inline">\(Z\)</span>平面转换到<span class="math inline">\(\Gamma\)</span>平面，可得阻抗圆图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211231047660.png" alt="image-20221123104650102" /><figcaption aria-hidden="true">image-20221123104650102</figcaption></figure><p>图中有<strong>三个关键点</strong>：</p><ol type="1"><li>匹配点：<span class="math inline">\(\Gamma (0,0)\)</span>点，对应<span class="math inline">\(Z(1,0)\)</span>点，此时有<span class="math inline">\(Z_L=Z_0\)</span>，传输线匹配，驻波比为1</li><li>开路点：<span class="math inline">\(\Gamma(1,0)\)</span>点，对应<span class="math inline">\(Z(\infty,\infty)\)</span>点，此时<span class="math inline">\(Z_L=\infty\)</span>，传输线处于开路状态，驻波比无穷大</li><li>短路点：<span class="math inline">\(\Gamma(-1,0)\)</span>点，对应<span class="math inline">\(Z(0,0)\)</span>点，此时<span class="math inline">\(Z_L=0\)</span>，传输线短路，驻波比无穷大</li></ol><p><strong>三个圆：</strong></p><ol type="1"><li><p>等电抗圆：指的是圆心在直线<span class="math inline">\(x=1\)</span>上的那些圆，在一个等点抗圆上的点有相等的电抗。在上半平面的电抗大于零，叫做感性；在下半平面的电抗小于零，叫做容性。其圆心在<span class="math inline">\((1,1/\bar X)\)</span>，半径为<span class="math inline">\(|1/\bar X|\)</span>。<span class="math inline">\(X\)</span>越小，等电抗圆越大。当<span class="math inline">\(X=0\)</span>时变成横轴，当<span class="math inline">\(X\to \infty\)</span>时变成开路点。</p></li><li><p>等电阻圆：指的是圆心在实轴（横轴）上的那些圆，在一个等电阻圆上的点有相等的电阻。其圆心为<span class="math inline">\((\bar R/(\bar R+1),0)\)</span>，半径为<span class="math inline">\(1/(\bar R+1)\)</span>。<span class="math inline">\(R\)</span>越小，等电阻圆越大。</p></li><li><p>等反射系数圆（也叫等驻波比圆）：指的是圆心在<span class="math inline">\(\Gamma (0,0)\)</span>的圆。圆的半径和反射系数以及驻波比有一一对应关系。当反射系数为正实数（即在实轴正半轴）时，对应电压波腹点，于是实轴正半轴叫做电压波腹线；同理，实轴负半轴叫做电压波节线。</p><p>当在传输线上移动<span class="math inline">\(\Delta z=\lambda/2\)</span>时，对应沿等反射系数圆旋转一圈，方向为“源顺负逆”。</p></li></ol><p>于是，在圆图中任意确定一个点，总能找到一个等电抗圆和一个等电阻圆与之对应，这样一来，我们就能读出这个点的阻抗。要确定传输线上其它点的阻抗，只需要按照源顺负逆的规则，在等反射系数圆上进行移动即可。</p><h4 id="导纳圆图">导纳圆图</h4><p>把阻抗圆图以圆心为中心旋转180度就是导纳圆图。在阻抗圆图中确定一点，绕等反射系数圆旋转180度，反射系数变为<span class="math inline">\(-\Gamma\)</span>。则<span class="math inline">\(-\Gamma\)</span>处在阻抗圆图中读出的归一化阻抗值就是原位置<span class="math inline">\(\Gamma\)</span>处的导纳值。</p><p>旋转时，波节线、波腹线、短路点、开路点随之旋转。但是“源顺负逆”的准则不变。</p><p>在导纳圆图上确定归一化导纳时，有关系： <span class="math display">\[\bar Y=Y\cdot Z_0\]</span></p><h3 id="阻抗匹配技术">阻抗匹配技术</h3><p>阻抗匹配包含两种含义，其一是信号源的匹配，即想办法从信号源中获得最大的功率并消除信号源的反射；其二是负载的匹配，即想办法消除反射。阻抗匹配有三种：信号源阻抗匹配，负载阻抗匹配，共轭阻抗匹配。其重要性有：</p><ol type="1"><li><p>负载匹配时功率最大，功率损耗最小</p></li><li><p>阻抗匹配可以改善系统信噪比</p></li><li><p>功率分配网络中的阻抗匹配可以吉昂蒂幅度和相位的误差</p></li><li><p>保持信号源工作稳定性</p></li><li><p>提高传输线 的功率容量 <span class="math display">\[P_{br}=\frac 12\frac{U^2_{br}}{Z_0}K\]</span></p></li></ol><h4 id="lambda4匹配"><span class="math inline">\(\lambda/4\)</span>匹配</h4><p>是一段特征阻抗为<span class="math inline">\(Z_{01}\)</span>，长度为<span class="math inline">\(\lambda/4\)</span>的传输线。如果这段传输线末端接<span class="math inline">\(R_L\)</span>阻抗，那么可以计算出，这部分的输入阻抗为： <span class="math display">\[Z_{in}=\frac{Z_{01}^2}{R_L}=Z_0\]</span></p><blockquote><p>推导过程：由公式 <span class="math display">\[Z_{\mathrm{in}}(z)=Z_0 \frac{1+\Gamma_2 \mathrm{e}^{-\mathrm{j} 2 \beta z}}{1-\Gamma_2 \mathrm{e}^{-j 2 \beta z}}=Z_0 \frac{Z_{\mathrm{L}}+\mathrm{j} Z_0 \tan \beta z}{Z_0+\mathrm{j} Z_{\mathrm{L}} \tan \beta z}\]</span> 把<span class="math inline">\(\beta z=2\pi/4=\pi/2\)</span>代入，得<span class="math inline">\(\tan \beta z=\infty\)</span>，此时可以把<span class="math inline">\(Z_L,Z_0\)</span>项略去，并把<span class="math inline">\(j\tan \beta z\)</span>项约分掉，就得： <span class="math display">\[Z_{in}=\frac{Z_0^2}{Z_L}\]</span></p></blockquote><p>这个结论也叫“<span class="math inline">\(\lambda/4\)</span>传输线阻抗变换特性”，需要记住。</p><p>得 <span class="math display">\[Z_{01}=\sqrt{Z_0R_L}\]</span> 如果负载不是纯电阻，那么可以把匹配器接在电压波腹点<span class="math inline">\(l_{max}\)</span>或电压波节点<span class="math inline">\(l_{min}\)</span>。此时，匹配的目的是要把输入阻抗变成纯电阻。匹配时，首先确定负载所在的等反射系数（等驻波比）圆，然后在这个圆上确定波节点/波腹点，读出对应的电阻值。负载的点和波节/波腹点的电标度的差决定了<span class="math inline">\(\lambda/4\)</span>传输线的位置（这个位置指的是从负载到<span class="math inline">\(\lambda/4\)</span>传输线最近的边缘的距离），在这里放置<span class="math inline">\(\lambda/4\)</span>传输线，其到负载之间的部分（负载+原传输线）等效为纯阻。然后，再把这个纯阻（刚刚读出来的）带入前面的方程中，计算<span class="math inline">\(\lambda/4\)</span>传输线所需的阻抗。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212202328429.png" alt="四分之一波长匹配器匹配过程" /><figcaption aria-hidden="true">四分之一波长匹配器匹配过程</figcaption></figure><h4 id="单支节匹配">单支节匹配</h4><p>单支节匹配是在传输线上并联一根传输线枝节，通过调节枝节的位置<span class="math inline">\(d\)</span>和长度<span class="math inline">\(l\)</span>，抵消阻抗的虚部，从而实现匹配。其步骤为：</p><ol type="1"><li><p>在史密斯圆图上画出归一化负载阻抗<span class="math inline">\(\bar Z_L\)</span>的位置，把它旋转180度，画出归一化负载导纳<span class="math inline">\(\bar Y_L\)</span>的位置，把导纳的位置记作<span class="math inline">\(A\)</span>，电标度为<span class="math inline">\(\bar l_A\)</span></p></li><li><p>首先来求<span class="math inline">\(d\)</span>：从<span class="math inline">\(A\)</span>点开始，沿着等反射系数圆顺时针旋转，直到和可匹配圆（<span class="math inline">\(\bar G=1\)</span>）相交，交点记作<span class="math inline">\(C\)</span>，对应导纳<span class="math inline">\(\bar Y_1=1+j\bar B\)</span>，则在此位置并联<span class="math inline">\(\bar Y_2=-jB\)</span>的电纳即可实现匹配。设<span class="math inline">\(C\)</span>点的电标度为<span class="math inline">\(\bar l_C\)</span>，则有： <span class="math display">\[d=(\bar l_C-\bar l_A)\lambda\]</span></p></li><li><p>接下来求<span class="math inline">\(l\)</span>：找到短路点（圆图右侧端点）位置，其电标度为0.25.从短路点开始，顺时针沿着全反射圆移动到电纳值为<span class="math inline">\(-\bar B\)</span>的地方，记作<span class="math inline">\(E\)</span>点。<span class="math inline">\(E\)</span>点的电标度为<span class="math inline">\(\bar l_E\)</span>，则有： <span class="math display">\[l=(\bar l_E-0.25)\lambda\]</span></p></li></ol><p>以上过程可由如下图示描述，不同颜色表示不同的步骤：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212201140012.png" alt="单枝节匹配过程" /><figcaption aria-hidden="true">单枝节匹配过程</figcaption></figure><h4 id="双支节匹配">双支节匹配</h4><p>在单支节匹配中，我们移动枝节的位置，来寻找归一化电导值为1的参考面。那么有没有别的办法得到这个面呢？有：我们在枝节和负载中间附加一个纯电纳即可。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212210021630.png" alt="双支节匹配示意图" /><figcaption aria-hidden="true">双支节匹配示意图</figcaption></figure><p>如图所示，这两个枝节的位置是固定的，我们首先要调节<span class="math inline">\(l_1\)</span>的长度，让<span class="math inline">\(2\)</span>号支节所在的参考面的归一化电导值为1，然后再调节<span class="math inline">\(l_2\)</span>的长度，以达到匹配效果。</p><p>以下，记：</p><table><thead><tr class="header"><th>名称</th><th>含义</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\bar Y_1\)</span></td><td><span class="math inline">\(d_1\)</span>段传输线（含负载）归一化输入导纳</td><td></td></tr><tr class="even"><td><span class="math inline">\(\bar Y_2\)</span></td><td><span class="math inline">\(1\)</span>号支节始端归一化输入导纳</td><td>纯纳</td></tr><tr class="odd"><td><span class="math inline">\(\bar Y_3\)</span></td><td><span class="math inline">\(d_2\)</span>段传输线始端归一化输入导纳</td><td>在可匹配圆上</td></tr><tr class="even"><td><span class="math inline">\(\bar Y_4\)</span></td><td><span class="math inline">\(2\)</span>号支节始端归一化输入导纳</td><td>纯纳</td></tr><tr class="odd"><td><span class="math inline">\(\bar Y_B\)</span></td><td>整个系统最前端等效负载归一化导纳</td><td><span class="math inline">\(Y_B=Y_3+Y_4\)</span></td></tr><tr class="even"><td><span class="math inline">\(\bar Y_A\)</span></td><td><span class="math inline">\(d_2\)</span>段传输线终端等效负载归一化导纳</td><td><span class="math inline">\(Y_A=Y_1+Y_2\)</span></td></tr></tbody></table><p>于是，我们知道：<span class="math inline">\(Y_3\)</span>在可匹配圆上，由于<span class="math inline">\(d_2\)</span>传输线会对于每个<span class="math inline">\(Y_3\)</span>对应的点有一个绕着圆心旋转的作用，所以我们把可匹配圆也绕着圆心旋转<span class="math inline">\(\bar d_2=d_2/\lambda\)</span>，称作“辅助圆”。双支节匹配的过程是：</p><ol type="1"><li><p>把可匹配圆绕着单位圆的圆心旋转<span class="math inline">\(\bar d_2=d_2/\lambda\)</span>，画出辅助圆（深绿色）</p></li><li><p>确定<span class="math inline">\(\bar Z_L,\bar Y_L\)</span>位置（鲜红色）</p></li><li><p>从<span class="math inline">\(\bar Y_L\)</span>开始，沿其所在的等反射系数圆顺时针旋转<span class="math inline">\(\bar d_1\)</span>，得到<span class="math inline">\(\bar Y_1\)</span>（橙色）</p></li><li><p>因为<span class="math inline">\(\bar Y_2\)</span>是纯纳，所以<span class="math inline">\(\bar Y_A\)</span>和<span class="math inline">\(\bar Y_1\)</span>在一个等电导圆上。画出<span class="math inline">\(Y_1\)</span>所在的等电导圆<span class="math inline">\(G=G_1\)</span>，这个等电导圆和辅助圆的交点就是<span class="math inline">\(\bar Y_A\)</span>。由<span class="math inline">\(\bar Y_2=\bar Y_A-\bar Y_1\)</span>计算出<span class="math inline">\(\bar Y_2\)</span>，绘制<span class="math inline">\(\bar Y_2\)</span>，读出<span class="math inline">\(\bar l_2\)</span>的电标度，有（鲜绿色）： <span class="math display">\[\bar l_1=(\bar l_{Y_2}-0.25)\]</span></p></li><li><p>画出<span class="math inline">\(\bar Y_A\)</span>所在的等反射系数圆，交可匹配圆<span class="math inline">\(G=1\)</span>于<span class="math inline">\(\bar Y_3\)</span>点。读出<span class="math inline">\(\bar Y_3=1+j\bar B_3\)</span>.（蓝色）</p></li><li><p>画出<span class="math inline">\(\bar Y_4=-jB_3\)</span>，有（紫色）： <span class="math display">\[\bar l_2=(\bar l_{Y_4}-0.25)\]</span></p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212210047719.png" alt="双支节匹配过程" /><figcaption aria-hidden="true">双支节匹配过程</figcaption></figure><h2 id="波导理论">波导理论</h2><h3 id="导行波的传播特性">导行波的传播特性</h3><p>导行波的场量都有因子<span class="math inline">\(e^{-\gamma z}\)</span>，其中<span class="math inline">\(\gamma=\alpha+j\beta\)</span>。由麦克斯韦方程和边界条件推导（意思就是我也不想推导）可知： <span class="math display">\[\gamma=k^2_c-k^2\]</span> 其中<span class="math inline">\(k=\omega\sqrt{\mu\varepsilon}\)</span>为电磁波在无限媒质中的波数，它由波的频率和传播介质决定。<span class="math inline">\(k_c\)</span>叫波导的截止波数，它由波导系统横截面的边界条件决定，这两个“波数”都是实数。于是，随着频率的不同，<span class="math inline">\(\gamma\)</span>有以下三种情况：</p><ul><li><span class="math inline">\(\gamma^2&lt;0\)</span>，此时有<span class="math inline">\(\gamma=j\beta\)</span>，因为场量不随着距离增长而衰减，称为传输状态。</li><li><span class="math inline">\(\gamma^2&gt;0\)</span>，此时有<span class="math inline">\(\gamma=\alpha\)</span>，此时场量随着距离增长而指数衰减，称为截止状态。</li><li><span class="math inline">\(\gamma^2=0\)</span>，这个叫临界状态，分析时认为不属于传输状态，波不能传输。</li></ul><p>既然有了“截止波数”<span class="math inline">\(k_c\)</span>的定义，我们也可以顺势定义出截止频率、截止波长：</p><ul><li><p>截止频率<span class="math inline">\(f_c\)</span> <span class="math display">\[f_c=\frac{k_c}{2\pi\sqrt{\mu\varepsilon}}\]</span></p></li><li><p>截止波长<span class="math inline">\(\lambda_c\)</span> <span class="math display">\[\lambda_c=\frac{v}{f_c}=\frac{2\pi}{k_c}\]</span> 其中<span class="math inline">\(v\)</span>是理想介质<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="就是不导电的介质，不是自由空间。">[1]</span></a></sup>中的光速。</p></li></ul><p>于是，导波系统传输TE波或TM波的条件是： <span class="math display">\[f&gt;f_c\ \text{or}\ \lambda&lt;\lambda_c\]</span> 我们进一步分析传输状态时的导行波。理想导波系统中的相波长<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="等相面在一个周期内移动的距离">[2]</span></a></sup>称为波导波长，记作<span class="math inline">\(\lambda_g\)</span>。根据相波长和相位常数的定义，有： <span class="math display">\[\beta=\frac{2\pi}{\lambda_g}\]</span> 我们可以计算出，对于相位常数<span class="math inline">\(\beta\)</span>，有： <span class="math display">\[\beta=\sqrt{k^2-k_c^2}=\frac{2\pi}\lambda\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}\]</span> 于是，相波长为 <span class="math display">\[\lambda_g=\frac{\lambda}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}=\frac{\lambda_0/\sqrt{\mu_r\varepsilon_r}}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}\]</span> 根据相速度的一般公式<span class="math inline">\(v_p=\omega/\beta\)</span>，相速度为： <span class="math display">\[v_p=\frac{c/\sqrt{\mu_r\varepsilon_r}}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}\]</span> 根据群速度的一般公式<span class="math inline">\(v_g=d\omega/d\beta\)</span>，将<span class="math inline">\(\beta=\sqrt{k^2-k_c^2}\)</span>中的<span class="math inline">\(k\)</span>用<span class="math inline">\(\omega\sqrt{\mu\varepsilon}\)</span>表示，有： <span class="math display">\[v_g=v\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}\]</span> 以上就是会经常用到的一些传播特性参量。</p><h3 id="导波模式">导波模式</h3><h4 id="矩形波导">矩形波导</h4><p>导通模式下矩形波导中TM波的通解为：</p><p>【一大坨式子，里面有两个参量<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>】</p><p>这里的<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>就是波导边界条件决定的正整数，称作波指数。<span class="math inline">\(m\)</span>表示沿着波导长边分布的半驻波个数，<span class="math inline">\(n\)</span>表示沿着波导短边分布的半驻波个数。<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都不能是零。每一个<span class="math inline">\((m,n)\)</span>都对应着一种电磁场分布，即一种波形，或者说，模式，记作<span class="math inline">\(TM_{mn}\)</span></p><p>导通模式下矩形波导中TE波的通解为：</p><p>【一大坨式子，里面有两个参量<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>】</p><p>这里的<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都是自然数，但是不能同时为零。每一个<span class="math inline">\((m,n)\)</span>都对应着一种模式，记作<span class="math inline">\(TE_{mn}\)</span></p><p>将各种<span class="math inline">\(TM_{mn}\)</span>和<span class="math inline">\(TE_{mn}\)</span>相互叠加，就能表示出矩形波导中所有可能存在的波形。那么怎么知道某种模式是否存在呢？我们有： <span class="math display">\[k_c^2=\left(\frac{m\pi}{a}\right)^2+\left(\frac{n\pi}{b}\right)^2\]</span> 也就是 <span class="math display">\[\lambda_c=\frac{2\pi}{k_c}=\frac{2}{\sqrt{\left(\frac{m\pi}{a}\right)^2+\left(\frac{n\pi}{b}\right)^2}}\]</span> 考察波的<span class="math inline">\(k\)</span>(由频率和介质决定)，当满足传输条件<span class="math inline">\(k&gt;k_c\)</span>或<span class="math inline">\(\lambda&lt;\lambda_c\)</span>时，就存在对应的模式。观察这个式子，我们发现当<span class="math inline">\(m,n\)</span>对应相等时，TM波和TE波有着相同的截止波数，我们把这样的现象叫做模式简并<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="严格的定义是：模式简并：截止波数相同但是场分布不同的现象">[3]</span></a></sup>。</p><p>通常，我们称截止波数最小（截止波长最大）的模式为主模，也叫基本模式或者最低模式。矩形波导的主模是<span class="math inline">\(TE_{10}\)</span>模。</p><p>矩形波导的功率容量（最大传输功率）如下： <span class="math display">\[P_{max}=\frac{ab}{480\pi}E^2_{br}\sqrt{1-\left(\frac{\lambda}{2a}\right)^2}\]</span> 其中<span class="math inline">\(E_{br}\)</span>是波导内媒质的击穿电压。</p><h4 id="圆波导">圆波导</h4><p>圆波导的分析的大概形状和矩形波导是类似的，也有TE、TM波。</p><p>TM通解为：</p><p>【一大坨式子，里面有个参量<span class="math inline">\(u_{ni}\)</span>】</p><p>其中<span class="math inline">\(u_{ni}\)</span>表示第一类<span class="math inline">\(n\)</span>阶贝塞尔函数的第<span class="math inline">\(i\)</span>个零点。<span class="math inline">\((n,i)\)</span>代表了一个TM波的模式，记作<span class="math inline">\(TM_{ni}^\circ\)</span></p><p>TE通解为：</p><p>【一大坨式子，里面有个参量<span class="math inline">\(v_{ni}\)</span>】</p><p>其中<span class="math inline">\(v_{ni}\)</span>表示第一类<span class="math inline">\(n\)</span>阶贝塞尔函数的导数的第<span class="math inline">\(i\)</span>个零点。<span class="math inline">\((n,i)\)</span>代表了一个TE波的模式，记作<span class="math inline">\(TE_{ni}^\circ\)</span></p><p>圆波导的截止波长一般查表给出。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211072249964.png" alt="截止波数表" /><figcaption aria-hidden="true">截止波数表</figcaption></figure><p>在圆波导中，存在两种模式简并。第一种是E-H简并，因为对于第一类贝塞尔函数有<span class="math inline">\(J&#39;_0(x)=-J_1(x)\)</span>，所以<span class="math inline">\(J&#39;_0\)</span>和<span class="math inline">\(J_1\)</span>的零点相等，因此<span class="math inline">\(H_{0i}\)</span>和<span class="math inline">\(E_{1i}\)</span>简并。第二种叫极化简并，是因为坐标<span class="math inline">\(\varphi\)</span>的完全对称性引起的。在圆波导中，电磁场的横向分布存在着<span class="math inline">\(\cos n\varphi\)</span>和<span class="math inline">\(\sin n\varphi\)</span>两种形式，它们具有相同的截止波长，只是极化方向旋转90度。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>就是不导电的介质，不是自由空间。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>等相面在一个周期内移动的距离 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>严格的定义是：模式简并：截止波数相同但是场分布不同的现象 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·变换之章</title>
    <link href="/2022/10/26/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/26/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="第二章离散时间信号与系统">第二章：离散时间信号与系统</h2><h3 id="离数时间序列">离数时间序列</h3><p>序列的表示方式略。</p><h4 id="序列的分类">序列的分类</h4><p>有限长度/无限长度序列、左/右/双边序列、因果/非因果序列、实/复数序列的定义很显然，就是字面意思，略。</p><ul><li><p>周期序列和非周期序列</p><p>周期序列的定义： <span class="math display">\[\exists N\neq 0\ \forall n\ x[n]=x[n+N]\]</span> 满足上面式子的序列称为周期序列，否则称为非周期序列。需要提醒的是：如果一个序列满足上面的式子，它一定是无限长的双边序列，也就是<span class="math inline">\(n\)</span>从负无穷取遍正无穷。例如：<span class="math inline">\(x[n]=\sin (\pi n/5)\)</span>是周期序列，但<span class="math inline">\(x[n]=u[n]\sin(\pi n/5)\)</span>不是周期序列。</p></li><li><p>能量序列和功率序列</p><p>如果对序列<span class="math inline">\(x[n]\)</span>有： <span class="math display">\[E=\sum_{n=-\infty}^{\infty}\lvert x[n]\rvert^2&lt;\infty\]</span> 称该序列为能量有限序列，简称能量序列。对于能量无限序列，如果另有： <span class="math display">\[P=\lim_{N\to \infty}\frac{1}{2N+1}\sum_{n=-N}^N \lvert x[n] \rvert ^2&lt;\infty\]</span> 则称该序列为功率有限序列，简称功率序列。需要注意的是：周期序列一般来说都是功率序列。周期序列的功率为： <span class="math display">\[P=\lim_{N\to \infty} \frac{1}{N} \sum_{n=n}^{N-1}\lvert x[n]\rvert^2\]</span></p></li></ul><h4 id="常见序列">常见序列</h4><p>矩形序列、脉冲序列、阶跃序列、实指数序列略。</p><ul><li><p>复指数序列</p><p>对于指数序列 <span class="math display">\[x[n]=A\alpha^n\]</span> 如果<span class="math inline">\(A,\alpha\)</span>是复数，那么这个序列是复指数序列。若有<span class="math inline">\(A=|A|\angle \varphi,\alpha=|\alpha|\angle \omega_0\)</span>，则复指数序列也可以表示成： <span class="math display">\[x[n]=|A||\alpha|^n\exp [j(\omega_0n+\varphi)]\]</span> 复指数序列表现为一列不断收缩或者扩张的螺旋。特别地，当<span class="math inline">\(|\alpha|=1\)</span>时，复指数序列的幅值保持不变。此时，如果满足 <span class="math display">\[\frac {\omega_0}{2N}\in \mathbb Q\]</span> 则复指数序列是周期序列。其周期为： <span class="math display">\[N=\frac{2\pi m}{\omega_0}\in \mathbb Z^+\]</span> 其中<span class="math inline">\(m\)</span>是能让<span class="math inline">\(N\)</span>成为正整数的整数。</p><blockquote><p>【例】计算以下序列的最小正周期： <span class="math display">\[x[n]=e^{j\frac {6\pi}{31}n}\]</span> 【解】由于 <span class="math display">\[N=\frac{2\pi m}{\omega}=\frac{31}{3}m\]</span> 取<span class="math inline">\(m=3\)</span>，得最小正周期为<span class="math inline">\(N=31\)</span></p></blockquote><p>无论复指数序列是不是周期序列，<span class="math inline">\(\omega_0\)</span>都称作这个序列的数字频率。对于连续时间信号来说，频率越大，信号震荡得越快。但是对于复指数序列来说，<span class="math inline">\(\omega_0\)</span>从<span class="math inline">\(0\)</span>增加到<span class="math inline">\(\pi\)</span>时，振荡得越来越快；从<span class="math inline">\(\pi\)</span>增加到<span class="math inline">\(2\pi\)</span>时，振荡得越来越慢，并且以<span class="math inline">\(2\pi\)</span>为周期。</p><p>这初看有些不好理解，但是实际上是因为复指数序列是离散时间序列，时间最细的粒度是<span class="math inline">\(1\)</span>（不同于连续时间序列的时间定义在连续统上，时间最细的粒度是无穷小）。复指数序列振荡最快的情形，可以想象这样的序列： <span class="math display">\[x[n]=Ae^{j\pi n}\]</span> 也就是<span class="math inline">\(x[n]=A(-1)^n\)</span>，它振荡得再快，也就是每过1个时间变一下符号而已嘛。</p><p>当<span class="math inline">\(\omega_0&gt;0\)</span>时，表示在复平面内逆时针旋转，否则为顺时针旋转。</p></li></ul><h3 id="离散时间系统">离散时间系统</h3><p>和连续时间系统的理论差不多，有线性、时不变、因果、记忆、稳定等等。</p><p>对于线性时不变<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="需要注意的是，我们平常做题见到的很多系统都不是线性时不变系统。例如：如果进行了压扩变换，那么系统往往是时变的。我们平常所进行的“调幅”(即频率搬移)乘以一个$\cos$，由于产生了新的频率分量，也不是线性时不变的。">[1]</span></a></sup>系统，同样可以用卷积表示。即：如果<strong>线性时不变系统</strong>的单位脉冲响应是<span class="math inline">\(h[n]\)</span>，对于任意输入序列<span class="math inline">\(x[n]\)</span>，有响应： <span class="math display">\[y[n]=\sum_{k=-\infty}^\infty x[k]h[n-k]=x[n]*h[n]\]</span></p><p>卷积有交换律、结合律，对加法有左分配律。</p><p>LTI系统是因果系统等价于其单位脉冲响应是因果序列。</p><p>LTI系统稳定等价于其单位脉冲响应绝对可和，即： <span class="math display">\[S=\sum_{k=-\infty}^\infty \lvert h[k] \rvert &lt; \infty\]</span></p><ul><li><p>线性常系数差分方程</p><p>差分方程的概念、表示方法和解法略，在之前的“Z变换”一文中有说明。</p><p>线性系统的输入序列<span class="math inline">\(x[n]\equiv 0\)</span>时，有输出序列<span class="math inline">\(y[n]\equiv 0\)</span>。这个结论是显然成立的：如果对于<span class="math inline">\(x[n]\equiv 0\)</span>的输出不全为零的话，设<span class="math inline">\(a[n]\)</span>单独输入时的输出为<span class="math inline">\(b[n]\)</span>，那么对于<span class="math inline">\(a[n]+x[n]\)</span>的输入，输出将为<span class="math inline">\(b[n]+y[n]\)</span>，可是<span class="math inline">\(a[n]+x[n]=a[n]\)</span>呀，<span class="math inline">\(y[n]\)</span>不全为零，那么系统对于同样的输入不就有两个不同输出了吗？这显然是荒诞的。</p><blockquote><p>【例】对于下列方程描述的系统： <span class="math display">\[y[n]-ay[n-1]=x[n]\]</span> 初始条件为<span class="math inline">\(y[-1]=1\)</span>，那么这是线性系统吗？</p><p>【解】对于全零输入，其输出序列为<span class="math inline">\(y[n]=a^{n+1}\)</span>，不全为零，因此不是线性系统。</p></blockquote><p>这道例题说明：不是一切用常系数线性差分方程表示的系统都是线性系统，更不用说线性时不变了。事实上，如果要系统是因果的LTI系统，必须要满足“初始松弛”的条件，也就是初始状态为零。</p></li></ul><h2 id="dtftdfs和z变换">DTFT、DFS和Z变换</h2><h3 id="离散时间傅里叶变换dtft">离散时间傅里叶变换(DTFT)</h3><p>首先，我们可以回忆一下连续时间信号的傅里叶变换： <span class="math display">\[\begin{align}X(j\Omega)=\int_{-\infty}^\infty x(t)e^{-j\Omega t}\mathbf dt\\x(t)=\frac{1}{2\pi}\int_{-\infty}^\infty X(j\Omega)e^{j\Omega t}\mathbf d\Omega\end{align}\]</span></p><h4 id="dtft的定义">DTFT的定义</h4><p>和连续时间傅里叶变换类似，DTFT是要把序列<span class="math inline">\(x[n]\)</span>表示序列<span class="math inline">\(e^{j\omega n }\mathbf d\omega\)</span>的线性组合： <span class="math display">\[x[n]=\frac{1}{2\pi}\int_{-\infty}^\infty X(e^{j\omega})e^{j\omega n}d\omega\]</span> 则权函数可以表示为： <span class="math display">\[X(e^{j\omega})=\sum_{n=-\infty}^\infty x[n]e^{-j\omega n}\]</span> 这就是离散时间傅里叶变换的性质。需要强调的是：<span class="math inline">\(X(e^{j\omega})\)</span>是<span class="math inline">\(\omega\)</span>的连续函数，称为频谱密度函数。它是周期为<span class="math inline">\(2\pi\)</span>的周期函数。</p><h4 id="dtft的性质和相关定理">DTFT的性质和相关定理</h4><p>假如<span class="math inline">\(x[n]\)</span>的DTFT是<span class="math inline">\(X(e^{j\omega})\)</span>，那么</p><ol type="1"><li><p>线性</p></li><li><p>时域移位性质： <span class="math display">\[x[n-n_d]\to e^{j\omega n_d}X(e^{j\omega})\]</span> 时域移位不会影响幅度频谱，但会引起相位频谱的线性变化，其斜率为<span class="math inline">\(-n_d\)</span></p></li><li><p>频域移位性质： <span class="math display">\[e^{j\omega_0n}\to X(e^{j(\omega-\omega_0)})\]</span></p></li><li><p>时间倒置性质： <span class="math display">\[x[-n]=X(e^{-j\omega})\]</span></p></li><li><p>频域微分性质： <span class="math display">\[nx[n]\to j\frac{d X}{d\omega}\]</span></p></li><li><p>共轭性质： <span class="math display">\[x^*[n]\to X^*(e^{-j\omega})\]</span></p></li><li><p>时、频域卷积，帕塞瓦尔定理。</p></li></ol><h4 id="dtft的对称性">DTFT的对称性</h4><p>对于一个序列<span class="math inline">\(x[n]\)</span>，有其共轭逆序序列<span class="math inline">\(x^*[-n]\)</span>，利用这个序列，我们可以把原序列分解<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="为什么说“分解”呢？因为$x[n]=x_e[n]+x_o[n]$显然成立。">[2]</span></a></sup>成共轭对称序列和共轭反对称序列，即： <span class="math display">\[\begin{align}x_e[n]=\frac 12(x[n]+x^*[-n])\\x_o[n]=\frac 12(x[n]-x^*[-n])\end{align}\]</span> 同样，对于连续函数（当然这里说的连续函数就是<span class="math inline">\(X(e^{j\omega})\)</span>，也可以按照类似的方法进行分解。</p><p>共轭对称序列<span class="math inline">\(x_e[n]\)</span>的实部偶对称，虚部奇对称；共轭反对称序列<span class="math inline">\(x_o[n]\)</span>的实部奇对称，虚部偶对称。</p><p>利用“共轭性质”，“线性性质”，有： <span class="math display">\[\begin{align}x_{Re}[n]\to X_e(e^{j\omega})\\jx_{Im}[n]\to X_o(e^{j\omega})\\x_e[n]\to X_{Re}(e^{j\omega})\\x_o[n]\to jX_{Im}(e^{j\omega})\end{align}\]</span> 由第一个式子，可以看出：实序列的DTFT幅度谱是偶函数，相位谱是奇函数。</p><h3 id="离散傅里叶级数dfs">离散傅里叶级数（DFS）</h3><p>DFS就是把DTFT里面的<span class="math inline">\(\omega\)</span>换成<span class="math inline">\(2\pi k/N\)</span>，其中<span class="math inline">\(N\)</span>是原序列的周期，<span class="math inline">\(k\)</span>是变换后得到的权序列的自变量。</p><h3 id="z变换">Z变换</h3><p>没啥好说的这个，上学期都学过了。</p><p>首先要注意的就是，<span class="math inline">\(X(z)\)</span>本质上来说还是个幂级数，以原序列为系数，即： <span class="math display">\[X(z)=\sum_{n=-\infty}^{\infty}x[n]z^{-n}\]</span> 在分析某些问题时，这种思维会很有用。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>需要注意的是，我们平常做题见到的很多系统都不是线性时不变系统。例如：如果进行了压扩变换，那么系统往往是时变的。我们平常所进行的“调幅”(即频率搬移)乘以一个<span class="math inline">()</span>，由于产生了新的频率分量，也不是线性时不变的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>为什么说“分解”呢？因为<span class="math inline">(x[n]=x_e[n]+x_o[n])</span>显然成立。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(21-30)</title>
    <link href="/2022/10/19/Verilog21-30/"/>
    <url>/2022/10/19/Verilog21-30/</url>
    
    <content type="html"><![CDATA[<h2 id="基于端口位置的实例化">基于端口位置的实例化</h2><h3 id="题目描述">题目描述</h3><p>创建一verilog电路，实现对模块mod_a基于端口位置的实例化，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191637163.png" /></p><p>其中mod_a模块的代码提供为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a(<br>    <span class="hljs-keyword">output</span> out1, out2,<br>    <span class="hljs-keyword">input</span> in1,in2,in3,in4);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;<br>    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;   <br>    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><strong>Hint:</strong></p><ul><li>实例化名称可以与模块名称相同</li><li>实例化模块时，需要注意端口信号的位宽相匹配，本例中都是1bit，所以不存在问题</li></ul><h3 id="输入格式">输入格式</h3><p>4个1bit信号a, b, c, d</p><h3 id="输出格式">输出格式</h3><p>经由模块mod_a输出的信号out1, out2</p><h3 id="代码和解析">代码和解析</h3><p>如题目所说，像调用函数一样依次传“参数”即可，注意位置要一一对应。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a(<br><span class="hljs-keyword">output</span> out1, out2,<br><span class="hljs-keyword">input</span> in1,in2,in3,in4);<br><span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4; <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;<span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out1,<br>    <span class="hljs-keyword">output</span> out2<br>);<br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    mod_a mod_a_inst(out1,out2,a,b,c,d);<br><br><span class="hljs-comment">// 用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="基于端口名称的实例化">基于端口名称的实例化</h2><h3 id="题目描述-1">题目描述</h3><p>创建一 verilog 电路，实现对模块 mod_a 基于端口名称的实例化，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191640660.png" /></p><p>其中mod_a模块的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a (<br>    <span class="hljs-keyword">output</span>   out1,<br>    <span class="hljs-keyword">output</span>   out2,<br>    <span class="hljs-keyword">input</span>    in1,<br>    <span class="hljs-keyword">input</span>    in2,<br>    <span class="hljs-keyword">input</span>    in3,<br>    <span class="hljs-keyword">input</span>    in4<br>);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="输入格式-1">输入格式</h3><p>输入信号 a, b, c, d，位宽 1bit。</p><h3 id="输出格式-1">输出格式</h3><p>输出信号 out1, out2，位宽 1bit。</p><h3 id="代码和解析-1">代码和解析</h3><p>除了像C语言一样按顺序传参数以外，Verilog还可以进行基于端口名称的实例化，如这道题所示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a (<br>    <span class="hljs-keyword">output</span>   out1   ,<br>    <span class="hljs-keyword">output</span>   out2   ,<br>    <span class="hljs-keyword">input</span>    in1    ,<br>    <span class="hljs-keyword">input</span>    in2    ,<br>    <span class="hljs-keyword">input</span>    in3    ,<br>    <span class="hljs-keyword">input</span>    in4<br>);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span>   a   ,<br>    <span class="hljs-keyword">input</span>   b   ,<br>    <span class="hljs-keyword">input</span>   c   ,<br>    <span class="hljs-keyword">input</span>   d   ,<br>    <span class="hljs-keyword">output</span>  out1,<br>    <span class="hljs-keyword">output</span>  out2<br>);<br><br>mod_a ul(<br>    <span class="hljs-variable">.out1</span>       (out1),<br>    <span class="hljs-variable">.out2</span>       (out2),<br>    <span class="hljs-variable">.in1</span>        (a),<br>    <span class="hljs-variable">.in2</span>        (b),<br>    <span class="hljs-variable">.in3</span>        (c),<br>    <span class="hljs-variable">.in4</span>        (d));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多个模块的例化">多个模块的例化</h2><h3 id="题目描述-2">题目描述</h3><p>对于给定模块my_dff，包含两个输入信号和一个输出信号（D触发器模块），其代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> d,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> q);<br>   <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>      q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请创建一verilog模块，在该模块中将my_dff模块例化3次，并串行连接，使其构成一个长度为3的移位寄存器，其中3个模块公用一个clk信号，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191642288.png" /></p><p>为实现电路功能，用户需要在顶层模块定义一些内部信号，从而能够将3个例化的模块进行连接。</p><h3 id="输入格式-2">输入格式</h3><p>2个 1bit 位宽信号 clk、d</p><h3 id="输出格式-2">输出格式</h3><p>1个 1bit 位宽信号 q</p><h3 id="代码和解析-2">代码和解析</h3><p>只需要对于图里面的两个粗箭头定义两个<code>wire</code>型中间信号即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> d,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> q);<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>        q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module ( <span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> d, <span class="hljs-keyword">output</span> q );<br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    my_dff u1(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.q</span>(w1));<br>    my_dff u2(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w1),<span class="hljs-variable">.q</span>(w2));<br>    my_dff u3(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w2),<span class="hljs-variable">.q</span>(q));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="模块与向量信号">模块与向量信号</h2><h3 id="题目描述-3">题目描述</h3><p>对于给定模块 my_dff8，其代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff8(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>        q &lt;= d;      <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>试创建一 Verilog 模块，对 my_dff8 模块例化 3 次，并串行连接，构成一个 8bit 位宽长度为 3 的移位寄存器，同时可以通过选择信号选择输出结果，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191647063.png" /></p><h3 id="输入格式-3">输入格式</h3><p>8bit 的任意有效输入</p><h3 id="输出格式-3">输出格式</h3><p>根据 sel 信号，选择一个模块或者原输入作为输出信号</p><h3 id="代码和解析-3">代码和解析</h3><p>比特矢量是可以作为一个信号直接参与模块例化的，这也是我之前说要把比特矢量看成一个“数”的原因之一。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff8(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>    q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w1,w2,w3;<br>    my_dff8 u1(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.q</span>(w1));<br>    my_dff8 u2(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w1),<span class="hljs-variable">.q</span>(w2));<br>    my_dff8 u3(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w2),<span class="hljs-variable">.q</span>(w3));<br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span> (sel)<br>            <span class="hljs-number">0</span>:q=d;<br>            <span class="hljs-number">1</span>:q=w1;<br>            <span class="hljs-number">2</span>:q=w2;<br>            <span class="hljs-number">3</span>:q=w3;<br>            <span class="hljs-keyword">default</span> : q=<span class="hljs-number">8&#x27;b00000000</span>;<br>        <span class="hljs-keyword">endcase</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-comment">// Write your code here</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这里用到了<code>always</code>块，是以前没有用到过的，但是我后面几个题的时候再来讲解。</p><h2 id="加法器">加法器</h2><p>对于给定的16bit加法器电路，其代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br> <span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>试创建一verilog模块，在该模块中实例化两个16bit的加法器，并进行适当的连接，最终构成一个32bit的加法器，该加法器输入进位位为0，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191652602.png" /></p><h3 id="输入格式-4">输入格式</h3><p>32'b0 32'b0</p><h3 id="输出格式-4">输出格式</h3><p>32'b0</p><h3 id="代码和解析-4">代码和解析</h3><p>这个题只需要读懂逻辑，然后照着图实现就可以了。这是一个典型的链接两个加法器的题，对于一个加法器（全加器），一般有三个输入：<code>a,b</code>是两个加数，<code>cin</code>是用来记录上一步有没有进位的值。输出一般有两个：<code>sum</code>是结果，<code>cout</code>是用来记录这个加法器有没有产生进位的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    add16 u1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<span class="hljs-variable">.sum</span>(sum1),<span class="hljs-variable">.cout</span>(w1));<br>    add16 u2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.cin</span>(w1),<span class="hljs-variable">.sum</span>(sum2),<span class="hljs-variable">.cout</span>(w2));<br>    <span class="hljs-keyword">assign</span> sum=&#123;sum2,sum1&#125;;<br>  <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多层次例化加法器">多层次例化加法器</h2><h3 id="题目描述-4">题目描述</h3><p>在此练习中，用户需要创建一个包含两层调用的电路，在顶层模块中，实例化两个16bit位宽的加法器add16,而add16模块又是通过例化16个1bit全加器实现的，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191656711.png" /></p><p>在本设计中，一共涉及到3个模块，分别是：顶层模块、add16模块、add1模块，其中add16模块源代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout);<br><span class="hljs-keyword">wire</span> c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15;<br><br>add1 inst_0(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">0</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(cin),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cout</span>(c1));<br>add1 inst_1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">1</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cin</span>(c1),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cout</span>(c2));<br>add1 inst_2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">2</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cin</span>(c2),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cout</span>(c3));<br>add1 inst_3(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">3</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cin</span>(c3),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cout</span>(c4));<br>add1 inst_4(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">4</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cin</span>(c4),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cout</span>(c5));<br>add1 inst_5(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">5</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cin</span>(c5),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cout</span>(c6));<br>add1 inst_6(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">6</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cin</span>(c6),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cout</span>(c7));<br>add1 inst_7(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">7</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cin</span>(c7),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cout</span>(c8));<br>add1 inst_8(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">8</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cin</span>(c8),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cout</span>(c9));<br>add1 inst_9(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">9</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cin</span>(c9),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cout</span>(c10));<br>add1 inst_10(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">10</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">10</span>]),<span class="hljs-variable">.cin</span>(c10),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">10</span>]),<span class="hljs-variable">.cout</span>(c11));<br>add1 inst_11(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">11</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">11</span>]),<span class="hljs-variable">.cin</span>(c11),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">11</span>]),<span class="hljs-variable">.cout</span>(c12));<br>add1 inst_12(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">12</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">12</span>]),<span class="hljs-variable">.cin</span>(c12),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">12</span>]),<span class="hljs-variable">.cout</span>(c13));<br>add1 inst_13(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">13</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">13</span>]),<span class="hljs-variable">.cin</span>(c13),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">13</span>]),<span class="hljs-variable">.cout</span>(c14));<br>add1 inst_14(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">14</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">14</span>]),<span class="hljs-variable">.cin</span>(c14),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">14</span>]),<span class="hljs-variable">.cout</span>(c15));<br>add1 inst_15(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>]),<span class="hljs-variable">.cin</span>(c15),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>]),<span class="hljs-variable">.cout</span>(cout));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>现在，你需要完成顶层模块和add1模块的verilog代码。</p><h3 id="输入格式-5">输入格式</h3><p>两个32位宽的加数a,b</p><h3 id="输出格式-5">输出格式</h3><p>32位宽的和sum</p><h3 id="代码和解析-5">代码和解析</h3><p>首先，第一部分是实现一位全加器<code>add1</code>，有两种实现方式。第一种是写出真值表，画出卡诺图并化简成逻辑表达式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">wire</span> w1,a1,a2,a3;<br>    <span class="hljs-keyword">assign</span> w1 = a ^ b;<br>    <span class="hljs-keyword">assign</span> sum = w1 ^ cin;<br>    <span class="hljs-keyword">assign</span> a1 = a &amp; b;<br>    <span class="hljs-keyword">assign</span> a2 = a &amp; cin;<br>    <span class="hljs-keyword">assign</span> a3 = b &amp; cin;<br>    <span class="hljs-keyword">assign</span> cout = a1 | a2 | a3;<br><span class="hljs-comment">// Full adder module here</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>第二种是基于行为建模，直接写出结果即可：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">assign</span> &#123;cout,sum&#125;=a+b+cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>然后，第二部分就是<code>top_module</code>，这个没有什么新意，照着图写就行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum);<br>    <br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br><br>    add16 u1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sum1),<br>        <span class="hljs-variable">.cout</span>(w1)<br>    );<br><br>    add16 u2(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(w1),<br>        <span class="hljs-variable">.sum</span>(sum2),<br>        <span class="hljs-variable">.cout</span>(w2)<br>    );<br><br>    <span class="hljs-keyword">assign</span> sum = &#123;sum2,sum1&#125;;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="进位选择加法器">进位选择加法器</h2><h3 id="题目描述-5">题目描述</h3><p>前例中的加法器成为串行进位加法器，只有等前一级的加法器运算结束产生进位位之后，下一级加法器才能利用进位位进行计算，因此电路延时会随加法器串联级数的增加而线性增加，这使得电路计算速度大大降低。设每一级全加器的延时为t，则32bit加法器的延时则为：32t。 为降低电路整体延时，我们可以按下图进行设计：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191702113.png" /></p><p>我们将电路分为两段，每段实现16bit的加法，为了使高16位与低16位同时进行运算，我们采用两个add16对高位进行计算，区别在于进位位分别为0和1，最终通过低16位加法器的输出进位作为选择控制信号，选择高16位的运算结果。这样，32bit加法器的延时就变为：16t+tmux2 ≈16t,延时降低了接近一倍，这种以空间（增加电路）换时间（提高速度）的做法，在数字电路设计中经常使用。 请创建Verilog模块，实现上图中的电路结构，其中add16不需要用户编写，其声明如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br>   <span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="输入格式-6">输入格式</h3><p>32bit a, 32bit b</p><h3 id="输出格式-6">输出格式</h3><p>32bit sum 为 a 与 b 的和</p><h3 id="代码和解析-6">代码和解析</h3><p>这题和前面几题差不多，没有什么难度，但是这个题介绍的方法很有趣。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <br><span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <br>    <span class="hljs-keyword">input</span> cin, <br>    <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <br>    <span class="hljs-keyword">output</span> cout <br>);<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sumH0,sumH1,sumL;<br>    <span class="hljs-keyword">wire</span> coutL;<br>    add16 H0(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sumH0)<br>    );<br>    add16 H1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-variable">.sum</span>(sumH1)<br>    );<br>    add16 L(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sumL),<br>        <span class="hljs-variable">.cout</span>(coutL)<br>    );<br>    <span class="hljs-keyword">assign</span> sum=(coutL?&#123;sumH1,sumL&#125;:&#123;sumH0,sumL&#125;);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="加法减法器">加法减法器</h2><h3 id="题目描述-6">题目描述</h3><p>通过对加法器进行改造，可以支持加、减两种运算。我们知道，电路中有符号数通常使用补码表示，如<span class="math inline">\(-b\)</span>其补码为：<span class="math inline">\(\sim b + 1\)</span>（按位取反然后加1）。因此，对于减法算式<span class="math inline">\(a-b\)</span>,可以理解为<span class="math inline">\(a+(-b) = a+(\sim b+1)= a + (\sim b) +1\)</span>,因此对于减法运算，可以将加法器进行如下改造实现</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191705188.png" /></p><p>实现减法运算时，首先通过32bit的异或门，将信号b按位取反，同时将输入进位位置1，实现加法运算时，b保持不变，输入进位位置0。 其中add16模块代码如下，用户可直接调用：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请创建Verilog模块，实现上述电路功能。</p><h3 id="输入格式-7">输入格式</h3><p>32位的a,b，以及一个1位信号sub，sub为1时为减法，sub为0时为加法</p><h3 id="输出格式-7">输出格式</h3><p>32位信号sum 注：我想你读到这里的时候，一定跟我一样想着直接用sum=(sub==0?a+b:a-b)逃课了，但是请老老实实地按题目要求分高位低位取补码相加哦~~~</p><h3 id="代码与解析">代码与解析</h3><p>我们先对<span class="math inline">\(b\)</span>进行一个处理。如果题目要求加，即<code>sub==0</code>，那么不需要做任何处理，直接加即可。但是如果题目要求减，即<code>sub==1</code>，那么需要求取<code>b</code>的反码，即<code>~b</code>。我们很容易想到，异或可以完成这个工作：遇到0不变，遇到1取反。所以我们可以直接把<code>b</code>和<code>sub</code>异或。</p><p>由于减法是<span class="math inline">\(a+(-b) = a+(\sim b+1)= a + (\sim b) +1\)</span>，为了实现这个加一，我们直接把<code>sub</code>信号接到第一个全加器的<code>cin</code>上即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">input</span> sub,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bXorSub;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br>    <span class="hljs-keyword">wire</span> w1;<br>    <span class="hljs-keyword">assign</span> bXorSub = b ^ &#123;<span class="hljs-number">32</span>&#123;sub&#125;&#125;;<br>    add16 u1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(bXorSub[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(sub),<br>        <span class="hljs-variable">.sum</span>(sum1),<br>        <span class="hljs-variable">.cout</span>(w1)<br>    );<br>    add16 u2(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(bXorSub[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(w1),<br>        <span class="hljs-variable">.sum</span>(sum2)<br>    );<br>    <span class="hljs-keyword">assign</span> sum=&#123;sum2,sum1&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="always过程块_组合逻辑">always过程块_组合逻辑</h2><h3 id="题目描述-7">题目描述</h3><p>所有的数字电路都是由逻辑门和连线构成的，因此理论上来说都可以通过模块的连接和<code>assign</code>语句进行描述，然而在很多情况下这并不是最方便的一种方式，过程块提供了一种更加方便的描述方式，<code>always</code>过程块便是其中最常用的一种。 对于可综合电路（即能转化成实际电路的verilog描述方式，与之相对的是不可综合电路，多用于电路仿真，不能转换成实际电路），有两种<code>always</code>块的语法形式：</p><ul><li>组合逻辑电路：<code>always@(*)</code></li><li>时序逻辑电路：<code>always@(posedge clk)</code></li></ul><p>组合逻辑电路的<code>always</code>块与<code>assign</code>语句等效，用户描述组合逻辑电路时，可根据便利性选择其中一种方式使用。两者生成的硬件电路一般是等效的，但在语法规则上稍有不同：</p><ul><li><code>assign</code>语句只能对一个信号进行赋值，<code>always</code>块内可对多个信号进行赋值</li><li><code>assign</code>语句中被赋值信号为<code>wire</code>类型，<code>always</code>块内被赋值信号需定义为<code>reg</code>类型</li><li><code>always</code>块内支持更加丰富的语法，如使用<code>if…else..</code>、<code>case</code>等适合实现交复杂的组合逻辑 例如下述两条语句是等效的（out1需定义为<code>wire</code>类型，out2需定义为<code>reg</code>类型，但这仅仅是语法上的要求，生成的电路并没有区别）： <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out1 = a &amp; b | c ^ d;<br><span class="hljs-keyword">always</span> @(*) out2 = a &amp; b | c ^ d;<br></code></pre></td></tr></table></figure> 其对应的电路图如下所示：</li></ul><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192023388.png" /></p><p><code>always</code>语句后的括号内放的是敏感变量列表，对于上例来说，可以写成<code>always @(a,b,c,d) out2 = a &amp; b | c ^ d</code>，但为了简单起见，我们一般都用符号<code>*</code>代替。 试创建一verilog模块，实现一与门，分别用<code>assign</code>语句和<code>always</code>块实现。</p><h3 id="输入格式-8">输入格式</h3><p>1位的a，1位的b</p><h3 id="输出格式-8">输出格式</h3><p>1位的out_assign，1位的out_alwaysblock</p><h3 id="代码和解析-7">代码和解析</h3><p>这道题向我们介绍了一个叫做“过程块”的事物，它就是<code>always</code>。在过程块中被赋值的变量必须是<code>reg</code>类型，尽管综合时可能和平常所使用的<code>assign</code>得到的电路没有区别。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_alwaysblock<br>);<br>    <span class="hljs-keyword">assign</span> out_assign = a &amp; b;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        out_alwaysblock = a &amp; b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="always过程块_时序逻辑">always过程块_时序逻辑</h2><h3 id="题目描述-8">题目描述</h3><p>通过前例已经了解到，对于可综合电路，有两种always块的语法形式：</p><ul><li>组合逻辑电路：<code>always@(*)</code></li><li>时序逻辑电路：<code>always@(posedge clk)</code></li></ul><p>用always描述的时序逻辑电路，除了像组合逻辑always块那样生成组合逻辑电路外，还会生成一组触发器（或称寄存器），用于寄存组合逻辑的输出。寄存器的输出只有在时钟的上升沿时（<code>posedge clk</code>）才会更新，其余时刻均保持不变。 阻塞赋值和非阻塞赋值： 在Verilog中，有三种赋值方式，分别为：</p><ul><li>连续赋值（如<code>assign x = y;</code>），该赋值方式只能用于过程块(如always块)之外</li><li>阻塞赋值（如<code>x = y;</code>），该赋值方式只能用在过程块（如<code>always@（*）</code>）内</li><li>非阻塞赋值（如<code>x &lt;= y;</code>），该赋值方式只能用在过程块内（如<code>always@（posedge clk）</code>）</li></ul><p>在设计Verilog模块时，请遵循以下原则：</p><ul><li>在组合逻辑的always块内采用阻塞赋值</li><li>时序逻辑的always块内采用非阻塞赋值</li></ul><p>违背这一原则将可能导致难以发现的电路错误，且可能导致仿真与综合的不一致，请用户切记。至于为何这样，初学者可以不必理会，简单理解为verilog语法规范性要求即可。 创建一verilog电路，分别采用上述三种赋值方式实现异或门电路，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192119474.png" /></p><p><strong>Hint</strong></p><ul><li>always块内被赋值的信号都应定义成reg类型</li><li>always块内，组合逻辑采用阻塞赋值（<code>a = b</code>），时序逻辑采用非阻塞赋值（<code>a &lt;= b</code>）</li><li>always语句括号内是敏感变量列表，时序逻辑是边沿敏感的，<code>posedge clk</code>表示的是clk信号的上升沿，此外，还可以是<code>negedge clk</code>，表示clk信号的下降沿。</li></ul><h3 id="输入格式-9">输入格式</h3><p>一位线网型变量clk，a, b。clk为时钟，a，b为输入</p><h3 id="输出格式-9">输出格式</h3><p>一位线网型变量out_assign，out_always_comb，out_always_ff。out_assign为a，b连续赋值得到的结果。out_always_comb为a，b阻塞赋值得到的结果。out_always_ff为a，b非阻塞赋值得到的结果</p><h3 id="代码和解析-8">代码和解析</h3><p>连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果；过程赋值只有在语句执行的时候，才会起作用。这是连续性赋值与过程性赋值的区别。</p><p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> sel, a, b ;<br><span class="hljs-keyword">reg</span> y , c ;<br><span class="hljs-keyword">always</span> @( sel <span class="hljs-keyword">or</span> a <span class="hljs-keyword">or</span> b ) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> ( sel == <span class="hljs-number">1&#x27;b1</span> ) <span class="hljs-keyword">begin</span><br>        c = a ;<br>        y = c ；<span class="hljs-comment">//实际就是y=a，这为了展示依次描述过程</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> y = b ;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这就是阻塞赋值，先执行<code>c=a</code>，再执行<code>y=c</code>，这段代码等价于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> sel, a, b, y ;<br><span class="hljs-keyword">assign</span> y = ( sel == <span class="hljs-number">1</span>’b1 ) ? a : b ;<br></code></pre></td></tr></table></figure><p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Cyclic_shifter ( clk, rst_n, Q );<br>    <span class="hljs-keyword">input</span> clk, rst_n ;<br>    <span class="hljs-keyword">output</span> [ <span class="hljs-number">2</span> : <span class="hljs-number">0</span> ] Q ;<br>    <span class="hljs-keyword">reg</span> [ <span class="hljs-number">2</span> : <span class="hljs-number">0</span> ] Q ;<br>    <span class="hljs-keyword">always</span> @ ( <span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n ) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> ( ~rst_n ) Q &lt;= <span class="hljs-number">3&#x27;b001</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            Q[<span class="hljs-number">0</span>] &lt;= Q[<span class="hljs-number">2</span>] ; <span class="hljs-comment">//相当于 Q &lt;= &#123; Q[1:0], Q[2]&#125; ;</span><br>            Q[<span class="hljs-number">1</span>] &lt;= Q[<span class="hljs-number">0</span>] ; <span class="hljs-comment">//这里只是为了展示非阻塞赋值，</span><br>            Q[<span class="hljs-number">2</span>] &lt;= Q[<span class="hljs-number">1</span>] ; <span class="hljs-comment">//实际上，可打乱这3句的次序，无影响</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>非阻塞赋值是先计算出要“赋”的“值”，然后到块结束再统一“赋予”。例如上面的代码，就是利用非阻塞赋值来交换了三个变量的值。</p><p>本题的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always_comb,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always_ff   <br>);<br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    <span class="hljs-keyword">assign</span> out_assign = a ^ b;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        out_always_comb = a ^ b;    <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        out_always_ff &lt;= a ^ b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="ifelse语句">if…else…语句</h2><p>题目描述</p><p>if语句用于过程块内部，其对应的电路是二选一的选择器，</p><p>以下述代码为例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(*)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(condition) out = x;<br>  <span class="hljs-keyword">else</span> out = y;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>上述代码与下面的assign语句完全等效：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out = (condition) ? x : y;<br></code></pre></td></tr></table></figure><p>试创建一Verilog模块，分别采用assing语句和过程块内的if语句实现下述选择器电路：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192154335.png" /></p><p><strong>Hint：</strong> 1. if…else…可以嵌套使用</p><ol start="2" type="1"><li>使用if语句描述组合逻辑时，务必加上else语句，以免产生锁存器（数字电路设计中应尽力避免产生锁存器）</li><li>本题两个输出信号波形其实是完全一致的，原则上是为了训练大家采用assign和过程块内的if语句使用，所以希望大家能够两种方式都各自尝试一下</li></ol><h3 id="输入格式-10">输入格式</h3><p>信号a, b, 选择信号sel_b1, sel_b2</p><h3 id="输出格式-10">输出格式</h3><p>通过assign语句选择的信号out_assign 通过if语句选择的信号out_always</p><h3 id="代码和解析-9">代码和解析</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">input</span> sel_b1,<br>    <span class="hljs-keyword">input</span> sel_b2,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always); <br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    <span class="hljs-keyword">assign</span> out_assign = (sel_b1 &amp; sel_b2) ? b : a;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(sel_b1 &amp; sel_b2)<br>            out_always = b;<br>        <span class="hljs-keyword">else</span> <br>            out_always = a;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(10-20)</title>
    <link href="/2022/10/10/verilog10-20/"/>
    <url>/2022/10/10/verilog10-20/</url>
    
    <content type="html"><![CDATA[<p>这一部分主要是比特矢量。</p><span id="more"></span><h2 id="向量">向量</h2><h3 id="题目描述">题目描述</h3><p><strong>Hint:</strong> 向量是为了编写、阅读代码方便，将一组相关的信号用一个向量名称统一命名的方式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w;<br></code></pre></td></tr></table></figure><p>声明了一个8bit位宽的向量信号w，实际上代表的是8个1bit的wire型信号。 注意向量信号的声明是将位宽信息放在信号名之前，这与C语言不太一样。我们可以将向量信号中的一位或多位单独拿来使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] out_4;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] my_vector;<br><span class="hljs-comment">// 声明一个100bit的向量my_vector</span><br><span class="hljs-keyword">assign</span> out = my_vector[<span class="hljs-number">11</span>] &amp; my_vector[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 选择其中两位信号进行运算</span><br><span class="hljs-keyword">assign</span> out_4 = my_vector[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<br><span class="hljs-comment">// 选择其中4bit信号</span><br></code></pre></td></tr></table></figure><p><strong>任务目标：</strong> 创建一verilog模块，具有一个3bit位宽的输入向量信号，然后将其输出到3bit位宽的输出向量信号，同时再分别输出到3个1bit位宽的输出信号，如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102158555.png" /></p><h3 id="输入格式">输入格式</h3><p>1个3bit位宽的向量信号vec</p><h3 id="输出格式">输出格式</h3><p>1个与输入vec保持一致的3bit位宽向量信号<code>outv</code>； 3个1bit位宽信号<code>o0</code>, <code>o1</code>, <code>o2</code>，分别对应输入信号<code>vec</code>的三位</p><h3 id="代码和解析">代码和解析</h3><p>当位宽大于 1 时，<code>wire</code>或 <code>reg</code> 即可声明为向量的形式。这种“向量”也叫“比特矢量”，为的是强调它的每一位都是一个二进制位。一个比特矢量一般来说是这么定义的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] name;<br></code></pre></td></tr></table></figure><p>对于一个比特矢量来说，我们更应该把它看成一个“变量”或“数”，而尽可能不把它看成“数列”，这样可能会为思考带来些许方便。比如说，一个比特矢量是可以直接赋值的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">var</span>;<br><span class="hljs-keyword">var</span>=<span class="hljs-number">8&#x27;hFF</span>;<br></code></pre></td></tr></table></figure><p>这样的话，变量<code>var</code>就被赋予了8位二进制数<code>8'b1111_1111</code>的值，也就是十进制下的511。在比特矢量中，更靠“左”的位对应的“下标”的数字会更大。初看很奇怪，但是只要把左边的理解成二进制的“高位”，那么位越高数字越大，就很显然了。</p><p>在访问单个元素时，可以使用类似于“数组”的形式来访问。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(vec,outv,o2,o1,o0);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] vec;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]outv;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> o0,o1,o2;<br><br>    <span class="hljs-keyword">assign</span> outv = vec[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> o0=vec[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> o1=vec[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">assign</span> o2=vec[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量_续-1">向量_续 1</h2><h3 id="题目描述-1">题目描述</h3><p>创建一 Verilog 模块，将 16bit 输入信号 <code>in</code>分成两个 8bit 的信号 <code>out_hi</code>、<code>out_lo</code>，然后输出，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102225212.png" /></p><h3 id="输入格式-1">输入格式</h3><p>输入信号 <code>in</code>, 位宽 16bit，类型为 <code>wire</code>。</p><h3 id="输出格式-1">输出格式</h3><p>输出信号<code>out_hi</code>，位宽 8bit，为输入信号的高 8 位。 输出信号<code>out_lo</code>，位宽 8bit，为输入信号的低 8 位。</p><h3 id="代码和解析-1">代码和解析</h3><p>Verilog里面的比特矢量是可以以和Python里面的列表切片有点类似的方法使用的，就像这里面一样，<code>[15:8]</code>就表示取第15位到第8位。这个学名叫“part-select操作”。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]out_hi,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]out_lo<br>);<br><br><span class="hljs-keyword">assign</span> out_lo = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> out_hi = in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量_续2">向量_续2</h2><h3 id="题目描述-2">题目描述</h3><p>一个32bit的向量信号包含有4个字节（bit[31:24]、bit[23:16]等），创建一个电路，用以调整4个字节的顺序，该电路经常用于在不同大小端系统之间进行数据交互： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">AaaaaaaaBbbbbbbbCcccccccDddddddd</span> <span class="hljs-operator">=</span>&gt; DdddddddCcccccccBbbbbbbbAaaaaaaa<br></code></pre></td></tr></table></figure> 提示：part-select操作即可以用于赋值语句的左侧也可用于右侧。</p><h3 id="输入格式-2">输入格式</h3><p>1个 32bit 位宽的向量信号 in</p><h3 id="输出格式-2">输出格式</h3><p>1个 32bit 位宽的向量信号 out</p><h3 id="代码和解析-2">代码和解析</h3><p>正如题目所说的，part-select操作即可以用于赋值语句的左侧也可用于右侧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>);<br><br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>] = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>] = in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>] = in[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = in[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="位操作">位操作</h2><h3 id="题目描述-3">题目描述</h3><p>创建一个电路，包含两个 3bit 的输入信号 a 和 b，分别对 ab 进行按位或、逻辑或操作，以及将 ab 拼接成 6bit 信号后进行按位取反，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102234810.png" /></p><h3 id="输入格式-3">输入格式</h3><p>a = 3'b101 b = 3'b000</p><h3 id="输出格式-3">输出格式</h3><p>按位或：3'b101 逻辑或：1 拼接ab后再按位取反：6'b111010</p><h3 id="代码和解析-3">代码和解析</h3><p>这里主要区分一下按位操作和逻辑操作。在逻辑操作中，一个数如果不等于0（即所有位都是0），那么它代表“真”值，反之，如果所有位都是0，那么它代表“假”值。</p><p>Verilog中，比特矢量是可以拼接的。只需要用个大括号把两部分括起来就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] out_or_bitwise,<br>    <span class="hljs-keyword">output</span> out_or_logical,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] out_not<br>);<br>    <span class="hljs-keyword">assign</span> out_or_bitwise = a|b;<br>    <span class="hljs-keyword">assign</span> out_or_logical = a || b;<br>    <span class="hljs-keyword">assign</span> out_not = &#123;~b,~a&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="位操作2">位操作2</h2><h3 id="题目描述-4">题目描述</h3><p>创建一个组合逻辑电路，包含4bit输入（in[3:0]），和3个输出，分别为：</p><ul><li><code>out_and</code>：四输入与门的输出信号</li><li><code>out_or</code>：四输入或门的输出信号</li><li><code>out_xor</code>：四输出异或门的输出信号</li></ul><p>电路结构如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102241454.png" /></p><h3 id="输入格式-4">输入格式</h3><p>0 0 0 0</p><h3 id="输出格式-4">输出格式</h3><p>0 0 0</p><h3 id="代码和解析-4">代码和解析</h3><p>在Verilog中，可以把一个本来是二目运算符的按位算符放在一个比特矢量的前面，这表示从高位到低位一个一个依次用这个二目运算符计算，最后得到一个一位的结果。这种操作叫“归约操作符”。归约操作符包括：归约与<code>&amp;</code>，归约与非<code>~&amp;</code>，归约或<code>|</code>，归约或非<code>~|</code>，归约异或<code>^</code>，归约同或<code>~^</code>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_and,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_or,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_xor<br>);<br>    <span class="hljs-keyword">assign</span> out_and = &amp;in;<br>    <span class="hljs-keyword">assign</span> out_or = |in;<br>    <span class="hljs-keyword">assign</span> out_xor = ^in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量拼接">向量拼接</h2><h3 id="题目描述-5">题目描述</h3><p>part_selection用于选择向量信号中的一部分，而向量拼接算子{a,b,c}用于将多个信号组合成一个位宽更大的向量信号，如： <code>&#123;3'b111, 3'b000&#125;</code> 等同于 <code>6'b111000</code> <code>&#123;1'b1, 1'b0, 3'b101&#125;</code>等同于<code>5'b10101</code> <code>&#123;4'ha, 4'd10&#125;</code> 等同于 <code>8'b10101010</code> // 4'ha and 4'd10 are both 4'b1010 in binary 向量拼接时，每个信号都需要有明确的位宽，这样拼接后的信号才会有明确的位宽。例如，{1,2,3}就是非法的，因为无法确定各信号的位宽，语法检查时会报错。 向量拼接算子既可以用于赋值语句的左侧，也可用于右侧，如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>] out;<br><span class="hljs-keyword">assign</span> &#123;out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125; = in;<br><span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;<br><span class="hljs-keyword">assign</span> out = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;  <br></code></pre></td></tr></table></figure><p>创建Verilog电路，将6个5bit位宽的输入信号，以及2bit的常量信号2’b11拼接成32bit的向量信号，并将其拆成4个8bit的信号，分别赋值给4个输出信号，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102248499.png" /></p><h3 id="输入格式-5">输入格式</h3><p>6个5位宽的输入信号a,b,c,d,e,f</p><h3 id="输出格式-5">输出格式</h3><p>4个8位宽的信号w,x,y,z</p><h3 id="代码和解析-5">代码和解析</h3><p>正如题目中所说：向量拼接算子既可以用于赋值语句的左侧，也可用于右侧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] a, b, c, d, e, f,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w, x, y, z );<br>    <span class="hljs-keyword">assign</span> &#123;w,x,y,z&#125; = &#123;a,b,c,d,e,f,<span class="hljs-number">2&#x27;b11</span>&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量翻转">向量翻转</h2><h3 id="题目描述-6">题目描述</h3><p>创建verilog电路，将8bit的输入信号按bit翻转，并输出到输出端口，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102255765.png" /></p><h3 id="输入格式-6">输入格式</h3><p>8 bit in</p><h3 id="输出格式-6">输出格式</h3><p>8 bit out, 为in的向量翻转</p><h3 id="代码和解析-6">代码和解析</h3><p>想到翻转，我第一时间想到的是直接写成这样：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out=in[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>然而实践证明并不行，是因为 Verilog 不允许翻转向量的位顺序，所以还是只能一个一个赋值。</p><p>正确的代码是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out=&#123;in[<span class="hljs-number">0</span>],in[<span class="hljs-number">1</span>],in[<span class="hljs-number">2</span>],in[<span class="hljs-number">3</span>],in[<span class="hljs-number">4</span>],in[<span class="hljs-number">5</span>],in[<span class="hljs-number">6</span>],in[<span class="hljs-number">7</span>]&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="复制算子">复制算子</h2><h3 id="题目描述-7">题目描述</h3><p>复制算子是拼接算子的一种特殊情况，如<code>a=&#123;b,b,b,b,b,b&#125;</code>便可以写成<code>a=&#123;6&#123;b&#125;&#125;</code>的形式。复制算子的格式为：<code>&#123;num&#123;vector&#125;&#125;</code>，其中<code>num</code>必须为常量。如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">&#123;<span class="hljs-number">5</span>&#123;<span class="hljs-number">1&#x27;b1</span>&#125;&#125; <span class="hljs-comment">// 5&#x27;b11111 (or 5&#x27;d31 or 5&#x27;h1f)</span><br>&#123;<span class="hljs-number">2</span>&#123;a,b,c&#125;&#125; <span class="hljs-comment">// The same as &#123;a,b,c,a,b,c&#125;</span><br>&#123;<span class="hljs-number">3&#x27;d5</span>, &#123;<span class="hljs-number">2</span>&#123;<span class="hljs-number">3&#x27;d6</span>&#125;&#125;&#125; <span class="hljs-comment">// 9&#x27;b101_110_110</span><br></code></pre></td></tr></table></figure><p>创建一verilog电路，将一个8bit位宽的输入信号进行符号位扩展，并通过32bit的输出端口输出，如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102258111.png" /></p><h3 id="输入格式-7">输入格式</h3><p>8位in信号</p><h3 id="输出格式-7">输出格式</h3><p>32位out信号</p><h3 id="代码和解析-7">代码和解析</h3><p>关于复制算子，题目里已经说得很清楚了，照着写就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out <br>);<br>    <span class="hljs-keyword">assign</span> out = &#123;&#123;<span class="hljs-number">24</span>&#123;in[<span class="hljs-number">7</span>]&#125;&#125;,in&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="复制算子_2">复制算子_2</h2><h3 id="题目描述-8">题目描述</h3><p>创建一verilog电路，包含5个1bit输入，使所有输入两两进行同或（两bit相同时输出1，不同时输出0），并将结果通过25bit的向量信号输出，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102259350.png" /></p><h3 id="输入格式-8">输入格式</h3><p>1位的a,b,c,d,e</p><h3 id="输出格式-8">输出格式</h3><p>25位的out</p><h3 id="代码和解析-8">代码和解析</h3><p>使用复制算子实现该电路，可以大大减少代码量，提高编码效率。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a, b, c, d, e,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] out <br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] mid_1;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] mid_2;<br>    <span class="hljs-keyword">assign</span> mid_1=&#123;&#123;<span class="hljs-number">5</span>&#123;a&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;b&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;c&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;d&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;e&#125;&#125;&#125;;<br>    <span class="hljs-keyword">assign</span> mid_2=&#123;&#123;<span class="hljs-number">5</span>&#123;a,b,c,d,e&#125;&#125;&#125;;<br>    <span class="hljs-keyword">assign</span> out=~(mid_1 ^ mid_2);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="模块例化">模块例化</h2><h3 id="题目描述-9">题目描述</h3><p>通过前面一系列的练习，用户应当已经熟悉单个模块电路的设计了。对于功能上更复杂的电路模块，一般都是由若干子模块以及附加的功能电路构成的。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102301840.png" /></p><p>在模块实例化过程中，被例化模块的端口信号是最重要的，用户甚至可以不知道模块的内部结构。上图展示了一个非常简单的包含有子模块电路的电路结构，在此电路中，创建模块mod_a的一个实例化，并将该实例化模块的三个端口（<code>in1</code>,<code>in2</code>,<code>out</code>）与顶层电路的三个端口(<code>a</code>,<code>b</code>,<code>out</code>)直接连接，其中<code>mod_a</code>模块的代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a ( <span class="hljs-keyword">input</span> in1, <span class="hljs-keyword">input</span> in2, <span class="hljs-keyword">output</span> out );<br><span class="hljs-comment">// Module body</span><br><span class="hljs-keyword">assign</span> out = in1 &amp; in2; <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>模块实例化一般有两种语法格式，分别称为基于端口名称的实例化和基于端口位置的实例化。 基于位置的实例化和C语言中的函数调用类似（只是语法上类似，实际上该例化会产生实际的硬件电路），以上述<code>mod_a</code>模块的实例化为例，可以在上层模块中使用以下语句：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<span class="hljs-keyword">input</span> wa,<span class="hljs-keyword">input</span> wb,<span class="hljs-keyword">output</span> wc);<br>mod_a inst_name1(wa,wb,wc);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>其中<code>inst_name1</code>是<code>mod_a</code>模块的实例化名称，可以由用户自定义，通过这种例化方式，便实现了端口对应：<code>wa↔︎in1</code>, <code>wb↔︎in2</code>, <code>wc↔︎out</code>。 基于端口名称的实例化如下所示</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<span class="hljs-keyword">input</span> wa,<span class="hljs-keyword">input</span> wb,<span class="hljs-keyword">output</span> wc);<br>mod_a inst_name2(<br><span class="hljs-variable">.out</span>(wc),<br><span class="hljs-variable">.in1</span>(wa),<br><span class="hljs-variable">.in2</span>(wb));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>本教程推荐用户使用基于端口名称的例化方式，因为这种方式编写的代码可读性更强。 试创建一verilog电路，并按照上图中所示实例化<code>mod_a</code>模块（建议使用基于端口名称的方式实例化）。</p><p>Hint:</p><ul><li>推荐使用基于端口名称的实例化方式</li><li>模块调用就像是一个树形的层次结构，不允许循环调用，如a调用b，b又调用a，也不允许模块调用自身，即模块c中又实例化模块c。</li><li>不允许在进程块（如always、initial等）或赋值语句（如assign语句）内进行模块实例化</li><li>模块的实例化名称可以自定义，如在同一模块中要对一个模块多次实例化，需要有不同的实例化名称。</li></ul><h3 id="输入格式-9">输入格式</h3><p>一位线网型变量a、b</p><h3 id="输出格式-9">输出格式</h3><p>一位线网型变量out</p><h3 id="代码和解析-9">代码和解析</h3><p>正如上一篇文章中所说，模块实例化可以类比为C语言里面的函数调用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">input</span> a,<br>  <span class="hljs-keyword">input</span> b,<br>  <span class="hljs-keyword">output</span> out<br>);<br>  <br><span class="hljs-comment">// 请用户在下方编辑代码</span><br><br>mod_a mod_a_inst(<span class="hljs-variable">.in1</span>(a),<span class="hljs-variable">.in2</span>(b),<span class="hljs-variable">.out</span>(out));<br><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> mod_a ( <br>  <span class="hljs-keyword">input</span> in1, <br>  <span class="hljs-keyword">input</span> in2, <br>  <span class="hljs-keyword">output</span> out <br>);<br><span class="hljs-keyword">assign</span> out = in1 &amp; in2;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(1-10)</title>
    <link href="/2022/10/08/verilog1-10/"/>
    <url>/2022/10/08/verilog1-10/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="准备工作">准备工作</h2><ol type="1"><li><p>安装Vivado软件，VSCode软件，VSCode的Verilog插件</p></li><li><p>在环境变量中加入Vivado的XVlog，以便VSCode检查</p></li><li><p>在Vivado中新建一个project，除取名和选择路径以外一路Next即可。</p></li><li><p>来到了以下界面</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082304579.png" alt="image-20221008230354388" /><figcaption aria-hidden="true">image-20221008230354388</figcaption></figure><p>鼠标选择Constraints，点加号，在弹出的窗口中选择第二个选项，点Next，点Creat File新建一个文件，文件名最好是模块名。</p></li><li><p>点小齿轮（设置），点Text Editor，选择Custom Editor，输入<code>.../Microsoft VS Code/Code.exe -g [file name]</code>，点OK</p></li><li><p>先打开VSCode软件，再双击Vivado Sources/Design Sources里你刚刚新建的.v文件，弹出新VSCode窗口，于是可以开始写代码了。</p></li></ol><h2 id="输出1">输出1</h2><h3 id="题目描述">题目描述</h3><p>编写 Verilog 代码，使电路输出信号1</p><h3 id="输入格式">输入格式</h3><p>无输入</p><h3 id="输出格式">输出格式</h3><p>输出1，位宽为1</p><h3 id="代码和解析">代码和解析</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(out);<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>  <span class="hljs-keyword">assign</span> out = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这个题没什么好解析的，直接用<code>assign</code>赋值即可，主要熟悉基本的操作。Verilog的基本结构是模块，也就是这里面的<code>module</code>，一个模块代表一个功能单元。模块最基本的结构是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名称(端口列表);<br>    <span class="hljs-keyword">input</span> 数据类型(<span class="hljs-keyword">reg</span> 或 <span class="hljs-keyword">wire</span>) 输入端口表;<br>    <span class="hljs-keyword">output</span> 数据类型(<span class="hljs-keyword">reg</span> 或 <span class="hljs-keyword">wire</span>) 输出端口表;<br>    <span class="hljs-comment">//逻辑代码...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>上述的声明方法是Verilog-1995标准 风格，还有一种声明方法是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名 <span class="hljs-variable">#(参数声明1，参数声明2,...)</span><br>    (端口声明 端口<span class="hljs-number">1</span>，端口<span class="hljs-number">2</span>，...,<br>     端口声明 端口<span class="hljs-number">3</span>，端口<span class="hljs-number">4</span>,....);<br>    <span class="hljs-comment">//逻辑代码...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>以这种风格书写的本题代码是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">output</span> out<br>);<br>  <span class="hljs-keyword">assign</span> out = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="输出0">输出0</h2><p>把上题中的<code>1</code>变成<code>0</code>即可，略。</p><h2 id="wire">wire</h2><h3 id="题目描述-1">题目描述</h3><p>wire 是 Verilog 的关键字，用于表征信号类型的，其含义是线网。wire 可理解为物理连线，但又有所不同，因为 Verilog 中的 wire 是有方向的。例如设计一模块，模块名命名为 top_module，输入信号名为 in，输出信号名为 out，使 in 与 out 直连，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082321013.png" /></p><p>请使用 assign 语句将代码补充完整，使其实现上述电路图的功能。</p><h3 id="输入格式-1">输入格式</h3><p>任意</p><h3 id="输出格式-1">输出格式</h3><p>与输入完全相同</p><h3 id="代码和解析-1">代码和解析</h3><p>Verilog的变量有两种最基本的类型，即<code>wire</code>和<code>reg</code>，默认1位宽。</p><p><code>wire</code>如其名字所示，表示连线。驱动端信号的改变会立刻传递到输出的连线上。输入输出端口，如果不另行声明类型，都默认为`<code>wire</code>，如果使用<code>assign</code>的连续赋值语句，被赋值的变量都得是<code>wire</code>。</p><p><code>reg</code>的意思是寄存器，它能保持其值，直到它被赋于新的值。在行为建模中，在过程块(<code>always</code>块)中被赋值的变量必须是<code>reg</code>类型</p><p>还有其它类型，如整数、实数、比特矢量、数组，等用到了再说。</p><p>这个题的代码实现是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(in,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out = in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多个端口的模块">多个端口的模块</h2><h3 id="题目描述-2">题目描述</h3><p>wire是Verilog的关键字，用于表征信号类型的，其含义是线网，wire可理解为物理连线，但又有所不同，因为verilog中的wire是有方向的，例如设计一模块，模块名命名为top_module，输入信号名为in，输出信号名为out，使in与out直连，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082332727.png" /></p><p>请使用assign语句将代码补充完整，使其实现上述电路图的功能</p><h3 id="输入格式-2">输入格式</h3><p>1 1 1</p><h3 id="输出格式-2">输出格式</h3><p>1 1 1 1</p><h3 id="代码和解析-2">代码和解析</h3><p>这题没啥解析的，和上一题差不多。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,c,w,x,y,z);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b,c;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> w,x,y,z;<br>    <span class="hljs-keyword">assign</span> w=a;<br>    <span class="hljs-keyword">assign</span> x=b;<br>    <span class="hljs-keyword">assign</span> y=b;<br>    <span class="hljs-keyword">assign</span> z=c;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h2 id="非门">非门</h2><h3 id="题目描述-3">题目描述</h3><p>创建一个名为top_module的Verilog模块，实现非门的功能</p><h3 id="输入格式-3">输入格式</h3><p>无</p><h3 id="输出格式-3">输出格式</h3><p>无</p><h3 id="代码和解析-3">代码和解析</h3><p>在这个题里，我们要介绍一下连续赋值。总的来说，Verilog里有两种赋值，叫做过程赋值和连续赋值。其中过程赋值主要在<code>initial</code>或<code>always</code>块中使用，我们也是到时候再说，先来说连续赋值。</p><p>连续赋值的格式是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> 被赋值量 = 值;<br></code></pre></td></tr></table></figure><p>其中被赋值量只能是<code>wire</code>型的，值的类型没有限制。</p><p>本题的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> b;<br>    <span class="hljs-keyword">assign</span>  b = ~a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="与门">与门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082342033.png" /></p><p>和上一题差别不大</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=a&amp;b;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="或非门">或非门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082343150.png" /></p><p>和上一题的差别不大，或非的意思就是先或再非。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=~(a|b);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="同或门">同或门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082344430.png" /></p><p>和上一题差别不大，同或的意思就是俩信号一样就是0，不一样就是1，也就是异或取反。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=~(a^b);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="线网型中间信号">线网型中间信号</h2><h3 id="题目描述-4">题目描述</h3><p>之前的verilog模块结构都比较简单，输出信号可直接用输入信号的逻辑表达式表示出来，模块功能稍微复杂时，一般都会用到中间信号，以下图为例，输入信号in经过两个非门后输出到out端口，为了在verilog模块中表示两个非门中间的这跟信号，需要将其定义为线网型（wire）信号，此处我们命名为not_in。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082345009.png" /></p><p>上述模块的verilog代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> out;<br>);<br>    <span class="hljs-keyword">wire</span> not_in;<br>    <br>    <span class="hljs-keyword">assign</span> out=~not_in;<br>    <span class="hljs-keyword">assign</span> not_in=~in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请根据上述示例，完成下图中电路所对应的Verilog模块</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082346567.png" /></p><h3 id="输入格式-4">输入格式</h3><p>四个线网型变量a、b、c、d</p><h3 id="输出格式-4">输出格式</h3><p>两个线网型变量out、out_n</p><h3 id="代码和解析-4">代码和解析</h3><p>这个题属于稍微复杂一点的组合逻辑，需要用到中间变量。在做题以前，我们先观察一下他给我们的代码，里面有这么两句：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out=~not_in;<br><span class="hljs-keyword">assign</span> not_in=~in;<br></code></pre></td></tr></table></figure><p>有同学可能就问了，按照逻辑，难道不应该是<code>not_in</code>先有值，然后<code>out</code>才有值吗？怎么能先给<code>out</code>赋值呢？这就是Verilog的一个特点，那就是并行赋值。你不要把这两个语句当成C语言，先执行上面的，再执行下面的，而是要当成图里面那个电路，输入信号来的时候，<code>not_in</code>和<code>out</code>有先后之分吗？忽略光速和元件延时的情况下，显然没有。</p><p>根据给出的图，我们很容易写出下面的代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,c,d,out,out_n);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b,c,d;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out,out_n;<br>    <span class="hljs-keyword">wire</span> x,y;<br>    <span class="hljs-keyword">assign</span> x = (a&amp;b);<br>    <span class="hljs-keyword">assign</span> y = (c&amp;d);<br>    <span class="hljs-keyword">assign</span> out = x|y;<br>    <span class="hljs-keyword">assign</span> out_n=~(x|y);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>但是有个问题，就是我们不知道这个代码对不对。那么怎么知道我们的代码是怎么运行起来呢？在C语言里，我们一般是编译执行然后在控制台里输入一些数据，看输出是不是符合我们的期待。在Verilog中，我们也要给程序输入一些信号，看输出的信号是否符合我们的期待，但是这个过程比C语言的要复杂一些：我们还要再写一个Verilog代码，它叫做“testbench”。</p><p>首先我们回到Vivado软件，鼠标选择Constraints，点加号，在弹出的窗口中选择第<strong>三</strong>个选项，点Next，点Creat File新建一个文件，文件名最好是“模块名_tb”。这里的“tb”就是"testbench"的意思。然后，在Simulation Source里面就生产力testbench代码。</p><p>testbench代码的基本结构是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> 模块名_tb;<br>   <span class="hljs-keyword">reg</span> 输入端口名<span class="hljs-number">1</span>,输入端口名<span class="hljs-number">2</span>,...;<br>   <span class="hljs-keyword">wire</span> 输出端口名<span class="hljs-number">1</span>，输出端口名<span class="hljs-number">2</span>，...;<br>   模块名 模块的示例名(.端口名<span class="hljs-number">1</span>(端口<span class="hljs-number">1</span>),.端口名<span class="hljs-number">2</span>(端口<span class="hljs-number">2</span>),...);<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>       输入端口<span class="hljs-number">1</span>=值<span class="hljs-number">1_1</span>;输入端口<span class="hljs-number">2</span>=值<span class="hljs-number">1_2</span>;...<br>       #<span class="hljs-number">50</span>;<br>       输入端口<span class="hljs-number">1</span>=值<span class="hljs-number">2_1</span>;输入端口<span class="hljs-number">2</span>=值<span class="hljs-number">2_2</span>;...<br>       #<span class="hljs-number">50</span>;<br>       ...<br>       输入端口<span class="hljs-number">1</span>=值n_1;输入端口<span class="hljs-number">2</span>=值n_2;...<br>       #<span class="hljs-number">50</span>;<br>       <span class="hljs-built_in">$stop</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这里面有几个我们之前没见过的东西。首先是第一行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br></code></pre></td></tr></table></figure><p>这个以反撇号开头的语句叫做编译指令，用于说明参考时间单位和仿真时间精度。</p><p>然后是第五行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">模块名 模块的示例名(.端口名<span class="hljs-number">1</span>(端口<span class="hljs-number">1</span>),.端口名<span class="hljs-number">2</span>(端口<span class="hljs-number">2</span>),...);<br></code></pre></td></tr></table></figure><p>这个叫做“例化”，可以类比C语言里面的“调用”。在C语言中，调用一个函数只能按顺序传参，但是在Verilog里，可以像这里一样端口命名法传递信号。</p><p>然后是第十行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">#<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>这个的意思是延时50个时间单位。</p><p>于是，我们可以写出这道题的testbench代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> top_module_tb;<br>   <span class="hljs-keyword">reg</span> a, b, c, d;<br>   <span class="hljs-keyword">wire</span> out, out_n;<br>   top_module ul(<span class="hljs-variable">.a</span>(a),<span class="hljs-variable">.b</span>(b),<span class="hljs-variable">.c</span>(c),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.out</span>(out),<span class="hljs-variable">.out_n</span>(out_n));<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      a=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;d=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      <span class="hljs-built_in">$stop</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>呃，说实话，这个代码不是我写的，是我写的代码帮我写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入模块名称:&quot;</span>);<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入input信号个数：&quot;</span>);<br><span class="hljs-type">int</span> NumInput;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;NumInput);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;依次输入input信号名称：&quot;</span>);<br>string inputSign[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i) &#123;<br>cin &gt;&gt; inputSign[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入output信号个数：&quot;</span>);<br><span class="hljs-type">int</span> NumOutput;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;NumOutput);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;依次输入output信号名称：&quot;</span>);<br>string outputSign[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i) &#123;<br>cin &gt;&gt; outputSign[i];<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;`timescale 1ns / 1ps\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;module &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;_tb;\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;   reg &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i)&#123;<br>cout &lt;&lt; inputSign[i];<br><span class="hljs-keyword">if</span>(i!=NumInput) cout&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;;&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   wire &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i)&#123;<br>cout &lt;&lt; outputSign[i];<br><span class="hljs-keyword">if</span>(i!=NumOutput) cout&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;;&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; ul(&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i)<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; inputSign[i] &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; inputSign[i] &lt;&lt; <span class="hljs-string">&quot;),&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; outputSign[i] &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; outputSign[i] &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br><span class="hljs-keyword">if</span> (i != NumOutput) cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;);&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   initial begin&quot;</span> &lt;&lt; endl;<br><span class="hljs-type">int</span> pow2in = <span class="hljs-number">1</span> &lt;&lt; NumInput;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= pow2in<span class="hljs-number">-1</span>; ++i) &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;      &quot;</span>;<br><span class="hljs-type">int</span> temp = i, cnt = NumInput;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= NumInput; ++j)<br>cout &lt;&lt; inputSign[j] &lt;&lt; <span class="hljs-string">&quot;=0;&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span> (temp &amp;&amp; cnt&gt;=<span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; inputSign[cnt] &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; temp % <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>temp = temp / <span class="hljs-number">2</span>;<br>--cnt;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=cnt;j&gt;=<span class="hljs-number">1</span>;--j)&#123;<br>cout &lt;&lt; inputSign[j] &lt;&lt; <span class="hljs-string">&quot;=0;&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;      #50;&quot;</span>&lt;&lt;endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;      $stop;&quot;</span>&lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   end&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;endmodule&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存文件，点这个</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210090004442.png" alt="image-20221009000446371" /><figcaption aria-hidden="true">image-20221009000446371</figcaption></figure><p>Vivado就产生了对应的波形：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210090005315.png" alt="image-20221009000506234" /><figcaption aria-hidden="true">image-20221009000506234</figcaption></figure><p>我们就能照着这个看自己写的对不对了。</p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第12届北影节游记</title>
    <link href="/2022/08/22/12%E5%B1%8A%E5%8C%97%E5%BD%B1%E8%8A%82%E6%B8%B8%E8%AE%B0/"/>
    <url>/2022/08/22/12%E5%B1%8A%E5%8C%97%E5%BD%B1%E8%8A%82%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这两天看了三部电影，应该是我有生以来在电影院看电影最频繁的一段时间。</p><span id="more"></span><h2 id="首先评价一下这三座电影院">首先评价一下这三座电影院</h2><h3 id="红剧场">红剧场</h3><p>“红剧场”，原名叫做“北京崇文区工人文化宫大剧场”。在此之前，我曾和朋友一起去海淀区工人文化宫看过一场《波斯语课》，所以说看到电影院的气质感到有些亲切。总的来说就是比较质朴的气质，值得一提的是，这是我这辈子第一次在二楼看电影，体验比想象中要好，各位有兴趣可以尝试一下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035665.jpg" alt="红剧场外景" /><figcaption aria-hidden="true">红剧场外景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035759.jpg" alt="红剧场内景" /><figcaption aria-hidden="true">红剧场内景</figcaption></figure><h3 id="深影国际影城">深影国际影城</h3><p>很现代化的影院，座椅和设备什么的比红剧场好很多，装潢也很漂亮。值得一提的是，似乎是这座影院养活了它所在的“哇沃生活广场”，这个广场的一二层都是饭店，生意很一般，整个三层都是影院。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035634.jpg" alt="深影国际影城" /><figcaption aria-hidden="true">深影国际影城</figcaption></figure><h3 id="天幕新彩云国际影城">天幕新彩云国际影城</h3><p>在中央新影旁边的一个院子里，进放映厅不让带水。它的巨幕厅非常非常巨大且震撼，一定要体验一次。一个趣事是，之前我和朋友曾在此看过《指环王3王者归来》，但是当甘道夫点燃烽火台时，影厅着火了。可能是影厅自带4D功能吧（笑)</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035294.jpg" alt="天幕新彩云" /><figcaption aria-hidden="true">天幕新彩云</figcaption></figure><h2 id="再来说一下这三部电影剧透预警">再来说一下这三部电影（剧透预警）</h2><h3 id="攻壳机动队">攻壳机动队</h3><figure><img src="https://lain.bgm.tv/pic/cover/l/53/9f/237_a8aEP.jpg" alt="GHOST IN THE SHELL / 攻殻機動隊 攻壳机动队" /><figcaption aria-hidden="true">GHOST IN THE SHELL / 攻殻機動隊 攻壳机动队</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220037972.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：90</p><p>关键字：哲学、科幻、赛博朋克</p><p>锐评：《攻壳机动队》，押井守导演，1995年首映。影片风格朦胧，节奏工整饱满，平衡统一。科幻构想和哲学思考作为一部27年前的电影相当前卫。</p><h3 id="峠qiǎ-最后的武士">峠(qiǎ) 最后的武士</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182351048.jpeg" alt="峠 最后的武士" /><figcaption aria-hidden="true">峠 最后的武士</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220039035.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：84</p><p>关键字：复古、时代、剑戟</p><p>锐评：本来刚看完的时候我给它了非常高的评价，现在回想了以后还是适当下调了一点。在剧中，役所广司饰演的主角是一个思想开阔的和平主义者，但在历史的剧变中被困在了最后一个武士的躯壳里。一个思想先进的人，因为要坚守忠义，被迫守卫行将就木的秩序。整部电影的节奏是庄严肃穆的时代感，正如刘慈欣所说“时间静默地切开一切”，而我们只能看着主角在时代的剧变中一步步走向自己的悲剧。影片中也有温馨的“闲笔”，例如八音盒以及舞蹈情节，调剂了肃穆的基调。役所广司的表演相当精彩，没得说。本片的缺点在于：运镜上世纪五六十年代那味儿太重了，有点刻意了；而且对战争场面的刻画并不尽如人意；没有特别好地展现主角的国际视野和和平主义精神，只是由主角的嘴说出，并没有太多的行为等其它侧面来刻画。不过瑕不掩瑜，值得一看！</p><h3 id="平家物语-犬王">平家物语 犬王</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220040886.jpeg" alt="犬王" /><figcaption aria-hidden="true">犬王</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220040966.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：89</p><p>关键字：表现主义、音乐、live、汤浅政明</p><p>锐评：汤浅政明导演。汤浅政明是现代动画总最具想象力和无拘束的监督之一，这部作品和他之前的作品，例如《春宵苦短，少女前进吧！》一样，深具表现主义风格。影片中live场景很多，演出极具张力，在电影院看非常震撼。故事很简单，基调有些悲戚苍凉。用琵琶演奏出电吉他音色很神奇。另外，这是这三部电影里唯一有特典的一部。希望别的电影也能有点特典233333</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高中记忆拾贝</title>
    <link href="/2022/07/26/%E9%AB%98%E4%B8%AD%E8%AE%B0%E5%BF%86%E6%8B%BE%E8%B4%9D/"/>
    <url>/2022/07/26/%E9%AB%98%E4%B8%AD%E8%AE%B0%E5%BF%86%E6%8B%BE%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>转载自个人公众号。</p><span id="more"></span><h2 id="高三">高三</h2><p>说起高考，我对高考，或者“高三”的记忆是什么呢？两年过去了，如果让我说起我对高三的TOP印象（不分顺序），可能会有如下几个场景：</p><ol type="1"><li><p>第一节晚自习下课，和基友一起在操场散步，谈论二次元。他给我口述动画片，不得不说确实挺好看。操场上灯光并不是很亮，我俩就看着像月亮一样的灯光绕着走圈圈。后来我给他送了这个动画片的原作。</p></li><li><p>高三唯一一次哭，是因为理化生三科改理综以后我突然之间就获得了很大很大的优势（因为我自己写字比较快，能答完。好多大佬不会安排时间，第一次没答完题）。然后理综练得越来越多，大家越来越熟练，我的优势突然之间就没有那么大了，就突然慌了，然后当时杂乱的事情又比较多，就一下子就崩溃了，不过好得也很快。后来一看，这算啥事儿啊2333.</p></li><li><p>模考不想去了，直接给老师发个短信说不想去了，然后和父母看电影，散步，逛公园。爽。</p></li><li><p>每次模考完了以后，成绩当晚就出了。老师就拿着那张排名单往教室后面一贴，大家都怀着忐忑的心情一拥而上。</p></li><li><p>五楼考场，阳光明媚，闭着眼睛吹风，很舒服。不过我每次在五楼都发挥得不是很好，不知道为啥。</p></li><li><p>5月12日，放假。我写了一张大表安排时间，把座位搬到了落地窗前，“悠然见南山”，真的是终南山噢！然后严格按照这张大表复习，效果真的特别特别好。爸爸的厨艺在这一个月也增长很多。非常快乐，非常好。</p></li><li><p>和同桌一起体育课在操场打羽毛球。我们每次体育课都打球，其他人好多都拿个小本本在卷，不过他们都卷不过我俩 哈哈哈哈。</p></li></ol><p>啊，想不起来，就这些吧。我曾经问过我那个基友和那个同桌“你觉得高三生活是‘地狱’吗？”，他们都斩钉截铁地回答，不是。没有什么拼搏的汗水，没有什么崩溃的泪水，没有动员会上的热泪盈眶，没有什么地狱般的生活，普普通通地过完了，拿到了自己最期望的高考成绩，不多不低。网上人说的那些，纪录片、电视剧里说的那些东西一个都没出现。没什么实感就结束了。</p><p>整个高三一年，我根本没有什么“熬夜学习到凌晨两三点”，“拼命学习”，“刷完了多少本题”，“追着老师问问题”，“用完了多少笔芯”之类的“拼搏”的经历;也没有做到“杜绝一切娱乐”,基本上每天都能玩到手机（家长不太管），我高三甚至看完了一套凉宫春日小说，补了三四部番，还听了很多音乐（主要是东方吧）。甚至在6月6日晚上，我也是照常看了2集动画片（我还记得，是少女歌剧）然后平常地睡觉了。总之，整个高三，我就是平平常常的，老师说什么，我就干什么，基本上就是完成作业，额外做的题特别少。学校要求6：50到校，我基本6：45到；23：30放学我基本上不会拖超过5分钟。</p><p>太平淡了，啥也没有，就这样结束了。</p><p>所以我才会关注高考新闻，想凭吊一下青春吧，哈哈哈哈。</p><h2 id="高一高二">高一高二</h2><p>上次写了高三，这次就来写写我的高一和高二。说实话，高一和高二的生活，真的比高三有意思很多。如果要找“ Gauss 节点”的话，大概有这么几个节点：</p><ol type="1"><li><p>高一的朗诵比赛，我们选的是《长恨歌》，不得不说效果是真的非常非常好啊，尤其是那位女同学“迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共？”的时候，真的，都差点哭出来了。虽然最后得的奖不是很高（现在想起来也有点生气，made),但是算是高中三年生活的一个很好的开始吧。</p></li><li><p>然后就开始学电竞，刷OJ。之所以学电竞是被朋友撺掇的，当时电脑课老师问有没有学电竞的，他先举手，然后又把我的手举起来了，于是就开始学电竞。我高中三年最正确的选择之一，居然是别人替我作出的，哈哈哈哈。</p></li><li><p>第一次月考，考完运动会。班主任是位生物老师，她把我拉去帮忙改卷子了。之后我的生物一直学得非常好，或许应该好好感谢她。</p></li><li><p>电竞上课要上到很晚，有一次我们练习完了以后，整个教学楼全黑了，好几扇门也锁起来了。我们转了几圈终于出去了，哈哈大笑。</p></li><li><p>我的经历就是到了这个高一结束，竞赛课内两开花，成绩都挺好。然后班主任就把我调到竞赛班去了。我说另请高明吧，我实在我也不是谦虚，她说别的老师已经把你夸上天了，我就念了两句诗，叫：“...”（其实没念）。我实在是不觉得这个竞赛班是个好东西，一开始我们开了个班会，常务副校长同志语出惊人：“你们难道来高新一中就是为了上个西交吗？”，一下子给我整麻了。后来发现这竞赛班tm真不是人待的地方，整个物理“动量”部分就讲了十分钟，然后就发一堆难度巨大的题让做，我哪里会做，然后就啥也没学会。期中考试考了个全年级四百多名，洗澡的时候在浴室哭了一场，”心之壁“ DEF+5000。然后就爬回了一个“重点班”（高新一中有三级班：平行班、重点班、竞赛班）。于是我就刷到了一个成就：在高一一年，遍历高新一中的所有级别班次，听过所有理科老师的课程。</p></li><li><p>竞赛班没有作业，也不学文科。但是到了重点班突然要考文科，我直接发动【高速制作】，期末的文科三科考了285分，超高吧，嘻嘻。</p></li><li><p>高二我就来到了四班，其实我还是很喜欢四班的，在这里认识了几个好朋友。不过我的高二生活的前半段主要是在学竞赛，就在那个三楼的《网络实验室》里，做题，刷题，讲题，中午就听音乐，直到很晚才回家。第一次吃了学校的晚饭，挺难吃的。假期上课的时候就和同学们一起过马路吃肉夹馍。这段时光确实非常的快乐，肆意吮吸知识的感觉，非常非常的爽。也认识了好朋友，直到现在都是好朋友。但是做题就是另一回事儿了哈哈哈哈哈。看了珂朵莉，很好看。</p></li><li><p>高二暑假的时候非常非常的热。那时候有个梗图，说西安地表温度65度，吐鲁番63度。每天下午，我们要从高新一中走到初中部去上课，哈哈哈。</p></li><li><p>2017年11月11日，我永远记得。D1T1当场把我送走。当天中午心态基本就崩溃了。D2发挥的比D1好，但是也无济于事。然后就心态很崩嘛，当时刚好看完了珂朵莉，那心情，哎，你懂吧又哭了几场。也很感谢家长，和竞赛的队友，和班里的同学能及时把我拉起来，”心之壁“DEF +10000.</p><p>然后七天以后就是期中考试，理所应当地考了倒数。不过值得吹一下的是，生物还是仅仅用学过了的知识依然拿到了全班前十。</p></li><li><p>凉宫春日是我永远的光。我永远爱凉宫春日。没有凉宫春日就没有现在的我。虽然主要还是我自己努力的原因，如果说父母同学输入的是活化能，那么她就是大大降低了活化能的催化剂。一个月学完一个学期所有科目，从倒数第一拿到全班前十，奇迹的复活！</p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207262350119.jpeg" alt="奇迹の复活" /><figcaption aria-hidden="true">奇迹の复活</figcaption></figure><ol start="11" type="1"><li><p>高二下的一开始就是学考。学考组织了四次模拟，如果政史地理化生中任意一个科目考的分不是很高，就要《补习》。但是我一次都没《补习》。甚至历史还进入过全校前十，整得文科班老师对着他们班大发雷霆：你们就连个理科生都考不过吗？</p></li><li><p>高一高二的时候我们组织了研学旅行，分别是去了关中民俗博物院、白鹿原、华清池，一个我忘了名字的红色景点，和一个我忘了名字的山水景点等，还是很快乐的。</p></li><li><p>有一天早上起来发现下了大雪，学校停课了，于是直接去看了《星球大战》的电影。</p></li><li><p>暑假，入坑了东方。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人看过的各动画锐评：二</title>
    <link href="/2022/07/17/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84%EF%BC%9A%E4%BA%8C/"/>
    <url>/2022/07/17/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84%EF%BC%9A%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本文记录我看过的各动画作品，不一定全，也不一定看完了，电影动画都有。然后可能会进行个人主观感受相当强烈的《锐评》。在评价中，个人的情绪、心理、主观观感有相当大的比重，评价也很短，很随性。所以如果和你心目中的差距比较大不要喷哈。</p><p>如果真的要写长评或者认真去评价我会写单独的文章，这个就看一乐。</p><p>第一部分合集：<a href="https://blog.sakizuki.site/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/">本人看过的各动画锐评：一</a></p><span id="more"></span><p>简要评分标准如下：</p><table><thead><tr class="header"><th>评分</th><th>标准</th></tr></thead><tbody><tr class="odd"><td>95+</td><td>【极优】非常优秀的作品，让我印象深刻</td></tr><tr class="even"><td>85+</td><td>【优】各方面都很优秀的作品，或有非常打动我的长处</td></tr><tr class="odd"><td>75+</td><td>【良】良好的作品，我心中的“平均水平”</td></tr><tr class="even"><td>60+</td><td>【合格】合格的作品，没有什么亮点</td></tr><tr class="odd"><td>60-</td><td>【不合格】有明显短板的作品，不堪卒读</td></tr></tbody></table><p>当然上面的“平均水平”的意思是全部动画的平均水平，而不是我看过的平均水平。我尽量把平均分控制在85分左右。</p><h2 id="凉宫春日的消失100">凉宫春日的消失：100</h2><figure><img src="https://lain.bgm.tv/pic/cover/l/9b/9b/3375_33BCV.jpg" alt="凉宫春日的消失" /><figcaption aria-hidden="true">凉宫春日的消失</figcaption></figure><p>个人评分：100</p><p>关键字：穿越、科幻、京阿尼</p><p>锐评：我在前一篇里面说《叛逆的物语》是我第二喜欢的动画电影，那么《凉宫春日的消失》就是我最喜欢的动画电影。自从我第一次看完这部电影以后，每年的12月18日，我都多了一项固定的活动：观看《凉宫春日的消失》。这部作品对我的影响非常大，甚至于塑造了我近年来的三观。</p><p>《凉宫春日》对我来说，很可能就是我热爱动画的意义所在。</p><blockquote><p>要到几岁才开始不相信圣诞老人的存在，这种无聊到家的话题对我来说根本不痛不痒的，不过，如果说到我是几岁开始不相信圣诞老人，那个只存在于幻想世界的穿着红衣服的老公公的存在，我能很确定的说，我根本打从一开始就不相信，我知道幼儿园圣诞节庆祝会时出现的圣诞老人是假的，即使没有撞见老妈正在亲吻圣诞老人，机灵的我也早就怀疑只在圣诞节才工作的老头子是否真的存在了，不过，那些外星人、未来人、幽灵、妖怪、超能力者，还有邪恶组织以及和他们战斗的动画特摄漫画英雄，我发现他们根本不存在于这个世界的时候已经很晚了，不，说不定我早就发现了，只不过一直不想承认而已，因为我的内心深处是十分渴望那些外星人、未来人、幽灵、妖怪、超能力者，还有邪恶组织能够出现在眼前的，不过，现实却是意外地残酷，于是我开始常常惊叹世界的物理法则是多么正确，不知何时开始我就不再热心地观看电视上的UFO特别节目或灵异节目了，宇宙人？未来人？超能力者？这种东西怎么可能存在嘛，不过还是希望他们存在啊...我就像是参考着真实与幻想之间的最大公约数般渐渐地长大了，初中毕业之后，我也从这种小孩子的幻想中毕业了，逐渐习惯了这个世界的平凡，我就这样没啥感慨地成为了高中生——然后遇到了那家伙.....</p></blockquote><p>要到几岁才开始不相信圣诞老人的存在，我能很确定地说，我根本打从一开始就不相信。我们每个人小时候总是充满着各种各样的幻想，甚至是一小段枯燥的文字也能唤起我们无限的遐想，看着一个普普通通的飞机模型，就可以想象这架飞机是怎么遨游在蓝天上的，看着泡澡时泡沫在水中出现又消失，脑中已经在想象一个历经千年波澜壮阔的“泡沐帝国”的兴衰荣辱了，更不要提把三角板夹到笔夹上当战斗机这种事情了。可是当我们长大后，在周围各种各样人无数次地提醒下，我们会不再相信那些不存在的幻想，而只会去关心诸如一日三餐这种一成不变而又真实存在的日常琐事，只因为我们被告知现实就是现实，渐渐地我们开始变得麻木，开始变得循规蹈矩，开始变得安于现状。我们被人无数次地提醒着，现实就是现实，梦想就是梦想。一个人还没找齐的小小社团说自己要进军全国第一，这是梦想；一个小小城市里的普通初中生说自己要上清华北大，这是梦想；都上中学了，也该有点对现实的自觉了吧？</p><p>而凉宫春日则不这样，她不在意什么现实，而只是跟着那些虚无的想法前进。当然，这样的人在现实世界中几乎看不到，那么我们不妨把它当作作者的“理想模型”。而回首人类历史时，我们不难发现，正是“幻想”，正是“虚无的想法”，推动了人类文明的进程。人类的历史就是幻想的历史，人类的历史正是由一个一个的“团长”们写就的。</p><p>一个在地上生活了几万年的物种，突然说自己要飞上蓝天，在二百多年前，这还是十足的幻想。但是现在呢？人类不仅飞上了蓝天，还登上了月球，人类的双手的延申、人类的眼耳的延申，人类的思想的延申，已经到达了冥王星轨道，甚至已经越过了太阳系，向着更远处的星空前进。这，还是幻想吗？</p><p>自古以来只有大雨天才会降下的白色神罚，在三百多年前，这还是十足的幻想。但是现在呢？这天下降下的神罚已经走进了每一家每一户的角落，我能写下这篇文字，也要拜这小小的电流所赐。这，还是幻想吗？</p><p>过直线外一点至少有两条直线与之平行，在四百多年前，这当然是异想天开，是十足的幻想。可是非欧几何成了相对论的基础，现如今所有的定位卫星离了相对论都无法工作。这，还是幻想吗？</p><p>决定人类行动的是情感，推动时代前进的呢？正是那些满怀梦想，充满激情，大胆想象的狂人亦或是疯子们一次一次地用超乎寻常的想象力改变了我们习以为常的世界。而动画艺术，对我而言就象征着想象力，一切都没有限制，在一个个奇妙有趣的异世界中，我们流泪欢笑，一切都是那么地富有激情和浪漫色彩。这也正是我热爱动画艺术的原因。</p><blockquote><p>Day by day うんざりだよね だから</p><p>Day by Day 生活是如此腻味</p><p>堂々と断っちゃう 君になりなよ</p><p>你该堂堂正正拒绝 随心所欲地活着</p></blockquote><p>说完了《凉宫春日》的精神，该说说《凉宫春日的消失》这部电影本身了。这是一部堪称完美的剧场版动画。接近3个小时的片长，绝佳的制作水平（甚至为了体现人物的心理活动，在多处制作了细致的人物表情。而表现手法也深入人心，我印象最深的一段是：阿虚问三味线，你能听懂我说话吗？能就伸右手，不能就伸左手，而三味线的回答则是打了个滚。一段生活中的小小片段，就把世界和阿虚断绝关系的疏远感和无助感体现得淋漓尽致。他心中的疑问，只能被这冰冷世界的表面所反射，少年想做的事情并非是这个世界需要他做的事情，他能听到的并非世界的呼唤，而是自己的发问在这庞大世界中空洞的回音。而原作中大段的心理描写，在电影中则以意识流来处理，而这一段，以标志性的“阿虚踩自己”为代表，也堪称影史经典了，多说无益，自己去看看吧！配乐采用了钢琴曲为主的配乐，即使直接把OST拿出来也很好听。这部电影是没有短板，堪称完美的六边形战士，是《凉宫春日》系列动画中最浓墨重彩的一笔。</p><h2 id="颠倒的帕特玛73">颠倒的帕特玛：73</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207180050015.jpeg" alt="颠倒的帕特玛" /><figcaption aria-hidden="true">颠倒的帕特玛</figcaption></figure><p>个人评分：73</p><p>关键字：科幻，反乌托邦，爱情，世界观</p><p>锐评：一部很可惜的作品。世界观和设定是很亮眼的，可惜用了这么个世界观讲了一个观感一般的故事，感情线也有点粗糙，颇有高汤煮泡面的感觉。</p><h2 id="普罗米亚85">普罗米亚：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207180053299.jpeg" /></p><p>个人评分：85</p><p>关键字：作画，奇幻，燃</p><p>锐评：底子是一个很王道的故事，但是这么一个王道的故事做出来的整体质量很不错。就像是我来朗读《滕王阁序》和人家朗诵家来朗读《滕王阁序》一样，底子是一样的，但是观感就是有区别。情节安排方面，很紧凑，没什么尿点。而艺术风格就非常亮眼了，非常有扳机社风格，大色块，三角形。一言以蔽之：曰：燃得批爆，值得一爽。</p><h2 id="秒速五厘米80">秒速五厘米：80</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242234613.jpeg" /></p><p>个人评分：82</p><p>关键字：恋爱、新海诚、小品</p><p>锐评：挺好看的一个小片子，就是看着也太着急了，急死我了。不知道为什么，第一个故事给我的感触是最深，最有代入感的，但是我明明没有经历过这样的事情，怎么回事呢？可能只是因为我在雪中坐过公交车？搞不明白了，哈哈。</p><h2 id="朝花夕誓于离别之朝束起约定之花83">朝花夕誓——于离别之朝束起约定之花：83</h2><p><img src="https://lain.bgm.tv/pic/cover/l/0e/1e/218971_PC00Z.jpg" /></p><p>个人评分：83</p><p>关键字：亲情、奇幻、治愈、温柔</p><p>个人锐评：一部很温柔的电影。画面精良，镜头也没什么大差错。整个电影就给人一种娓娓道来的，温柔平和的感觉，人物情感丰富，设定引人入胜，鉴定为好。</p><h2 id="福音战士新剧场版序85">福音战士新剧场版：序：85</h2><p><img src="https://lain.bgm.tv/pic/cover/l/e5/7c/772_yFW6i.jpg" /></p><p>个人评分：85</p><p>关键字：高清重制、EVA、科幻、萝卜</p><p>锐评：就是高清重制版，画质和节奏都比TV好不少，鉴定为彳亍。美术风格就是完全的痞子风辣。</p><h2 id="福音战士新剧场版破90">福音战士新剧场版：破：90</h2><p><img src="https://lain.bgm.tv/pic/cover/l/6f/ab/3302_rEfZV.jpg" /></p><p>个人评分：90</p><p>关键字：EVA、科幻、萝卜</p><p>锐评：从这部开始就不是高清重制版了，对剧情走向有比较大的改动。整体基调比TV积极（......），两段的配乐还是很震撼人心的，虽然不知道为什么，可能这就是艺术吧。</p><h2 id="福音战士新剧场版q52">福音战士新剧场版：Q：52</h2><p><img src="https://lain.bgm.tv/pic/cover/l/a6/bb/22505_O197k.jpg" /></p><p>个人评分：52</p><p>关键字：EVA、科幻、萝卜</p><p>锐评：垃圾得一批，没看终之前还以为看不懂是我的问题，看了终以后才知道就是这作品的问题。故事云里雾里，人员全员谜语，叙事完全失败。等于只有画面和配乐能给点分了。这人设我还不太喜欢，我的第一部不及格献给这部作品。</p><h2 id="福音战士新剧场版终90">福音战士新剧场版：终：90</h2><p><img src="https://lain.bgm.tv/pic/cover/l/04/dc/29883_jQ4Hz.jpg" /></p><p>个人评分：90</p><p>关键字：EVA、科幻、萝卜、告别</p><p>锐评：一部非常好的告别作。虽然看完以后还有很多谜团没有解开，不过也不需要在意了，就是这样的感觉。剧里剧外的人都补完了，再见了，所有的EVA。</p><h2 id="平家物语82">平家物语：82</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208271617155.jpeg" alt="平家物語 平家物语" /><figcaption aria-hidden="true">平家物語 平家物语</figcaption></figure><p>个人评分：82</p><p>关键字：历史，山田尚子，温柔</p><p>锐评：这部动画原创了一个叫做“琵琶”的人物作为主视角，时间流转，她却不会老去。琵琶的眼睛能预知未来，我们也早已知晓了平家的未来，琵琶似乎是观众的化身。这个创意还是很有意思的。整体观感，怎么说呢，就像用红楼梦的打开方式看三国演义。本片艺术风格采取了和版画、浮世绘风格类似的画风，很有特点；细节安排丰富，美术引人入胜，镜头也比较有实验性。但本片信息量实在太大，对于不具备相关历史知识的人而言看起来有些费劲；且本片对“悲剧”的刻画似乎并不完美，在很多地方用喜剧化的演出来表现悲剧，有些煞风景。总而言之，是一部佳作，希望山田尚子再接再厉（</p><p>最后提醒大家：坚持辩证唯物主义，不要发毒誓，神仙收命不办事，说的就是你，平重盛</p><h2 id="龙与雀斑公主73">龙与雀斑公主：73</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209050015658.jpeg" alt="竜とそばかすの姫 龙与雀斑公主" /><figcaption aria-hidden="true">竜とそばかすの姫 龙与雀斑公主</figcaption></figure><p>个人评分：73</p><p>关键字：音乐、vtb</p><p>锐评：这个电影，在电影院和不在电影院看，完全是两种体验。为什么呢？因为它的音乐很好听但是剧情太拉跨。人物太多，有些人物不知道出现的意义是什么；内容太多，看得出来想讲很多东西，但是东一榔头西一棒槌，一个也没讲深入。不过至少故事比泡泡好，哈哈。而且女主和她爸那个亲情线还挺温馨的。另外，我觉得女主本身比她在U世界里面那个皮好看。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈什么是二次元</title>
    <link href="/2022/07/07/%E6%B5%85%E8%B0%88%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    <url>/2022/07/07/%E6%B5%85%E8%B0%88%E4%BA%8C%E6%AC%A1%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>从“原神是不是二次元”说开去。</p><span id="more"></span><p>原神是不是二次元呢？在文章的一开始，我可以给出答案：在我心中，原神是二次元。</p><p>那么，什么是所谓的“二次元”呢？二次元，在平常的语境中，有两种含义。第一种，是指二维动画艺术，及其衍生作品，第二种含义，则是喜欢第一种作品的人。在我看来，这两种含义是有机地结合在一起的。</p><p>我第一次接触现代网络上最普遍意义的“二次元”，应该是在高一刚刚开学，也就是2016年的10月份。基于各种机缘巧合<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="说来搞笑，这里的“机缘巧合”是我在看一个《康熙怒斥群臣》的鬼畜时，“正大光明匾”升上来的一刻，弹幕里有人发了个“御坂美琴”。">[1]</span></a></sup>,我看的第一部是“二次元”是《某科学的超电磁炮》。但是很神奇的是，在接下来的一年中，我自己只是在不断地，一遍又一遍地去看这一部动画（实际上是两部，毕竟还有一个S）。所以说我认为，我真正的“入宅番”并不是《某科学的超电磁炮》，而是《末日时在做什么？有没有空？可以来拯救吗？》。在看过这部以后，我才开始找各种“二次元”动画片看，后来又陆续看了《凉宫春日的忧郁》，《工作细胞》，等等，不再一一列举了。后来在大学，我又在学校的二次元社团（也是学校最大的社团）里，担任了2-3年的职务。</p><p>那么在我心中，什么是二次元呢？其实我自己在选阅作品时是有一种很强烈的倾向的，也就是我很喜欢“幻想艺术”。相比于基于所有人的常理所构建的世界的作品，我更喜欢奇幻、科幻，这种“给世界一刀，看世界带伤运转”的作品。这一点，从我的博客的封面图也可以看得出来。为什么呢？我想，我在欣赏“二次元”作品时，是在躲避现实世界。</p><p>这时候，你就要说了：桀桀，又避世了吧？所以说二次元都是现实世界不如意的fw。是这样的吗？不是。如果真的说“避世”，那可能确实有一点。但是我之所以用了“躲避”，而不是“逃避”，正是为了说明这一点。躲避不同于逃避，逃避有恐惧的含义，而躲避，只是累了。二次元不等同于“社恐”，也不等同于“死宅”，当然也不等于“没有男/女朋友的人”（笑）。我可以白天在底下坐着几百人的讲台上激情洋溢地讲课，也可以和期中考试挂科了的同学坐下来谈心，但这不影响我到了晚上点开一集动画片，和美少女们在剑与魔法的世界中遨游吧？我不恐惧社交，也不是不擅长与社交，我只是很单纯的，不喜欢社交。现实世界太累了，压力太大了，人和人打交道，总要我打起十二分精神，开动所有的CPU，算这，算那。于是我选择了一个更加温暖柔情的世界来做我的避风港。</p><p>那么为什么王者荣耀在我眼中不是二次元，而原神则是呢？明明看艺术风格，王者荣耀也挺二次元的。没错，艺术风格只是一方面，“二次元”这个概念最核心的东西是和内容相关的，是提炼出来的那种纯粹。这种纯粹既可以理解为对现实世界的简单化，也可以理解为对现实世界的升华。王者荣耀这种游戏，激励人玩下去的是“人超越人的快乐”，是“人与人”之间的优越感，是“人与人”之间的攀比心。我这里这么强调“人与人”，正是为了说明，这样的游戏的本质还是社交，是现实世界中人和人的关系。而促使包括我自己在内的很大一部分人游玩原神的动机，则是为了体会那个风和日丽，鸟语花香，高山大川，千里冰封的“异世界”。甘雨一箭的伤害是一万还是十万很重要吗？圣遗物是暴击爆伤还是生命防御很重要吗？在一个小黑屋里杀光敌人，是用了一分钟，还是用了30秒，这很重要吗？当我驻足在风神像前，用风物之诗琴朴拙地弹奏一曲仅仅在我脑中存在过的旋律时，当我看到浅濑神社门前的猫猫云彩时，当我登上寒天之钉俯瞰大陆时，我想，这才是我游戏的意义。可以看出，这个相比现实世界更加温暖柔情的世界正是担当了我的避风港。因此，在我看来，原神是二次元，证毕。</p><p>当然，也有喜欢《原神》的人们，他们更关心在一个小黑屋里杀光敌人，是用了一分钟，还是用了30秒，或者说，他们关心的是有没有比别人更快。那么在这样的玩家看来，原神就不是二次元。在喜欢看剧情，喜欢看人物介绍的人看来，明日方舟是二次元；在把所有人物都当作数值和机制的集合，当作“塔”，一心一意地只为了拿到全世界最快的满级危机合约的玩家看起来，明日方舟就不是二次元。当然，这些玩家没有高下之分，这里说的，只是“是不是二次元”。</p><p>写到这里，可以说“二次元”理论的大厦已经基本建成了，只是上空还漂浮着两朵乌云。</p><p>首先，你刚刚说过，“二次元”这个概念最核心的东西是和内容相关的，是提炼出来的那种纯粹。那么我就要问了，照你这么说，电影电视剧也是二次元！小说也是二次元！这合理吗？</p><p>是的，这不合理。首先我们来说说电影电视剧的事。电影电视剧有一个特点，那就是它们是“实拍”的。无论特效做得再花里胡哨，这改变不了它们是实拍的本质。既然是实拍，那么我在观看的时候，就会不由自主地往真正的现实世界上去投影。我就会想，这些事情怎么可能发生呢？在现实世界里，他们肯定会这样这样，那样那样，然后怎样怎样~，最后落得一个悲惨的下场，所以说这电视剧拍得一点都不好。但是在观看动画作品时，和现实世界略有相似却大相径庭的画风每时每刻都在提醒我：这是你的避风港，把你的那些CPU都关掉，放松一下吧。</p><p>至于小说是不是二次元，在我看来是很模糊的。毕竟还有“轻小说”这种东西。不过我倾向于认为：小说就是二次元！因为在读小说的时候，我在脑子自然地构建着一整个世界。这就是文字艺术的魅力。（P.S. 当然，主角是美少女的最好。）</p><p>好好好，算你混过去了。那么第二点，我要一击致命了！那就是：动漫社为什么会存在？既然你们“二次元”都在躲避社交，那么一群二次元们怎么混在一起社交，不觉得矛盾么？所谓的动漫社，不过是现充聚会罢了！</p><p>必须承认的是，动漫社里面有现充<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="现充分为严现充和宽现充。严现充特指有男/女朋友的人；而宽现充则指有现充行为模式的人。现充行为模式是一套现充的行为模式（什么废话），包括但不限于：吃饭时，打球时，看电影/电视剧/动画时不专注于自己正做的事情，而专注于聊天；乐于社交（注意，还是提醒各位读者，乐于不同于擅于，不乐于不同于不擅于）等。严现充和宽现充不互相包含，但大部分严现充都是宽现充。这里的现充指的是宽现充。">[2]</span></a></sup>。但是，二次元也不少。为什么呢？二次元们躲避社交，不代表二次元们不需要社交。二次元和二次元之间，当然可以有基于二次元形成的纽带。当御坂美琴拿出硬币时，当珂朵莉拿起不属于她的杀人圣剑冲向无边无际的兽之海时，当凉宫春日大声说出“让世界变得更热闹”时，当阿瑠的歌在阿瑠死后不知道多少年响起时，当鹿目圆献出自己的“存在”来消灭魔女时......当在满屏“泪目”弹幕的那一刻，我，确实能感受到有很多和我一样的二次元宅宅，在为了虚拟世界中的虚拟女孩感动。那一刻，我们的心是连在一起的，是通过一个名叫“鹿目圆”的虚拟世界的虚拟女孩连在一起的。在某种意义上，在这一刻，我们这些素昧平生的二次元之间的距离，比我在现实世界中打起十二分精神，开动所有的CPU，算这，算那，来进行社交的对象的关系近得多。在人与人之间真诚地交流自己的兴趣时（当然这里的兴趣并不局限于二次元），也就不需要打起十二分精神算这算那了。因为此时的人是单纯的人，此时的世界是单纯的世界。这一刻联系着我们的，并不是所谓的“社交技巧”，甚至不是二次元作品本身，在我看来，这一刻联系着我们的，是人类的本性，是对善良和爱，感动和泪水，正义和激昂的确信。在这一刻，我似乎相信，即使在现实世界中，也有人在追寻着理想国。于是，我便能关掉CPU，放下十二分精神，只用自己的本性，和同好们畅谈鹿目圆，畅谈珂朵莉，畅谈阿瑠，畅谈他们背后的人类的最最美好的品性，和平时并不相信存在的理想国。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>说来搞笑，这里的“机缘巧合”是我在看一个《康熙怒斥群臣》的鬼畜时，“正大光明匾”升上来的一刻，弹幕里有人发了个“御坂美琴”。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>现充分为严现充和宽现充。严现充特指有男/女朋友的人；而宽现充则指有现充行为模式的人。现充行为模式是一套现充的行为模式（什么废话），包括但不限于：吃饭时，打球时，看电影/电视剧/动画时不专注于自己正做的事情，而专注于聊天；乐于社交（注意，还是提醒各位读者，乐于不同于擅于，不乐于不同于不擅于）等。严现充和宽现充不互相包含，但大部分严现充都是宽现充。这里的现充指的是宽现充。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人看过的各动画锐评：一</title>
    <link href="/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/"/>
    <url>/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>本文记录我看过的各动画作品，不一定全，也不一定看完了，电影动画都有。然后可能会进行个人主观感受相当强烈的《锐评》。在评价中，个人的情绪、心理、主观观感有相当大的比重，评价也很短，很随性。所以如果和你心目中的差距比较大不要喷哈。</p><p>如果真的要写长评或者认真去评价我会写单独的文章，这个就看一乐。</p><span id="more"></span><p>简要评分标准如下：</p><table><thead><tr class="header"><th>评分</th><th>标准</th></tr></thead><tbody><tr class="odd"><td>95+</td><td>【极优】非常优秀的作品，让我印象深刻</td></tr><tr class="even"><td>85+</td><td>【优】各方面都很优秀的作品，或有非常打动我的长处</td></tr><tr class="odd"><td>75+</td><td>【良】良好的作品，我心中的“平均水平”</td></tr><tr class="even"><td>60+</td><td>【合格】合格的作品，没有什么亮点</td></tr><tr class="odd"><td>60-</td><td>【不合格】有明显短板的作品，不堪卒读</td></tr></tbody></table><p>当然上面的“平均水平”的意思是全部动画的平均水平，而不是我看过的平均水平。我尽量把平均分控制在85分左右。</p><h2 id="赛马娘-pretty-derby-第二季-83">赛马娘 Pretty Derby 第二季 ：83</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335693.jpeg" alt="赛马娘" /><figcaption aria-hidden="true">赛马娘</figcaption></figure><p>个人评分：83</p><p>关键字：励志、运动、拟人、<del>轻百合</del></p><p>锐评：好动画，节奏合适，燃虐有度。本动画可以做到合理改编历史事实，抓住主要矛盾，删除没必要体现黑暗的一面并加入偶像元素，使得动画的一体性更高，不至于有割裂感。就论故事来说其实也就是关于梦想和挫折的故事，的一个制作比较优秀的动画。但是这个改编实在是太新奇了，竟然把赛马这一项运动改编成动画，不得不打个高分。</p><h2 id="奇巧计程车95">奇巧计程车：95</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335781.jpeg" alt="taxi" /><figcaption aria-hidden="true">taxi</figcaption></figure><p>个人评分：95</p><p>关键字：群像、推理、<del>叙述性诡计</del>、剧情向</p><p>锐评：其实我自己对这种有叙述性诡计的作品就自带了好感度（久美子：这是什么？听起来有点色情）。最有趣的是本作的叙诡只有依靠“动画”这一载体才能实现（类似于《罗杰疑案》的叙诡只有依靠文字才能实现？hhhh），所以在我心中非常加分。</p><p>而且本作剧情相当优秀、环环相扣；都市感很强；人物群像塑造不空洞，而且有我很喜欢的画面（比如那个月下飞车）。一点点小遗憾在于一个很重要的剧情依赖巧合推动，有一点点操纵剧本的脱离感。</p><h2 id="泡泡61">泡泡：61</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335770.jpeg" alt="bb" /><figcaption aria-hidden="true">bb</figcaption></figure><p>个人评分：61</p><p>关键字：后新海诚、奇幻、恋爱</p><p>锐评：这部作品平庸到了极点，尽管STAFF各种牛逼，又是虚渊玄又是泽野弘之又是荒木哲郎的，但是做出来的东西只能说是感觉不如新海诚。那么这是怎么会事呢？</p><blockquote><p>配角1: シン (shin) 配角2: カイ (kai) 配角3: マコト (makoto)</p></blockquote><p>只能说是一目了然不言而喻了好吧。当然我这里只是说平庸，而不是说差劲。之所以说平庸，是因为我感觉这几个staff肯定能做出更让人眼前一亮的东西，这个只能说是让人十分失望。但是就片论片，画面和音乐都还算是比较好，算是及格了吧。</p><p>如果日后人们分析日本动画电影时提到“后新海诚主义”，那么这部作品一定首当其冲，作为代表性平庸之作载入史册。这里推荐赵冰的《固守与超越：美日动画电影母题研究》，有兴趣的不妨看一看。</p><h2 id="魔法少女小圆叛逆的物语96">魔法少女小圆：叛逆的物语：96</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335986.jpeg" alt="pn" /><figcaption aria-hidden="true">pn</figcaption></figure><p>（或有剧透）</p><p>关键字：剧情、百合、魔法少女、战斗、<del>看不懂</del></p><p>个人评分：96</p><p>锐评：神作！这是我心目中第二好看的动画电影。整个剧情看下来虽然初看不是很能看懂，但是其实很讲框架和逻辑，剧情发展得非常正规。而最后的转折更是画龙点睛之笔，如果整部作品在圆神把晓美焰接走后结束，那就太太太遗憾了——作为本篇主角的晓美焰，竟然没有为本篇主要矛盾的解决起到最关键的作用吗？可是新房创造性地、开天辟地 地设置了这个场景，设置了晓美焰撕裂圆神而成魔的结局，给本篇的整个结构画上了完美的句号。</p><h2 id="利兹与青鸟86">利兹与青鸟：86</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335970.jpeg" alt="lzyqn" /> 关键字：音乐、文艺、青春</p><p>个人评分：86</p><p>锐评：这部作品应该走的是文艺风，整体风格都比较淡雅，音乐也很好，百合也很好，而且画风和本篇差别比较大。故事淡雅轻灵，作画细致入微，更以嵌入童话的手法来创新叙事。通过清灵的作画、配乐和叙事，本作塑造了一个非常纯粹的世界：没有“世界VS她”的抉择，也没有三角恋，没有本篇中的“政治”因素（笑），有的只是两个高中女生之间细腻而青涩的感情。配乐和故事也进行了非常有机的结合。我在《音乐分析与鉴赏》的课程中就选择了《利兹与青鸟》的第三乐章，得了90好几分。在讨论这部作品时，经常有人讨论谁是利兹而谁是青鸟，在我看来，没有人是利兹也没有人是青鸟，或者说，两个人互为利兹与青鸟。利兹与青鸟童话中的故事不是在暗示霙和希美两人关系的正确解法，而是在暗示霙和希美的现状：两人之间无法传达的心意，和阴差阳错的误解。在电影最后，她们终于了解了自己和对方，真正的抱在了一起，脚步声也从一开始的不同频在最后变成了协调的声音。</p><h2 id="少女歌剧含剧场版87">少女歌剧（含剧场版）：87</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336273.jpeg" /> 关键字：百合、战斗、奇幻、演出</p><p>个人评分：87</p><p>锐评：这个动画我一开始是在19年准备高考的时候看的，看的时候有很多既视感，什么少革小圆的。我的高中在2019年5月12日就放假了，基本上来说，是这部动画陪我走过的高中生涯的最后一个月。至于看的契机，大概是感觉里面的美少女非常帅气吧。本作的剧情虽然有点弱势，但是Revue看着是真的爽，尤其是第一集里面爱城华恋进入地下剧场，然后她跳到舞台中央时的那一段BGM，简直让人颅内高潮。每场Revue加上音乐和歌唱都是一场视听盛宴，可能这就是动画的魅力吧。当然战斗美少女百合CP俺也很喜欢。而剧场版更是扬长避短，用极具张力的演出和音乐不断挑动观众的神经，是一部非常优秀的粉丝向剧场版。</p><h2 id="恋爱小行星78">恋爱小行星：78</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336349.jpeg" /> 关键字：天文、地理、校园、治愈</p><p>个人评分：78</p><p>锐评：这个动画就是比较良好的动画。所谓的“轻百合八股”，就是选取一个小众爱好，加一点校园，加一点美少女，加一点美少女贴贴。比较好的地方在于校园日常的塑造，偶尔会出现那么一两个让我既视感很强的片段，女孩子的人设也很可爱。这部和“传统轻百合”还有一点区别，就是现实主义色彩更加浓重，也有很多三次元的联动。但是缺点没有完全把天文地理的魅力展现出来，知识和动画结合的略有些生硬。</p><h2 id="魔女之旅80">魔女之旅：80</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336761.jpeg" /> 关键字：公路、百合、<del>屑</del>、奇幻、单元剧</p><p>个人评分：80</p><p>锐评：人设大于剧情，伊雷娜的人设确实很讨喜，毕竟是讨论度极高的“屑魔女”嘛。百合+生草小片段的处理也算是版本答案，这一点在《莉克莉斯》中被发扬光大了。但是就是说作者的故事写的水平确实是差了一点。小说前期确实写的不怎么样，后面有些改观。改天要去看看《奇诺之旅》。</p><h2 id="来自深渊第一部深魂黎明85">来自深渊（第一部+深魂黎明）：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336929.jpeg" /> 关键字：世界观、虐、奇幻、冒险</p><p>个人评分：85</p><p>锐评：其实我看这部是看了2部总集篇+1部剧场版。只能说这个世界构建得实在是太有意思了，壮丽、神秘而精美，如果做成开放世界游戏肯定非常非常好玩，如果有个靠谱的游戏公司来做的话就太好了（现在这个游戏，我说句不好听的，感觉不如原神）。在世界观以及如此优秀的情况下剧情没有拉跨，就已经非常值得一看了，况且剧情也很精彩呢。这部动画在我看来是非常“遗憾”的动画，第一遗憾在创造了这么精彩的世界观，但是没有展开介绍，情节推进的速度太快，还没来得及欣赏这一层的生态呢，就要继续往下走了。第二遗憾在如果某些“血腥”或者说“恶趣味”的情节不要表现得这么露骨，让人看着心惊胆战（这部片是PG12真的合理吗？），它有可能本来会得到更高的评价，而不是让“土笔恶趣味”的阴影一直伴随着它。当然，这也可能是来自深渊之所以是来自深渊的原因吧，谁知道呢？</p><h2 id="末日时在做什么有没有空可以来拯救吗95">末日时在做什么？有没有空？可以来拯救吗？：95</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336289.jpeg" /> 关键字：奇幻、末世、恋爱、诺斯替</p><p>个人评分：95</p><p>锐评：这部作品应该对我的影响是非常非常大的，是我真正的“二次元入坑作”。当时是17年吧，我是在打OI的时候被同学（以及刷题网站？hhhh）安利到了这部番 <del>，然后就感受到了二次元的魅力，变成了萌萌二次元</del> 。第一集的斯卡布罗集市就非常地抓人眼球，然后就是这个摇摇欲坠又精致的异世界，然后就是珂朵莉和威廉甜甜的恋爱，然后就是刀子。鲁迅说过：“悲剧就是把美好的东西撕碎给人看”，在这部作品中我确实是体会到了悲剧带给我的震撼。后来我在NOIP2017被 <span class="math inline">\(ab-a-b\)</span> 背刺了以后，也是不停地在听这个动画里的歌，我记得里面有一句是：</p><blockquote><p>We never say good bye and never see again</p></blockquote><p>虽然说这部动画现在看来有这样那样的问题，诸如什么制作贫穷、宏大的世界观和渺小的爱情故事不搭配之类的问题，但是这些都不妨碍现在的我替2017年的我打出95分的高分，因为它在我心中永远是【神作】：非常优秀的作品，让我印象深刻。</p><p>另：本动画的原作小说也非常值得一看，今年还入围了日本星云奖。我最喜欢的是其中的第四本，在这一本中视角回到了500年前，作者将插叙手法运用得炉火纯青，带我领略了500年前大灾变的始末，和“叹月的最初之兽”的悲叹。</p><h2 id="索玛丽与森林之神70">索玛丽与森林之神：70</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336213.jpeg" /> 关键字：旅行、日常、萝莉、催泪</p><p>个人评分：70</p><p>锐评：我记得我看这部的原因就是它和上面说的末日时是一个公司做的。不过这部没给我留下太大印象，可能是不太对我胃口。就光记得催泪催得有点太生硬了。</p><h2 id="lovelive76">Lovelive！：76</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336901.jpeg" /> 关键字：偶像、校园、青春</p><p>个人评分：76</p><p>锐评：单就动画作品来看其实这部比较平凡，算是良作，说好听点就是淳朴吧，当成歌舞片看还挺好的。当然如果加上偶像企划等等一系列内容就另说了。但是这篇文章还是以动画评价为主，所以给到一个良作的档。</p><h2 id="轻音少女89">轻音少女：89</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336552.jpeg" /> 关键字：校园、青春、日常、<del>meta</del></p><p>个人评分：89</p><p>锐评：一部相当优秀的作品，各方面素质都不弱。这部作品是我在2019年高考后看的第一部动画。刚刚结束高中生活的我看着几个可爱的女孩子慢慢走完高中生活的感觉，很奇妙呢。而且在我看的时候她们高考出分和我高考出分是同步的，是同一天，也算是一个别样的体验了，这也是对我来说这部作品的关键字里面有 <del>meta</del> 的原因。其实我感觉这不正是我想要的青春吗。喜欢了什么就义无反顾地开始学习，钱不够了就大家一起打工赚钱，放课后的偷懒，上台前的特训，一起向着目标努力，一起经历疯疯傻傻的生活。最后的最后要毕业了，要分开了，以前一起做过什么很多都记不起来了呢，只记得十分地快乐幸福。 在我刚进大学的时候给我很多很多帮助的18级的前辈，比如aikx、喵燐、赫卡、半宅、薛汐、马老师、mlz、Sky等等，也马上就要毕业了。真伤感啊。</p><h2 id="吹响吧上低音号95">吹响吧！上低音号：95</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336575.jpeg" /> 关键字：社团、青春、音乐、古典、轻百合、励志</p><p>个人评分：95</p><p>锐评：我的高中完全没有社团这种东西的存在，但我却对这部作品的共鸣很强烈，这是为什么呢？其实是因为我把我的竞赛经历投射到了9妹子她们搞吹奏乐身上。我觉得这简直 <strong>完全同构</strong> 好吧，目标都是一路过关斩将， <strong>全国大会出席</strong> ，而且还有什么选拔、合宿（指集训）、等等。唯一的缺点就是9妹子找到了女朋友和男朋友，但我没找到，话虽如此，也算是认识了几个非常要好的朋友。</p><p>除开个人因素，本作作画精美；音乐极其优秀，大大加强了我对古典音乐的兴趣，我有一个相当大的愿望，就是能在音乐厅里欣赏一次本作的经典音乐，如《三日月之舞》、《利兹与青鸟》、《吹响吧！上低音号》、《北宇治四重奏》等。剧情多线交织，详略得当，总集篇的删减也算比较合理。总之来说综合素质可圈可点，所以：</p><p><strong>什么时候出第三季！！！！！！</strong></p><p>（反转了，已经出了）</p><h2 id="比宇宙更远的地方86">比宇宙更远的地方：86</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336539.jpeg" /> 关键字：青春，南极，浪漫</p><p>个人评分：86</p><p>锐评：其实从2019年元旦起，我有一个每年的12月31日都要一晚上看一部动画来跨年的习惯。19年我看的是《凉宫春日》（虽然不知道是几刷了），20年我看的是《紫罗兰永恒花园》，21年我看的就是《比宇宙更远的地方》。这部吸引我的关键字是“宇宙”，虽然实际上和宇宙没有什么关系。但并不影响这是部好作品。能把正值青春期孩子们的烦恼，友情，人际交往等关系充分表现出来，题材也很浪漫，虽然不是宇宙，但那是南极耶！！</p><h2 id="寒蝉鸣泣之时含解不含其它90">寒蝉鸣泣之时（含解，不含其它）:90</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336347.jpeg" /> 关键字：爱，悬疑，猎奇，友情</p><p>个人评分：90</p><p>锐评：一部爱与友情的治愈史诗，比较优秀的游戏改编作品。本作的最大有点一是设置精巧而符合逻辑的悬疑，二是让人看到美好的结局时的欣慰。尽管有着恐怖、血腥等等的形式，但是观众们拨开一层层漆黑的外壳时，最终却得到了晶莹剔透的果实。如果画风能更精致一点，然后血腥暴力稍微少一点就好了。毕竟一开始我也是忍着恐惧在看hhhh</p><h2 id="派对浪客诸葛孔明83">派对浪客诸葛孔明：83</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336014.jpeg" /></p><p>关键字：穿越、偶像、轻松、搞笑</p><p>个人评分：83</p><p>锐评：“酱酱<sub>爱7ki7ki棒棒</sub>”本作 算是四月黑马，观感尚佳，值得期待第二季。虽然名字乍一看挺逆天的，但是可以看出制作人员对孔明和三国历史还是有一定程度的了解的，不是光套个名字就硬上。另外英子莫名地合我的xp，总感觉很是喜欢这种帅帅的二次元女孩子，大加分！制作确实有点穷了，多来点钱应该会更好。</p><h2 id="未闻花名73">未闻花名：73</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336249.jpeg" /></p><p>关键字：友情、伤感、治愈</p><p>个人评价：72</p><p>锐评：这部是一部非常著名的动画，但是就我个人来说，没对我有什么太大的感触。氛围营造得有点刻意，不太好共情。好在ed还挺好听，算是挽回一点评价。</p><h2 id="来自新世界82">来自新世界：82</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336315.jpeg" /></p><p>关键字：科幻，反乌托邦，轻改</p><p>个人评分：82</p><p>锐评：这是一部很有经典气息科幻作品。什么是科幻小说的经典气息呢？科幻小说，也就是幻想和构造的艺术——作者假定一种技术或科学现象，以此假定为种子来进行逻辑推演，开花结果，最终形成了一篇精彩的作品，这才叫经典的科幻。正如前些年热映的《Arrival》中的“外星语言”、《三体》中的三体运动、《诗云》中的“穷举所有诗词”一样。很喜欢我忘了是谁说过的一句话：“科幻文学就是给世界一刀，看世界带病运转的样子”。（当然，多说两句题外话，科幻艺术并不能因为科幻而放弃艺术，毕竟大家看动画小说，看得还是人物塑造、故事情节以及情感，而不是线性代数课本。所以说，科幻作品以点子为基础，而以人物和故事为核心。并不是说一个人越“懂科学”，他所写出的科幻小说就越好）在这个层面，本作也是基于一个核心点子（即咒力，简单来说就是人的武力值近乎于无限地增大，锐利的矛能轻松击破所有的盾），然后推演文明如何演进。作为科幻作品，本作的内部的逻辑能够自洽，设定严谨，有着深刻的社会学思辨，非常难得。这部动画的原作实在是太强了，以至于能掩盖掉动画制作的种种缺陷，所谓瑕不掩瑜。但是还是推荐所有对这部作品有兴趣的人优先去阅读原作，如果实在是不想读文字再来看动画，真的。</p><h2 id="紫罗兰永恒花园85">紫罗兰永恒花园：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336150.jpeg" /></p><p>关键字：画面，京阿尼，奇幻</p><p>评分：85</p><p>锐评：这部是我看过的画面最强大的TV动画，没有之一。在视听领域，这部动画应该可以说是做到了极致。剧情的薄弱没有掩盖到视听方面给我带来的震撼。太可惜了，如果剧本能再好好打磨一下，应该可以说是神作了。我之前提到过我有每年看一部动画片跨年的习惯，这部是我在2019年12月31日看的。之后回家以后和朋友看了外传剧场版，应该是1月20号前后，从影院一出来，一看手机，冠神遍地开花，于是我的前途命运被彻底改变了（笑）</p><p>这一部分到20篇为止，之后的我会另开一贴更新，敬请期待。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于离散系统和Z变换的那些事</title>
    <link href="/2022/07/03/%E5%85%B3%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E5%92%8CZ%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/07/03/%E5%85%B3%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E5%92%8CZ%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>离散系统和Z变换，与连续系统和Laplace变换很像，但也有些不同，可以对比学习。 本文合计5598字。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="离散时间信号与系统">离散时间信号与系统</h2><h3 id="常用基本序列">常用基本序列</h3><ol type="1"><li><p>单位样值序列（对应冲激函数） <span class="math display">\[\delta(n)=\begin{cases}1 &amp; n=0\\\\0 &amp; \text{others}\end{cases}\]</span> 于是，仿照把任意信号分解成冲激函数和的形式，我们可以把任意序列分解成单位样值序列的和的形式，并且这个操作比在连续函数里更直观，即： <span class="math display">\[x(n)=\sum_{m=-\infty}^{\infty} x(m)\delta(n-m) \]</span></p></li><li><p>单位阶跃序列（对应单位阶跃函数） <span class="math display">\[u(n)=\begin{cases}1 &amp; n\geq 0\\\\0 &amp; n&lt;0\end{cases}\]</span> 类似于单位冲激函数和单位阶跃函数的关系，有： <span class="math display">\[u(n)=\sum_{m=-\infty}^{n}\delta(m)\]</span> 和单位阶跃函数不同，<span class="math inline">\(u(0)\)</span>有明确定义，为<span class="math inline">\(1\)</span>.</p></li><li><p>矩形序列</p><p>矩形序列<span class="math inline">\(G_N(n)\)</span>指的是从0开始（含0），含<span class="math inline">\(N-1\)</span>个<span class="math inline">\(1\)</span>的序列，即： <span class="math display">\[G_N(n)=\begin{cases}1 &amp; n\in[0,n)\\\\0 &amp; \text{others}\end{cases}\]</span> 矩形序列是两个单位阶跃序列的组合。有： <span class="math display">\[G_N(n)=u(n)-u(n-N)\]</span></p></li><li><p>（单边）指数序列 <span class="math display">\[x(n)=a^nu(u)\]</span> 当<span class="math inline">\(|a|&lt;1\)</span>时收敛，<span class="math inline">\(|a|&gt;1\)</span>和<span class="math inline">\(a=-1\)</span>时发散。</p><p>当<span class="math inline">\(a&lt;0\)</span>时会在<span class="math inline">\(x\)</span>轴两侧摆动。</p></li><li><p>正弦序列</p><p>正弦序列是由正弦函数采样的序列，有： <span class="math display">\[x(n)=A\sin(\omega t+\varphi)|_{t=nT_s}=A\sin(\omega nT_s+\varphi)\]</span> 其中<span class="math inline">\(T_s\)</span>是采样周期。定义数字角频率： <span class="math display">\[\Omega=\omega T_s\]</span> 与正弦函数不同，正弦序列不一定是周期序列。当且仅当 <span class="math display">\[\frac{2\pi} {\Omega}\]</span> 是有理数时，正弦序列才是周期序列。</p></li></ol><h3 id="离散序列基本运算">离散序列基本运算</h3><p>一般的运算和连续信号（函数）没有多少区别。需要注意的是压扩运算。压扩运算需要去除某些点，或者补充某些0点。</p><h3 id="离散时间系统">离散时间系统</h3><p>离散时间系统的描述和连续时间系统差别不大。不同于连续时间系统中常用积分器，离散时间系统中常用延时器，其符号为一个方框中写了一个“D”，作用是输入<span class="math inline">\(x(n)\)</span>，输出<span class="math inline">\(x(n-1)\)</span>。</p><p>记忆与无记忆、线性与非线性、时变与时不变、稳定与不稳定的含义和连续时间系统没有区别。</p><h3 id="差分方程时域求解方法">差分方程时域求解方法</h3><p>离散时间系统的数学表达式常用差分方程来表示，一般差分方程的形式为： <span class="math display">\[a_0y(n)+a_1y(n-1)+\cdots+a_Ny(n-N)=b_0x(n)+b_1x(n-1)+\cdots+b_My(n-M)\]</span> 求解的过程和微分方程类似：首先将方程右边置0求得齐次解；然后根据激励信号的特点选取含待定系数的特解，代入方程求得特解；再将齐次解和特解相加得完全解；最后代入 <strong>初始条件</strong> 求待定系数。</p><ol type="1"><li><p>求齐次解</p><p>将方程右边置0，得： <span class="math display">\[\sum_{k=0}^Na_ky(n-k)=0\]</span> 特征方程为： <span class="math display">\[\sum_{k=0}^Na_k\lambda^{N-k}=0\]</span> 这是一个关于<span class="math inline">\(\lambda\)</span>的多项式方程。求解特征方程得到特征根<span class="math inline">\(\lambda_1\cdots\lambda_N\)</span>。</p><p>如果<span class="math inline">\(\lambda_i\)</span>是单根或者共轭复根，那么齐次解中含有一项： <span class="math display">\[C_i\lambda_i^n\]</span> 如果<span class="math inline">\(\lambda_j\)</span>是<span class="math inline">\(r\)</span>重根，那么齐次解中含有项： <span class="math display">\[C_1n^{r-1}\lambda_j^n+C_2n^{r-2}\lambda_j^n+\cdots+C_{r-1}n\lambda_j^n+C_r\lambda_j^n\]</span></p></li><li><p>选取特解</p><p>常见激励和它对应的特解如下：</p><table><thead><tr class="header"><th style="text-align: center;">激励<span class="math inline">\(x(n)\)</span></th><th style="text-align: center;">特解</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(n^m\)</span></td><td style="text-align: center;"><span class="math inline">\(\sum_{i=0}^m P_{m-i}n^{m-i}\)</span></td><td style="text-align: center;">所有特征根不为1</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(n^m\)</span></td><td style="text-align: center;"><span class="math inline">\(n^r\sum_{i=0}^m P_{m-i}n^{m-i}\)</span></td><td style="text-align: center;">1是<span class="math inline">\(r\)</span>重特征根</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(P\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>不是特征根</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(P_1n\lambda^n+P_0\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>是特征单根</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\sum_{i=0}^rP_{r-i}n^{r-i}\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>是<span class="math inline">\(r\)</span>重特征根</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sin(\beta n)\)</span>或<span class="math inline">\(\cos(\beta t)\)</span></td><td style="text-align: center;"><span class="math inline">\(P\cos(\beta n)+Q\sin(\beta n)\)</span> 或 <span class="math inline">\(A\cos(\beta n-\theta)\)</span></td><td style="text-align: center;">其中<span class="math inline">\(Ae^{j\theta}=P+jQ\)</span>,<span class="math inline">\(e^{\pm j\theta}\)</span>不是特征根</td></tr></tbody></table></li></ol><blockquote><p>【例】求解差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>， <strong>起始条件</strong> 为<span class="math inline">\(y(-2)=\frac12,y(-1)=0\)</span>。</p><p>【解】特征方程为： <span class="math display">\[\lambda^2+3\lambda+2=0\]</span> 特征根为 <span class="math display">\[\lambda_1=-1,\lambda_2=-2\]</span> 则齐次解为 <span class="math display">\[y_h(h)=C_1(-1)^n+C_2(-2)^n\]</span> 由于<span class="math inline">\(x(n)=2^n\)</span>，2不是特征根，选特解形式为 <span class="math display">\[y_p(n)=P\cdot2^n\]</span> 代入方程，有： <span class="math display">\[P\cdot2^n+3P\cdot2^{n-1}+2P\cdot 2^{n-2}=2^n\]</span> 两边同时除以<span class="math inline">\(2^n\)</span>，有： <span class="math display">\[3P=1\]</span> 得特解： <span class="math display">\[y_p(n)=\frac 13\cdot2^n\]</span> 则完全解形式为： <span class="math display">\[y(n)=C_1(-1)^n+C_2(-2)^n+\frac 13\cdot 2^n\]</span> 代入初始条件.因为方程右边的激励只在<span class="math inline">\(n\geq0\)</span>处有定义，我们要把已知的<span class="math inline">\(y(-1),y(-2)\)</span>转换成<span class="math inline">\(y(0),y(1)\)</span>.有： <span class="math display">\[\begin{cases}y(0)+3y(-1)+2y(-2)=x(0)\\\\y(1)+3y(0)+2y(-1)=x(1)\end{cases}\]</span> 得： <span class="math display">\[y(0)=0,y(1)=2\]</span> 将上述条件代入完全解形式，得： <span class="math display">\[\begin{cases}C_1+C_2+\frac 13=0\\\\-C_1-2C_2+\frac 23=1\end{cases}\]</span> 于是可解得完全解： <span class="math display">\[y(n)=\frac 23(-1)^n -(-2)^n +\frac 13 \cdot2^n \ \ n\geq 0\]</span></p></blockquote><h3 id="零输入和零状态响应">零输入和零状态响应</h3><ol type="1"><li><p>零输入响应</p><p>零输入响应就是只考虑起始状态，而把输入置0时，系统的响应。也就是 <span class="math display">\[\begin{cases}\sum_{i=0}^N a_iy_{zi}(n-i)=0\\\\[2ex]y_{zi}(-1)=y(-1)\\\\y_{zi}(-2)=y(-2)\\\\\cdots\\\\y_{zi}(-N)=y(-N)\end{cases}\]</span> 的解。其中<span class="math inline">\(y_{zi}\)</span>表示零输入（Zero Input）。</p></li><li><p>零状态响应</p><p>零状态响应的意思是起始状态全为0，仅仅考虑外加激励，所引起的响应。也就是 <span class="math display">\[\begin{cases}\sum_{i=0}^N a_iy_{zs}(n-i)=\sum_{i=0}^N b_ix(n-i)\\\\y(-1)=y(-2)=\cdots=0\end{cases}\]</span> 其中<span class="math inline">\(y_{zs}(n)\)</span>表示零状态（Zero State）。</p></li></ol><p>可以通过零输入响应和零状态响应求和的办法求解全响应。</p><blockquote><p>【例】求解差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>，初始条件为<span class="math inline">\(y(0)=1,y(1)=2\)</span>。</p><p>【解】特征方程为： <span class="math display">\[\lambda^2+3\lambda+2=0\]</span> 特征根为 <span class="math display">\[\lambda_1=-1,\lambda_2=-2\]</span> 则齐次解为 <span class="math display">\[y_h(n)=C_1(-1)^n+C_2(-2)^n\]</span> 因为初始条件包含了激励信号的影响，因此需要求出起始条件为： <span class="math display">\[y(-2)=\frac12,y(-1)=0\]</span> 则有： <span class="math display">\[\begin{cases}C_1(-1)^{-1}+C_2(-2)^{-1}=0\\\\C_1(-1)^{-2}+C_2(-2)^{-2}=\frac 12\\\\\end{cases}\]</span> 解得零输入响应为： <span class="math display">\[y_{zi}(n)=(-1)^n-2(-2)^n\]</span> 然后求零状态响应。由于<span class="math inline">\(x(n)=2^n\)</span>，2不是特征根，选特解形式为 <span class="math display">\[y_p(n)=P\cdot2^n\]</span> 代入方程，有： <span class="math display">\[P\cdot2^n+3P\cdot2^{n-1}+2P\cdot 2^{n-2}=2^n\]</span> 两边同时除以<span class="math inline">\(2^n\)</span>，有： <span class="math display">\[3P=1\]</span> 得特解： <span class="math display">\[y_p(n)=\frac 13\cdot2^n\]</span> 则零状态响应的形式为： <span class="math display">\[y_{zs}(n)=D_1(-1)^n+D_2(-2)^n+\frac 13 \cdot 2^n\]</span></p><p>因为求解的是零状态响应，因此此时系统的初始条件为：<span class="math inline">\(y(-1)=y(-2)=0\)</span>。代入差分方程，得初始条件： <span class="math display">\[y_{zs}(0)=0,y_{zs}(1)=1\]</span> 代入待定系数，解得： <span class="math display">\[y_{zs}(n)=-\frac 13(-1)^n+(-2)^n +\frac 13 \cdot (2^n)\]</span> 则全响应为 <span class="math display">\[\begin{aligned}y(n)&amp;=y_{zi}(n)+y_{zs}(n)\\\\&amp;=\frac 23(-1)^n -(-2)^n +\frac 13 \cdot2^n \ \ n\geq 0\end{aligned}\]</span></p></blockquote><h3 id="单位样值响应">单位样值响应</h3><p>单位响应就是激励信号是<span class="math inline">\(\delta(n)\)</span>时的零状态响应。它具有齐次解的形式，而且具有固定起始条件，即： <span class="math display">\[h(-N+1)=0,h(-N+2)=0,\cdots,h(0)=1\]</span></p><blockquote><p>【例】求以下系统的单位样值响应 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=2x(n-1)+x(n-2)\]</span> 【解】先求系统 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 的单位样值响应<span class="math inline">\(h_1\)</span>，再由线性时不变特性求<span class="math inline">\(h(n)\)</span>.</p><p>齐次解的形式为： <span class="math display">\[h_1(n)=[C_1(-1)^n+C_2(-2)^n]u(n)\]</span> 代入固定起始条件<span class="math inline">\(h(-1)=0,h(0)=1\)</span>： <span class="math display">\[\begin{cases}-C_1-\frac 12 C_2=0\\\\C_1+C_2=1\end{cases}\]</span> 得： <span class="math display">\[h_1(n)=[(-1)^(n+1)+2(-2)^n]u(n)\]</span> 有： <span class="math display">\[\begin{aligned}h(n)&amp;=2h_1(n-1)+h_1(n-2)\\\\&amp;=2[(-1)^n+2(-2)^{n-2}]u(n-1)+[(-1)^{n-1}+2(-2)^{n-2}]u(n-2)\\\\&amp;=\frac {\delta(n)}2+(-1)^nu(n)-1.5(-2)^nu(n)\end{aligned}\]</span></p></blockquote><h3 id="卷积和">卷积和</h3><p>两个序列<span class="math inline">\(x(n)\)</span>和<span class="math inline">\(h(n)\)</span>的“卷积和”定义如下： <span class="math display">\[y(n)=x(n)\bigotimes h(n)=\sum_{m=-\infty}^\infty x(m)h(n-m)\]</span> 卷积和具有交换律、结合律、分配律，此外，还有：</p><ol type="1"><li><p>移不变性 <span class="math display">\[x_1(n-m)\bigotimes x_2(n+k)=y(n-m+k)\]</span></p></li><li><p>序列和单位样值序列的卷积 <span class="math display">\[x(n)\bigotimes h(n-m)=x(n-m)\]</span></p></li><li><p>序列和单位阶跃序列的卷积 <span class="math display">\[x(n)\bigotimes u(n)=\sum_{i=-\infty}^n x(n)\]</span></p></li></ol><p>在计算两个有限长度序列的卷积时，可以像列乘法竖式一样，先把两个序列右对齐，然后算“乘法”（只是不进位），即：</p><ol type="1"><li>两序列右对齐</li><li>逐个样值对应相乘，不进位</li><li>同列乘积相加</li></ol><p>得到的结果<span class="math inline">\(y(n)\)</span>的第一个数的下标是两个原始序列的第一个数的下标的和。</p><p>对于无穷长序列一般只能通过定义公式计算。</p><h2 id="离散时间信号与系统变换域分析">离散时间信号与系统变换域分析</h2><h3 id="z变换"><span class="math inline">\(Z\)</span>变换</h3><p>类似于拉普拉斯变换，Z变换也分为双边和单边。</p><p>双边<span class="math inline">\(Z\)</span>变换的定义如下： <span class="math display">\[X(z)={\mathscr Z}[x(n)]=\sum_{n=-\infty}^\infty x(n)z^{-n}\]</span> 单边<span class="math inline">\(Z\)</span>变换的定义如下： <span class="math display">\[X(z)={\mathscr Z}[x(n)]=\sum_{n=0}^\infty x(n)z^{-n}\]</span></p><p>那么为什么和拉普拉斯变换这么像呢？这是因为<span class="math inline">\(Z\)</span>变换可以从拉普拉斯变换导出。</p><p>考虑对一个连续时间信号<span class="math inline">\(x(t)\)</span>进行时间间隔为<span class="math inline">\(T\)</span>的理想冲激抽样，抽样所得的信号记为<span class="math inline">\(x_s(t)\)</span>，则有： <span class="math display">\[x_s(t)=x(t)\cdot \delta_T(t)=\sum_{n=-\infty}^\infty x(nT)\delta(t-nT)\]</span> 对上式取<span class="math inline">\(Z\)</span>变换，有： <span class="math display">\[X_s(s)={\mathscr L}[x_s(t)]=\int_{0}^{\infty}\left[\sum_{n=-\infty}^\infty x(nT)\delta(t-nT)\right]e^{-st} {\mathbf d}t\]</span> 对调积分求和、利用冲激函数性质，有： <span class="math display">\[X_s(s)=\sum_{n=-\infty}^\infty x(nT)e^{-snT} \]</span> 设<span class="math inline">\(z=e^{sT}\)</span>，由于<span class="math inline">\(T\)</span>是给定常数，则<span class="math inline">\(z\)</span>是<span class="math inline">\(s\)</span>的函数，则有： <span class="math display">\[X_s(z)=\sum_{n=-\infty}^\infty x(nT)z^{-n}\]</span> 在一般的离散系统中，让<span class="math inline">\(T=1\)</span>，则有： <span class="math display">\[X_s(z)=\sum_{n=-\infty}^{\infty} x(n)z^{-n}\]</span> 一个序列的<span class="math inline">\(Z\)</span>变换，实际上是一个系数为这个序列的样值，变量为<span class="math inline">\(z^{-1}\)</span>的幂级数。即： <span class="math display">\[X(z)=\cdots+x(-2)z^2+x(-1)z^1+x(0)z^0+x(1)z^{-1}+x(2)z^{-2}+\cdots\]</span></p><h3 id="z变换的收敛域"><span class="math inline">\(Z\)</span>变换的收敛域</h3><p>既然是从拉普拉斯变换导出来的，而且还是幂级数，那就不得不讨论收敛域。</p><p>复习一下，分析里面判断级数收敛有很多方法，其中最常用的有达朗贝尔判别法，即对于变号级数， <span class="math display">\[\lim_{n\to \infty} \left|\frac{x(n+1)z^{-(n+1)} } {x(n)z^{-n} }\right|=\rho\]</span> 如果<span class="math inline">\(\rho&lt;1\)</span>，那么绝对收敛；如果<span class="math inline">\(\rho&gt;1\)</span>，那么发散。</p><p>结合拉普拉斯变换，我们把序列分成左边序列，右边序列，双边序列来讨论。由于 <span class="math display">\[z=e^{s}\]</span> 我们可以通过下图的方法来建立S平面和Z平面的联系。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/AAC37E072C27DA06CC75C6F0EE4975D9.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>有：</p><table><thead><tr class="header"><th>序列（函数）类型</th><th>Z变换收敛性形状</th><th>拉普拉斯变换收敛域形状</th></tr></thead><tbody><tr class="odd"><td>右边</td><td>以原点为中心的圆之外 <span class="math inline">\(\|z\|&gt;\|a\|\)</span></td><td>右半平面 <span class="math inline">\(Re[s]&gt;\alpha\)</span></td></tr><tr class="even"><td>左边</td><td>以原点为中心的圆之内 <span class="math inline">\(\|z\|&lt;\|b\|\)</span></td><td>左半平面 <span class="math inline">\(Re[s]&lt;\beta\)</span></td></tr><tr class="odd"><td>两边</td><td>以原点为圆心的圆环 <span class="math inline">\(\|z\|\in(a,b)\)</span></td><td>条带 <span class="math inline">\(Re[s]\in (\alpha,\beta)\)</span></td></tr></tbody></table><p>对于有限长的序列，收敛域是除去零点和无穷远点的整个Z平面。</p><h3 id="常见序列的z变换">常见序列的<span class="math inline">\(Z\)</span>变换</h3><table><thead><tr class="header"><th>序列名称</th><th>序列表达式</th><th><span class="math inline">\(Z\)</span>变换</th><th>收敛域</th></tr></thead><tbody><tr class="odd"><td>单位样值序列</td><td><span class="math inline">\(\delta(n)=(n=0)?1:0\)</span></td><td><span class="math inline">\(1\)</span></td><td>全平面</td></tr><tr class="even"><td>单位阶跃序列</td><td><span class="math inline">\(u(n)=(n\geq 0)?1:0\)</span></td><td><span class="math inline">\(\frac{z} {z-1}\)</span></td><td><span class="math inline">\(\|z\|&gt;1\)</span></td></tr><tr class="odd"><td>因果指数序列</td><td><span class="math inline">\(x(n)=a^nu(n)\)</span></td><td><span class="math inline">\(\frac{z} {z-a}\)</span></td><td><span class="math inline">\(\|z\|&gt;\|a\|\)</span></td></tr></tbody></table><h3 id="z变换的性质"><span class="math inline">\(Z\)</span>变换的性质</h3><p>设 <span class="math display">\[{\mathscr Z}[x(n)]=X(z),|z|\in(\alpha,\beta)\]</span></p><h4 id="时域性质">时域性质</h4><ol type="1"><li><p>反褶性质 <span class="math display">\[{\mathscr Z}[x(-n)]=X(z^{-1}),|z|\in(\frac 1\beta,\frac 1\alpha)\]</span></p></li><li><p>扩展性质 <span class="math display">\[{\mathscr Z}\left[x\left(\frac na \right)\right]=X(z^a),|z|\in (\alpha^{\frac 1a},\beta ^{\frac 1a})\]</span></p></li><li><p>位移性质</p><ol type="1"><li><p>单边</p><p>若<span class="math inline">\(x(n)\)</span>是双边序列，有： <span class="math display">\[{\mathscr Z}[x(n)u(n)]=X(z) ,|z|&gt;a\]</span> 则有： <span class="math display">\[{\mathscr Z}[x(n+m)u(n)]=z^m\left[ X(z)-\sum_{k=0}^{m-1} x(k)z^{-k} \right]\\\\{\mathscr Z}[x(n-m)u(n)]=z^{-m}\left[ X(z)+\sum_{k=-m}^{-1} x(k)z^{-k} \right]\\\\\]</span> 请注意这里的“位移”：<span class="math inline">\(x(n-m)u(n)\)</span>和拉普拉斯变换里的“位移”<span class="math inline">\(f(t-t_0)u(t-t_0)\)</span>，以及傅里叶变换里的“位移”<span class="math inline">\(f(t-t_0)\)</span>的区别。</p><p>特别的，如果<span class="math inline">\(x(n)\)</span>是因果序列，那么有： <span class="math display">\[\begin{aligned}{\mathscr Z}[x(n+m)u(n)]&amp;=z^m\left[ X(z)-\sum_{k=0}^{m-1} x(k)z^{-k} \right]\\\\{\mathscr Z}[x(n-m)u(n)]&amp;=z^{-m}X(z)\end{aligned}\]</span></p></li><li><p>双边</p><p>双边位移性质比较简单。 <span class="math display">\[{\mathscr Z}[x(n\pm m)]=z^{\pm m}X(z),|z|\in(\alpha,\beta)\]</span></p></li></ol></li><li><p>线性性质</p></li></ol><h4 id="频域性质">频域性质</h4><ol type="1"><li><p><span class="math inline">\(Z\)</span>域微分-序列线性加权 <span class="math display">\[{\mathscr Z}[n\cdot x(n)]=-z\frac{ {\mathbf d}X(z)} { {\mathbf d}z}\]</span></p></li><li><p><span class="math inline">\(Z\)</span>域压扩-序列指数加权 <span class="math display">\[{\mathscr Z}[a^n x(n)]=X\left(\frac za\right),\alpha&lt;\left|\frac za\right|&lt;\beta\]</span> 特殊的，如果要实现<span class="math inline">\(Z\)</span>域反褶运算，有： <span class="math display">\[{\mathscr Z}[(-1)^nx(n)]=X(-z)\]</span></p></li></ol><h4 id="其它性质">其它性质</h4><ol type="1"><li><p>时域卷积 <span class="math display">\[{\mathscr Z}[x_1(n)\bigotimes x_2(n)]=X_1(z)X_2(z)\]</span></p></li><li><p>初值定理</p><p>对于因果序列 <span class="math display">\[x(0)=\lim_{z\to \infty} X(z)\]</span></p></li><li><p>终值定理 <span class="math display">\[x(\infty)=\lim_{z\to 1}[(z-1)X(z)]\]</span></p></li></ol><h3 id="利用z变换性质求其它常用序列的z变换">利用<span class="math inline">\(Z\)</span>变换性质求其它常用序列的<span class="math inline">\(Z\)</span>变换</h3><ol type="1"><li><p>单位样值序列的平移<span class="math inline">\(\delta(n-m)\)</span></p><p>由时移性质，有： <span class="math display">\[{\mathscr Z}[\delta(n-m)]=z^{-m}\]</span></p></li><li><p>斜变序列<span class="math inline">\(x(n)=nu(n)\)</span></p><p>由<span class="math inline">\(Z\)</span>域微分-线性加权性质，有： <span class="math display">\[{\mathscr Z}[nu(n)]=-z\frac{ {\mathbf d} } {\mathbf dz}\left(\frac {z} {z-1}\right)=\frac{z} {(z-1)^2}\]</span></p></li><li><p>因果余弦序列<span class="math inline">\(x(n)=\cos(\omega_0 n)u(n)\)</span></p><p>由欧拉公式： <span class="math display">\[\cos(\omega_0 n)=\frac 12 \left(e^{j\omega_0n}+e^{-j\omega_0 n}\right)\]</span> 和已知的公式 <span class="math display">\[{\mathscr Z}[\left(e^{\pm j\omega_0}\right)^nu(n)]=\frac{z} {z-e^{\pm j\omega_0} },|z|&gt;1\]</span> 结合线性性质，得 <span class="math display">\[{\mathscr Z}[\cos(\omega_0 n)u(n)]=\frac{z^2 -z\cos(\omega_0)} {z^2-2z\cos \omega_0+1},|z|&gt;1\]</span> 同理，因果正弦序列为： <span class="math display">\[{\mathscr Z}[\sin(\omega_0 n)u(n)]=\frac{z\sin(\omega_0)} {z^2-2z\cos \omega_0+1},|z|&gt;1\]</span></p></li></ol><h3 id="逆z变换的求解">逆<span class="math inline">\(Z\)</span>变换的求解</h3><p>一般的线性时不变系统的<span class="math inline">\(Z\)</span>变换表达式往往具有有理多项式的形式。</p><h4 id="长除法">长除法</h4><p>长除法的意思就是根据<span class="math inline">\(Z\)</span>变换的定义，直接求解幂级数的系数，从而求解原始序列。</p><p>当收敛域形式为<span class="math inline">\(|z|&gt;a\)</span>时，幂级数表现出洛朗级数的形式，序列是右边序列，此时应把分母整理成降幂形式，再做长除法。</p><p>当收敛域形式为<span class="math inline">\(|z|&lt;b\)</span>时，幂级数表现出泰勒级数的形式，序列是左边序列，此时应把分母整理成升幂形式，再做长除法。</p><p>这种长除法只能得到序列的部分样值，而且多用于单边<span class="math inline">\(z\)</span>变换。对于双边<span class="math inline">\(z\)</span>变换，一般用部分分式展开法。</p><h4 id="部分分式分解法">部分分式分解法</h4><p>部分分式分解法的核心思想是把有理多项式分式分解成基本分式 <span class="math display">\[\frac{kz} {z-a}\]</span> 的和，然后由于 <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {z-a}\right]=ka^nu(n),|z|&gt;a\]</span> 或者 <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {z-a}\right]=-ka^nu(-n-1),|z|&lt;a\]</span> 来求解原始序列。</p><blockquote><p>【例】求解： <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{5z} {-3z^2+7z-2}\right]\]</span> 分收敛域为：(1) <span class="math inline">\(|z|&gt;2\)</span> (2) <span class="math inline">\(|z|\in (\frac 13 , 2)\)</span>两种情况。</p><p>【解】首先对 <span class="math display">\[\frac{X(z)} {z}=\frac{5} {-3z^2+7z-2}\]</span> 进行分解，过程略，如果不会请参考拉普拉斯变换部分相关内容。有： <span class="math display">\[\frac{X(z)} {z}=\frac{-1} {z-2}+\frac{1} {z-\frac{1} {3} }\]</span> 则： <span class="math display">\[X(z)=\frac{-z} {z-2}+\frac{z} {z-\frac{1} {3} }\]</span></p><ol type="1"><li><p>收敛域为<span class="math inline">\(|z|&gt;2\)</span></p><p>此时，有： <span class="math display">\[x(n)=-2^nu(n)+\left(\frac 13\right)^nu(n)\]</span></p></li><li><p>收敛域为<span class="math inline">\(|z|\in \left(\frac 13,2\right)\)</span></p><p>这时要考虑两个分式分别代表的收敛域是什么。因为线性组合的收敛域是各项的收敛域的交集。我们经分析，得：第一项对应收敛域<span class="math inline">\(|z|&lt;2\)</span>，第二项对应收敛域<span class="math inline">\(|z|&gt;\frac 13\)</span>。(如果反过来，那么收敛域就是空集，这和题目不符)，因此： <span class="math display">\[x(n)=2^nu(-n-1)+\left(\frac 13\right)^nu(n)\]</span></p></li></ol></blockquote><p>对于右边序列，如果出现共轭复根的情况，即 <span class="math display">\[\frac{kz} {z^2+a}\]</span> 则有 <span class="math display">\[\begin{aligned}\frac{kz} {z^2+a}&amp;=\frac{\frac{k} {\sqrt a}\cdot \frac{z} {\sqrt a} } {\left(\frac z{\sqrt a}\right)^2+1}\\\\&amp;=\frac{k} {\sqrt a}\frac{\frac{z} {\sqrt a}\sin \frac \pi 2} {\left(\frac z{\sqrt a}\right)^2-2\left(\frac z{\sqrt a}\right)\cos\frac \pi 2 +1}\\\\&amp;\to \frac{k} {\sqrt a}\cdot \sqrt{a}^n\cdot \sin\left(\frac{\pi} {2}n\right)u(n)\end{aligned}\]</span> 可以使用<code>mathematica</code>验证上述推导，输入：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">ZTransform</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">a</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">^</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">n</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">*</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">n</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-variable">n</span><span class="hljs-operator">,</span> <span class="hljs-variable">z</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>输出： <span class="math display">\[\frac{k z} {a+z^2}\]</span> 对于2阶重极点，有： <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {(z-a)^2}\right]=a^{n-1}knu(n)\]</span> 对于更高阶的极点，有： <span class="math display">\[{\mathscr Z}\left[\frac{kz} {(z-a)^r}\right]=\frac{k} {(r-1)!}a^{n-r+1}\prod_{i=0}^{r-2}(n-i)=k a^{n-r+1} \binom{n} {r-1}\]</span></p><h3 id="用z变换求解差分方程">用<span class="math inline">\(Z\)</span>变换求解差分方程</h3><p>一般差分方程的形式如下： <span class="math display">\[\sum_{k=0}^N a_ky(n-k)=\sum_{r=0}^M b_rx(n-r)\]</span> 对等式两边取<span class="math inline">\(Z\)</span>变换： <span class="math display">\[\sum_{k=0}^N a_kz^{-k}\left[Y(z)+\sum_{l=-k}^{-1}y(l)z^{-l}\right]=\sum_{r=0}^M b_rz^{-r}\left[X(z)+\sum_{m=-r}^{-1}x(m)z^{-m}\right]\]</span> 则系统全响应（的<span class="math inline">\(Z\)</span>变换）为： <span class="math display">\[Y(z)=\frac{\sum_{r=0}^M b_rz^{-r}\left[X(z)+\sum_{m=-r}^{-1}x(m)z^{-m}\right]} {\sum_{k=0}^Na_kz^{-k} }-\frac{\sum_{k=0}^N\left[a_kz^{-k}\cdot\sum_{l=-k}^{-1}y(l)z^{-l}\right]} {\sum_{k=0}^Na_kz^{-k} }\]</span> 其中第一项代表零状态响应，第二项代表零输入响应。</p><p>......麻了没？这么多分式，<span class="math inline">\(\sum\)</span>，我打着都麻。其实这玩意很简单的，下面通过一个例题给大家表演一下。</p><blockquote><p>【例】差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>， <strong>起始条件</strong> 为<span class="math inline">\(y(-2)=2,y(-1)=0\)</span>。求零输入、零状态和全响应。</p><p>【解】对方程两边取<span class="math inline">\(Z\)</span>变换，有： <span class="math display">\[Y(z)+3\left[z^{-1}Y(z)+y(-1)\right]+2\left[z^{-2}Y(z)+y(-2)+y(-1)z^{-1}\right]=X(z)\]</span> 代入数据： <span class="math display">\[(1+3z^{-1}+2z^{-2})Y(z)+4=\frac{z} {z-2}\]</span> 则： <span class="math display">\[\begin{aligned}Y(z)&amp;=\frac {-4} {1+3z^{-1}+2z^{-2} }+\frac{1} {1+3z^{-1}+2z^{-2} }\frac{z} {z-2}\\\\&amp;=\frac{-4z^2} {z^2+3z+2}+\frac{z^2} {z^2+3z+2}\frac{z} {z-2}\end{aligned}\]</span> 其中第一项代表零状态响应，第二项代表零输入响应。有： <span class="math display">\[Y_{zi}(z)=\frac{4z} {z+1}+\frac{-8z} {z+2}\]</span></p><p><span class="math display">\[Y_{zs}(z)=\frac{-\frac 13 z} {z+1}+\frac{z} {z+2}+\frac{\frac 13 z} {z-2}\]</span></p><p>则： <span class="math display">\[y_{zi}(n)=4(-1)^n-8(-2)^n\\\\y_{zs}(n)=-\frac 13 (-1)^n+(-2)^n+\frac 13 (2)^n\]</span> (<span class="math inline">\(n\geq 0\)</span>)</p></blockquote><h3 id="离散系统传递函数">离散系统传递函数</h3><p>就是单位样值响应（零状态）<span class="math inline">\(h(n)\)</span>的<span class="math inline">\(Z\)</span>变换<span class="math inline">\(H(z)\)</span>,一般有如下形式：</p><p><span class="math display">\[H(z)=\frac{\sum_{r=0}^M b_rz^{-r} } {\sum_{k=0}^N a_kz^{-k} }=G\frac{\prod _{r=1}^M (1-o_rz^{-1})} {\prod_{k=0}^N (1-p_kz^{-1})}\]</span></p><p>其中<span class="math inline">\(o\)</span>就是零点，<span class="math inline">\(p\)</span>就是极点。对于因果序列而言，极点分布和<span class="math inline">\(h(n)\)</span>大致时域形状的关系如下：</p><table><thead><tr class="header"><th><span class="math inline">\(H(z)\)</span>极点位置</th><th><span class="math inline">\(h(n)\)</span>时域形状</th></tr></thead><tbody><tr class="odd"><td>单位圆内实数</td><td>指数衰减序列</td></tr><tr class="even"><td>单位圆内共轭复数</td><td>衰减的正弦序列</td></tr><tr class="odd"><td>单位圆外实数</td><td>指数增长序列</td></tr><tr class="even"><td>单位圆外共轭复数</td><td>增长的正弦序列</td></tr><tr class="odd"><td>单位圆上实数</td><td>常序列（一阶）或逐渐增大</td></tr><tr class="even"><td>单位圆上共轭复数</td><td>幅度为常数或逐渐增大的正弦序列</td></tr></tbody></table><p>由此可以看出极点分布和系统稳定性的关系。另外，这个表也可以由<span class="math inline">\(s-z\)</span>平面变换得出。</p><p>至于因果性，那就更简单了。只要系统函数的极点分布在<span class="math inline">\(Z\)</span>平面内的一个半径有限的圆内就行，即保证收敛域为 <span class="math display">\[|z|&gt;R\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假计划</title>
    <link href="/2022/07/02/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/"/>
    <url>/2022/07/02/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>雄心壮志！！</p><span id="more"></span><h2 id="游戏">游戏</h2><ul><li>苍之彼方的四重奏</li><li>梅时露霁书~雨潺海汐间~</li><li>传送门</li><li>传送门2</li><li>Outer Wildes</li><li>OPUS龙脉常歌</li></ul><h2 id="动画片">动画片</h2><ul><li>无职转生</li><li>相合之物</li><li>白箱</li><li>奇诺之旅</li><li>摇曳露营2</li></ul><h2 id="书">书</h2><ul><li>科幻世界</li><li>固守与超越</li></ul><p>啊嗯，宏伟的计划！</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于分离变量法和物质极化的那些事</title>
    <link href="/2022/07/01/%E5%87%89%E5%AE%AB%E7%A7%8B%E6%9C%88/"/>
    <url>/2022/07/01/%E5%87%89%E5%AE%AB%E7%A7%8B%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<p>这部分写的有点混乱，主要原因是我自己也没搞得太明白。还是希望大家多多在评论里交流。</p><span id="more"></span><p>[toc]</p><h2 id="静电位拉普拉斯方程的变量可分离解">静电位拉普拉斯方程的变量可分离解</h2><p>拉普拉斯方程： <span class="math display">\[\nabla^2\Phi=0\]</span></p><h3 id="直角坐标系中">直角坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=X(x) Y(y) Z(z)=(A x+B)(C y+D)(E z+F)\]</span> 一般解： <span class="math display">\[\Phi(x, y, z)=\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{x} x\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{y} y\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{z} z\]</span> 满足： <span class="math display">\[\pm K_x^2\pm K_y^2\pm K_z^2=0\]</span> 选试探解时，必须从分割线两边选取，不能只取一边。</p><h3 id="柱坐标系中">柱坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=\left(A+B \ln r_ { c } \right)(C+D \varphi)(F+G z)\]</span> 其中第一项的物理意义是：<span class="math inline">\(z\)</span>方向上无限长均匀带电直线线电荷周围的电场。</p><p>一般解： <span class="math display">\[\Phi(\vec { r } )=\left(A r_ { C } ^ { n } +B r_ { C } ^ { -n } \right)(C \sin n \varphi+D \cos n \varphi)\]</span> 其物理意义如下：</p><ol type="1"><li><span class="math inline">\(n=1,B=C=0\)</span>：<span class="math inline">\(x\)</span>方向匀强电场</li><li><span class="math inline">\(n=1,B=D=0\)</span>：<span class="math inline">\(y\)</span>方向匀强电场</li><li><span class="math inline">\(n=1,A=C=0\)</span>​：沿着<span class="math inline">\(x\)</span>轴放置的二维电偶极子</li><li><span class="math inline">\(n=1,A=D=0\)</span>：沿着<span class="math inline">\(y\)</span>轴放置的二维电偶极子</li><li>对于整数<span class="math inline">\(n\)</span>，系统是一个<span class="math inline">\(2n\)</span>偶极子。当<span class="math inline">\(A\neq 0\)</span>时， 有放置在无穷远处多极子形式；当<span class="math inline">\(B\neq0\)</span>时，有放置在原点的多极子形式</li></ol><p>需要注意的是：上述系统的总电荷量都是0，只有平凡解中式<span class="math inline">\(\left(A+B \ln r_ { c } \right)\)</span>对应的系统总电荷量不为零。因此，系统有没有净电荷，可以作为判断要不要取<span class="math inline">\(\left(A+B \ln r_ { c } \right)\)</span>的依据。</p><h3 id="球坐标系中">球坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=\left(A+\frac { B }  { r_ { s }  } \right)\left[C+D \ln \left(\tan \frac { \theta }  { 2 } \right)\right](F+G \varphi)\]</span> 其物理意义为：</p><ol type="1"><li>第一项表示了位于原点的点电荷</li><li>第二项是在一个空间两圆锥面之间夹着的区域的电荷分布</li><li>第三项是空间角域的电荷分布</li></ol><p>一般解： <span class="math display">\[\Phi(\vec { r } ) =\left[A r_ { S } ^ { n } +\frac { B }  { r_ { S } ^ { n+1 }  } \right] P_ { n } ^ { m } (\cos \theta)(C \sin m \varphi+D \cos m \varphi)\ \ (m\leq n)\]</span> 如果系统的总电荷量为0，它的电位中就不可能有$ { r_s } <span class="math inline">\(出现，因此只会有一般解中\)</span>n<span class="math inline">\(的形式出现。如果一个系统中总电荷量不是0，那么就可以有\)</span> { r_s } $出现。</p><h2 id="边界条件的选取规则">边界条件的选取规则</h2><h3 id="边界电位已知的系统">边界电位已知的系统</h3><p>直接写出边界上<span class="math inline">\(\Phi\)</span>等于已知的电位即可。</p><h3 id="带有自然边界条件的系统">带有自然边界条件的系统</h3><p>对于一个<strong>分布在有限区域的源</strong>（例如：给出某边界的电压表达式，在某表面上有电荷等），观察点离他越远，他对观察点的 <strong>场</strong> 的影响就越小。如果源在某个方向是无限的，那么在无限远处电位是常数，只有电场趋于零。如果源确实是有限的（例如：球面），那么可以认为电位在无穷远点是0，此时电场当然也是零。因此，有： <span class="math display">\[r\to \infty,E\to 0\]</span> 对于在某个方向无限的情况，特别地，如果在系统中给出了“地”，或者和地相连的零电位面，而且当前<span class="math inline">\(r\to \infty\)</span>的这个方向附近存在零电位面，那么这个条件很可能也可以被进一步加强为： <span class="math display">\[r\to \infty,\Phi\to 0\]</span> 在系统的原点处，往往有极值定理。这说明：在<span class="math inline">\(r=0\)</span>处，电位应该有限，即： <span class="math display">\[r\to 0,\Phi=0\]</span></p><h3 id="导数边界条件">导数边界条件</h3><p>在载流导体和空气的边界，电容器的边缘处，往往有： <span class="math display">\[\frac { \partial \Phi }  { \partial n } =0\]</span> 在有面自由电荷分布的边界上，有： <span class="math display">\[\varepsilon_0\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_0\frac { \partial \Phi_1 }  { \partial n } =\eta\]</span> 如果上面的情况是在两个电介质的交界处，有： <span class="math display">\[\varepsilon_0\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_0\frac { \partial \Phi_1 }  { \partial n } =\eta_f+\eta_p\]</span> 或 <span class="math display">\[\varepsilon_1\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_2\frac { \partial \Phi_1 }  { \partial n } =\eta_f\]</span></p><p>在两个电导率不同的材料的交界面上，有： <span class="math display">\[\sigma_1\frac { \partial \Phi_1 }  { \partial n } =\sigma_1\frac { \partial \Phi_1 }  { \partial n } \]</span></p><h3 id="带有趋势性边界条件的静电系统">带有趋势性边界条件的静电系统</h3><p>近区：点电荷、电偶极子等，如果放在原点，那么<span class="math inline">\(r_s\to 0\)</span>时，电位趋向于点电荷和电偶极子的电荷。</p><p>远区：如果在一个看起来就很“大”的系统，例如：遍布于全空间的匀强电场中放入一个导体球，那么当<span class="math inline">\(r_s\to \infty\)</span>时，场分布应该和那么很“大”的系统一样。</p><h2 id="试探解的选取规则">试探解的选取规则</h2><h3 id="直角坐标系中-1">直角坐标系中</h3><p>首先确定：电位和哪些坐标量有关，和哪些坐标量无关。</p><p>然后，检查电位是否在某个方向线性变化。这里一般是看边界条件。如果确实线性变化，选平凡解。</p><p>然后，看系统在某坐标量上的零点个数。如果有超过1个零点，那么这个坐标量应该考虑三角函数形式。否则，可以考虑指数函数形式。需要特别注意的是：<span class="math inline">\(\cosh\)</span>函数是没有零点的。</p><p>然后，看对称性。三角函数中，<span class="math inline">\(\sin\)</span>是奇函数，<span class="math inline">\(\cos\)</span>是偶函数。在指数形式函数中，<span class="math inline">\(\sinh\)</span>是奇函数，<span class="math inline">\(\cosh\)</span>是偶函数。</p><h3 id="柱坐标系中-1">柱坐标系中</h3><p>在柱坐标系中确定<span class="math inline">\(n\)</span>的值时，应结合边界条件，看看边界条件中给出的是（例如）： <span class="math display">\[r_c=b,\Phi_1=\Phi_2=V_0\sin 2\varphi\]</span> 这时候<span class="math inline">\(n\)</span>就是2。如果边界条件是（例如）： <span class="math display">\[r_ { C } =R, \Phi_ { 1 } (\vec { r } )=\Phi_ { 2 } (\vec { r } )=V_ { 0 }  \cos \varphi\]</span> 这时候<span class="math inline">\(n\)</span>显然是<span class="math inline">\(1\)</span>，同时也可以确定<span class="math inline">\(C,D\)</span>的存在性。</p><p>如果系统中存在净电荷量，或者只和<span class="math inline">\(r_c\)</span>有关，那么可以考虑平凡解的<span class="math inline">\((A+B\ln r_c)\)</span>项。</p><h3 id="球坐标系中-1">球坐标系中</h3><p>首先也要确定<span class="math inline">\(n,m\)</span>的取值。如果系统和<span class="math inline">\(\phi\)</span>无关，那么这时候<span class="math inline">\(m\)</span>显然是0，这种情况很简单。如果不能确定，应看边界条件中有没有和勒让德函数形式契合的。如果有，那么<span class="math inline">\(n,m\)</span>的取值也随之确定。</p><p>如果系统和<span class="math inline">\(\theta,\varphi\)</span>看起来都没有关系，可以选取平凡解<span class="math inline">\((A+B/r_s)\)</span>。如果系统很契合“两个圆锥面”的物理情景，可选择平凡解的第二项。</p><h2 id="有物质存在时的场定律">有物质存在时的场定律</h2><h3 id="极化">极化</h3><h4 id="极化强度矢量">极化强度矢量</h4><p>定义式: <span class="math display">\[P=\lim_ { \Delta V\to 0 } \frac { \sum_ { i=1 } ^n p_i }  { \Delta V } \]</span> 其中ΔV是空间中的小体积元，pi是ΔV中一个电偶极子的电偶极矩。还有一个计算式： <span class="math display">\[P=\chi_e\varepsilon_0E\]</span> 其中<span class="math inline">\(\chi_e\)</span>是极化率。这个式子只有在非永久极化时才能使用。</p><h4 id="极化与高斯定律">极化与高斯定律</h4><p>有极化电荷密度： <span class="math display">\[\rho_P=-\nabla\cdot P\]</span> 由这个式子，可导出边界条件： <span class="math display">\[\eta_P=-i_n\cdot(P_1-P_2)\]</span> 宏观极化模型下的高斯定律： <span class="math display">\[\nabla\cdot(\varepsilon_0E+P)=\rho_f\]</span> 如果令电位移矢量<span class="math inline">\(D\)</span> <span class="math display">\[D=\varepsilon_0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=(1+\chi_e)\varepsilon_0E=\varepsilon_r\varepsilon_0E\]</span> 有： <span class="math display">\[\nabla\cdot D=\rho_f\]</span> 写成积分形式： <span class="math display">\[\oint_sD \mathrm { d } a=\iiint_v\rho_f \mathrm { d } V\]</span> 还可以导出以下两个边界条件： <span class="math display">\[i_n\cdot\varepsilon_0(E_1-E_2)=\eta_f+\eta_p\\i_n\cdot(D_1-D_2)=\eta_f\]</span></p><h4 id="极化与安培环路定律">极化与安培环路定律</h4><p>极化电流： <span class="math display">\[J_p=\frac { \partial P }  { \partial t } \]</span> 修正的安培环路定律： <span class="math display">\[\nabla\times H=J_f+\frac { \mathbf { d } D }  { \mathbf { d } t } \]</span> 积分形式： <span class="math display">\[\oint_cH\mathbf { d } s=\iint_sJ\mathbf { d } a+\frac { \mathbf { d }  }  { \mathbf { d } t } \iint_sD\mathbf { d } a\]</span></p><h4 id="求解问题思路">求解问题思路</h4><ol type="1"><li><p>永久极化问题</p><p>在永久极化的情况下，<span class="math inline">\(P=\chi_e\varepsilon_0E\)</span>不能用，这时候<span class="math inline">\(P\)</span>一般会直接告诉你。我们一般用 <span class="math display">\[\rho_P=-\nabla\cdot P\]</span> 求出极化电荷分布，然后把极化电荷当成电荷，用已知电荷求场的思路解决问题。</p></li><li><p>非永久极化问题</p><p>这时候一般用分离变量法求出场分布，然后再用<span class="math inline">\(D=\varepsilon E\)</span>求出电位移矢量，然后进一步求解极化电荷等等。</p></li></ol><h3 id="磁化">磁化</h3><p>这里只介绍磁荷模型，因为它可以导出电磁对偶关系。</p><h4 id="磁化强度矢量">磁化强度矢量</h4><p><span class="math display">\[M=\lim_ { \Delta V\to0 } \frac { \sum_ { i=1 } ^N m_i }  { \Delta V } \]</span></p><p>由电磁对偶关系（这里是<span class="math inline">\(\mu_0M\)</span>和<span class="math inline">\(P\)</span>对偶），就能直接得出：</p><p>磁荷密度： <span class="math display">\[\rho_M=-\nabla\cdot\mu_0M\]</span> 磁流密度： <span class="math display">\[J_M=\frac {   { \bf d }   }   {   {  \bf d  }  t  }  (\mu_0M)\]</span> 定义磁感应强度<span class="math inline">\(B\)</span>: <span class="math display">\[B=\mu_0(1+\chi_m)H=\mu H\]</span></p><h4 id="磁化与电磁感应定律">磁化与电磁感应定律</h4><p><span class="math display">\[\nabla \times E=-\frac { \partial B }  { \partial t } \]</span></p><p>积分形式： <span class="math display">\[\oint_cE  {  \bf d  }  s=-\frac {  { \bf d }  }  {  { \bf d } t } \iint_sB { \bf d } a\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于傅里叶变换的那些事</title>
    <link href="/2022/06/27/%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/27/%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>所谓的变换，也就是信号的正交分解。如果两个函数的内积为<span class="math inline">\(0\)</span>，我们称为这两个函数正交。那么对于任意信号<span class="math inline">\(f(t)\)</span>，都可以写成一组正交函数系的和的形式（可以对比正交向量理解），这就是信号的正交分解。通过正交分解，可以对信号的特性有进一步的认识，也可以简化信号的分析和计算。</p><span id="more"></span><h2 id="傅里叶级数">傅里叶级数</h2><p>傅里叶级数是 <strong>周期信号</strong> 基于正交函数系<span class="math inline">\(\{e^{j\omega t}\}\)</span>的正交分解。</p><h3 id="三角函数形式的傅里叶级数">三角函数形式的傅里叶级数</h3><p>三角函数形式的傅里叶级数就是我们最熟悉的傅里叶级数。对于满足以下条件的函数<span class="math inline">\(f(t)\)</span>:</p><ul><li>周期函数，周期为<span class="math inline">\(T_1\)</span>，角频率为<span class="math inline">\(\omega_1=2\pi/T_1\)</span></li><li>间断点个数有限（可数）</li><li>极大极小值个数有限（可数）</li><li>绝对可积</li></ul><p>有： <span class="math display">\[f(t)=a_{0}+\sum_{n=1}^{\infty}\left(a_{n} \cos n \omega_{1} t+b_{n} \sin n \omega_{1} t\right)\]</span> 其中<span class="math inline">\(a_0\)</span>叫直流分量，<span class="math inline">\(a_n\)</span>叫<span class="math inline">\(n\)</span>次谐波余弦分量，<span class="math inline">\(b_n\)</span>叫<span class="math inline">\(n\)</span>次谐波正弦分量。有计算公式： <span class="math display">\[a_0=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \mathrm{d} t\]</span></p><p><span class="math display">\[a_n=\frac{2} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \cos n \omega_{1} t \mathrm{~d} t\]</span></p><p><span class="math display">\[b_n=\frac{2} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \sin n \omega_{1} t \mathrm{~d} t\]</span></p><p>当然，也可通过和差化积公式，转换成只有正弦或余弦分量的形式，此处不再赘述。</p><p>有： <span class="math display">\[a_n=a_{-n},-b_n=b_{-n}\]</span></p><h3 id="指数形式傅里叶级数">指数形式傅里叶级数</h3><p>因为： <span class="math display">\[\sin x=\frac{1} {2j}(e^{jx}-e^{-jx})\]</span></p><p><span class="math display">\[\cos x=\frac 12 (e^{jx}+e^{-jx})\]</span></p><p>代入三角函数形式傅里叶级数中，就能得到指数形式傅里叶级数。这里给出部分关键步骤供参考。 <span class="math display">\[\begin{aligned}f(t)&amp;=a_{0}+\sum_{n=1}^{\infty}\left(a_{n} \cos n \omega_{1} t+b_{n} \sin n \omega_{1} t\right)\\\\&amp;=a_{0}+\sum_{n=1}^{\infty}\left(\frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t}+\frac{a_{n}+j b_{n} } {2} e^{-j n \omega_{1} t}\right)\\\\&amp;=a_{0}+\sum_{n=1}^{\infty} \frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t}+\sum_{n=-\infty}^{-1} \frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t} &amp; a_n=a_{-n},-b_n=b_{-n}\\\\&amp;=\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\end{aligned}\]</span> 其中 <span class="math display">\[F\left(n \omega_{1}\right)=\begin{cases}a_{0}, &amp; n=0 \\\\ \frac{a_{n}-j b_{n} } {2}, &amp; n \neq 0\end{cases}\]</span> 即 <span class="math display">\[F(n\omega_1)=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) e^{-j n \omega_{1} t} \mathrm{d} t\]</span> 可以看出，<span class="math inline">\(F\left(n \omega_{1}\right)\)</span>一般而言是一个复数。它的模长和幅角满足： <span class="math display">\[|F\left(n \omega_{1}\right)|=\frac 12 \sqrt{a_n^2+b_n^2}\]</span></p><p><span class="math display">\[\tan \varphi_n=-\frac{b_n} {a_n}\]</span></p><h3 id="函数的对称性和傅里叶级数">函数的对称性和傅里叶级数</h3><p>因为<span class="math inline">\(\cos\)</span>是偶函数，<span class="math inline">\(\sin\)</span>是奇函数，所以函数本身的奇偶对称性和傅里叶系数的奇偶对称性有关系。</p><table><thead><tr class="header"><th style="text-align: center;">信号</th><th style="text-align: center;"><span class="math inline">\(a_n\)</span></th><th style="text-align: center;"><span class="math inline">\(b_n\)</span></th><th style="text-align: center;"><span class="math inline">\(F(n\omega_1)\)</span></th><th style="text-align: center;"><span class="math inline">\(\varphi_n\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">奇函数</td><td style="text-align: center;">0</td><td style="text-align: center;">不为0</td><td style="text-align: center;">纯虚数</td><td style="text-align: center;"><span class="math inline">\(\pm \pi/2\)</span></td></tr><tr class="even"><td style="text-align: center;">偶函数</td><td style="text-align: center;">不为0</td><td style="text-align: center;">0</td><td style="text-align: center;">实数</td><td style="text-align: center;"><span class="math inline">\(\pm \pi\)</span></td></tr><tr class="odd"><td style="text-align: center;">奇谐函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="在一个周期里的两个半周期里呈现奇对称的函数，即$f(t)=-f(t\pm \frac T2)$​">[1]</span></a></sup></td><td style="text-align: center;">只含奇次谐波</td><td style="text-align: center;">只含奇次谐波</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td></tr><tr class="even"><td style="text-align: center;">偶谐函数</td><td style="text-align: center;">只含直流分量和偶次谐波</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td></tr></tbody></table><p>我们需要注意到：一个“偶谐函数”，和一个周期为<span class="math inline">\(T_1/2\)</span>的函数，实质上是一回事。</p><h3 id="从傅里叶级数看傅里叶变换">从傅里叶级数看傅里叶变换</h3><p>傅里叶级数只能描述周期函数。但是我如果非得描述非周期函数，又会怎么样呢？我们来考虑一下怎么把非周期函数强行变成周期函数，其实只需要让周期<span class="math inline">\(T\)</span>趋向于无穷大就好了。</p><p>对于 <span class="math display">\[F(n\omega_1)=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) e^{-j n \omega_{1} t} \mathrm{d} t\]</span> 让<span class="math inline">\(T\)</span>趋向于无穷大，则<span class="math inline">\(\omega\)</span>趋向于无穷小。因为函数满足绝对可积条件，所以右边是一个有限值比无穷大，趋向于0。而左边因为<span class="math inline">\(\omega\)</span>趋向于无穷小，取值点趋向于连续。有没有发现，这个过程有一点点像随机变量从连续型变成离散型时，分布列的变化情况（一方面，取值趋向于无穷小；另一方面，自变量趋向于连续）。于是，类似于“概率论”的知识，我们也可以定义“频谱密度函数”，让<span class="math inline">\(n\omega_1\to\omega\)</span>，有 <span class="math display">\[F(\omega)=\int_{-\infty}^\infty f(t)e^{-j\omega t}\mathrm{d}t\]</span> 这就是我们常说的傅里叶变换。</p><h2 id="傅里叶变换">傅里叶变换</h2><h3 id="傅里叶变换的定义式">傅里叶变换的定义式</h3><p><span class="math display">\[F(\omega)=\int_{-\infty}^\infty f(t)e^{-j\omega t}\mathrm{d}t\]</span></p><h3 id="基本信号及其傅里叶变换">基本信号及其傅里叶变换</h3><ol type="1"><li><p>矩形脉冲信号（门信号）</p><p>即： <span class="math display">\[G_N(t)=\begin{cases}1 &amp; |t|&lt;N\\\\0 &amp; |t|&gt;N\end{cases}\]</span> 有： <span class="math display">\[\mathscr{F}[G_N(t)]=2N\mathrm{Sa}(\omega N)\]</span></p></li><li><p>单边指数信号 <span class="math display">\[f_1(t)=\begin{cases}e^{-at} &amp; t\geq 0\\\\0 &amp; \text{others}\end{cases}\]</span> 则 <span class="math display">\[\mathscr{F}[f_1(t)]=\frac {1} {a+j\omega}\]</span> 类似地， <span class="math display">\[f_2(t)=\begin{cases}0 &amp; t\geq 0\\\\e^{bt} &amp; t&lt;0\end{cases}\]</span> 则 <span class="math display">\[\mathscr{F}[f_2(t)]=\frac 1{b-j\omega}\]</span></p></li><li><p>“偶”双边指数信号</p><p>把前面两个单边指数信号加起来就行了。 <span class="math display">\[f(t)=e^{-a|t|}\]</span> 则 <span class="math display">\[\mathscr{F}\left[e^{-a|t|}\right]=\frac{2a} {a^2+\omega^2}\]</span></p></li><li><p>符号函数 <span class="math display">\[\text{sgn}(t)=\begin{cases}1 &amp; t&gt;0\\\\0 &amp; t=0\\\\-1 &amp; t&lt;0\end{cases}\]</span> 为求符号函数的傅里叶变换，先求“奇双边指数函数”的傅里叶变换，然后让指数系数趋向于0即可。</p><p>奇双边指数函数，即 <span class="math display">\[f(t)=\begin{cases}e^{-at} &amp;t&gt;0\\\\-e^{-at} &amp; t&lt;0\end{cases}\]</span></p><p><span class="math display">\[\mathscr{F}[f(t)]=\frac{-2j\omega} {a^2+\omega^2}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220627114355617.png" alt="image-20220627114355617" /><figcaption aria-hidden="true">image-20220627114355617</figcaption></figure><p>当<span class="math inline">\(a\to0\)</span>时，这个函数就趋向于<span class="math inline">\(\text{sgn}(t)\)</span>。如图是<span class="math inline">\(a=0.01\)</span>的图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220627114553417.png" alt="image-20220627114553417" /><figcaption aria-hidden="true">image-20220627114553417</figcaption></figure><p>则有： <span class="math display">\[\mathscr{F}[\text{sgn}(t)]=\frac 2{j\omega}\]</span></p></li><li><p>冲激信号 <span class="math display">\[\mathscr{F}[\delta(t)]=1\]</span></p></li><li><p>阶跃信号 <span class="math display">\[\mathscr{F}[u(t)]=\pi \delta(\omega)+\frac 1{j\omega}\]</span> 这个结果可以通过符号函数平移得到。</p></li></ol><h3 id="傅里叶变换的性质">傅里叶变换的性质</h3><p>如果有： <span class="math display">\[\mathscr F[f(t)]=F(\omega)\]</span> 则有：</p><h4 id="基于定义的性质">基于定义的性质</h4><ol type="1"><li><p>对称性 <span class="math display">\[\mathscr F[F(t)]=2\pi f(-\omega)\]</span></p></li><li><p>奇虚偶实性</p><ul><li><span class="math inline">\(|F(\omega)|\)</span>是偶函数</li><li><span class="math inline">\(\varphi(\omega)\)</span>是奇函数</li><li>如果<span class="math inline">\(f(t)\)</span>是实偶函数，则<span class="math inline">\(F(\omega)\)</span>是实偶函数</li><li>如果<span class="math inline">\(f(t)\)</span>是实奇函数，则<span class="math inline">\(F(\omega)\)</span>是虚奇函数</li></ul></li></ol><h4 id="基于时间运算的性质">基于时间运算的性质</h4><ol type="1"><li><p>反褶性质 <span class="math display">\[\mathscr F[f(-t)]=F(-\omega)=F^*(\omega)\]</span></p></li><li><p>时移性质 <span class="math display">\[\mathscr F[f(t-t_0)]=F(\omega)e^{-j\omega t_0}\]</span> 可以说：时移不改变幅频特性，而改变相频特性。</p></li><li><p>压扩性质 <span class="math display">\[\mathscr F[f(at)]=\frac 1{|a|}F\left(\frac \omega a\right)\]</span> 对于频域带限信号，时域的压缩和扩展，会导致频谱范围的增大和减小，频率分量的减少和增加。</p></li><li><p>时域综合性质 <span class="math display">\[\mathscr F[f(at+b)]=\frac 1{|a|}F\left(\frac \omega a\right)e^{j\omega\frac ba}\]</span></p></li><li><p>线性</p></li><li><p>时域微分性质 <span class="math display">\[\mathscr F[f&#39;(t)]=j\omega F(\omega)\]</span> 进一步： <span class="math display">\[\mathscr F[f^{(n)}(t)]=(j\omega)^nF(\omega)\]</span> 因为函数加上任意常数后，微分都相同。在运用这个性质时，要把信号的直流分量提取出来单独处理。例如：尝试利用时域微分性质和线性性质分别由<span class="math inline">\(\text{sgn}(t)\)</span>函数的傅里叶变换计算<span class="math inline">\(u(t)\)</span>的傅里叶变换，并比较结果。</p></li><li><p>时域积分性质 <span class="math display">\[\mathscr F\left[\int_{-\infty}^t f(\tau)\mathrm d\tau\right]=\frac {F(\omega)} {j\omega}+\pi F(0)\delta(\omega)\]</span></p></li></ol><h4 id="基于频域运算的性质">基于频域运算的性质</h4><ol type="1"><li><p>频移性质 <span class="math display">\[\mathscr F[f(t)e^{j\omega_0 t}]=F(\omega-\omega_0)\]</span></p></li><li><p>频域微分-时域线性加权性质 <span class="math display">\[\mathscr F[t^nf(t)]=j^n \frac{\mathrm d^nF(\omega)} {\mathrm d \omega^n}\]</span></p></li></ol><h4 id="卷积性质">卷积性质</h4><ol type="1"><li><p>时域卷积 <span class="math display">\[\mathscr F[f_1(t)\bigotimes f_2(t)]=F_1(\omega)F_2(\omega)\]</span></p></li><li><p>频域卷积 <span class="math display">\[\mathscr F[f_1(t)f_2(t)]=\frac 1{2\pi}F_1(\omega)\bigotimes F_2(\omega)\]</span></p></li></ol><h3 id="由变换的性质计算常用信号的傅里叶变换">由变换的性质计算常用信号的傅里叶变换</h3><ol type="1"><li><p>直流信号<span class="math inline">\(E\)</span></p><p>由 <span class="math display">\[\mathscr F[\delta(t)]=1\]</span> 因对称性，有： <span class="math display">\[\mathscr F[1]=2\pi \delta(\omega)\]</span> 因线性，有： <span class="math display">\[\mathscr F[E]=2\pi E\delta(\omega)\]</span></p></li><li><p><span class="math inline">\(f(t)=1/t\)</span></p><p>由 <span class="math display">\[\mathscr F[\text{sgn} (t)]=\frac 2{j\omega}\]</span> 因对称性，有： <span class="math display">\[\mathscr F\left[\frac 2{jt}\right]=2\pi\text{sgn}(-\omega)\]</span> 因线性，有： <span class="math display">\[\mathscr F\left[\frac 1 t\right]=-j\pi\text{sgn}(\omega)\]</span></p></li><li><p>正余弦信号</p><p>由 <span class="math display">\[\mathscr F[1]=2\pi\delta(\omega)\]</span> 因频移性质，有： <span class="math display">\[\mathscr F[e^{j\omega_0t}]=2\pi\delta(\omega-\omega_0)\\\\\mathscr F[e^{-j\omega_0t}]=2\pi\delta(\omega+\omega_0)\\\\\]</span> 因三角函数分解公式： <span class="math display">\[\sin \omega_0t=\frac{1} {2j}(e^{j\omega_0t}-e^{-j\omega_0t})\\\\\cos \omega_0t=\frac 12 (e^{j\omega_0t}+e^{-j\omega_0t})\]</span> 有： <span class="math display">\[\mathscr F[\sin(\omega_0 t)]=-j\pi [\delta(\omega-\omega_0)-\delta(\omega+\omega_0)]\\\\\mathscr F [\cos(\omega_0 t)]=\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]\]</span></p></li><li><p>三角脉冲信号</p><p>定义三角脉冲信号<span class="math inline">\(T_\tau(t)\)</span>为形如下面的信号，计算傅里叶变换。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/2BED7AAC8763AB14671045D511389210.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由 <span class="math display">\[\mathscr F[G_N(t)]=2N\text{Sa}(N\omega)\]</span> 则三角脉冲信号<span class="math inline">\(T_\tau(t)\)</span>是门信号的卷积，具体地： <span class="math display">\[T_\tau(t)=\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\bigotimes\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\]</span> 由于 <span class="math display">\[\mathscr F\left[\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\right]=\sqrt{\tau}\text{Sa}\left(\frac \tau2\omega\right)\]</span> 和卷积性质，有： <span class="math display">\[\mathscr F[T_\tau(t)]=\tau\text{Sa}^2\left(\frac \tau2 \omega\right)\]</span></p></li></ol><p>现将常用信号的傅里叶变换归纳如下：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(f(t)\)</span></th><th style="text-align: center;"><span class="math inline">\(F(\omega)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\delta(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\delta (t-t_0)\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{-j\omega t_0}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(2\pi\delta(\omega)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{j\omega_0t}\)</span></td><td style="text-align: center;"><span class="math inline">\(2\pi\delta(\omega-\omega_0)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\pi\delta(\omega)-\frac 1{j\omega}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(sgn(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac 2{j\omega}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\cos(\omega_0t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sin(\omega_0t)\)</span></td><td style="text-align: center;"><span class="math inline">\(-j\pi [\delta(\omega-\omega_0)-\delta(\omega+\omega_0)]\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(e^{-a\|t\|}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{2a} {a^2+\omega^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(G_N(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(2NSa(N\omega)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_\tau(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\tau\text{Sa}^2\left(\frac \tau2 \omega\right)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-at}u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {j\omega+a}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1/t\)</span></td><td style="text-align: center;"><span class="math inline">\(-j\pi\text{sgn}(\omega)\)</span></td></tr></tbody></table><p>这里提出一个趣味问题：</p><blockquote><p>【例】：是否存在一个时域、频域都有限的信号？</p><p>【解】：不存在。如果时域有限，则信号可以表示为： <span class="math display">\[f(t)=f(t)G_N(t-t_0)\]</span> 而<span class="math inline">\(G_N(t)\)</span>的傅里叶变换的频带是无限的。卷积之后，频带也是无限长的。频域有限情况同理可知。</p></blockquote><h3 id="周期信号的傅里叶变换">周期信号的傅里叶变换</h3><p>在之前，我们研究的是周期信号的傅里叶级数，和非周期信号的傅里叶变换。现在为了把它们都纳入傅里叶分析的框架中，我们要讨论周期信号的傅里叶变换。</p><p>我们都知道，周期信号的傅里叶系数<span class="math inline">\(F(n\omega)\)</span>叫“频谱函数”，而非周期信号的傅里叶变换<span class="math inline">\(F(\omega)\)</span>叫“频谱密度函数”。那么如果我们非要用频谱密度函数来表示频谱函数，那么结果应该是出现在其角频率各次谐波处的冲激函数。（请联想概率论中，如果我们非要用“概率密度函数”来表示离散分布的“分布函数”，那么会出现什么现象？）</p><p>周期函数的傅里叶系数和它一个周期内函数的傅里叶变换的关系为：</p><p><span class="math display">\[F(n\omega_1)=\left.\frac 1{T_1}F_1(\omega)\right|_{\omega=n\omega_1}\]</span></p><p>对于周期函数的傅里叶级数</p><p><span class="math display">\[f(t)=\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\]</span></p><p>作傅里叶变换：</p><p><span class="math display">\[\mathscr F\left[\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\right]=\sum_{n=-\infty}^{\infty}F(n\omega_1)\mathscr F[e^{jn\omega_1 t}]\]</span></p><p>由于频移性质：</p><p><span class="math display">\[\mathscr F [e^{jn\omega_1 t}]=2\pi\delta(\omega-n\omega_1)\]</span></p><p>故：</p><p><span class="math display">\[\mathscr F[f(t)]=\mathscr F\left[\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\right]=2\pi\sum_{n=-\infty}^{\infty}F(n\omega_1)\delta(\omega-n\omega_1)\]</span></p><p>这就是一般周期信号的傅里叶变换。</p><h4 id="典型周期信号的傅里叶变换">典型周期信号的傅里叶变换</h4><ol type="1"><li><p>正余弦信号</p><p>正余弦信号的傅里叶变换我们之前已经求过了。现在我们可以从一个新的视角来考虑这个问题。对于余弦信号而言，有：</p><p><span class="math display">\[\cos(\omega_1 t)=\frac 12(e^{j\omega_1 t}+e^{-j\omega_1t})\]</span></p><p>则其傅里叶级数的系数为：</p><p><span class="math display">\[F(n\omega_1)|_{n=\pm 1}=\frac 12\]</span></p><p>则其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[\cos(\omega_1 t)]=\pi[\delta(\omega-\omega_1)+\delta(\omega+\omega_1)]\]</span></p></li><li><p>周期冲激信号</p><p>周期冲激信号经常被用来采样，所以也算是一个常用的信号。我们来看一下它的傅里叶变换。</p><p>周期冲激信号的定义是：</p><p><span class="math display">\[\delta_{T_1}(t)=\sum_{n=-\infty}^{\infty}\delta(t-nT_1)\]</span></p><p>其傅里叶系数为：</p><p><span class="math display">\[F(n\omega_1)=\left.\frac 1{T_1}F_1(\omega)\right|_{\omega=n\omega_1}=\frac1{T_1}\]</span></p><p>则其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[\delta_{T_1}(t)]=\frac {2\pi} {T_1}\sum_{n=-\infty}^\infty \delta(\omega-n\omega_1)=\omega_1\sum_{n=-\infty}^\infty \delta(\omega-n\omega_1)\]</span></p><p>可以看出：周期冲激信号的傅里叶变换也是周期冲激信号。</p></li><li><p>周期矩形脉冲信号</p><p>周期矩形脉冲信号有两个参数：周期<span class="math inline">\(T_1\)</span>，脉宽<span class="math inline">\(\tau\)</span>，即：<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/AFA6FB4DBB59084944CDA2465162854F.png" alt="img" /></p><p>记作：<span class="math inline">\(G_{T_1,\tau}(t)\)</span>，图中<span class="math inline">\(E=1\)</span>.</p><p>在一个周期中，其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[G_{0,\tau}(t)]=\tau\text{Sa}\left(\frac{\omega\tau} {2}\right)\]</span></p><p>则周期矩形脉冲的傅里叶系数为</p><p><span class="math display">\[F(n\omega_1)=\frac{\tau} {T_1}\text{Sa}\left(\frac{n\omega_1\tau} {2}\right)\]</span></p><p>故周期矩形脉冲的傅里叶变换为</p><p><span class="math display">\[\tau\omega_1\sum_{n=-\infty}^{\infty}\text{Sa}\left(\frac{n\omega_1\tau} {2}\right)\delta(\omega-n\omega_1)\]</span></p></li></ol><h3 id="抽样">抽样</h3><p>一个基本的抽样过程等效于以下的模型：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/BEE55B4CEAA391E54CF074AFBC5F30B1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里的"<span class="math inline">\(\bigotimes\)</span>"是乘法的意思。即有：</p><p><span class="math display">\[f_s(t)=f(t)p(t)\]</span></p><p>这里的<span class="math inline">\(p(t)\)</span>就是脉冲信号，比如说周期冲激信号，周期矩形脉冲信号等等。</p><p>利用傅里叶变换的卷积定理，有（这里要熟练掌握冲激函数的卷积性质）：</p><p><span class="math display">\[\mathscr F[f_s(t)]=\frac 1{T_s}\sum_{n=-\infty}^{\infty}P_0(n\omega_s)F(\omega-n\omega_s)\]</span></p><p>也就是说，抽样信号的频谱是连续信号频谱以<span class="math inline">\(\omega_s\)</span>为周期的周期延拓，并收到脉冲信号频谱<span class="math inline">\(P_0(n\omega_s)\)</span>和脉冲信号周期<span class="math inline">\(T_s\)</span>的加权。</p><p>于是，我们发现，如果要求不发生频域混叠，那么原始连续信号必须在频域是带限信号。但是这实际上是不可能存在的。但是信号的主要频域往往确实是有限的，其它部分的分量可以忽略不计，为此我们可以定义<span class="math inline">\(-3\text{dB}\)</span>带宽，零点带宽等带宽（记作<span class="math inline">\(\omega_m\)</span>），把信号近似为一个频域带限信号。</p><p>那么，一个带限信号<span class="math inline">\(f(t)\)</span>,如果其频谱存在在频域区间<span class="math inline">\([-\omega_m,\omega_m]\)</span>，则可用抽样值唯一表示<span class="math inline">\(f(t)\)</span>,抽样值的间隔不能大于<span class="math inline">\(T_s=\frac{1} {2f_m}\)</span>,其中<span class="math inline">\(f_m=\frac{\omega_m} {2\pi}\)</span>，否则会发生频域混叠，这就是奈奎斯特采样定理。我们把<span class="math inline">\(f_s=2f_m\)</span>称作“奈奎斯特频率”，这是不发生频域混叠的最小抽样频率。</p><p>为了从抽样信号中恢复出原始信号，对理想冲激抽样，我们用一个截止频率为<span class="math inline">\(\omega_c\)</span>，幅度增益为<span class="math inline">\(T_s\)</span>的零延时低通滤波器即可，其中<span class="math inline">\(\omega_c\)</span>满足<span class="math inline">\(\omega_c\in[\omega_m,\omega_s-\omega_m]\)</span>.对于理想矩形脉冲抽样，滤波器的幅度增益应为<span class="math inline">\(T_s/(E\tau)\)</span></p><h2 id="连续系统实频域分析">连续系统实频域分析</h2><p>所谓的连续系统实频域分析，也就是利用傅里叶变换来分析连续系统。在本节，将首先介绍系统传递函数的概念，再介绍一类比较理想的系统：无失真系统，然后分析一类具体的系统：低通滤波器。</p><h3 id="系统频率响应">系统频率响应</h3><p>定义系统单位冲激响应<span class="math inline">\(h(t)\)</span>的傅里叶变换为系统频率响应。即：</p><p><span class="math display">\[H(\omega)=\int_{-\infty}^\infty h(t)e^{-j\omega t}\mathrm d t\]</span></p><p>如果系统的激励为<span class="math inline">\(e(t)\)</span>,激励的傅里叶变换为<span class="math inline">\(E(\omega)\)</span>，那么对系统的响应的傅里叶变换，有：</p><p><span class="math display">\[R(\omega)=E(\omega)\cdot H(\omega)\]</span></p><p>如果系统输入的是复指数信号<span class="math inline">\(e^{j\omega_0 t}\)</span>，那么有：</p><p><span class="math display">\[R=2\pi\delta(\omega-\omega_0)H(\omega)\]</span></p><p>则有：</p><p><span class="math display">\[r(t)=\frac 1{2\pi}\int_{-\infty}^{\infty}2\pi\delta(\omega-\omega_0)H(\omega)e^{j\omega t}\mathrm d t=e^{j\omega_0t}H(\omega_0)\]</span></p><p>这说明：系统对不同频率的正弦信号的幅度和相位加权不相同；不同的系统对相同频率的正弦信号的幅度和相位的加权也不相同。</p><p>对于频率响应<span class="math inline">\(H(\omega)\)</span>，称<span class="math inline">\(|H(\omega)|\)</span>为系统的幅频响应，而<span class="math inline">\(\varphi(\omega)\)</span>为系统的相频响应。</p><p>如果系统用微分方程</p><p><span class="math display">\[C_0r^{(n)}(t)+C_1r^{(n-1)}(t)+\cdots+C_nr(t)=E_0e^{(m)}(t)+E_1e^{(m-1)}(t)+\cdots+E_me(t)\]</span></p><p>可以直接写出其频率响应：</p><p><span class="math display">\[H(\omega)=\frac{\sum_{i=0}^nC_i(j\omega)^{n-i} } {\sum_{j=1}^m E_{j}(j\omega)^{m-j} }\]</span></p><p>在已知频率响应和激励，求系统响应时，一般有两种思路。其一是系统激励以傅里叶级数形式给出，这时只需要针对每个谐波分量计算对应的幅频响应和相频响应，然后把响应作用于激励即可。另一种思路是先求出激励的傅里叶变换，然后用图像和系统频率响应相乘，得到响应的傅里叶变换，最后得到结果。</p><h3 id="无失真系统">无失真系统</h3><p>输出响应能再现系统的输入，只有出现时刻和幅度不同，即没有改变输入波形的形状，这种系统叫做无失真系统。那么把冲激信号输入系统，就可以得到无失真系统的频响：</p><p><span class="math display">\[H(\omega)=ke^{-j\omega t_0}\]</span></p><p>则其幅频，相频特性如下：</p><p><span class="math display">\[|H(\omega)|=k\\\\\varphi(\omega)=-\omega t_0\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/33FCDB8A45A057AE5F76B35B9A69EBCE.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>相频特性是一条直线的含义是：相频特性表示了系统的延时，对信号的所有频率分量，应该有相同的延时，即相位附加值相同。例如输入<span class="math inline">\(E_1\sin(\omega_1t)\)</span>，那么理应得到输出<span class="math inline">\(E_1\sin\left[\omega(t+\varphi(\omega))\right]=E_1\sin\left[\omega(t+\frac{\varphi(\omega)} {\omega})\right]\)</span>，于是，为了对不同的频率分量得到相同的附加相移，就需要：</p><p><span class="math display">\[\forall \omega_1,\omega_2,\frac{\varphi(\omega_1)} {\omega_1}=\frac{\varphi(\omega_2)} {\omega_2}\]</span></p><h3 id="低通滤波器">低通滤波器</h3><p>理想滤波器是在特定频段范围内的无失真传输系统。这里之所以只讨论低通滤波器，是其它滤波器可以由低通滤波器转换而来。具体如何转换，我们后面再说。</p><p>理想低通滤波器的频响特性如下：</p><p><span class="math display">\[H(\omega)= \begin{cases}e^{-j \omega t_{0} } &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p>注意，切不可以以为理想低通滤波器的频响函数是频域门函数，因为还要考虑附加相移（时域延迟）。有：</p><p><span class="math display">\[|{H}(\omega)|= \begin{cases}1 &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p><span class="math display">\[\varphi(\omega)= \begin{cases}-\omega t_{0} &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p>对频响函数作傅里叶逆变换，可得单位冲激响应：</p><p><span class="math display">\[h(t)=\frac{\omega_{c} } {\pi} \cdot \text{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right]\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/DF189DDD56F929706856BF8B26DA1D67.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="其它滤波器">其它滤波器</h4><ul><li><p>高通滤波器</p><p>无失真全通系统-低通滤波器=高通滤波器。因而，有：</p><p><span class="math display">\[H_{h}(\omega)=e^{-\mathrm{j} \omega t_{0} }\left[1-u\left(\omega+\omega_{c}\right)+u\left(\omega-\omega_{c}\right)\right]\]</span></p><p><span class="math display">\[h_{h}(t)=\delta\left(t-t_{0}\right)-h_{l}(t)=\delta\left(t-t_{0}\right)-\frac{\omega_{c} } {\pi} \cdot \mathrm{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right]\]</span></p></li><li><p>带通滤波器</p><p>带通滤波器可以由理想低通滤波器频响向两侧搬移，再对相频特性进行修正得到。</p><p><span class="math display">\[H_{b}(\omega)=e^{-\mathrm{j} \omega_{0} }\left[\left(u\left(\omega+\omega_{h}\right)-u\left(\omega+\omega_{l}\right)\right)+\left(u\left(\omega-\omega_{l}\right)-u\left(\omega-\omega_{h}\right)\right)\right]\]</span></p><p><span class="math display">\[h_{b}(t)=\frac{2 \omega_{c} } {\pi} \cdot \operatorname{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right] \cos \left[\omega_{0}\left(t-t_{0}\right)\right]\]</span></p><p>其中</p><p><span class="math display">\[\omega_{c}=\frac{\omega_{h}-\omega_{l} } {2}, \omega_{0}=\frac{\omega_{h}+\omega_{l} } {2}\]</span></p></li></ul><h3 id="系统的因果性">系统的因果性</h3><p>我们都知道，<span class="math inline">\(LTI\)</span>系统因果的充要条件是：</p><p><span class="math display">\[h(t)=h(t)u(t)\]</span></p><p>现在我们从频域考虑这个问题。</p><h4 id="佩里维纳准则">佩里维纳准则</h4><p>一个幅频响应绝对可积的系统物理可实现的必要条件是：</p><p><span class="math display">\[\int_{-\infty}^{\infty}\frac{|\ \ln|H(\omega)|\ |} {1+\omega^2}\mathrm d\omega&lt;\infty\]</span></p><p>从直观角度考虑，佩里维纳准则要求系统的幅频响应不能衰减得太快。特别的，如果幅频响应在某个连续频带上为<span class="math inline">\(0\)</span>，那么系统就不可实现。</p><h4 id="希尔伯特变换">希尔伯特变换</h4><p>接下来从时域入手，讨论判断系统因果性的充要条件。</p><p>从用卷积性质计算<span class="math inline">\(h(t)u(t)\)</span>的傅里叶变换入手，设<span class="math inline">\(H(\omega)=R(\omega)+jX(\omega)\)</span>，那么<span class="math inline">\(R,X\)</span>构成一希尔伯特变换对。所谓的希尔伯特变换是指：</p><p><span class="math display">\[\hat{x}(t)=\mathscr H[x(t)]=x(t)\bigotimes\frac1{\pi t}\]</span></p><p>把卷积展开，有：</p><p><span class="math display">\[\begin{aligned}\hat{x}(t) &amp;=\frac{1} {\pi} \int_{-\infty}^{\infty} x(\tau) \frac{1} {t-\tau} d \tau \\\\&amp;=-\frac{1} {\pi} \int_{-\infty}^{\infty} x(t+\tau) \frac{1} {\tau} d \tau \\\\&amp;=\frac{1} {\pi} \int_{-\infty}^{\infty} x(t-\tau) \frac{1} {\tau} d \tau\end{aligned}\]</span></p><p>对一个系统作希尔伯特变换，实质上是将其经过一个<span class="math inline">\(\pi/2\)</span>相移器（注意：这里不是时移）。</p><p>希尔伯特变换将在《随机过程理论》中再次详细说明，这里只提两个重要性质：</p><ul><li><p><span class="math display">\[\mathscr F[\hat{x}(t)]=-j\mathscr F[x(t)]sgn(\omega)\]</span></p></li><li><p><span class="math display">\[\mathscr H[\hat{x}(t)]=-x(t)\]</span></p></li></ul><p>则系统因果的充要条件是：频响函数<span class="math inline">\(H(\omega)\)</span>的实部和虚部是一对希尔伯特变换对。</p><h3 id="相关定理以及能量和功率">相关定理，以及能量和功率</h3><p>为了动态地描述两个信号的相关关系，避免基于内积定义的相关系数所带来的种种漏洞.</p><p>对于能量信号，我们定义相关函数：</p><p><span class="math display">\[R_{12}(\tau)=\int_{-\infty}^{\infty}f_1(t)f^*_2(t-\tau)\mathrm dt\]</span></p><p>定义自相关函数：</p><p><span class="math display">\[R(\tau)=\int_{-\infty}^{\infty} f(t) f^{*}(t-\tau) d t\]</span></p><p>如果信号是功率信号，上面的积分可能不收敛。定义功率信号的相关函数：</p><p><span class="math display">\[R_{12}(\tau)=\lim _{T \rightarrow \infty} \frac{1} {T} \int_{-\frac{T} {2} }^{\frac{T} {2} } f_{1}(t) f_{2}^{*}(t-\tau) \mathrm{d} t\]</span></p><p>自相关函数：</p><p><span class="math display">\[R(\tau)=\lim _{T \rightarrow \infty} \frac{1} {T} \int_{-\frac{T} {2} }^{\frac{T} {2} } f(t) f^{*}(t-\tau) d t\]</span></p><p>在下学期学的《随机过程理论》中，我们将从期望的角度重新认识相关函数。</p><p>有“相关定理”：</p><p><span class="math display">\[\mathscr{F}\left[R_{12}(\tau)\right]=F_{1}(\omega) F_{2}^{*}(\omega)\]</span></p><p>进一步，对自相关函数：</p><p><span class="math display">\[\mathscr{F}[R(\tau)]=|F(\omega)|^{2}\]</span></p><p>联想到帕塞瓦尔定理：</p><p><span class="math display">\[\int_{-\infty}^{\infty}|f(t)|^2\mathrm d t=\int_{-\infty}^{\infty}|F(2\pi f)|^2\mathrm d f\]</span></p><p>我们可以令<span class="math inline">\(\varepsilon(\omega)=|F(\omega)|^2\)</span>为“能量密度函数”，也叫“能量谱函数”，它反映了能量在频域上的分布。则能量谱函数和能量信号自相关函数是一对傅里叶变换对。</p><p>对于功率信号，定义功率谱函数：</p><p><span class="math display">\[p(\omega)=\lim_{T\to \infty}\frac{|F_T(\omega)|^2} {T}\]</span></p><p>则功率信号的功率谱函数和自相关函数也是一对傅里叶变换对，这叫做“维纳辛钦定理”。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>在一个周期里的两个半周期里呈现奇对称的函数，即<span class="math inline">(f(t)=-f(tT2))</span>​ <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验3：离散时间系统特性分析</title>
    <link href="/2022/06/22/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A3/"/>
    <url>/2022/06/22/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A3/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第三个实验，离散时间系统特性分析</p><span id="more"></span><h2 id="实验目的">实验目的</h2><ol type="1"><li><p>深入理解单位样值相应，离散系统的频率响应的概念；</p></li><li><p>掌握通过计算机进行求得离散系统的单位样值相应，以及离散系统的频率响应的方法。</p></li></ol><h2 id="实验原理">实验原理</h2><p>对于离散系统的单位样值而言，在实际处理过程中，不可能选取无穷多项的取值。往往是选取有限项的取值，当然这里会产生一个截尾误差，但只要这个误差在相对小一个范围里，可以忽略不计。</p><p>另外，在一些实际的离散系统中，往往不是事先就能得到描述系统的差分方程的，而是通过得到系统的某些相应值，则此时系统的分析就需借助计算机的数值处理来进行，得到描述系统的某些特征，甚至进而得到描述系统的数学模型。</p><p>本实验首先给出描述系统的差分方程，通过迭代的方法求得系统的单位样值响应，进而求得该离散系统的频率响应。限于试验条件，虽然给出了系统方程，但处理的方法依然具有同样的实际意义。</p><p>具体的方法是：</p><p>1．在给定系统方程的条件下，选取激励信号为<span class="math inline">\(\delta(n)\)</span>，系统的起始状态为零状态，通过迭代法，求得系统的单位样值响应<span class="math inline">\(h(n)(n=0,1,\cdots,N)\)</span></p><p>2．利用公式 <span class="math display">\[H(e^{j\Omega})=\sum_{n=0}^Nh(n)e^{-j\Omega n},\Omega\in[0,2\pi]\]</span> 计算系统的频率响应。</p><h2 id="实验内容">实验内容</h2><h3 id="求单位样值响应">求单位样值响应</h3><p>已知系统： <span class="math display">\[y(n)-1.3y(n-1)-0.4y(n-2)=x(n-1)\]</span> 求单位样值响应。</p><p>可以用迭代法求解，迭代公式为： <span class="math display">\[y(n)=x(n-1)+1.3y(n-1)+0.4y(n-2)\]</span></p><h3 id="求系统幅频响应">求系统幅频响应</h3><p>利用公式 <span class="math display">\[H(e^{j\Omega})=\sum_{n=0}^Nh(n)e^{-j\Omega n},\Omega\in[0,2\pi]\]</span> 计算系统的频率响应。</p><p>需要注意，计算出的<span class="math inline">\(H(e^{j\Omega})\)</span>是一个复数，但是C语言对复数的支持并不是很好，因此我们可以分别计算实部和虚部。有：</p><p><span class="math display">\[\Re\left[H(e^{j\Omega})\right]=\sum_{k=0}^{10}h(k)\cos(-\Omega k)\\\\\Im\left[H(e^{j\Omega})\right]=\sum_{k=0}^{10}h(k)\sin(-\Omega k)\\\\\text{Amp}=|H(e^{j\Omega})|=\sqrt{\Re ^2+\Im ^2}\\\\\varphi=\arctan(\frac{\Re\left[H(e^{j\Omega})\right]}{\Im\left[H(e^{j\Omega})\right]})\]</span></p><h2 id="实验代码及其流程图">实验代码及其流程图</h2><p>实验流程图如下：</p><p><img src="" /><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/234.bmp" alt="234" /></p><p>实验代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM2.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-type">int</span> x[MAXN];<br><span class="hljs-type">double</span> h[MAXN], t[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">h_</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> h[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>x[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>t[i] = i;<br>h[i] = x[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1.3</span> * <span class="hljs-built_in">h_</span>(i - <span class="hljs-number">1</span>) - <span class="hljs-number">0.4</span> * <span class="hljs-built_in">h_</span>(i - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>, h[i]);<br>&#125;<br><span class="hljs-type">double</span> w[MAXN], amp[MAXN], phi[MAXN];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">2</span> * PI; i += <span class="hljs-number">0.1</span> * PI) &#123;<br><span class="hljs-type">double</span> a = <span class="hljs-number">0.0</span>, b = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">10</span>; ++j) &#123;<br>a += h[j] * <span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span> * j * i);<br>b += h[j] * <span class="hljs-built_in">sin</span>(<span class="hljs-number">-1</span> * j * i);<br>&#125;<br><span class="hljs-type">double</span>  tem_phi = <span class="hljs-built_in">atan2</span>(b, a);<br>w[cnt] = i;<br>amp[cnt] = <span class="hljs-built_in">sqrt</span>(a * a + b * b);<br>phi[cnt] = tem_phi;<br>++cnt;<br>&#125;<br>PPMdata background, axis, grid, line;<br>background = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br><span class="hljs-function">Graph <span class="hljs-title">H</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;response.ppm&quot;</span>)</span></span>;<br><span class="hljs-function">Graph <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, PI, <span class="hljs-number">5.0</span>, <span class="hljs-number">2.5</span> * PI, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;amp-fre.ppm&quot;</span>)</span></span>;<br><span class="hljs-function">Graph <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, PI, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.5</span> * PI, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;pha-fre.ppm&quot;</span>)</span></span>;<br>A.<span class="hljs-built_in">drawXY</span>(w, amp, cnt);<br>P.<span class="hljs-built_in">drawXY</span>(w, phi, cnt);<br>H.<span class="hljs-built_in">drawXY</span>(t, h, <span class="hljs-number">11</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8.4f %8.4f %8.4f\n&quot;</span>, w[i], amp[i], phi[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验结果">实验结果</h2><h3 id="系统单位样值响应">系统单位样值响应</h3><table><thead><tr class="header"><th><span class="math inline">\(n\)</span></th><th><span class="math inline">\(\delta(n)\)</span></th><th><span class="math inline">\(h(n)\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>0.000000</td></tr><tr class="even"><td>1</td><td>0</td><td>1.000000</td></tr><tr class="odd"><td>2</td><td>0</td><td>1.300000</td></tr><tr class="even"><td>3</td><td>0</td><td>1.290000</td></tr><tr class="odd"><td>4</td><td>0</td><td>1.157000</td></tr><tr class="even"><td>5</td><td>0</td><td>0.988100</td></tr><tr class="odd"><td>6</td><td>0</td><td>0.821730</td></tr><tr class="even"><td>7</td><td>0</td><td>0.673009</td></tr><tr class="odd"><td>8</td><td>0</td><td>0.546220</td></tr><tr class="even"><td>9</td><td>0</td><td>0.440882</td></tr><tr class="odd"><td>10</td><td>0</td><td>0.354659</td></tr></tbody></table><p>响应-时间图如下</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/response.jpg" alt="response" /><figcaption aria-hidden="true">response</figcaption></figure><h3 id="系统幅频和相频特性">系统幅频和相频特性</h3><table><thead><tr class="header"><th><span class="math inline">\(\Omega\)</span></th><th><span class="math inline">\(\text{Amp}(\Omega)\)</span></th><th><span class="math inline">\(\varphi(\Omega)\)</span></th></tr></thead><tbody><tr class="odd"><td>0.0000</td><td>8.5716</td><td>0.0000</td></tr><tr class="even"><td>0.3142</td><td>6.1182</td><td>-1.3645</td></tr><tr class="odd"><td>0.6283</td><td>2.1370</td><td>-2.1140</td></tr><tr class="even"><td>0.9425</td><td>1.7731</td><td>-2.2523</td></tr><tr class="odd"><td>1.2566</td><td>0.7426</td><td>-2.7356</td></tr><tr class="even"><td>1.5708</td><td>0.9027</td><td>-2.5992</td></tr><tr class="odd"><td>1.8850</td><td>0.3754</td><td>-3.0217</td></tr><tr class="even"><td>2.1991</td><td>0.6304</td><td>-2.8331</td></tr><tr class="odd"><td>2.5133</td><td>0.2467</td><td>-3.1356</td></tr><tr class="even"><td>2.8274</td><td>0.5384</td><td>-3.0404</td></tr><tr class="odd"><td>3.1416</td><td>0.2124</td><td>3.1416</td></tr><tr class="even"><td>3.4558</td><td>0.5384</td><td>3.0404</td></tr><tr class="odd"><td>3.7699</td><td>0.2467</td><td>3.1356</td></tr><tr class="even"><td>4.0841</td><td>0.6304</td><td>2.8331</td></tr><tr class="odd"><td>4.3982</td><td>0.3754</td><td>3.0217</td></tr><tr class="even"><td>4.7124</td><td>0.9027</td><td>2.5992</td></tr><tr class="odd"><td>5.0265</td><td>0.7426</td><td>2.7356</td></tr><tr class="even"><td>5.3407</td><td>1.7731</td><td>2.2523</td></tr><tr class="odd"><td>5.6549</td><td>2.1370</td><td>2.1140</td></tr><tr class="even"><td>5.9690</td><td>6.1182</td><td>1.3645</td></tr><tr class="odd"><td>6.2832</td><td>8.5716</td><td>0.0000</td></tr></tbody></table><p>幅频曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/amp-fre.jpg" alt="amp-fre" /><figcaption aria-hidden="true">amp-fre</figcaption></figure><p>相频曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/pha-fre.jpg" alt="pha-fre" /><figcaption aria-hidden="true">pha-fre</figcaption></figure><h2 id="实验总结">实验总结</h2><p><span class="math inline">\(0\)</span>时对应的是低频，<span class="math inline">\(\pi\)</span>时对应的是高频，通过幅频特性曲线可以看出，本系统是离散的低通滤波器。</p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于电磁场辐射的那些事</title>
    <link href="/2022/06/21/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E8%BE%90%E5%B0%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/21/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E8%BE%90%E5%B0%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>这部分主要讨论的是电磁波是如何产生的。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="时变场的位函数">时变场的位函数</h2><p>这一部分不是重点，我写完其它的再来写。</p><h2 id="时变电偶极子的辐射">时变电偶极子的辐射</h2><h3 id="时变电偶极子">时变电偶极子</h3><p>时变电偶极子是由大小相等、方向相反的两个点电荷<span class="math inline">\(\pm q(t)\)</span>组成的，其中<span class="math inline">\(q(t)\)</span>按正弦形式变化。这两个点电荷间距为<span class="math inline">\(\mathbf{d}s\to 0\)</span>，电偶极子的有效长度（也叫电尺寸）为<span class="math inline">\(\mathbf{d}s/\lambda\)</span>。有时，需要对电偶极子的电尺寸进行检验，看它是不是满足“远小于一”的条件。如果不满足，不应用电偶极子模型分析。</p><p>对于电偶极子之间的电流，有关系式：</p><p><span class="math display">\[I(t)=\frac{\mathbf{d}q(t)} {\mathbf{d}t}\]</span></p><p>写成复数形式，就是</p><p><span class="math display">\[\dot{I}=j\omega \dot{q}\]</span></p><h3 id="全空间电磁场表达式">全空间电磁场表达式</h3><p>磁场：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>电场</p><p><span class="math display">\[\begin{cases}&amp;\dot{E}_{r_{s} }=-\frac{\dot{I} d s \beta^{2} \eta 2 \cos \theta} {4 \pi}\left[\frac{1} {\left(j \beta r_{s}\right)^{2} }+\frac{1} {\left(j \beta r_{s}\right)^{3} }\right] e^{-j \beta r_{s} } \\\\&amp;\dot{E}_{\theta}=-\frac{\dot{I} d s \beta^{2} \eta \sin \theta} {4 \pi}\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }+\frac{1} {\left(j \beta r_{s}\right)^{3} }\right] e^{-j \beta r_{s} }\end{cases}\]</span></p><p>其中，有：</p><p><span class="math display">\[\frac{\beta} {\omega \varepsilon}=\frac{1} {c \varepsilon}=\frac{\sqrt{\mu \varepsilon} } {\varepsilon}=\eta\]</span></p><p>这个<span class="math inline">\(\eta\)</span>就是波阻抗。</p><h3 id="时变电偶极子场的讨论">时变电偶极子场的讨论</h3><h4 id="近区场">近区场</h4><p>满足<span class="math inline">\(\beta r_s&lt;&lt;1\)</span>的条件，观察点<span class="math inline">\(P\)</span>离电偶极子比较近，这个区域称为近区。</p><p>在近区中，有：</p><p><span class="math display">\[(\beta r_s)^{-3}&gt;&gt;(\beta r_s)^{-2}&gt;&gt;(\beta r_s)^{-1}\]</span></p><p>而且</p><p><span class="math display">\[e^{-j\beta r_s}=0\]</span></p><p>对于磁场，本来<span class="math inline">\(\tilde{H}\)</span>的表达式是：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>中括号中第一项省去，后面的<span class="math inline">\(\exp\)</span>项省去，有：</p><p><span class="math display">\[\dot{H}_{\varphi\text{近} }\approx \frac{\dot{I} d s \sin \theta} {4 \pi r_{s}^{2} }\]</span></p><p>同理，对于电场，有：</p><p><span class="math display">\[\tilde{E}_{\text{近} }\approx \frac{\dot{I} d s} {4 \pi j \omega \varepsilon} \cdot \frac{1} {r_{s}^{3} }\left[i_{r s} 2 \cos \theta+i_{\theta} \sin \theta\right]\]</span></p><p>我们观察电场和磁场表达式，容易发现，近区场的主要成分是似静场，也就是近似于静电（磁）场的场。它的复坡印廷矢量是一个纯虚数，于是，这部分的能量不会被辐射出现，好像是被束缚在了近区，因此似静场也叫<strong>“束缚场”</strong>。我们可以说：时变电偶极子近区场的主要成分是束缚场；<strong>但是不可以说：近区场就是束缚场。</strong></p><h4 id="远区场">远区场</h4><p>当<span class="math inline">\(\beta r_s&gt;&gt;1\)</span>时，观察点<span class="math inline">\(P\)</span>离电偶极子很远，这样的区域称为远区。</p><p>在远区中，有：</p><p><span class="math display">\[(\beta r_s)^{-1}&gt;&gt;(\beta r_s)^{-2}&gt;&gt;(\beta r_s)^{-3}\]</span></p><p>对于磁场，本来<span class="math inline">\(\tilde{H}\)</span>的表达式是：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>中括号中的第二项省去，有：</p><p><span class="math display">\[\dot{H}_{\varphi\text{远} } \approx \frac{i d s \sin \theta} {4 \pi r_{s} } j \beta e^{-j \beta r_{s} }=j \frac{i d s \sin \theta} {2 \lambda r_{s} } e^{-j \beta r_{s} }\]</span></p><p>很多同学可能不知道这个等号是怎么回事。我来说明一下：</p><p>有波长公式：</p><p><span class="math display">\[\lambda f=c\]</span></p><p>又有：</p><p><span class="math display">\[\omega=2\pi f\]</span></p><p>因此：</p><p><span class="math display">\[\lambda=\frac{2\pi c} {\omega}\]</span></p><p>又因为：</p><p><span class="math display">\[c=\frac 1{\sqrt{\mu\varepsilon} }\]</span></p><p>因此：</p><p><span class="math display">\[2\lambda\beta=2\cdot\frac{2\pi} {\omega\sqrt{\mu\varepsilon} }\cdot\omega\sqrt{\mu\varepsilon}=4\pi\]</span></p><p>可以看出，掌握电磁场中各个量的代换关系，是非常重要的。</p><p>同理，对于电场，有：</p><p><span class="math display">\[\dot{E}_{\theta} \approx j \eta \frac{\dot{I} d s} {2 \lambda r_{s} } \sin \theta e^{-j \beta r_{s} }\]</span></p><p>计算坡印廷矢量：</p><p><span class="math display">\[\tilde{S}=\frac{1} {2} \tilde{E} \times \widetilde{H}^{*}=i_{r_{s} } \frac{1} {2} \eta\left|\dot{H}_{\varphi}\right|^{2}\]</span></p><p>可以看出，在远区，电磁场有一个向外发射的功率流。远区中，电磁场携带的能量会全部辐射出去，因此远区场的 <strong>主要部分</strong> ，也就是和<span class="math inline">\(r_s^{-1}\)</span>成正比的这部分，被称为辐射场。辐射场中电场和磁场同相位，在等相位面上，电磁场振幅按照<span class="math inline">\(\sin \theta\)</span>规律变化，因此辐射波是一个非均匀球面波。</p><p>必须说明的是：辐射场在近区也是存在的，不过十分微弱，不起主导作用。即：近区场也有能量发射的部分，远区场也有能量交换的部分，这里讨论的只是占主导作用的部分。因此 <strong>不能说：近区场就是束缚场，远区场就是辐射场</strong> 。随着<span class="math inline">\(r_s\)</span>的增长，辐射场（即反比于<span class="math inline">\(r_s\)</span>的项）比其它反比于<span class="math inline">\(r_s\)</span>高次方的项减少的慢，因此辐射场渐渐起了主导作用。用一个示意图描述，就是：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620233646037.png" alt="image-20220620233646037" /><figcaption aria-hidden="true">image-20220620233646037</figcaption></figure><h4 id="方向性函数">方向性函数</h4><p>方向性函数的定义：</p><p><span class="math display">\[F(\theta,\varphi)=\frac{|E(\theta,\varphi)|} {|E_maxx|}\]</span></p><p>在时变电偶极子的情况下，有：</p><p><span class="math display">\[F(\theta,\varphi)=|\sin \theta|\]</span></p><p>在Mathematica中运行代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">SphericalPlot3D</span><span class="hljs-punctuation">[</span><br> <span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">\[Theta]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Theta]</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Pi</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Phi]</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以看出它长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620234231700.png" alt="image-20220620234231700" /><figcaption aria-hidden="true">image-20220620234231700</figcaption></figure><p>其E面方向图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620234857788.png" alt="image-20220620234857788" /><figcaption aria-hidden="true">image-20220620234857788</figcaption></figure><p>H面方向图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620235040126.png" alt="image-20220620235040126" /><figcaption aria-hidden="true">image-20220620235040126</figcaption></figure><h4 id="辐射功率和辐射电阻">辐射功率和辐射电阻</h4><p>时变电偶极子的辐射功率为：</p><p><span class="math display">\[\dot{P}_r=\oint_A\tilde{S}\mathbf{d}a=\frac \pi 3\eta I^2\left(\frac{ds} {\lambda}\right)^2\]</span></p><p>由</p><p><span class="math display">\[P=I^2R\]</span></p><p>得辐射电阻：</p><p><span class="math display">\[R_r=\frac{2\pi} {3}\eta\left(\frac{ds} {\lambda}\right)^2\]</span></p><h2 id="时变磁偶极子的辐射">时变磁偶极子的辐射</h2><h3 id="时变磁偶极子">时变磁偶极子</h3><p>时变磁偶极子的模型是一个面积为<span class="math inline">\(a\)</span>，载有电流<span class="math inline">\(I(t)\)</span>的导线环。当导线环的大小远远小于波长时，可以视为一个时变磁偶极子。</p><h3 id="电磁对偶原理">电磁对偶原理</h3><p>在讨论时变磁偶极子之前，首先来介绍电磁对偶原理。在之前，曾经提到过对称形式场定律：</p><p><span class="math display">\[\begin{cases}\nabla \times \boldsymbol{H}=\varepsilon_{0} \frac{\partial \boldsymbol{E} } {\partial t}+\boldsymbol{J} \\\\\nabla \cdot \varepsilon_{0} \boldsymbol{E}=\boldsymbol{\rho} \\\\\nabla \cdot \boldsymbol{J}=-\frac{\partial \rho} {\partial t}\end{cases}\]</span></p><p><span class="math display">\[\begin{cases}\nabla \times \boldsymbol{E}=-\mu_{0} \frac{\partial \boldsymbol{H} } {\partial t}-\boldsymbol{J}_{\mathrm{M} } \\\\\nabla \cdot \mu_{0} \boldsymbol{E}=\rho_{\mathrm{M} } \\\\\nabla \cdot \boldsymbol{J}_{\mathrm{M} }=-\frac{\partial \rho_{\mathrm{M} }} {\partial t}\end{cases}\]</span></p><p>这两组方程形式完全相同，只是第一个式子的源是电流、电荷；而第二个式子的源是磁流，磁荷。因此，如果一个只含电流、电荷源的系统的解<span class="math inline">\(E_1\)</span>,<span class="math inline">\(H_1\)</span>已经求得，那么对于一个其它完全相同，只是把电流换成磁流，把电荷换成磁荷的新系统，它的解<span class="math inline">\(E_2\)</span>和<span class="math inline">\(H_1\)</span>，<span class="math inline">\(H_2\)</span>和<span class="math inline">\(E_1\)</span>应该有完全一样的形式</p><p>不妨对比一般性的两个系统a和b，如下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/73D6797EF70B879E8BF95BC4795FE7A4.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>两个系统有完全相同的区域和边界，只是把电流和磁流，电荷和磁荷调换。那么存在以下的代换关系：</p><p><span class="math display">\[\begin{aligned}E&amp;\to H\\\\H&amp;\to E\\\\\rho &amp;\to -\rho_M\\\\\rho_M &amp;\to -\rho\\\\J&amp;\to-J_M\\\\J_M &amp;\to-J\\\\\varepsilon &amp;\to -\mu\\\\\mu &amp;\to -\varepsilon\end{aligned}\]</span></p><p>如果上面系统<span class="math inline">\((a)\)</span>的解<span class="math inline">\(E_a,H_a\)</span>已经求出，按照上面的代换关系，就可以立刻得到系统<span class="math inline">\((b)\)</span>的解。</p><h3 id="全空间电磁场表达式-1">全空间电磁场表达式</h3><p>结合上面的电磁对偶关系，对于时变电偶极子式子里面的<span class="math inline">\(\beta/\eta=\omega\varepsilon\)</span>应该代换成<span class="math inline">\(-\beta\eta=-\omega\mu\)</span>,因此<span class="math inline">\(\eta\)</span>代换为<span class="math inline">\(-1/\eta\)</span>,还有关系<span class="math inline">\(\dot{I}ds\to-j\omega\mu\dot{I}a\)</span>，可以直接写出全空间电磁场表达式：</p><p><span class="math display">\[\begin{aligned}&amp;\dot{E}_{\varphi}(\boldsymbol{r})=\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} \sin \theta} {4 \pi}\left[\frac{1} {j \beta_{0} r_{s} }+\frac{1} {\left(j\beta_{0} r_{s}\right)^{2} }\right] e^{-j \beta_{0} r_{s} }  \\\\&amp;\dot{H}_{r_{s} }(\boldsymbol{r})=-\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} 2 \cos \theta} {4 \pi \eta_{0} }\left[\frac{1} {\left(j \beta_{0} r_{s}\right)^{2} }+\frac{1} {\left(j \beta_{0} r_{s}\right)^{3} }\right] e^{-j \beta_{0} r_{s} } \\\\&amp;\dot{H}_{\theta}(\boldsymbol{r})=-\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} \sin \theta} {4 \pi \eta_{0} }\left[\frac{1} {j \beta_{0} r_{s} }+\frac{1} {\left(j \beta_{s} r_{\omega}\right)^{2} }+\frac{1} {\left(j \beta_{s} r_{0}\right)^{3} }\right] e^{-j\beta_{0} r_{s} } \end{aligned}\]</span></p><h3 id="时变磁偶极子场的讨论">时变磁偶极子场的讨论</h3><h4 id="近区场-1">近区场</h4><p>近区场应该保留<span class="math inline">\((\beta r_s)\)</span>的最低次项（也就是<span class="math inline">\(\frac{1} {\beta r_s}\)</span>的最高次项）,删去<span class="math inline">\(e\)</span>的指数项，有：</p><p><span class="math display">\[E_\varphi\approx\frac{-j\omega\mu_0\dot{I}a\sin \theta} {4\pi r_s^2}\]</span></p><p><span class="math display">\[H\approx \frac{j\omega\mu_0\dot{I}a} {4\pi j\omega \mu_0}\frac{1} {r_s^3}(i_{rs}2\cos\theta+i_\theta\sin \theta)=\frac{\dot{I}a} {4\pi}\frac{1} {r_s^3}(i_{rs}2\cos\theta+i_\theta\sin \theta)\]</span></p><h4 id="远区场-1">远区场</h4><p><span class="math display">\[H_{远}-\frac{\pi \dot{I}a} {\lambda^2r_s}\sin \theta e^{-j\beta_0r_s}\]</span></p><p><span class="math display">\[E_{远}=\frac{\pi\eta\dot{I}a} {\lambda^2r_s}\sin\theta e^{-j\beta_0r_s}\]</span></p><h4 id="方向性函数-1">方向性函数</h4><p><span class="math display">\[F(\theta,\varphi)=|\sin \theta|\]</span></p><p>形状和电偶极子完全一样，但是E和H面的图要对换。</p><h4 id="辐射功率和辐射电阻-1">辐射功率和辐射电阻</h4><p>由电磁对偶原理，有：</p><p><span class="math display">\[P_r=\frac{\pi} {3\eta}\frac{\omega^2\mu^2I^2a^2} {\lambda^2}\]</span></p><p>化简后， 有：</p><p><span class="math display">\[P_r=\frac{4} {3}\pi^3\eta\frac{I^2a^2} {\lambda^2}\]</span></p><p>在自由空间中，把<span class="math inline">\(\eta=120\pi\)</span>代入，有：</p><p><span class="math display">\[P_r=160\pi^4\frac{I^2a^2} {\lambda^2}\]</span></p><p>辐射电阻为：</p><p><span class="math display">\[R_r=\frac{4\pi^3a^2\eta} {3\lambda^2}\]</span></p><h2 id="其它天线简述">其它天线简述</h2><h3 id="半波天线">半波天线</h3><p>可以理解为电偶极子天线长度变成半个波长。线天线的端点总是电流的波节点，中心点为波腹点。</p><p>方向性函数为：</p><p><span class="math display">\[F(\theta,\varphi)=\frac{\cos(\frac \pi 2\cos \theta)} {\sin \theta}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220621114342987.png" alt="image-20220621114342987" /><figcaption aria-hidden="true">image-20220621114342987</figcaption></figure><p>它的指向性比交变电偶极子更窄。</p><p>天线长度越大，方向函数的零、极点越多，主向越向轴线靠拢。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于电磁场的能量的那些事</title>
    <link href="/2022/06/20/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E7%9A%84%E8%83%BD%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/20/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E7%9A%84%E8%83%BD%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>这章的核心是坡印廷定理。</p><span id="more"></span><hr /><h2 id="静电场和静磁场的能量">静电场和静磁场的能量</h2><p>在自由空间的分布电荷系统中，有两种方法计算系统蕴含的静电场能量： <span class="math display">\[W_E=\frac 12\iiint_V \varPhi(r)\rho(r) \mathbf{d}V\]</span> 和 <span class="math display">\[W_E=\iiint_V\frac 12\varepsilon_0\boldsymbol{E}(r)\cdot \boldsymbol{E}(r)\mathbf{d}V\]</span> 其中，定义电场能量密度 <span class="math display">\[w_E=\frac 12\varepsilon_0\boldsymbol{E}(r)\cdot \boldsymbol{E}(r)=\frac 12 \mu_0 |\boldsymbol{E}(r)|^2\ \ \text{(J/m$^3$)}\]</span> 对于点电荷系统来说，原则上不能利用电场能量密度<span class="math inline">\(w_E\)</span>来计算电场能，因为积分不收敛，会得到一个无穷大的结果，此时，只能使用 <span class="math display">\[W_E=\frac 12 \sum_{i=1}^nq_i\varPhi_i\]</span> 来计算。其中<span class="math inline">\(\varPhi_i\)</span>是在点电荷<span class="math inline">\(q_i\)</span>的位置上，除去<span class="math inline">\(q_i\)</span>以外的所有其它电荷产生的电势。有： <span class="math display">\[\varPhi_i=\sum_{k=1,k\neq i}^n \frac {q_k}{4\pi \varepsilon_0r_{ki}}\]</span> 对于自由空间中的电流系统，有磁场能计算公式： <span class="math display">\[W_H=\iiint_V \frac 12 \mu_0\boldsymbol{H}(r)\cdot\boldsymbol{H}(r)\mathbf{d}V\]</span> 于是可以定义磁能密度： <span class="math display">\[w_H=\frac 12 \mu_0\boldsymbol{H}(r)\cdot\boldsymbol{H}(r)=\frac 12 \mu_0 |\boldsymbol{H}(r)|^2\ \  \text{(J/m$^3$)}\]</span> 当然也有类似电场能的另一个公式： <span class="math display">\[W_H=\frac 12\sum_{i=1}^n \Psi_iI_i\]</span> 其中<span class="math inline">\(\Psi_i\)</span>表示系统中和线电流回路<span class="math inline">\(C_i\)</span>交链的磁通量。这个公式很少用到。</p><h2 id="坡印廷定理">坡印廷定理</h2><p>坡印廷定理的基本表达式为： <span class="math display">\[-\nabla \cdot \vec{S}(\vec{r}, t)=p(\vec{r}, t)+\frac{\partial w(\vec{r}, t)}{\partial t}\]</span> 其中<span class="math inline">\(S\)</span>是坡印廷矢量，定义为： <span class="math display">\[\vec{S}(\vec{r}, t)=\vec{E}(\vec{r}, t) \times \vec{H}(\vec{r}, t)\]</span> 其中各项的含义为：</p><ul><li><span class="math inline">\(-\nabla \cdot \vec{S}(\vec{r}, t)\)</span>，即坡印廷矢量的负散度。它表示外界向电磁场中某点所提供的功率流密度。</li><li><span class="math inline">\(p(\vec{r}, t)\)</span>，它表示电磁场对这点的电磁荷提供的电磁功率密度。</li><li><span class="math inline">\(\frac{\partial w(\vec{r}, t)}{\partial t}\)</span>，它表示电磁场在这点蕴含的能量密度的增加率。</li></ul><p>从整体上来说，也就是：外界向一点提供的电磁能必定用于对处在该点的电磁荷做功，和增加电磁场在该点的电磁能。</p><p>在物质中的坡印廷定理有以下形式： <span class="math display">\[-\nabla \cdot \vec{S}(\vec{r}, t)+p_{s}(\vec{r}, t)=p_{d}(\vec{r}, t)+p_{P}(\vec{r}, t)+p_{M}(\vec{r}, t)+\frac{\partial }{\partial t}[w_E(\vec{r}, t)+w_E(\vec{r}, t)]\]</span> 其中：</p><ul><li><p><span class="math inline">\(p_S\)</span>表示电源向电磁场提供的功率。有： <span class="math display">\[p_s(\vec{r},t)=-J_s(\vec{r},t)\cdot E(\vec{r},t)\]</span> 需要注意这里的符号。符号的意思是如果<span class="math inline">\(J_s(\vec{r},t)\cdot E(\vec{r},t)&gt;0\)</span>，这时候实际上是电磁场给电源充电。</p></li><li><p><span class="math inline">\(p_d\)</span>表示由于物质的电阻性而转化为焦耳热的功率。有： <span class="math display">\[p_d(\vec{r},t)=\sigma|\boldsymbol{E}(\vec{r},t)|^2\]</span></p></li><li><p><span class="math inline">\(p_P\)</span>表示用来增加物质极化程度的功率。有： <span class="math display">\[p_P(\vec{r},t)=\boldsymbol{E}(\vec{r},t)\cdot \frac{\partial \boldsymbol{P}(\vec{r},t)}{\partial t}\]</span> 其中<span class="math inline">\(P(\vec{r},t)\)</span>是极化强度，对于简单媒质来说，有： <span class="math display">\[\boldsymbol{P}(\vec{r},t)=\chi_e\varepsilon_0\boldsymbol{E}(\vec{r},t)\]</span> 其中<span class="math inline">\(\chi_e\)</span>是电极化率。</p></li><li><p><span class="math inline">\(p_M\)</span>表示用来增加物质磁化程度的功率。有： <span class="math display">\[p_M(\vec{r},t)=\boldsymbol{H}(\vec{r},t)\cdot \mu_0\frac{\partial \boldsymbol{M}(\vec{r},t)}{\partial t}\]</span></p></li><li><p>上面四条加起来称为“物质消耗的功率”,也就是坡印廷定理一般表达式的<span class="math inline">\(p(\vec{r},t)\)</span>，特殊地，对于电阻性导体，只存在<span class="math inline">\(p_d\)</span>。</p></li><li><p><span class="math inline">\(w_E,w_H\)</span>表示电磁场的储能。</p></li></ul><p>在做题时，还会遇到一个模型，叫“同轴电缆”，一开始我完全不知道它是啥玩意。其实，“同轴电缆”是一个由两部分导体组成的系统，“内导体”是一个半径为<span class="math inline">\(a\)</span>的圆柱体，“外导体”是一片半径为<span class="math inline">\(b\)</span>的圆柱面，这俩是同心的。制造同轴电缆的导体可能是理想的，也可能不是理想的。在一端的内外导体之间，往往接有圆对称的电压源。</p><h2 id="物质中的极化能和磁化能">物质中的极化能和磁化能</h2><h3 id="电容器的能量极化能">电容器的能量：极化能</h3><p>对于公式： <span class="math display">\[p_P(\vec{r},t)=\boldsymbol{E}(\vec{r},t)\cdot \frac{\partial \boldsymbol{P}(\vec{r},t)}{\partial t}\]</span> 将 <span class="math display">\[\boldsymbol{P}(\vec{r},t)=\chi_e\varepsilon_0\boldsymbol{E}(\vec{r},t)\]</span> 代入，可推导得： <span class="math display">\[p_P(\vec{r},t)=\frac{\partial}{\partial t}\left[\frac 12 \boldsymbol{P}(\vec{r},t)\cdot \boldsymbol{E}(\vec{r},t)\right]\]</span> 于是有极化能密度： <span class="math display">\[w_P(\vec{r},t)=\frac 12\boldsymbol{P}(\vec{r},t)\cdot \boldsymbol{E}(\vec{r},t)\]</span> "极化能"的意思，就是电容器两个导体板子中间夹的那一坨电介质因为要极化所以得到的能量。为了完整讨论电介质的能量，我们还要加上电场的能量，即： <span class="math display">\[w_E(\vec{r},t)=\frac 12 \varepsilon_0|E(\vec{r},t)|^2\]</span> 有电能密度： <span class="math display">\[\begin{aligned}w_e&amp;=w_p+w_E\\&amp;=\frac 12E(\vec{r},t)\cdot D(\vec{r},t)\end{aligned}\]</span> 其中<span class="math inline">\(D(\vec{r},t)\)</span>叫电位移矢量，定义如下： <span class="math display">\[D=\varepsilon_0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=(1+\chi_e)\varepsilon_0E=\varepsilon_r\varepsilon_0E\]</span> 于是： <span class="math display">\[w_e=\frac 12 \varepsilon E^2\]</span></p><p>再结合电分里面的电容公式： <span class="math display">\[W_c=\frac 12 CV^2\]</span> 就能求出电容量。</p><h3 id="电感器的能量磁化能">电感器的能量：磁化能</h3><p><span class="math display">\[p_M(\vec{r},t)=\boldsymbol{H}(\vec{r},t)\cdot \mu_0\frac{\partial \boldsymbol{M}(\vec{r},t)}{\partial t}\]</span></p><p>其中<span class="math inline">\(M\)</span>叫磁化强度，有： <span class="math display">\[\mu_0M=(\mu-\mu_0)H\]</span> 在单值简单介质中，有磁化能密度： <span class="math display">\[w_M=\frac 12 \mu_0H(\vec{r},t)\cdot M(\vec{r},t)\]</span> 再加上磁场本身的能量，就有磁能密度： <span class="math display">\[w_H=\frac 12 B\cdot H=\frac 12 \mu H^2\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统课程设计：频分复用系统设计</title>
    <link href="/2022/06/16/%E4%BF%A1%E5%8F%B7%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <url>/2022/06/16/%E4%BF%A1%E5%8F%B7%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是大作业，频分复用系统设计</p><span id="more"></span><h2 id="实验目的">实验目的</h2><p>本次实验尝试设计一种频分复用系统，接收三个带限信号，通过选取不同的调制频率<span class="math inline">\(\omega_c\)</span>，将所需传输的信号的频谱搬移到不同频段，在同一物理信道中传输多路信号。频分复用的原理框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/41CA9D78D2872ED5A23ED8B6346EC6EC.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="实验过程">实验过程</h2><h3 id="读取信号">读取信号</h3><p>输入信号以列表的方式给出，表的形式如下：</p><table><thead><tr class="header"><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(f_1(t)\)</span></th><th><span class="math inline">\(f_2(t)\)</span></th><th><span class="math inline">\(f_3(t)\)</span></th></tr></thead><tbody><tr class="odd"><td>-10</td><td>-0.0498</td><td>0.0032</td><td>0.0031</td></tr><tr class="even"><td>-9.9</td><td>-0.0424</td><td>0.0023</td><td>0.0032</td></tr><tr class="odd"><td>-9.8</td><td>-0.0344</td><td>0.0015</td><td>0.0031</td></tr><tr class="even"><td>-9.7</td><td>-0.0258</td><td>0.0008</td><td>0.003</td></tr><tr class="odd"><td>-9.6</td><td>-0.0167</td><td>0.0004</td><td>0.0028</td></tr><tr class="even"><td>-9.5</td><td>-0.0073</td><td>0.0001</td><td>0.0025</td></tr><tr class="odd"><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr class="even"><td>9.8</td><td>-0.0344</td><td>0.0015</td><td>0.0031</td></tr><tr class="odd"><td>9.9</td><td>-0.0424</td><td>0.0023</td><td>0.0032</td></tr></tbody></table><p>读取数据相关的程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> T[MAXN], f1[MAXN], f2[MAXN], f3[MAXN];<br>tf tf_f1[MAXN], tf_f2[MAXN], tf_f3[MAXN];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;T[cnt], &amp;f1[cnt], &amp;f2[cnt], &amp;f3[cnt]) != EOF) &#123;<br>tf_f1[cnt] = (tf) &#123;T[cnt], f1[cnt]&#125;;<br>tf_f2[cnt] = (tf) &#123;T[cnt], f2[cnt]&#125;;<br>tf_f3[cnt] = (tf) &#123;T[cnt], f3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> length = cnt;<br></code></pre></td></tr></table></figure><p>其中<code>tf</code>结构体是为运算方便定义的结构，其中有两个<code>double</code>型量，即<code>t</code>和<code>f</code>，用来存储时间-信号表。</p><p>原始信号的波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616164757519.png" alt="image-20220616164757519" /><figcaption aria-hidden="true">image-20220616164757519</figcaption></figure><h3 id="获取原始信号的频域图像分析频域特征">获取原始信号的频域图像，分析频域特征</h3><p>对三个原始信号作傅里叶变换，并绘制频域图像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> W[MAXN], F1[MAXN], F2[MAXN], F3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-3.0</span>; w &lt;= <span class="hljs-number">3.0</span>; w += <span class="hljs-number">0.01</span>) &#123;<br>    W[cnt] = w;<br>    F1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f1, length);<br>    F2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f2, length);<br>    F3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f3, length);<br>    ++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">inputWSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;inputW.ppm&quot;</span>)</span></span>;<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F1, cnt, line_blue);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F2, cnt, line_green);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F3, cnt, line_red);<br>inputWSignal.<span class="hljs-built_in">draw</span>();<br></code></pre></td></tr></table></figure><p>其中<code>fourierTransform</code>函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, tf f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].t - f[<span class="hljs-number">0</span>].t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].f * <span class="hljs-built_in">cos</span>(w * f[i].t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>绘制出的频域波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616164823488.png" alt="image-20220616164823488" /><figcaption aria-hidden="true">image-20220616164823488</figcaption></figure><p>可以看出，输入的三个信号都是带限信号。有： <span class="math display">\[\omega_{m1}=1\\\omega_{m2}=2\\\omega_{m3}=\frac \pi 2\]</span> 因此，我们可以使用频分复用的方法把这三个信号合在一个信道中传输。</p><h3 id="频域搬移和信道组合">频域搬移和信道组合</h3><p>由公式： <span class="math display">\[g(t)=\sum_{i=1}^3 f_i(t)\cos(\omega_it)\]</span> 我们可以将这三个信号的频域进行搬移，并组合在一个信道中进行传输。其中<span class="math inline">\(\cos(\omega_it)\)</span>就起到了幅度调制，频域搬移的作用。这是因为： <span class="math display">\[\begin{aligned}\mathscr{F}[f(t)\cos(\omega_0 t)]&amp;=\frac{1}{2\pi}\mathscr{F}[f(t)]\bigotimes\mathscr{F}[\cos(\omega_0 t)]\\&amp;=\frac{1}{2\pi}F(\omega)\bigotimes\pi[\delta(\omega+\omega_0)+\delta(\omega-\omega_0)]\\&amp;=\frac 12[F(\omega+\omega_0)-F(\omega-\omega_0)]\end{aligned}\]</span> 在选择载波频率时，考虑到原始采样频率为<span class="math inline">\(f=10\text{Hz}\)</span>，所以载波频率分别选择 <span class="math display">\[\omega_1=5,\omega_2=12.5,\omega_3=20\]</span> 这部分的代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> omega1 = <span class="hljs-number">5.0</span>, omega2 = <span class="hljs-number">12.5</span>, omega3 = <span class="hljs-number">20.0</span>;<br><span class="hljs-type">double</span> g[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br>tf tf_g[MAXN];<br><span class="hljs-type">int</span> g_length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>g[cnt] = (f1[cnt] * <span class="hljs-built_in">cos</span>(omega1 * t) + f2[cnt] * <span class="hljs-built_in">cos</span>(omega2 * t) + f3[cnt] * <span class="hljs-built_in">cos</span>(omega3 * t));<br>tf_g[cnt] = (tf) &#123;t, g[cnt]&#125;;<br>++cnt;<br>&#125;<br>g_length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">GT</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GT.ppm&quot;</span>)</span></span>;<br>GT.<span class="hljs-built_in">drawXY</span>(T, g, cnt, line_blue);<br><span class="hljs-type">double</span> G[MAXN], w2[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>w2[cnt] = w;<br>G[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_g, g_length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">GW</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GW.ppm&quot;</span>)</span></span>;<br>GW.<span class="hljs-built_in">drawXY</span>(w2, G, cnt, line_blue);<br></code></pre></td></tr></table></figure><p>同时分别画出了<span class="math inline">\(g(t)\)</span>的时域、频域图像，如下：</p><p>时域图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616172004693.png" alt="image-20220616172004693" /><figcaption aria-hidden="true">image-20220616172004693</figcaption></figure><p>频域图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616171953072.png" alt="image-20220616171953072" /><figcaption aria-hidden="true">image-20220616171953072</figcaption></figure><p>可见：已经实现了频域搬移。</p><h3 id="使用带通滤波器接受信号">使用带通滤波器接受信号</h3><p>在解调过程中，使用带通滤波器接受信号。对于三个信号，分别采用中心频率为<span class="math inline">\(\omega_i\)</span>，通过频带宽度为<span class="math inline">\(\omega_{mi}\)</span>的带通滤波器。信号<span class="math inline">\(g(t)\)</span>经过带通滤波器以后，被分为了三路信号。对这三路信号，每一路再乘以<span class="math inline">\(\cos(\omega_i t)\)</span>，就把频带移动到了中间。如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616172628586.png" alt="image-20220616172628586" /><figcaption aria-hidden="true">image-20220616172628586</figcaption></figure><p>我们再对这三个信号过一个低通滤波器，就能恢复出原来的信号了。</p><p>这部分的代码如下：</p><ol type="1"><li><p>通过带通滤波器分开三路信号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> G1[MAXN], G2[MAXN], G3[MAXN];<br>wF wF_g1[MAXN], wF_g2[MAXN], wF_g3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(G1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G1));<br><span class="hljs-built_in">memset</span>(G2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G2));<br><span class="hljs-built_in">memset</span>(G3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G3));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>G1[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, w);<br>G2[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">12.5</span>, <span class="hljs-number">5.0</span>, w);<br>G3[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">20.0</span>, PI, w);<br>wF_g1[cnt] = (wF) &#123;w, G1[cnt]&#125;;<br>wF_g2[cnt] = (wF) &#123;w, G2[cnt]&#125;;<br>wF_g3[cnt] = (wF) &#123;w, G3[cnt]&#125;;<br>++cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分别再乘以<span class="math inline">\(\cos(\omega_i t)\)</span>再次搬移频域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> G1length = cnt;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> fG1[MAXN], fG2[MAXN], fG3[MAXN];<br>tf tf_fG1[MAXN], tf_fG2[MAXN], tf_fG3[MAXN];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>fG1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g1, G1length);<br>fG2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g2, G1length);<br>fG3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g3, G1length);<br>fG1[cnt] *= <span class="hljs-built_in">cos</span>(omega1 * t);<br>fG2[cnt] *= <span class="hljs-built_in">cos</span>(omega2 * t);<br>fG3[cnt] *= <span class="hljs-built_in">cos</span>(omega3 * t);<br>tf_fG1[cnt] = (tf) &#123;t, fG1[cnt]&#125;;<br>tf_fG2[cnt] = (tf) &#123;t, fG2[cnt]&#125;;<br>tf_fG3[cnt] = (tf) &#123;t, fG3[cnt]&#125;;<br>++cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过低通滤波器，恢复原始信号，并绘制出输出信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> GfG1[MAXN], GfG2[MAXN], GfG3[MAXN];<br>wF wf_gfg1[MAXN], wf_gfg2[MAXN], wf_gfg3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>GfG1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG1, g_length);<br>GfG2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG2, g_length);<br>GfG3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG3, g_length);<br>GfG1[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG2[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG3[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>wf_gfg1[cnt] = (wF) &#123;w, GfG1[cnt]&#125;;<br>wf_gfg2[cnt] = (wF) &#123;w, GfG2[cnt]&#125;;<br>wf_gfg3[cnt] = (wF) &#123;w, GfG3[cnt]&#125;;<br>++cnt;<br>&#125;<br>length = cnt;<br><span class="hljs-type">double</span> finalf1[MAXN], finalf2[MAXN], finalf3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10</span>; t &lt;= <span class="hljs-number">10</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>finalf1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg1, length);<br>finalf2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg2, length);<br>finalf3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg3, length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">outputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;output.ppm&quot;</span>)</span></span>;<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf1, cnt, line_blue);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf2, cnt, line_green);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf3, cnt, line_red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><p>输出信号的波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616173101518.png" alt="image-20220616173101518" /><figcaption aria-hidden="true">image-20220616173101518</figcaption></figure><p>可以看出，本次实验较好地完成了频分复用信号传输的任务。</p><p>计算三个信号的均方误差，有：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">MSE1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000048221</span><br><span class="hljs-attribute">MSE2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000652</span><br><span class="hljs-attribute">MSE3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000173</span><br></code></pre></td></tr></table></figure><p>可以看出，这个系统的效果还是比较理想。</p><h2 id="实验心得体会">实验心得体会</h2><p>本次实验我综合运用了《信号与系统》课程的相关知识，如奈奎斯特采样定理、傅里叶变换的相关内容，完成了综合信号传输系统的设计，对我的学习非常的有帮助。</p><h2 id="附录">附录</h2><p>本次实验完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM2.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 3000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDTH 1920</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIGHT 1080</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forvec(TYPE,NAME,IT) for(vector<span class="hljs-string">&lt;TYPE&gt;</span>::iterator IT=NAME.begin();IT!=NAME.end();++IT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forset(TYPE,NAME,IT) for(set<span class="hljs-string">&lt;TYPE&gt;</span>::iterator IT=NAME.begin();IT!=NAME.end();++IT)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*fun_p)</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">double</span> t, f;<br>&#125; tf;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">wF</span> &#123;<br><span class="hljs-type">double</span> w, F;<br>&#125; wF;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierInvTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> t, wF f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].w - f[<span class="hljs-number">0</span>].w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].F * <span class="hljs-built_in">cos</span>(t * f[i].w) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans / (<span class="hljs-number">2.0</span> * PI);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, tf f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].t - f[<span class="hljs-number">0</span>].t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].f * <span class="hljs-built_in">cos</span>(w * f[i].t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bandPassFilter</span><span class="hljs-params">(<span class="hljs-type">double</span> center, <span class="hljs-type">double</span> band, <span class="hljs-type">double</span> w)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(w - center) &lt; (band / <span class="hljs-number">2.0</span>) || <span class="hljs-built_in">fabs</span>(w + center) &lt; (band / <span class="hljs-number">2.0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><span class="hljs-comment">//return (fabs(w - center) &lt; (band / 2.0)) ? 1.0 : 0.0;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;inputSignal.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>PPMdata background, axis, grid, line_blue, line_green, line_red;<br>background = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line_blue = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br>line_green = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">66</span>, <span class="hljs-number">96</span>, <span class="hljs-number">45</span>);<br>line_red = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">193</span>, <span class="hljs-number">50</span>, <span class="hljs-number">142</span>);<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> T[MAXN], f1[MAXN], f2[MAXN], f3[MAXN];<br>tf tf_f1[MAXN], tf_f2[MAXN], tf_f3[MAXN];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;T[cnt], &amp;f1[cnt], &amp;f2[cnt], &amp;f3[cnt]) != EOF) &#123;<br>tf_f1[cnt] = (tf) &#123;T[cnt], f1[cnt]&#125;;<br>tf_f2[cnt] = (tf) &#123;T[cnt], f2[cnt]&#125;;<br>tf_f3[cnt] = (tf) &#123;T[cnt], f3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">inputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;input.ppm&quot;</span>)</span></span>;<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f1, cnt, line_blue);<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f2, cnt, line_green);<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f3, cnt, line_red);<br>inputSignal.<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-type">double</span> W[MAXN], F1[MAXN], F2[MAXN], F3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-3.0</span>; w &lt;= <span class="hljs-number">3.0</span>; w += <span class="hljs-number">0.01</span>) &#123;<br>W[cnt] = w;<br>F1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f1, length);<br>F2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f2, length);<br>F3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f3, length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">inputWSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;inputW.ppm&quot;</span>)</span></span>;<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F1, cnt, line_blue);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F2, cnt, line_green);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F3, cnt, line_red);<br>inputWSignal.<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-type">double</span> omega1 = <span class="hljs-number">5.0</span>, omega2 = <span class="hljs-number">12.5</span>, omega3 = <span class="hljs-number">20.0</span>;<br><span class="hljs-type">double</span> g[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br>tf tf_g[MAXN];<br><span class="hljs-type">int</span> g_length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>g[cnt] = (f1[cnt] * <span class="hljs-built_in">cos</span>(omega1 * t) + f2[cnt] * <span class="hljs-built_in">cos</span>(omega2 * t) + f3[cnt] * <span class="hljs-built_in">cos</span>(omega3 * t));<br>tf_g[cnt] = (tf) &#123;t, g[cnt]&#125;;<br>++cnt;<br>&#125;<br>g_length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">GT</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GT.ppm&quot;</span>)</span></span>;<br>GT.<span class="hljs-built_in">drawXY</span>(T, g, cnt, line_blue);<br><span class="hljs-type">double</span> G[MAXN], w2[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>w2[cnt] = w;<br>G[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_g, g_length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">GW</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GW.ppm&quot;</span>)</span></span>;<br>GW.<span class="hljs-built_in">drawXY</span>(w2, G, cnt, line_blue);<br><br><span class="hljs-type">double</span> G1[MAXN], G2[MAXN], G3[MAXN];<br>wF wF_g1[MAXN], wF_g2[MAXN], wF_g3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(G1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G1));<br><span class="hljs-built_in">memset</span>(G2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G2));<br><span class="hljs-built_in">memset</span>(G3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G3));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>G1[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, w);<br>G2[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">12.5</span>, <span class="hljs-number">5.0</span>, w);<br>G3[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">20.0</span>, PI, w);<br>wF_g1[cnt] = (wF) &#123;w, G1[cnt]&#125;;<br>wF_g2[cnt] = (wF) &#123;w, G2[cnt]&#125;;<br>wF_g3[cnt] = (wF) &#123;w, G3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> G1length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">Gerr</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;Gerr.ppm&quot;</span>)</span></span>;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> fG1[MAXN], fG2[MAXN], fG3[MAXN];<br>tf tf_fG1[MAXN], tf_fG2[MAXN], tf_fG3[MAXN];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>fG1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g1, G1length);<br>fG2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g2, G1length);<br>fG3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g3, G1length);<br>fG1[cnt] *= <span class="hljs-built_in">cos</span>(omega1 * t);<br>fG2[cnt] *= <span class="hljs-built_in">cos</span>(omega2 * t);<br>fG3[cnt] *= <span class="hljs-built_in">cos</span>(omega3 * t);<br>tf_fG1[cnt] = (tf) &#123;t, fG1[cnt]&#125;;<br>tf_fG2[cnt] = (tf) &#123;t, fG2[cnt]&#125;;<br>tf_fG3[cnt] = (tf) &#123;t, fG3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">double</span> GfG1[MAXN], GfG2[MAXN], GfG3[MAXN];<br>wF wf_gfg1[MAXN], wf_gfg2[MAXN], wf_gfg3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>GfG1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG1, g_length);<br>GfG2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG2, g_length);<br>GfG3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG3, g_length);<br>GfG1[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG2[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG3[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>wf_gfg1[cnt] = (wF) &#123;w, GfG1[cnt]&#125;;<br>wf_gfg2[cnt] = (wF) &#123;w, GfG2[cnt]&#125;;<br>wf_gfg3[cnt] = (wF) &#123;w, GfG3[cnt]&#125;;<br>++cnt;<br>&#125;<br>length = cnt;<br><span class="hljs-type">double</span> finalf1[MAXN], finalf2[MAXN], finalf3[MAXN];<br><span class="hljs-type">double</span> MSE[<span class="hljs-number">4</span>];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10</span>; t &lt;= <span class="hljs-number">10</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>finalf1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg1, length);<br>finalf2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg2, length);<br>finalf3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg3, length);<br>MSE[<span class="hljs-number">1</span>]+=(finalf1[cnt]-f1[cnt])*(finalf1[cnt]-f1[cnt]);<br>MSE[<span class="hljs-number">2</span>]+=(finalf2[cnt]-f2[cnt])*(finalf2[cnt]-f2[cnt]);<br>MSE[<span class="hljs-number">3</span>]+=(finalf3[cnt]-f3[cnt])*(finalf3[cnt]-f3[cnt]);<br>++cnt;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i) MSE[i]/=(cnt*<span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MSE%d = %.9lf\n&quot;</span>,i,MSE[i]);<br><span class="hljs-function">Graph <span class="hljs-title">outputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;output.ppm&quot;</span>)</span></span>;<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf1, cnt, line_blue);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf2, cnt, line_green);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf3, cnt, line_red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>"arrayToPPM2.hpp"</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 999999999</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstdio&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstdlib&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cmath&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFuncY(x1,y1,x2,y2,y) ((y-y1)*(x2-x1)/(y2-y1)+x1)</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*fun_P)</span> <span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;<br><span class="hljs-function">T <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;<br>a = b;<br>b = c;<br>&#125;<br><br><span class="hljs-function">PPMdata <span class="hljs-title">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>PPMdata ans;<br>ans.r = r, ans.g = g, ans.b = b;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">private</span>:<br>PPMdata **matrix;<br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> height;<br><span class="hljs-type">double</span> centerX;<br><span class="hljs-type">double</span> centerY;<br><span class="hljs-type">double</span> rangeX;<br><span class="hljs-type">double</span> rangeY;<br><span class="hljs-type">double</span> gridX;<br><span class="hljs-type">double</span> gridY;<br>PPMdata line, grid, bgc, axis;<br><span class="hljs-type">char</span> *fileName;<br><br><span class="hljs-type">double</span> stepX, stepY;<br><span class="hljs-type">bool</span> drawed;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> idth,<br>      <span class="hljs-type">int</span> eight,<br>      <span class="hljs-type">double</span> enterX,<br>      <span class="hljs-type">double</span> enterY,<br>      <span class="hljs-type">double</span> angeX,<br>      <span class="hljs-type">double</span> angeY,<br>      <span class="hljs-type">double</span> ridX,<br>      <span class="hljs-type">double</span> ridY,<br>      PPMdata ine,<br>      PPMdata rid,<br>      PPMdata ack,<br>      PPMdata xis,<br>      <span class="hljs-type">char</span> *fName);<br>~<span class="hljs-built_in">Graph</span>();<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> y2,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> size,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawPos</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">drawXY</span><span class="hljs-params">(<span class="hljs-type">double</span> *x, <span class="hljs-type">double</span> *y, <span class="hljs-type">int</span> arrayLen,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num2MatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">bool</span> flag)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>Graph::<span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> idth,<br>             <span class="hljs-type">int</span> eight,<br>             <span class="hljs-type">double</span> enterX,<br>             <span class="hljs-type">double</span> enterY,<br>             <span class="hljs-type">double</span> angeX,<br>             <span class="hljs-type">double</span> angeY,<br>             <span class="hljs-type">double</span> ridX,<br>             <span class="hljs-type">double</span> ridY,<br>             PPMdata ine,<br>             PPMdata rid,<br>             PPMdata ack,<br>             PPMdata xis,<br>             <span class="hljs-type">char</span> *fName) &#123;<br>width = idth;<br>height = eight;<br>centerX = enterX;<br>centerY = enterY;<br>rangeX = angeX;<br>rangeY = angeY;<br>gridX = ridX;<br>gridY = ridY;<br>line = ine;<br>grid = rid;<br>bgc = ack;<br>axis = xis;<br>fileName = fName;<br>drawed = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br>matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PPMdata *) * height);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(width, <span class="hljs-built_in">sizeof</span>(PPMdata));<br>&#125;<br><br>stepX = rangeX / (width * <span class="hljs-number">1.0</span>);<br>stepY = rangeY / (height * <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>matrix[i][j] = bgc;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br><span class="hljs-built_in">drawPos</span>(<span class="hljs-built_in">num2MatPos</span>(centerX + i * gridX, <span class="hljs-number">1</span>), j, grid);<br><span class="hljs-built_in">drawPos</span>(<span class="hljs-built_in">num2MatPos</span>(centerX - i * gridX, <span class="hljs-number">1</span>), j, grid);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">drawPos</span>(j, <span class="hljs-built_in">num2MatPos</span>(centerY + i * gridY, <span class="hljs-number">0</span>), grid);<br><span class="hljs-built_in">drawPos</span>(j, <span class="hljs-built_in">num2MatPos</span>(centerY - i * gridY, <span class="hljs-number">0</span>), grid);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br><span class="hljs-built_in">drawPos</span>(i, height / <span class="hljs-number">2</span>, axis);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-built_in">drawPos</span>(width / <span class="hljs-number">2</span>, i, axis);<br>&#125;<br><br>&#125;<br><br>Graph::~<span class="hljs-built_in">Graph</span>() &#123;<br><span class="hljs-keyword">if</span> (drawed == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Object has been deleted!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::draw</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (drawed) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This Graph has been drawed in %s.\n&quot;</span>, fileName);<br>&#125;<br><span class="hljs-built_in">freopen</span>(fileName, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = height - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; --i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">fclose</span>(stdout);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>drawed = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Graph::num2MatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">bool</span> flag)</span> </span>&#123;<br><span class="hljs-comment">//flag=1 x else y</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(width / <span class="hljs-number">2</span> + (num - centerX) / rangeX * width);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">return</span> (<span class="hljs-type">int</span>)(height / <span class="hljs-number">2</span> + (num - centerY) / rangeY * height);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::drawPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> size,PPMdata color)</span> </span>&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">num2MatPos</span>(x, <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> v = <span class="hljs-built_in">num2MatPos</span>(y, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br><span class="hljs-type">int</span> U = u + i, V = v + j;<br><span class="hljs-keyword">if</span> (U &gt;= width || U &lt; <span class="hljs-number">0</span> || V &gt;= height || V &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> matrix[V][U] = color;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::drawPos</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, PPMdata color)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> matrix[v][u] = color;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph::drawLine</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2,PPMdata color)</span> </span>&#123;<br><span class="hljs-type">int</span> u1, u2, v1, v2;<br>u1 = <span class="hljs-built_in">num2MatPos</span>(x1, <span class="hljs-number">1</span>);<br>u2 = <span class="hljs-built_in">num2MatPos</span>(x2, <span class="hljs-number">1</span>);<br>v1 = <span class="hljs-built_in">num2MatPos</span>(y1, <span class="hljs-number">0</span>);<br>v2 = <span class="hljs-built_in">num2MatPos</span>(y2, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (u1 &gt;= width || u1 &lt; <span class="hljs-number">0</span> || u2 &gt;= width || u2 &lt; <span class="hljs-number">0</span> || v1 &gt;= height || v1 &lt; <span class="hljs-number">0</span> || v2 &gt;= height || v2 &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawLineError:out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">double</span> k = INF;<br><span class="hljs-keyword">if</span> (u2 != u1)<br>k = (v2 * <span class="hljs-number">1.0</span> - v1 * <span class="hljs-number">1.0</span>) / (u2 * <span class="hljs-number">1.0</span> - u1 * <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(k) &gt;= <span class="hljs-number">2.0</span>) &#123;<br><span class="hljs-keyword">if</span> (y1 &gt; y2) &#123;<br><span class="hljs-built_in">swap</span>(x1, x2);<br><span class="hljs-built_in">swap</span>(y1, y2);<br>&#125;<br>k=(x2-x1)/(y2-y1);<br><span class="hljs-type">double</span> x11=x1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> y = y1; y &lt;= y2; y += stepY) &#123;<br><span class="hljs-built_in">drawPoint</span>(x11, y, <span class="hljs-number">1</span>,color);<br>x11+=stepY*k;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(x1&gt;x2)&#123;<br><span class="hljs-built_in">swap</span>(x1,x2);<br><span class="hljs-built_in">swap</span>(y1,y2);<br>&#125;<br>k=(y2-y1)/(x2-x1);<br><span class="hljs-type">double</span> y11=y1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> x = x1; x &lt;= x2; x += stepX) &#123;<br><span class="hljs-built_in">drawPoint</span>(x, y11, <span class="hljs-number">1</span>,color);<br>y11+=stepX*k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph::drawXY</span><span class="hljs-params">(<span class="hljs-type">double</span> *x, <span class="hljs-type">double</span> *y_save, <span class="hljs-type">int</span> arrayLen,PPMdata color)</span> </span>&#123;<br><br><span class="hljs-type">double</span> *y = (<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) * (arrayLen + <span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i)<br>y[i] = y_save[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawXYError:X is not increasing.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawXYError:X out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br><span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (i &gt;= arrayLen) <span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">drawLine</span>(x[i - <span class="hljs-number">1</span>], y[i - <span class="hljs-number">1</span>], x[i], y[i],color);<br>&#125;<br><span class="hljs-built_in">free</span>(y);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于平面电磁波的那些事</title>
    <link href="/2022/06/15/%E5%85%B3%E4%BA%8E%E5%B9%B3%E9%9D%A2%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/15/%E5%85%B3%E4%BA%8E%E5%B9%B3%E9%9D%A2%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>主要是课本和PPT的总结，加了一点点我学习时的疑问和感悟。电磁场是真™的难，能学懂的都是神人，反正我是学不懂，哈人。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="平面电磁波相关概念">平面电磁波相关概念</h2><ul><li>等相面：同一时刻，空间振动相位相同的点连成的面</li><li>等幅面：同一时刻，空间振动幅度相同的点连成的面</li><li>平面波：等相面是平面的波</li><li>均匀平面波：也叫UPW，指等相面和等幅面重合的平面波。即：在均匀平面波的等相面上，波有相同的振幅</li><li>球面波：等相面是球面的波</li><li>柱面波：等相面是柱面的波</li><li>TEM波：电场强度和磁场强度矢量在传播方向上的分量为0的电磁波。均匀平面波一定是TEM波，反之不然。例：均匀球面波也是TEM波。</li></ul><h2 id="自由空间平面电磁波的时域解">自由空间平面电磁波的时域解</h2><p>由麦克斯韦方程组的推导，设源量为0，各量不随<span class="math inline">\(x,y\)</span>变化而变化（即等相位面是<span class="math inline">\(xoy\)</span>平面）。</p><p>由于 <span class="math display">\[\begin{aligned}\nabla\cdot \varepsilon_0E=0\\\\\nabla\cdot \mu_0H=0\end{aligned}\]</span> 因此<span class="math inline">\(E,H\)</span>的<span class="math inline">\(z\)</span>分量和<span class="math inline">\(z\)</span>无关。</p><p>由于 <span class="math display">\[\nabla \times H=\varepsilon \frac{\partial E} {\partial t}\]</span> 考虑<span class="math inline">\(i_z\)</span>分量，有： <span class="math display">\[\frac{\partial H_y} {\partial x}-\frac{\partial H_z} {\partial y}=\varepsilon _0\frac{\partial E_z} {\partial t}=0\]</span> 则<span class="math inline">\(E\)</span>的<span class="math inline">\(z\)</span>分量和时间无关(同理，<span class="math inline">\(H\)</span>也是)。因此<span class="math inline">\(E_z,H_z\)</span>是和时间，空间都没有关系的常数。在讨论时变场时不考虑常量，因此。 <span class="math display">\[\begin{aligned}E(z,t)=i_xE_x(z,t)+i_yE_y(z,t)\\\\H(z,t)=i_xH_x(z,t)+i_yH_y(z,t)\\\\\end{aligned}\]</span> 代入麦克斯韦方程 <span class="math display">\[\begin{aligned}\nabla \times E=-\mu_0\frac{\partial H} {\partial t}\\\\\nabla \times H=\varepsilon \frac{\partial E} {\partial t}\\\\\end{aligned}\]</span> 有 <span class="math display">\[\begin{cases}\frac{\partial E_y} {\partial z}=\mu_0\frac{\partial H_x} {\partial t}\\\\[2ex]\frac{\partial H_x} {\partial z}=\varepsilon_0\frac{\partial E_y} {\partial t}\\\\\end{cases}\]</span> 和 <span class="math display">\[\begin{cases}\frac{\partial E_x} {\partial z}=-\mu_0\frac{\partial H_y} {\partial t}\\\\[2ex]\frac{\partial H_y} {\partial z}=-\varepsilon_0\frac{\partial E_x} {\partial t}\\\\\end{cases}\]</span></p><p>一维波动方程（以第二组为例）： <span class="math display">\[\begin{aligned}\frac{\partial E_x} {\partial z^2}=\mu_0\varepsilon_0\frac{\partial^2 E_x} {\partial t^2}\\\\\frac{\partial^2 H_y} {\partial z^2}=\mu_0\varepsilon_0\frac{\partial^2H_y} {\partial t^2}\end{aligned}\]</span> 写成统一的形式： <span class="math display">\[\frac{\partial^2 u} {\partial z^2}=\frac{1} {v^2}\frac{\partial ^u} {\partial t^2}\]</span> 它的解实际上是宗量为<span class="math inline">\((z\pm vt)\)</span>的任意二阶可微分函数，即： <span class="math display">\[u=f(z\pm vt)\]</span> 那么结合麦克斯韦方程组，在电磁场中，它的解为： <span class="math display">\[\begin{aligned}E_x=f_1(z-vt)+f_2(z+vt)=E_x^+ + E_x^-\\\\H_y=\sqrt{\frac{\varepsilon_0} {\mu_0} }[f_1(z-vt)-f_2(z+vt)]=H_y^+ + H_y^-\end{aligned}\]</span> 同理，对1，有： <span class="math display">\[\begin{aligned}E_y=E_y^+ + E_y^-\\\\H_x=H_x^+ + H_x^-\end{aligned}\]</span> 那么所有沿着<span class="math inline">\(z\)</span>传播的平面波都可以写成上面四个解的线性组合。对于<span class="math inline">\(E\)</span>，有： <span class="math display">\[E=i_x(A_1E_x^+ + B_1E_x^-)+i_y(A_2E_y^+ + B_2E_y^-)\]</span> 于是，均匀平面波有这些传播特性：</p><ol type="1"><li><p>电场方向和磁场方向总和波的传播方向，也就是波印庭矢量的方向垂直，即： <span class="math display">\[S=E\times H\]</span></p></li><li><p>自由空间中，相速度等于光速，有： <span class="math display">\[v=c=(\mu_0\varepsilon_0)^{-1/2}\]</span></p></li><li><p>空间中任意一点，电场和磁场的波形和相位都相同，而且他们的数值之比是常数，这个比叫空间波阻抗，有： <span class="math display">\[\eta_0=\frac{|E|} {|H|}=\sqrt{\frac{\mu_0} {\varepsilon_0} }=120\pi\]</span></p></li><li><p>空间中任意一点，电场和磁场正交</p></li><li><p>空间中任意一点，电场和磁场的能量密度相等。</p></li></ol><p>## 正弦时变场和复数场定律</p><p>对于一个瞬时正弦时变场： <span class="math display">\[A(r,t)=i_xA_x(r)\cos\left[\omega t+\theta_x(r)\right]+i_yA_y(r)\cos\left[\omega t+\theta_y(r)\right]+i_zA_z(r)\cos\left[\omega t+\theta_z(r)\right]\]</span> 可以借鉴“相量法”的思想，把它写成复矢量形式： <span class="math display">\[A(r,t)=\Re[\tilde{A}(r)e^{j\omega t}]\]</span> 其中<span class="math inline">\(\tilde{A}(r)\)</span>就是我们所说的正弦量的复表示。有： <span class="math display">\[\tilde{A}(r)=i_xA_x(r)\angle\theta_x(r)+i_yA_y(r)\angle\theta_y(r)+i_zA_z(r)\angle\theta_z(r)\]</span> 在麦克斯韦方程组中，把对时间求导的<span class="math inline">\(\frac{\partial } {\partial t}\)</span>换成<span class="math inline">\(j\omega\)</span>，把各量换成复矢量表示，就得到了复数场定律。</p><p><strong>简单媒质</strong>中复数场定律如下： <span class="math display">\[\begin{aligned}\nabla \times \tilde{E}(\vec{r})&amp;=-j \omega \mu \widetilde{H}(\vec{r}) \\\\\nabla \times \widetilde{H}(\vec{r})&amp;=\tilde{J}_{f}(\vec{r})+j \omega \varepsilon \widetilde{E}(\vec{r}) \\\\\nabla \cdot \varepsilon \tilde{E}(\vec{r})&amp;=\dot{\rho}_{f}(\vec{r}) \\\\\nabla \cdot \mu \widetilde{H}(\vec{r})&amp;=0 \\\\\nabla \cdot \tilde{J}_{f}(\vec{r})&amp;=-j \omega \dot{\rho}_{f}(\vec{r})\end{aligned}\]</span></p><h2 id="正弦均匀平面波">正弦均匀平面波</h2><p>由复数场定律可导出<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>齐次亥姆霍兹方程： <span class="math display">\[\begin{aligned}\Delta\tilde{E}(r)+\beta^2\tilde{E}(r)=0\\\\\Delta\tilde{H}(r)+\beta^2\tilde{H}(r)=0\end{aligned}\]</span> 其中 <span class="math display">\[\beta=\omega\sqrt{\mu\varepsilon}=\frac{2\pi} {\lambda}\]</span> 我们知道沿<span class="math inline">\(z\)</span>传播的均匀平面波有两组独立的解<span class="math inline">\(\dot{E}_x-\dot{H}_y\)</span>和<span class="math inline">\(\dot{E}_y-\dot{H}_x\)</span>，只需讨论第一组，有解： <span class="math display">\[\dot{E}_x(z)=\dot{E}_{m_1}e^{j\beta z}+\dot{E}_{m_2}e^{ -j\beta z}\]</span> 结合 <span class="math display">\[\nabla\times\tilde{E}(r)=-j\omega\tilde{H}(r)\]</span> 可以求出<span class="math inline">\(\dot{H}_y\)</span>.</p><p>写出对应的时域表达式，有： <span class="math display">\[\begin{aligned}E_x(z,t)&amp;=\Re[\dot{E}_x(z)e^{j\omega t}]\\\\&amp;=|\dot{E}_{m1}|\cos(\omega t+\beta z+\alpha_1)+|\dot{E}_{m2}|\cos(\omega t-\beta z+\alpha_2)\\\\&amp;=|\dot{E}_{m1}|\cos\left[\beta(z+vt)+\alpha_1\right]+|\dot{E}_{m2}|\cos\left[\beta(z-vt)+\alpha_2\right]\end{aligned}\]</span> 其中<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(\dot{E}_m\)</span>的幅角。于是，各项的物理意义便很明显了：复振幅<span class="math inline">\(\dot{E}_m\)</span>反映了电场在<span class="math inline">\(z=0\)</span>点的初始振幅和相位，而<span class="math inline">\(e^{\pm j\beta z}\)</span>反映了相位随空间位置的变化和波的传播情况。其中<span class="math inline">\(\beta\)</span>称为空间相位常数。</p><h3 id="复数场极化方向的判断">复数场极化方向的判断</h3><p>电场的极化方向也就是说电场矢量尖端在和电磁场传播方向垂直的平面上划出的轨迹形状。有圆、椭圆、线极化三种。在判断复数场的极化方向时，有以下的操作步骤。</p><p>对于复数场 <span class="math display">\[\begin{aligned}\tilde{E}(r)&amp;=\dot{E}_me^{-j\beta z}\\\\&amp;=[E_R(z)+j\cdot E_I(z)]e^{-j\beta z}\end{aligned}\]</span></p><ol type="1"><li><p>线极化：以下三条件<strong>任意</strong>满足一项 <span class="math display">\[E_R(z)=0,\ E_I(z)=0, E_R(z)//E_I(z)\]</span></p></li><li><p>圆极化：<strong>同时</strong>满足以下条件 <span class="math display">\[E_R(z)\cdot E_I(z)=0 ,\ |E_R(z)|=|E_I(z)|\]</span></p></li><li><p>椭圆极化：其余情况。</p></li></ol><p>判断左旋还是右旋的方法是：在右手系（即右手从<span class="math inline">\(x\)</span>轴握向<span class="math inline">\(y\)</span>轴，大拇指指向<span class="math inline">\(z+\)</span>方向）中，画出电磁场传播方向（也就是波因亭矢量的方向）、<span class="math inline">\(E_R\)</span>、<span class="math inline">\(E_I\)</span>，然后用右手从<span class="math inline">\(E_I\)</span>向<span class="math inline">\(E_R\)</span>握，如果大拇指指向<span class="math inline">\(S\)</span>，那么就是右旋，否则是左旋。</p><h3 id="空间任意方向电磁场的表达">空间任意方向电磁场的表达</h3><p>前面我们讨论的都是沿着<span class="math inline">\(z\)</span>轴的电磁场。如果指向<span class="math inline">\(i_xa+i_yb+i_zc\)</span>的电磁场，我们就要改变<span class="math inline">\(e\)</span>的指数。有： <span class="math display">\[\tilde{E}(r)=\dot{E}_me^{-j(ax+by+cz)}\]</span> 这时，<span class="math inline">\(\beta=\sqrt{a^2+b^2+c^2}\)</span>.</p><p>通过例题来感受一下。</p><blockquote><p>【例】已知均匀平面波的电场为 <span class="math display">\[E(\boldsymbol{r},t)=10(i_x+2i_y+E_zi_z)\cos(\omega t+3x-y-z)\]</span> 求：传播方向（用单位矢量表示），波长，角频率，极化状态，磁场（用复矢量表示）</p><p>【解】 <span class="math display">\[\begin{aligned}\tilde{E}(\boldsymbol{r})&amp;=\dot{E}_0e^{-j\boldsymbol{\beta \cdot r} }\\\\&amp;=10(i_x+2i_y+E_zi_z)e^{-j(-3x+y+z)}\\\\\end{aligned}\]</span> 波的传播方向： <span class="math display">\[\boldsymbol{i}_\beta=\frac{\boldsymbol{\beta} } {|\boldsymbol{\beta}|}=\frac{-3i_x+i_y+i_z} {\sqrt{3^2+1+1} }=\left(\frac{-3} {\sqrt{11} },\frac 1{\sqrt{11} },\frac 1{\sqrt{11} }\right)\]</span> 波长： <span class="math display">\[\lambda=\frac{2\pi} {\beta}=\frac{2\pi} {\sqrt{11} }=1.89\text{(m)}\]</span> 角频率： <span class="math display">\[\omega=\beta c=3\sqrt{11}\times 10^8 \text{(rad/s)}\]</span> 由于电场方向和电磁场传播方向应该正交，即： <span class="math display">\[\boldsymbol{\beta}\cdot \dot{E}_0=0\]</span> 则解得<span class="math inline">\(E_z=1\)</span></p><p>由于满足 <span class="math display">\[\Im[E_0]=0\]</span> 因此是线极化波。</p><p>由 <span class="math display">\[H=\frac 1{\eta_0}i_\beta\times\tilde{E}(r,t)\]</span> 可求得<span class="math inline">\(H\)</span>.</p></blockquote><h2 id="复数形式场的功率讨论">复数形式场的功率讨论</h2><h3 id="复矢量乘积的意义">复矢量乘积的意义</h3><p>容易证明：两个复矢量的共轭叉（点）积的实部的一半等于相应的正弦时变量叉（点）积的时间平均值。</p><p>即： <span class="math display">\[\langle\vec{A}(t) \times \vec{B}(t)\rangle=\frac{1} {2} \operatorname{Re}\left(\tilde{A} \times \tilde{B}^{*}\right)\]</span></p><p><span class="math display">\[\langle\vec{A}(t) \cdot \vec{B}(t)\rangle=\frac{1} {2} \operatorname{Re}\left(\tilde{A} \cdot \tilde{B}^{*}\right)\]</span></p><p>证明提示：</p><p>用公式 <span class="math display">\[\vec{A}(t)=\frac{1} {2}\left[\tilde{A} e^{j \omega t}+\tilde{A}^{*} e^{-j \omega t}\right]\]</span> 把时变量运算式中的时变量和复矢量关联起来。</p><h3 id="复数坡印廷矢量">复数坡印廷矢量</h3><p>在前面，我们学过时域坡印廷矢量： <span class="math display">\[\boldsymbol{S}(\boldsymbol{r},t)=\boldsymbol{E}(\boldsymbol{r},t)\times\boldsymbol{H}(\boldsymbol{r},t)\]</span> 将电场，磁场的时域表达式用复数形式来表示，即： <span class="math display">\[\begin{aligned}\boldsymbol{E}(\boldsymbol{r},t)=\frac 12[\tilde{E}(r)e^{j\omega t}+\tilde{E}^*(r)e^{-j\omega t}]\\\\\boldsymbol{H}(\boldsymbol{r},t)=\frac 12[\tilde{H}(r)e^{j\omega t}+\tilde{H}^*(r)e^{-j\omega t}]\end{aligned}\]</span> 代入： <span class="math display">\[\boldsymbol{S}(\boldsymbol{r},t)=\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)]+\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)2^{j2\omega t}]\]</span> 定义复数坡印廷矢量： <span class="math display">\[\tilde{S}(r)=\frac 12 \tilde{E}(r)\times\tilde{H}^*(r)\]</span> 则有： <span class="math display">\[\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)]=\langle S(r,t)\rangle=\Re[\tilde{S}(r)]\]</span> 于是，我们可以说：复数坡印廷矢量的实部表示有功功率流密度，虚部可以解释为无功功率流密度。（这里可以类比电路分析中的复功率<span class="math inline">\(\dot{P}=\dot{V}_m\dot{I}_m/2=P+jQ\)</span>）</p><h3 id="复数坡印廷定理">复数坡印廷定理</h3><p>复数坡印廷定理的微分形式表达式如下： <span class="math display">\[-\nabla \cdot \tilde{S}(\vec{r})-\frac{1} {2}\left[\tilde{E}(\vec{r}) \cdot \tilde{J}_{S}^{*}(\vec{r})\right]=\frac{1} {2}\left[\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})\right]+j 2 \omega\left[\frac{\mu} {4}|\widetilde{H}(\vec{r})|^{2}-\frac{\varepsilon} {4}|\tilde{E}(\vec{r})|^{2}\right]\]</span> 为了理解其中各项物理意义，解释如下：</p><ul><li><p>等号左边第二项 <span class="math display">\[\Re\left[-\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{S}^{*}(\vec{r})\right]=\langle J_s(r,t)\times E(r,t)\rangle=\langle p_s(r,t)\rangle\]</span> 这一项表示电源提供的有功功率</p></li><li><p>等号右边第一项 <span class="math display">\[\Re\left[\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})\right]=\langle p_d(r,t)\rangle\]</span> 这一项表示电阻消耗的功率（即焦耳热功率）。注意：因为 <span class="math display">\[\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})=\frac 12\sigma |\tilde{E}(r)|^2\]</span> 所以这一项实际上是纯实数。</p></li><li><p>等号右边第二项 <span class="math display">\[\frac{\mu} {4}|\widetilde{H}(\vec{r})|^{2}=\langle\frac 12 \mu H(r,t)\cdot H(r,t)\rangle=\langle w_m(r,t)\rangle\]</span> 这一项可以理解为电感能量，也是纯实数（乘以前面的系数就是纯虚数了）</p></li><li><p>等号右边第三项 <span class="math display">\[\frac{\varepsilon} {4}|\tilde{E}(\vec{r})|^{2}=\langle\frac 12 \varepsilon E(r,t)\cdot E(r,t)\rangle=\langle w_e(r,t)\rangle\]</span> 这一项可以理解为电容的能量。</p></li></ul><p>我们把上面那个式子的实部和虚部拆开，有：</p><ul><li><p>实部： <span class="math display">\[\langle-\nabla \cdot \vec{S}(\vec{r}, t)\rangle+\left\langle p_{s}(\vec{r}, t)\right\rangle=\left\langle p_{d}(\vec{r}, t)\right\rangle\]</span> 电磁场向某点提供的电磁功率密度的时间平均值（有功电磁功率密度）与电源向该点提供的电磁功率密度的时间平均值（有功电磁功率密度）之和，等于该点焦耳热损耗功率密度的时间平均值。</p></li><li><p>虚部 <span class="math display">\[-\operatorname{Im}[\nabla \cdot \tilde{S}(\vec{r})]+q_{S}(\vec{r})=2 \omega\left[\left\langle w_{m}(\vec{r}, t)\right\rangle-\left\langle w_{e}(\vec{r}, t)\right\rangle\right]\]</span> 电磁场和电源向某点提供的无功电磁功率密度等于该点的磁能功率密度时间平均值和电能功率密度时间平均值之差的<span class="math inline">\(2𝜔\)</span>倍</p></li></ul><h2 id="平面波在有耗媒质中的传播">平面波在有耗媒质中的传播</h2><p>有耗媒质的根本特征是其电导率<span class="math inline">\(\sigma\)</span>不为零，进而，其中的传导电流<span class="math inline">\(J_d\)</span>不为零。因此，电磁波在其中传播时会产生损耗。特别的，如果电导率很高，以至于成为导体（例如金属），那么电磁波在其中几乎不能传播，只能在表面传播，这叫做“趋肤效应”。电磁波不能在理想导体中传播。</p><p>考虑复数形式的修正安培环路定律： <span class="math display">\[\nabla \times \tilde{H}(r)=\tilde{J}+j\omega \varepsilon\tilde{E}(r)\]</span> 将 <span class="math display">\[\tilde{J}=\sigma\tilde{E}(r)\]</span> 代入，有： <span class="math display">\[\nabla \times \tilde{H}(r)=\sigma\tilde{E}(r)+j\omega \varepsilon\tilde{E}(r)=j\omega\left(\frac{\sigma} {j\omega}+\varepsilon\right)\tilde{E}(r)\]</span> 定义复介电常数： <span class="math display">\[\dot{\varepsilon}=\left(\frac{\sigma} {j\omega}+\varepsilon\right)\]</span> 用复介电常数替换复麦克斯韦方程组中<strong>所有</strong>的介电常数，就能得到有耗媒质中的场定律。</p><p>需要注意的是，这时候波阻抗也变成了复数，即： <span class="math display">\[\dot{\eta}=\frac{\mu} {\dot{\varepsilon} }\]</span> 仿照前面的过程<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，导出复亥姆霍兹方程。仿照传播常数(波数)<span class="math inline">\(\beta\)</span>，定义复传播常数 <span class="math display">\[\dot{k}=\omega\sqrt{\dot{\varepsilon}\mu}=\beta-j\alpha\]</span> 那么，在有耗媒质中传播的电磁波的电场和磁场的复表示如下： <span class="math display">\[\begin{aligned}&amp;\widetilde{E}(r)=\hat{\imath}_{x} \dot{E}_{x 0} e^{-\alpha z} e^{-j \beta z}=\hat{\imath}_{x}\left|\dot{E}_{x 0}\right| e^{j \varphi_{x 0} } e^{-\alpha z} e^{-j \beta z} \\\\&amp;\widetilde{H}(r)=\hat{\imath}_{y} \frac{\dot{E}_{x 0} } {\dot{\eta} } e^{-\alpha z} \cdot e^{-j \beta z}=\hat{\imath}_{y}\left|\frac{\dot{E}_{x 0} } {\dot{\eta} }\right| e^{j\left(\varphi_{x 0}-\varphi_{\eta}\right)} e^{-\alpha z} e^{-j \beta z}\end{aligned}\]</span> 这里之所以要特意把<span class="math inline">\(\dot{E}_{x0}\)</span>以及<span class="math inline">\(\dot{E}_{x0}/\dot{\eta}\)</span>拆开成模长-幅角模式来写，是为了体现平面波在有耗媒质中的传播特点。</p><p>在有耗无源简单媒质中传播的均匀平面波是一个沿传播方向衰减的均匀平面波，衰减因子用<span class="math inline">\(\alpha\)</span>表示。电磁波频率越高，衰减因子越大，最终会趋向于 <span class="math display">\[\max \alpha=\frac {\sigma} {2}\sqrt{\frac{\mu} {\varepsilon} }\]</span> <strong>且磁场与电场不再同相</strong>。这是因为波阻抗不再是实数。</p><h3 id="导体的趋肤效应">导体的趋肤效应</h3><p>导体的电导率<span class="math inline">\(\sigma\)</span>越大，衰减因子也就越大。透入深度表示幅度衰减为<span class="math inline">\(e^{-1}\)</span>的深度，对良导体，其值为： <span class="math display">\[\delta=\sqrt{\frac 2{\omega\sigma\mu} }\]</span></p><h2 id="平面波的反射和折射">平面波的反射和折射</h2><h3 id="相关概念">相关概念</h3><ul><li><p>入射线：入射波波矢量<span class="math inline">\(\boldsymbol{\beta}_i\)</span>所在的直线</p></li><li><p>入射面：同时包含入射线和界面法线的平面</p></li><li><p>入射角：入射线和法线的夹角</p></li><li><p>反射线：反射波波矢量<span class="math inline">\(\boldsymbol{\beta}_r\)</span>所在的直线</p></li><li><p>反射面：同时包含反射线和界面法线的平面</p></li><li><p>反射角：反射线和法线的夹角</p></li><li><p>折射线：折射波波矢量<span class="math inline">\(\boldsymbol{\beta}_\tau\)</span>所在的直线</p></li><li><p>折射角：折射线和界面法线的夹角</p></li><li><p>垂直极化：线极化波的电场和入射面垂直</p></li><li><p>平行极化<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>：线极化波的电场和入射面平行</p></li><li><p>媒质的折射指数（折射率）： <span class="math display">\[n=\sqrt{\mu_r\varepsilon_r}\]</span> 其中<span class="math inline">\(\mu_r,\varepsilon_r\)</span>是相对磁导率和相对介电常数<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p></li><li><p>媒质的波数： <span class="math display">\[\beta=\omega\sqrt{\mu_1\varepsilon_1}=\beta_0n_1\]</span></p></li><li><p>媒质的波阻抗： <span class="math display">\[\eta_1=\sqrt{\frac{\mu_1} {\varepsilon_1} }=\eta_0\sqrt{\frac{\mu_{r1} } {\varepsilon_{r1} }}\]</span></p></li><li><p>Snell定律</p><ul><li>反射线和折射线都在入射面内</li><li>反射角等于入射角</li><li>折射角和入射角的正弦之比等于折射率之比，也等于波数之比和波的传播速度之比。</li></ul></li><li><p>光密（疏）介质：一个媒质的折射指数（折射率）越大，光（电磁波）在其中传播的速度越慢，波数<span class="math inline">\(\beta\)</span>越大，它就越可以被称为光密介质。真空是最疏的介质。</p></li></ul><h3 id="自由空间和理想导体界面的反射">自由空间和理想导体界面的反射</h3><h4 id="正入射">正入射</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/5711CB1D86975C4E56B6223EE37219FC.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图所示，入射波为 <span class="math display">\[\begin{aligned}\tilde{E}(r)=i_x\dot{E}_{i0}e^{-j\beta_0z}\\\\\tilde{H}(r)=i_y\frac{\dot{E}_{i0} } {\eta_0}e^{-j\beta_0z}\end{aligned}\]</span> 那么反射波的形式为： <span class="math display">\[\begin{aligned}\tilde{E}_r(r)=i_x\dot{E}_{r0}e^{j\beta_0z}\\\\\tilde{H}_r(r)=i_y\frac{\dot{E}_{r0} } {\eta_0}e^{j\beta_0z}\end{aligned}\]</span> 下面求<span class="math inline">\(\dot{E}_{r0}\)</span>。由边界条件： <span class="math display">\[i_n\times(\tilde{E}_1-\tilde{E}_2)=0\]</span> 其中： <span class="math display">\[\begin{aligned}\tilde{E}_1&amp;=\tilde{E}_i+\tilde{E}_r\\\\\tilde{E}_2&amp;=0\\\\i_n&amp;=-i_z\end{aligned}\]</span> 代入，得： <span class="math display">\[\dot{E_{r0} }=-\dot{E}_{i0}\]</span> 则有： <span class="math display">\[\begin{aligned}\tilde{E}_r(r)=-i_x\dot{E}_{i0}e^{j\beta_0z}\\\\\tilde{H}_r(r)=-i_y\frac{\dot{E}_{i0} } {\eta_0}e^{j\beta_0z}\end{aligned}\]</span> 合成波表达式为<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>： <span class="math display">\[\begin{aligned}\tilde{E}(r)=-2j\cdot i_x \dot{E}_{i0}\sin \beta_0z\\\\\tilde{H}(r)=2\cdot i_y\frac{\dot{E}_{i0} } {\eta_0}\cos \beta_0z\end{aligned}\]</span> 为了研究合成波的性质，我们把它转换到时域： <span class="math display">\[\begin{aligned}E(r,t)=i_x\cdot2|\dot{E}_{i0}|(\sin\beta_0z)\sin(\omega t+\varphi)\\\\H(r,t)=i_y\cdot\frac{2} {\eta_0}|\dot{E}_{i0}|(\cos\beta_0z)\cos(\omega t+\varphi)\end{aligned}\]</span> 我们可以看到，这表达了一列驻波。在驻波中电场和磁场有所谓“三个90度”关系，即：</p><ul><li>电场和磁场在空间分布上的相位差为90度。这说明：电场最强的 <strong>地方</strong> 磁场最弱。</li><li>电场和磁场在时间分布上的相位差为90度。这说明：电场最强的 <strong>时刻</strong> 磁场最弱。</li><li>电场和磁场在空间方向上相差90度。</li></ul><p>在驻波中，没有能量指向性的传播，只有能量形式的转换。</p><h4 id="斜入射">斜入射</h4><p>首先以垂直极化为例分析问题：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220617223348.png" /></p><p><strong>特别注意：不要看着这张图上面画了线，就以为电磁波“只在那条线上存在”，我们这里讨论的是平面波，入射波、反射波都在<span class="math inline">\(z&lt;0\)</span>整个空间上存在，所以可以直接合成，不需要也不应该考虑位置。</strong></p><p>入射方向： <span class="math display">\[\vec{\beta}_{i}=\beta_{0}\left(i_{x} \sin \theta_{i}+i_{z} \cos \theta_{i}\right)\]</span> 反射方向： <span class="math display">\[\vec{\beta}_{r}=\beta_{0}\left(i_{x} \sin \theta_{r}-i_{z} \cos \theta_{r}\right)\]</span> 那么，分别有入射场和反射场： <span class="math display">\[\begin{aligned}\tilde{E}_{i} &amp;=i_{y} \dot{E}_{i 0} e^{-j \vec{\beta}_{i} \cdot \vec{r} }=i_{y} \dot{E}_{i 0} e^{-j \beta_{0}\left(x \sin \theta_{i}+z \cos \theta_{i}\right)} \\\\\tilde{E}_{r} &amp;=i_{y} \dot{E}_{r 0} e^{-j \beta_{0}\left(x \sin \theta_{r}-z \cos \theta_{r}\right)}\end{aligned}\]</span> 由边界条件计算，得： <span class="math display">\[\dot{E}_{r0}=-\dot{E}_{i0}\]</span> 那么空间中的合成电场为：</p>$$<span class="math display">\[\begin{aligned}\tilde{E}&amp;=\tilde{E}_{i}+\tilde{E}_{r}=i_{y}\left[\dot{E}_{i 0} e^{-j \beta_{0}(x \sin \theta+z \cos \theta)}-\dot{E}_{i 0} e^{-j \beta_{0}(x \sin \theta-z \cos \theta)}\right]\\\\&amp;=i_{y} \dot{E}_{i 0}\left(e^{-j \beta_{0} z \cos \theta}-e^{j \beta_{0} z \cos \theta}\right) e^{-j \beta_{0} x \sin \theta}\\\\&amp;=-i_{y} \dot{E}_{i 0} j 2 \sin \left(\beta_{0} z \cos \theta\right) e^{-j \beta_{0} x \sin \theta} \end{aligned}\]</span><p>$$</p><p>记 <span class="math inline">\(\beta_0\cos \theta=\beta_z,\beta_0\sin\theta=\beta_x\)</span> ，有：</p><p><span class="math display">\[\tilde{E}=-i_{y} 2 j \dot{E}_{i 0} \sin \beta_{z} z \cdot e^{-j \beta_{x} x}\]</span></p><p>再由麦克斯韦方程组可求得磁场。</p><p>观察<span class="math inline">\(\tilde{E}\)</span>的表达式，我们发现有以下特点：</p><ol type="1"><li>在<span class="math inline">\(x\)</span>是常数的平面上，<span class="math inline">\(e^{-j\beta_xx}\)</span>是常数，所以<span class="math inline">\(x=C\)</span>是波的等相面。在<span class="math inline">\(x=C\)</span>的平面上，场量按三角函数形式分布，波显示出驻波性质。</li><li>在<span class="math inline">\(z\)</span>是常数的平面上，<span class="math inline">\(\sin \beta_zz\)</span>是常数，波的表达式表现出一般平面波的形式，是行波。而且在等相面上振幅不是常数，是非均匀平面波。</li><li>于是，我们可以发现：合成波只在<span class="math inline">\(x\)</span>方向有能量传输，而在<span class="math inline">\(z\)</span>方向没有。</li></ol><p>正入射时，入射波和反射波的合成波形成了一种特殊的传播方式，我们称之为驻波。 <strong>斜入射时，入射波和反射波的合成波也形成了一种特殊的传播方式，我们称之为导行波。</strong> 这里的电场指向<span class="math inline">\(y\)</span>，和传播方向垂直，我们称之为横电波（TE波）。</p><p>导行波的等相面是 <span class="math display">\[\omega t-\beta_x x=C\]</span> 因此，其相速度为 <span class="math display">\[v_p=\frac c {\sin\theta}\]</span> 神奇！相速度超过了光速！但是我们都知道光速是无论如何不能超过的，这是怎么回事呢？我们要先理解相速度和群速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/v2-192809449ccca511cddfb1735ed54b8d_720w.gif" alt="这个图片只用来说明相速度和群速度的概念" /><figcaption aria-hidden="true">这个图片只用来说明相速度和群速度的概念</figcaption></figure><ul><li>相速度是等相位面传播的速度，也就是图中红色方块的速度。</li><li>群速度的波包移动的速度，是能量传递的速度，也就是绿色圆点移动的速度。</li></ul><p>我们可以看出，只有群速度是真正的速度。譬如说，我拿着一个激光笔扫过夜空，那么激光笔在云层上反射的光点可能会具有非常非常非常高的速度，那么难道说真的有物体在以这个速度移动吗？不是这样的。相速度只是一种“看起来”的速度，是一个虚假的速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/0F8C440DC9578247F927A8C922F4A842.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图，在这个情景中，黑色的实线和虚线是等相位面，蓝色是相速度，绿色是群速度，红色是光速。这么一说大家应该可以理解了。在一个周期里，导行波过<span class="math inline">\(A\)</span>点的等相位面的相位传到了<span class="math inline">\(C\)</span>点，从<span class="math inline">\(X\)</span>方向看，就像是相位从<span class="math inline">\(B\)</span>移动到了<span class="math inline">\(C\)</span>，而此时能量只是从A移动到了<span class="math inline">\(C’\)</span>。</p><p>在平行极化时，合成波的磁场是横向的，电场是<span class="math inline">\(xOz\)</span>面内的椭圆极化波。合成波依然在<span class="math inline">\(x\)</span>方向表现行波，在<span class="math inline">\(z\)</span>方向表现为驻波。这种波叫横磁波（TM波）。</p><h3 id="在两种理想介质分界面处的反射和折射">在两种理想介质分界面处的反射和折射</h3><p>这里讨论的是两种均匀、线性、各向同性、无耗理想介质分界面处的反射和折射。</p><h4 id="两种无耗介质交界面的垂直入射">两种无耗介质交界面的垂直入射</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/12414515.png" /></p><p>入射波为 <span class="math display">\[\begin{aligned}\tilde{E}(r)=i_x\dot{E}_{i0}e^{-j\beta_0z}\\\\\tilde{H}(r)=i_y\frac{\dot{E}_{i0} } {\eta_0}e^{-j\beta_0z}\end{aligned}\]</span> 不难写出反射波，折射波的表达式：只需要把入射波中的<span class="math inline">\(E_{i0}\)</span>换成<span class="math inline">\(E_{r0},E_{\tau 0}\)</span>，再注意一下方向就行了，十分的简单。我们的问题现在是：<span class="math inline">\(E_{i0}\)</span>和<span class="math inline">\(E_{r0},E_{\tau 0}\)</span>的关系是？</p><p>由边界条件： <span class="math display">\[\begin{aligned}i_{n} \times\left.\left(\tilde{E}_{1}-\tilde{E}_{2}\right)\right|_{z=0}=0 \quad \\\\i_{n} \times\left.\left(\widetilde{H}_{1}-\widetilde{H}_{2}\right)\right|_{z=0}=\tilde{k}_{f}=0\end{aligned}\]</span> 得： <span class="math display">\[\left\{\begin{array} {l}\dot{E}_{i 0}+\dot{E}_{r 0}=\dot{E}_{\tau 0} \\\\\dot{H}_{i 0}-\dot{H}_{r 0}=\dot{H}_{\tau 0} \Rightarrow \frac{\dot{E}_{i 0} } {\eta_{1} }-\frac{\dot{E}_{r 0} } {\eta_{1} }=\frac{\dot{E}_{\tau 0} } {\eta_{2} }\end{array}\right.\]</span></p><p>于是有反射系数： <span class="math display">\[\Gamma=\frac{\dot{E}_{r 0} } {\dot{E}_{i 0} }=\frac{\eta_{2}-\eta_{1} } {\eta_{2}+\eta_{1} }\]</span> 透射系数： <span class="math display">\[T=\frac{\dot{E}_{\tau 0} } {\dot{E}_{i 0} }=\frac{2 \eta_{2} } {\eta_{2}+\eta_{1} }\]</span></p><h4 id="三层介质垂直入射无反射条件">三层介质垂直入射无反射条件</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220617234904444.png" /></p><p>一般来说应用场景是：I是空气（真空），III是玻璃，II是增透膜，要求你调整增透膜的<span class="math inline">\(\eta_2\)</span>和厚度。有以下两种情况都能达到目的：</p><ol type="1"><li><span class="math inline">\(\eta_1=\eta_3,d=n\lambda_2/2\)</span></li><li><span class="math inline">\(\eta_2=\sqrt{\eta_1\eta_3},d=(2n+1)\lambda_2/4\)</span></li></ol><p>请注意，这里的波长是在介质2中的波长。电磁场在不同介质中，频率是不会变 ，而波长会变。</p><h4 id="斜入射-1">斜入射</h4><p>还是以垂直极化为例：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220617235606731.png" /></p><p>同样，由边界条件计算反射、透射系数，有：</p><p>反射系数： <span class="math display">\[\Gamma_{\perp}=\frac{\dot{E}_{r 0} } {\dot{E}_{i 0} }=\frac{\eta_{2} \cos \theta_{1}-\eta_{1} \cos \theta_{2} } {\eta_{2} \cos \theta_{1}+\eta_{1} \cos \theta_{2} }\]</span></p><p>透射系数： <span class="math display">\[T_{\perp}=\frac{\dot{E}_{\tau 0} } {\dot{E}_{i 0} }=\frac{2 \eta_{2} \cos \theta_{1} } {\eta_{2} \cos \theta_{1}+\eta_{1} \cos \theta_{2} }\]</span></p><p>有时候会出现一些神奇的现象：</p><ul><li><p>全反射</p><p>全反射无论是磁介质（<span class="math inline">\(\mu_r\neq 1\)</span>）还是电介质（<span class="math inline">\(\varepsilon_r\neq 1\)</span>）都可以产生。当从光密介质射入光疏介质时，当入射角达到一个临界值<span class="math inline">\(\theta_c\)</span>时，反射线和介质表面重合（反射角是<span class="math inline">\(\pi/2\)</span>），这时称为出现全反射现象，<span class="math inline">\(\theta_c\)</span>是全反射临界角。有： <span class="math display">\[\sin \theta_c=\frac{n_2} {n_1}\]</span></p></li><li><p>全折射 当入射波垂直极化时，在电介质交界面，不会出现全折射现象，只有磁介质交界面才会出现。无论从疏到密，还是从密到疏，都能发生全折射现象。全折射的临界角<span class="math inline">\(\theta_{P_\perp}\)</span>称为布茹斯特角。有： <span class="math display">\[\theta_{P_\perp}=\sqrt{\frac{\mu_2} {\mu_1+\mu_2} }\]</span></p></li></ul><p>我写了一个代码来计算反射系数和折射系数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">er1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质1的相对介电常数&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">mur1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质1的相对磁导率&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">er2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质2的相对介电常数&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">mur2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质2的相对磁导率&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">eta0</span><span class="hljs-operator">=</span><span class="hljs-number">120</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">;</span><br><span class="hljs-variable">eta1</span><span class="hljs-operator">=</span><span class="hljs-variable">eta0</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur1</span><span class="hljs-operator">/</span><span class="hljs-variable">er1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">eta2</span><span class="hljs-operator">=</span><span class="hljs-variable">eta0</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur2</span><span class="hljs-operator">/</span><span class="hljs-variable">er2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">n1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur1</span><span class="hljs-operator">*</span><span class="hljs-variable">er1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">n2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur2</span><span class="hljs-operator">*</span><span class="hljs-variable">er2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span><span class="hljs-built_in">ArcSin</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">*</span><span class="hljs-variable">n1</span><span class="hljs-operator">/</span><span class="hljs-variable">n2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Gammaa</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">-</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Tt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span> <span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Gammaa</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Tt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">theta</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-operator">,</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span><span class="hljs-built_in">PlotLegends</span><span class="hljs-operator">-&gt;</span><span class="hljs-string">&quot;Expressions&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>例如，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>会给出图像</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220618114117442.png" alt="全反射现象示意图" /><figcaption aria-hidden="true">全反射现象示意图</figcaption></figure><p>全反射现象十分明显。</p><p>再例如输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>会给出图像</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220618114215103.png" alt="全折射现象示意图" /><figcaption aria-hidden="true">全折射现象示意图</figcaption></figure><p>从疏介质射入密介质，这里发生了全折射。</p><hr /><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>由于<span class="math inline">\(\nabla\times\tilde{E}(r)=-j\omega\mu\tilde{H}(r)\)</span>，两边取旋度，有<span class="math inline">\(\nabla\times\nabla\times\tilde{E}(r)=-j\omega\mu\nabla \times \tilde{H}(r)\)</span>，代入<span class="math inline">\(\nabla \times \tilde{H}(r)=j\omega\varepsilon\tilde{E}(r)\)</span>，并结合矢量公式<span class="math inline">\(\nabla\times\nabla\times A=\nabla[\nabla \cdot A]-\Delta A\)</span>即可推出。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>由于<span class="math inline">\(\nabla\times\tilde{E}(r)=-j\omega\mu\tilde{H}(r)\)</span>，两边取旋度，有<span class="math inline">\(\nabla\times\nabla\times\tilde{E}(r)=-j\omega\mu\nabla \times \tilde{H}(r)\)</span>，代入<span class="math inline">\(\nabla \times \tilde{H}(r)=j\omega\varepsilon\tilde{E}(r)\)</span>，并结合矢量公式<span class="math inline">\(\nabla\times\nabla\times A=\nabla[\nabla \cdot A]-\Delta A\)</span>即可推出。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>椭圆极化波和圆极化波可以分解成两个垂直的线极化波，进而，可以分解成垂直极化和平行极化波。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>相对磁导率（介电常数）意思是媒质中的磁导率（介电常数）和真空中的比值。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p><span class="math inline">\(\sin x=\frac{1} {2j}(e^{jx}-e^{-jx})\)</span>,<span class="math inline">\(\cos x=\frac{1} {2}(e^{jx}+e^{-jx})\)</span><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告4：集成运放实验2</title>
    <link href="/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A4/"/>
    <url>/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A4/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第四个实验，运用555定时器和集成运放的实验。</p><span id="more"></span><h2 id="方波发生器">方波发生器</h2><p>LM555是一款具有精确定时功能的芯片，利用其工作原理，可以实现脉冲波发射电路。在电路正常工作时，可以通过调节滑动变阻器<span class="math inline">\(R_1\)</span>，来调节脉冲波的占空比。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140015286.png" alt="image-20220607230056150" /><figcaption aria-hidden="true">image-20220607230056150</figcaption></figure><h2 id="锯齿波发生器">锯齿波发生器</h2><p>锯齿波的产生原理是对方波进行积分。在这里使用一个单运放积分器即可。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140015177.png" alt="image-20220608223724447" /><figcaption aria-hidden="true">image-20220608223724447</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140015781.png" alt="image-20220608223742381" /><figcaption aria-hidden="true">image-20220608223742381</figcaption></figure><h2 id="正弦波发生器">正弦波发生器</h2><p>正弦波发生器的工作原理是对脉冲波进行滤波得到基波分量，这里使用一个单运放有源滤波器进行滤波。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140016152.png" alt="image-20220609113906066" /><figcaption aria-hidden="true">image-20220609113906066</figcaption></figure><h2 id="系统级实验">系统级实验</h2><p>系统级实验需要把前面三项实验组合在一起，其中三次谐波分量的生成需要一个带通滤波器。还应该考虑电路之间的互相影响，调节元器件参数。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140016042.png" alt="image-20220613142835570" /><figcaption aria-hidden="true">image-20220613142835570</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140016369.png" alt="image-20220613142910664" /><figcaption aria-hidden="true">image-20220613142910664</figcaption></figure><h2 id="感想与体会">感想与体会</h2><p>这部分就自己写哈</p><hr /><p>本实验各文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E5%AE%9E%E9%AA%8C%202%EF%BC%88555%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89.zip">集成运放实验2 555定时器 下载</a></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子电路</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告3：集成运放实验1</title>
    <link href="/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A3/"/>
    <url>/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A3/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第三个实验，集成运放实验1。</p><span id="more"></span><h2 id="单运放波形发生器">单运放波形发生器</h2><p>考虑到波形近似的可能，在方波生成器参考点引入反馈，可以获得近似三角波的波形。其中电容<span class="math inline">\(C_1\)</span>较大时可以获得良好的积分曲线，但是同时可能导致波形发生器的频率太低，也就是说信号的幅度，周期，频率是相互制约的。综合考虑实验要求，<span class="math inline">\(C_1\)</span>选择<span class="math inline">\(1\mu F\)</span>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140019425.png" alt="image-20220607204743998" /><figcaption aria-hidden="true">image-20220607204743998</figcaption></figure><h2 id="单运放加法器">单运放加法器</h2><p>考虑到正相加法器的电阻参数是互相关联的，不能单独调整，而且信号源的内阻会影响电路的增益，而反相加法器实现简单，调试方便，因此这里选用反相加法电路。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140019293.png" alt="image-20220607204102829" /><figcaption aria-hidden="true">image-20220607204102829</figcaption></figure><h2 id="单运放四阶滤波器">单运放四阶滤波器</h2><p>此处采用四阶带通有源滤波器设计，其滤波效果更好，带外衰减比较大。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140019344.png" alt="image-20220607214307585" /><figcaption aria-hidden="true">image-20220607214307585</figcaption></figure><h2 id="比较器">比较器</h2><p>对速度要求不高时，采用无穷大阻抗反馈可以把普通运算放大器作为比较器使用。故采用如图所示的设计。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140019806.png" alt="image-20220607221123119" /><figcaption aria-hidden="true">image-20220607221123119</figcaption></figure><h2 id="系统级实验">系统级实验</h2><p>系统级实验是前面四个实验的组合，级联时需要考虑前后级模块的匹配问题，适当调整参数。三</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140019716.png" alt="image-20220607224348279" /><figcaption aria-hidden="true">image-20220607224348279</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140020813.png" alt="image-20220607224402833" /><figcaption aria-hidden="true">image-20220607224402833</figcaption></figure><h2 id="感想与体会">感想与体会</h2><p>这部分就自己写哈。</p><hr /><p>本次实验各文件下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E5%AE%9E%E9%AA%8C%201.zip">集成运放实验1下载</a></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xc能为宅宅做的35件实事</title>
    <link href="/2022/06/11/xc%E8%83%BD%E4%B8%BA%E5%AE%85%E5%AE%85%E5%81%9A%E7%9A%8435%E4%BB%B6%E5%AE%9E%E4%BA%8B/"/>
    <url>/2022/06/11/xc%E8%83%BD%E4%B8%BA%E5%AE%85%E5%AE%85%E5%81%9A%E7%9A%8435%E4%BB%B6%E5%AE%9E%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>1. 承担一半（或以上）的小组作业或科研工作。</strong></p><p>你需要承担自己份内的小组作业，按时完成，不需请求，不找借口。要知道，我们当前的习惯性的任务分配模式，包括我们对此的观念，都是非常有利于xc的，是宅宅歧视的。作为支持宅权主义的xc，你有责任与这些传统观念抗争。如果说宅权主义是理论，那么多写两行代码就是实践。请在接下来的一周记录你写了多少代码，并和你组中的宅宅作比较，看看任务分配是否平均。</p><p><strong>2. 在与群友、同事的关系中，承担一半（或以上）的精神支持工作。</strong></p><p>你要认识到，宅宅所承担的情绪劳动要比xc多得多[注1]，而这项劳动会占据他们实现个人抱负的时间和精力。</p><p>[注1]：读者自证不难</p><p><strong>3. 购买二次元的文化产品。</strong></p><p>不管你是喜欢法国电影、天体物理学，还是棒球、观鸟……请保证二次元的声音和宅宅创作的文化产品出现在你的文化消费清单之中。如果此前你的消费清单上从没出现过二次元的作品，现在就努力把它们找出来吧。</p><p><strong>4. 给宅宅留出空间。</strong> 宅宅出门在外都会觉得缺乏安全感并感到紧张，尤其是在晚间出行或单独出行的时候。这种不安全感在有陌生xc接近并且抱在一起互相啃食时会加剧。想一想有多少宅宅曾经在公共场合被xc虐待，你就知道宅宅的这种恐惧并非无缘无故。同时请注意，即使你不是那种真会对宅宅造成威胁的xc，也请不要随意离他们太近，因为他们没法在大街上判断出你到底危不危险。</p><p>举个例子：在公交上，请优先坐在情侣旁边、而不是宅宅旁边的空座上。如果你与独自走夜路的宅宅同路，请穿到马路对面走，避免跟在他身后，这样他就不用担心自己是否被虐狗了。</p><p><strong>5. 请充分利用自己的xc身份制止宅宅歧视。</strong></p><p>例如：公开反驳那些在群里秀恩爱的线虫。如果在酒吧里、在聚会上、在地铁上……看到你的宅宅朋友似乎正苦于应付面前的情侣，都请你友好地上前打断他们，为你的宅宅朋友制造出一个可以脱身的机会。 我知道做这样的事情可能会非常困难和尴尬，而且大家都不太清楚究竟怎么做才更合适，但是总该去努力尝试一下。如果自己一时的尴尬能让宅宅感到更舒适，那这么做也是值得的。</p><p><strong>6. 如果有宅宅告诉你“这是xc对我的歧视”，请相信他。</strong></p><p><strong>7. 请弄清楚什么情况下是可以秀恩爱的。</strong></p><p><strong>8. 承担被移出群聊的责任。</strong></p><p><strong>9. 每天观看一集动画片</strong></p><p><strong>10. 接受进步的文化娱乐观念。</strong></p><p><strong>11. 如果你看电影，请平等地做观赏者。</strong></p><p>你在看xc电影时，也同时要看等量（或以上）的二次元儿电影。</p><p><strong>12. 注意到并反对那些在无形中强化了xc和宅宅角色分工的行为。</strong></p><p>比如说吃饭的时候，请观察是不是基本上只有宅宅在认真吃饭，而xc们则在一旁聊天娱乐，高谈阔论。如果是这样，请主动改变这种情况，并说服其他xc跟你一起这样做。</p><p><strong>13. 请留心自己与身边的宅宅之间是否存在明显和不明显的权利差异。</strong></p><p>请努力意识到所有基于种族、阶级、性别、性取向、年龄等因素的固有结构性权利差异。当你受益于这些结构性不平等时，你要能意识到自己究竟享有了哪些特权，并尝试打破这些不平等，以实现权利的均衡。</p><p><strong>14. 请将真诚和尊重作为与宅宅保持群友关系和同事关系的前提。</strong></p><p>你与宅宅交往的方式基本可以反映出你对宅宅的价值观。如果你像对待垃圾一样对待自己的群友，那不管你有多支持宅权主义理论都没用。</p><p><strong>15. 请不要做宅宅歧视的线上旁观者。</strong></p><p>如果在网络上，尤其是社交网络上看到宅宅歧视言论或行为，请一定站起来质疑它们。</p><p><strong>16. 当你和宅宅在一个组里时，请对自己的财务状况负责。</strong></p><p>如果你不能对自己的财务状况负起责任来，你的组员必定会因此受牵连。由于宅宅收入普遍低于xc，但是宅宅的寿命又普遍长于xc，所以这也是个宅权议题。</p><p><strong>17. 请对自己的健康负责。</strong></p><p><strong>18. 不要盯着宅宅看或者对他们的生活评头论足。</strong></p><p><strong>19. 留意媒体中出现的各种专家和重要信息提供者的属性。</strong></p><p>当你在电视中看到或者在文章中读到某位专家的观点，请注意一下这些专家是不是都是xc，他们的观点是不是都是从xc的角度提出的，或者请至少想一想，若是从宅宅的角度来看这个问题，可能会有哪些不同。</p><p><strong>20. 请确保你也有一些宅宅偶像和榜样。</strong></p><p><strong>21. 在生活中向他人夸赞你身边宅宅的优点和成就。</strong></p><p>当你在日常对话和交流中提到某个你知道的宅宅时，请正面积极地评价他。请利用自己的关系网为你的宅宅朋友提供与他人合作共事的机会。</p><p><strong>22. 在你的xc朋友面前表现得正直一点（也就是说，不要因为xc情义就纵容他那些对宅宅失礼的行为）。</strong></p><p>当你的男性朋友表现得很大xc主义的时候（例如胡乱秀恩爱，侮辱宅宅等等），请做一个正直的朋友，去劝阻他。你的正直想法仅仅停留在脑中是不够的，要说出口，让他们意识到自己的错误。</p><p><strong>23. 不要嫌你的群友“死宅”，他“死宅”可能是因为你“线虫”。</strong></p><p>注：特意采用“死宅”来翻译“otaku”，是想提醒大家注意，这个中文词汇本身就很有宅宅歧视的意味。</p><p><strong>24. 仅仅承认你有宅宅歧视的倾向和保守老旧的思想是不够的，你得付诸行动，做出改变。</strong></p><p><strong>25. 将宅宅当做朋友看待。</strong></p><p>如果你没有二次元朋友，请弄明白为什么。尝试交一些宅宅朋友，并确保你和他的友谊是真诚可信的、有意义的。我们越多与他人接触，多关心别人，越能建立一个更平等的社会。</p><p><strong>26. 寻找宅宅领袖或导师（也就是说成为宅宅的下属）</strong></p><p>如果你在寻找一名导师，或者想到某个组织当志愿者，请去找二次元组织或者由二次元领导的组织。你可以从权威的宅宅身上学到很多东西。</p><p><strong>27. 请对每一个二次元角色的生日负责。</strong></p><p>请记住你自己的宅宅群友喜欢的lp的生日、纪念日和重要活动的日期。</p><p><strong>28. 不要对宅宅的xp指手画脚。</strong></p><p><strong>29. 千万不要提议与需要出门宅宅朋友同行。</strong></p><p><strong>30. 将宅权主义融入你与其他xc的日常交谈中。</strong></p><p><strong>31. 如果你在酒精或者npy的作用下可能会对宅宅有失礼的行为，那就请你不要摄入酒精或者npy。</strong></p><p><strong>32. 请留意你所占据的公共空间，不管是身体上的还是情绪上的，不要占据过多的，超出基本需求的空间。</strong></p><p><strong>33. 真正着手解决地位不平等问题。</strong></p><p><strong>34. 要明白你的xc是一种与生俱来的特权，并努力放弃你所拥有的特权；不要以为宅宅是与生俱来的劣势，也不要觉得克服这种劣势仅仅是宅宅的责任。</strong></p><p><strong>35. 认同自己“宅权主义者”的身份。</strong></p><p>将宅权主义当做是一种自然地、平常的、无可争议的信念，因为本来就应该是这样的。不要躲藏掩饰，不要使用“人道主义者”或者“宅权主义同盟”这样的概念，因为这会让人们更容易觉得“宅权主义”是个很恐怖的字眼儿。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告2：差分放大电路仿真与分析</title>
    <link href="/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A2/"/>
    <url>/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A2/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第二个实验，差分放大电路。</p><span id="more"></span><hr /><h2 id="差分放大电路">差分放大电路</h2><h3 id="普通差分放大电路">普通差分放大电路</h3><p>实验原始电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140020889.png" alt="image-20220607164117446" /><figcaption aria-hidden="true">image-20220607164117446</figcaption></figure><h4 id="直流工作点分析">直流工作点分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140020508.png" alt="image-20220607164142482" /><figcaption aria-hidden="true">image-20220607164142482</figcaption></figure><table><thead><tr class="header"><th style="text-align: center;">Variable</th><th style="text-align: center;">Operating point value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V(1)-V(11)/V</td><td style="text-align: center;">12.22515</td></tr><tr class="even"><td style="text-align: center;">I(Q3[IB])/uA</td><td style="text-align: center;">2.07344</td></tr><tr class="odd"><td style="text-align: center;">I(Q3[IC])/uA</td><td style="text-align: center;">359.1267</td></tr><tr class="even"><td style="text-align: center;">I(Q3[IE])/uA</td><td style="text-align: center;">-361.20014</td></tr></tbody></table><p>即： <span class="math display">\[V_{be}=12.23\text{mV}\\I_b=2.07\mu\text{A}\\I_c=359 \mu\text{A}\\I_e=-361\mu\text{A}\]</span> 三极管工作在放大区。</p><h4 id="测量静态工作电流">测量静态工作电流</h4><p>测量电路及结果如图所示，电流表设置为直流模式：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140020287.png" alt="image-20220607164553377" /><figcaption aria-hidden="true">image-20220607164553377</figcaption></figure><p>电流源提供的静态工作电流约<span class="math inline">\(722\mu\text{A}\)</span>.</p><h4 id="测量输入输出电阻">测量输入、输出电阻</h4><p>测量输入电阻，在输入部分测量电流和电压，相除即可得到输入电阻。</p><p>测量电路和结果如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165012310.png" alt="image-20220607165012310" /><figcaption aria-hidden="true">image-20220607165012310</figcaption></figure><p>有： <span class="math display">\[R_i=\frac VI=33750\Omega\]</span> 测量输出电阻，分别测量开关<span class="math inline">\(S_1\)</span>打开和闭合时的电压，通过公式计算输出电阻。</p><p>测量电路和结果如图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140020179.png" alt="image-20220607165247200" /><figcaption aria-hidden="true">image-20220607165247200</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165316048.png" alt="image-20220607165316048" /><figcaption aria-hidden="true">image-20220607165316048</figcaption></figure><p>有： <span class="math display">\[R_o=\frac{V_2-V_1}{V_1}R_L=1059\Omega\]</span></p><h4 id="测量单端输出差模放大倍数">测量单端输出差模放大倍数</h4><p>在输出端、输入端接入电压表，测量并求比值。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140020337.png" alt="image-20220607165450973" /> <span class="math display">\[A=\frac{V_o}{V_i}=5.94\]</span></p><h4 id="用仪表测量幅频相频曲线">用仪表测量幅频、相频曲线</h4><p>把波特测试仪连入电路并测量。</p><p>电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021294.png" alt="image-20220607165832111" /><figcaption aria-hidden="true">image-20220607165832111</figcaption></figure><p>结果：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021045.png" alt="image-20220607110325379" /><figcaption aria-hidden="true">image-20220607110325379</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021834.png" alt="image-20220607110341367" /><figcaption aria-hidden="true">image-20220607110341367</figcaption></figure><h4 id="用交流分析给出幅频相频曲线">用交流分析给出幅频、相频曲线</h4><p>在“仿真”中选择交流分析，选定合适的参数和输出量并进行仿真。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021543.png" alt="image-20220607110425299" /><figcaption aria-hidden="true">image-20220607110425299</figcaption></figure><h4 id="温度扫描">温度扫描</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021758.png" alt="image-20220607111351195" /><figcaption aria-hidden="true">image-20220607111351195</figcaption></figure><p>单管放大器电路以及温度扫描：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021495.png" alt="image-20220607111249985" /><figcaption aria-hidden="true">image-20220607111249985</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021504.png" alt="image-20220607111230796" /><figcaption aria-hidden="true">image-20220607111230796</figcaption></figure><p>由此可见，差放有抑制温漂的功能。</p><h4 id="最大不失真输出电压">最大不失真输出电压</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021796.png" alt="image-20220607172410632" /><figcaption aria-hidden="true">image-20220607172410632</figcaption></figure><p>最大不失真输出电压约为11.94V。</p><h3 id="有源负载差分放大电路">有源负载差分放大电路</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140021257.png" alt="image-20220607172622665" /><figcaption aria-hidden="true">image-20220607172622665</figcaption></figure><p>有<span class="math inline">\(1k\Omega\)</span>负载时，放大倍数约为10.41。</p><p>这个电路的特点有：</p><ol type="1"><li>单端输出</li><li>共模抑制比无穷多</li><li>差模电压增益很大</li></ol><h2 id="cmos差分放大电路">CMOS差分放大电路</h2><h3 id="原始电路图">原始电路图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607192057086.png" alt="image-20220607192057086" /><figcaption aria-hidden="true">image-20220607192057086</figcaption></figure><p>在选取管子时，应该右键管子编辑模型，以将L、N的长度编辑到书上给定的长度。</p><h3 id="直流工作点分析-1">直流工作点分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140022544.png" alt="image-20220607192231241" /><figcaption aria-hidden="true">image-20220607192231241</figcaption></figure><p>查询手册，得：<span class="math inline">\(V_{GS(th)}=1.6\text{V}\)</span> <span class="math display">\[V_{GS}=V_2-V_1=2.36&gt;V_{GS(th)}\\V_{DS}=V_4-V_1=3.65&gt;V_{GS}-V{GS(th)}\]</span> 因此，工作在恒流区。</p><h3 id="测量差模放大倍数">测量差模放大倍数</h3><p>在一端设置<span class="math inline">\(10\)</span>mV输入信号，并测定单端输出电压，电路图和结果如图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140022271.png" alt="image-20220607193641714" /><figcaption aria-hidden="true">image-20220607193641714</figcaption></figure><p>如图，有： <span class="math display">\[A_{vd1}=\frac{V_o}{V_i}=78\]</span> 用示波器测量波形如图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140022044.png" alt="image-20220607195027828" /><figcaption aria-hidden="true">image-20220607195027828</figcaption></figure><h3 id="测量共模放大倍数">测量共模放大倍数</h3><p>在两端端设置彼此相同的1V输入信号，并测定单端输出电压，电路图和结果如图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140022175.png" alt="image-20220607194543351" /><figcaption aria-hidden="true">image-20220607194543351</figcaption></figure><p>如图所示，两边放相同的信号源，测量共模放大倍数。有： <span class="math display">\[A_{vc1}=\frac{V_o}{V_i}=0.054\]</span> 用示波器测量波形：<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140022948.png" alt="image-20220607194857656" /></p><h3 id="填写记录表格">填写记录表格</h3><p>共模抑制比计算公式为： <span class="math display">\[K_{CMR}=\frac{A_{vd1}}{A_{vc1}}\]</span></p><table><thead><tr class="header"><th>参数</th><th><span class="math inline">\(V_{i1}\)</span></th><th><span class="math inline">\(V_{o1}\)</span></th><th><span class="math inline">\(A_{vd1}\)</span></th><th><span class="math inline">\(V_{ic}\)</span></th><th><span class="math inline">\(V_{o1}\)</span></th><th><span class="math inline">\(A_{vc1}\)</span></th><th><span class="math inline">\(K_{CMR}\)</span></th></tr></thead><tbody><tr class="odd"><td>值</td><td>9.996mV</td><td>769.686mV</td><td>78</td><td>1V</td><td>54.45mV</td><td>0.054</td><td>1444.44</td></tr></tbody></table><h2 id="感想和体会">感想和体会</h2><p>这部分就自己写哈</p><hr /><p>本次实验各文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8.zip">差分放大器实验下载</a></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告1：共射放大器和射极跟随器</title>
    <link href="/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A1/"/>
    <url>/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A1/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第一个实验，共射放大器和射极跟随器。</p><span id="more"></span><h2 id="共射放大器的分析和设计">共射放大器的分析和设计</h2><h3 id="实验目的">实验目的</h3><ol type="1"><li><p>进一步了解 Multisim 的各项功能，熟练掌握其使用方法，为后续课程打好基础。</p></li><li><p>通过使用 Multisim 来仿真电路，测试如图 1 所示的单管共射放大电路的静态工作点、电压放大倍数、输入电阻和输出电阻，并观察静态工作点的变化对输出波形的影响。</p></li><li><p>加深对放大电路工作原理的理解和参数变化对输出波形的影响。</p></li><li><p>观察失真现象，了解其产生的原因。</p></li></ol><h3 id="实验原理图">实验原理图</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023052.png" alt="image-20220530203406386" /><figcaption aria-hidden="true">image-20220530203406386</figcaption></figure><h3 id="实验内容及仿真数据">实验内容及仿真数据</h3><h4 id="进行直流工作点分析判断工作状态">进行直流工作点分析，判断工作状态</h4><p>用“分析”-“Analyses and simulation”工具中的“直流工作点”分析，得结果如下：</p><table><thead><tr class="header"><th style="text-align: center;">Variable</th><th style="text-align: center;">Operating point value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V(4)-V(5)</td><td style="text-align: center;">6.76596</td></tr><tr class="even"><td style="text-align: center;">V(3)-V(5)</td><td style="text-align: center;">0.618865</td></tr><tr class="odd"><td style="text-align: center;">I(Q1[IB])</td><td style="text-align: center;">6.21E-06</td></tr><tr class="even"><td style="text-align: center;">I(Q1[IC])</td><td style="text-align: center;">0.000967</td></tr><tr class="odd"><td style="text-align: center;">I(Q1[IE])</td><td style="text-align: center;">-0.00097</td></tr></tbody></table><p>则有： <span class="math display">\[V_{be}=V(3)-V(5)=0.618865 \text{V}\\V_{ce}=V(4)-V(5)=6.76596\text{V}\\I_b=6.21\mu\text{A}\\I_c=967\mu\text{A}\\I_e=-970\mu\text{A}\]</span> 可知：管子工作在放大区。</p><h4 id="测量输入电阻">测量输入电阻</h4><p>使用万用表器件，测量电路以及测量结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023548.png" alt="image-20220530205610684" /><figcaption aria-hidden="true">image-20220530205610684</figcaption></figure><p>有结果：</p><table><thead><tr class="header"><th>项目</th><th>值</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(U_i\)</span></td><td>3.794mV</td></tr><tr class="even"><td><span class="math inline">\(I_i\)</span></td><td>1.209μA</td></tr></tbody></table><p>计算： <span class="math display">\[\begin{aligned}R_i&amp;=\frac{U_i}{I_i}\\&amp;=\frac{3.794\times10^{-3}}{1.209\times 10^{-6}}\\[1.5ex]&amp;=3138.13\ \Omega\end{aligned}\]</span> 故输入电阻为<span class="math inline">\(3138.13\Omega\)</span>，此时的频率为<span class="math inline">\(1\text{kHz}\)</span></p><h4 id="测量输出电阻">测量输出电阻</h4><p>为测量输出电阻，将信号源置<span class="math inline">\(0\)</span>，将负载电阻从电路中取出，换成信号源，用电流表测量输出支路电流。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023934.png" alt="image-20220530212159779" /><figcaption aria-hidden="true">image-20220530212159779</figcaption></figure><p>则有： <span class="math display">\[\begin{aligned}R_o&amp;=\frac{U_o}{I_o}\\&amp;=\frac{10\times10^{-3}}{3.922\times10^{-6}}\\[1.5ex]&amp;=2549.71\Omega\end{aligned}\]</span> 所以输出电阻为<span class="math inline">\(2549.71\Omega\)</span></p><h4 id="用测量仪表测定幅频相频曲线">用测量仪表测定幅频、相频曲线</h4><p>如图所示，将波特分析仪连入电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023244.png" alt="image-20220530214705599" /><figcaption aria-hidden="true">image-20220530214705599</figcaption></figure><p>选择“幅值”模式，调整范围：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023987.png" alt="image-20220530214736718" /><figcaption aria-hidden="true">image-20220530214736718</figcaption></figure><p>选择“相位”模式：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023892.png" alt="image-20220530221124547" /><figcaption aria-hidden="true">image-20220530221124547</figcaption></figure><h4 id="用交流分析测幅频相频曲线">用交流分析测幅频、相频曲线</h4><p>用“分析”-“Analyses and simulation”工具中的“交流分析”，如图设置参数：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023217.png" alt="image-20220530221813255" /><figcaption aria-hidden="true">image-20220530221813255</figcaption></figure><p>将输出设置为<span class="math inline">\(V(6)\)</span>，开始分析：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023505.png" alt="image-20220530221847557" /><figcaption aria-hidden="true">image-20220530221847557</figcaption></figure><h4 id="分别在5-个频点利用示波器测出输入和输出的关系并仔细观察放大倍数和相位差">分别在5 个频点利用示波器测出输入和输出的关系，并仔细观察放大倍数和相位差</h4><p>电路连接方式如图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023793.png" alt="image-20220530222634242" /><figcaption aria-hidden="true">image-20220530222634242</figcaption></figure><ol type="1"><li>30Hz</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023036.png" alt="image-20220530231206151" /><figcaption aria-hidden="true">image-20220530231206151</figcaption></figure><p>图中<span class="math inline">\(T_1\)</span>，<span class="math inline">\(T_2\)</span>分别对应输入、输出通道的最大值。由<span class="math inline">\(\Delta \varphi=2\pi f(T_2-T_1)\)</span>可知： <span class="math display">\[   \max V_i=6.620\text{mV} \\   \max V_o=65.526\text{mV} \\   \Delta \varphi=51.132\degree   \]</span></p><ol start="2" type="1"><li><p>1kHz</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140023485.png" alt="image-20220530232304194" /> <span class="math display">\[\max V_i=5.334\text{mV} \\\max V_o=238.006\text{mV} \\\Delta \varphi=168.75\degree\]</span></p></li><li><p>100kHz</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024238.png" alt="image-20220530232540514" /> <span class="math display">\[\max V_i=5.282\text{mV} \\\max V_o=236.081\text{mV} \\\Delta \varphi=181.548\degree\]</span></p></li><li><p>4MHz</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024825.png" alt="image-20220530233003943" /> <span class="math display">\[\max V_i=1.582\text{mV} \\\max V_o=73.091\text{mV} \\\Delta \varphi=180\degree\]</span></p></li><li><p>100MHz</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024862.png" alt="image-20220530233500579" /> <span class="math display">\[\max V_i=193.301\mu\text{V} \\\max V_o=2.919\text{mV} \\\Delta \varphi=258.228\degree\]</span></p></li></ol><p>汇总，得：</p><table><thead><tr class="header"><th>f/Hz</th><th>max <span class="math inline">\(V_i\)</span>/mV</th><th>max<span class="math inline">\(V_o\)</span>/mV</th><th><span class="math inline">\(\Delta \varphi/\degree\)</span></th><th><span class="math inline">\(A\)</span></th></tr></thead><tbody><tr class="odd"><td>30</td><td>6.620</td><td>65.526</td><td>51.132</td><td>9.90</td></tr><tr class="even"><td>1k</td><td>5.334</td><td>238.006</td><td>168.75</td><td>44.62</td></tr><tr class="odd"><td>100k</td><td>5.282</td><td>236.081</td><td>181.548</td><td>44.70</td></tr><tr class="even"><td>4M</td><td>1.582</td><td>73.091</td><td>180</td><td>46.20</td></tr><tr class="odd"><td>100M</td><td>0.193</td><td>2.919</td><td>258.228</td><td>15.12</td></tr></tbody></table><h3 id="最大不失真输出电压的优化">最大不失真输出电压的优化</h3><h4 id="原电路最大不失真输出电压">原电路最大不失真输出电压</h4><p>原电路如图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024492.png" alt="image-20220605152356360" /><figcaption aria-hidden="true">image-20220605152356360</figcaption></figure><p>设置信号源电压为变量<span class="math inline">\(v_i\)</span>，用参数扫描功能，从<span class="math inline">\(5\text{mV}\)</span>到<span class="math inline">\(15\text{mv}\)</span>扫描，用瞬态分析，分析时间设置为一个周期，即<span class="math inline">\(0.001\text{ms}\)</span>，得图形：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024553.png" alt="image-20220605152905709" /><figcaption aria-hidden="true">image-20220605152905709</figcaption></figure><p>可见在约<span class="math inline">\(10\text{mV}\)</span>时出现饱和失真。将信号源设置为<span class="math inline">\(10\text{mV}\)</span>，用示波器分析</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024548.png" alt="image-20220605153150707" /><figcaption aria-hidden="true">image-20220605153150707</figcaption></figure><p>可得最大不失真电压为<span class="math inline">\(4.5\text{mV}\)</span>左右。</p><h4 id="调整电阻后的最大不失真输出电压">调整电阻后的最大不失真输出电压</h4><p>调整<span class="math inline">\(R_1\)</span>,<span class="math inline">\(R_2\)</span>的比值，加入射级电阻，电路及参数扫描结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024772.png" alt="image-20220605151534469" /><figcaption aria-hidden="true">image-20220605151534469</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024184.png" alt="image-20220605151417177" /><figcaption aria-hidden="true">image-20220605151417177</figcaption></figure><p>将信号源设置为<span class="math inline">\(211\text{mV}\)</span>，用示波器分析：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024256.png" alt="image-20220605153340470" /><figcaption aria-hidden="true">image-20220605153340470</figcaption></figure><p>此时输出电压约为<span class="math inline">\(2.2\text{V}\)</span>，比之前的电路提升了487.8倍。</p><h4 id="添加有源负载后的最大不失真电压">添加有源负载后的最大不失真电压</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024661.png" alt="image-20220702230017279" /><figcaption aria-hidden="true">image-20220702230017279</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024407.png" alt="image-20220702230157561" /><figcaption aria-hidden="true">image-20220702230157561</figcaption></figure><p>最大不失真输出电压进一步提高到了<span class="math inline">\(3.13V\)</span>左右。</p><h2 id="射极跟随器分析与设计">射极跟随器分析与设计</h2><h3 id="实验目的-1">实验目的</h3><ol type="1"><li>使用Multisim搭建仿真电路图，测定电路的静态工作点、电压放大倍数、输入电阻、输出电阻、观察静态工作点的变化对输入、输出特性的影响。</li><li>设计有源负载射随器</li><li>了解失真现象</li></ol><h3 id="原始电路图">原始电路图</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140024870.png" alt="image-20220606233327519" /><figcaption aria-hidden="true">image-20220606233327519</figcaption></figure><h3 id="射随器仿真实验">射随器仿真实验</h3><h4 id="进行直流工作点分析判断工作状态-1">进行直流工作点分析，判断工作状态</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025118.png" alt="image-20220606202123233" /><figcaption aria-hidden="true">image-20220606202123233</figcaption></figure><p>结果如下：</p><table><thead><tr class="header"><th>Variable</th><th>Operating point value</th></tr></thead><tbody><tr class="odd"><td>I(Q1[IC])</td><td>0.001601</td></tr><tr class="even"><td>V(3)-V(1)</td><td>0.63146175</td></tr><tr class="odd"><td>V(vcc)-V(1)</td><td>7.89915</td></tr></tbody></table><p>则有： <span class="math display">\[V_{be}=0.631\text{V}\\V_{ce}=7.899\text{V}\\I_c=1.6\text{mA}\]</span> 由此可见，管子工作在放大区。</p><h4 id="测量输入电阻-1">测量输入电阻</h4><p>电路及仿真结果如图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025202.png" alt="image-20220606204235062" /><figcaption aria-hidden="true">image-20220606204235062</figcaption></figure><p>则有： <span class="math display">\[I_i=\frac{u_1}{R_4}=2.5\times10^{-8}\text{A}\\U_i=9.255\text{mV}\\R_i=356.44\text{k}\Omega\]</span></p><h4 id="测量输出电阻-1">测量输出电阻</h4><p>电路及相关测量结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025225.png" alt="image-20220606210346703" /><figcaption aria-hidden="true">image-20220606210346703</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025664.png" alt="image-20220606210415737" /><figcaption aria-hidden="true">image-20220606210415737</figcaption></figure><p>设开关闭合时电压为<span class="math inline">\(V_1\)</span>，开关打开时电压为<span class="math inline">\(V_2\)</span>，有： <span class="math display">\[R_0=\frac{V_2-V_1}{V_1}R_l=17.7\Omega\]</span></p><h4 id="用测量仪表测定幅频相频曲线-1">用测量仪表测定幅频、相频曲线</h4><p>电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025885.png" alt="image-20220606213854747" /><figcaption aria-hidden="true">image-20220606213854747</figcaption></figure><p>测量结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025698.png" alt="image-20220606214506998" /><figcaption aria-hidden="true">image-20220606214506998</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025954.png" alt="image-20220606214610105" /><figcaption aria-hidden="true">image-20220606214610105</figcaption></figure><h4 id="用交流分析测幅频相频曲线-1">用交流分析测幅频、相频曲线</h4><p>结果如图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025598.png" alt="image-20220606215412272" /><figcaption aria-hidden="true">image-20220606215412272</figcaption></figure><h4 id="最大不失真输出电压">最大不失真输出电压</h4><p>由参数扫描得，射随器最大不失真输出电压为<span class="math inline">\(7.158\text{V}\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025557.png" alt="image-20220606231952324" /><figcaption aria-hidden="true">image-20220606231952324</figcaption></figure><h3 id="有源负载射随器仿真实验">有源负载射随器仿真实验</h3><h4 id="直流工作点分析">直流工作点分析</h4><p>电路图和直流工作点分析结果如下，其中绿色部分为镜像电流源负载</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025064.png" alt="image-20220606221933500" /><figcaption aria-hidden="true">image-20220606221933500</figcaption></figure><table><thead><tr class="header"><th>Variable</th><th>Operating point value</th></tr></thead><tbody><tr class="odd"><td>I(Q1[IC])</td><td>0.00160115</td></tr><tr class="even"><td>V(3)-V(1)</td><td>0.63146373</td></tr><tr class="odd"><td>V(vcc)-V(1)</td><td>7.89959</td></tr></tbody></table><p>工作点和上个实验中射随器工作点基本一致。</p><h4 id="测量输入电阻-2">测量输入电阻</h4><p>电路图和相关测量结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025648.png" alt="image-20220606230225977" /><figcaption aria-hidden="true">image-20220606230225977</figcaption></figure><p>有： <span class="math display">\[R_i=\frac{V_S}{V_i-V_s}R_6=429.42\text{kV}\]</span></p><h4 id="测量输出电阻-2">测量输出电阻</h4><p>电路图和相关测量结果如下：<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025729.png" alt="image-20220606225533334" /></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140025237.png" alt="image-20220606225549913" /><figcaption aria-hidden="true">image-20220606225549913</figcaption></figure><p>设开关闭合时电压为<span class="math inline">\(V_1\)</span>，开关打开时电压为<span class="math inline">\(V_2\)</span>，有： <span class="math display">\[R_0=\frac{V_2-V_1}{V_1}R_l=17.7\Omega\]</span></p><h4 id="用测量仪表测定幅频相频曲线-2">用测量仪表测定幅频、相频曲线</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230655603.png" alt="image-20220606230655603" /><figcaption aria-hidden="true">image-20220606230655603</figcaption></figure><p>测量结果如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140026152.png" alt="image-20220606230740927" /><figcaption aria-hidden="true">image-20220606230740927</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140026747.png" alt="image-20220606230803991" /><figcaption aria-hidden="true">image-20220606230803991</figcaption></figure><h4 id="用交流分析测幅频相频曲线-2">用交流分析测幅频、相频曲线</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140026280.png" alt="image-20220606231140129" /><figcaption aria-hidden="true">image-20220606231140129</figcaption></figure><h4 id="最大不失真输出电压-1">最大不失真输出电压</h4><p>由参数扫描得，有源负载射随器最大不失真输出电压为<span class="math inline">\(7.920\text{V}\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140026527.png" alt="image-20220606231847858" /><figcaption aria-hidden="true">image-20220606231847858</figcaption></figure><p>修改电路，再进行参数扫描</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140026369.png" alt="image-20220606232942274" /><figcaption aria-hidden="true">image-20220606232942274</figcaption></figure><p>得最大不失真输出电压为<span class="math inline">\(9.621\text{V}\)</span>,比最初提升了<span class="math inline">\(34.41\%\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202409140026809.png" alt="image-20220606232756093" /><figcaption aria-hidden="true">image-20220606232756093</figcaption></figure><h2 id="感想和体会">感想和体会</h2><p>这部分大家就自己写哈。</p><hr /><p>本次实验涉及到的各个文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E5%85%B1%E5%B0%84%E6%94%BE%E5%A4%A7%E5%99%A8%E5%92%8C%E5%B0%84%E6%9E%81%E8%B7%9F%E9%9A%8F%E5%99%A8.zip">共射放大器和射极跟随器实验下载</a></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理统计重点内容梳理</title>
    <link href="/2022/05/31/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2022/05/31/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>周日就要考了，救命...... 另外，本文只是考试内容，有很多很好玩的内容，如方差分析，逐次回归，正交试验等没有涉及。</p><span id="more"></span><p>@[toc]</p><h2 id="估计">估计</h2><h3 id="umvue一致最小方差无偏估计">UMVUE一致最小方差无偏估计</h3><p><strong>定义（一致最小方差无偏估计）</strong> ：设<span class="math inline">\(U_q\)</span>表示参数<span class="math inline">\(q(\theta)\)</span>所有的方差有限的估计组成的集合，如果存在无偏估计<span class="math inline">\(T*(\mathbf{x})\)</span>，使得： <span class="math display">\[Var_\theta(T^*(x))\leq Var_\theta(T(x))\]</span> 对任何<span class="math inline">\(\theta\)</span>,任何<span class="math inline">\(T(x)\in U_q\)</span>成立，那么<span class="math inline">\(T^*(x)\)</span>就是一致最小方差无偏估计。</p><p>一般来说，我们可以用完全充分统计量的方法来寻找一致最小方差无偏估计。首先看几个概念：</p><p><strong>定义（统计量）</strong> :<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是来自总体<span class="math inline">\(X\)</span>的样本，那么仅和<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>有关的函数<span class="math inline">\(T(x_1,\cdots,x_n)\)</span>就是一个 <strong>统计量</strong></p><p><strong>定义（充分统计量）</strong> :设总体分布族为<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>,<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是来自总体<span class="math inline">\(X\)</span>的样本，<span class="math inline">\(T\)</span>是统计量。如果给定<span class="math inline">\(T=t\)</span>，样本的条件分布函数<span class="math inline">\(F_\theta(\{x\}|t)\)</span>和参数<span class="math inline">\(\theta\)</span>无关，那么称<span class="math inline">\(T\)</span>是充分统计量。</p><p><strong>定理（因子分解定理）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，统计量<span class="math inline">\(T\)</span>充分，等价于：存在一个定义在<span class="math inline">\(I\times\Theta\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="$I$是$T(x)$的值域，$\Theta$是$\theta$的值域">[2]</span></a></sup>上的实函数<span class="math inline">\(g(t,\theta)\)</span>，和定义在样本空间上的不依赖于参数<span class="math inline">\(\theta\)</span>的实函数<span class="math inline">\(h(x)\)</span>，使得对于样本的联合分布有： <span class="math display">\[p(x;\theta)=g(T(x),\theta)\cdot h(x)\]</span> 对样本空间上的每一个<span class="math inline">\(x\)</span>都成立。</p><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自泊松总体的<span class="math inline">\(n\)</span>个样本，求充分统计量。</p><p>【解】联合分布： <span class="math display">\[p(\{x\};\lambda)=\frac{e^{-n\lambda} } {x_1!x_2!\cdots x_n!}\lambda^{\sum_{i=1}^nx_i}\]</span> 取 <span class="math display">\[T=\sum x_i,g(T,\lambda)=e^{-n\lambda}\lambda^T,h(x)=\frac 1{x_1!x_2!\cdots x_n!}\]</span> 有 <span class="math display">\[p(\{x\};\lambda)=g(T,\lambda)h(x)\]</span> 则<span class="math inline">\(T=\sum x_i\)</span>是充分统计量。</p></blockquote><p><strong>定义*（完全统计量）</strong> ：对于总体<span class="math inline">\(X\)</span>的分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，<span class="math inline">\(g(X)\)</span>是随机变量，如果有：“对一切<span class="math inline">\(\theta\)</span>，<span class="math inline">\(E_\theta[g(x)]=0 \to P_\theta[g(x)=0]=1\)</span>”，则称这个分布族是完全分布族。如果统计量<span class="math inline">\(T\)</span>的分布族是完全的，那么<span class="math inline">\(T\)</span>就是完全统计量。</p><p><strong>定理（充分性定理）</strong> ：设<span class="math inline">\(\{x\}\)</span>是来自总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>的<span class="math inline">\(n\)</span>个简单样本，如果联合密度函数（联合分布列）可以分解为： <span class="math display">\[p(\{x\},\theta)=c(\theta)h(\{x\})\exp\left\{ \sum_{k=1}^mw_k(\theta)T_k(\{x\}) \right\}\]</span> 其中：</p><ul><li><span class="math inline">\(h(\{x\})\)</span>仅是<span class="math inline">\(x_1,\cdots,x_n\)</span>的函数</li><li><span class="math inline">\(w=[w_1(\theta),\cdots,w_k(\theta)]\)</span>是定义在<span class="math inline">\(\Theta^m\)</span>空间上的取值为<span class="math inline">\(A\subset{\mathbb R}^m\)</span>的向量函数</li><li><span class="math inline">\(c(\theta)\)</span>仅是<span class="math inline">\(\theta\)</span>的函数</li></ul><p>如果<span class="math inline">\(A\)</span>包含内点，那么<span class="math inline">\(T_1,\cdots,T_m\)</span>都是完全充分的。</p><blockquote><p>【例】设<span class="math inline">\(\{x\}\)</span>是来自二项分布<span class="math inline">\(B(1,\theta)\)</span><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="$B(n,p)$表示重复$n$次试验，每次试验成功的概率为$p$，成功的试验数目。这里实际上退化成了两点分布。">[3]</span></a></sup>总体的<span class="math inline">\(n\)</span>个简单样本，求<span class="math inline">\(\theta\)</span>的完全充分统计量。</p><p>【解】联合分布列： <span class="math display">\[\begin{aligned}p(\{x\};\theta)&amp;=\prod_{i=1}^n \theta^{x_i}(1-\theta)^{1-x_i}\\\\&amp;=(1-\theta)^n\exp\left\{ \ln\frac{\theta} {1-\theta}\sum_{i=1}^n x_i \right\}\end{aligned}\]</span> 取：</p><ul><li><span class="math inline">\(w=\ln\frac{\theta} {1-\theta}\)</span>，<span class="math inline">\(m=1\)</span></li><li><span class="math inline">\(c(\theta)=(1-\theta)^n\)</span></li><li><span class="math inline">\(h(\{x\})=1\)</span></li><li><span class="math inline">\(T=\sum x_i\)</span></li></ul><p>则<span class="math inline">\(T\)</span>是完全充分统计量。</p></blockquote><p><strong>定理（Lehmann-Scheffe定理）</strong>： 设<span class="math inline">\(S(x)\)</span>是完全充分统计量，<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(q(\theta)\)</span>的方差有限的无偏估计，则 <span class="math display">\[T(x)=E_\theta[\varphi(x)|S(x)]\]</span> 是<span class="math inline">\(q(\theta)\)</span>的一致最小方差无偏估计。</p><p>Lehmann-Scheffe定理实际上提供了两种根据完全充分统计量<span class="math inline">\(S(x)\)</span>寻求<span class="math inline">\(q(\theta)\)</span>的UMVUE的路径：</p><ol type="1"><li><p>如果能获得<span class="math inline">\(q(\theta)\)</span>的无偏估计<span class="math inline">\(\varphi(x)\)</span>，那么直接按照公式计算即可。</p><blockquote><p>【例】设<span class="math inline">\(\{x\}\)</span>是来自泊松总体的<span class="math inline">\(n\)</span>个简单样本，求<span class="math inline">\(q(\lambda)=e^{-\lambda}\)</span>的UMVUE。</p><p>【解】泊松分布列为： <span class="math display">\[p(x;\lambda)=\frac{\lambda^x} {x!}e^{-\lambda}=e^{-\lambda}\frac 1{x!}\exp(\ln (\lambda) x)\ \ x=0,1,2,\cdots\]</span> 则联合分布列的分解： <span class="math display">\[p(\{x\};\theta)=e^{-n\lambda}\prod_{i=1}^n\frac{1} {x_i!}\exp(\ln \lambda \sum_{i=1}^n x_i)\]</span> 取：</p><ul><li><span class="math inline">\(S(x)=\sum x_i\)</span></li><li><span class="math inline">\(w(\lambda)=\ln \lambda\)</span>,<span class="math inline">\(m=1\)</span></li><li><span class="math inline">\(c(\lambda)=e^{-n\lambda}\)</span></li><li><span class="math inline">\(h=\prod \frac{1} {x_i!}\)</span></li></ul><p>则<span class="math inline">\(S\)</span>是完全充分统计量。</p><p>接下来寻找<span class="math inline">\(q(\lambda)\)</span>的无偏估计。取 <span class="math display">\[\varphi(x)=I_{x_1=0}(x_1,\cdots,x_n)\]</span> 其中<span class="math inline">\(I\)</span>是指示函数<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="指示函数$I_a()$：当条件$a$为真时为$1$，反之为$0$.">[4]</span></a></sup>.</p><p>则： <span class="math display">\[E_\lambda[\varphi(x)]=P[x_1=0]=e^{-n\lambda}\]</span> 故<span class="math inline">\(\varphi\)</span>是<span class="math inline">\(q(\lambda)\)</span>的无偏估计。则有： <span class="math display">\[T=E[\varphi|S(x)=s]\]</span> 则有： <span class="math display">\[T=\frac{P[x_1=0]P[\sum_{k=2}^nx_k=s]} {P[\sum_{k=1}^nx_k=s]}\]</span> 由于泊松分布的和是泊松分布，<span class="math inline">\(\lambda\)</span>参数求和，则： <span class="math display">\[T=\left(\frac{n-1} {n}\right)^{\sum x_i}\]</span></p></blockquote></li><li><p>由于<span class="math inline">\(T(x)\)</span>一定是<span class="math inline">\(S(x)\)</span>的函数，因此如果能获取<span class="math inline">\(S(x)\)</span>的函数<span class="math inline">\(h(S(x))\)</span>，并将其无偏化，则可以获得UMVUE。</p><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>个简单样本，其中<span class="math inline">\(\mu\)</span>是已知量，求<span class="math inline">\(\sigma^2\)</span>的UMVUE。</p><p>【解】样本的联合密度函数为： <span class="math display">\[p(\{x\};\sigma^2)=(2\pi\sigma^2)^{-\frac{n} {2} }\exp\left\{-\frac{1} {2\sigma^2}\sum_{i=1}^{n}(x_i-\mu)^2 \right\}\]</span> 取：</p><ul><li><span class="math inline">\(c(\sigma^2)=(2\pi\sigma^2)^{-\frac n2}\)</span></li><li><span class="math inline">\(h(\{x\})=1\)</span></li><li><span class="math inline">\(w(\sigma^2)=-\frac{1} {2\sigma^2},m=1\)</span></li><li><span class="math inline">\(S(x)=\sum(x_i-\mu)^2\)</span></li></ul><p>则<span class="math inline">\(S(x)\)</span>是完全充分统计量。由于 <span class="math display">\[E[S(x)]=E\left[\sum(x_i-\mu)^2\right]=n\sigma^2\]</span> 则： <span class="math display">\[E\left[\frac{1} {n}S(x)\right]=\sigma^2\]</span> 于是<span class="math inline">\(S/n\)</span>既是待估计量的无偏估计，也是完全充分统计量<span class="math inline">\(S\)</span>的函数，因此 <span class="math display">\[\frac Sn=\frac 1n \sum_{i=1}^n(x_i-\mu)^2\]</span> 是待估计量的UMVUE。</p></blockquote></li></ol><h3 id="有效估计">有效估计</h3><h3 id="矩估计">矩估计</h3><p>矩估计法的思想是基于替换原理，用样本矩替换相应的总体矩，进而求出某些待估计参数的过程。</p><p>其中的样本矩的意思是根据<span class="math inline">\(n\)</span>次抽样算出来的矩，比如说抽样<span class="math inline">\(n\)</span>次的样本是<span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span>，那么<span class="math inline">\(k\)</span>阶样本原点矩就是 <span class="math display">\[A_k=\frac 1n\sum_{i=1}^n x_i^k\]</span> 而总体矩的意思是将待估计参数代入分布的理论形式中，通过理论分析计算期望而得出的矩。假如待估计参数是<span class="math inline">\(\theta\)</span>,那么<span class="math inline">\(k\)</span>阶总体原点矩是 <span class="math display">\[\mu_k=E_\theta[X^k]\]</span> 求矩估计的一般步骤是：将待估计的参数<span class="math inline">\(q(\theta)\)</span>表示成各阶总体矩<span class="math inline">\(\mu_k\)</span>的函数,然后用样本矩替换总体矩，就可以获得矩估计。</p><blockquote><p>【例】总体<span class="math inline">\(X\)</span>服从<span class="math inline">\([a,b]\)</span>上的均匀分布，也就是说，其概率密度函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="$p(x;a,b)$的含义是：该函数以$x$为自变量，有两个参数$a$和$b$">[1]</span></a></sup>为： <span class="math display">\[p(x;a,b)=\begin{cases}\frac{1} {b-a} &amp;x\in[a,b]\\\\0 &amp;\text{others}\end{cases}\]</span> <span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span>是总体<span class="math inline">\(X\)</span>的简单抽样样本。求<span class="math inline">\(a,b\)</span>的矩估计。</p><p>【解】设<span class="math inline">\(\mu_1=E[x],v_2=D[x]\)</span>,有： <span class="math display">\[\begin{cases}\mu_1=\frac{1} {2}(a+b)\\\\[2ex]v_2=\frac{1} {12}(b-a)^2\\\\[2ex]\end{cases}\]</span> 解方程，可得： <span class="math display">\[a=\mu_1-\sqrt{3v_2}\\\\b=\mu_1+\sqrt{3v_2}\]</span> 用样本均值替换总体均值，用样本方差替换二阶中心矩，有： <span class="math display">\[\mu_1 \to \bar{x}\\\\v_2 \to \frac{1} {n}\sum_{i=1}^n(x_i-\bar{x})^2\]</span> 则可得<span class="math inline">\(a,b\)</span>的矩估计： <span class="math display">\[a=\bar{x}-\sqrt{\frac 3n\sum_{i=1}^n(x_i-\bar{x})^2}\\\\b=\bar{x}+\sqrt{\frac 3n\sum_{i=1}^n(x_i-\bar{x})^2}\]</span></p></blockquote><h3 id="极大似然估计">极大似然估计</h3><p>极大似然估计的思想是：如果在一次试验中产生了一个结果，那么一般认为试验条件对这个结果的发生有利，也就是这个结果发生的概率最大。</p><p>一般步骤是：先求出一个似然函数<span class="math inline">\(L(\theta;x_1,x_2,\cdots,x_n)\)</span>，它以待估计量<span class="math inline">\(\theta\)</span>为自变量，以试验结果为参数，它的含义是当前试验结果出现的概率。然后通过将<span class="math inline">\(L\)</span>(因为概率往往是乘积形式，有时我们也用<span class="math inline">\(\ln L\)</span>)对<span class="math inline">\(\theta\)</span>求偏导的方法，得出<span class="math inline">\(L\)</span>取得上界时<span class="math inline">\(\theta\)</span>的值，并将其作为估计结果。</p><blockquote><p>【例】总体<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.其中<span class="math inline">\(\mu,\sigma^2\)</span>的参数空间为<span class="math inline">\(\mu\in{\mathbb R},\sigma^2&gt;0\)</span>，<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是简单样本，求<span class="math inline">\(\mu,\sigma^2\)</span>的极大似然估计。</p><p>【解】总体的密度函数为： <span class="math display">\[p(x;\mu,\sigma^2)=\frac{1} {\sqrt{2\pi\sigma^2} }\exp(\frac{-(x-\mu)^2} {2\sigma^2})\]</span> 则有“似然函数”： <span class="math display">\[\begin{aligned}L(\mu,\sigma^2;x_1,\cdots,x_n)=\prod_{i=1}^np(x_1;\mu,\sigma^2)\end{aligned}\]</span> 则 <span class="math display">\[\ln L=-\frac n2\ln(2\pi)-\frac n2 \ln(\sigma^2)-\frac 1{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\]</span> 分别对<span class="math inline">\(\mu,\sigma^2\)</span>求导，得： <span class="math display">\[\begin{cases}\frac{\partial \ln L} {\partial \mu}=\frac{1} {\sigma^2}\sum_{i=1}^n(x_i-\mu)=0\\\\\frac{\partial \ln L} {\partial \sigma^2}=-\frac n{2\sigma^2}+\frac 1{2(\sigma^2)^2}\sum_{i=1}^n(x_i-\mu)=0\end{cases}\]</span> 解得： <span class="math display">\[\mu=\bar{x}\\\\\sigma^2=\frac 1n \sum(x_i-\bar{x})^2\]</span></p></blockquote><h3 id="区间估计定义">区间估计（定义）</h3><p><strong>定义（区间估计）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，如果存在两个统计量<span class="math inline">\(T_1(x),T_2(x)\)</span>，对于给定的<span class="math inline">\(\alpha\)</span>，有： <span class="math display">\[P\left\{\theta\in [T_1(x),T_2(x)]\right\}\geq 1-\alpha\]</span> 对任意<span class="math inline">\(\theta\)</span>都成立，称<span class="math inline">\([T_1,T_2]\)</span>是参数<span class="math inline">\(\theta\)</span>置信度为<span class="math inline">\(1-\alpha\)</span>的区间估计。</p><p>区间估计的含义是，假设做<span class="math inline">\(m\)</span>组重复试验，每组抽取<span class="math inline">\(n\)</span>个样本，这样就可以得到<span class="math inline">\(m\)</span>个区间<span class="math inline">\([T_1,T_2]\)</span>。在这<span class="math inline">\(m\)</span>个区间中，大约有<span class="math inline">\(100(1-\alpha)\%\)</span>包含<span class="math inline">\(\theta\)</span>的真值。我们不能说<span class="math inline">\(\theta\)</span>落入区间<span class="math inline">\([T_1,T_2]\)</span>的概率是<span class="math inline">\(1-\alpha\)</span>，这是因为<span class="math inline">\(\theta\)</span>的真值是一个客观存在的不变量。</p><h3 id="minimax估计">Minimax估计</h3><p><strong>定义（Minimax估计）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，<span class="math inline">\(G_q\)</span>是由待估参数<span class="math inline">\(q(\theta)\)</span>的估计量（决策函数）<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="决策函数的自变量是样本$\{x\}$，因变量是对待估计量的估计">[5]</span></a></sup>组成的集合，如果存在<span class="math inline">\(T^*\in G_q\)</span>，有： <span class="math display">\[\sup_{\theta\in\Theta}R(\theta,T^*)\leq\sup_{\theta\in\Theta}R(\theta,T)\]</span> 对任意<span class="math inline">\(T\in G_q\)</span>成立，则称<span class="math inline">\(T^*\)</span>是Minimax估计。其中<span class="math inline">\(R(\theta,T)\)</span>是风险函数，定义如下： <span class="math display">\[R(\theta,T)=E_\theta[L(\theta,T(x))]\]</span> 其中<span class="math inline">\(L(\theta,T)\)</span>是损失函数，意思是当待估计量是<span class="math inline">\(\theta\)</span>，然后你估计它为<span class="math inline">\(T(x)\)</span>时产生的损失。</p><blockquote><p>【例】总体服从两点分布<span class="math inline">\(B(1,p)\)</span>，<span class="math inline">\(p \in \{\frac 14,\frac12\}\)</span>，损失函数如下表所示，求<span class="math inline">\(p\)</span>的Minimax估计。</p><table><thead><tr class="header"><th><span class="math inline">\(p\)</span></th><th><span class="math inline">\(a_1=1/4\)</span></th><th><span class="math inline">\(a_2=1/2\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(p_1=1/4\)</span></td><td>1</td><td>4</td></tr><tr class="even"><td><span class="math inline">\(p_2=1/2\)</span></td><td>3</td><td>2</td></tr></tbody></table><p>【解】仅仅取1个观察值，那么总共有4种决策函数：</p><ol type="1"><li><p><code>T1=1/4</code></p></li><li><p><code>T2=(x==0)?1/4:1/2</code></p></li><li><p><code>T3=(x==0)?1/2:1/4</code></p></li><li><p><code>T4=1/2</code></p><p>响应的风险表如下：</p><table><thead><tr class="header"><th><span class="math inline">\(T_i\)</span></th><th><span class="math inline">\(R(p_1,T_i)\)</span></th><th><span class="math inline">\(R(p_2,T_i)\)</span></th><th><span class="math inline">\(\max R\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>3</td><td>3</td></tr><tr class="even"><td>2</td><td>7/4</td><td>5/2</td><td>5/2</td></tr><tr class="odd"><td>3</td><td>13/4</td><td>5/2</td><td>13/4</td></tr><tr class="even"><td>4</td><td>4</td><td>2</td><td>4</td></tr></tbody></table><p>例如，我们求<span class="math inline">\(R(p_2,T_2)\)</span>: <span class="math display">\[\begin{aligned}R(p_2,T_2)&amp;=E_{p_2}[L(p_2,T_2)]\\\\&amp;=P_{p_2}\{x=0\}L(p_2,1/4)+P_{p_2}\{x=1\}L(p_2,1/2)\\\\&amp;=\frac 12\times 3+\frac 12 \times 2\\\\&amp;=\frac 52\end{aligned}\]</span> 在第四列中选取最小的，所以应该选<span class="math inline">\(T_2\)</span>。</p></li></ol></blockquote><h2 id="假设检验">假设检验</h2><h3 id="结合实际问题的假设检验">结合实际问题的假设检验</h3><p>对于正态总体而言，有：</p><ol type="1"><li><p>单个方差已知时总体均值的检验 <span class="math display">\[H_0:\mu=\mu_0\ \ H_1:\mu\neq\mu_0\]</span> 检验统计量为： <span class="math display">\[z=\frac{\bar{x}-\mu_0} {\sigma/\sqrt{n} }\sim N(0,1)\]</span> 这种检验方法叫做“<span class="math inline">\(z\)</span>检验”</p><p>拒绝域为： <span class="math display">\[W=\{|z|\geq z_{1-\frac\alpha 2}\}\]</span></p></li><li><p>单个方差未知时总体均值的检验 <span class="math display">\[H_0:\mu=\mu_0\ \ H_1:\mu\neq\mu_0\]</span> 检验统计量： <span class="math display">\[t=\frac{\bar{x}-\mu_0} {S/\sqrt{n} }\sim t(n-1)\]</span> 这种检验方式叫做<span class="math inline">\(t\)</span>检验。</p><p>拒绝域： <span class="math display">\[W=\left\{\frac{\bar{x}-\mu_0} {S/\sqrt{n} }\geq t_{1-\frac \alpha2}(n-1)\right\}\]</span></p></li><li><p>单个均值未知时方差的检验 <span class="math display">\[H_0:\sigma^2=\sigma_0^2\]</span> 检验统计量： <span class="math display">\[\chi^2=\frac{(n-1)S^2} {\sigma_0^2} \sim \chi^2(n-1)\]</span> 拒绝域： <span class="math display">\[W=\{\chi^2\leq\chi^2_{\frac \alpha2}(n-1)\}\cup \{\chi^2\geq\chi_{1-\frac \alpha2}^2(n-1)\}\]</span></p></li><li><p>单个均值已知时方差的检验 <span class="math display">\[H_0:\sigma^2=\sigma_0^2\]</span> 检验统计量： <span class="math display">\[\chi^2=\frac 1{\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\sim\chi^2(n)\]</span> 拒绝域: <span class="math display">\[W=\{\chi^2\leq\chi^2_{\frac \alpha2}(n)\}\cup \{\chi^2\geq\chi_{1-\frac \alpha2}^2(n)\}\]</span></p></li><li><p>两个总体均值相等的检验</p><ol type="1"><li><p>两个方差<span class="math inline">\(\sigma_1,\sigma_2\)</span>已知</p><p>检验统计量： <span class="math display">\[z=\frac{\bar{x}-\bar{y} } {\sqrt{\frac{\sigma_1^2} {n_1}+\frac{\sigma^2_2} {n_2} }}\]</span></p><p>拒绝域： <span class="math display">\[W=\{|z|\geq z_{1-\frac\alpha 2}\}\]</span></p></li><li><p>两个方差未知但相等</p><p>检验统计量： <span class="math display">\[S^2_w=\frac{(n_1-1)S^2_1+(n_2-1)S_2^2} {n_1+n_2-2}\\\\t=\frac{\bar{x}-\bar{y} } {S_w\sqrt{\frac 1{n_1}+\frac1{n_2} }}\sim t(n_1+n_2-2)\]</span> 拒绝域 <span class="math display">\[W=\{|t|\geq t_{1-\frac \alpha2}(n_1+n_2-2)\}\]</span></p></li><li><p>方差情况未知但样本数相等</p><p>检验统计量 <span class="math display">\[z_i=x_i-y_i\\\\t=\frac{\bar{z} } {S_z/\sqrt{n} }\sim t(n-1)\]</span> 拒绝域 <span class="math display">\[W=\{|t|\geq t_{1-\frac \alpha2}(n-1)\}\]</span></p></li></ol></li></ol><h3 id="umpt一致最优势检验">UMPT一致最优势检验</h3><p>首先我们明确几个概念</p><p><strong>定义（检验函数）</strong> 检验函数<span class="math inline">\(\varphi(x)\)</span>一般定义如下： <span class="math display">\[\varphi(x)=I_{x\in W}(x)\]</span> 也就是拒绝域上的示性函数，即： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;x\in W\\\\0, &amp;\text{others}\end{cases}\]</span> 当检验函数为1时，选择拒绝<span class="math inline">\(H_0\)</span>。这样的检验函数叫非随机化检验函数。如果得到样本<span class="math inline">\(x\)</span>后，以概率<span class="math inline">\(\varphi(x)\)</span>，这就是随机化检验函数。</p><p><strong>定义（检验的势函数）</strong> 样本观测值落入拒绝域的概率称为势函数<span class="math inline">\(g(\theta)\)</span>.</p><p><strong>定义（检验的水平）</strong> 对于给定的<span class="math inline">\(\alpha\in[0,1]\)</span>,如果检验<span class="math inline">\(\varphi(x)\)</span>对所有<span class="math inline">\(\theta\in\Theta_0\)</span>满足<span class="math inline">\(E_{\theta}[\varphi(x)]\leq\alpha\)</span>，称<span class="math inline">\(\varphi(x)\)</span>的水平是<span class="math inline">\(\alpha\)</span></p><p>一个自然的比较检验的优劣的方式是：在相同的检验水平<span class="math inline">\(\alpha\)</span>下，如果 <span class="math display">\[E_{\theta_1}[\varphi_1(x)]\geq E_{\theta_1}[\varphi_2(x)]\]</span> 那么就说<span class="math inline">\(\varphi_1\)</span>比较好。</p><p><strong>定理（N-P引理）</strong> 对于假设检验问题： <span class="math display">\[H_0:\theta= \theta_0\ \ \ H_1:\theta=\theta_1\]</span> 以及给定检验水平<span class="math inline">\(\alpha\)</span>,有：</p><ol type="1"><li><p>存在非负常数<span class="math inline">\(k\)</span>，检验 <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;L(x)\geq k\\\\1, &amp;L(x)&lt; k\\\\\end{cases}\]</span> 满足 <span class="math display">\[E_{\theta_0}[\varphi(x)]=\alpha\]</span> 而且检验函数<span class="math inline">\(\varphi(x)\)</span>是水平为<span class="math inline">\(\alpha\)</span>的最优势检验。其中<span class="math inline">\(L(x)\)</span>是似然比统计量： <span class="math display">\[L(x)=\frac{p(x;\theta_1)} {p(x;\theta_0)}\]</span></p></li><li><p>如果检验函数<span class="math inline">\(\varphi(x)\)</span>是水平为<span class="math inline">\(\alpha\)</span>的最优势检验，那么一定存在非负常数<span class="math inline">\(k\)</span>，使得<span class="math inline">\(\varphi(x)\)</span>满足（1）的第一个式子，如果有<span class="math inline">\(E_{\theta_1}[\varphi(x)]\leq 1\)</span>，那么第二个式子也满足。</p></li></ol><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自正态总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>维简单随机样本，<span class="math inline">\(\mu\geq 0,\sigma\)</span>已知。对于假设： <span class="math display">\[H_0:\mu=0\ \ H_1:\mu=\mu_1&gt;0\]</span> 求水平为<span class="math inline">\(\alpha\)</span>的最优势检验。</p><p>【解】检验函数具有如下形式： <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;L(x)\geq k\\\\1, &amp;L(x)&lt; k\\\\\end{cases}\]</span> 其中<span class="math inline">\(L(x)\)</span>满足： <span class="math display">\[\begin{aligned}L(x)&amp;=\frac{p(x;\mu_1)} {p(x;0)}\\\\&amp;=\exp\left\{\frac{n\mu_1\bar{x} } {\sigma^2}-\frac{n\mu_1^2} {2\sigma^2}\right\}\end{aligned}\]</span> <span class="math inline">\(k\)</span>由 <span class="math display">\[E_{\mu=0}[\varphi(x)]=P_{\mu=0}\{L(x)\geq k\}=\alpha\]</span> 确定。</p><p>由于<span class="math inline">\(L(x)\)</span>随<span class="math inline">\(\bar{x}\)</span>单增，因此 <span class="math display">\[\{x|L(x)\geq k\}=\{x|\bar{x}\geq c\}\]</span> 对于给定的<span class="math inline">\(\alpha\)</span>，有： <span class="math display">\[P_{\mu=0}\{L(x)\geq k\}=P_{\mu=0}\{\bar{x}\geq c\}=1-\Phi\left(\frac{c} {\sigma/\sqrt{n} }\right)=\alpha\]</span> 得<span class="math inline">\(c=\sigma z_{1-\alpha}/\sqrt{n}\)</span></p><p>则检验函数： <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;\bar(x)\geq c\\\\1, &amp;\bar(x)&lt; c\\\\\end{cases}\]</span></p></blockquote><p><strong>定义（一致最优势检验）</strong> 如果检验问题是： <span class="math display">\[H_0:\theta\in \Theta_0\ \ \ H_1:\theta\in\Theta_1\]</span> 对于<span class="math inline">\(\Theta_0\)</span>中的每个<span class="math inline">\(\theta\)</span>，<span class="math inline">\(\varphi\)</span>都是最优势检验，那么<span class="math inline">\(\varphi\)</span>称为一致最优势检验。</p><p><strong>定理（UMPT的确定） </strong> 对于单参数的密度函数（分布列）<span class="math inline">\(p(x;\theta)\)</span>，如果可以表示为： <span class="math display">\[p(x;\theta)=d(\theta)h(x)\exp\{c(\theta)T(x)\}\]</span> 其中<span class="math inline">\(c(\theta)\)</span>严格单增，那么对于检验问题： <span class="math display">\[H_0:\theta\leq \theta_0\ \ H_1:\theta&gt;\theta_0\]</span></p><ol type="1"><li><p>水平为<span class="math inline">\(\alpha\)</span>的UMPT存在，为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;T(x)&gt; c\\\\r, &amp;T(x)=c\\\\0, &amp;T(x)&lt; c\\\\\end{cases}\]</span> 常数<span class="math inline">\(c,r\)</span>由<span class="math inline">\(E_{\theta_0}[\varphi(x)]=\alpha\)</span>确定。</p></li><li><p>势函数<span class="math inline">\(g(\theta)=E_{\theta}[\varphi(x)]\)</span>单增。</p></li></ol><p>注解：</p><ol type="1"><li><p>如果<span class="math inline">\(c(\theta)\)</span>单减，结论仍然成立，只需将检验函数中的不等号调换。</p></li><li><p>对于检验问题： <span class="math display">\[H_0:\theta=\theta_0\ \ H_1:\theta&gt;\theta_0\]</span> 结论完全照原样成立。</p></li><li><p>对于检验问题 <span class="math display">\[H_0:\theta\geq \theta_0\ \ H_1:\theta&lt;\theta_0\]</span> 只需取<span class="math inline">\(\theta&#39;=-\theta\)</span>即可。</p></li></ol><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自正态总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>维简单随机样本，<span class="math inline">\(\mu\)</span>已知，<span class="math inline">\(\sigma^2\)</span>未知，求检验： <span class="math display">\[H_0:\sigma^2\leq \sigma_0^2\ \ H_1:\sigma^2&gt;\sigma_0^2\]</span> 的UMPT。</p><p>【解】对于联合密度函数，有： <span class="math display">\[p(x;\theta)=\left(\frac{1} {\sqrt{2\pi\sigma^2} }\right)^n\exp\left\{-\frac{1} {2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\right\}\]</span> 其中：</p><ol type="1"><li><span class="math inline">\(d(\sigma^2)=\left(\frac{1} {\sqrt{2\pi\sigma^2} }\right)^n\)</span></li><li><span class="math inline">\(h(x)=1\)</span></li><li><span class="math inline">\(c(\sigma^2)=-\frac{1} {2\sigma^2}\)</span></li><li><span class="math inline">\(T(x)=\sum_{i=1}^n(x_i-\mu)^2\)</span></li></ol><p>则UMPT存在，为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;T(x)\geq c\\\\0, &amp;T(x)&lt; c\\\\\end{cases}\]</span> 由 <span class="math display">\[E_{\sigma^2}[\varphi(x)]=P_{\sigma_0^2}\left\{\frac{1} {\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\geq\frac{c} {\sigma_0^2} \right\}=\alpha\]</span> 其中 <span class="math display">\[\frac{1} {\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\sim \chi^2(n)\]</span> 故 <span class="math display">\[c=\sigma_0^2\chi^2_{1-\alpha}(n)\]</span> 综上所述，UMPT为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;\sum_{i=1}^n(x_i-\mu)^2\geq \sigma_0^2\chi^2_{1-\alpha}(n)\\\\0, &amp;\sum_{i=1}^n(x_i-\mu)^2&lt; \sigma_0^2\chi^2_{1-\alpha}(n)\\\\\end{cases}\]</span></p></blockquote><h2 id="分布">分布</h2><p>由正态分布导出的三大分布：</p><h3 id="chi2分布"><span class="math inline">\(\chi^2\)</span>分布</h3><p>设<span class="math inline">\(X_1\cdots X_n\)</span>是服从<span class="math inline">\(N(0,1)\)</span>的随机变量，而且互相独立，则 <span class="math display">\[\sum_{i=1}^nX_i^2 \sim \chi^2(n)\]</span> 叫做：服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(\chi^2\)</span>分布。</p><h3 id="t分布"><span class="math inline">\(t\)</span>分布</h3><p>设<span class="math inline">\(X\sim N(0,1),Y\sim\chi^2(n)\)</span>，而且相互独立，则 <span class="math display">\[\frac{X} {\sqrt{Y/n} }\sim t(n)\]</span> 叫做：服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(t\)</span>分布，也叫学生分布。</p><h3 id="f分布"><span class="math inline">\(F\)</span>分布</h3><p>设<span class="math inline">\(X\sim \chi^2(n_1),Y\sim\chi^2(n_2)\)</span>，而且相互独立，则 <span class="math display">\[\frac{X/n_1} {Y/n_2}\sim F(n_1,n_2)\]</span></p><h3 id="分位数">分位数</h3><p>对于随机变量<span class="math inline">\(X\)</span>的分布函数<span class="math inline">\(F(x)\)</span>，给定实数<span class="math inline">\(p\in[0,1]\)</span>，若： <span class="math display">\[p\{X\leq x_p\}=F(x_p)=p\]</span> 称<span class="math inline">\(x_p\)</span>是此概率分布的<span class="math inline">\(p\)</span>分位数。</p><h2 id="线性回归">线性回归</h2><p>证明：<span class="math inline">\(e=Y-\hat{Y}\)</span>和<span class="math inline">\(\hat{\beta}=(X&#39;X)^{-1}X&#39;Y\)</span>不相关。</p><p>证明：<span class="math inline">\(e=[I_n-X(X&#39;X)^{-1}X&#39;]Y\)</span></p><p>由 <span class="math display">\[Cov(Ax,By)=ACov(x,y)B&#39;\]</span> 得： <span class="math display">\[\begin{aligned}Cov(e,\hat{\beta})&amp;=Cov([I_n-X(X&#39;X)^{-1}X&#39;]Y,(X&#39;X)^{-1}X&#39;Y)\\\\&amp;=[I_n-X(X&#39;X)^{-1}X&#39;]D[Y][(X&#39;X)^{-1}X&#39;]&#39;\\\\&amp;=\sigma^2[I_n-X(X&#39;X)^{-1}X&#39;][(X&#39;X)^{-1}X&#39;]&#39;\\\\&amp;=\sigma^2[(X&#39;X)^{-1}X]-[X(X&#39;X)^{-1}(X&#39;(X&#39;X)^{-1}X)]\\\\&amp;=\sigma^2[(X&#39;X)^{-1}X-X(X&#39;X)^{-1}]\\\\&amp;=0\end{aligned}\]</span></p><h2 id="主成分分析">主成分分析</h2><p>设总体<span class="math inline">\(\boldsymbol{x}=(x_1,x_2,\cdots,x_p)&#39;\)</span>是<span class="math inline">\(p\)</span>元总体，<span class="math inline">\(E[\boldsymbol{x}]=\boldsymbol{\mu},Var(\boldsymbol{x})=\boldsymbol{\Sigma}=(\sigma_{ij})\)</span>。我们的目标是把这<span class="math inline">\(p\)</span>个指标综合成少数几个指标，也就是所谓的主成分。要求这几个指标能尽量多地反应原来<span class="math inline">\(p\)</span>个指标所提供的信息，而且彼此不相关。</p><p>首先考虑把这<span class="math inline">\(p\)</span>个指标全综合到一个数值<span class="math inline">\(y_1\)</span>里，有： <span class="math display">\[y_1=u_1x_1+\cdots+u_px_p=\boldsymbol{u&#39;x}\]</span> 因为方差越大，信息量越大，所以我们的目的是：在<span class="math inline">\(\boldsymbol{u&#39;u}=1\)</span>的条件下，让<span class="math inline">\(Var(y)=\boldsymbol{u&#39;\Sigma u}\)</span>最大。</p><p>有如下定理：</p><p><strong>定理</strong> ：设<span class="math inline">\(\boldsymbol{\Sigma}\)</span>的特征值从大到小依次是<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_p\geq0\)</span>,<span class="math inline">\(\lambda_i\)</span>对应的单位特征向量为<span class="math inline">\(\boldsymbol{a_i}\)</span>，则：</p><ol type="1"><li>在<span class="math inline">\(\boldsymbol{u&#39;u}=1\)</span>的条件下，<span class="math inline">\(\boldsymbol{u&#39;\Sigma u}\)</span>在<span class="math inline">\(\boldsymbol{u=a_1}\)</span>时取得最大值<span class="math inline">\(\lambda_1\)</span></li><li>在<span class="math inline">\(\boldsymbol{u&#39;u}=1,\boldsymbol{u&#39;a_i}=0\)</span>的条件下（<span class="math inline">\(i=1,2,3,\cdots,k-1\)</span>），<span class="math inline">\(\boldsymbol{u&#39;\Sigma u}\)</span>在<span class="math inline">\(u=a_k\)</span>处取得最大值<span class="math inline">\(\lambda_k\)</span></li></ol><p>于是，我们称<span class="math inline">\(y_1=\boldsymbol{u&#39;a_1}\)</span>为第一主成分，如果信息量仍然不够，应该选择第二主成分。由于要保证主成分之间的独立性，则条件应该加上<span class="math inline">\(Cov(y_1,y_2)=\boldsymbol{a&#39;_1\Sigma u}=\lambda\boldsymbol{u&#39;a_1}=0\)</span>,于是遵循（2）的规则继续取就行了。如此这样不断地取，直到累计方差贡献率 <span class="math display">\[\frac{\lambda_1+\cdots+\lambda_k} {\lambda_1+\lambda_2+\cdots+\lambda_p}\]</span> 达到预设值（往往为百分之七十五），就结束分析。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><span class="math inline">(p(x;a,b))</span>的含义是：该函数以<span class="math inline">(x)</span>为自变量，有两个参数<span class="math inline">(a)</span>和<span class="math inline">(b)</span> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><span class="math inline">(I)</span>是<span class="math inline">(T(x))</span>的值域，<span class="math inline">()</span>是<span class="math inline">()</span>的值域 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><span class="math inline">(B(n,p))</span>表示重复<span class="math inline">(n)</span>次试验，每次试验成功的概率为<span class="math inline">(p)</span>，成功的试验数目。这里实际上退化成了两点分布。 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>指示函数<span class="math inline">(I_a())</span>：当条件<span class="math inline">(a)</span>为真时为<span class="math inline">(1)</span>，反之为<span class="math inline">(0)</span>. <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>决策函数的自变量是样本<span class="math inline">({x})</span>，因变量是对待估计量的估计 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数定义整理：第二弹</title>
    <link href="/2022/05/27/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E5%BC%B9/"/>
    <url>/2022/05/27/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p>环为什么叫做环？</p><span id="more"></span><hr /><h2 id="第三章-环与域">第三章 环与域</h2><p><strong>定义1（加群）</strong> .一个交换群叫做加群，当这个群的代数运算叫做”加法“，并用符号<span class="math inline">\(+\)</span>表示。</p><p><strong>定义2（环）</strong> .一个集合<span class="math inline">\(R\)</span>叫做一个环，当：</p><ol type="1"><li><span class="math inline">\(R\)</span>是一个加群，即<span class="math inline">\(R\)</span>对一个叫加法的代数运算作成一个交换群</li><li><span class="math inline">\(R\)</span>对另一个叫做乘法的代数运算封闭</li><li>这个乘法适合结合律</li><li>这里的加法和乘法适合左右分配律</li></ol><blockquote><p>例如：全体整数作成的集合对普通加法和乘法构成一个环。需要注意的是，环的定义中的乘法并不总满足交换律。</p></blockquote><p><strong>定义3（交换环）</strong> .一个环<span class="math inline">\(R\)</span>被称作交换环，当： <span class="math display">\[\forall a,b\in R,ab=ba\]</span> <strong>定义4（环的单位元）</strong> 如果一个环<span class="math inline">\(R\)</span>中存在一个元素<span class="math inline">\(e\)</span>,使得 <span class="math display">\[\forall a\in R,ea=ae=a\]</span> 那么这个<span class="math inline">\(e\)</span>叫做环<span class="math inline">\(R\)</span>的单位元。环并不总有单位元。</p><blockquote><p>例如：全体偶数对普通加法和普通乘法作成环，但是没有单位元。</p></blockquote><p><strong>定义5（零因子）</strong> .如果在一个环里，<span class="math inline">\(a\neq0,b\neq0\)</span>但是<span class="math inline">\(ab=0\)</span>，那么<span class="math inline">\(a\)</span>是环中的一个左零因子，<span class="math inline">\(b\)</span>是环中的一个右零因子。</p><blockquote><p>例如：对于所有形如<span class="math inline">\(\begin{pmatrix}x&amp;0\\y&amp;0\\\end{pmatrix}\)</span>的矩阵，对普通矩阵加法和普通矩阵乘法构成的环而言，有： <span class="math display">\[\begin{pmatrix}1 &amp; 0\\0 &amp;0\\\end{pmatrix}\begin{pmatrix}0 &amp; 0\\1 &amp; 0\\\end{pmatrix}=\begin{pmatrix}0 &amp; 0\\0 &amp;0\\\end{pmatrix}\]</span> 于是<span class="math inline">\(\begin{pmatrix}1 &amp; 0\\0 &amp;0\\\end{pmatrix}\)</span>是一个左零因子，<span class="math inline">\(\begin{pmatrix}0 &amp; 0\\1 &amp; 0\\\end{pmatrix}\)</span>是一个右零因子。</p></blockquote><blockquote><p>在一个没有零因子的环中两个消去律都成立，并且如果有任意一个消去律成立，就没有零因子。</p></blockquote><p><strong>定义6（整环）</strong> 符合以下性质的环<span class="math inline">\(R\)</span>叫做整环：</p><ol type="1"><li>乘法适合交换律</li><li><span class="math inline">\(R\)</span>有单位元<span class="math inline">\(1\)</span></li><li><span class="math inline">\(R\)</span>没有零因子</li></ol><p><strong>定义7（除环）</strong> 符合以下性质的环<span class="math inline">\(R\)</span>叫做除环：</p><ol type="1"><li><span class="math inline">\(R\)</span>至少包含一个不为<span class="math inline">\(0\)</span>的元</li><li><span class="math inline">\(R\)</span>有单位元</li><li><span class="math inline">\(R\)</span>的每一个不为<span class="math inline">\(0\)</span>的元有一个逆元</li></ol><blockquote><p>显然，除环没有零因子，而且除环中的元素（除了0）对于乘法来说构成群。在一个除环中，只要<span class="math inline">\(a\neq 0\)</span>,我们就能拿<span class="math inline">\(a\)</span>去除任意一个元<span class="math inline">\(b\)</span>，这就是除环名字的来历。</p></blockquote><p><strong>定义8（域）</strong> 一个交换除环叫做一个域。</p><p><strong>定义9（环的特征）</strong> 一个无零因子环<span class="math inline">\(R\)</span>的非零元的相同的（对于加法来说）的阶叫做环的特征。</p><blockquote><p>环的特征如果有限，那么它一定是个素数。</p></blockquote><p><strong>定义10（子环）</strong> 一个环<span class="math inline">\(R\)</span>的子集<span class="math inline">\(S\)</span>如果对<span class="math inline">\(R\)</span>的代数运算也作成一个环，那么它叫做<span class="math inline">\(R\)</span>的子环。</p><p><strong>定义11（多项式）</strong> 假设<span class="math inline">\(R_0\)</span>是一个有单位元的交换环，<span class="math inline">\(R\)</span>是<span class="math inline">\(R_0\)</span>的子环，且包含<span class="math inline">\(R_0\)</span>的单位元。我们在<span class="math inline">\(R_0\)</span>中取出一个元<span class="math inline">\(x\)</span>。一个可以写成 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n\]</span> 的<span class="math inline">\(R_0\)</span>的元叫做<span class="math inline">\(R\)</span>上的<span class="math inline">\(x\)</span>的多项式。</p><p><strong>定义12（多项式环）</strong> 我们把所有<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式放在一个集合中，叫做<span class="math inline">\(R[x]\)</span>，那么<span class="math inline">\(R[x]\)</span>叫做<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式环。</p><p><strong>定义13（未定元，次数）</strong> <span class="math inline">\(R_0\)</span>的一个元<span class="math inline">\(x\)</span>叫做<span class="math inline">\(R\)</span>上的一个未定元，如果<span class="math inline">\(R\)</span>中不存在不全为零的<span class="math inline">\(a_0,a_1,a_2,\cdots,a_n\)</span>，使得 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n=0\]</span> <span class="math inline">\(R\)</span>上的一个未定元<span class="math inline">\(x\)</span>的一元多项式只能用一种方法写成 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n ,a_n\neq0\]</span> 的形式。其中<span class="math inline">\(n\)</span>叫做多项式的次数。</p><p><strong>定义14（无关未定元）</strong> <span class="math inline">\(R_0\)</span>上的<span class="math inline">\(n\)</span>个元<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>叫做<span class="math inline">\(R\)</span>上的无关未定元，假如任何一个<span class="math inline">\(R\)</span>上<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>的多项式都不为零，除非系数全为零。</p><p><strong>定义15（理想）</strong> 环<span class="math inline">\(R\)</span>的一个子环<span class="math inline">\({\mathfrak A}\)</span>叫做一个 <strong>理想子环，简称理想</strong> ，当：</p><ol type="1"><li><span class="math inline">\(a,b\in{\mathfrak A}\to a-b\in {\mathfrak A}\)</span></li><li><span class="math inline">\(a\in{\mathfrak A},r\in R\to ra,ar\in{\mathfrak A}\)</span></li></ol><blockquote><p>一个环有两个平凡的理想，分别的只含零元的零理想、R自己（单位理想）</p></blockquote><p><strong>定义16（主理想）</strong> 给定一个环<span class="math inline">\(R\)</span>，取其中的一个元素<span class="math inline">\(a\)</span>，利用<span class="math inline">\(a\)</span>作成一个集合<span class="math inline">\({\mathfrak A}\)</span>,其中包含所有形如： <span class="math display">\[(x_1ay_1+\cdots+x_may_m)+sa+st+na\]</span> （其中<span class="math inline">\(x,y,s,t\in R\)</span>，<span class="math inline">\(n\)</span>是整数）形式的元。那么<span class="math inline">\({\mathfrak A}\)</span>是含有<span class="math inline">\(a\)</span>的最小理想，叫做由<span class="math inline">\(a\)</span>生成的 <strong>主理想</strong> ，用<span class="math inline">\((a)\)</span>表示。</p><p>特别地：</p><ul><li>如果<span class="math inline">\(R\)</span>是交换环，<span class="math inline">\((a)\)</span>的元都可以写成<span class="math inline">\(ra+na\)</span>的形式。其中<span class="math inline">\(r\in R,n\)</span>是整数</li><li>如果<span class="math inline">\(R\)</span>有单位元，<span class="math inline">\((a)\)</span>的元都可以写成<span class="math inline">\(\sum x_iay_i\)</span>的形式。</li><li>如果<span class="math inline">\(R\)</span>既是交换环由于单位元，那么<span class="math inline">\((a)\)</span>都可以写成<span class="math inline">\(ra\)</span>的形式。</li></ul><p><strong>定义17（生成理想）</strong> <span class="math inline">\({\mathfrak A}\)</span>叫做由<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span> <strong>生成的理想</strong> ，用<span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span>来表示。<span class="math inline">\({\mathfrak A}\)</span>包含所有可以写成 <span class="math display">\[s_1+s_2+\cdots+s_n(s_1\in(a_i))\]</span> 的元。</p><p><strong>定义18（剩余类环）</strong> 给定一个环<span class="math inline">\(R\)</span>，<span class="math inline">\({\mathfrak A}\)</span>是它的一个理想。就加法来看，<span class="math inline">\({\mathfrak A}\)</span>是<span class="math inline">\(R\)</span>的不变子群，这样<span class="math inline">\({\mathfrak A}\)</span>的陪集 <span class="math display">\[[a],[b],\cdots\]</span> 作成<span class="math inline">\(R\)</span>的一个分类，我们把这些类叫做模<span class="math inline">\({\mathfrak A}\)</span>的剩余类，<span class="math inline">\(\bar{R}\)</span>是所有模<span class="math inline">\({\mathfrak A}\)</span>的剩余类组成的集合，它也是一个环，我们称其为 <strong>剩余类环</strong> ，记作： <span class="math display">\[R/{\mathfrak A}\]</span></p><blockquote><p>事实上，<span class="math inline">\(R\)</span>和<span class="math inline">\(\bar{R}\)</span>同态。</p></blockquote><p><strong>定义19（最大理想）</strong> 一个环<span class="math inline">\(R\)</span>的一个不等于<span class="math inline">\(R\)</span>的理想<span class="math inline">\({\mathfrak A}\)</span>叫做 <strong>最大理想</strong> ，当除了<span class="math inline">\(R\)</span>和<span class="math inline">\({\mathfrak A}\)</span>以外，没有包含<span class="math inline">\({\mathfrak A}\)</span>的理想。</p><p>最大理想有时候也叫做极大理想。如果<span class="math inline">\(R\)</span>是有单位元的交换环，<span class="math inline">\({\mathfrak A}\)</span>是<span class="math inline">\(R\)</span>的理想，那么<span class="math inline">\(R/{\mathfrak A}\)</span>是一个域等价于<span class="math inline">\({\mathfrak A}\)</span>是最大理想。</p><p><strong>定义20（商域）</strong> 一个域<span class="math inline">\(Q\)</span>叫做一个环<span class="math inline">\(R\)</span>的 <strong>商域</strong> ，假如<span class="math inline">\(Q\)</span>包含<span class="math inline">\(R\)</span>，并且<span class="math inline">\(Q\)</span>恰好由 <span class="math display">\[\frac{a}{b}\ \ (a,b\in R,b\neq 0)\]</span> 组成。</p><h2 id="第四章-整环里的因子分解">第四章 整环里的因子分解</h2><p><strong>定理1（整数环上唯一分解定理）</strong> 一个整数可以唯一地写成若干个素数的乘积。</p><p><strong>定义21（整除,因子）</strong> 我们说整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(a\)</span>可以被整环<span class="math inline">\(I\)</span>中的另一个元<span class="math inline">\(b\)</span> <strong>整除</strong> ，当能在<span class="math inline">\(I\)</span>中找出一个元<span class="math inline">\(c\)</span>，使得 <span class="math display">\[a=bc\]</span> 如果<span class="math inline">\(a\)</span>能被<span class="math inline">\(b\)</span>整除，记作<span class="math inline">\(b|a\)</span>，我们说<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的 <strong>因子</strong>。</p><p><strong>定义22（单位，相伴元）</strong> 整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(\varepsilon\)</span>叫做<span class="math inline">\(I\)</span>的一个 <strong>单位</strong> ，当<span class="math inline">\(\varepsilon\)</span>是有逆元的元。<span class="math inline">\(b\)</span>叫做<span class="math inline">\(a\)</span>的 <strong>相伴元</strong> ，假如 <span class="math display">\[b=\varepsilon a\]</span></p><blockquote><p>例如，整数环中有两个单位，分别是<span class="math inline">\(1\)</span>和<span class="math inline">\(-1\)</span>；整复数环中有四个单位，分别是<span class="math inline">\(\pm 1\)</span>,<span class="math inline">\(\pm i\)</span>。显然，单位的乘积、单位的逆元也是单位。</p></blockquote><p><strong>定义23（平凡因子、真因子）</strong> 单位和<span class="math inline">\(a\)</span>的相伴元叫做<span class="math inline">\(a\)</span>的 <strong>平凡因子</strong> ，<span class="math inline">\(a\)</span>的其它因子叫做<span class="math inline">\(a\)</span>的 <strong>真因子</strong> 。</p><p><strong>定义24（素元）</strong> 一个整环<span class="math inline">\(I\)</span>的一个既不是零元、也不是单位、还没有真因子的元<span class="math inline">\(p\)</span>叫做 <strong>素元</strong> 。</p><blockquote><p>这样的话，单位元和素元的积也是素元。</p></blockquote><p><strong>定义25（唯一分解）</strong> 我们说一个整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(a\)</span>在<span class="math inline">\(I\)</span>里有 <strong>唯一分解</strong> ，假如：</p><ol type="1"><li><span class="math inline">\(a=p_1p_2\cdots p_r\)</span>，其中<span class="math inline">\(p_i\)</span>是素元</li><li>若同时<span class="math inline">\(a=q_1q_2\cdots q_s\)</span>，其中<span class="math inline">\(q\)</span>是素元，那么<span class="math inline">\(r=s\)</span>，并且我们可以把<span class="math inline">\(q_i\)</span>的次序调换一下，使得<span class="math inline">\(\forall i,q_i=p_i\varepsilon\)</span></li></ol><blockquote><p>一个整环的泠鸢和单位显然是没有唯一分解的，但是其实不是零元也不是单位的元也不一定有唯一分解，例如在环<span class="math inline">\(I=\{a+\sqrt{3}bi|a,b\in {\mathbb Z}\}\)</span>中的元<span class="math inline">\(4\)</span>，有： <span class="math display">\[4=2\times2=(1+\sqrt{3}i)\times(1-\sqrt{3}i)\]</span></p></blockquote><p><strong>定义26（唯一分解环）</strong> 如果一个整环<span class="math inline">\(I\)</span>的每一个不是零元也不是单位的元都能唯一分解，那么<span class="math inline">\(I\)</span>叫做 <strong>唯一分解环</strong> 。</p><p><strong>定义27（公因子，最大公因子）</strong> 如果一个元<span class="math inline">\(c\)</span>能同时整除<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，这个元<span class="math inline">\(c\)</span>叫做<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>的 <strong>公因子</strong> 。如果公因子<span class="math inline">\(d\)</span>能被每个公因子整除，那么这个<span class="math inline">\(d\)</span>叫做 <strong>最大公因子</strong> 。</p><p><strong>定义28（互素）</strong> 一列数的最大公因子是单位，那称这一列数 <strong>互素</strong> 。</p><p><strong>定义29（主理想环）</strong> 如果整环<span class="math inline">\(I\)</span>的每个理想都是主理想，那么称<span class="math inline">\(I\)</span>是 <strong>主理想环</strong> 。</p><blockquote><p>主理想环有个很重要的性质：在主理想环中构造一个序列<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，其中后项一定是前项的真因子，那么这个序列长度有限。而且一个主理想环一定是唯一分解环。</p></blockquote><p><strong>定义30（欧氏环）</strong> 一个满足下列性质的整环<span class="math inline">\(I\)</span>叫做 <strong>欧氏环</strong> ：</p><ol type="1"><li><p>有一个从<span class="math inline">\(I\)</span>的非零元所组成的集合到自然数集合的映射<span class="math inline">\(\phi\)</span>存在</p></li><li><p>对于<span class="math inline">\(I\)</span>中一个非零元<span class="math inline">\(a\)</span>，<span class="math inline">\(I\)</span>中任何元<span class="math inline">\(b\)</span>都可写成 <span class="math display">\[b=qa+r\ \ (q,r\in I)\]</span> 的形式，且有：<span class="math inline">\(r=0\)</span>或<span class="math inline">\(\phi(r)&lt;\phi(a)\)</span></p></li></ol><blockquote><p>所有欧氏环都是主理想环，于是也是唯一分解环。而且一个域<span class="math inline">\(F\)</span>上的一元多项式环<span class="math inline">\(F[x]\)</span>是一个欧氏环。</p></blockquote><p><strong>定义31（本原多项式）</strong> <span class="math inline">\(I[x]\)</span>的一个元<span class="math inline">\(f(x)\)</span>叫做本原多项式，假如<span class="math inline">\(f(x)\)</span>系数的最大公因子是单位。</p><p>如果有<span class="math inline">\(f(x)=g(x)h(x)\)</span>，那么<span class="math inline">\(f(x)\)</span>是本原多项式，当且仅当<span class="math inline">\(g(x),h(x)\)</span>是本原多项式。</p><p><strong>定义32（多项式的根）</strong> <span class="math inline">\(I\)</span>的元<span class="math inline">\(a\)</span>叫做<span class="math inline">\(I[x]\)</span>的多项式<span class="math inline">\(f(x)\)</span>的一个 <strong>根</strong> ，当且仅当<span class="math inline">\(f(a)=0\)</span></p><p><strong>定义33（多项式的重根）</strong> <span class="math inline">\(I\)</span>的元<span class="math inline">\(a\)</span>叫做<span class="math inline">\(I[x]\)</span>的多项式<span class="math inline">\(f(x)\)</span>的一个 <strong><span class="math inline">\(k\)</span>重根</strong> ，假如<span class="math inline">\(f(x)\)</span>能被<span class="math inline">\((x-a)^k\)</span>整除，其中<span class="math inline">\(k\)</span>大于1.</p><p><strong>定义34（多项式的导数）</strong> 对于多项式 <span class="math display">\[f(x)=\sum_{i=0}^na_ix^i\]</span> 其导数为 <span class="math display">\[f&#39;(x)=\sum_{i=1}^{n}ia_ix^{i-1}\]</span></p><h2 id="第五章扩域">第五章：扩域</h2><p><strong>定义35（扩域）</strong> 一个域<span class="math inline">\(E\)</span>叫做一个域<span class="math inline">\(F\)</span>的 <strong>扩域</strong> ，当<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域</p><p>例如：实数域是有理数域的扩域，复数域是实数域的扩域。</p><blockquote><p>事实上，令<span class="math inline">\(E\)</span>是一个域，如果<span class="math inline">\(E\)</span>的特征是无穷大，那么它含有一个和有理数域同构的子域；如果<span class="math inline">\(E\)</span>的特征是素数<span class="math inline">\(p\)</span>，那么它含一个和<span class="math inline">\(R/(p)\)</span>同构的子域，其中<span class="math inline">\(R\)</span>是整数环，<span class="math inline">\((p)\)</span>是由<span class="math inline">\(p\)</span>生成的主理想。</p></blockquote><p><strong>定义36（素域）</strong> 一个域叫做一个 <strong>素域</strong> ，假如它不含任何真子域。</p><p><strong>定义37（单扩域）</strong> 添加一个元素<span class="math inline">\(\alpha\)</span>于域<span class="math inline">\(F\)</span>中所得的扩域<span class="math inline">\(F(\alpha)\)</span>叫做<span class="math inline">\(F\)</span>的一个单扩域</p><p><strong>定义38（代数元）</strong> 如果对于域<span class="math inline">\(F\)</span>中的一个元素<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(F\)</span>中存在不全为零的元<span class="math inline">\(a_1,\cdots,a_n\)</span>，使得： <span class="math display">\[a_0+a_1\alpha+a_2\alpha+\cdots+a_n\alpha^n=0\]</span> 那么<span class="math inline">\(\alpha\)</span>叫做 <strong>代数元</strong> 。如果这样的<span class="math inline">\(a_1,\cdots,a_n\)</span>不存在，<span class="math inline">\(\alpha\)</span>就叫做 <strong>超越元</strong> 。</p><blockquote><p>代数数就是整数环上的代数元。</p></blockquote><p><strong>定义39（极小多项式）</strong> <span class="math inline">\(F[x]\)</span>中满足<span class="math inline">\(p(\alpha)=0\)</span>的次数最低的多项式 <span class="math display">\[p(x)=x^n+a_{n-1}x^{n-1}+\cdots+a_0\]</span> 叫做<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(F\)</span>上的 <strong>极小多项式</strong> ，<span class="math inline">\(n\)</span>叫做<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(F\)</span>上的 <strong>次数</strong></p><p><strong>定义40（代数扩域）</strong> 如果域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>的每一个元都是<span class="math inline">\(F\)</span>的代数元，那么<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F\)</span>的 <strong>代数扩域（扩张）</strong> 。</p><blockquote><p>假如<span class="math inline">\(K\)</span>是<span class="math inline">\(F\)</span>的扩域，那么<span class="math inline">\(K\)</span>可以视作是<span class="math inline">\(F\)</span>上的一个向量空间（对于<span class="math inline">\(K\)</span>的加法和<span class="math inline">\(F\times K\to K\)</span>的乘法）。也就是说，对于任意<span class="math inline">\(K\)</span>上的元素<span class="math inline">\(\alpha\)</span> ，存在一组来自于<span class="math inline">\(K\)</span>的基，使<span class="math inline">\(\alpha\)</span>可以被那些基线性表出，而表示的基的各项系数都在<span class="math inline">\(F\)</span>内。</p><p>例如：复数域是实数域的扩域，而复数域的“基”就是<span class="math inline">\(1\)</span>和<span class="math inline">\(i\)</span></p></blockquote><p><strong>定义41（有限扩域，扩域的次数）</strong> 如果域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>作为<span class="math inline">\(F\)</span>上的向量空间的维数为<span class="math inline">\(n\)</span>，那么<span class="math inline">\(n\)</span>称作扩域<span class="math inline">\(E\)</span>在<span class="math inline">\(F\)</span>上的 <strong>次数</strong> ，记作<span class="math inline">\((E:F)=n\)</span>.此时<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F\)</span>的一个 <strong>有限扩域</strong> 。</p><blockquote><p>若有 <span class="math display">\[F\subset I\subset E\]</span> 则有 <span class="math display">\[(E:F)=(E:I)(I:F)\]</span></p></blockquote><p><strong>定义42（多项式的分裂域/根域）</strong> 域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F[x]\)</span>的<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(F\)</span>上的一个 <strong>分裂域（也叫根域）</strong> ，如果：</p><ol type="1"><li><p>在<span class="math inline">\(E[x]\)</span>中，<span class="math inline">\(f(x)\)</span>可以分解为一次因子的积 <span class="math display">\[f(x)=a_n(x-\alpha_1)(x-\alpha_2)\cdots(x-\alpha_n)\]</span></p></li><li><p>在一个比<span class="math inline">\(E\)</span>小的域中，<span class="math inline">\(f(x)\)</span>不能被这样分解。</p></li></ol><blockquote><p>有： <span class="math display">\[E=F(\alpha_1,\alpha_2\cdots,\alpha_n)\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于用R语言进行方差分析的乐子二则</title>
    <link href="/2022/05/23/%E5%85%B3%E4%BA%8E%E7%94%A8R%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%90%E5%AD%90%E4%BA%8C%E5%88%99/"/>
    <url>/2022/05/23/%E5%85%B3%E4%BA%8E%E7%94%A8R%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%90%E5%AD%90%E4%BA%8C%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>我们都知道R语言是非常强的统计工具，今天想着用R语言来做数理统计作业，却被摆了两道，哈哈。</p><span id="more"></span><h2 id="方差分析">方差分析</h2><p>要讨论这两则乐子，首先要知道什么是方差分析。</p><h3 id="单变量方差分析">单变量方差分析</h3><p>单因素方差分析可以看成基础统计中两样本<span class="math inline">\(t\)</span>检验的一个推广， 要比较试验观测值的某个因变量（称为“指标”）按照一个分组变量（称为“因素”）分组后， 各组的因变量均值有无显著差异。</p><p>设因素A有p个不同的水平<span class="math inline">\(A_1,A_2,\cdots,A_p\)</span>,在每个水平下，总体<span class="math inline">\(X_i\sim N(\mu_i,\sigma^2)\)</span>,需要检验的是这<span class="math inline">\(p\)</span>个样本的平均值有没有显著差异，即： <span class="math display">\[H_0:\mu_1=\mu_2=\cdots=\mu_p\]</span> 一般地，我们在每个水平中抽取<span class="math inline">\(r\)</span>个样本，形成如下的样本表：</p><table><thead><tr class="header"><th><span class="math inline">\(A_1\)</span></th><th><span class="math inline">\(x_{11}\)</span></th><th><span class="math inline">\(x_{12}\)</span></th><th><span class="math inline">\(\cdots\)</span></th><th><span class="math inline">\(x_{1r}\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(A_2\)</span></td><td><span class="math inline">\(x_{21}\)</span></td><td><span class="math inline">\(x_{22}\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(x_{2r}\)</span></td></tr><tr class="even"><td><span class="math inline">\(\cdots\)</span></td><td></td><td></td><td><span class="math inline">\(\cdots\)</span></td><td></td></tr><tr class="odd"><td><span class="math inline">\(A_P\)</span></td><td><span class="math inline">\(x_{p1}\)</span></td><td><span class="math inline">\(x_{p2}\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(x_{pr}\)</span></td></tr></tbody></table><p>【例】：用R语言对下列数据进行方差分析：</p><table><thead><tr class="header"><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr class="odd"><td>58</td><td>58</td><td>48</td></tr><tr class="even"><td>64</td><td>69</td><td>57</td></tr><tr class="odd"><td>55</td><td>71</td><td>59</td></tr><tr class="even"><td>66</td><td>64</td><td>47</td></tr><tr class="odd"><td>67</td><td>68</td><td>49</td></tr></tbody></table><p>【解】先把表格转换成纵列形式</p><table><thead><tr class="header"><th>grp</th><th>y</th></tr></thead><tbody><tr class="odd"><td>A</td><td>58</td></tr><tr class="even"><td>A</td><td>64</td></tr><tr class="odd"><td>A</td><td>55</td></tr><tr class="even"><td>A</td><td>66</td></tr><tr class="odd"><td>A</td><td>67</td></tr><tr class="even"><td>B</td><td>58</td></tr><tr class="odd"><td>B</td><td>69</td></tr><tr class="even"><td>B</td><td>71</td></tr><tr class="odd"><td>B</td><td>64</td></tr><tr class="even"><td>B</td><td>68</td></tr><tr class="odd"><td>C</td><td>48</td></tr><tr class="even"><td>C</td><td>57</td></tr><tr class="odd"><td>C</td><td>59</td></tr><tr class="even"><td>C</td><td>47</td></tr><tr class="odd"><td>C</td><td>49</td></tr></tbody></table><p>将上表保存为<code>R1.csv</code>，在”我的文档“中。在R软件中输入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">data <span class="hljs-operator">&lt;-</span> read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;R1.csv&quot;</span><span class="hljs-punctuation">)</span><br>data<br></code></pre></td></tr></table></figure><p>可以读入数据，并展示数据。</p><p>然后建立方差分析模型，在R软件中输入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>y<span class="hljs-operator">~</span>grp<span class="hljs-punctuation">,</span>data<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>即可输出分析结果，如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value  Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>   <br>grp          <span class="hljs-number">2</span>    <span class="hljs-number">520</span>  <span class="hljs-number">260.00</span>   <span class="hljs-number">9.176</span> <span class="hljs-number">0.00382</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">12</span>    <span class="hljs-number">340</span>   <span class="hljs-number">28.33</span>                   <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们看到<code>grp</code>的<span class="math inline">\(P_r\)</span>值有<span class="math inline">\(0.00382&lt;0.05\)</span>，所以可以认为各组之间有显著差异。</p><h3 id="双变量方差分析">双变量方差分析</h3><p>在实际任务中，影响实验结果的因素可能不止一个，这时就要用到双变量方差分析（或者正交实验）。在两个因素的实验中，不但每一个因素会对结果起作用，而且两个因素联合起来往往也会对结果起作用。如果你不能理解这个结论，不妨设想这样一个例子：工人在工厂工作时，对工人效率的影响因素有工人和机器。如果工人专业技能高、机器运行状况好，那么效率很自然地就会比较高。但是一个资质平平的工人如果对某个状况一般的机器非常熟悉，以至于把这个机器什么时候会出现什么误差都记得滚瓜烂熟，那么把他俩结合起来，也有可能获得很高的效率。</p><p>为了进行双变量方差分析，进行双因素重复性实验，得到的数据表往往是这样给出的：</p><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320029199.png" /></p><p>这时，我就美美地开始做题了！</p><h2 id="第一道题">第一道题</h2><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320064532.png" /></p><p>我一看这不简单？于是美美列了个表：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B   Y<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">106</span><br><span class="hljs-number">4</span>  <span class="hljs-number">4</span> <span class="hljs-number">1</span>  <span class="hljs-number">98</span><br><span class="hljs-number">5</span>  <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">102</span><br><span class="hljs-number">6</span>  <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">112</span><br><span class="hljs-number">7</span>  <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">105</span><br><span class="hljs-number">8</span>  <span class="hljs-number">8</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">9</span>  <span class="hljs-number">1</span> <span class="hljs-number">2</span>  <span class="hljs-number">95</span><br><span class="hljs-number">10</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>  <span class="hljs-number">94</span><br><span class="hljs-number">11</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">105</span><br><span class="hljs-number">12</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span>  <span class="hljs-number">97</span><br><span class="hljs-number">13</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-number">98</span><br><span class="hljs-number">14</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">112</span><br><span class="hljs-number">15</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">103</span><br><span class="hljs-number">16</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span>  <span class="hljs-number">92</span><br><span class="hljs-number">17</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>  <span class="hljs-number">89</span><br><span class="hljs-number">18</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>  <span class="hljs-number">88</span><br><span class="hljs-number">19</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>  <span class="hljs-number">87</span><br><span class="hljs-number">20</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>  <span class="hljs-number">95</span><br><span class="hljs-number">21</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span>  <span class="hljs-number">97</span><br><span class="hljs-number">22</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">101</span><br><span class="hljs-number">23</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span>  <span class="hljs-number">97</span><br><span class="hljs-number">24</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span>  <span class="hljs-number">90</span><br><span class="hljs-number">25</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>  <span class="hljs-number">83</span><br><span class="hljs-number">26</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>  <span class="hljs-number">84</span><br><span class="hljs-number">27</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>  <span class="hljs-number">90</span><br><span class="hljs-number">28</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">90</span><br><span class="hljs-number">29</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">88</span><br><span class="hljs-number">30</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span>  <span class="hljs-number">94</span><br><span class="hljs-number">31</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span>  <span class="hljs-number">88</span><br><span class="hljs-number">32</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span>  <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>读取数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">X<span class="hljs-operator">=</span>read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;R.csv&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>建立模型并分析：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod<span class="hljs-operator">&lt;-</span>aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">+</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">1</span>   <span class="hljs-number">74.0</span>    <span class="hljs-number">74.0</span>   <span class="hljs-number">2.385</span>    <span class="hljs-number">0.133</span>    <br>B            <span class="hljs-number">1</span>  <span class="hljs-number">926.4</span>   <span class="hljs-number">926.4</span>  <span class="hljs-number">29.857</span> <span class="hljs-number">6.99e-06</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">29</span>  <span class="hljs-number">899.8</span>    <span class="hljs-number">31.0</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其中：</p><table><thead><tr class="header"><th>项目</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Df</td><td>自由度</td></tr><tr class="even"><td>Sum Sq</td><td>平方和</td></tr><tr class="odd"><td>Mean Sq</td><td>均方</td></tr><tr class="even"><td>F value</td><td>F值</td></tr><tr class="odd"><td>Pr(&gt;F)</td><td>p值</td></tr></tbody></table><p>哈哈，聪明的你一定看出问题了吧，那就是这俩的自由度都是<span class="math inline">\(1\)</span>，这是怎么会事呢？</p><p>原来是因为我的两个标签<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都用了数字，而R语言里的数据类型有数字、字符等。它把我们的1，2，3，...当成了一个连续变量，于是就出错了。当然这个问题可以用<code>ac.factor()</code>函数解决，但是我直接把标签换成字母也能解决。</p><p>修改了以后的输出为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">7</span>  <span class="hljs-number">747.5</span>   <span class="hljs-number">106.8</span>   <span class="hljs-number">12.78</span> <span class="hljs-number">2.62e-06</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>B            <span class="hljs-number">3</span>  <span class="hljs-number">977.3</span>   <span class="hljs-number">325.8</span>   <span class="hljs-number">39.00</span> <span class="hljs-number">9.12e-09</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">21</span>  <span class="hljs-number">175.4</span>     <span class="hljs-number">8.4</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个结果是正确的。我们可以发现<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都对结果有不可忽视的影响。</p><h2 id="第二道题">第二道题</h2><p>三位操作工分别在四台不同的机器上操作了3天，其产量如下表所示：</p><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320084039.png" /></p><p>于是我想当然哈，以为三次实验，加一下就好了，于是列了这么个表：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B  Y<br><span class="hljs-number">1</span>  a x <span class="hljs-number">47</span><br><span class="hljs-number">2</span>  b x <span class="hljs-number">51</span><br><span class="hljs-number">3</span>  <span class="hljs-built_in">c</span> x <span class="hljs-number">48</span><br><span class="hljs-number">4</span>  d x <span class="hljs-number">60</span><br><span class="hljs-number">5</span>  a y <span class="hljs-number">54</span><br><span class="hljs-number">6</span>  b y <span class="hljs-number">45</span><br><span class="hljs-number">7</span>  <span class="hljs-built_in">c</span> y <span class="hljs-number">51</span><br><span class="hljs-number">8</span>  d y <span class="hljs-number">48</span><br><span class="hljs-number">9</span>  a z <span class="hljs-number">55</span><br><span class="hljs-number">10</span> b z <span class="hljs-number">63</span><br><span class="hljs-number">11</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">54</span><br><span class="hljs-number">12</span> d z <span class="hljs-number">51</span><br></code></pre></td></tr></table></figure><p>建立模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">+</span>B<span class="hljs-operator">+</span>A<span class="hljs-operator">:</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq<br>A            <span class="hljs-number">3</span>   <span class="hljs-number">8.25</span>    <span class="hljs-number">2.75</span><br>B            <span class="hljs-number">2</span>  <span class="hljs-number">81.50</span>   <span class="hljs-number">40.75</span><br>A<span class="hljs-operator">:</span>B          <span class="hljs-number">6</span> <span class="hljs-number">220.50</span>   <span class="hljs-number">36.75</span><br></code></pre></td></tr></table></figure><p>根据<span class="math inline">\(F\)</span>值，我们可以看出....欸我<span class="math inline">\(F\)</span>值呢？咋没了？</p><p>这是因为，在”加和“（或者求平均值）的时候，就顺带消除了<span class="math inline">\(A\times B\)</span>的影响。这是因为<span class="math inline">\(A\times B\)</span>的离差平方和为： <span class="math display">\[S_{A\times B}=\sum_{i=1}^p\sum_{j=1}^q\sum_{k=1}^r (\bar{x}_{ij\cdot} -\bar{x}_{i\cdot \cdot } - \bar{x}_{\cdot j \cdot } +\bar{x})^2\]</span> 对于多次重复实验，应该把它们分拆开，每次都单独算。列表如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B  Y<br><span class="hljs-number">1</span>  a x <span class="hljs-number">15</span><br><span class="hljs-number">2</span>  b x <span class="hljs-number">17</span><br><span class="hljs-number">3</span>  <span class="hljs-built_in">c</span> x <span class="hljs-number">15</span><br><span class="hljs-number">4</span>  d x <span class="hljs-number">18</span><br><span class="hljs-number">5</span>  a y <span class="hljs-number">19</span><br><span class="hljs-number">6</span>  b y <span class="hljs-number">15</span><br><span class="hljs-number">7</span>  <span class="hljs-built_in">c</span> y <span class="hljs-number">18</span><br><span class="hljs-number">8</span>  d y <span class="hljs-number">15</span><br><span class="hljs-number">9</span>  a z <span class="hljs-number">16</span><br><span class="hljs-number">10</span> b z <span class="hljs-number">19</span><br><span class="hljs-number">11</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">12</span> d z <span class="hljs-number">17</span><br><span class="hljs-number">13</span> a x <span class="hljs-number">15</span><br><span class="hljs-number">14</span> b x <span class="hljs-number">17</span><br><span class="hljs-number">15</span> <span class="hljs-built_in">c</span> x <span class="hljs-number">17</span><br><span class="hljs-number">16</span> d x <span class="hljs-number">20</span><br><span class="hljs-number">17</span> a y <span class="hljs-number">19</span><br><span class="hljs-number">18</span> b y <span class="hljs-number">15</span><br><span class="hljs-number">19</span> <span class="hljs-built_in">c</span> y <span class="hljs-number">17</span><br><span class="hljs-number">20</span> d y <span class="hljs-number">16</span><br><span class="hljs-number">21</span> a z <span class="hljs-number">18</span><br><span class="hljs-number">22</span> b z <span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">24</span> d z <span class="hljs-number">17</span><br><span class="hljs-number">25</span> a x <span class="hljs-number">17</span><br><span class="hljs-number">26</span> b x <span class="hljs-number">17</span><br><span class="hljs-number">27</span> <span class="hljs-built_in">c</span> x <span class="hljs-number">16</span><br><span class="hljs-number">28</span> d x <span class="hljs-number">22</span><br><span class="hljs-number">29</span> a y <span class="hljs-number">16</span><br><span class="hljs-number">30</span> b y <span class="hljs-number">15</span><br><span class="hljs-number">31</span> <span class="hljs-built_in">c</span> y <span class="hljs-number">16</span><br><span class="hljs-number">32</span> d y <span class="hljs-number">17</span><br><span class="hljs-number">33</span> a z <span class="hljs-number">21</span><br><span class="hljs-number">34</span> b z <span class="hljs-number">22</span><br><span class="hljs-number">35</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">36</span> d z <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>建立模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">*</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">3</span>   <span class="hljs-number">2.75</span>   <span class="hljs-number">0.917</span>   <span class="hljs-number">0.532</span> <span class="hljs-number">0.664528</span>    <br>B            <span class="hljs-number">2</span>  <span class="hljs-number">27.17</span>  <span class="hljs-number">13.583</span>   <span class="hljs-number">7.887</span> <span class="hljs-number">0.002330</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span> <br>A<span class="hljs-operator">:</span>B          <span class="hljs-number">6</span>  <span class="hljs-number">73.50</span>  <span class="hljs-number">12.250</span>   <span class="hljs-number">7.113</span> <span class="hljs-number">0.000192</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">24</span>  <span class="hljs-number">41.33</span>   <span class="hljs-number">1.722</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们可以看到，效率主要和工人的水平以及工人和机器的交互有关。</p><p>哈哈，我是铸币。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于拉普拉斯变换的那些事</title>
    <link href="/2022/05/21/%E5%85%B3%E4%BA%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/05/21/%E5%85%B3%E4%BA%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>拉普拉斯变换在许多工程技术和科学研究领域中有着广泛的应用，特别是在力学系统、电学系统、自动控制系统、可靠性系统以及随机服务系统等系统科学中都起着重要作用。本文大概写了一下常用的拉普拉斯变换技巧，非常的详细，我感觉任何人都能看懂。 本文约5200字，阅读时间22分钟。</p><span id="more"></span><h2 id="拉普拉斯变换概述">拉普拉斯变换概述</h2><p>说到拉普拉斯变换，就不得不提到奥列弗·赫维赛德。不得不说这位更是重量级，尽管大家可能不认识他，但是大家一定知道<code>Heaviside()</code>函数（在Mathematica中是<code>HeavisideTheta[]</code>函数）,这就是所谓的单位阶跃函数，我们一般简写为<span class="math inline">\(u(t)\)</span>或者<span class="math inline">\(\varepsilon(t)\)</span>。而且他在电子信息领域还有很多重要的贡献，比如说归纳整理了麦克斯韦方程组。而这里我们要说的是，他提出了运算微积分的思想，把常微分方程转换成了代数方程。具体地，他提出了微分算子<span class="math inline">\(p\)</span>: <span class="math display">\[p^n \leftrightarrow\frac{ {\mathbf d}^n()} { {\mathbf d}t^n}\]</span> 积分算子： <span class="math display">\[\frac{1} {p}\leftrightarrow \int_{-\infty}^t(){\mathbf d}\tau\]</span> 于是就能把常微分方程化成代数方程了。这种想法在当时并不被学界认可，但是我们现在发现这就是拉普拉斯变换的前身。</p><p>......扯远了，那么什么是拉普拉斯变换呢？我们都知道傅里叶变换很好用，但是要用它就必须得满足狄利特雷条件，其中有一条就是<span class="math inline">\(f(t)\)</span>绝对可积，这可不是什么简单的条件，于是就导致很多常见的函数没有傅里叶变换。那么为了推广傅里叶变换，给<span class="math inline">\(f(t)\)</span>乘上一个很强的衰减系数<span class="math inline">\(e^{-\sigma t}\)</span>,这时很多函数就变得绝对可积了。</p><p>容易发现，<span class="math inline">\(e^{-\sigma t}\)</span>往往在<span class="math inline">\(t&gt;0\)</span>的时候才表现出”衰减“的性质，于是我们往往讨论单边拉普拉斯变换，即： <span class="math display">\[{\mathscr L}[f(t)]=F(s)=\int_{0-}^{\infty}f(t)e^{-(\sigma +j\omega)t} {\mathbf d}t\]</span> 其中<span class="math inline">\(s={\sigma + j\omega}\)</span>.</p><p>拉普拉斯变换需要讨论收敛域的问题。我们把让上述无穷积分收敛的<span class="math inline">\(s\)</span>所在的区域称为收敛域。收敛域的边界是平行于虚轴的直线。对于右边信号而言，收敛域往往是<span class="math inline">\(Re[s]&gt;\alpha\)</span>的形式，也就是右半边平面。在讨论右边信号和单边拉普拉斯变换时，往往省去对收敛域的讨论。但对于双边拉普拉斯变换来说，一定要讨论收敛域。因为此时对于同一个<span class="math inline">\(F(s)\)</span>，不同的收敛域会导致反变换的结果不同。</p><h2 id="拉普拉斯变换性质">拉普拉斯变换性质</h2><p>设<span class="math inline">\({\mathscr L}[f(t)]=F(s)\)</span>，则</p><p>拉普拉斯变换常用的性质有：</p><h3 id="时域性质">时域性质</h3><ol type="1"><li><p>时移性质： <span class="math display">\[{\mathscr  L}[f(t-t_0)u(t-t_0)]=F(s)e^{-st_0}\]</span> 需要注意到：<span class="math inline">\(f(t-t_0)u(t-t_0)\)</span>、<span class="math inline">\(f(t-t_0)u(t)\)</span>、<span class="math inline">\(f(t-t_0)\)</span>是互不相同的。</p></li><li><p>压扩(相似)性质： <span class="math display">\[{\mathscr  L}[f(at)]=\frac{1} {a}F(\frac{s} {a})\]</span></p></li><li><p>线性性质</p></li><li><p>时域微分性质： <span class="math display">\[\begin{aligned}{\mathscr L}[\frac{ {\mathbf d}^n f(t)} { {\mathbf d}t}]&amp;=s^nF(s)-s^{n-1}f(0_-)-s^{n-2}f&#39;(0_-)-\cdots-f^{(n-1)}(0_-)\\\\&amp;=s^nF(s)-\sum_{k=0}^{n-1}s^{n-1-k}f^{(k)}(0_-)\end{aligned}\]</span></p><p>如果<span class="math inline">\(f(t)\)</span>为因果信号，即<span class="math inline">\(f(t)=f(t)u(t)\)</span>，那么： <span class="math display">\[{\mathscr  L}[\frac{ {\mathbf d}^n f(t)} { {\mathbf d}t}]=s^nF(s)\]</span> 我们看出这个形式和前面所说的”微分算子“有异曲同工之妙。这也是用拉普拉斯变换解微分方程的基础。</p></li><li><p>时域积分性质： <span class="math display">\[{\mathscr  L}[\int_{-\infty}^tf(\tau){\mathbf d}\tau]=\frac{F(s)} {s}+\frac{f^{(-1)}(0_-)} {s}\]</span></p></li></ol><h3 id="频域性质">频域性质</h3><ol type="1"><li><p>频移性质： <span class="math display">\[{\mathscr  L}[e^{s_0t}f(t)]=F(s-s_0)\]</span> 请注意和时移性质之间的区别。时间变成<span class="math inline">\(t-t_0\)</span>，乘的指数因子也是<span class="math inline">\(e^{-st_0}\)</span>，但是频域变成<span class="math inline">\(s-s_0\)</span>后，乘的指数因子却是<span class="math inline">\(e^{s_0t}\)</span>，符号不同。</p></li><li><p>频域微分性质： <span class="math display">\[{\mathscr  L}[-tf(t)]=\frac{ {\mathbf d}F(s)} { {\mathbf d}s}\]</span> 同样，注意符号。一般的，有： <span class="math display">\[{\mathscr  L}[(-t)^nf(t)]=\frac{ {\mathbf d}^nF} { {\mathbf d}s^n}\]</span></p></li><li><p>频域积分性质： <span class="math display">\[{\mathscr  L}[\frac{f(t)} {t}]=\int_s^\infty F(\lambda){\mathbf d}\lambda\]</span></p></li></ol><h3 id="其它定理">其它定理</h3><p>对于卷积运算，有卷积性质：</p><ol type="1"><li>时域卷积</li></ol><p><span class="math display">\[{\mathscr  L}[f_1(t)\bigotimes f_2(t)]=F_1(s)F_2(s)\]</span></p><ol start="2" type="1"><li>频域卷积 <span class="math display">\[{\mathscr  L}[f_1(t)f_2(t)]=\frac{1} {2\pi j}F_1(s)\bigotimes F_2(s)\]</span> 频域卷积很少用到。</li></ol><p>此外，还有终、初值定理：</p><ol type="1"><li><p>初值定理 <span class="math display">\[f(0_+)=\lim_{s\to \infty}sF(s)\]</span></p></li><li><p>终值定理 <span class="math display">\[\lim_{t\to \infty}f(t)=\lim_{s\to 0}sF(s)\]</span></p></li></ol><h2 id="常用拉普拉斯变换表">常用拉普拉斯变换表</h2><table><thead><tr class="header"><th style="text-align: center;">原函数</th><th style="text-align: center;">像函数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span>或<span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s}\)</span></td></tr></tbody></table><p>就一个？没错。因为其它的常用的基本上都能用性质推导出来。</p><ol type="1"><li><p><span class="math inline">\(t^n\)</span></p><p>由频域微分性质<span class="math inline">\({\mathscr L}[(-t)^nf(t)]=\frac{ {\mathbf d}^nF} { {\mathbf d}s^n}\)</span>，将<span class="math inline">\(f(t)=u(t),F=s^{-1}\)</span>代入，可得： <span class="math display">\[{\mathscr  L}[t^n]=\frac{n!} {s^{n+1} }\]</span></p></li><li><p><span class="math inline">\(e^{at}\)</span></p><p>由频移性质<span class="math inline">\({\mathscr L}[e^{s_0t}f(t)]=F(s-s_0)\)</span>可得： <span class="math display">\[{\mathscr  L}[e^{at}]=\frac{1} {s-a}\]</span></p></li><li><p><span class="math inline">\(t^ne^{at}\)</span></p><p>对<span class="math inline">\(t^n\)</span>的拉普拉斯变换应用频移性质，有： <span class="math display">\[{\mathscr  L}[t^n e^{at}]=\frac{n!} {(s-a)^{n+1} }\]</span></p></li><li><p><span class="math inline">\(\cos (\omega t)\)</span></p><p>由 <span class="math display">\[\cos(\omega t)=\frac{1} {2}(e^{-j\omega t}+e^{j\omega t})\]</span> 运用<span class="math inline">\(e^{at}\)</span>的拉普拉斯变换，可得 <span class="math display">\[{\mathscr  L}[\cos (\omega t)]=\frac{s} {s^2+\omega ^2}\]</span></p></li><li><p><span class="math inline">\(\sin (\omega t)\)</span></p><p>由 <span class="math display">\[\sin(\omega t)=\frac{1} {2j}(e^{j\omega t}-e^{-j\omega t})\]</span> 得 <span class="math display">\[{\mathscr  L}[\sin(\omega t)]=\frac{\omega} {s^2+\omega ^2}\]</span></p></li></ol><p>虽说如此，表格还是需要的。现归纳如下：</p><table><thead><tr class="header"><th style="text-align: center;">原函数</th><th style="text-align: center;">像函数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac 1s\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{n!} {s^{n+1} }\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s-a}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(te^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {(s-a)^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t^ne^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{n!} {(s-a)^{n+1} }\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sin (\omega t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\omega} {s^2+\omega^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\cos (\omega t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{s} {s^2+\omega^2}\)</span></td></tr></tbody></table><h2 id="多项式分式的拉普拉斯逆变换">多项式分式的拉普拉斯逆变换</h2><p>一个有理真分式形式的拉普拉斯变换式可以写成： <span class="math display">\[F(s)=\frac{N(s)} {D(s)}\]</span> 其中<span class="math inline">\(N\)</span>和<span class="math inline">\(D\)</span>都是多项式，<span class="math inline">\(D\)</span>的次数更高。接下来讲解如何计算这样的式子的拉普拉斯反变换。</p><p>基于代数方程的理论，上面的式子可以写成： <span class="math display">\[F(s)=\frac{K_1} {(s-p_1)}+\frac{K_1} {(s-p_1)}+\cdots+\frac{K_n} {(s-p_n)}\]</span> 即分解成很多小分式的和，其中<span class="math inline">\(p\)</span>为<span class="math inline">\(D\)</span>的根。多项式的根可能有单根、多重根，共轭复数根三种情况，我们来分别讨论。</p><h3 id="单根">单根</h3><p>单根对应的小分式为： <span class="math display">\[\frac{K_i} {s-p_i}\]</span> 在计算时，只需要给<span class="math inline">\(F(s)\)</span>两边同时乘以<span class="math inline">\((s-p_i)\)</span>，这样就能把这个极点消掉了，然后将<span class="math inline">\(s=p_i\)</span>代入<span class="math inline">\((s-p_i)F(s)\)</span>中（温馨提示：不要看到<span class="math inline">\((s-p_i)\)</span>乘以什么什么的形式就以为是0哦！），就能算出<span class="math inline">\(K_i\)</span>了。</p><p>这个小分式对应的原函数是<span class="math inline">\(K_ie^{p_it}\)</span>.</p><p>举例如下：</p><blockquote><p>【例】计算下式的拉普拉斯反变换 <span class="math display">\[\frac{2s^2+3s+3} {s^3+6s^2+11s+6}\]</span> 【解】首先计算极点。打开计算器，按顺序输入：<kbd>设置</kbd> <kbd>8</kbd> <kbd>2</kbd> <kbd>3</kbd>，进入求解三次多项式方程的页面。输入<kbd>1</kbd> <kbd>=</kbd> <kbd>6</kbd> <kbd>=</kbd> <kbd>1</kbd> <kbd>1</kbd> <kbd>=</kbd> <kbd>6</kbd>，将分母的多项式输入计算器。按<kbd>=</kbd>，即可得到三个根为： <span class="math display">\[-3,-1,-2\]</span> 于是<span class="math inline">\(F(s)\)</span>可以写为： <span class="math display">\[\begin{aligned}F(s)&amp;=\frac{2s^2+3s+3} {(s+1)(s+2)(s+3)}\\&amp;=\frac{K_1} {s+1}+\frac{K_2} {s+2}+\frac{K_3} {s+3}\end{aligned}\]</span> 我们看到都是单根，于是继续进行求解。</p><p>按计算器<kbd>设置</kbd> <kbd>1</kbd>返回计算模式。依次在键盘上输入<kbd>-</kbd> <kbd>1</kbd> <kbd>STO</kbd> <kbd>(-)[即A]</kbd>，屏幕上显示</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> -&gt; A<br>      <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>意思是给变量A赋值为-1.</p><p>按<kbd>AC</kbd>，在计算器上输入<span class="math inline">\((s+1)F(s)\)</span>，即： <span class="math display">\[\frac{2A^2+3A+3} {(A+2)(A+3)}\]</span> 按<kbd>=</kbd>,屏幕上的结果即为<span class="math inline">\(K_1=1\)</span></p><p>如法炮制，可以计算出<span class="math inline">\(K_2=-5,K_3=6\)</span></p><p>则原函数为 <span class="math display">\[f(t)=(e^{-t}+5e^{-2t}+6e^{-3t})u(t)\]</span></p></blockquote><h3 id="共轭复根">共轭复根</h3><p>共轭复根对应的小分式为： <span class="math display">\[\frac{K_1} {s-(a+bj)}+\frac{K_2} {s-(a-bj)}\]</span> 其中<span class="math inline">\(K_1\)</span>和<span class="math inline">\(K_2\)</span>是一对共轭复数。因为共轭复根归根结底也是单根，所以可以继续使用上面的解法来求解<span class="math inline">\(K_1,K_2\)</span>，但是只用求解其中的一个就行，因为它们共轭。假设<span class="math inline">\((a+bj)\)</span>对应的系数<span class="math inline">\(K_1=r\angle \theta=re^{i\theta}\)</span>,这对共轭复根对应的原函数为： <span class="math display">\[\begin{aligned}f(t)&amp;=re^{j\theta}e^{(a+bj)t}+re^{-j\theta}e^{(a-bj)t}\\&amp;=re^{at}(e^{j(bt+\theta)}+e^{-j(bt+\theta)})\\&amp;=2re^{at}\cos(bt+\theta)\end{aligned}\]</span></p><blockquote><p>【例】求解下式的拉普拉斯反变换： <span class="math display">\[\frac{2s+4} {s^2+2s+2}\]</span> 【解】按照上题的办法用计算器求解极点，得极点： <span class="math display">\[-1+j,-1-j\]</span> 于是原式可以写为： <span class="math display">\[\begin{aligned}F(s)&amp;=\frac{2s+4} {[s-(-1+j)][s-(-1-j)]}\\&amp;=\frac{K_1} {s-(-1+j)}+\frac{K_2} {s-(-1-j)}\end{aligned}\]</span> 下面求<span class="math inline">\(K_1\)</span>.按<kbd>设置</kbd> <kbd>2</kbd>进入复数计算模式，按<kbd>-</kbd> <kbd>1</kbd> <kbd>+</kbd> <kbd>ENG</kbd> 输入<span class="math inline">\(-1+j\)</span>，按<kbd>STO</kbd> <kbd>(-)</kbd>存入变量A中。输入 <span class="math display">\[\frac{2A+4} {A-(-1-j)}\]</span> 按<kbd>=</kbd>,屏幕上显示计算结果为<span class="math inline">\(K_1=1-j\)</span>.</p><p>按<kbd>shift</kbd> <kbd>设置</kbd> <kbd>↓</kbd> <kbd>2</kbd> <kbd>2</kbd>将复数显示切换为模长-幅角形式，屏幕上显示：<span class="math inline">\(\sqrt{2}\angle -45\)</span> ,这里的单位是度。按<kbd>shift</kbd> <kbd>设置</kbd> <kbd>2</kbd> <kbd>2</kbd>把角度单位改为弧度，屏幕上显示<span class="math inline">\(\sqrt{2}\angle -\frac{1} {4}\pi\)</span>.</p><p>那么对应的原函数为 <span class="math display">\[f(t)=2\sqrt{2}e^{-t}\cos(t-\frac{\pi} {4})u(t)\]</span></p></blockquote><h3 id="多重根">多重根</h3><p><span class="math inline">\(k\)</span>重根对应的小分式如下： <span class="math display">\[G(s)=\frac{K_1} {(s-p)^k}+\frac{K_2} {(s-p)^{k-1} }+\cdots+\frac{K_k} {s-p}\]</span> 给两边同时乘以<span class="math inline">\((s-p)^k\)</span>，有： <span class="math display">\[(s-p)^kG(s)=K_1+K_2(s-p)+\cdots +K_k(s-p)^{k-1}\]</span> 于是我们知道： <span class="math display">\[K_m=\frac{1} {(m-1)!}\frac{d^{m-1} } {ds^{m-1} }[(s-p)^kG(s)]_{s=p}\]</span> 这项对应的原函数为： <span class="math display">\[e^{pt}\left[\frac{K_1} {(k-1)!}t^{k-1}+\frac{K_2} {(k-2)!}t^{k-2}+\cdots+K_k\right]\]</span></p><blockquote><p>【例】求解下式的拉普拉斯反变换： <span class="math display">\[\frac{s^2} {(s+2)(s+1)^2}\]</span> 【解】因为题目已经帮我们因式分解好了，于是我们直接拆开： <span class="math display">\[F(s)=\frac{K_0} {s+2}+\frac{K_1} {(s+1)^2}+\frac{K_2} {s+1}\]</span> <span class="math inline">\(K_0\)</span>很容易计算，为<span class="math inline">\(4\)</span>。</p><p>对等式两端同时乘以<span class="math inline">\((s+1)^2\)</span>，有： <span class="math display">\[\frac{s^2} {s+2}=K_0\frac{(s+1)^2} {s+2}+K_1+(s+1)K_2\]</span> 将<span class="math inline">\(s=-1\)</span>代入得<span class="math inline">\(K_1=1\)</span></p><p>在计算器中输入： <span class="math display">\[\left. \frac{ {\mathbf d} } { {\mathbf d}x}\left(\frac{x^2} {x+2}\right) \right |_{x=-1}\]</span> 按等号，得<span class="math inline">\(K_2=-3\)</span>.</p><p>于是原函数为 <span class="math display">\[f(t)=(4e^{-2t}-3e^{-t}+te^{-t})u(t)\]</span></p></blockquote><h2 id="运算电路">运算电路</h2><p>运算电路说的就是在RLC电路中，通过把元件的时域<span class="math inline">\(u-i\)</span>微分方程通过拉普拉斯变换转换成代数方程然后求解的过程，其操作过程和相量法是相似的。具体来说：</p><h3 id="电阻">电阻</h3><p>形式不变，仍为<span class="math inline">\(R\)</span></p><h3 id="电容">电容</h3><p>如果电容的值为<span class="math inline">\(C\)</span>，初值条件为<span class="math inline">\(u_c(0_-)\)</span>，那么在运算电路中，电容模型变为<span class="math inline">\(\frac{1} {sC}\)</span>，并且串联一个和初值电压方向相同，值为<span class="math inline">\(\frac{1} {s}u_c(0_-)\)</span>的电压源。</p><h3 id="电感">电感</h3><p>如果电感的值为<span class="math inline">\(L\)</span>，初值条件为<span class="math inline">\(i_L(0_-)\)</span>，那么在运算电路中，电感模型变为<span class="math inline">\(Ls\)</span>，并且并联一个和初值电流方向相同的，值为<span class="math inline">\(\frac{1} {s}i_L(0_-)\)</span>的电流源。</p><h2 id="系统函数与响应的分解">系统函数与响应的分解</h2><p>在拉普拉斯变换下，系统函数有两种定义。</p><ol type="1"><li><p>基于单位冲激响应的定义： <span class="math display">\[H(s)={\mathscr L}[h(t)]=\int_{0-}^{\infty}h(t)e^{-st} {\mathbf d}t\]</span></p></li><li><p>基于一般激励的零状态响应的拉普拉斯变换<span class="math inline">\(R(s)\)</span>和激励的拉普拉斯变换<span class="math inline">\(E(s)\)</span>的比值的定义： <span class="math display">\[H(s)=\frac{R(s)} {E(s)}\]</span></p></li></ol><p>在之前的学习中，我们学过响应可以分为自由响应、强迫响应、暂态响应、稳态响应等部分，我们可以以拉普拉斯变换的视角来重新看待这些概念。</p><p>假设系统函数和输入激励只含一阶零极点，即： <span class="math display">\[H(s)=\frac{N(s)} {D(s)}=k_h\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\]</span></p><p><span class="math display">\[E(s)=k_e\frac{\prod_{l=1}^u(s-z_l)} {\prod _{k=1}^v(s-p_k)}\]</span></p><p>于是系统响应的拉普拉斯变换<span class="math inline">\(R=E\times H\)</span>为： <span class="math display">\[R(s)=k_hk_e\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\frac{\prod_{l=1}^u(s-z_l)} {\prod _{k=1}^v(s-p_k)}\]</span> 拉普拉斯逆变换，得系统的响应<span class="math inline">\(r(t)={\mathscr L}^{-1}[R(s)]\)</span>为： <span class="math display">\[r(t)=\left(\sum_{i=1}^nA_ie^{p_it}+\sum_{k=1}^vA_ke^{p_kt}\right)u(t)\]</span></p><h3 id="自由响应和强迫响应">自由响应和强迫响应</h3><p>我们可以看到，左边的求和式<span class="math inline">\(\sum_{i=1}^nA_ie^{p_it}\)</span>来自于<span class="math inline">\(H(s)\)</span>，是系统本身（的极点）决定的，对应于微分方程的齐次解。我们知道 <strong>齐次解和激励无关，所以称之为自由响应。</strong> 而<span class="math inline">\(\sum_{k=1}^vA_ke^{p_kt}\)</span>项来自于<span class="math inline">\(R(s)\)</span>，也就是微分方程的特解。我们知道 <strong>特解取决于外加激励，所以称之为强迫响应。</strong></p><h3 id="暂态响应和稳态响应">暂态响应和稳态响应</h3><p>我们将<span class="math inline">\(R(s)\)</span>的极点分成位于“左半平面”和“虚轴以及右半平面”的两类。位于左半平面的极点带来的响应会乘以一个<span class="math inline">\(e^{-at}\)</span>的系数（其中<span class="math inline">\(a&gt;0\)</span>)，因此如果时间比较长，便会近似等于<span class="math inline">\(0\)</span>。 <strong>这种左半平面的极点对应的响应是暂时的，因此称作暂态响应。</strong> 相反，位于虚轴或右半平面的极点带来的响应往往要不是<span class="math inline">\(\cos\)</span>震荡形式，要不会乘以一个<span class="math inline">\(e^{at}\)</span>的系数（其中<span class="math inline">\(a&gt;0\)</span>),这种响应 <strong>不会随着时间推移而消失，所以称为稳态响应。</strong></p><h2 id="系统框图">系统框图</h2><p>在之前的推文中其实我介绍了一种绘制系统框图的技术。现在我们来介绍一种基于拉普拉斯变换的，更简单的技术。</p><p>对于微分方程系统（<span class="math inline">\(n&gt;m\)</span>） <span class="math display">\[C_0r^{(n)}(t)+C_1r^{(n-1)}(t)+\cdots+C_nr(t)=E_0e^{(m)}(t)+E_1e^{(m-1)}(t)+\cdots+E_me(t)\]</span> 有系统函数 <span class="math display">\[H(s)=\frac{\sum_{j=0}^mE_js^{m-j} } {\sum_{i=0}^nC_is^{n-i} }\]</span> 因为我们系统框图里面一般都用积分器，所以我们也把系统函数进行一个变形（上下同除以<span class="math inline">\(s^n\)</span>）也就是把微分方程变成积分方程（方程两边进行<span class="math inline">\(n\)</span>次积分）： <span class="math display">\[H(s)=\frac{\sum_{j=0}^mE_js^{-n+m-j} } {\sum_{i=0}^nC_is^{-i} }\]</span> 这样的系统可以拆分成两个系统的级联,设置中间变量<span class="math inline">\(W(s)\)</span>： <span class="math display">\[H_1(s)=\frac{W(s)} {E(s)}=\frac 1 {\sum_{i=0}^nC_is^{-i} }\\H_2(s)=\frac{R(s)} {W(s)}=\sum_{j=0}^mE_js^{-n+m-j}\]</span> 经过变形， 有： <span class="math display">\[C_0W(s)=E(s)-W(s)\sum_{i=1}^nC_is^{-i}\\R(s)=W(s)H_2(s)\]</span> 于是框图如下所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653882298205.png" /></p><h2 id="系统幅相频特性和波特图">系统幅相频特性和波特图</h2><p>系统幅相频特性就是系统的响应随着输入信号频率的变化而变化的性质，而我们常用波特图来进行描述。波特图是一种比较特殊的绘图方式，其纵轴为<span class="math inline">\(20\lg H/\text{dB}\)</span>，横轴为<span class="math inline">\(\omega\)</span>，且横轴是对数坐标。（由于纵轴的<span class="math inline">\(\text{dB}\)</span>已经隐含了对数坐标的事实，所以其实是双对数图）</p><p>一般来说，线性时不变系统的传递函数可以写作： <span class="math display">\[H(s)=H_0\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\]</span> 其中<span class="math inline">\(\{z_1,z_2,\cdots,z_m\}\)</span>叫做系统的零点，<span class="math inline">\(\{p_1,p_2,\cdots,p_n\}\)</span>叫做系统的极点。如果一个系统稳定，那么其极点一定在左半平面，而且极点个数一定大于等于零点个数。</p><p>用<span class="math inline">\(j\omega\)</span>代替上面的<span class="math inline">\(s\)</span>，有： <span class="math display">\[H(j\omega)=H_0\frac{(j\omega-z_1)(j\omega-z_2)\cdots(j\omega-z_m)} {(j\omega-p_1)(j\omega-p_2)\cdots(j\omega-p_n)}\]</span> 取对数，因为对数可以把乘除式化为加减式，有幅频特性表达式： <span class="math display">\[\begin{aligned}20\lg H(\omega)&amp;=20\lg H_0\\&amp;+\left(20\lg \sqrt{\omega^2+z_1^2}+20\lg \sqrt{\omega^2+z_2^2}+\cdots+20\lg \sqrt{\omega^2+z_m^2}\right)\\&amp;-\left(20\lg \sqrt{\omega^2+p_1^2}+20\lg \sqrt{\omega^2+p_2^2}+\cdots+20\lg \sqrt{\omega^2+p_n^2}\right)\end{aligned}\]</span> 由于复数作积是相角相加，复数作商是相角相减，有相频表达式： <span class="math display">\[\varphi(\omega)=\tan^{-1}\left(-\frac\omega {z_1}\right )+\tan^{-1}\left(-\frac\omega {z_2}\right )+\cdots-\tan^{-1}\left(-\frac\omega {p_1}\right )-\cdots\]</span> 为表达方便，记： <span class="math display">\[\omega_z=-z,\omega_p=-p\]</span></p><h3 id="幅频波特图">幅频波特图</h3><h4 id="常数因子">常数因子</h4><p>即<span class="math inline">\(H&#39;(\omega)=K\)</span>项，有：</p><p><span class="math inline">\(20\lg H&#39;(\omega)=20\lg K\)</span>是常数</p><p><span class="math inline">\(\varphi(\omega)=0\)</span>恒为0</p><p>对应的图像如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653825965018.png" /></p><h4 id="jomega因子零零点因子"><span class="math inline">\(j\omega\)</span>因子（零零点因子）</h4><p>即<span class="math inline">\(H&#39;(\omega)=j\omega\)</span>，有：</p><p><span class="math inline">\(20\lg H&#39;(\omega)=20\lg \omega\)</span></p><p><span class="math inline">\(\varphi(\omega)=90\degree\)</span></p><p>对应的图像如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653825989648.png" /></p><h4 id="一般一阶零点因子">一般一阶零点因子</h4><p>即<span class="math inline">\(A(j\omega)=j\omega+\omega_z\)</span></p><p>可以变形为：<span class="math inline">\(A(j\omega)=\omega_z(1+\frac{j\omega} {\omega_z})\)</span></p><p>其中<span class="math inline">\(\omega_z\)</span>可以划归进常数因子，我们只需考虑<span class="math inline">\(A&#39;(\omega)=(1+j\frac{\omega} {z_i})\)</span>.有：</p><p><span class="math inline">\(20\lg A&#39;(\omega)=20\lg \sqrt{1+(\frac\omega{\omega_z})^2}\)</span></p><p><span class="math inline">\(\varphi&#39;(\omega)=\tan^{-1}\left(\frac{\omega} {\omega_z}\right)\)</span></p><p>我们观察幅频特性，它并不是一个非常容易画的函数。但是我们感性认识一下，发现它应该近似于一个线性函数。我们取零点为<span class="math inline">\(-10^1\)</span>，即<span class="math inline">\(\omega_z=10^1\)</span>，用mathematica 12绘制图像：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-number">20</span><span class="hljs-operator">*</span><span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-variable">x</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><span class="hljs-punctuation">)</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <br>  <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">100000</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826010267.png" /></p><p>我们发现它近似于一个与<span class="math inline">\(x\)</span>轴交于<span class="math inline">\(1\)</span>点，增长速度为<span class="math inline">\(20\text{dB}/\)</span>十倍频的直线。</p><p>如法炮制，绘制相频曲线：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">ArcTan</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-variable">x</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">100000</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826030142.png" /></p><p>以上两个图的横轴是<span class="math inline">\(10^x \omega_{zi}\)</span>上面的那个指数，所以你看着是<span class="math inline">\(0\)</span>的地方，其实对应的是<span class="math inline">\(1\omega_z\)</span></p><p>于是，我们可以得到近似画法：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826050805.png" /></p><h4 id="极点因子">极点因子</h4><p>即： <span class="math display">\[A(\omega)=\frac{1} {j\omega+\omega_p}\]</span></p><p>可以变形为： <span class="math display">\[A(j\omega)=\frac{1} {w_p(j\frac{\omega} {\omega_p}+1)}\]</span> 同理，<span class="math inline">\(\omega_p^{-1}\)</span>也可以划归为常数因子，则： <span class="math display">\[A&#39;(\omega)=\frac 1 {j\frac \omega {\omega_p}+1}\]</span> 有：</p><p><span class="math inline">\(20\lg A&#39;(\omega)=-20\lg \sqrt{1+(\frac{\omega} {\omega_p})^2}\)</span></p><p><span class="math inline">\(\varphi&#39;(\omega)=-\tan^{-1}(\frac{\omega} {\omega_p})\)</span></p><p>这个其实就是前面一阶零点的相反数，也就不需要再拿软件画图看性质了。这里的<span class="math inline">\(\omega_p=-p_i\)</span>.简化图如下： <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826066834.png" /></p><h4 id="作图的一般流程">作图的一般流程</h4><ol type="1"><li><p>首先求出各零、极点，将网络函数写成 <span class="math display">\[H(j\omega)=H_0\frac{(j\omega-z_1)(j\omega-z_2)\cdots(j\omega-z_m)} {(j\omega-p_1)(j\omega-p_2)\cdots(j\omega-p_n)}\]</span> 的形式。</p></li><li><p>提取各零、极点因子的常数项，把零点和极点转换成<span class="math inline">\(\omega_z,\omega_p\)</span>,把它们都变成<span class="math inline">\((1+j\frac{\omega} {\omega_z})\)</span>、<span class="math inline">\(\frac{1} {1+j\frac{\omega} {\omega_p} }\)</span>的形式。这时，有： <span class="math display">\[H(j\omega)=H(0)\frac{(1+j\frac{\omega} {\omega_{z1} })(1+j\frac{\omega} {\omega_{z2} })\cdots(1+j\frac{\omega} {\omega_{zm} })} {(1+j\frac{\omega} {\omega_{p1} })(1+j\frac{\omega} {\omega_{p2} })\cdots(1+j\frac{\omega} {\omega_{pn} })}\]</span> 其中： <span class="math display">\[H(0)=H_0\frac{\prod _{i=1}^m \omega_{zi} } {\prod_{i=1}^n \omega_{p_i} }\]</span></p></li><li><p>根据叠加原理，结合上面各个因子的图像画出波特图。</p></li></ol><h2 id="系统稳定性的判断">系统稳定性的判断</h2><p>在<strong>6.2 暂态响应和稳态响应</strong>中，我们讨论过系统零极点的位置对系统的响应的影响。即：<span class="math inline">\(H(s)\)</span>的极点如果全部位于左半平面，则系统稳定。当虚轴存在一阶零点时，称为边界稳定或者震荡稳定；当右半平面有极点，或者虚轴上有高阶极点时，称系统不稳定。</p><ol type="1"><li><p>首先基于<span class="math inline">\(H(s)=N/D\)</span>的阶次进行分析。其中<span class="math inline">\(N\)</span>是<span class="math inline">\(m\)</span>阶多项式，<span class="math inline">\(D\)</span>是<span class="math inline">\(n\)</span>阶多项式。</p><p>如果<span class="math inline">\(m&gt;n\)</span>，系统一定存在一个无穷远点处的极点。基于这个事实，有以下系统稳定的必要条件：</p><ol type="1"><li><span class="math inline">\(m\leq n\)</span>是系统稳定的必要条件</li><li><span class="math inline">\(m&gt;n+1\)</span>时，系统一定不稳定</li></ol><p>因此，我们在前面几乎只讨论<span class="math inline">\(m\leq n\)</span>的系统。</p></li><li><p>基于分母多项式的根的分布判别</p><ol type="1"><li><p>必要条件</p><ol type="1"><li><span class="math inline">\(D(s)\)</span>的所有系数都同号</li><li><span class="math inline">\(D(s)\)</span>不缺项，或者缺全部的奇次或偶次项</li></ol><p>上面两个条件是必要条件，只要任一条件不被满足，系统就不是稳定的。但是即使全部满足，系统也不一定稳定。例如： <span class="math display">\[D(s)=2s^3+s^2+3s+9\]</span></p></li><li><p>劳斯判据</p><p>劳斯判据就是列劳斯表，然后看第一列是不是全同号。劳斯表是这样列的：</p><p>前两行，第一行从前往后是<span class="math inline">\(a_n,a_{n-2},a_{n-4},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>；第二行，是<span class="math inline">\(a_{n-1},a_{n-3},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>。设劳斯表第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素是<span class="math inline">\(m_{ij}\)</span>，在第三行之后，有： <span class="math display">\[m_{ij}=-\frac{1} {m_{i-1,i} }\begin{vmatrix}m_{i-2,1} &amp; m_{i-2,j+1}\\m_{i-1,1} &amp; m_{i-1,j+1}\\\end{vmatrix}\]</span> 如果出现<span class="math inline">\(0\)</span>，那就把它替换成一个<span class="math inline">\(\varepsilon&gt;0\)</span>极小量，然后继续算。 我写了个代码来进行这个过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100+10</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">hls</span><span class="hljs-params">(<span class="hljs-type">double</span> aa, <span class="hljs-type">double</span> ab, <span class="hljs-type">double</span> ba, <span class="hljs-type">double</span> bb)</span> </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  aa ab</span><br><span class="hljs-comment">  ba bb</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> aa * bb - ab * ba;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>;<br>&#125;<br><br><span class="hljs-type">double</span> epsilon = <span class="hljs-number">0.01</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入多项式的次数：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-type">double</span> a[MAXN], lis[MAXN][MAXN];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从低到高输入系数：&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;a[i]);<br>  <span class="hljs-type">int</span> lincnt;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; (n - (<span class="hljs-number">2</span> * (j - <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span>); ++j) &#123;<br>              lis[i][j] = a[n - (<span class="hljs-number">2</span> * (j - <span class="hljs-number">1</span>))];<br>              lincnt = j;<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>              <span class="hljs-keyword">if</span> (n - (<span class="hljs-number">2</span> * j - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) lis[i][j] = a[n - (<span class="hljs-number">2</span> * j - <span class="hljs-number">1</span>)];<br>              <span class="hljs-keyword">else</span> lis[i][j] = <span class="hljs-number">0</span>;<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>              lis[i][j] = <span class="hljs-built_in">hls</span>(lis[i - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], lis[i - <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>], lis[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], lis[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) / (-lis[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(lis[i][j]) &lt; eps) &#123;<br>                  <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>                      lis[i][j] = epsilon;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  flag = <span class="hljs-number">0</span>;<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 行全为0，系统不稳定，判定结束。\n&quot;</span>, i);<br>              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>          &#125;<br><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\&quot;%d\&quot;&quot;</span>, i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%+8.2f&quot;</span>, lis[i][j]);<br>      &#125;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> f = <span class="hljs-built_in">sgn</span>(lis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sgn</span>(lis[i][<span class="hljs-number">1</span>]) != f) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 行出现异号，不稳定.\n&quot;</span>, i);<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;稳定。\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，对于<span class="math inline">\(s^4+2s^3+8s^2+3s+4\)</span>，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&quot;1&quot;   <span class="hljs-string">+1</span>.00   <span class="hljs-string">+8</span>.00   <span class="hljs-string">+4</span>.00<br>&quot;2&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+3</span>.00   <span class="hljs-string">+0</span>.00<br>&quot;3&quot;   <span class="hljs-string">+6</span>.50   <span class="hljs-string">+4</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;4&quot;   <span class="hljs-string">+1</span>.77   <span class="hljs-string">+0</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;5&quot;   <span class="hljs-string">+4</span>.00   <span class="hljs-string">-0</span>.00   <span class="hljs-string">-0</span>.00<br>稳定。<br></code></pre></td></tr></table></figure><p>对于<span class="math inline">\(2s^4+2s^3+4s^2+4s+5\)</span>，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&quot;1&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+4</span>.00   <span class="hljs-string">+5</span>.00<br>&quot;2&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+4</span>.00   <span class="hljs-string">+0</span>.00<br>&quot;3&quot;   <span class="hljs-string">+0</span>.01   <span class="hljs-string">+5</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;4&quot; <span class="hljs-string">-996</span>.00   <span class="hljs-string">+0</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;5&quot;   <span class="hljs-string">+5</span>.00   <span class="hljs-string">-0</span>.00   <span class="hljs-string">+0</span>.00<br>第 4 行出现异号，不稳定.<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数定义整理：第一弹</title>
    <link href="/2022/05/20/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <url>/2022/05/20/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p>抽象代数课程概念繁杂，而且很多概念都使用了非常非常基础的字眼（例如“群”group，不觉得这是一个在日常生活中很基础的字吗？）因此，如果对基础概念不了如指掌，做题的时候很可能连题目也看不懂。本文整理一下抽象代数里面的概念，附带很有限的批注和定理，以供速查使用。</p><span id="more"></span><h2 id="基本概念">基本概念</h2><p><strong>定义 1(代数运算)</strong> . 一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span>的映射叫做一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span> 的代数运算。其中<span class="math inline">\(A^n\)</span>到<span class="math inline">\(A\)</span>的代数运算叫做<span class="math inline">\(A\)</span>上的<span class="math inline">\(n\)</span>元 运算。</p><p>例：定义<span class="math inline">\(A=\mathbb{Z},B=\{x|x\in \mathbb{Z}\ \&amp;\ x\neq 0\},D=\mathbb{Q}\)</span>,则除法： <span class="math display">\[(a,b)\to\frac ab = a/b\]</span> 是一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span>的代数运算。但是除法并不是<span class="math inline">\(\mathbb{Q}\)</span>上的二元运算。</p><p><strong>定义 2 (结合律)</strong>. 我们说一个<span class="math inline">\(A\)</span>上的代数运算<span class="math inline">\(\circ\)</span>适合结合律， 假如对于<span class="math inline">\(A\)</span>中的任意三个元<span class="math inline">\(a,b,c\)</span>，都有 <span class="math display">\[(a\circ b)\circ c=a\circ (b\circ c)\]</span> 其中<span class="math inline">\(a,b,c\)</span>不一定不相同。</p><p><strong>定义 3 (连算)</strong>. 假如对于<span class="math inline">\(A\)</span>的不少于<span class="math inline">\(2\)</span>个固定的元<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，对于下列的符号 <span class="math display">\[a_1\circ a_2 \circ \cdots a_n\]</span> 的任意一种加括号的方式<span class="math inline">\(\pi_i(a_1\circ a_2 \circ \cdots a_n)\)</span>都相等， 那么我们就把这些所有的<span class="math inline">\(\pi_i\)</span>用 <span class="math display">\[a_1\circ a_2 \circ \cdots a_n\]</span> 来表示， 叫做连算。</p><p>事实上，如果<span class="math inline">\(\circ\)</span>适合结合律，那么连算就存在。</p><p><strong>定义 4 (交换律)</strong>. 我们说一个<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(D\)</span>的代数运算<span class="math inline">\(\circ\)</span>适合交换律， 假如对于<span class="math inline">\(A\)</span>上的任意两个元<span class="math inline">\(a,b\)</span>，有： <span class="math display">\[a\circ b=b\circ a\]</span></p><p>事实上，如果<span class="math inline">\(\circ\)</span>同时适合交换律和结合律，那么连算式中 的元顺序就可以任意交换。</p><p><strong>定义 5 (分配律)</strong>. 对于<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span></p><p><span class="math inline">\(\bigotimes\)</span>是一个<span class="math inline">\(B\times A\)</span>到<span class="math inline">\(A\)</span>的代数运算。</p><p><span class="math inline">\(\bigoplus\)</span>是一个<span class="math inline">\(A\)</span>的代数运算。</p><p>假如对于<span class="math inline">\(B\)</span>的任意<span class="math inline">\(b\)</span>，<span class="math inline">\(A\)</span>的任意<span class="math inline">\(a_1,a_2\)</span>来说：</p><ol type="1"><li><p>有左分配律：假如 <span class="math display">\[b\bigotimes(a_1\bigoplus a_2)=(b\bigotimes a_1)\bigoplus(b\bigotimes a_2)\]</span></p></li><li><p>有右分配律：假如 <span class="math display">\[(a_1\bigoplus a_2)\bigotimes b=(a_1 \bigotimes b)\bigoplus(a_2 \bigotimes b )\]</span></p></li></ol><p><strong>定义 6 (满射)</strong>. 若是在一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>下，<span class="math inline">\(\bar{A}\)</span>的 每一个元都至少是<span class="math inline">\(A\)</span>中某一个元的象，那么<span class="math inline">\(\phi\)</span>叫做一个<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的 满射。</p><p>例如，<span class="math inline">\(f(x)=\sin(x)\)</span>就不是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的满射，因为不存在<span class="math inline">\(x\in \mathbb{R},f(x)=2\)</span> 但是，<span class="math inline">\(f(x)=\ln(x)\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的满射。</p><p><strong>定义 7 (单射)</strong>. 一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>，假如 <span class="math display">\[a\neq b\to \bar{a}\neq \bar{b}\]</span> 那么<span class="math inline">\(\phi\)</span>是一个单射。</p><p>例如，<span class="math inline">\(f(x)=x^2\)</span>就不是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的单射，因为<span class="math inline">\(1\neq -1\)</span>但是<span class="math inline">\(f(1)=f(-1)\)</span>. 但是，<span class="math inline">\(f(x)=e^x\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的单射。</p><p><strong>定义 8(一一映射)</strong> . 如果集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>既是满射又是单射，那么它就是一一映射。 一一映射的逆是一个<span class="math inline">\(\bar{A}\to A\)</span>的一一映射，用<span class="math inline">\(\phi^{-1}\)</span>表示。</p><p>例如，<span class="math inline">\(f(x)=x^3\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的一一映射。</p><p><strong>定义 9 (变换)</strong>. 一个<span class="math inline">\(A\to A\)</span>的映射叫做变换。</p><p><strong>定义 10 (同态映射)</strong>. 一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>叫做对于代数运算 <span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>的同态映射，假如在<span class="math inline">\(\phi\)</span>之下， 对于<span class="math inline">\(\forall a,b \in A\)</span>，只要 <span class="math display">\[a\to \bar{a},b\to \bar{b}\]</span> 就有。 <span class="math display">\[a\circ b\to \bar{a}\bar{\circ}\bar{b}\]</span> 如果<span class="math inline">\(\phi\)</span>还是个满射，那么就叫做同态满射。</p><p><strong>定义 11 (同构映射)</strong>. 如果一个同态满射还是一一映射，那么它就是同构映射。 如果<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同构，记作： <span class="math display">\[A\cong \bar{A}\]</span></p><p>事实上，如果对于<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>来说，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同构， 那么我们可以说，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>这两个集合对于这两个运算来说除了名字 以外没有区别。</p><p><strong>定义 12 (自同构)</strong>. 对于<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\circ\)</span>来说的一个<span class="math inline">\(A\to A\)</span>的同构映射称为一个对于<span class="math inline">\(\circ\)</span>来说的<span class="math inline">\(A\)</span>的自同构。</p><p><strong>定义 13 (关系)</strong>. 一个<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(\{T,F\}\)</span>的映射<span class="math inline">\(R\)</span>称作<span class="math inline">\(A\)</span>的元 之间的一个关系。如果<span class="math inline">\(R(a,b)=T\)</span>，那么称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>符合 这个关系，记作：<span class="math inline">\(aRb\)</span></p><p><strong>定义 14 (等价关系)</strong>. 如果关系<span class="math inline">\(\sim\)</span>满足以下三点：</p><ol type="1"><li><p><span class="math inline">\(\forall a\in A,a\sim a\)</span></p></li><li><p><span class="math inline">\(\forall a,b\in A,a\sim b\to b\sim a\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in A,a\sim b\wedge b\sim c\to a\sim c\)</span></p></li></ol><p>那么称这个关系为等价关系。</p><p>常见的等价关系有：等于、同余、矩阵相似、矩阵合同等。</p><p><strong>定义 15(分类)</strong> . 如果把集合<span class="math inline">\(A\)</span>分成若干个称作类的子集，使得A的每个元属于且仅属于一个 类，那么这些类的全体叫做集合<span class="math inline">\(A\)</span>的一个分类。</p><p>集合的一个分类决定了集合的元之间的一个等价关系。 集合的元之间的一个等价关系决定了集合的一个分类。</p><p><strong>定义 16 (代表和代表团)</strong>. 假如有一个集合的一个分类，那么一个类里面的任意一个元 叫做这个类的一个代表，由每个类的一个代表组成的集合叫做这个集合 的代表团。</p><h2 id="群论">群论</h2><p><strong>定义 17 (群的第一定义)</strong>. 一个不空集合<span class="math inline">\(G\)</span>和一个叫做乘法的代数运算组成的结构叫做一个群，如果：</p><ol type="1"><li><p>*<span class="math inline">\(\forall a,b\in G,ab\in G\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in G,a(bc)=(ab)c\)</span></p></li><li><p><span class="math inline">\(\forall a,b \in G,\exists x,y\in G\ {\mathbf s.t.} ax=b\wedge ya=b\)</span></p></li></ol><p><strong>定义 18 (群的第二定义)</strong>. 一个不空集合<span class="math inline">\(G\)</span>和一个叫做乘法的代数运算组成的结构叫做一个群，如果：</p><ol type="1"><li><p><span class="math inline">\(\forall a,b\in G,ab\in G\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in G,a(bc)=(ab)c\)</span></p></li><li><p><span class="math inline">\(\exists e\in G ,\forall a\in G,ea=a\)</span>,这个<span class="math inline">\(e\)</span>叫做左单位元</p></li><li><p><span class="math inline">\(\forall a\in G, \exists a^{-1}\in G,a^{-1}a=e\)</span></p></li></ol><p><strong>定义 19 (群的阶)</strong>. 一个元素有限的群叫做有限群，一个元素无限的群叫做无限群。 有限群元的个数叫做群的阶。</p><p><strong>定义 20 (交换群)</strong>. 如果<span class="math inline">\(\forall a,b\in G,ab=ba\)</span>，那么群<span class="math inline">\((G,\cdot)\)</span>称为交换群，也叫阿贝尔群。</p><p><strong>定义 21 (单位元)</strong>. 一个群<span class="math inline">\(G\)</span>的<strong>唯一</strong>能使 <span class="math display">\[ea=ae=e\]</span> 的元叫做群<span class="math inline">\(G\)</span>的单位元。</p><p><strong>定义 22 (逆元)</strong>. 对于群<span class="math inline">\(G\)</span>的每一个元<span class="math inline">\(a\)</span>，<span class="math inline">\(G\)</span>中存在<strong>唯一</strong>的一个元<span class="math inline">\(a^{-1}\)</span>， 使得 <span class="math display">\[a^{-1}a=aa^{-1}=e\]</span> 这个<span class="math inline">\(a^{-1}\)</span>叫做群<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的逆元。</p><p><strong>定义 23 (群中元素的阶）</strong>. 对于群<span class="math inline">\(G\)</span>中的一个元素<span class="math inline">\(a\)</span>,能够使得 <span class="math display">\[a^m=e\]</span> 的最小的正整数<span class="math inline">\(m\)</span>称作<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的阶。如果 不存在这样的<span class="math inline">\(m\)</span>，那么称元素<span class="math inline">\(a\)</span>的阶为无穷大。</p><p>例如：</p><ol type="1"><li><p>对于群<span class="math inline">\((\mathbb{R}+,\times)\)</span>,<span class="math inline">\(1\)</span>的阶为<span class="math inline">\(1\)</span>，其余每个元素的阶为<span class="math inline">\(\infty\)</span>.</p></li><li><p>对于群<span class="math inline">\((\{x|x^3=1,x\in \mathbb{C}\},\times)\)</span>,<span class="math inline">\(1\)</span>的阶为<span class="math inline">\(1\)</span>，其余元素的阶为<span class="math inline">\(3\)</span>.</p></li></ol><p><strong>定理 1 (消去律)</strong>. 一个群的乘法适合消去律： <span class="math display">\[\begin{cases}            ax=ax&#39; \to x=x&#39;\\            ya=y&#39;a \to y=y&#39;\\        \end{cases}\]</span></p><p><strong>定义 24 (有限群的另一定义)</strong>. 一个乘法和一个有限集合构成一个群，假如"封闭性"、"结合律"和"消去律"能被满足。</p><p><strong>定义 25 (变换群)</strong>. 首先我们用一种特殊的记法来表示变换： <span class="math display">\[\tau : a\to a&#39;=a^\tau\]</span> 我们把一个集合的所有变换放到一个集合里： <span class="math display">\[S=\{\tau,\lambda,\mu,\cdots\}\]</span> 看这个集合中的两个元<span class="math inline">\(\tau,\lambda\)</span>： <span class="math display">\[t:a\to a^\tau,\lambda:a\to a^\lambda\]</span> 于是给了一个元<span class="math inline">\(a\)</span>，我们可以得出一个唯一的元<span class="math inline">\((a^\tau)^\lambda\)</span>. 我们规定变换的乘积： <span class="math display">\[\tau\lambda : a\to (a^\tau)^\lambda=a^{\tau\lambda}\]</span> 那么一个集合<span class="math inline">\(A\)</span>的若干个一一变换对于上述规定的乘法作成的群叫做<span class="math inline">\(A\)</span>的一个变换群。</p><p>事实上，任何一个群都和一个变换群同构，任意一个抽象的群都能在变换群中找到一个具体的例子。</p><p><strong>定义 26 (置换)</strong>. 一个有限集合的一个一一变换叫做一个置换。</p><p><strong>定义 27(对称群)</strong> . 一个包含<span class="math inline">\(n\)</span>个元的集合的全体置换作成的群叫做<span class="math inline">\(n\)</span>次对称群，记作：<span class="math inline">\(S_n\)</span>.</p><p><strong>定义 28 (<span class="math inline">\(k\)</span>-循环置换)</strong>. <span class="math inline">\(S_n\)</span>中的一个把<span class="math inline">\(a_{i_1}\)</span>变到<span class="math inline">\(a_{i_2}\)</span>,把<span class="math inline">\(a_{i_2}\)</span>变到<span class="math inline">\(a_{i_3}\)</span>,<span class="math inline">\(\cdots\)</span> ,把<span class="math inline">\(a_{i_k}\)</span>变到<span class="math inline">\(a_{i_1}\)</span>，而使其它元不变的置换，叫做<span class="math inline">\(k\)</span>-循环置换。这样的 循环置换可以用以下<span class="math inline">\(k\)</span>个符号同时表示： <span class="math display">\[(i_1i_2\cdots i_k),(i_2i_3\cdots i_ki_1),\cdots (i_ki_1\cdots i_{k-1})\]</span></p><p>事实上，每个<span class="math inline">\(n\)</span>元置换<span class="math inline">\(\pi\)</span>都能写成若干个没有重复数字的循环置换的乘积。 事实上，每个有限群都和一个置换群同构。</p><p><strong>定义 29 (循环群)</strong>. 如果一个群<span class="math inline">\(G\)</span>的每一个元都是其中某一个固定元<span class="math inline">\(a\)</span>的乘方，那么 我们把<span class="math inline">\(G\)</span>叫做循环群，并用符号<span class="math inline">\(G=(a)\)</span>来表示，其中<span class="math inline">\(a\)</span>叫做<span class="math inline">\(G\)</span>的生成元。</p><p>其实<span class="math inline">\(G\)</span>的构造完全由<span class="math inline">\(a\)</span>的阶数<span class="math inline">\(n\)</span>决定。如果有限，那么<span class="math inline">\(G\)</span>同构于整数加群，否则 同构于模<span class="math inline">\(n\)</span>剩余类加群。</p><p><strong>定义 30 (子群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子集<span class="math inline">\(H\)</span>叫做<span class="math inline">\(G\)</span>的一个子群，假如 <span class="math inline">\(H\)</span>对于<span class="math inline">\(G\)</span>的乘法来说也构成一个群。</p><p><strong>定义 31 (陪集)</strong>. 对于一个群<span class="math inline">\(G\)</span>和它的一个子群<span class="math inline">\(H\)</span>,我们规定一个关系<span class="math inline">\(\sim\)</span>: <span class="math display">\[a\sim b \leftrightarrow ab^{-1}\in H\]</span> 那么由上述等价关系<span class="math inline">\(\sim\)</span>所决定的类叫做子群<span class="math inline">\(H\)</span>的右陪集，记作： <span class="math inline">\(Ha\)</span>，它刚好包含所有能写成 <span class="math inline">\(ha (h\in H)\)</span> 的<span class="math inline">\(G\)</span>的元。</p><p>如果把等价关系的定义换成： <span class="math display">\[a\sim b \leftrightarrow b^{-1}a\in H\]</span> 包含元<span class="math inline">\(a\)</span>的陪集叫做左陪集，用<span class="math inline">\(aH\)</span>表示。</p><p><strong>定义 32 (指数)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(H\)</span>的右陪集或左陪集（事实上，这俩一定相等）的个数 叫做<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>里的指数。</p><p><strong>定义 33 (不变子群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(N\)</span>叫做<span class="math inline">\(G\)</span>的不变子群，有：<span class="math inline">\(\forall a\in G,Na=aN\)</span></p><p>一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(N\)</span>是不变子群的充分必要条件是：<span class="math inline">\(\forall a\in G,n\in N \to ana^{-1}\in N\)</span></p><p><strong>定义 34 (中心)</strong>. 如果<span class="math inline">\(N\)</span>包含<span class="math inline">\(G\)</span>中所有有以下性质的元<span class="math inline">\(n\)</span>: <span class="math display">\[\forall a\in G,na=an\]</span> 那么<span class="math inline">\(N\)</span>是<span class="math inline">\(G\)</span>的一个不变子群。这个不变子群叫做中心。</p><p>简言之：中心和<span class="math inline">\(G\)</span>的每个元素可交换。</p><p><strong>定义 35 (商群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个不变子群<span class="math inline">\(N\)</span>的陪集作成的集合<span class="math inline">\(S\)</span>对于集合乘法构成一个群， 这个群叫做商群，记作<span class="math inline">\(G/N\)</span>.这里的"乘法"，指的是： <span class="math inline">\((xN)(yN)=(xy)N\)</span></p><p>一个群<span class="math inline">\(G\)</span>和它的每一个商群同态。</p><p><strong>定义 36 (核)</strong>. 如果<span class="math inline">\(\phi\)</span>是群<span class="math inline">\(G\)</span>到<span class="math inline">\(\bar{G}\)</span>的同态满射，那么<span class="math inline">\(\bar{G}\)</span> 的单位元<span class="math inline">\(\bar{e}\)</span>在<span class="math inline">\(\phi\)</span>下的所有逆象称为同态满射<span class="math inline">\(\phi\)</span>的核。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于微分方程和系统框图的那些事</title>
    <link href="/2022/05/18/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/05/18/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>昨天做了做作业，发现有通过系统框图写微分方程、和通过微分方程画系统框图这两种题目。初看完全摸不着头脑，但是只要把握<span class="math inline">\(LTI\)</span>系统的性质就很简单了。</p><span id="more"></span><h2 id="怎么通过系统框图写微分方程">怎么通过系统框图写微分方程？</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837378264.png" /></p><p>我们很容易想到，首先设一个中间变量<span class="math inline">\(x(t)\)</span>，这里我把<span class="math inline">\(x(t)\)</span>放在第二个积分器和<span class="math inline">\(\frac{1}{2}\)</span>倍乘器中间。那么两个积分器之间的信号就是<span class="math inline">\(x&#39;(t)\)</span>，第一个积分器前的信号就是<span class="math inline">\(x&#39;&#39;(t)\)</span>，根据两个累加器，我们可以列出方程： <span class="math display">\[\begin{cases}r(t)=-\frac{3}{2}x&#39;(t)+\frac{1}{2}x(t)\\e(t)+\frac{3}{8}x(t)-\frac{1}{4}x&#39;(t)=x&#39;&#39;(t)\end{cases}\]</span> 整理得： <span class="math display">\[\begin{cases}r(t)=-\frac{3}{2}x&#39;(t)+\frac{1}{2}x(t)\\e(t)=-\frac{3}{8}x(t)+\frac{1}{4}x&#39;(t)+x&#39;&#39;(t)\end{cases}\]</span> 那然后怎么消掉<span class="math inline">\(x(t)\)</span>呢？有人说，线性变换，加加减减就行了呀。没错，非常正确，但是我算不出来。我想了一想，发现了一种方法，可以立刻就把微分方程写出来：只需要把第<span class="math inline">\(2\)</span>个式子右边的<span class="math inline">\(&#39;x&#39;\)</span>统一换成<span class="math inline">\(&#39;r&#39;\)</span>，写在等号左边，然后把第<span class="math inline">\(1\)</span>个式子右边的<span class="math inline">\(&#39;x&#39;\)</span>统一换成<span class="math inline">\(&#39;e&#39;\)</span>，写在等号的右边，就大功告成啦！对这个题来说，就是： <span class="math display">\[r&#39;&#39;(t)+\frac{1}{4}r&#39;(t)-\frac{3}{8}r(t)=-\frac{3}{2}e&#39;(t)+\frac{1}{2}e(t)\]</span> 这么简单么？只替换两个字符就行了？为啥啊？其实，这利用了<span class="math inline">\(LTI\)</span>系统的性质。</p><p>我们把第二个式子也看作一个线性系统，输入<span class="math inline">\(e(t)\)</span>，输出<span class="math inline">\(x(t)\)</span>。那么如果我们把输入改为 <span class="math display">\[\frac{1}{2}e(t)-\frac{3}{2}e&#39;(t)\]</span> 此时这个小系统的输出是什么呢？显然，是 <span class="math display">\[\frac{1}{2}x(t)-\frac{3}{2}x&#39;(t)\]</span> 这是什么呢？结合方程组第一个式子，我们发现这就是<span class="math inline">\(r(t)\)</span>。</p><p>对于第二个式子所代表的,输入<span class="math inline">\(e\)</span>输出<span class="math inline">\(x\)</span>的系统 <span class="math display">\[e(t)=-\frac{3}{8}x(t)+\frac{1}{4}x&#39;(t)+x&#39;&#39;(t)\]</span> 现在我们输入了<span class="math inline">\(\frac{1}{2}e(t)-\frac{3}{2}e&#39;(t)\)</span>,输出了<span class="math inline">\(r(t)\)</span>，那么填进去，就有： <span class="math display">\[r&#39;&#39;(t)+\frac{1}{4}r&#39;(t)-\frac{3}{8}r(t)=-\frac{3}{2}e&#39;(t)+\frac{1}{2}e(t)\]</span> 完毕。</p><h2 id="怎么通过微分方程画系统框图">怎么通过微分方程画系统框图</h2><p>例如： <span class="math display">\[r&#39;&#39;(t)+5r&#39;(t)+6r(t)=9e&#39;(t)+5e(t)\]</span> 这个系统相对来说还是比较复杂的。我们遵循上一部分的思路，逆过来思考。</p><ol type="1"><li><p>设<span class="math inline">\(x(t)\)</span>是系统输入为<span class="math inline">\(e(t)\)</span>时的输出，即： <span class="math display">\[x&#39;&#39;(t)+5x&#39;(t)+6x(t)=e(t)\]</span></p></li><li><p>这时由于<span class="math inline">\(LTI\)</span>系统的线性时不变性质（把上面那个式子右边的<span class="math inline">\(e(t)\)</span>变成<span class="math inline">\(9e&#39;(t)+5e(t)\)</span>），有： <span class="math display">\[r(t)=9x&#39;(t)+5x(t)\]</span></p></li><li><p>把1.中的式子进行一个移项，变成： <span class="math display">\[x&#39;&#39;(t)=e(t)-5x&#39;(t)-6x(t)\]</span></p></li><li><p>现在可以开始画图了。因为是二阶系统，所以先画2个积分器，标上<span class="math inline">\(x(t)\)</span>,再画上加法器</p></li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837311836.png" /></p><ol start="5" type="1"><li>我们知道加法器是等号的来源，把上面两个等式画上去，就完成啦。</li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837321749.png" /></p><p>好了，现在你已经是系统框图大师啦！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种基于纯C语言的函数绘图解决方案</title>
    <link href="/2022/05/16/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BA%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/05/16/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BA%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>本文尝试实现一种利用C语言绘制函数图像的方法。最终输出为PPM格式图片。 <span id="more"></span></p><h2 id="一ppm图片格式">一、PPM图片格式</h2><p>我们首先来看一下我们的问题：怎么用纯C语言写一个<code>plot()</code>函数。那么我们迎面而来遇到的第一个问题就是：我们平常使用的C语言，往往是在一个黑框框里面输入一堆数字，然后输出一堆数字，而现在却要展示一张图片，这怎么做呢？但是我们静下心来想一想，就会发现所谓的图片实际上也是文件，而文件就是可以用C语言的<code>freopen</code>读写的。但是我们平时读写的都是纯文本文件，现在却要写入一张图片文件。怎么做到呢？这时就需要一种非常简单的图片编码：PPM格式。</p><p>PPM格式是 Netpbm <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Netpbm#File_formats">[1]</span></a></sup>的一部分。这个项目使用和定义了几种图形格式。便携式像素映射格式（PPM）、便携式灰图格式（PGM） 和便携式位图格式（PBM） ，旨在便于在平台之间交换。</p><p>一个PPM文件由两部分组成，即文件头和数据流。文件头的第一部分是一个Magic Number，格式为<code>P%d</code>，表示了文件的类型，具体如下表所示：</p><table><thead><tr class="header"><th>类型</th><th>ASCII （普通）</th><th><strong>二进制（原始）</strong></th></tr></thead><tbody><tr class="odd"><td>便携式位图（PBM）</td><td>P1</td><td>P4</td></tr><tr class="even"><td>便携式灰度图（PGM）</td><td>P2</td><td>P5</td></tr><tr class="odd"><td>便携式像素映像（PPM）</td><td>P3</td><td>P6</td></tr></tbody></table><p>文件头的第二部分是两个数字，表示了图像的宽度和高度。</p><p>而PGM和PPM文件的文件头有第三部分，是一个数字，表示颜色（分量）的最大值。</p><p>数据流部分是以矩阵形式显示的像素点。接下来我们看几个例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">P1</span><br><span class="hljs-comment"># This is an example bitmap of the letter &quot;J&quot;</span><br><span class="hljs-attribute">6</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669222979.png" alt="123" /><figcaption aria-hidden="true">123</figcaption></figure><p>这是一个PBM（位图）格式的文件，其中0表示白色，1表示黑色。显示成图片的话是这个样子（放大了20倍）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">P2</span><br><span class="hljs-comment"># Shows the word &quot;FEEP&quot; (example from Netpbm man page on PGM)</span><br><span class="hljs-attribute">24</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">15</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个一个PGM（灰度图）的例子，我们可以看到第四行，这就是所谓“颜色（分量）的最大值”。它对应的图片是这个样子（当然也经过了放大）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669278002.png" /></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">P3           <span class="hljs-comment"># &quot;P3&quot; means this is a RGB color image in ASCII</span><br>3<span class="hljs-number"> 2 </span>         <span class="hljs-comment"># &quot;3 2&quot; is the width and height of the image in pixels</span><br>255          <span class="hljs-comment"># &quot;255&quot; is the maximum value for each color</span><br><span class="hljs-comment"># The part above is the header</span><br><span class="hljs-comment"># The part below is the image data: RGB triplets</span><br>255  <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># red</span><br> <span class="hljs-number"> 0 </span>255  <span class="hljs-number"> 0 </span> <span class="hljs-comment"># green</span><br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span>255  <span class="hljs-comment"># blue</span><br>255<span class="hljs-number"> 255 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># yellow</span><br>255<span class="hljs-number"> 255 </span>255  <span class="hljs-comment"># white</span><br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># black</span><br></code></pre></td></tr></table></figure><p>这是一个PPM图片的例子，我们可以看到每个像素点使用了三个数字来指定颜色，也就是我们所说的RGB。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669396133.png" /></p><p>到这里，你应该已经掌握了PPM格式图片怎么写了吧！</p><h2 id="二定义函数表">二、定义函数表</h2><p>为了方便绘图，首先我们定义PPM数据类型，由RGB三个颜色分量组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br></code></pre></td></tr></table></figure><p>这个结构体的构造函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span>;<br></code></pre></td></tr></table></figure><p>主要执行绘图功能的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span>;<br></code></pre></td></tr></table></figure><p>其中各参数的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>char *name</code></td><td>输出文件的文件名</td></tr><tr class="even"><td><code>PPMdata **matrix</code></td><td>PPM文件流矩阵，大小至少为height*width</td></tr><tr class="odd"><td><code>const double *x</code></td><td>采样点x坐标</td></tr><tr class="even"><td><code>double *y</code></td><td>采样点y坐标</td></tr><tr class="odd"><td><code>int width</code></td><td>整个图像的宽度 单位：像素</td></tr><tr class="even"><td><code>int height</code></td><td>整个图像的高度 单位：像素</td></tr><tr class="odd"><td><code>int arrayLen</code></td><td>采样点的数目</td></tr><tr class="even"><td><code>double centerX</code></td><td>图片中心点对应的直角坐标X</td></tr><tr class="odd"><td><code>double centerY</code></td><td>图片中心点对应的直角坐标Y</td></tr><tr class="even"><td><code>double rangeX</code></td><td>X直角坐标范围</td></tr><tr class="odd"><td><code>double rangeY</code></td><td>Y直角坐标范围</td></tr><tr class="even"><td><code>double gridX</code></td><td>X网格宽度（单位：直角坐标）</td></tr><tr class="odd"><td><code>double gridY</code></td><td>Y网格宽度（单位：直角坐标）</td></tr></tbody></table><p>将直角坐标量转化为像素量（矩阵下标量）的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span>;<br></code></pre></td></tr></table></figure><p>其中各参数的意义为：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>double num</code></td><td>待转换的直角坐标量x</td></tr><tr class="even"><td><code>double center</code></td><td>图片该方向中心点对应的直角坐标c</td></tr><tr class="odd"><td><code>double range</code></td><td>该方向直角坐标范围r</td></tr><tr class="even"><td><code>int picLen</code></td><td>图片该方向的像素大小p</td></tr></tbody></table><p>转换公式为： <span class="math display">\[p\left(\frac 12+\frac{x-c}{r}\right)\]</span> 在图像上绘制坐标点的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span><br></code></pre></td></tr></table></figure><p>各新参数的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>int x</code></td><td>要绘制的点的像素X坐标</td></tr><tr class="even"><td><code>int y</code></td><td>要绘制的点的像素Y坐标</td></tr><tr class="odd"><td><code>PPMdata color</code></td><td>颜色</td></tr><tr class="even"><td><code>int size</code></td><td>点的大小，最后绘制出来是一个<span class="math inline">\(2size+1\)</span>边长的正方形</td></tr></tbody></table><p>将<code>PPMdata</code>数据矩阵转换为<code>.ppm</code>图像文件的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName,PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br></code></pre></td></tr></table></figure><p>没有新的参数。</p><p>由于绘图时采用分段线性拟合算法，定义线性函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br></code></pre></td></tr></table></figure><p>这个定义的意思是：<span class="math inline">\(y=\text{linerFunc}(x_1,y_1,x_2,y_2,x)\)</span>表示一条经过<span class="math inline">\((x_1,y_2)\)</span>和<span class="math inline">\((x_2,y_2)\)</span>，以<span class="math inline">\(x\)</span>为自变量的直线。直线方程为： <span class="math display">\[y=(x-x_1)\frac{y_2-y_1}{x_2-x_1}+y_1\]</span></p><h2 id="三实现函数">三、实现函数</h2><p>这部分以<code>arrayToPPM()</code>函数的实现为主线，完整介绍各个函数的实现方法。</p><h3 id="第一步检测数据的合法性">第一步，检测数据的合法性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: X is not increasing.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: X out of range.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br>        <span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，为了方便，我们强制把像素大小设置为偶数。然后主要检查三个事：</p><ol type="1"><li><span class="math inline">\(x\)</span>坐标是否严格单调递增。若不是，返回错误并退出。</li><li><span class="math inline">\(x\)</span>坐标是否在范围内。若不是，返回错误并退出。</li><li><span class="math inline">\(y\)</span>坐标是否在范围内。若不是，强制将其设置在范围内。</li></ol><h3 id="第二步定义ppmdata颜色">第二步，定义PPMdata颜色。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">PPMdata background, axis, grid, line;<br>background = makePPMdata(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = makePPMdata(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = makePPMdata(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = makePPMdata(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br></code></pre></td></tr></table></figure><p>各变量的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>background</code></td><td>背景颜色</td></tr><tr class="even"><td><code>axis</code></td><td>主坐标轴颜色</td></tr><tr class="odd"><td><code>grid</code></td><td>网格颜色</td></tr><tr class="even"><td><code>line</code></td><td>要画的函数的颜色</td></tr></tbody></table><p>这里就用配色软件找一个好看的颜色就行。</p><h3 id="第三步绘制背景板">第三步，绘制背景板</h3><ol type="1"><li><p>画背景</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>        matrix[i][j] = background;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>画网格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br>        drawPoint(matrix, width, height, numToMatPos(centerX + i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>        drawPoint(matrix, width, height, numToMatPos(centerX - i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//纵向网格</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>        drawPoint(matrix, width, height, j, numToMatPos(centerY + i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>        drawPoint(matrix, width, height, j, numToMatPos(centerY - i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//横向网格</span><br></code></pre></td></tr></table></figure></li><li><p>画主坐标轴</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br>    drawPoint(matrix, width, height, i, height / <span class="hljs-number">2</span>, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>    drawPoint(matrix, width, height, width / <span class="hljs-number">2</span>, i, axis, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的“主坐标轴”，恒定位于图像的正中心。</p></li></ol><p>这里涉及到了<code>drawPoint()</code>函数。它的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br>            <span class="hljs-type">int</span> u = x + i, v = y + j;<br>            <span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">else</span> matrix[v][u] = color;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要还是要检测是不是越界了，不然容易<code>RE</code>.还有一个需要注意的地方就是第6行，这里的x和y互换了。为什么要互换呢？我们想一想矩阵下标的顺序和坐标的顺序有什么区别就好了。</p><h3 id="第四步画函数">第四步，画函数</h3><p>我们经过了这么长的准备，终于要开始画函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> stepX = rangeX / width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> X = centerX - rangeX / <span class="hljs-number">2</span>; X &lt; centerX + rangeX / <span class="hljs-number">2</span>; X += stepX) &#123;<br>    <span class="hljs-type">int</span> linerIndex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (X &lt; x[i]) &#123;<br>            linerIndex = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (linerIndex == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">double</span> u, v, Y;<br>        u = numToMatPos(X, centerX, rangeX, width);<br>        Y = linerFunc(x[linerIndex], y[linerIndex], x[linerIndex + <span class="hljs-number">1</span>], y[linerIndex + <span class="hljs-number">1</span>], X);<br>        v = numToMatPos(Y, centerY, rangeY, height);<br>        drawPoint(matrix, width, height, u, v, line, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然我们用的是分段线性拟合法，那么就要确认当前在哪个段里，也就是代码中的<code>linerIndex</code>变量。</p><p><code>X</code>就是枚举变量。如果当前比<code>x[]</code>数列中的最小值还小，那么不应该有图像，否则找到当前所在的段，然后画一条线段。</p><h3 id="第五步写文件">第五步，写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">matToPPM(name, matrix, width, height);<br></code></pre></td></tr></table></figure><p>这里<code>matToPPM</code>函数的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>    freopen(fileName, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    fclose(<span class="hljs-built_in">stdout</span>);<br>    freopen(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是重定向，输出，再重定向回来，没什么特别值得说明的。</p><h2 id="四试用一下">四、试用一下</h2><p>我们把上面那一堆函数和实现打包到一个<code>.h</code>文件里。然后我们写个代码调用一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> x[<span class="hljs-number">1001</span>], y[<span class="hljs-number">1001</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.1</span>) &#123;<br>        x[cnt] = i;<br>        y[cnt] = <span class="hljs-built_in">sin</span>(i*<span class="hljs-number">2.0</span>)/(i*<span class="hljs-number">2.0</span>);<br>        ++cnt;<br>    &#125;<br>    <span class="hljs-comment">//创建matrix 矩阵</span><br>    PPMdata **matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PPMdata *) * <span class="hljs-number">1080</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1080</span>; i++) <br>        matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1920</span>, <span class="hljs-keyword">sizeof</span>(PPMdata));<br>    <span class="hljs-type">char</span> c[]=<span class="hljs-string">&quot;out.ppm&quot;</span>;<br>    arrayToPPM(c, matrix, x, y, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3.14159</span>/<span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;complete.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码的功能是绘制 <span class="math display">\[y=\frac{\sin 2x}{2x}\]</span> 的图像。</p><p>编译运行，在目录下输出了一个<code>out.ppm</code>文件，打开：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669362308.png" /></p><p>大功告成咯！</p><h2 id="五更多讨论">五、更多讨论</h2><p>这个代码存在以下问题：</p><ol type="1"><li>面对函数变化率特别高的情况下表现不理想，会有间断的情况，如下图所示：</li></ol><p><span class="math display">\[   y=\tan x\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669353744.png" /></p><ol start="2" type="1"><li>需要人工指定的变量太多，日后我会开发一版能自动适应采样点，选择合适的坐标、范围的绘图函数。</li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://en.wikipedia.org/wiki/Netpbm#File_formats <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验2：信号的矩形脉冲抽样与恢复</title>
    <link href="/2022/05/10/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A2/"/>
    <url>/2022/05/10/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A2/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第二个实验，信号的矩形脉冲抽样与恢复</p><span id="more"></span><h2 id="一实验结果展示">一、实验结果展示</h2><h3 id="各频域图像">各频域图像</h3><ol type="1"><li><p><span class="math inline">\(F(\omega)\)</span>原始频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130549021.png" alt="image-20220604130549021" /><figcaption aria-hidden="true">image-20220604130549021</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130602889.png" alt="image-20220604130602889" /><figcaption aria-hidden="true">image-20220604130602889</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130625486.png" alt="image-20220604130625486" /><figcaption aria-hidden="true">image-20220604130625486</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130636810.png" alt="image-20220604130636810" /><figcaption aria-hidden="true">image-20220604130636810</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130648381.png" alt="image-20220604130648381" /><figcaption aria-hidden="true">image-20220604130648381</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130659596.png" alt="image-20220604130659596" /><figcaption aria-hidden="true">image-20220604130659596</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130713220.png" alt="image-20220604130713220" /><figcaption aria-hidden="true">image-20220604130713220</figcaption></figure></li></ol><h3 id="各时域图像">各时域图像</h3><ol type="1"><li><p><span class="math inline">\(F(\omega)\)</span>傅里叶反变换后时域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130724746.png" alt="image-20220604130724746" /><figcaption aria-hidden="true">image-20220604130724746</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样滤波后恢复的时域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130735531.png" alt="image-20220604130735531" /><figcaption aria-hidden="true">image-20220604130735531</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样滤波后恢复的时域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130746852.png" alt="image-20220604130746852" /><figcaption aria-hidden="true">image-20220604130746852</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样滤波后恢复的时域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130758457.png" alt="image-20220604130758457" /><figcaption aria-hidden="true">image-20220604130758457</figcaption></figure></li></ol><h2 id="二实验结果分析">二、实验结果分析</h2><p>由奈奎斯特抽样定理，一个带限信号<span class="math inline">\(f(t)\)</span>,如果其频谱存在在频域（角频率）区间<span class="math inline">\([-\omega_m,\omega_m]\)</span>，则可用抽样值唯一表示<span class="math inline">\(f(t)\)</span>,抽样值的间隔不能大于<span class="math inline">\(T_s=\frac{1}{2f_m}\)</span>,其中<span class="math inline">\(f_m=\frac{\omega_m}{2\pi}\)</span>.</p><p>在本实验中，<span class="math inline">\(\omega_m=\frac \pi2\)</span>，即采样的频率需要达到<span class="math inline">\(2\frac{\omega_m}{2\pi}=0.5\text{Hz}\)</span>。所以<span class="math inline">\(0.5\text{Hz}\)</span>和<span class="math inline">\(1\text{Hz}\)</span>采样后可以恢复，而<span class="math inline">\(0.2\text{Hz}\)</span>采样后就不能恢复出原来的波形。</p><h2 id="三实验代码">三、实验代码</h2><ol type="1"><li><p>实验用代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 5005</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.1415926535</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">double</span> <span class="hljs-params">(*fun_p)</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">F</span><span class="hljs-params">(<span class="hljs-type">double</span> omega)</span> &#123;<br><span class="hljs-keyword">return</span> ((omega &gt;= <span class="hljs-number">-0.5</span> * PI &amp;&amp; omega &lt;= <span class="hljs-number">0.5</span> * PI) ? <span class="hljs-built_in">cos</span>(omega) : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, fun_p f, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> step)</span> &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = left; t &lt;= right; t += step) &#123;<br>ans = ans + f(t) * <span class="hljs-built_in">cos</span>(w * t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fourierInvTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> t, fun_p f, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> step)</span> &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = left; w &lt;= right; w += step) &#123;<br>ans = ans + f(w) * <span class="hljs-built_in">cos</span>(w * t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans / (<span class="hljs-number">2.0</span> * PI);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">sample</span><span class="hljs-params">(<span class="hljs-type">double</span> t, <span class="hljs-type">double</span> fre, <span class="hljs-type">double</span> tau)</span> &#123; <span class="hljs-comment">//时域矩形抽样函数</span><br><span class="hljs-type">double</span> clc = <span class="hljs-number">1.0</span> / fre;<br>t = <span class="hljs-built_in">fabs</span>(t);<br><span class="hljs-type">double</span> res = <span class="hljs-built_in">fmod</span>(t, clc);<br><span class="hljs-keyword">if</span> (res &gt; (clc / <span class="hljs-number">2.0</span>)) res -= clc;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">fabs</span>(res) &lt;= (tau / <span class="hljs-number">2.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(<span class="hljs-type">double</span> w, <span class="hljs-type">double</span> fre, <span class="hljs-type">double</span> tau)</span> &#123;<br><span class="hljs-keyword">if</span> (w &gt;= -PI / <span class="hljs-number">2.0</span> &amp;&amp; w &lt;= PI / <span class="hljs-number">2.0</span>)<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> / fre) / tau;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">double</span> t[maxn], ft[maxn];<br>PPMdata **matrix;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> w[maxn], Fw[maxn];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-0.5</span> * PI - <span class="hljs-number">0.5</span>; w0 &lt;= <span class="hljs-number">0.5</span> * PI + <span class="hljs-number">0.5</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>w[cnt] = w0;<br>Fw[cnt] = F(w0);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out1.ppm&quot;</span>, matrix, w, Fw, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> * PI, <span class="hljs-number">3</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 1 finished------\n&quot;</span>);<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t0 = <span class="hljs-number">-20.0</span>; t0 &lt;= <span class="hljs-number">20.0</span>; t0 += <span class="hljs-number">0.1</span>) &#123;<br>t[cnt] = t0;<br>ft[cnt] = fourierInvTransform(t0, F, <span class="hljs-number">-0.5</span> * PI - <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span> * PI + <span class="hljs-number">0.5</span>, <span class="hljs-number">0.001</span>);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out2.ppm&quot;</span>, matrix, t, ft, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 2 finished------\n&quot;</span>);<br><br><span class="hljs-type">double</span> Fw_2[maxn], Fw_5[maxn], Fw_10[maxn];<br><br><br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-20.0</span>; i &lt;= <span class="hljs-number">20.0</span>; i += <span class="hljs-number">0.1</span>) &#123; <span class="hljs-comment">//计算傅里叶积分</span><br>Fw_2[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>Fw_5[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>Fw_10[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>++j;<br>&#125;<br>w[cnt] = w0;<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out3_1.ppm&quot;</span>, matrix, w, Fw_2, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out3_2.ppm&quot;</span>, matrix, w, Fw_5, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out3_3.ppm&quot;</span>, matrix, w, Fw_10, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 3 finished------\n&quot;</span>);<br><br><span class="hljs-type">double</span> Fw2_fil[maxn], Fw5_fil[maxn], Fw10_fil[maxn];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>Fw2_fil[cnt] = Fw_2[cnt] * filter(w0, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.01</span>);<br>Fw5_fil[cnt] = Fw_5[cnt] * filter(w0, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.01</span>);<br>Fw10_fil[cnt] = Fw_10[cnt] * filter(w0, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.01</span>);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out4_1.ppm&quot;</span>, matrix, w, Fw2_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4_2.ppm&quot;</span>, matrix, w, Fw5_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4_3.ppm&quot;</span>, matrix, w, Fw10_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> ft_2[maxn], ft_5[maxn], ft_10[maxn];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t0 = <span class="hljs-number">-20.0</span>; t0 &lt;= <span class="hljs-number">20.0</span>; t0 += <span class="hljs-number">0.1</span>) &#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>ft_2[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw2_fil[j] * <span class="hljs-number">0.01</span>;<br>ft_5[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw5_fil[j] * <span class="hljs-number">0.01</span>;<br>ft_10[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw10_fil[j] * <span class="hljs-number">0.01</span>;<br>++j;<br>&#125;<br>ft_2[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>ft_5[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>ft_10[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out4-4.ppm&quot;</span>, matrix, t, ft_2, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4-5.ppm&quot;</span>, matrix, t, ft_5, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4-6.ppm&quot;</span>, matrix, t, ft_10, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其中的<code>arratToPPM.h</code>是本人编写的绘图用代码库。文件内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 999999999</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span>;<br><br>PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">drawMatrix</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br><br><br><br>PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> &#123;<br>PPMdata ans;<br>ans.r = r, ans.g = g, ans.b = b;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span> &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(picLen / <span class="hljs-number">2</span> + (num - center) / range * picLen);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">drawMatrix</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color)</span> &#123;<br><span class="hljs-keyword">if</span> (x &gt;= width || x &lt; <span class="hljs-number">0</span> || y &gt;= height || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> matrix[y][x] = color;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br><span class="hljs-type">int</span> u = x + i, v = y + j;<br><span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> matrix[v][u] = color;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>freopen(fileName, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>fclose(<span class="hljs-built_in">stdout</span>);<br>freopen(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span> &#123;<br><br>matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PPMdata *) * height);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(width, <span class="hljs-keyword">sizeof</span>(PPMdata));<br>&#125;<br><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br><span class="hljs-type">double</span> *y_save=(<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>)*(arrayLen+<span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrayLen;++i) y_save[i]=y[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>y[i] = centerY - (y[i] - centerY);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR:X is not increasing.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR:X out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br><span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>&#125;<br>&#125;<br>PPMdata background, axis, grid, line;<br>background = makePPMdata(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = makePPMdata(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = makePPMdata(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = makePPMdata(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>matrix[i][j] = background;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br>drawPoint(matrix, width, height, numToMatPos(centerX + i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>drawPoint(matrix, width, height, numToMatPos(centerX - i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>drawPoint(matrix, width, height, j, numToMatPos(centerY + i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>drawPoint(matrix, width, height, j, numToMatPos(centerY - i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br>drawPoint(matrix, width, height, i, height / <span class="hljs-number">2</span>, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>drawPoint(matrix, width, height, width / <span class="hljs-number">2</span>, i, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">double</span> stepX = rangeX / width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> X = centerX - rangeX / <span class="hljs-number">2</span>; X &lt; centerX + rangeX / <span class="hljs-number">2</span>; X += stepX) &#123;<br><span class="hljs-type">int</span> linerIndex = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (X &lt; x[i]) &#123;<br>linerIndex = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (linerIndex == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">double</span> u, v, Y;<br>u = numToMatPos(X, centerX, rangeX, width);<br>Y = linerFunc(x[linerIndex], y[linerIndex], x[linerIndex + <span class="hljs-number">1</span>], y[linerIndex + <span class="hljs-number">1</span>], X);<br>v = numToMatPos(Y, centerY, rangeY, height);<br>drawPoint(matrix, width, height, u, v, line, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br>matToPPM(name, matrix, width, height);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s Draw finish!\n&quot;</span>,name);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height;++i)<br><span class="hljs-built_in">free</span>(matrix[i]);<br><span class="hljs-built_in">free</span>(matrix);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrayLen;++i) y[i]=y_save[i];<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验1：连续时间系统卷积的数值计算</title>
    <link href="/2022/04/06/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A1/"/>
    <url>/2022/04/06/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A1/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第一个实验，连续时间系统卷积的数值计算</p><span id="more"></span><h2 id="一实验原理">一、实验原理</h2><p>卷积积分不仅可以通过直接积分或查表的方法来求解，还可以用积分的数值计算方法来求解。在线性系统的分析过程中，有时会遇到复杂的激励信号，或者有时只是一组测试数据或曲线，冲激响应也可能出现同样的情况。显然，此时直接计算积分或查表都有困难，而采用近似的数值计算方法可以解决这个问题，求得卷积积分。</p><p>两个信号<span class="math inline">\(f_1(t)\)</span>和<span class="math inline">\(f_2(t)\)</span>的卷积<span class="math inline">\(f_1(t)*f_2(t)\)</span>定义为： <span class="math display">\[f_1(t)*f_2(t)=\int_{-\infty}^{\infty}f_1(t-\tau)f_2(\tau){\bf d}\tau\]</span> 在计算卷积积分时，我们通常采取“翻转→平移→相乘→叠加”的方法。</p><ol type="1"><li><p>将信号取值离散化，即以 Ts 为周期，对信号取值，得到一系列宽度间隔为 Ts 的矩形脉冲原信号的离散取值点，用所得离散取值点矩形脉冲来表示原来的连续时间信号；</p></li><li><p>将进行卷积的两个信号序列之一反转，与另一信号相乘，并求积分，所得为 t=0 时的卷积积分的值。以 Ts 为单位左右移动反转的信号，与另一信号相乘求积分，求的 t&lt;0 和 t&gt;0 时卷积积分的值；</p></li><li><p>将所得卷积积分值与对应的 t 标在图上，连成一条光滑的曲线，即为所求卷积积分的曲线。</p></li></ol><p>上述过程，在形式上，就是用 <span class="math display">\[\sum_{\tau=\tau_0}^{\tau_1}f_1(t-\tau)f_2(\tau)\Delta\tau\]</span> 来逼近<span class="math inline">\(f_1(t)*f_2(t)\)</span>。其中<span class="math inline">\(\tau_0\)</span>是一个很小的值，<span class="math inline">\(\tau_1\)</span>是一个很大的值，<span class="math inline">\(\Delta \tau\)</span>是每次<span class="math inline">\(\tau\)</span>增加的值。</p><h2 id="二实验内容">二、实验内容</h2><p><span class="math display">\[f_1(t)=u(t+2)-u(t-2)\\f_2(t)=t[u(t)-u(t-2)]+(4-t)[u(t-2)-u(t-4)]\]</span></p><p>用数值方法计算<span class="math inline">\(f_1*f_2\)</span>，将结果用表格列出，并画出图像。</p><h2 id="三实验过程">三、实验过程</h2><h3 id="程序框图">1. 程序框图</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091624871.png" alt="image-20220709162415460" /><figcaption aria-hidden="true">image-20220709162415460</figcaption></figure><h3 id="程序代码">2. 程序代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> dt = <span class="hljs-number">0.1</span>;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">u</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> (t &gt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> u(t + <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> t * <span class="hljs-number">1.0</span> * (u(t) - u(t - <span class="hljs-number">2</span>)) + (<span class="hljs-number">4</span> - t) * <span class="hljs-number">1.0</span> * (u(t - <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>freopen(<span class="hljs-string">&quot;ans.xls&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-2.5</span>; t &lt;= <span class="hljs-number">6.5</span>; t += dt) &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.01</span>) &#123;<br>ans += f1(t - i) * f2(i) * <span class="hljs-number">0.01</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f\t%.3f\n&quot;</span>, t, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果">3. 运行结果</h3><p><strong>部分表格：</strong></p><p>其中<span class="math inline">\(g(t)=f_1(t)*f_2(t)\)</span></p><table><thead><tr class="header"><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(g(t)\)</span></th><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(g(t)\)</span></th></tr></thead><tbody><tr class="odd"><td>-2</td><td>0</td><td>2.1</td><td>3.995</td></tr><tr class="even"><td>-1.9</td><td>0.005</td><td>2.2</td><td>3.981</td></tr><tr class="odd"><td>-1.8</td><td>0.019</td><td>2.3</td><td>3.957</td></tr><tr class="even"><td>-1.7</td><td>0.044</td><td>2.4</td><td>3.922</td></tr><tr class="odd"><td>-1.6</td><td>0.078</td><td>2.5</td><td>3.877</td></tr><tr class="even"><td>-1.5</td><td>0.123</td><td>2.6</td><td>3.823</td></tr><tr class="odd"><td>-1.4</td><td>0.177</td><td>2.7</td><td>3.758</td></tr><tr class="even"><td>-1.3</td><td>0.242</td><td>2.8</td><td>3.684</td></tr><tr class="odd"><td>-1.2</td><td>0.316</td><td>2.9</td><td>3.599</td></tr><tr class="even"><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td></tr></tbody></table><p>完整表格下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.xls">实验结果</a></p><p><strong>绘制图像：</strong></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091624863.png" alt="image-20220405220304046" /><figcaption aria-hidden="true">image-20220405220304046</figcaption></figure><p>使用Excel 365软件绘制图像。</p><h2 id="四解析求解和误差分析">四、解析求解和误差分析</h2><p>使用符号计算语言<code>Mathematica</code>运行下列代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-variable">t</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">(</span><span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-variable">t</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <br>      <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">4</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Convolve</span><span class="hljs-punctuation">[</span><span class="hljs-variable">f1</span><span class="hljs-operator">,</span> <span class="hljs-variable">f2</span><span class="hljs-operator">,</span> <span class="hljs-variable">t</span><span class="hljs-operator">,</span> <span class="hljs-variable">\[Tau]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-variable">g</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Tau]</span><span class="hljs-operator">,</span> <span class="hljs-operator">-</span><span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-built_in">PiecewiseExpand</span><span class="hljs-punctuation">[</span><span class="hljs-variable">g</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以得到卷积结果的解析式为： <span class="math display">\[g(\tau)=\begin{cases} \frac{1}{2} (\tau +2)^2 &amp; -2\leq \tau &lt;0 \\[1.5ex] \frac{1}{2} \left(-\tau ^2+4 \tau +4\right) &amp; 0\leq \tau &lt;4 \\[1.5ex] \frac{1}{2} \left(\tau ^2-12 \tau +36\right) &amp; 4\leq \tau &lt;6 \\[1.5ex] 0 &amp; \text{others}\end{cases}\]</span> 画出的图像为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091638947.png" alt="image-20220709163735914" /><figcaption aria-hidden="true">image-20220709163735914</figcaption></figure><p>将其代入程序，可计算得数值算法的均方误差 <span class="math display">\[\begin{aligned}\text{MSE}&amp;=\sum_{i=1}^n[ans_i-g(t_i)]^2\\&amp;=0.000029\end{aligned}\]</span> 计算代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> dt = <span class="hljs-number">0.1</span>;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">u</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> (t &gt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> u(t + <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> t * <span class="hljs-number">1.0</span> * (u(t) - u(t - <span class="hljs-number">2</span>)) + (<span class="hljs-number">4</span> - t) * <span class="hljs-number">1.0</span> * (u(t - <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span>&#123;<br><span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-number">-2</span> &amp;&amp; t&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (t+<span class="hljs-number">2.0</span>)*(t+<span class="hljs-number">2.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;t &amp;&amp; t&lt;=<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> (-t*t+<span class="hljs-number">4.0</span>*t+<span class="hljs-number">4.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">4</span>&lt;t &amp;&amp; t&lt;=<span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> (t*t<span class="hljs-number">-12.0</span>*t+<span class="hljs-number">36.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>freopen(<span class="hljs-string">&quot;ans.xls&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-type">double</span> e=<span class="hljs-number">0.0</span>;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-2.5</span>; t &lt;= <span class="hljs-number">6.5</span>; t += dt) &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.01</span>) &#123;<br>ans += f1(t - i) * f2(i) * <span class="hljs-number">0.01</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f\t%.3f\n&quot;</span>, t, ans);<br>e+=(ans-g(t))*(ans-g(t));<br>++cnt;<br>&#125;<br>fclose(<span class="hljs-built_in">stdout</span>);<br>freopen(<span class="hljs-string">&quot;CON&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MSE = %f&quot;</span>,e/(cnt*<span class="hljs-number">1.0</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
