<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>周记（20221107-20221130）</title>
    <link href="/2022/11/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221107-20221130%EF%BC%89/"/>
    <url>/2022/11/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221107-20221130%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>哈哈，我以及很多周没有写周记了，大概有三四周了。现在是校历第十四周的周三，期末的氛围已经很浓厚了。在这一段时间里面，北航竟然出现了阳性病例，这是我没有想到的。第一次出现是在11月25日，那次一早上醒来就发现新北有阳性，然后学校就迅速的把所有宿舍都封控了，还迅速给每个宿舍发了饭，这一系列动作不得不给北航点个赞，你航的后勤这方面真的没法喷。</p><p>至于我自己呢，首先心理状态肯定是会受到疫情影响的，按群友的话来说就是“一阳性就没心情学习了”，这也是我接下来要着力克服的方面。这段时间的信息真的太多了，纷繁复杂，如果真的要一一处理，无疑会浪费我的大量经历。而我的精力很宝贵，我的精力要用在学习上的。所以我想，我还是要把精力放在学习上，至于外部的纷繁复杂的消息，我想，只能作为消遣吧。我的计划是：早上八点半起床，下午两点起床，学习的时候少玩手机，少刷知乎，增强效率，做好计划，就酱。</p><p>我看完了《论中国》，《Ever17》暂时搁置。原神打通了深渊12-3，这是值得自豪的事。这说明像我这样的XP党也可以打通深渊的。深渊打通了以后，Ever17也可以继续了。我看了《孤独摇滚》，真他妈的好看，我要向全世界推荐。</p><p>今天江主席去世了，我买了一本《他改变了中国》，其实我早就读过电子版了，不知道重读一遍会不会有新的收获。</p><p>现在这个互联网，真是春春的奇葩了。认知战真是无处不在，我试举一例吧：有些人喜欢发一些看似意味深长而莫名其妙的东西，当问他们“发的是什么”时，他们往往会回答“不能说”、“懂得都懂”之类的话，或者某些粗略的引导。那么这时候，有些人，尤其是自诩为高级知识分子的人，为了不使自己看起来很“笨”，以至于连人家发的神秘信息也看不懂，为了显示自己是“懂得”，为了不“脱离圈子”，便会自己往上面附会一些意义，于是，自己便从“不懂得”演化成了“懂得”，这就叫做用自己的智慧击败自己。</p><p>那么这些信息到底有什么含义？正如三体中汪淼眼前的倒计时，它本身可以没有任何含义，倒计时的尽头什么也没有。可是三体人越故弄玄虚，越说什么也没有，作为高级知识分子的汪淼就越抓狂——他不允许自己理解不了这倒计时是什么含义。</p><p>这些可怜的不想被别人认为自己很笨的高级知识分子正在仔细研究这些信息，以从中推理出含义。可是这些信息本身真的什么也不是，于是他们自然推理不出来含义。这时，发信息的人又出现了，他给予这些可怜人以一点点微弱的引导，譬如：“想想最近发生了什么”，沉迷做题十数年、数十年的可怜人们便像是看到了出题人给出的“提示”，把那提示潜移默化中在脑中咂摸十遍百遍，于是，思想引导便完成了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电子技术学习笔记</title>
    <link href="/2022/11/16/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/16/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>你说得对，但是《数字电子技术基础》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作五（202）的幻想世界，在这里，被神选中的信号将被授予“门电路”，导引高低电平之力。玩家将扮演一位名为“学生”的神秘角色，在自由的课程中邂逅性格各异、能力独特的元件们，和他们一起分析逻辑，找回失散的导线——同时，逐步发掘“Verilog”的真相。</p><span id="more"></span><h2 id="数制和码制">数制和码制</h2><h3 id="数制">数制</h3><p>数制指的是数字每一位的构成方法，以及从低位到高位的进位规则。常用的数制有十进制、二进制、八进制、十六进制。</p><p>k进制数字的基本表示方式为： <span class="math display">\[(\cdots x_2x_1x_0.x_{-1}x_{-2}\cdots)_k=\sum_{i=-\infty}^{\infty}x_i\times k^i\]</span></p><h4 id="不同数制的转换方式">不同数制的转换方式</h4><ul><li><p>任意进制到十进制的转换</p><p>直接按上面的式子展开即可。</p><blockquote><p>【例】<span class="math inline">\((8FA.C)_{16}=8\times 16^2+F\times16^1+A\times16^0+C\times16^{-1}=(2298.75)_{10}\)</span></p></blockquote></li><li><p>十-二转换</p><p>整数部分用除二取余法，小数部分用乘二取整法。这成天写，我不展开了，忘了就随便拿个什么11啊这种数字推一下。</p></li><li><p>二-十六（八）转换</p><p>分组对应法最快。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161438587.png" alt="进制转换对应表" /><figcaption aria-hidden="true">进制转换对应表</figcaption></figure></li></ul><p>不同进制下四则运算的规则和方法和十进制一致。</p><h4 id="原码反码和补码">原码、反码和补码</h4><ul><li><p>原码</p><p>最高位（最左边的一位）表示正负号，0为+，1为-，其余各位表示数的绝对值。</p><p>表示范围为<span class="math inline">\(-(2^{n-1}-1)\sim (2^{n-1}-1)\)</span>，0的表示不唯一</p></li><li><p>反码</p><p>正数和原码的规则一样，有符号位和绝对值；负数是它的相反数整体（含符号位）取反，当然也可以理解成，负数的符号位是1，绝对值按位取反。</p><p>表示范围为<span class="math inline">\(-(2^{n-1}-1)\sim (2^{n-1}-1)\)</span>，0的表示不唯一</p></li><li><p>补码</p><p>正数和原码的规则一样；负数为“反码加一”，即符号位为1，绝对值按位取反，再加一。</p><p>表示范围为<span class="math inline">\(-(2^{n-1})\sim (2^{n-1}-1)\)</span>，0的表示唯一。</p><p>补码加减法运算，符号位参与运算，而且应该在相应位数表示的数值范围内进行，进位直接丢弃。</p><blockquote><p>【例】利用补码加法计算39-22</p><p>【解】<span class="math inline">\((39)_{10}=(0|010\ 0111)_{2},(-22)_{10}=(1|110\ 1010)_2\)</span>，两个二进制数相加后为<span class="math inline">\((1\ 0001\ 0001)_2\)</span>，舍弃溢出位，得结果为<span class="math inline">\((0|001\ 0001)_2=(17)_{10}\)</span></p></blockquote><p>补码的运算有模的特性。</p></li></ul><h3 id="码制">码制</h3><ul><li><p>BCD码</p><p>BCD码，即二-十进制代码，它是用二进制代码表示十进制数码的编码方法，也就是0~9这十个符号的二进制编码。分为恒权码和变权码等。</p><p>例如：8421码，就是从高位到低位的权依次是8421（和普通二进制一样），它的有效编码是0000<sub>1001，分别代表0</sub>9，其它的是非法码。</p><p>还有其他的编码，比如2421码、余3码、余3循环码等。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161527716.png" alt="常用BCD码" /><figcaption aria-hidden="true">常用BCD码</figcaption></figure></li><li><p>格雷码</p><p>格雷码的特性如下：</p><ul><li>单位距离：相邻码字仅有一个位元不同，其它位都相同。</li><li>循环相邻：对于n位循环码，如果从第0个码字开始，最大范围是第<span class="math inline">\((2^n-1)\)</span>个码字，而对<span class="math inline">\((2^n-1)\)</span>的编码一定是<span class="math inline">\(( 2^ {n-1})\)</span>的自然二进制码。</li><li>镜像反射</li></ul></li></ul><h2 id="逻辑代数">逻辑代数</h2><p>逻辑运算的大部分知识已经在“离散数学”课程中讲过了，这里仅进行补充。这里“<span class="math inline">\(\cdot\)</span>”表示与，"<span class="math inline">\(+\)</span>"表示或，<span class="math inline">\(\overline{X}\)</span>表示非，<span class="math inline">\(\oplus\)</span>表示异或，<span class="math inline">\(\odot\)</span>表示异或。</p><h3 id="逻辑函数的两种标准形式">逻辑函数的两种标准形式</h3><p>两种标准形式就是指标准与或表达式（也叫最小项之和，主析取范式），和标准或与表达式（也叫最大项之积，主合取范式）。</p><ul><li><p>标准与或表达式</p><p>形如下列式子的形式： <span class="math display">\[\begin{align}Y&amp;=AB\overline{C}+ABC+\overline{A}BC\\&amp;=m_{3}+m_{6}+m_{7}\\&amp;=\sum m(3,6,7)\end{align}\]</span> 这三个形式都是标准与或表达式。<span class="math inline">\(m\)</span>下面的下标由对应的最小项确定（没有取反的项记为1，有取反的项记为1，构成一个二进制串，转换为十进制即可）。</p></li><li><p>标准或与表达式</p><p>形如下面的式子： <span class="math display">\[\begin{align}Y&amp;=(A+B+C)(A+B+\overline{C})(\overline{A}+B+C)\\&amp;=M_0M_1M_4\\&amp;=\prod M(0,1,4)\end{align}\]</span> 和上面的一样，不赘述了。</p></li></ul><h3 id="逻辑化简">逻辑化简</h3><p>公式法略。</p><h4 id="卡诺图法">卡诺图法</h4><p>卡诺图法是一种从真值表出发得到最简与或表达式的方法。使用卡诺图的步骤如下：</p><ol type="1"><li><p>先记住这几个标准格式</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161607455.png" alt="卡诺图" /><figcaption aria-hidden="true">卡诺图</figcaption></figure><p>其实很好记的，横纵坐标就是格雷码的顺序，这也是为了利用单位距离性。</p></li><li><p>在逻辑函数为真的格子上填1，逻辑函数为假的格子填0</p></li><li><p>画卡诺圈（乘积项），合并最小项（1），反复利用互补律化简。卡诺圈的形状可以是日字形，田字形，而且有循环边界条件。</p><p>互补律：<span class="math inline">\(A\overline{A}=0,A+\overline{A}=1\)</span></p><p>画卡诺圈时应该遵循以下原则：</p><ol type="1"><li>“1”格不能漏圈</li><li>“1”格可以属于一个以上的圈</li><li>圈越大越好</li><li>圈越少越好</li><li>每个圈应该包含至少一个新的“1”格</li></ol></li></ol><h4 id="无关项">无关项</h4><p>有时候，输入逻辑变量的某些取值组合禁止出现，这种叫做“约束项”。有时候，一些取值组合出现时，输出逻辑值可以是任意的，这种叫做“任意项”。以上两个统称为无关项。在化简时，把无关项用X表示，在画卡诺圈时，X既可以被当作1，也可以被当作0，具体看你需要。</p><h4 id="逻辑函数形式的转换">逻辑函数形式的转换</h4><p>除了我们前面说的最简与或式以外，还有一些常用的形式。</p><ul><li><p>最简或与式</p><p>在画出<span class="math inline">\(Y\)</span>的卡诺图后，合并<span class="math inline">\(0\)</span>方格，求反函数的最简与或表达式，然后使用德摩根公式进行反演变换，得到原函数的最简或与表达式</p><p>德摩根公式： <span class="math display">\[\overline{AB}=\overline{A}+\overline{B},\overline{A+B}=\overline{A}\cdot\overline{B}\]</span></p></li></ul><blockquote><p>【例】已知Y的反函数，求Y的最简或与式。 <span class="math display">\[\overline{Y}=AB+CD+B\overline{D}\]</span> 【解】 <span class="math display">\[\begin{align}Y&amp;=\overline{AB}\cdot\overline{CD}\cdot\overline{B\overline{D}}\\&amp;=(\overline{A}+\overline{B})(\overline{C}+\overline{D})(\overline{B}+\overline{D})\end{align}\]</span></p></blockquote><ul><li><p>或非-或非式</p><p>先求出最简或与式，对最简或与式求两次反，再用一次德摩根公式展开。</p><blockquote><p>【例】 <span class="math display">\[\overline{\overline{(A+B)(\overline{A}+C)}}\to \overline{\overline{A+B}+\overline{\overline{A}+C}}\]</span></p></blockquote><p>也可以在求出反函数的最简与或表达式的时候，直接对反函数两端求反，在对各个乘积项用德摩根公式</p><blockquote><p>【例】 <span class="math display">\[\begin{align}&amp;\overline Y=\overline A\cdot \overline B+A\overline C\\&amp;\to Y=\overline{\overline A\cdot \overline B+A\overline C}\\&amp;\to Y=\overline{\overline{A+B}+\overline{\overline A+C}}\end{align}\]</span></p></blockquote></li><li><p>与非-与非式</p><p>把与或表达式两次取反，再用德摩根公式即可。</p><blockquote><p>【例】 <span class="math display">\[\begin{aligned}Y &amp;={A C+\overline{A} B} \\&amp;=\overline{\overline{A C+\overline{A} B}} \\&amp;=\overline{\overline{A \cdot C} \cdot \overline{\overline{A} \cdot B}}\end{aligned}\]</span></p></blockquote></li><li><p>与或非式</p><p>先求反函数的最简与或表达式，再求反。</p><blockquote><p>【例】 <span class="math display">\[\begin{align}Y&amp;=A C+\overline{A} B \\\overline{Y}&amp;=\overline{A} \cdot \overline{B}+A \cdot \overline{C} \\Y&amp;=\overline{\overline{A} \cdot \overline{B}+A \cdot \overline{C}}\end{align}\]</span></p></blockquote></li></ul><h2 id="门电路">门电路</h2><h3 id="cmos门电路">CMOS门电路</h3><p>要研究CMOS门电路，首先要认识MOS器件以及它们的特性。</p><h4 id="mos管的基本概念">MOS管的基本概念</h4><p>MOS管全名叫“结型场效应晶体管”，我们平常见到的有以下四种</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161943768.png" alt="常见MOS管符号" /><figcaption aria-hidden="true">常见MOS管符号</figcaption></figure><p>注意看：箭头方向决定是N还是P，线的虚实决定是增强还是耗尽。</p><p>MOS管的符号也有简化画法，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161944750.png" alt="MOS管符号的简化画法" /><figcaption aria-hidden="true">MOS管符号的简化画法</figcaption></figure><p>它们的特性按P、N和增强、耗尽，有所不同：</p><ul><li><strong>N沟道</strong>的，当<span class="math inline">\(V_{GS}\)</span>接足够大的正向电压时，<span class="math inline">\(DS\)</span>之间相当于联通。<strong>P沟道</strong>的，当<span class="math inline">\(V_{GS}\)</span>之间接足够大的反向电压，<span class="math inline">\(DS\)</span>之间相当于导通。</li><li><strong>增强型</strong>，开启电压为正。以<span class="math inline">\(N\)</span>沟道为例，当<span class="math inline">\(V_{GS}&gt;V_{GS(th)}&gt;0\)</span>时，<span class="math inline">\(DS\)</span>之间才能相当于联通。<strong>耗尽型</strong>，截止电压为负。以<span class="math inline">\(N\)</span>沟道为例，只要<span class="math inline">\(V&gt;V_{GS(off)}\)</span>，其中<span class="math inline">\(V_{GS(off)}&lt;0\)</span>，<span class="math inline">\(DS\)</span>之间就能导通，也就是说为了让N沟道耗尽型的DS之间不再导通，<span class="math inline">\(V_{GS}\)</span>需要一个足够大的负值电压才行。</li></ul><p>为了加深对这个特性的理解，我们来分析一下下面这个电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161954418.png" alt="未知的CMOS门电路" /><figcaption aria-hidden="true">未知的CMOS门电路</figcaption></figure><p>约定：<span class="math inline">\(V_{DD}\)</span>大于两管开启电源绝对值之和。</p><ul><li>当<span class="math inline">\(V_i=0\)</span>（接低电平）时，<span class="math inline">\(T_1\)</span>P沟道增强型MOS管的<span class="math inline">\(V_{GS}=-V_{DD}&lt;V_{GS(th)P}\)</span>，于是<span class="math inline">\(T_1\)</span>两端相当于连通，<span class="math inline">\(V_o=V_{DD}\)</span>，输出高电平。此时<span class="math inline">\(T_2\)</span>截止，两端相当于断路。</li><li>当<span class="math inline">\(V_i=V_{DD}\)</span>（接低电平）时，<span class="math inline">\(T_2\)</span>N沟道增强型MOS管的<span class="math inline">\(V_{GS}=V_{DD}&gt;V_{GS(th)N}\)</span>，于是<span class="math inline">\(T_2\)</span>导通，<span class="math inline">\(V_o\)</span>输出地（0V），此时<span class="math inline">\(T_1\)</span>截止，两端相当于断路。</li><li>综上所述，这是个非门。</li></ul><h4 id="经典门电路的mos管实现">经典门电路的MOS管实现</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162009771.png" alt="MOS门电路" /><figcaption aria-hidden="true">MOS门电路</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162009164.png" alt="MOS门电路" /><figcaption aria-hidden="true">MOS门电路</figcaption></figure><p>对于CMOS器件构成的门电路，不允许输入端悬空，输入端经电阻接地时和低电平等效，输入端经电阻接电源时和高电平等效。</p><h4 id="od门">OD门</h4><p>OD门全称为漏极开关输出门电路，它的电路长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162017294.png" alt="OD与非门电路详图" /><figcaption aria-hidden="true">OD与非门电路详图</figcaption></figure><p>其逻辑符号为门电路符号里面加一个带下划线的菱形，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162018140.png" alt="OD与非门逻辑符号" /><figcaption aria-hidden="true">OD与非门逻辑符号</figcaption></figure><p>OD门要正常工作，必须把输出端经过一个上拉电阻和电源相连。也就是电路详图中的<span class="math inline">\(R_L\)</span>，这样一来，输出的高电平具体是几伏，就取决于<span class="math inline">\(V_{DD2}\)</span>而不是<span class="math inline">\(V_{DD1}\)</span>了。</p><p>把多个OD门的输出端直接接在一起，可以构成“线与”逻辑，如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162022900.png" alt="线与接法" /><figcaption aria-hidden="true">线与接法</figcaption></figure><p>这时，有<span class="math inline">\(Y=Y_1Y_2\)</span>。有时，线与的与门符号省略，直接用圆点表示。</p><p>在选取<span class="math inline">\(R_L\)</span>时，应该注意以下原则：</p><ol type="1"><li><p><span class="math inline">\(R_L\)</span>不能太大，以保证<span class="math inline">\(V_{DD}-V_{R_L}\geq V_{OH}\)</span>。在这个条件下，有： <span class="math display">\[R_{\mathrm{L}}\leq\frac{V_{\mathrm{DD}}-V_{\mathrm{OH}}}{n \cdot I_{\mathrm{OH}}+m \cdot I_{\mathrm{IH}}}\]</span> 这里的<span class="math inline">\(V_{DD}\)</span>当然是<span class="math inline">\(R_L\)</span>连接的那个电源，其中<span class="math inline">\(n\)</span>是OD门的数目，<span class="math inline">\(m\)</span>是下一级输入端的数目（比如说，一个与非门一般有两个输入端），<span class="math inline">\(I_{OH}\)</span>是OD门截止时的漏电流，<span class="math inline">\(I_{IH}\)</span>是负载门每个输入端的高电平输入电流</p></li><li><p><span class="math inline">\(R_L\)</span>不能过小，以保证“灌入”的负载电流不大于单只OD门可承受的输入电流。有： <span class="math display">\[R_{\mathrm{L}} \geq \frac{V_{\mathrm{DD}}-V_{\mathrm{OL}}}{I_{\mathrm{OL}(\mathrm{OD})}-m \cdot I_{\mathrm{IL}}}\]</span> <span class="math inline">\(m\)</span>是下一级输入端的数目。</p></li></ol><h4 id="传输门">传输门</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162030714.png" alt="CMOS传输门电路和逻辑符号" /><figcaption aria-hidden="true">CMOS传输门电路和逻辑符号</figcaption></figure><p>其特性为：</p><ul><li><span class="math inline">\(C\)</span>接高电平而<span class="math inline">\(\overline{C}\)</span>接低电平，<span class="math inline">\(V_o=V_i\)</span>，相当于信号直接通过</li><li><span class="math inline">\(C\)</span>接低电平而<span class="math inline">\(\overline{C}\)</span>接高电平，相当于中间的电路断开，输出是高阻态。</li></ul><h4 id="三态门">三态门</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162032490.png" alt="三态门符号" /><figcaption aria-hidden="true">三态门符号</figcaption></figure><p>三态门是一个正常的门电路外加一个<span class="math inline">\(EN\)</span>信号，里面画一个倒三角。当<span class="math inline">\(EN\)</span>为有效信号（上图是低电平有效，也就是<span class="math inline">\(EN=0\)</span>）时，门电路正常工作，否则，输出高阻态。</p><h3 id="ttl门电路">TTL门电路</h3><p>我也不会分析，所以分析略。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162040271.png" /></p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162040028.png" /></p><p>这里这个OC门就和前面那个OD门意思差不多，也有线与，也得算<span class="math inline">\(R_L\)</span>的范围。不同的是，当输出端含有与非门时，要按与非门的门数计算，而不是端数。</p><p>对于TTL门电路，输入端悬空等效于逻辑高电平；输入端经过几十千欧以内的电阻接电源，等效于逻辑高电平；输入端经过几十欧的小电阻接地等效于低电平，当电阻升高到一定程度（一般是几千欧）以后，等效为高电平。</p><h2 id="组合逻辑电路">组合逻辑电路</h2><h3 id="设计分析">设计分析</h3><p>略，无非是列功能表、真值表、画卡诺图、化简、转换形式、连电路。</p><h3 id="经典组合逻辑电路模块">经典组合逻辑电路模块</h3><h4 id="编码器">编码器</h4><ul><li><p>8（位）-3（线）编码器</p><p>其基本功能是输入8位中的一位表示被编码的十进制数，3条输出线表示这个十进制数的二进制形式。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162058622.png" alt="83编码器功能表" /><figcaption aria-hidden="true">83编码器功能表</figcaption></figure></li><li><p>优先编码器</p><p>相比于83编码器，优先编码器的输出取决于最高为1的那一位。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162100464.png" alt="优先编码器功能表" /><figcaption aria-hidden="true">优先编码器功能表</figcaption></figure></li><li><p>74HC148优先编码器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162102678.png" alt="电路图" /><figcaption aria-hidden="true">电路图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162102372.png" alt="逻辑符号" /><figcaption aria-hidden="true">逻辑符号</figcaption></figure><p>其中的<span class="math inline">\(A_i,Y_i\)</span>是完成基本功能的输入输出端，此外，它还有一些其它的端口，能进行扩展功能：</p><ul><li><span class="math inline">\(\overline S\)</span>选通输入端，当且仅当<span class="math inline">\(\overline S=0\)</span>，电路正常工作，否则，所有输出都被封锁在高电平。</li><li><span class="math inline">\(\overline {Y_S}\)</span>选通输出端，当它为0时表示：电路工作但无编码输入</li><li><span class="math inline">\(\overline {Y_{EX}}\)</span>扩展输出端，它为0时表示：电路工作且有编码输入</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162110457.png" alt="74HC148功能表" /><figcaption aria-hidden="true">74HC148功能表</figcaption></figure></li></ul><h4 id="译码器">译码器</h4><p>译码器就是编码器的逆，输入三个信号表示一个二进制数，输出八个信号中的一个表示那个二进制数的十进制表示。</p><p>常用的译码器是74138译码器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162113986.png" alt="74138逻辑图" /><figcaption aria-hidden="true">74138逻辑图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162114347.png" alt="功能表" /><figcaption aria-hidden="true">功能表</figcaption></figure><p>它有三个附加控制器：<span class="math inline">\(S_1,\overline S_{2},\overline S_3\)</span>。当<span class="math inline">\(S_1=1,\overline S_{2}=\overline S_3=0\)</span>时，电路正常工作，否则，所有输出端为高电平。</p><h4 id="数据选择器">数据选择器</h4><p>数据选择器有若干个输入信号，一个选择信号（可能有多位）和一个输出。由选择信号决定输出接哪个输入信号。</p><p>常用的数据选择器是74HC153双四选一数据选择器。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162121574.png" alt="74HC153逻辑图" /><figcaption aria-hidden="true">74HC153逻辑图</figcaption></figure><p>其中<span class="math inline">\(D\)</span>表示输入信号，<span class="math inline">\(A_1A_0\)</span>共同表示一个二进制数，是选择信号，<span class="math inline">\(Y\)</span>是输出信号，<span class="math inline">\(S\)</span>是选通输入端。有时候我们只用单四选一，这时候把其它管脚留空即可，但是不能把这个片劈成两半。</p><h4 id="数值比较器">数值比较器</h4><p>略，没啥说的，都差不多。</p><p>常用的数值比较器是7485数值比较器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162137127.png" alt="7485逻辑图" /><figcaption aria-hidden="true">7485逻辑图</figcaption></figure><p>其中<span class="math inline">\(A,B\)</span>是待比较的数值，<span class="math inline">\(F\)</span>是输出。而<span class="math inline">\(I\)</span>则是当数值比较器扩展时，来自低位的比较结果。比如说，要实现八位数值的比较，我们可以这样级联：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162139534.png" alt="数值比较器扩展" /><figcaption aria-hidden="true">数值比较器扩展</figcaption></figure><p>首先比较高四位。如果高四位出现了不同，那么自然可以直接输出。如果高四位相同，那么就需要另接入一个数值比较器来比较下四位，然后把下四位的比较结果通过<span class="math inline">\(I\)</span>端反馈到高位的比较器，再由负责高位的比较器来输出最终的结果。</p><p>也就是说，当<span class="math inline">\(AB\)</span>不相等时，输出和<span class="math inline">\(I\)</span>无关，直接输出<span class="math inline">\(AB\)</span>的关系，否则，直接输出<span class="math inline">\(I\)</span>。</p><h4 id="加法器">加法器</h4><p>全加器有三个输入<span class="math inline">\(A,B,CI\)</span>，其中<span class="math inline">\(AB\)</span>表示两个加数，<span class="math inline">\(CI\)</span>表示上个全加器产生的进位信号。有两个输出：<span class="math inline">\(S,CO\)</span>，<span class="math inline">\(S\)</span>表示和，<span class="math inline">\(CO\)</span>表示有无进位。</p><p>这个功能很简单就能描述：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> &#123;CO,S&#125;=A+B+CI<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162127862.png" alt="全加器功能表" /><figcaption aria-hidden="true">全加器功能表</figcaption></figure><h2 id="半导体存储电路">半导体存储电路</h2><p>基本的半导体存储电路有锁存器、触发器、寄存器、存储器等。其中触发器可按结构分为基本、同步、主从、边沿触发器，按触发方式分为电平、脉冲、脉冲边沿触发器，按逻辑功能分为RS、JK、D和T触发器等。</p><h3 id="sr锁存器">SR锁存器</h3><p>SR锁存器是最基本的半导体存储电路。一般来说，我们所谓的锁存器，都指的是SR锁存器。其电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271054295.png" alt="或非门SR锁存器" /><figcaption aria-hidden="true">或非门SR锁存器</figcaption></figure><p>由于或非门可以被“锁定”的特性，这个电路具有了锁存的功能。其状态转移图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271052715.png" alt="image-20221127105256632" /><figcaption aria-hidden="true">image-20221127105256632</figcaption></figure><p>状态方程如下： <span class="math display">\[\left\{\begin{array}{c}Q^{n+1}=S_{\mathrm{D}}+\overline{R_{\mathrm{D}}} \cdot Q^n \\R_{\mathrm{D}} S_{\mathrm{D}} \equiv 0\end{array}\right.\]</span> 状态表如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271107647.png" alt="或非门SR锁存器状态表" /><figcaption aria-hidden="true">或非门SR锁存器状态表</figcaption></figure><p>状态转移图、状态方程、状态表，说的都是一件事，那就是这个元件的状态如何变化。在SR触发器中，记住状态表是最高效的分析方法。</p><p>在状态表中，我们观察最后两行，这是状态转移图和状态方程中没有考虑到的。这里的“不定”有两种含义。第一种，当电路正常工作时，如果施加<span class="math inline">\(S_D=1,R_D=1\)</span>的输入，会有<span class="math inline">\(Q=\overline{Q}=0\)</span>的状态，这既<strong>不</strong>是<strong>定</strong>义的“1”状态，也<strong>不</strong>是<strong>定</strong>义的“0”状态，所以叫“<strong>不定</strong>”。第二种是，当电路本来就是上一个状态时，如果同时把<span class="math inline">\(S,R\)</span>置<span class="math inline">\(0\)</span>，那么电路的输出状态<strong>不</strong>能确<strong>定</strong>（这个照着电路图推一推就明白了），于是叫做“<strong>不定</strong>”。</p><p>观察状态转换方法，我们有时将<span class="math inline">\(S_D\)</span>叫做“直接置位端”，意思是直接把状态置为1；将<span class="math inline">\(R_D\)</span>叫做“直接复位端”，意思是把状态复位为0，于是这个电路叫做“Ser-Reser Latch”，即“SR锁存器”。</p><p>SR锁存器也可以用与非门构造，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271115837.png" alt="与非门SR锁存器" /><figcaption aria-hidden="true">与非门SR锁存器</figcaption></figure><p>不同的是，这里的<span class="math inline">\(S_D,R_D\)</span>都变成了低电平有效。</p><h3 id="触发器">触发器</h3><h4 id="电平触发">电平触发</h4><p>电平触发的意思，就是当且仅当<code>clk</code>信号是有效信号时，触发器的输出状态随着输入信号变化。如果不是有效信号，则保持之前的输出状态。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271609270.png" alt="电平触发SR触发器" /><figcaption aria-hidden="true">电平触发SR触发器</figcaption></figure><p>电平触发有时会因为一些短暂的噪声而影响整个输出，因此我们要考虑其它触发方式</p><h4 id="脉冲触发">脉冲触发</h4><p>首先来考虑主从SR触发器（也叫“脉冲触发的SR触发器”）。主从SR触发器的结构和符号如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271644991.png" alt="主从SR触发器" /><figcaption aria-hidden="true">主从SR触发器</figcaption></figure><p>可以看出，一个脉冲触发的SR触发器，是由两个电平触发的SR触发器接成的。<span class="math inline">\(FF_1\)</span>叫主触发器，<span class="math inline">\(FF_2\)</span>叫从触发器，主触发器的输出直接接入从触发器的输入。在分析时，应该在高电平先对<span class="math inline">\(Q_1\)</span>进行分析，之后，再在低电平（注意，从触发器接的时钟信号是翻转的）对<span class="math inline">\(Q\)</span>进行分析。显然，主触发器在一个高电平时间段内，可以随着输入信号的变化而翻转多次。</p><p>接下来我们考虑JK触发器。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272038848.png" alt="JK触发器" /><figcaption aria-hidden="true">JK触发器</figcaption></figure><p>这里在输出端和输入端之间接了一个反馈。即： <span class="math display">\[S=\overline{Q}J,R=QK\]</span> 带入，有： <span class="math display">\[Q^{n+1}=J \cdot \overline{Q^n}+\overline{K} \cdot Q^n\]</span> 这就是JK触发器的状态转移方程，可以写出状态转移图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272045222.png" alt="JK触发器的状态转移图" /><figcaption aria-hidden="true">JK触发器的状态转移图</figcaption></figure><p>状态表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272106517.png" alt="JK触发器状态表" /><figcaption aria-hidden="true">JK触发器状态表</figcaption></figure><p>接下来，我们讨论一下JK触发器是怎么进行状态转移的。JK的主触发器仍然是一个电平触发的SR触发器，但是由于JK触发器的反馈机制，当<span class="math inline">\(Q=0\)</span>时，因为<span class="math inline">\(R=QK=0\)</span>，主触发器只能接受“置1输入信号”；当<span class="math inline">\(Q=1\)</span>时，因为<span class="math inline">\(S=\overline QJ=0\)</span>，主触发器只能接受“置0（复位）输入信号”，所以这个主触发器在<span class="math inline">\(CLK=1\)</span>期间至多翻转一次，这就是所谓的“JK触发器的一次性变化现象”。</p><p>于是，我们可以知道所谓“脉冲触发”到底是什么意思。</p><ol type="1"><li>触发器的翻转分两步动作，首先，在<span class="math inline">\(CLK=1\)</span>时，主触发器接收输入信号，进行动作，而从触发器不动。第二步，<span class="math inline">\(CLK=1\)</span>的信号消失时（有的人把这个动作表述为“下降沿来临时”），从触发器根据主触发器的状态进行动作。由于输出信号是从触发器的输出信号，我们看起来，脉冲触发的触发器进行动作总是发生在<span class="math inline">\(CLK\)</span>信号的下降沿。</li><li>主触发器本来是一个电平触发的SR触发器，所以在<span class="math inline">\(CLK=1\)</span>的全部时间，输入信号都会对主触发器起作用。</li></ol><h4 id="边沿触发">边沿触发</h4><p>边沿触发是最简单的，它的次态仅仅取决与<span class="math inline">\(CLK\)</span>信号的上升沿或下降沿来临的瞬间，输入信号的状态。在分析时，只用对触发的边沿那几个有限的点进行分析就行了。</p><h4 id="按逻辑功能的分类">按逻辑功能的分类</h4><p>SR触发器和JK触发器的逻辑功能前面已经讲了。接下来介绍两种其它的触发器：</p><ol type="1"><li><p>T触发器</p><p>T触发器的功能简单来说是：“0保持，1取反”，即： <span class="math display">\[Q^{n+1}=T\overline{Q}+\overline{T}Q\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(T\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(Q^{n+1}\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>0</td></tr></tbody></table></li><li><p>D触发器</p><p>D触发器的功能简单来说是：“延迟一位”，即： <span class="math display">\[Q^{n+1}=D\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(D\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(Q^{n+1}\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table></li></ol><h3 id="存储器">存储器</h3><p>首先明确一个概念：怎么表达一个存储器的大小呢？书上说：“通常写成（字数）x（每个字的位数）”的形式。什么是字？字就是这个存储器输出的东西。存储器每读入一个地址，就会输出一个01串，这个01串就是一个“字”，这个01串的长度就是“每个字的位数”。那么有人说，假设每个字的位数是<span class="math inline">\(n\)</span>，那么字数难道不会自动是<span class="math inline">\(2^n\)</span>吗？不是这样的。因为我们可以在不同的地址里存相同的字，也可以不在存储器中存储所有字，这是显而易见的。存储器的每个地址中存法一个字，所以所谓的“字数”其实是有效的地址数。</p><h4 id="随机存取存储器ram">随机存取存储器RAM</h4><p>可以随时从任何一个指定的地址读出数据，也可以随时将数据写入任何一个指定的存储单元中去，但是掉电后数据会丢失。其基本结构如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272202657.png" alt="RAM结构" /><figcaption aria-hidden="true">RAM结构</figcaption></figure><h4 id="只读存储器rom">只读存储器ROM</h4><p>ROM的基本结构如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272204218.png" alt="ROM" /><figcaption aria-hidden="true">ROM</figcaption></figure><p>我们可以考察一下二极管ROM的详细结构。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272205218.png" alt="二极管ROM" /><figcaption aria-hidden="true">二极管ROM</figcaption></figure><p>在地址译码器中，看纵列，每个纵列构成了一个二极管与门。于是： <span class="math display">\[\begin{aligned}W_0=\overline{A_0}\ \overline{A_1}\\W_1=A_0 \overline{A_1}\\W_2=\overline{A_0}A_1\\W_3=A_0A_1\end{aligned}\]</span> 这样一来，就实现了一个译码器，这就是地址译码器。它将输入的二位二进制地址码翻译成<span class="math inline">\(W_i\)</span>的其中一个信号。</p><p>现在看存储矩阵，看横行，每个横行构成了一个二极管或门，比如<span class="math inline">\(D_3=W_1+W_3,D_2=W_0+W_2+W_3,\cdots\)</span>，这样一来，输出端<span class="math inline">\(D\)</span>就能根据<span class="math inline">\(W\)</span>的选通而输出对应的信号<span class="math inline">\(\{D_3D_2D_1D_0\}\)</span>了。这就是二极管ROM的工作原理。根据这个原理，我们也可以使用ROM来实现多输出端逻辑函数，不再赘述了。</p><h4 id="存储器容量的扩展">存储器容量的扩展</h4><ol type="1"><li><p>位扩展</p><p>当字数够用而每个字的位数不够时，可以使用位扩展。位扩展很简单，只需要把所有地址线、读写控制线、<span class="math inline">\(CS&#39;\)</span>线（CS‘线就是片选输入端，当<span class="math inline">\(\overline{CS}=0\)</span>时，这个片才工作）统统拧在一起就行了，如下是把8个1024x1位存储器位扩展为一个1024x8位存储器的过程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272225535.png" alt="位扩展" /><figcaption aria-hidden="true">位扩展</figcaption></figure></li><li><p>字扩展</p><p>当位数够用而字数不够时，可以使用字扩展。字扩展的接法是：首先把每个片的每个输出端，每个低位地址端，读写控制线并联起来，然后在新的地址位上加入一个译码器，通过译码器和CS端来控制不同的片工作与否，以达到扩展字数的目的。如下图是把4个256x8存储器接成一个1024x8存储器的过程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272232639.png" alt="字扩展" /><figcaption aria-hidden="true">字扩展</figcaption></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波技术笔记</title>
    <link href="/2022/11/07/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/07/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《微波技术》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作五（303）的幻想世界，在这里，被神选中的信号将被授予“波导”，导引电磁波。玩家将扮演一位名为“传输线”的神秘角色，在自由的课程中邂逅性格各异、能力独特的圆图们，和他们一起分析阻抗，找回失散的能量——同时，逐步发掘“Black Magic”的真相。</p><span id="more"></span><p>[toc]</p><h2 id="传输线理论">传输线理论</h2><p>微波的工作频率为<span class="math inline">\(300MHz\sim 3000GHz\)</span>，对应的自由空间中的波长为<span class="math inline">\(1m\sim 0.1mm\)</span>，在这种条件下，日常尺度的导线以及具备很多异于理想导线的性质，被称作“长线”或者“传输线”，理想导线则被称作“短线”。具体来说，当系统的电长度<span class="math inline">\(l/\lambda \geq0.05\)</span>时，就要用传输线理论来分析问题，这种导线就被称作长线。</p><h3 id="传输线方程">传输线方程</h3><p>对于传输线上的一个微元<span class="math inline">\(dz\)</span>，有其等效集总参数模型：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211181534581.png" alt="image-20221118153336875" /><figcaption aria-hidden="true">image-20221118153336875</figcaption></figure><p>其中<span class="math inline">\(R_0\)</span>叫分布电阻，<span class="math inline">\(L_0\)</span>叫分布电感，<span class="math inline">\(G_0\)</span>叫分布电导，<span class="math inline">\(C_0\)</span>叫分布电容。理想导体的<span class="math inline">\(R_0=0\)</span>，理想介质的<span class="math inline">\(G_0=0\)</span>。</p><p>根据基尔霍夫定律列出方程，转换为复频域形式，则有我们所说的传输线方程，也叫频域电报方程 <span class="math display">\[\begin{aligned}&amp;\frac{\mathrm{d} \dot{U}(z)}{\mathrm{d} z}=-\left(R_0+j \omega L_0\right) \dot{I}(z)=-Z \dot{I}(z) \\&amp;\frac{\mathrm{d} \dot{I}(z)}{\mathrm{d} z}=-\left(G_0+\mathrm{j} \omega C_0\right) \dot{U}(z)=-Y \dot{U}(z)\end{aligned}\]</span> 其中<span class="math inline">\(Z=(R_0+j\omega L_0)\)</span>叫单位长度串联阻抗、<span class="math inline">\(Y=(G_0+j\omega C_0)\)</span>叫单位长度并联导纳。把上面两个式子对<span class="math inline">\(z\)</span>求导，再代换，有： <span class="math display">\[\begin{aligned}&amp;\frac{\mathrm{d}^2 \dot{U}(z)}{\mathrm{dz} z^2}-\gamma^2 \dot{U}(z)=0 \\&amp;\frac{\mathrm{d}^2 \dot{I}(z)}{\mathrm{d} z^2}-\gamma^2 \dot{l}(z)=0\end{aligned}\]</span> 其中 <span class="math display">\[\gamma=\sqrt{Z Y}=\sqrt{\left(R_0+\mathrm{j} \omega L_0\right)\left(G_0+\mathrm{j} \omega C_0\right)}=\alpha+\mathrm{j} \beta\]</span> 叫做传播常数，是一个取决于传输线物理性质的常数。于是，可以解出传输线方程的通解： <span class="math display">\[\dot{U}(z)=A_1 \mathrm{e}^{-\gamma z}+A_2 \mathrm{e}^{\gamma z}\]</span></p><p><span class="math display">\[I(z)=-\frac 1Z\frac{ \mathrm{~d} \dot{U}(z)}{ \mathrm{~d} z}=\frac{\gamma}{Z}\left(A_1 \mathrm{e}^{-\gamma z}-A_2 \mathrm{e}^{\gamma z}\right)=\frac{1}{Z_0}\left(A_1 \mathrm{e}^{-\gamma z}-A_2 \mathrm{e}^{\gamma z}\right)\]</span></p><p>其中<span class="math inline">\(Z_0\)</span>叫做传输线特性阻抗，有： <span class="math display">\[Z_0=\frac{Z}{\gamma}=\sqrt{\frac{Z}{Y}}=\sqrt{\frac{R_0+\mathrm{j} \omega L_0}{G_0+\mathrm{j} \omega C_0}}\]</span> <span class="math inline">\(A_1,A_2\)</span>是待定常数，要根据端口条件来确定。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211181630064.png" alt="完整电路" /><figcaption aria-hidden="true">完整电路</figcaption></figure><ol type="1"><li><p>终端条件</p><p>即已知终端<span class="math inline">\(\dot{U}_2,\dot{I}_2\)</span>。则有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{1}{2}\left(\dot{U}_2+Z_0 \dot{I}_2\right) \\A_2=\frac{1}{2}\left(\dot{U}_2-Z_0 \dot{I}_2\right)\end{array}\right.\]</span></p></li><li><p>始端条件</p><p>即已知<span class="math inline">\(\dot{U}_1,\dot{I}_1\)</span>。则有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{1}{2}\left(\dot{U}_1+Z_0 \dot{I}_1\right) \\A_2=\frac{1}{2}\left(\dot{U}_1-Z_0 \dot{I}_1\right)\end{array}\right.\]</span></p></li><li><p>波源阻抗条件</p><p>即已知<span class="math inline">\(\dot{E}_g,Z_g,Z_L\)</span>，有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{Z_0 \dot{E}_{\mathrm{g}} \mathrm{e}^{-\gamma l}}{Z_{\mathrm{g}}+Z_0} \\A_2=\frac{Z_0 \dot{E}_{\mathrm{g}} \mathrm{e}^{-\gamma l}}{Z_{\mathrm{g}}+Z_0} \Gamma_{\mathrm{L}}\end{array}\right.\]</span></p></li></ol><h3 id="传输线上的参量">传输线上的参量</h3><h4 id="一次特征参量">一次特征参量</h4><p><span class="math inline">\(R_0\)</span>分布电阻，<span class="math inline">\(L_0\)</span>分布电感，<span class="math inline">\(G_0\)</span>分布电导，<span class="math inline">\(C_0\)</span>分布电容</p><h4 id="二次特征参量">二次特征参量</h4><p>二次特征参量也叫传播特性参量，其中最主要的就是传播常数<span class="math inline">\(\gamma\)</span>和特征阻抗<span class="math inline">\(Z_0\)</span>，具体的计算式已经在上面给出了。还有一些其它的特征参量，可以由上面的导出。</p><ol type="1"><li><p>衰减常数和相位常数</p><p>若<span class="math inline">\(\gamma=\alpha+j\beta\)</span>，那么<span class="math inline">\(\alpha\)</span>叫做衰减常数，表示经过单位长度行波幅度衰减<span class="math inline">\(e^{-\alpha}\)</span>，<span class="math inline">\(\beta\)</span>叫做相位常数，表示单位长度行波滞后的幅度。对于无耗传输线，有： <span class="math display">\[\left\{\begin{array}{l}\gamma=\mathrm{j} \omega \sqrt{L_0 C_0} \\\alpha=0 \\\beta=\omega \sqrt{L_0 C_0}\end{array}\right.\]</span></p></li><li><p>相速度和相波长</p><p>相速度就是等相位面移动的速度，相波长就是等相位面在一个周期内移动的距离。有： <span class="math display">\[v_p=\frac \omega \beta\]</span></p><p><span class="math display">\[\lambda_p=\frac{2\pi}\beta\]</span></p><p>对于均匀无耗传输线，有： <span class="math display">\[v_p=\frac{c}{\sqrt{\varepsilon_r\mu_r}}\]</span></p><p><span class="math display">\[\lambda_p=\frac{\lambda_0}{\sqrt{\varepsilon_r\mu_r}}\]</span></p></li><li><p>特性阻抗</p><p>特性阻抗具有如下特点：</p><ul><li>同一时刻，传输线上行波电压不同，但是传输线上各点的入射波电压和入射波之比是一个定值，这个值就是特性阻抗</li><li>传输线特性阻抗仅取决于传输线的结构，和其长度无关</li><li>特性阻抗描述入射（或反射）波电压和电流的幅度相位关系。</li></ul></li></ol><h4 id="工作状态参量">工作状态参量</h4><ol type="1"><li><p>反射系数</p><p>定义电压反射系数： <span class="math display">\[\Gamma_U(z)=\frac{\dot U_r(z)}{\dot U_i(z)}\]</span> 电流反射系数可类似定义，但我们一般都用电压反射系数。</p><p>对于无耗传输线，有： <span class="math display">\[\Gamma_{U}(z)=\frac{A_2}{A_1} \mathrm{e}^{-\mathrm{j} 2 \beta z}\]</span> 若终端负载处反射系数为<span class="math inline">\(\Gamma_2\)</span>，则有： <span class="math display">\[\Gamma(z)=\Gamma_2 \mathrm{e}^{-j 2 \beta z}=\left|\Gamma_2\right| \mathrm{e}^{\mathrm{j}\left(\phi_2-2 \beta_2\right)}=\left|\Gamma_2\right| \mathrm{e}^{\mathrm{j} \phi}\]</span> 其中<span class="math inline">\(\phi_2\)</span>是<span class="math inline">\(\Gamma_2\)</span>的相角。</p></li><li><p>输入阻抗</p><p>输入阻抗是传输线上任何一点的总电压和总电流的比，即： <span class="math display">\[Z_{\mathrm{in}}(z)=\frac{\dot{U}(z)}{\dot{I}(z)}\]</span> 输入阻抗和线上反射系数可以互相转化： <span class="math display">\[Z_{in}(z)=Z_0 \frac{1+\Gamma(z)}{1-\Gamma(z)}\]</span></p><p><span class="math display">\[\Gamma(z)=\frac{Z_{\mathrm{in}}(z)-Z_0}{Z_{\mathrm{in}}(z)+Z_0}\]</span></p><p>需要提醒：上面两个式子对终端也适用，也就是说如果终端直接接入阻抗<span class="math inline">\(Z_L\)</span>，是可以直接计算终端反射系数<span class="math inline">\(\Gamma_2\)</span>的。进一步，有： <span class="math display">\[Z_{\mathrm{in}}(z)=Z_0 \frac{1+\Gamma_2 \mathrm{e}^{-\mathrm{j} 2 \beta z}}{1-\Gamma_2 \mathrm{e}^{-j 2 \beta z}}=Z_0 \frac{Z_{\mathrm{L}}+\mathrm{j} Z_0 \tan \beta z}{Z_0+\mathrm{j} Z_{\mathrm{L}} \tan \beta z}\]</span> 当然，我感觉这个用史密斯圆图更好算。</p></li></ol><h4 id="驻波参量">驻波参量</h4><p>当<span class="math inline">\(Z_L=Z_0\)</span>时，称传输线阻抗匹配，否则称传输线失配。我们用驻波参量来衡量失配程度。</p><ol type="1"><li><p>驻波比SWR（<span class="math inline">\(\rho\)</span>）</p><p>驻波比的定义是沿线电压最大值和最小值之比，它和反射系数是一一对应的。对于无耗传输线，有： <span class="math display">\[\begin{gathered}\rho=\frac{1+|\Gamma|}{1-|\Gamma|}=\frac{1+\left|\Gamma_2\right|}{1-\left|\Gamma_2\right|} \\|\Gamma|=\left|\Gamma_2\right|=\frac{\rho-1}{\rho+1}\end{gathered}\]</span> 当完全匹配时，驻波比为1，沿线电压最大值和最小值相等，<span class="math inline">\(\Gamma_2=0\)</span>。</p></li><li><p>行波系数<span class="math inline">\(K\)</span></p><p>就是驻波比的倒数。</p></li><li><p>驻波相位<span class="math inline">\(l_{min}\)</span></p><p>离终端最近的电压波节点到终端的距离</p></li></ol><p>无耗传输线上的波有三种传输模式：</p><ol type="1"><li><span class="math inline">\(Z_L=Z_0\)</span>，此时阻抗匹配，波形是行波</li><li><span class="math inline">\(Z_L\)</span> 开路、短路或是纯虚数，此时传输线处于全反射状态，波形是纯驻波。</li><li>其它情况，传输线处于部分反射状态，波形是行驻波。</li></ol><h3 id="史密斯圆图">史密斯圆图</h3><h4 id="归一化阻抗和导纳">归一化阻抗和导纳</h4><p>定义归一化阻抗： <span class="math display">\[\bar{Z}_L=\frac{Z_L}{Z_0}\]</span> 则有： <span class="math display">\[\bar{Z}_{\mathrm{in}}(z)=\frac{\bar{Z}_{\mathrm{L}}+\mathrm{j} \tan \beta z}{1+\mathrm{j} Z_1 \tan \beta z}\]</span> 再定义归一化电标度（电尺寸）： <span class="math display">\[\bar{z}=\frac z\lambda\]</span> 则有： <span class="math display">\[\bar{Z}_{\mathrm{in}}(\bar{z})=\frac{\bar{Z}_{\mathrm{L}}+\mathrm{j} \tan 2 \pi \bar{z}}{1+\mathrm{j} \bar{Z}_{\mathrm{L}} \tan 2 \pi \bar{z}}\]</span> 表达式中不再包含和传输线结构有关的参量，于是此表达式可以适用于任意传输线的分析。</p><p>由阻抗和反射系数的一对一转换关系： <span class="math display">\[\Gamma(\bar{z})=\frac{\bar{Z}_{\mathrm{in}}(\bar{z})-1}{\bar{Z}_{\mathrm{in}}(\bar{z})+1}\]</span> 把<span class="math inline">\(Z\)</span>平面转换到<span class="math inline">\(\Gamma\)</span>平面，可得阻抗圆图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211231047660.png" alt="image-20221123104650102" /><figcaption aria-hidden="true">image-20221123104650102</figcaption></figure><p>图中有<strong>三个关键点</strong>：</p><ol type="1"><li>匹配点：<span class="math inline">\(\Gamma (0,0)\)</span>点，对应<span class="math inline">\(Z(1,0)\)</span>点，此时有<span class="math inline">\(Z_L=Z_0\)</span>，传输线匹配，驻波比为1</li><li>开路点：<span class="math inline">\(\Gamma(1,0)\)</span>点，对应<span class="math inline">\(Z(\infty,\infty)\)</span>点，此时<span class="math inline">\(Z_L=\infty\)</span>，传输线处于开路状态，驻波比无穷大</li><li>短路点：<span class="math inline">\(\Gamma(-1,0)\)</span>点，对应<span class="math inline">\(Z(0,0)\)</span>点，此时<span class="math inline">\(Z_L=0\)</span>，传输线短路，驻波比无穷大</li></ol><p><strong>三个圆：</strong></p><ol type="1"><li><p>等电抗圆：指的是圆心在直线<span class="math inline">\(x=1\)</span>上的那些圆，在一个等点抗圆上的点有相等的电抗。在上半平面的电抗大于零，叫做感性；在下半平面的电抗小于零，叫做容性。</p></li><li><p>等电阻圆：指的是圆心在实轴（横轴）上的那些圆，在一个等电阻圆上的点有相等的电阻</p></li><li><p>等反射系数圆（也叫等驻波比圆）：指的是圆心在<span class="math inline">\(\Gamma (0,0)\)</span>的圆。圆的半径和反射系数以及驻波比有一一对应关系。当反射系数为正实数（即在实轴正半轴）时，对应电压波腹点，于是实轴正半轴叫做电压波腹线；同理，实轴负半轴叫做电压波节线。</p><p>当在传输线上移动<span class="math inline">\(\Delta z=\lambda/2\)</span>时，对应沿等反射系数圆旋转一圈，方向为“源顺负逆”。</p></li></ol><p>于是，在圆图中任意确定一个点，总能找到一个等电抗圆和一个等电阻圆与之对应，这样一来，我们就能读出这个点的阻抗。要确定传输线上其它点的阻抗，只需要按照源顺负逆的规则，在等反射系数圆上进行移动即可。</p><h2 id="波导理论">波导理论</h2><h3 id="导行波的传播特性">导行波的传播特性</h3><p>导行波的场量都有因子<span class="math inline">\(e^{-\gamma z}\)</span>，其中<span class="math inline">\(\gamma=\alpha+j\beta\)</span>。由麦克斯韦方程和边界条件推导（意思就是我也不想推导）可知： <span class="math display">\[\gamma=k^2_c-k^2\]</span> 其中<span class="math inline">\(k=\omega\sqrt{\mu\varepsilon}\)</span>为电磁波在无限媒质中的波数，它由波的频率和传播介质决定。<span class="math inline">\(k_c\)</span>叫波导的截止波数，它由波导系统横截面的边界条件决定，这两个“波数”都是实数。于是，随着频率的不同，<span class="math inline">\(\gamma\)</span>有以下三种情况：</p><ul><li><span class="math inline">\(\gamma^2&lt;0\)</span>，此时有<span class="math inline">\(\gamma=j\beta\)</span>，因为场量不随着距离增长而衰减，称为传输状态。</li><li><span class="math inline">\(\gamma^2&gt;0\)</span>，此时有<span class="math inline">\(\gamma=\alpha\)</span>，此时场量随着距离增长而指数衰减，称为截止状态。</li><li><span class="math inline">\(\gamma^2=0\)</span>，这个叫临界状态，分析时认为不属于传输状态，波不能传输。</li></ul><p>既然有了“截止波数”<span class="math inline">\(k_c\)</span>的定义，我们也可以顺势定义出截止频率、截止波长：</p><ul><li><p>截止频率<span class="math inline">\(f_c\)</span> <span class="math display">\[f_c=\frac{k_c}{2\pi\sqrt{\mu\varepsilon}}\]</span></p></li><li><p>截止波长<span class="math inline">\(\lambda_c\)</span> <span class="math display">\[\lambda_c=\frac{v}{f_c}=\frac{2\pi}{k_c}\]</span> 其中<span class="math inline">\(v\)</span>是理想介质<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="就是不导电的介质，不是自由空间。">[1]</span></a></sup>中的光速。</p></li></ul><p>于是，导波系统传输TE波或TM波的条件是： <span class="math display">\[f&gt;f_c\ \text{or}\ \lambda&lt;\lambda_c\]</span> 我们进一步分析传输状态时的导行波。理想导波系统中的相波长<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="等相面在一个周期内移动的距离">[2]</span></a></sup>称为波导波长，记作<span class="math inline">\(\lambda_g\)</span>。根据相波长和相位常数的定义，有： <span class="math display">\[\beta=\frac{2\pi}{\lambda_g}\]</span> 我们可以计算出，对于相位常数<span class="math inline">\(\beta\)</span>，有： <span class="math display">\[\beta=\sqrt{k^2-k_c^2}=\frac{2\pi}\lambda\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}\]</span> 于是，相波长为 <span class="math display">\[\lambda_g=\frac{\lambda}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}=\frac{\lambda_0/\sqrt{\mu_r\varepsilon_r}}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}\]</span> 根据相速度的一般公式<span class="math inline">\(v_p=\omega/\beta\)</span>，相速度为： <span class="math display">\[v_p=\frac{c/\sqrt{\mu_r\varepsilon_r}}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}\]</span> 根据群速度的一般公式<span class="math inline">\(v_g=d\omega/d\beta\)</span>，将<span class="math inline">\(\beta=\sqrt{k^2-k_c^2}\)</span>中的<span class="math inline">\(k\)</span>用<span class="math inline">\(\omega\sqrt{\mu\varepsilon}\)</span>表示，有： <span class="math display">\[v_g=v\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}\]</span> 以上就是会经常用到的一些传播特性参量。</p><h3 id="导波模式">导波模式</h3><h4 id="矩形波导">矩形波导</h4><p>导通模式下矩形波导中TM波的通解为：</p><p>【一大坨式子，里面有两个参量<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>】</p><p>这里的<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>就是波导边界条件决定的正整数，称作波指数。<span class="math inline">\(m\)</span>表示沿着波导长边分布的半驻波个数，<span class="math inline">\(n\)</span>表示沿着波导短边分布的半驻波个数。<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都不能是零。每一个<span class="math inline">\((m,n)\)</span>都对应着一种电磁场分布，即一种波形，或者说，模式，记作<span class="math inline">\(TM_{mn}\)</span></p><p>导通模式下矩形波导中TE波的通解为：</p><p>【一大坨式子，里面有两个参量<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>】</p><p>这里的<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都是自然数，但是不能同时为零。每一个<span class="math inline">\((m,n)\)</span>都对应着一种模式，记作<span class="math inline">\(TE_{mn}\)</span></p><p>将各种<span class="math inline">\(TM_{mn}\)</span>和<span class="math inline">\(TE_{mn}\)</span>相互叠加，就能表示出矩形波导中所有可能存在的波形。那么怎么知道某种模式是否存在呢？我们有： <span class="math display">\[k_c^2=\left(\frac{m\pi}{a}\right)^2+\left(\frac{n\pi}{b}\right)^2\]</span> 也就是 <span class="math display">\[\lambda_c=\frac{2\pi}{k_c}=\frac{2}{\sqrt{\left(\frac{m\pi}{a}\right)^2+\left(\frac{n\pi}{b}\right)^2}}\]</span> 考察波的<span class="math inline">\(k\)</span>(由频率和介质决定)，当满足传输条件<span class="math inline">\(k&gt;k_c\)</span>或<span class="math inline">\(\lambda&lt;\lambda_c\)</span>时，就存在对应的模式。观察这个式子，我们发现当<span class="math inline">\(m,n\)</span>对应相等时，TM波和TE波有着相同的截止波数，我们把这样的现象叫做模式简并<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="严格的定义是：模式简并：截止波数相同但是场分布不同的现象">[3]</span></a></sup>。</p><p>通常，我们称截止波数最小（截止波长最大）的模式为主模，也叫基本模式或者最低模式。矩形波导的主模是<span class="math inline">\(TE_{10}\)</span>模。</p><h4 id="圆波导">圆波导</h4><p>圆波导的分析的大概形状和矩形波导是类似的，也有TE、TM波。</p><p>TM通解为：</p><p>【一大坨式子，里面有个参量<span class="math inline">\(u_{ni}\)</span>】</p><p>其中<span class="math inline">\(u_{ni}\)</span>表示第一类<span class="math inline">\(n\)</span>阶贝塞尔函数的第<span class="math inline">\(i\)</span>个零点。<span class="math inline">\((n,i)\)</span>代表了一个TM波的模式，记作<span class="math inline">\(TM_{ni}^\circ\)</span></p><p>TE通解为：</p><p>【一大坨式子，里面有个参量<span class="math inline">\(v_{ni}\)</span>】</p><p>其中<span class="math inline">\(v_{ni}\)</span>表示第一类<span class="math inline">\(n\)</span>阶贝塞尔函数的导数的第<span class="math inline">\(i\)</span>个零点。<span class="math inline">\((n,i)\)</span>代表了一个TE波的模式，记作<span class="math inline">\(TE_{ni}^\circ\)</span></p><p>圆波导的截止波长一般查表给出。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211072249964.png" alt="截止波数表" /><figcaption aria-hidden="true">截止波数表</figcaption></figure><p>在圆波导中，存在两种模式简并。第一种是E-H简并，因为对于第一类贝塞尔函数有<span class="math inline">\(J&#39;_0(x)=-J_1(x)\)</span>，所以<span class="math inline">\(J&#39;_0\)</span>和<span class="math inline">\(J_1\)</span>的零点相等，因此<span class="math inline">\(H_{0i}\)</span>和<span class="math inline">\(E_{1i}\)</span>简并。第二种叫极化简并，是因为坐标<span class="math inline">\(\varphi\)</span>的完全对称性引起的。在圆波导中，电磁场的横向分布存在着<span class="math inline">\(\cos n\varphi\)</span>和<span class="math inline">\(\sin n\varphi\)</span>两种形式，它们具有相同的截止波长，只是极化方向旋转90度。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>就是不导电的介质，不是自由空间。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>等相面在一个周期内移动的距离 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>严格的定义是：模式简并：截止波数相同但是场分布不同的现象 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221031-20221106）</title>
    <link href="/2022/11/06/%E5%91%A8%E8%AE%B0%EF%BC%8820221031-20221106%EF%BC%89/"/>
    <url>/2022/11/06/%E5%91%A8%E8%AE%B0%EF%BC%8820221031-20221106%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第十周，一个学期又快要结束了（指还剩下7周），稍微有点焦虑。本周精神状态、身体状态良好，学习状态佳，还是挺不错的。周三的时候和友人一起去故宫了，故宫确实好看，但是只转了一个下午，属于是有点潦草了。另外，这周还买了D9音乐会的票，这玩意之前我也是每年看一次的，还以为不办了呢，结果又回来了，有点开心。</p><p>这周打了原神3.2和赛博朋克2077，以及Ever17。Ever17打通了第一条线，赛博朋克就剩最后一个结局了。所以说，精神状态和心理状态好了，干啥都好。</p><p>这周电赛的成绩出来了，二等奖，算是“还行”吧，挺不错的。集成电路马上就来了，要抓紧学习了。</p><p>这周做了俩实验，微波实验的一个表看着比我还老，春春的逆天，哈哈</p><p>这周继续阅读了论中国这本书，下周说不定能看完了。</p><p>这周，我们来议论一下提瓦特大陆各国的政治体制，分析一下“教令院之变”的过程。</p><p>分析提瓦特的政治，不能照搬照抄我们这个世界的理论。毕竟，人家是异世界嘛。提瓦特目前的四个国家，尽管风土人情、政治体制、权力部门设置区别很大，但是有一个不变的共同点，那就是“君权神授”。而且，这里的神不同于在我们这个世界流毒甚广的亚伯拉罕一神教的神，这里的神是个活生生的，权能极大的真“人”。在提瓦特，谁掌握了神权，谁能称为神的代言人，谁就能拥有一切。</p><p>蒙德国，尽管风神巴巴托斯在大部分人看来是个酒鬼流浪汉，但是国家的立国理念“自由”被攥在神权手中。当风神弹琴时，统治机构西风骑士团的代理团长也得安安静静站在一旁听着，她还得在国家的各种重要场合邀请这个酒鬼流浪汉出席。</p><p>璃月国，岩王帝君摩拉克斯自导自演了一出退休戏码，神权似乎隐退了。但是事实果然如此吗？非也。在璃月，仙人作为神的代言人，行使着神权。例如月海亭秘书长甘雨就一直权柄在握，不如说，璃月七星必须让她掌握大权。到了过节了，璃月七星还得亲自去给仙人送礼慰问。</p><p>稻妻国，三奉行深知，稻妻之所以存在至今，完全是因为雷神巴尔泽布的存在，更准确地说，是因为“无想的一刀”的存在，以至于到了对其“迷信”的地步。三奉行知道，自己能吃拿卡要，能作威作福，完全是巴尔泽布（及其创造的机器人）赐予的。在巴尔泽布逮捕当朝三分之二的高官时，没有遇到任何形式的抵抗：将军说什么就是什么——不然，你来挥出“无想的一刀”？</p><p>须弥国，是目前最接近“人治”的国家。但是教令院君主立宪制的合法性来源于何处？来源于大慈树王的神权，包括最重要的统治工具——虚空——也是如此。大慈树王山陵崩后，教令院以她的神权为后盾，都督须弥诸军事。但是，教令院也知道，自己的合法性的最大来源已经死了，于是他们软禁新神，并试图创造属于自己的<a href="https://www.zhihu.com/search?q=伪神&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2747711192%7D">伪神</a>，以便在彻底瞒不过去后寻找新的合法性。</p><p>但是，教令院没有想到，他们低估了真正的神之权能，他们软禁的纳西妲是一位优秀的政治家。这位政治家有着优秀的品质：谦逊和忍耐，也就是“<strong>战略定力</strong>”。她能耐得住五百年的寂寞，观察须弥和提瓦特的社会各阶层，等待教令院自我毁灭。终于，她等到了教令院的致命失误，在一场政变中把教令院卖国集团一波带走。</p><p>在进入须弥前不久，须弥国的主要矛盾是什么？很简单，是<strong>世界树的污染</strong>。那么谁能根治世界树的污染？很简单，有且仅有一个人，那就是纳西妲，那就是摩诃善法大吉祥智慧主布耶尔。大道理管着小道理，这就是纳西妲能成功大政奉还的最大的道理。</p><p>此外，须弥国还面临着其它严重的危机，换句话说，教令院正在犯下严重的错误。</p><p>第一，<strong>城乡发展不平衡</strong>，沙漠人民和雨林人民矛盾日益加深，国家处在分裂的边缘；</p><p>第二，<strong>教令院高层出现分裂</strong>，六贤者中呈现了四对二的局面；</p><p>第三，<strong>政治中心须弥城的防卫部队竟然大部分都是外包的</strong>，而且几乎全是地位低下的沙漠人民；（是不是二次元都喜欢让战斗角色的政治地位较低？其它例子如86、EVA、末日时在做什么等等）</p><p>第四，<strong>死域、魔鳞病等灾害愈演愈烈</strong>，当然这是主要矛盾的副作用；</p><p>最后，<strong>教令院卖国集团勾结愚人众境外势力</strong>，借用民众大脑制造伪神，妄图给自己塑造新的合法性。</p><p>此时，<strong>西风骑士团荣誉骑士、绝云间归来之人、璃月港的大英雄、雷电将军御侧侍卫、稻妻几乎全部国土的再生父母——大名鼎鼎的旅行者来了，纳西妲觉得是时候了。</strong></p><blockquote><p>咔咔，请您下决心吧！</p></blockquote><p>在旅行者还没到达须弥，还在海岛度假时，纳西妲抢先一步和旅行者建立了联系。后来，在梦境事件中，纳西妲和旅行者建立了深厚的革命友谊（她说我是她的唯一！）。</p><p>为什么选定了旅行者？因为她可以提供极强的羁绊（或者说，关系）。旅行者说话，有人信。试想如果是普通须弥人告诉艾书记、赛诺等人梦境事件，他大概只有一个结果，那就是被当成林居诳语期然后扔到阿如村。但是旅行者不一样，旅行者上通神灵下通百姓，权势滔天功勋卓著，平易近人无私奉献，简直就是天降圣人（唯一的缺点可能就是成天发情，盒盒）。旅行者让艾书记、提纳里和赛诺相信了小吉祥草王“居然还活跃在须弥”，于是才能有后面的教令院之变。与此同时，旅行者还办了一件事，那就是消弭了赤王信徒和草王信徒的宗教矛盾，为日后的计划奠定了基础。</p><p>终于，爷一行人抵达了教令院，开始了政变。</p><p>第一步，拥有了至高无上的<strong>合法性宣称</strong>：智慧之神纳西妲。</p><p>第二步，通过伪装被捕的方式在全国政治中心埋下一支<strong>精锐武装部队</strong>。</p><blockquote><p>拉赫曼将军，就由你来打头阵吧！</p></blockquote><p>第三步，调离或策反首都警卫力量。在沙漠人民和雨林居民矛盾不断恶化的时代，只要纳西妲提出乡村（沙漠）振兴计划，拿出<strong>解决城乡发展不平衡的诚意</strong>（解决了问题一），消弭赤王和草王的信仰分歧，拿钱办事的沙漠雇佣兵很难不倒戈（解决了问题三）。</p><blockquote><p>我们军人是很单纯的，生来就是为国家服务的！</p></blockquote><p>第四步，待对方首脑防卫空虚，立刻派出赛诺<strong>直接将其逮捕</strong>。</p><blockquote><p>大贤者从愚人众处收受不少的金钱吧！因此我们有必要听取大贤者的陈述，请贤者合作。</p></blockquote><p>第五步，纳西妲以迅雷不及掩耳之势<strong>控制了全国的广播站、电视台</strong>（也就是虚空）<strong>，</strong>发表题为《散兵怎么打，在线等，急》的<strong>全国虚空讲话</strong>，正式荣登大宝。此时，爷和纳西妲以坚决的斗争姿态清除了教令院的残余抵抗势力散兵。</p><blockquote><p>须弥人民们！在我们祖国和我国各族人民命运面临严峻危急的时刻，我们向你们发出呼吁！我们伟大的祖国面临致命的危险！由阿扎尔发起并开始的改革政策，原想作为保障教令院迅速发展的手段，却因种种原因已走入死胡同。失去信仰、冷漠和绝望取代了最初的热情和希望。教令院失去了人民的信任。在社会生活中，玩弄权术取代了对国家和人民命运的关心。整个须弥实际上已失去控制。</p></blockquote><p>这时候，政变看似已经基本结束了，可以开香槟了。是这样的吗？</p><p>看似是的，但是纳西妲非常清醒，她记得自己的政变能成功的<strong>大道理</strong>，也记得须弥的<strong>主要矛盾</strong>。于是她没有着急控制局势，收拾残局，而是直接用神的权能根治了世界树，治好了魔鳞病，遏制了死域发展（解决了问题四），自此，<strong>小吉祥草王和大慈树王二位一体</strong>，获得了完美无缺的政权宣称。紧接着，她和博士展开战略博弈，一口气完成了几件小小的战略目标：</p><p>首先有一个，就是<strong>加入了至冬国的反抗天理阵营</strong>。二一个就是获得了<strong>至冬国和国际社会对新生政权的承认</strong>，要说还有一个就是<strong>博士一律不许切片</strong>，这对须弥的安全来说也是很重要的一个。</p><p>至此，纳西妲执掌了政权，站稳了脚跟，获得了国际社会的认可，还狠狠地削了博士一把。之后，艾书记等人将教令院拨乱反正，粉碎了四贤者卖国集团，但没有开展大清洗，而是保留了绝大多数原有的精英。紧接着，艾书记急流勇退，纳西妲正式执政。接下来 她面临的问题就是：须弥新的主要矛盾是什么？须弥社会怎么和平稳定地发展？我们只能拭目以待了。</p><p>周日晚上我看了摇曳露营，我的评价是一部温馨而慢节奏的励志片，非常好看，推荐大家看。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211070028289.jpg" alt="摇曳露营" /><figcaption aria-hidden="true">摇曳露营</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221024-20221030）</title>
    <link href="/2022/10/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221024-20221030%EF%BC%89/"/>
    <url>/2022/10/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221024-20221030%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第九周，也就是这学期已经过去一半了。这周我的心情总体来说有点不好，因为我发现我的学习状态不是特别好。但是在周末已经努力改回来了，现在就看下周能不能继续保持住了。我估计下周会很忙，因为周二和周四各有两个实验，也不知道怎么做。</p><p>这周有一件大事，那就是校庆。我和友人一起去了，虽然因为去得比较晚，几乎啥奖品都没了。但是我得到了宋友便利贴，以及和友人一起逛校庆的经历，我以及赢麻了。虽然但是，校庆晚会上的“北京航天航空大学”属实是给我整绷不住了，就你航管宣传的这伙人，我不好说了，只能说是烂泥扶不上墙吧。</p><p>这周继续看论中国、以及一些科幻小说，游戏继续玩Ever17，以及赛博朋克。动画的话，想看孤独摇滚，明天就看。</p><p>在这周，我进行了一些思考。我认为中国的“谈话-酝酿-确认”模式，确实比西方的“辩论-投票”模式更加高级。首先：“辩论”这个行为，对人的临场反应能力，以及调动听众的情绪的能力的要求很高；而“谈话”（或者，写长文等），这种形式更考察人的深入思考、全面思考、冷静思考，以及想法和书面语之间的相互转化能力，以辨明真理为最高目标，而不以在言语上驳倒他人为最高目标。就我观察的几场辩论而言，双方为了驳倒对方，往往会深究某些不是主要矛盾的“定义”（例如，在“原神是不是国产游戏的黎明”议题中，双方对“黎明”进行了很长时间的辨析，但是这是主要矛盾吗？），攻击对方言语上的漏洞，或者试图调动观众的情绪。那么这两种要求哪个是作为一个国家的执政者更需要掌握的呢？我认为是第二个。当希特勒说出“你们是八百万德意志人，还是八百万奴隶”时，当然所有听众的情绪都被调动了，然后就把他选成德国总理，给全世界带来了深重的灾难。辩论、集会、演讲，选出来的是语言家、表演家，而不一定是政治家。</p><p>其次，我们来考量一下“投票”。我写了一些，但是我感觉写得不好，然后删了。总之我的观点是：民主不等同于人民直接决定政治领导人的过程，我国的全过程民主更接近民主的本质。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310008897.jpg" alt="绿园的秋" /><figcaption aria-hidden="true">绿园的秋</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310008371.jpg" alt="七公寓门前" /><figcaption aria-hidden="true">七公寓门前</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310008496.jpg" alt="图书馆门前" /><figcaption aria-hidden="true">图书馆门前</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310009850.jpg" alt="站点披萨，真他妈好吃！" /><figcaption aria-hidden="true">站点披萨，真他妈好吃！</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310009878.jpg" alt="为庆祝北航生日吃蛋糕，当然实际上就是想吃蛋糕了" /><figcaption aria-hidden="true">为庆祝北航生日吃蛋糕，当然实际上就是想吃蛋糕了</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理笔记</title>
    <link href="/2022/10/26/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/26/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="第二章离散时间信号与系统">第二章：离散时间信号与系统</h2><h3 id="离数时间序列">离数时间序列</h3><p>序列的表示方式略。</p><h4 id="序列的分类">序列的分类</h4><p>有限长度/无限长度序列、左/右/双边序列、因果/非因果序列、实/复数序列的定义很显然，就是字面意思，略。</p><ul><li><p>周期序列和非周期序列</p><p>周期序列的定义： <span class="math display">\[\exists N\neq 0\ \forall n\ x[n]=x[n+N]\]</span> 满足上面式子的序列称为周期序列，否则称为非周期序列。需要提醒的是：如果一个序列满足上面的式子，它一定是无限长的双边序列，也就是<span class="math inline">\(n\)</span>从负无穷取遍正无穷。例如：<span class="math inline">\(x[n]=\sin (\pi n/5)\)</span>是周期序列，但<span class="math inline">\(x[n]=u[n]\sin(\pi n/5)\)</span>不是周期序列。</p></li><li><p>能量序列和功率序列</p><p>如果对序列<span class="math inline">\(x[n]\)</span>有： <span class="math display">\[E=\sum_{n=-\infty}^{\infty}\lvert x[n]\rvert^2&lt;\infty\]</span> 称该序列为能量有限序列，简称能量序列。对于能量无限序列，如果另有： <span class="math display">\[P=\lim_{N\to \infty}\frac{1}{2N+1}\sum_{n=-N}^N \lvert x[n] \rvert ^2&lt;\infty\]</span> 则称该序列为功率有限序列，简称功率序列。需要注意的是：周期序列一般来说都是功率序列。周期序列的功率为： <span class="math display">\[P=\lim_{N\to \infty} \frac{1}{N} \sum_{n=n}^{N-1}\lvert x[n]\rvert^2\]</span></p></li></ul><h4 id="常见序列">常见序列</h4><p>矩形序列、脉冲序列、阶跃序列、实指数序列略。</p><ul><li><p>复指数序列</p><p>对于指数序列 <span class="math display">\[x[n]=A\alpha^n\]</span> 如果<span class="math inline">\(A,\alpha\)</span>是复数，那么这个序列是复指数序列。若有<span class="math inline">\(A=|A|\angle \varphi,\alpha=|\alpha|\angle \omega_0\)</span>，则复指数序列也可以表示成： <span class="math display">\[x[n]=|A||\alpha|^n\exp [j(\omega_0n+\varphi)]\]</span> 复指数序列表现为一列不断收缩或者扩张的螺旋。特别地，当<span class="math inline">\(|\alpha|=1\)</span>时，复指数序列的幅值保持不变。此时，如果满足 <span class="math display">\[\frac {\omega_0}{2N}\in \mathbb Q\]</span> 则复指数序列是周期序列。其周期为： <span class="math display">\[N=\frac{2\pi m}{\omega_0}\in \mathbb Z^+\]</span> 其中<span class="math inline">\(m\)</span>是能让<span class="math inline">\(N\)</span>成为正整数的整数。</p><blockquote><p>【例】计算以下序列的最小正周期： <span class="math display">\[x[n]=e^{j\frac {6\pi}{31}n}\]</span> 【解】由于 <span class="math display">\[N=\frac{2\pi m}{\omega}=\frac{31}{3}m\]</span> 取<span class="math inline">\(m=3\)</span>，得最小正周期为<span class="math inline">\(N=31\)</span></p></blockquote><p>无论复指数序列是不是周期序列，<span class="math inline">\(\omega_0\)</span>都称作这个序列的数字频率。对于连续时间信号来说，频率越大，信号震荡得越快。但是对于复指数序列来说，<span class="math inline">\(\omega_0\)</span>从<span class="math inline">\(0\)</span>增加到<span class="math inline">\(\pi\)</span>时，振荡得越来越快；从<span class="math inline">\(\pi\)</span>增加到<span class="math inline">\(2\pi\)</span>时，振荡得越来越慢，并且以<span class="math inline">\(2\pi\)</span>为周期。</p><p>这初看有些不好理解，但是实际上是因为复指数序列是离散时间序列，时间最细的粒度是<span class="math inline">\(1\)</span>（不同于连续时间序列的时间定义在连续统上，时间最细的粒度是无穷小）。复指数序列振荡最快的情形，可以想象这样的序列： <span class="math display">\[x[n]=Ae^{j\pi n}\]</span> 也就是<span class="math inline">\(x[n]=A(-1)^n\)</span>，它振荡得再快，也就是每过1个时间变一下符号而已嘛。</p><p>当<span class="math inline">\(\omega_0&gt;0\)</span>时，表示在复平面内逆时针旋转，否则为顺时针旋转。</p></li></ul><h3 id="离散时间系统">离散时间系统</h3><p>和连续时间系统的理论差不多，有线性、时不变、因果、记忆、稳定等等。</p><p>对于线性时不变<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="需要注意的是，我们平常做题见到的很多系统都不是线性时不变系统。例如：如果进行了压扩变换，那么系统往往是时变的。我们平常所进行的“调幅”(即频率搬移)乘以一个$\cos$​，由于产生了新的频率分量，也不是线性时不变的。">[1]</span></a></sup>系统，同样可以用卷积表示。即：如果<strong>线性时不变系统</strong>的单位脉冲响应是<span class="math inline">\(h[n]\)</span>，对于任意输入序列<span class="math inline">\(x[n]\)</span>，有响应： <span class="math display">\[y[n]=\sum_{k=-\infty}^\infty x[k]h[n-k]=x[n]*h[n]\]</span></p><p>卷积有交换律、结合律，对加法有左分配律。</p><p>LTI系统是因果系统等价于其单位脉冲响应是因果序列。</p><p>LTI系统稳定等价于其单位脉冲响应绝对可和，即： <span class="math display">\[S=\sum_{k=-\infty}^\infty \lvert h[k] \rvert &lt; \infty\]</span></p><ul><li><p>线性常系数差分方程</p><p>差分方程的概念、表示方法和解法略，在之前的“Z变换”一文中有说明。</p><p>线性系统的输入序列<span class="math inline">\(x[n]\equiv 0\)</span>时，有输出序列<span class="math inline">\(y[n]\equiv 0\)</span>。这个结论是显然成立的：如果对于<span class="math inline">\(x[n]\equiv 0\)</span>的输出不全为零的话，设<span class="math inline">\(a[n]\)</span>单独输入时的输出为<span class="math inline">\(b[n]\)</span>，那么对于<span class="math inline">\(a[n]+x[n]\)</span>的输入，输出将为<span class="math inline">\(b[n]+y[n]\)</span>，可是<span class="math inline">\(a[n]+x[n]=a[n]\)</span>呀，<span class="math inline">\(y[n]\)</span>不全为零，那么系统对于同样的输入不就有两个不同输出了吗？这显然是荒诞的。</p><blockquote><p>【例】对于下列方程描述的系统： <span class="math display">\[y[n]-ay[n-1]=x[n]\]</span> 初始条件为<span class="math inline">\(y[-1]=1\)</span>，那么这是线性系统吗？</p><p>【解】对于全零输入，其输出序列为<span class="math inline">\(y[n]=a^{n+1}\)</span>，不全为零，因此不是线性系统。</p></blockquote><p>这道例题说明：不是一切用常系数线性差分方程表示的系统都是线性系统，更不用说线性时不变了。事实上，如果要系统是因果的LTI系统，必须要满足“初始松弛”的条件，也就是初始状态为零。</p></li></ul><h2 id="dtftdfs和z变换">DTFT、DFS和Z变换</h2><h3 id="离散时间傅里叶变换dtft">离散时间傅里叶变换(DTFT)</h3><p>首先，我们可以回忆一下连续时间信号的傅里叶变换： <span class="math display">\[\begin{align}X(j\Omega)=\int_{-\infty}^\infty x(t)e^{-j\Omega t}\mathbf dt\\x(t)=\frac{1}{2\pi}\int_{-\infty}^\infty X(j\Omega)e^{j\Omega t}\mathbf d\Omega\end{align}\]</span></p><h4 id="dtft的定义">DTFT的定义</h4><p>和连续时间傅里叶变换类似，DTFT是要把序列<span class="math inline">\(x[n]\)</span>表示序列<span class="math inline">\(e^{j\omega n }\mathbf d\omega\)</span>的线性组合： <span class="math display">\[x[n]=\frac{1}{2\pi}\int_{-\infty}^\infty X(e^{j\omega})e^{j\omega n}d\omega\]</span> 则权函数可以表示为： <span class="math display">\[X(e^{j\omega})=\sum_{n=-\infty}^\infty x[n]e^{-j\omega n}\]</span> 这就是离散时间傅里叶变换的性质。需要强调的是：<span class="math inline">\(X(e^{j\omega})\)</span>是<span class="math inline">\(\omega\)</span>的连续函数，称为频谱密度函数。它是周期为<span class="math inline">\(2\pi\)</span>的周期函数。</p><h4 id="dtft的性质和相关定理">DTFT的性质和相关定理</h4><p>假如<span class="math inline">\(x[n]\)</span>的DTFT是<span class="math inline">\(X(e^{j\omega})\)</span>，那么</p><ol type="1"><li><p>线性</p></li><li><p>时域移位性质： <span class="math display">\[x[n-n_d]\to e^{j\omega n_d}X(e^{j\omega})\]</span> 时域移位不会影响幅度频谱，但会引起相位频谱的线性变化，其斜率为<span class="math inline">\(-n_d\)</span></p></li><li><p>频域移位性质： <span class="math display">\[e^{j\omega_0n}\to X(e^{j(\omega-\omega_0)})\]</span></p></li><li><p>时间倒置性质： <span class="math display">\[x[-n]=X(e^{-j\omega})\]</span></p></li><li><p>频域微分性质： <span class="math display">\[nx[n]\to j\frac{d X}{d\omega}\]</span></p></li><li><p>共轭性质： <span class="math display">\[x^*[n]\to X^*(e^{-j\omega})\]</span></p></li><li><p>时、频域卷积，帕塞瓦尔定理。</p></li></ol><h4 id="dtft的对称性">DTFT的对称性</h4><p>对于一个序列<span class="math inline">\(x[n]\)</span>，有其共轭逆序序列<span class="math inline">\(x^*[-n]\)</span>，利用这个序列，我们可以把原序列分解<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="为什么说“分解”呢？因为$x[n]=x_e[n]+x_o[n]$显然成立。">[2]</span></a></sup>成共轭对称序列和共轭反对称序列，即： <span class="math display">\[\begin{align}x_e[n]=\frac 12(x[n]+x^*[-n])\\x_o[n]=\frac 12(x[n]-x^*[-n])\end{align}\]</span> 同样，对于连续函数（当然这里说的连续函数就是<span class="math inline">\(X(e^{j\omega})\)</span>，也可以按照类似的方法进行分解。</p><p>共轭对称序列<span class="math inline">\(x_e[n]\)</span>的实部偶对称，虚部奇对称；共轭反对称序列<span class="math inline">\(x_o[n]\)</span>的实部奇对称，虚部偶对称。</p><p>利用“共轭性质”，“线性性质”，有： <span class="math display">\[\begin{align}x_{Re}[n]\to X_e(e^{j\omega})\\jx_{Im}[n]\to X_o(e^{j\omega})\\x_e[n]\to X_{Re}(e^{j\omega})\\x_o[n]\to jX_{Im}(e^{j\omega})\end{align}\]</span> 由第一个式子，可以看出：实序列的DTFT幅度谱是偶函数，相位谱是奇函数。</p><h3 id="离散傅里叶级数dfs">离散傅里叶级数（DFS）</h3><p>DFS就是把DTFT里面的<span class="math inline">\(\omega\)</span>换成<span class="math inline">\(2\pi k/N\)</span>，其中<span class="math inline">\(N\)</span>是原序列的周期，<span class="math inline">\(k\)</span>是变换后得到的权序列的自变量。</p><h3 id="z变换">Z变换</h3><p>没啥好说的这个，上学期都学过了。</p><p>首先要注意的就是，<span class="math inline">\(X(z)\)</span>本质上来说还是个幂级数，以原序列为系数，即： <span class="math display">\[X(z)=\sum_{n=-\infty}^{\infty}x[n]z^{-n}\]</span> 在分析某些问题时，这种思维会很有用。</p><h2 id="离散系统变换域分析">离散系统变换域分析</h2><p>表示LTI系统有很多方法，我们常用三种：</p><ul><li>单位脉冲响应 <span class="math inline">\(h[n]\)</span></li><li>单位脉冲响应的频谱密度函数（DTFT） <span class="math inline">\(H(e^{j\omega})\)</span></li><li>系统函数（单位脉冲响应的Z变换） <span class="math inline">\(H(z)\)</span></li></ul><h3 id="lti系统的频域表示">LTI系统的频域表示</h3><h4 id="特征函数和频率响应">特征函数和频率响应</h4><p>对于LTI系统，对于某些输入序列，输出序列是输入序列和某个复常数的乘积。这样的输入序列叫做特征函数，复常数叫做系统的特征值。</p><p>由于输入序列为<span class="math inline">\(x[n]=e^{j\omega n}\)</span>时，有 <span class="math display">\[y[n]=x[n]*h[n]=\sum_{k=-\infty}^\infty e^{j\omega(n-k)}h[k]=e^{j\omega n}H(e^{j\omega})\]</span> 所以LTI系统的其中一个特征函数就是<span class="math inline">\(x[n]=e^{j\omega n}\)</span>（事实上，所有的指数型函数，例如<span class="math inline">\(5^n\)</span>等，都是特征函数，而且，指数型函数和指数型函数的有限项乘积也是特征函数，但是形容<span class="math inline">\(e^{j\omega n}u[n]\)</span>这种就不行），其对应的特征值为<span class="math inline">\(H(e^{j\omega})\)</span>。</p><p>而且，由傅里叶变换，我们知道：序列<span class="math inline">\(x[n]\)</span>往往可以表示为<span class="math inline">\(e^{j\omega n}\)</span>的线性组合，即<span class="math inline">\(x[n]=\frac{1}{2\pi}\int_{-\pi}^\pi X(e^{j\omega})e^{j\omega n}d\omega\)</span>。于是，我们将其中的每一项乘以对应的特征值，就得到了输出<span class="math inline">\(y[n]=\frac{1}{2\pi}\int_{-\pi}^\pi X(e^{j\omega})H(e^{j\omega})e^{j\omega n}d\omega\)</span>。于是我们得到了： <span class="math display">\[Y(e^{j\omega})=X(e^{j\omega})H(e^{j\omega})\]</span> 如果LTI系统的相频响应满足<span class="math inline">\(\angle H(e^{j\omega})=-\omega n_d\)</span>，那么称这样的系统为线性相位系统。线性相位系统对所有频率分量<span class="math inline">\(e^{j\omega n}\)</span>造成的延迟均为<span class="math inline">\(n_d\)</span>。一般来说，我们用群延时衡量相位变化对信号的影响，有： <span class="math display">\[\tau(\omega)=-\frac{d}{d\omega}\angle H(e^{j\omega})\]</span> 如果群延时不是常数，那么会造成输出信号的失真，这称为色散。</p><h4 id="lti系统的z变换分析">LTI系统的Z变换分析</h4><p>对于以下差分方程表示的系统： <span class="math display">\[y[n]=\sum_{k=1}^N a_ky[n-k]+\sum_{k=0}^Mb[k]x[n-k]\]</span> 在有初始松弛条件（零状态）时，是因果LTI系统。其系统函数为： <span class="math display">\[H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^M b_kz^{-k}}{1-\sum_{k=1}^N a_kz^{-k}}\]</span> 也可以把它表示为因式的形式： <span class="math display">\[H(z)=\frac{b_0}{a_0}\frac{\prod_{m=1}^M(1-c_mz^{-1})}{\prod_{n=1}^N (1-d_nz^{-1})}\]</span> 关于系统的因果和稳定性，有如下结论：</p><ul><li>LTI系统是因果的 等价于 <span class="math inline">\(H(z)\)</span>的收敛域包含无穷远点</li><li>LTI系统是稳定的 等价于<span class="math inline">\(H(z)\)</span>在单位圆上是收敛的</li></ul><p>关于系统的零极点和幅频响应的关系，有如下结论：</p><ul><li>对于单零点系统，零点为<span class="math inline">\(c\)</span>，当<span class="math inline">\(\omega=\theta_c\)</span>时，幅频响应是极小值，零点越靠近单位圆，幅频响应的极小值越小，当零点在单位圆上时，这个极小值为<span class="math inline">\(0\)</span>(如果采用对数坐标则为负无穷)</li><li>对于单极点系统，极点为<span class="math inline">\(d\)</span>，当<span class="math inline">\(\omega=\theta_d\)</span>时，幅频响应是极大值，极点越靠近单位圆，幅频响应的极大值越大，当极点在单位圆上时，这个极大值为正无穷。极点在单位圆上或单位圆外，则系统不稳定。</li></ul><h4 id="有理系统的全通分解">有理系统的全通分解</h4><ul><li><p>幅频特性相同的系统</p><p>若有一个有理实系统，把其中的若干个零点或极点用它的共轭倒数代替，新系统的幅频响应和原来的系统相同。于是，如果设计好一个系统的幅频特性，一定存在符合要求的因果稳定LTI系统，其极点都在单位圆内。</p></li><li><p>全通系统</p><p>全通指的是<span class="math inline">\(|H(e^{j\omega})|\equiv1\)</span>的系统，仅有相频特性随频率变化而变化。全通系统的零极点相对单位圆是镜像共轭成对的。也就是说：如果<span class="math inline">\(a_i\)</span>是系统的零点，那么<span class="math inline">\((a_i^*)^{-1}\)</span>，即<span class="math inline">\(a_i\)</span>的共轭的倒数，定是全通系统的极点。而且，对于有理实系数系统来说，零点和极点本身也是共轭成对的，即如果<span class="math inline">\(b_i\)</span>是零点或极点，那么它的共轭一定也是零点或极点。</p><p>全通系统具有以下性质：</p><ul><li><p>相位特性随频率单调下降，即 <span class="math display">\[\frac{\rm d\theta(\omega)}{\rm d\omega}&lt;0\]</span></p></li><li><p>输入信号<span class="math inline">\(x[n]\)</span>和输出信号<span class="math inline">\(y[n]\)</span>的能量相同，即 <span class="math display">\[\sum_{n=-\infty}^\infty\lvert x[n]\rvert^2=\sum_{n=-\infty}^\infty\lvert y[n]\rvert^2\]</span></p></li><li><p>当频率<span class="math inline">\(\omega\)</span>从<span class="math inline">\(0\)</span>变化到<span class="math inline">\(\pi\)</span>时，<span class="math inline">\(N\)</span>阶全通系统的相位改变为<span class="math inline">\(N\pi\)</span></p></li></ul><p>全通系统的应用主要在作相位均衡器，或者通过级联全通系统的方法提高系统的稳定性。</p></li><li><p>最小相位系统</p><p>对于一个离散时间因果稳定系统，它的极点都在单位圆内。如果在此基础上，零点也都在单位圆内，那么这样的系统叫做最小相位系统<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="也就是说最小相位系统的意思就是零极点都在单位圆内。">[3]</span></a></sup>；如果零点全在单位圆外，叫最大相位系统；如果零点在单位圆内外都有，叫混合相位系统。</p><p>最小相位系统有以下性质：</p><ul><li>在所有幅频响应相同的因果稳定系统中，最小相位系统的相位延迟最小</li><li>在所有幅频响应相同的实系数因果稳定系统中，最小相位系统的群延时最小</li><li>最小相位系统的逆系统也是最小相位系统</li></ul><blockquote><p>【例】因果序列<span class="math inline">\(x[n]\)</span>的<span class="math inline">\(z\)</span>变换为 <span class="math display">\[X(z)=\frac{\left(1-\frac 12 z^{-1}\right)\left(1-\frac 14 z^{-1}\right)\left(1-\frac 15 z\right)}{\left(1-\frac 16 z\right)}\]</span> 又已知<span class="math inline">\(\alpha^nx[n]\)</span>是一个最小相位系统，求<span class="math inline">\(\alpha\)</span>的范围。</p><p>【解】只有不在单位圆内的有一个零点<span class="math inline">\(5\)</span>和一个极点<span class="math inline">\(6\)</span>。记<span class="math inline">\(y[n]=\alpha^nx[n]\)</span>，则有 <span class="math display">\[Y(z)=\sum_{n=-\infty}^\infty\alpha^nx[n]z^{-n}=X\left(\frac z\alpha\right)\]</span> 如果<span class="math inline">\(a_i\)</span>是<span class="math inline">\(X(z)\)</span>的零点或极点，那么<span class="math inline">\(a_i\cdot\alpha\)</span>就是<span class="math inline">\(Y(z)\)</span>的零点或极点。为了让<span class="math inline">\(Y(z)\)</span>的所有零极点都在单位圆内，只需调整<span class="math inline">\(\alpha\)</span>，让<span class="math inline">\(6\alpha\)</span>在单位圆内即可。于是有： <span class="math display">\[\alpha&lt;\frac 16\]</span></p></blockquote></li><li><p>有理系统的全通分解</p><p>任何有理系统函数都可以分解为最小相位系统<span class="math inline">\(H_{min}(z)\)</span>和全通系统<span class="math inline">\(H_{ap}(z)\)</span>级联的形式。假设系统仅有一个单位圆外的零点<span class="math inline">\((c^*)^{-1}\)</span>，即： <span class="math display">\[H(z)=H_1(z)(z^{-1}-c^*)\]</span> 则<span class="math inline">\(H_1\)</span>的零极点都在单位圆内，是最小相位系统。上式可以进一步表示为： <span class="math display">\[H(z)=H_1(z)(z^{-1}-c^*)\frac{1-cz^{-1}}{1-cz^{-1}}=H_1(z)(1-cz^{-1})\frac{z^{-1}-c^*}{1-cz^{-1}}\]</span> 其中<span class="math inline">\(\frac{z^{-1}-c^*}{1-cz^{-1}}\)</span>的零点是<span class="math inline">\((c^*)^{-1}\)</span>，极点是<span class="math inline">\(c\)</span>，互为共轭倒数，是全通系统，记作<span class="math inline">\(H_{ap}(z)\)</span>。因为<span class="math inline">\(|z|&lt;1\)</span>，其余部分是最小相位系统，记作<span class="math inline">\(H_{min}(z)\)</span>，于是分解完成。</p><p>上述过程的实质是在单位圆外零点<span class="math inline">\((c^*)^{-1}\)</span>的共轭倒数<span class="math inline">\(c\)</span>的位置放置了一个零点和一个极点。<span class="math inline">\(c\)</span>上的极点和<span class="math inline">\((c^*)^{-1}\)</span>这个零点一起构成了全通系统；<span class="math inline">\(c\)</span>上的极点和原来系统的其它零极点构成了最小相位系统。</p><blockquote><p>【例】把以下系统分解成全通系统和最小相位系统的级联 <span class="math display">\[H(z)=\frac{1-3z^{-1}}{1+\frac 12 z^{-1}}\]</span> 【解】该系统有<span class="math inline">\(z=-1/2\)</span>的极点和<span class="math inline">\(z=3\)</span>的零点。即<span class="math inline">\((c^*)^{-1}=3\)</span>，得<span class="math inline">\(c=1/3\)</span>。则有： <span class="math display">\[\begin{align}H(z)&amp;=\frac{-3}{1+\frac 12 z^{-1}}\left(z^{-1}-\frac 13\right)\\&amp;=-3\left(\frac{1-\frac 13z^{-1}}{1+\frac 12 z^{-1}}\right)\left(\frac{z^{-1}-\frac 13}{1-\frac 13z^{-1}}\right)\end{align}\]</span> 于是： <span class="math display">\[H_{min}(z)=-3\left(\frac{1-\frac 13z^{-1}}{1+\frac 12 z^{-1}}\right)\]</span></p><p><span class="math display">\[H_{ap}(z)=\left(\frac{z^{-1}-\frac 13}{1-\frac 13z^{-1}}\right)\]</span></p></blockquote></li></ul><h4 id="广义线性相位系统">广义线性相位系统</h4><p>所谓的线性相位的意思是，系统对不同频率的正弦信号所产生的相移和正弦信号的频率呈线性关系。即： <span class="math display">\[\angle H(e^{j\omega})=-\alpha \omega\]</span> 那么广义线性相位的意思就是，给这个加上一个常数，变成 <span class="math display">\[\angle H(e^{j\omega})=\beta-\alpha \omega\]</span> 经过一番数学推导，相频响应满足上面式子的系统的单位脉冲响应满足以下等式： <span class="math display">\[\sum_{n=-\infty}^\infty h[n]\sin(\omega(n-\alpha)+\beta)=0\]</span> 满足上面式子的情况的两组解如下：</p><ul><li><span class="math inline">\(\beta=0\)</span>或<span class="math inline">\(\pi\)</span>，<span class="math inline">\(2\alpha=M\in \mathbb N\)</span>，<span class="math inline">\(h[2\alpha-n]=h[n]\)</span></li><li><span class="math inline">\(\beta=\pi/2\)</span>或<span class="math inline">\(3\pi/2\)</span>，<span class="math inline">\(2\alpha=M\in \mathbb N\)</span>，<span class="math inline">\(h[2\alpha-n]=-h[n]\)</span></li></ul><p>于是，我们可以分出四种广义线性相位系统。</p><ul><li><p>第I类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>偶对称，而且<span class="math inline">\(M\)</span>是偶数。第I类的<span class="math inline">\(\beta=0,\pi\)</span>。所以相频响应是过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=m\pi,m\in \mathbb Z\)</span>偶对称。</p></li><li><p>第II类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>偶对称，而且<span class="math inline">\(M\)</span>是奇数。第II类的<span class="math inline">\(\beta=0,\pi\)</span>。所以相频响应是过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=2m\pi,m\in \mathbb Z\)</span>偶对称，关于<span class="math inline">\(\omega=(2m+1)\pi,m\in \mathbb Z\)</span>奇对称，幅度函数在<span class="math inline">\(\pi\)</span>时为零，不适合作高通、带阻滤波器。</p></li><li><p>第III类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=-h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>奇对称，而且<span class="math inline">\(M\)</span>是偶数。第III类的<span class="math inline">\(\beta=\pi/2,3\pi/2\)</span>。所以相频响应是不过原点的直线（过<span class="math inline">\((0,\pi/2)\)</span>或<span class="math inline">\((0,3\pi/2)\)</span>），斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=m\pi,m\in \mathbb Z\)</span>奇对称。</p></li><li><p>第IV类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=-h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>奇对称，而且<span class="math inline">\(M\)</span>是奇数。第IV类的<span class="math inline">\(\beta=\pi/2,3\pi/2\)</span>。所以相频响应是不过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=2m\pi,m\in \mathbb Z\)</span>奇对称，关于<span class="math inline">\(\omega=(2m+1)\pi,m\in \mathbb Z\)</span>偶对称，幅度函数在<span class="math inline">\(\pi\)</span>时为零，不适合作低通、带通滤波器。</p></li></ul><p>由于第3、4类广义线性系统的相移特性，可以作希尔伯特变换器使用。</p><p>对于广义线性系统而言，如果<span class="math inline">\(z_0\)</span>是系统的零点，那么<span class="math inline">\(z_0^{-1},z_0^*,(z_0^*)^{-1}\)</span>也是系统的零点。第2、3类的零点一定包含-1，第3、4类的零点一定包含1.</p><h2 id="信号的采样和重建">信号的采样和重建</h2><h3 id="连续信号的理想采样">连续信号的理想采样</h3><p>设原连续信号为<span class="math inline">\(x_c(t)\)</span>，用来采样的理想冲击串为<span class="math inline">\(s(t)\)</span>，采样得的连续采样信号为<span class="math inline">\(x_s(t)\)</span>，采样得的离散时间序列为<span class="math inline">\(x[n]\)</span>。其中采样用的理想冲击串的周期为<span class="math inline">\(T_s\)</span>。</p><h4 id="x_s和x_c的关系"><span class="math inline">\(X_s\)</span>和<span class="math inline">\(X_c\)</span>的关系</h4><p>这一部分是《信号与系统》的内容，这里只简单提一下。</p><p>首先我们知道，冲击串的傅里叶变换还是冲击串，即： <span class="math display">\[S(j\Omega)=\frac{2\pi}{T_s}\sum_{k=-\infty}^{\infty}\delta(\Omega-k\Omega_s)\]</span> 由傅里叶变换的乘积性质，有： <span class="math display">\[X_s(j\Omega)=\frac 1 {T_s}\sum_{k=-\infty}^\infty X_c(j\Omega-jk\Omega_s)\]</span> 即：<span class="math inline">\(x_s(t)\)</span>的频谱<span class="math inline">\(X_s(j\Omega)\)</span>是连续时间信号<span class="math inline">\(x_c(t)\)</span>的频谱<span class="math inline">\(X_c(j\Omega)\)</span>以采样周期<span class="math inline">\(\Omega_s=2\pi/T_s\)</span>的周期延拓，并以<span class="math inline">\(\frac 1{T_s}\)</span>加权的结果。所以，为了不使得频域混叠，需满足<span class="math inline">\(\Omega_s&gt;2\Omega_N\)</span>，其中<span class="math inline">\(\Omega_N\)</span>是原信号所含有的最高频分量的频率。</p><h4 id="xejomega和x_cjomega的关系"><span class="math inline">\(X(e^{j\omega})\)</span>和<span class="math inline">\(X_c(j\Omega)\)</span>的关系</h4><p>有： <span class="math display">\[X_s(j\Omega)=\sum_{n=-\infty}^{\infty}x[n]e^{-j\Omega nT_s}\]</span> 令<span class="math inline">\(\omega=\Omega T_s\)</span>，有： <span class="math display">\[X_s\left(j\frac{\omega}{T_s}\right)=\sum_{n=-\infty}^\infty x[n]e^{-j\omega n}\]</span></p><p>可以发现：使用<span class="math inline">\(1/T_s\)</span>对<span class="math inline">\(X_c(j\Omega)\)</span>加权且频率按<span class="math inline">\(\Omega=\omega/T_s\)</span>尺度变换，得到函数<span class="math inline">\(X_c(j\omega/T_s)/T_s\)</span>，将其以<span class="math inline">\(2\pi\)</span>为周期进行延拓，得离散序列<span class="math inline">\(x[n]\)</span>频谱<span class="math inline">\(X(e^{j\omega})\)</span>.</p><h3 id="连续信号的理想重建">连续信号的理想重建</h3><p>重建系统的示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301039578.png" alt="连续信号重建系统" /><figcaption aria-hidden="true">连续信号重建系统</figcaption></figure><p>先把离散时间信号序列<span class="math inline">\(y[n]\)</span>转化为连续时间信号<span class="math inline">\(y_s(t)\)</span>，然后让<span class="math inline">\(y_s(t)\)</span>经过截止频率为<span class="math inline">\(\pi/T_s\)</span>，幅度<span class="math inline">\(T_s\)</span>的低通滤波器，得到重建信号<span class="math inline">\(y_r(t)\)</span>。</p><p>即： <span class="math display">\[H_r(j\Omega)=\begin{cases}T_s, &amp;|\Omega|&lt;\frac{\Omega_s}{2}\\0 , &amp;\text{others}\end{cases}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301112181.png" alt="重建过程" /><figcaption aria-hidden="true">重建过程</figcaption></figure><h3 id="余弦信号的采样">余弦信号的采样</h3><p>这一段没有什么新东西，主要内容是以对余弦信号采样举例来让人直观感受“频域混叠”的存在，尤其是在采样频率<span class="math inline">\(\Omega_s=2\Omega_0\)</span>时，可能会出现各种情况：当<span class="math inline">\(\varphi=0\)</span>时，才能恢复原信号；当其它情况时，都不能恢复原信号，极端时刻，甚至采样值全部为0，不包含任何信息。</p><h2 id="离散傅里叶变换dft">离散傅里叶变换DFT</h2><p>我们之前已学过很多“变换”了，例如连续时间信号傅里叶变换FT、连续时间信号傅里叶级数FS、离散时间序列傅里叶变换DTFT、离散时间序列傅里叶级数FS。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301609617.png" alt="各个变换" /><figcaption aria-hidden="true">各个变换</figcaption></figure><p>因为数字系统只能处理离散序列，而这其中只有DFS同时在时域和频域是离散的。但是DFS又是周期无限长序列，而现有的数字系统仍然不能实现。因此我们必须考虑用有限长序列建立时域离散和频域离散的关系。</p><p>设<span class="math inline">\(\widetilde{x}[n]\)</span>是周期为<span class="math inline">\(N\)</span>的周期序列，那么称 <span class="math display">\[x[n]=\widetilde x[n]R_N[n]\]</span> 为“主值序列”，也就是原序列的第<span class="math inline">\(0\sim N-1\)</span>个值。</p><p>设<span class="math inline">\(x[n]\)</span>是长度为<span class="math inline">\(N\)</span>的有限长序列，那么为了将其周期性延拓，有： <span class="math display">\[\widetilde  {x}[n]=\sum_{r=-\infty}^{\infty} x[n+r N]\]</span></p><p>记作： <span class="math display">\[\widetilde{x}[n]=x[((n))_N]\]</span> 其中<span class="math inline">\(((n))_N\)</span>称作取模运算，设<span class="math inline">\(n=mN+n_1\)</span>，则<span class="math inline">\(((n))_N=n_1\)</span>。</p><p>周期序列<span class="math inline">\(\widetilde x[n],\widetilde X[k]\)</span>可以看作有限长序列<span class="math inline">\(x[n],X[k]\)</span>的周期延拓，因此只需计算主值区间中的DFS，即可对周期序列进行恢复。有DFT的定义： <span class="math display">\[\begin{gathered}x[n]=\frac{1}{N} \sum_{k=0}^{N-1} X[k] \mathrm{e}^{\frac{2\pi k n}{N}} \\X[k]=\sum_{n=0}^{N-1} x[n] \mathrm{e}^{j \frac{-2 \pi k n}{N}}\end{gathered}\]</span> 我们可以看出：DFT并不是一个新的变换形式，而是DFS在实频域的主值序列，因此其很多性质和DFS有类似性。</p><h3 id="几大变换之间的关系">几大变换之间的关系</h3><p>以下：将Z变换记作<span class="math inline">\(X(z)\)</span>，将DTFT（离散时间序列傅里叶变换）记作<span class="math inline">\(X(e^{j\omega})\)</span>，将DFS（离散时间序列傅里叶级数）记作<span class="math inline">\(\widetilde X[k]\)</span>，将DFT（离散傅里叶变换）记作<span class="math inline">\(X[k]\)</span>。</p><h4 id="z变换和dtft">Z变换和DTFT</h4><p><span class="math inline">\(x[n]\)</span>的DTFT是其Z变换在单位圆上的采样。即： <span class="math display">\[X\left(\mathrm{e}^{j w}\right)=\left.X(z)\right|_{z=e^{j\omega}}\]</span></p><h4 id="dtft和dfs">DTFT和DFS</h4><p>对<span class="math inline">\(X(e^{j\omega})\)</span>在<span class="math inline">\(\omega \in [0,2\pi)\)</span>的等间隔频率点进行<span class="math inline">\(N\)</span>点采样得到周期序列<span class="math inline">\(\widetilde X[k]\)</span>。对<span class="math inline">\(\widetilde X[k]\)</span>作IDFS（离散时间序列傅里叶级数逆变换），得到序列<span class="math inline">\(\widetilde x_N[n]\)</span>。</p><p>由： <span class="math display">\[\tilde{X}[k]=\left.X\left(\mathrm{e}^{j \omega}\right)\right|_{\omega=\frac{2 \pi i}{N}}=\sum_{n=-\infty}^{\infty} x[n] \mathrm{e}^{-j \frac{2 \pi}{N} k n}\]</span> 和 <span class="math display">\[\tilde{x}_N[n]=\operatorname{IDFS}[\tilde{X}[k]]=\frac{1}{N} \sum_{k=0}^{N-1} \widetilde {X}[k] \mathrm{e}^{j\frac{2 \pi}{N} k n}\]</span> 把上式带入下式，有： <span class="math display">\[\widetilde x_N[n]=\sum_{m=-\infty}^{\infty} x[m]\left[\frac{1}{N} \sum_{k=0}^{N-1} \mathrm{e}^{-j \frac{2 \pi}{N} k(m-n)}\right]\]</span> 有复指数函数的正交性和周期性，有： <span class="math display">\[\begin{aligned}\tilde{x}_N[n]&amp;=\sum_{m=-\infty}^{\infty} x[m]\left[\sum_{r=-\infty}^{\infty} \delta[m-n-r N]\right]\\&amp;=\cdots+x[n+N]+x[n]+x[n-N]+\cdots\end{aligned}\]</span> 可以看到，<span class="math inline">\(\widetilde x_N[n]\)</span>是<span class="math inline">\(x[n]\)</span>的周期移位。也就是说，正如时域采样会导致频域周期延拓，频域采样也会导致时域周期延拓。下面按<span class="math inline">\(x[n]\)</span>的长度<span class="math inline">\(L\)</span>和频域采样数<span class="math inline">\(N\)</span>分情况讨论：</p><ol type="1"><li>非周期序列<span class="math inline">\(x[n]\)</span>不是有限长序列，则频域采样一定会造成混叠</li><li><span class="math inline">\(N&lt;L\)</span>时，仍会产生时域混叠失真。混叠的长度就是<span class="math inline">\(L-N\)</span>，参考上面的式子</li><li><span class="math inline">\(N\geq L\)</span>时，才能由频域采样<span class="math inline">\(\tilde X[k]\)</span>恢复出<span class="math inline">\(x[n]\)</span></li></ol><h4 id="dfs和dft">DFS和DFT</h4><p>如前文所说，DFT和DFS本质上来说是一种变换，不过DFS的离散时间序列是周期的，变换得到的频域也是周期的，DFT是DFS的主值序列。</p><h4 id="dft的性质和定理">DFT的性质和定理</h4><p>在研究DFT的性质时，需要时刻注意DFT的有限定长度性以及循环周期性。当涉及到两个长度不同的序列时，要通过补0的方式使其长度均为<span class="math inline">\(N\geq max(N_1,N_2)\)</span>。</p><ol type="1"><li><p>线性</p></li><li><p>时域循环位移性质</p><p>这里的循环移位是圆周移位，在序列中，从左（右）边移出多少位，就会从右（左）边移入相同位的序列值。 <span class="math display">\[x\left[\left(\left(n+n_d\right)\right)_N\right] R_N[n] \underset{N-\mathrm{DFFT}}{\stackrel{N-\mathrm{DFT}}{\longrightarrow}} \mathrm{e}^{j\left(2 \pi kn_d / N\right)} X[k]\]</span></p></li></ol><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>需要注意的是，我们平常做题见到的很多系统都不是线性时不变系统。例如：如果进行了压扩变换，那么系统往往是时变的。我们平常所进行的“调幅”(即频率搬移)乘以一个<span class="math inline">()</span>​，由于产生了新的频率分量，也不是线性时不变的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>为什么说“分解”呢？因为<span class="math inline">(x[n]=x_e[n]+x_o[n])</span>显然成立。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>也就是说最小相位系统的意思就是零极点都在单位圆内。 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221017-20221023）</title>
    <link href="/2022/10/23/%E5%91%A8%E8%AE%B0%EF%BC%8820221017-20221023%EF%BC%89/"/>
    <url>/2022/10/23/%E5%91%A8%E8%AE%B0%EF%BC%8820221017-20221023%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第八周，也就是这学期即将过去一半了。本周我有些感冒（应该是从周二夜间开始的），不如说还挺严重的，对我的生活各方面造成了相当大的影响。一方面是身体确实不太舒服，另一方面是容易借感冒了这个理由而多多摆烂，不过我觉得还好，摆就摆一会儿吧， 休息一下也好。不过等康复了以后要恢复起来。</p><p>在学习方面，本周没有做什么太多有意义的事情，无非是上课、写作业等。本来，我预计在周三更新一篇DSP总结，但是由于身体原因一直没有开始，争取这周写一写。另外就是本周进行了电赛测评，不知道结果如何。</p><p>在游戏方面，我开始打《Ever 17》了。游戏里的时间2017年，我们早已经超过了（笑），但是现在还没有实现那里面的技术。曾经有一部电影叫做《2001太空漫游》，里面充满了对2001年的太空世界浪漫主义的瑰丽想象。可是事实上我们人类却总是执着于在这个小小地球里面内卷，无暇顾及无垠的太空了。1991年美国取得冷战的胜利以来，已经失去了其初心使命，它的政权（或者说，体制，下文不作区分，当然实际上区别很大的）的目的已经是维持统治本身了。世界由这样的政权统治，还能有什么好结果呢？本周，党的二十大胜利召开了，里面有一条提法我很喜欢，那就是：建立人类文明新形态。我相信，经历了“不可能之革命”胜利的中国、中国共产党和中国体制是“领先于版本”的，一定能成为人类文明的出路。</p><p>西方国家总是对中国有着错误的理解，这导致它们从1949年以来对中国的预测“屡战屡败”，这很搞笑，它们难道没有发现自己的错误吗？譬如说吧，西方人总以为，在议会大打出手就是所谓的“民主”，而领导层们铁板一块则必然是“专制”，这太可笑了。</p><p>书，继续读论中国。这周读的少。我有点想看《孤独摇滚》。</p><p>下周就是校庆了，有点期待，但是还是有点懒。我和友人约定一起去校庆玩了。和去年相比，我更享受和友人在一起的时光了，而不是把它当成“任务”了。我也更乐于和友人分享生活中琐碎的事物了，这是一大进步。</p><p>我申请了一个优秀志愿者，接下来还要申请三好和优干。算了，都申吧，反正写申请书不要钱，哈哈。</p><p>对了，还有一件事，我确认了电子信息工程专业。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210240011528.jpg" alt="秋意渐浓如瀑" /><figcaption aria-hidden="true">秋意渐浓如瀑</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210240014356.jpg" alt="一星级志愿者" /><figcaption aria-hidden="true">一星级志愿者</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210240014395.png" alt="足迹" /><figcaption aria-hidden="true">足迹</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(21-30)</title>
    <link href="/2022/10/19/Verilog21-30/"/>
    <url>/2022/10/19/Verilog21-30/</url>
    
    <content type="html"><![CDATA[<h2 id="基于端口位置的实例化">基于端口位置的实例化</h2><h3 id="题目描述">题目描述</h3><p>创建一verilog电路，实现对模块mod_a基于端口位置的实例化，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191637163.png" /></p><p>其中mod_a模块的代码提供为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a(<br>    <span class="hljs-keyword">output</span> out1, out2,<br>    <span class="hljs-keyword">input</span> in1,in2,in3,in4);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;<br>    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;   <br>    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><strong>Hint:</strong></p><ul><li>实例化名称可以与模块名称相同</li><li>实例化模块时，需要注意端口信号的位宽相匹配，本例中都是1bit，所以不存在问题</li></ul><h3 id="输入格式">输入格式</h3><p>4个1bit信号a, b, c, d</p><h3 id="输出格式">输出格式</h3><p>经由模块mod_a输出的信号out1, out2</p><h3 id="代码和解析">代码和解析</h3><p>如题目所说，像调用函数一样依次传“参数”即可，注意位置要一一对应。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a(<br><span class="hljs-keyword">output</span> out1, out2,<br><span class="hljs-keyword">input</span> in1,in2,in3,in4);<br><span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4; <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;<span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out1,<br>    <span class="hljs-keyword">output</span> out2<br>);<br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    mod_a mod_a_inst(out1,out2,a,b,c,d);<br><br><span class="hljs-comment">// 用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="基于端口名称的实例化">基于端口名称的实例化</h2><h3 id="题目描述-1">题目描述</h3><p>创建一 verilog 电路，实现对模块 mod_a 基于端口名称的实例化，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191640660.png" /></p><p>其中mod_a模块的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a (<br>    <span class="hljs-keyword">output</span>   out1,<br>    <span class="hljs-keyword">output</span>   out2,<br>    <span class="hljs-keyword">input</span>    in1,<br>    <span class="hljs-keyword">input</span>    in2,<br>    <span class="hljs-keyword">input</span>    in3,<br>    <span class="hljs-keyword">input</span>    in4<br>);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="输入格式-1">输入格式</h3><p>输入信号 a, b, c, d，位宽 1bit。</p><h3 id="输出格式-1">输出格式</h3><p>输出信号 out1, out2，位宽 1bit。</p><h3 id="代码和解析-1">代码和解析</h3><p>除了像C语言一样按顺序传参数以外，Verilog还可以进行基于端口名称的实例化，如这道题所示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a (<br>    <span class="hljs-keyword">output</span>   out1   ,<br>    <span class="hljs-keyword">output</span>   out2   ,<br>    <span class="hljs-keyword">input</span>    in1    ,<br>    <span class="hljs-keyword">input</span>    in2    ,<br>    <span class="hljs-keyword">input</span>    in3    ,<br>    <span class="hljs-keyword">input</span>    in4<br>);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span>   a   ,<br>    <span class="hljs-keyword">input</span>   b   ,<br>    <span class="hljs-keyword">input</span>   c   ,<br>    <span class="hljs-keyword">input</span>   d   ,<br>    <span class="hljs-keyword">output</span>  out1,<br>    <span class="hljs-keyword">output</span>  out2<br>);<br><br>mod_a ul(<br>    <span class="hljs-variable">.out1</span>       (out1),<br>    <span class="hljs-variable">.out2</span>       (out2),<br>    <span class="hljs-variable">.in1</span>        (a),<br>    <span class="hljs-variable">.in2</span>        (b),<br>    <span class="hljs-variable">.in3</span>        (c),<br>    <span class="hljs-variable">.in4</span>        (d));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多个模块的例化">多个模块的例化</h2><h3 id="题目描述-2">题目描述</h3><p>对于给定模块my_dff，包含两个输入信号和一个输出信号（D触发器模块），其代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> d,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> q);<br>   <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>      q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请创建一verilog模块，在该模块中将my_dff模块例化3次，并串行连接，使其构成一个长度为3的移位寄存器，其中3个模块公用一个clk信号，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191642288.png" /></p><p>为实现电路功能，用户需要在顶层模块定义一些内部信号，从而能够将3个例化的模块进行连接。</p><h3 id="输入格式-2">输入格式</h3><p>2个 1bit 位宽信号 clk、d</p><h3 id="输出格式-2">输出格式</h3><p>1个 1bit 位宽信号 q</p><h3 id="代码和解析-2">代码和解析</h3><p>只需要对于图里面的两个粗箭头定义两个<code>wire</code>型中间信号即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> d,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> q);<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>        q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module ( <span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> d, <span class="hljs-keyword">output</span> q );<br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    my_dff u1(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.q</span>(w1));<br>    my_dff u2(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w1),<span class="hljs-variable">.q</span>(w2));<br>    my_dff u3(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w2),<span class="hljs-variable">.q</span>(q));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="模块与向量信号">模块与向量信号</h2><h3 id="题目描述-3">题目描述</h3><p>对于给定模块 my_dff8，其代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff8(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>        q &lt;= d;      <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>试创建一 Verilog 模块，对 my_dff8 模块例化 3 次，并串行连接，构成一个 8bit 位宽长度为 3 的移位寄存器，同时可以通过选择信号选择输出结果，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191647063.png" /></p><h3 id="输入格式-3">输入格式</h3><p>8bit 的任意有效输入</p><h3 id="输出格式-3">输出格式</h3><p>根据 sel 信号，选择一个模块或者原输入作为输出信号</p><h3 id="代码和解析-3">代码和解析</h3><p>比特矢量是可以作为一个信号直接参与模块例化的，这也是我之前说要把比特矢量看成一个“数”的原因之一。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff8(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>    q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w1,w2,w3;<br>    my_dff8 u1(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.q</span>(w1));<br>    my_dff8 u2(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w1),<span class="hljs-variable">.q</span>(w2));<br>    my_dff8 u3(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w2),<span class="hljs-variable">.q</span>(w3));<br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span> (sel)<br>            <span class="hljs-number">0</span>:q=d;<br>            <span class="hljs-number">1</span>:q=w1;<br>            <span class="hljs-number">2</span>:q=w2;<br>            <span class="hljs-number">3</span>:q=w3;<br>            <span class="hljs-keyword">default</span> : q=<span class="hljs-number">8&#x27;b00000000</span>;<br>        <span class="hljs-keyword">endcase</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-comment">// Write your code here</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这里用到了<code>always</code>块，是以前没有用到过的，但是我后面几个题的时候再来讲解。</p><h2 id="加法器">加法器</h2><p>对于给定的16bit加法器电路，其代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br> <span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>试创建一verilog模块，在该模块中实例化两个16bit的加法器，并进行适当的连接，最终构成一个32bit的加法器，该加法器输入进位位为0，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191652602.png" /></p><h3 id="输入格式-4">输入格式</h3><p>32'b0 32'b0</p><h3 id="输出格式-4">输出格式</h3><p>32'b0</p><h3 id="代码和解析-4">代码和解析</h3><p>这个题只需要读懂逻辑，然后照着图实现就可以了。这是一个典型的链接两个加法器的题，对于一个加法器（全加器），一般有三个输入：<code>a,b</code>是两个加数，<code>cin</code>是用来记录上一步有没有进位的值。输出一般有两个：<code>sum</code>是结果，<code>cout</code>是用来记录这个加法器有没有产生进位的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    add16 u1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<span class="hljs-variable">.sum</span>(sum1),<span class="hljs-variable">.cout</span>(w1));<br>    add16 u2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.cin</span>(w1),<span class="hljs-variable">.sum</span>(sum2),<span class="hljs-variable">.cout</span>(w2));<br>    <span class="hljs-keyword">assign</span> sum=&#123;sum2,sum1&#125;;<br>  <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多层次例化加法器">多层次例化加法器</h2><h3 id="题目描述-4">题目描述</h3><p>在此练习中，用户需要创建一个包含两层调用的电路，在顶层模块中，实例化两个16bit位宽的加法器add16,而add16模块又是通过例化16个1bit全加器实现的，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191656711.png" /></p><p>在本设计中，一共涉及到3个模块，分别是：顶层模块、add16模块、add1模块，其中add16模块源代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout);<br><span class="hljs-keyword">wire</span> c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15;<br><br>add1 inst_0(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">0</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(cin),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cout</span>(c1));<br>add1 inst_1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">1</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cin</span>(c1),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cout</span>(c2));<br>add1 inst_2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">2</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cin</span>(c2),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cout</span>(c3));<br>add1 inst_3(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">3</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cin</span>(c3),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cout</span>(c4));<br>add1 inst_4(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">4</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cin</span>(c4),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cout</span>(c5));<br>add1 inst_5(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">5</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cin</span>(c5),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cout</span>(c6));<br>add1 inst_6(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">6</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cin</span>(c6),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cout</span>(c7));<br>add1 inst_7(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">7</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cin</span>(c7),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cout</span>(c8));<br>add1 inst_8(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">8</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cin</span>(c8),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cout</span>(c9));<br>add1 inst_9(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">9</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cin</span>(c9),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cout</span>(c10));<br>add1 inst_10(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">10</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">10</span>]),<span class="hljs-variable">.cin</span>(c10),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">10</span>]),<span class="hljs-variable">.cout</span>(c11));<br>add1 inst_11(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">11</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">11</span>]),<span class="hljs-variable">.cin</span>(c11),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">11</span>]),<span class="hljs-variable">.cout</span>(c12));<br>add1 inst_12(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">12</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">12</span>]),<span class="hljs-variable">.cin</span>(c12),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">12</span>]),<span class="hljs-variable">.cout</span>(c13));<br>add1 inst_13(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">13</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">13</span>]),<span class="hljs-variable">.cin</span>(c13),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">13</span>]),<span class="hljs-variable">.cout</span>(c14));<br>add1 inst_14(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">14</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">14</span>]),<span class="hljs-variable">.cin</span>(c14),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">14</span>]),<span class="hljs-variable">.cout</span>(c15));<br>add1 inst_15(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>]),<span class="hljs-variable">.cin</span>(c15),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>]),<span class="hljs-variable">.cout</span>(cout));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>现在，你需要完成顶层模块和add1模块的verilog代码。</p><h3 id="输入格式-5">输入格式</h3><p>两个32位宽的加数a,b</p><h3 id="输出格式-5">输出格式</h3><p>32位宽的和sum</p><h3 id="代码和解析-5">代码和解析</h3><p>首先，第一部分是实现一位全加器<code>add1</code>，有两种实现方式。第一种是写出真值表，画出卡诺图并化简成逻辑表达式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">wire</span> w1,a1,a2,a3;<br>    <span class="hljs-keyword">assign</span> w1 = a ^ b;<br>    <span class="hljs-keyword">assign</span> sum = w1 ^ cin;<br>    <span class="hljs-keyword">assign</span> a1 = a &amp; b;<br>    <span class="hljs-keyword">assign</span> a2 = a &amp; cin;<br>    <span class="hljs-keyword">assign</span> a3 = b &amp; cin;<br>    <span class="hljs-keyword">assign</span> cout = a1 | a2 | a3;<br><span class="hljs-comment">// Full adder module here</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>第二种是基于行为建模，直接写出结果即可：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">assign</span> &#123;cout,sum&#125;=a+b+cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>然后，第二部分就是<code>top_module</code>，这个没有什么新意，照着图写就行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum);<br>    <br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br><br>    add16 u1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sum1),<br>        <span class="hljs-variable">.cout</span>(w1)<br>    );<br><br>    add16 u2(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(w1),<br>        <span class="hljs-variable">.sum</span>(sum2),<br>        <span class="hljs-variable">.cout</span>(w2)<br>    );<br><br>    <span class="hljs-keyword">assign</span> sum = &#123;sum2,sum1&#125;;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="进位选择加法器">进位选择加法器</h2><h3 id="题目描述-5">题目描述</h3><p>前例中的加法器成为串行进位加法器，只有等前一级的加法器运算结束产生进位位之后，下一级加法器才能利用进位位进行计算，因此电路延时会随加法器串联级数的增加而线性增加，这使得电路计算速度大大降低。设每一级全加器的延时为t，则32bit加法器的延时则为：32t。 为降低电路整体延时，我们可以按下图进行设计：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191702113.png" /></p><p>我们将电路分为两段，每段实现16bit的加法，为了使高16位与低16位同时进行运算，我们采用两个add16对高位进行计算，区别在于进位位分别为0和1，最终通过低16位加法器的输出进位作为选择控制信号，选择高16位的运算结果。这样，32bit加法器的延时就变为：16t+tmux2 ≈16t,延时降低了接近一倍，这种以空间（增加电路）换时间（提高速度）的做法，在数字电路设计中经常使用。 请创建Verilog模块，实现上图中的电路结构，其中add16不需要用户编写，其声明如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br>   <span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="输入格式-6">输入格式</h3><p>32bit a, 32bit b</p><h3 id="输出格式-6">输出格式</h3><p>32bit sum 为 a 与 b 的和</p><h3 id="代码和解析-6">代码和解析</h3><p>这题和前面几题差不多，没有什么难度，但是这个题介绍的方法很有趣。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <br><span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <br>    <span class="hljs-keyword">input</span> cin, <br>    <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <br>    <span class="hljs-keyword">output</span> cout <br>);<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sumH0,sumH1,sumL;<br>    <span class="hljs-keyword">wire</span> coutL;<br>    add16 H0(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sumH0)<br>    );<br>    add16 H1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-variable">.sum</span>(sumH1)<br>    );<br>    add16 L(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sumL),<br>        <span class="hljs-variable">.cout</span>(coutL)<br>    );<br>    <span class="hljs-keyword">assign</span> sum=(coutL?&#123;sumH1,sumL&#125;:&#123;sumH0,sumL&#125;);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="加法减法器">加法减法器</h2><h3 id="题目描述-6">题目描述</h3><p>通过对加法器进行改造，可以支持加、减两种运算。我们知道，电路中有符号数通常使用补码表示，如<span class="math inline">\(-b\)</span>其补码为：<span class="math inline">\(\sim b + 1\)</span>（按位取反然后加1）。因此，对于减法算式<span class="math inline">\(a-b\)</span>,可以理解为<span class="math inline">\(a+(-b) = a+(\sim b+1)= a + (\sim b) +1\)</span>,因此对于减法运算，可以将加法器进行如下改造实现</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191705188.png" /></p><p>实现减法运算时，首先通过32bit的异或门，将信号b按位取反，同时将输入进位位置1，实现加法运算时，b保持不变，输入进位位置0。 其中add16模块代码如下，用户可直接调用：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请创建Verilog模块，实现上述电路功能。</p><h3 id="输入格式-7">输入格式</h3><p>32位的a,b，以及一个1位信号sub，sub为1时为减法，sub为0时为加法</p><h3 id="输出格式-7">输出格式</h3><p>32位信号sum 注：我想你读到这里的时候，一定跟我一样想着直接用sum=(sub==0?a+b:a-b)逃课了，但是请老老实实地按题目要求分高位低位取补码相加哦~~~</p><h3 id="代码与解析">代码与解析</h3><p>我们先对<span class="math inline">\(b\)</span>进行一个处理。如果题目要求加，即<code>sub==0</code>，那么不需要做任何处理，直接加即可。但是如果题目要求减，即<code>sub==1</code>，那么需要求取<code>b</code>的反码，即<code>~b</code>。我们很容易想到，异或可以完成这个工作：遇到0不变，遇到1取反。所以我们可以直接把<code>b</code>和<code>sub</code>异或。</p><p>由于减法是<span class="math inline">\(a+(-b) = a+(\sim b+1)= a + (\sim b) +1\)</span>，为了实现这个加一，我们直接把<code>sub</code>信号接到第一个全加器的<code>cin</code>上即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">input</span> sub,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bXorSub;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br>    <span class="hljs-keyword">wire</span> w1;<br>    <span class="hljs-keyword">assign</span> bXorSub = b ^ &#123;<span class="hljs-number">32</span>&#123;sub&#125;&#125;;<br>    add16 u1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(bXorSub[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(sub),<br>        <span class="hljs-variable">.sum</span>(sum1),<br>        <span class="hljs-variable">.cout</span>(w1)<br>    );<br>    add16 u2(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(bXorSub[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(w1),<br>        <span class="hljs-variable">.sum</span>(sum2)<br>    );<br>    <span class="hljs-keyword">assign</span> sum=&#123;sum2,sum1&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="always过程块_组合逻辑">always过程块_组合逻辑</h2><h3 id="题目描述-7">题目描述</h3><p>所有的数字电路都是由逻辑门和连线构成的，因此理论上来说都可以通过模块的连接和<code>assign</code>语句进行描述，然而在很多情况下这并不是最方便的一种方式，过程块提供了一种更加方便的描述方式，<code>always</code>过程块便是其中最常用的一种。 对于可综合电路（即能转化成实际电路的verilog描述方式，与之相对的是不可综合电路，多用于电路仿真，不能转换成实际电路），有两种<code>always</code>块的语法形式：</p><ul><li>组合逻辑电路：<code>always@(*)</code></li><li>时序逻辑电路：<code>always@(posedge clk)</code></li></ul><p>组合逻辑电路的<code>always</code>块与<code>assign</code>语句等效，用户描述组合逻辑电路时，可根据便利性选择其中一种方式使用。两者生成的硬件电路一般是等效的，但在语法规则上稍有不同：</p><ul><li><code>assign</code>语句只能对一个信号进行赋值，<code>always</code>块内可对多个信号进行赋值</li><li><code>assign</code>语句中被赋值信号为<code>wire</code>类型，<code>always</code>块内被赋值信号需定义为<code>reg</code>类型</li><li><code>always</code>块内支持更加丰富的语法，如使用<code>if…else..</code>、<code>case</code>等适合实现交复杂的组合逻辑 例如下述两条语句是等效的（out1需定义为<code>wire</code>类型，out2需定义为<code>reg</code>类型，但这仅仅是语法上的要求，生成的电路并没有区别）： <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out1 = a &amp; b | c ^ d;<br><span class="hljs-keyword">always</span> @(*) out2 = a &amp; b | c ^ d;<br></code></pre></td></tr></table></figure> 其对应的电路图如下所示：</li></ul><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192023388.png" /></p><p><code>always</code>语句后的括号内放的是敏感变量列表，对于上例来说，可以写成<code>always @(a,b,c,d) out2 = a &amp; b | c ^ d</code>，但为了简单起见，我们一般都用符号<code>*</code>代替。 试创建一verilog模块，实现一与门，分别用<code>assign</code>语句和<code>always</code>块实现。</p><h3 id="输入格式-8">输入格式</h3><p>1位的a，1位的b</p><h3 id="输出格式-8">输出格式</h3><p>1位的out_assign，1位的out_alwaysblock</p><h3 id="代码和解析-7">代码和解析</h3><p>这道题向我们介绍了一个叫做“过程块”的事物，它就是<code>always</code>。在过程块中被赋值的变量必须是<code>reg</code>类型，尽管综合时可能和平常所使用的<code>assign</code>得到的电路没有区别。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_alwaysblock<br>);<br>    <span class="hljs-keyword">assign</span> out_assign = a &amp; b;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        out_alwaysblock = a &amp; b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="always过程块_时序逻辑">always过程块_时序逻辑</h2><h3 id="题目描述-8">题目描述</h3><p>通过前例已经了解到，对于可综合电路，有两种always块的语法形式：</p><ul><li>组合逻辑电路：<code>always@(*)</code></li><li>时序逻辑电路：<code>always@(posedge clk)</code></li></ul><p>用always描述的时序逻辑电路，除了像组合逻辑always块那样生成组合逻辑电路外，还会生成一组触发器（或称寄存器），用于寄存组合逻辑的输出。寄存器的输出只有在时钟的上升沿时（<code>posedge clk</code>）才会更新，其余时刻均保持不变。 阻塞赋值和非阻塞赋值： 在Verilog中，有三种赋值方式，分别为：</p><ul><li>连续赋值（如<code>assign x = y;</code>），该赋值方式只能用于过程块(如always块)之外</li><li>阻塞赋值（如<code>x = y;</code>），该赋值方式只能用在过程块（如<code>always@（*）</code>）内</li><li>非阻塞赋值（如<code>x &lt;= y;</code>），该赋值方式只能用在过程块内（如<code>always@（posedge clk）</code>）</li></ul><p>在设计Verilog模块时，请遵循以下原则：</p><ul><li>在组合逻辑的always块内采用阻塞赋值</li><li>时序逻辑的always块内采用非阻塞赋值</li></ul><p>违背这一原则将可能导致难以发现的电路错误，且可能导致仿真与综合的不一致，请用户切记。至于为何这样，初学者可以不必理会，简单理解为verilog语法规范性要求即可。 创建一verilog电路，分别采用上述三种赋值方式实现异或门电路，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192119474.png" /></p><p><strong>Hint</strong></p><ul><li>always块内被赋值的信号都应定义成reg类型</li><li>always块内，组合逻辑采用阻塞赋值（<code>a = b</code>），时序逻辑采用非阻塞赋值（<code>a &lt;= b</code>）</li><li>always语句括号内是敏感变量列表，时序逻辑是边沿敏感的，<code>posedge clk</code>表示的是clk信号的上升沿，此外，还可以是<code>negedge clk</code>，表示clk信号的下降沿。</li></ul><h3 id="输入格式-9">输入格式</h3><p>一位线网型变量clk，a, b。clk为时钟，a，b为输入</p><h3 id="输出格式-9">输出格式</h3><p>一位线网型变量out_assign，out_always_comb，out_always_ff。out_assign为a，b连续赋值得到的结果。out_always_comb为a，b阻塞赋值得到的结果。out_always_ff为a，b非阻塞赋值得到的结果</p><h3 id="代码和解析-8">代码和解析</h3><p>连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果；过程赋值只有在语句执行的时候，才会起作用。这是连续性赋值与过程性赋值的区别。</p><p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> sel, a, b ;<br><span class="hljs-keyword">reg</span> y , c ;<br><span class="hljs-keyword">always</span> @( sel <span class="hljs-keyword">or</span> a <span class="hljs-keyword">or</span> b ) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> ( sel == <span class="hljs-number">1&#x27;b1</span> ) <span class="hljs-keyword">begin</span><br>        c = a ;<br>        y = c ；<span class="hljs-comment">//实际就是y=a，这为了展示依次描述过程</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> y = b ;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这就是阻塞赋值，先执行<code>c=a</code>，再执行<code>y=c</code>，这段代码等价于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> sel, a, b, y ;<br><span class="hljs-keyword">assign</span> y = ( sel == <span class="hljs-number">1</span>’b1 ) ? a : b ;<br></code></pre></td></tr></table></figure><p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Cyclic_shifter ( clk, rst_n, Q );<br>    <span class="hljs-keyword">input</span> clk, rst_n ;<br>    <span class="hljs-keyword">output</span> [ <span class="hljs-number">2</span> : <span class="hljs-number">0</span> ] Q ;<br>    <span class="hljs-keyword">reg</span> [ <span class="hljs-number">2</span> : <span class="hljs-number">0</span> ] Q ;<br>    <span class="hljs-keyword">always</span> @ ( <span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n ) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> ( ~rst_n ) Q &lt;= <span class="hljs-number">3&#x27;b001</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            Q[<span class="hljs-number">0</span>] &lt;= Q[<span class="hljs-number">2</span>] ; <span class="hljs-comment">//相当于 Q &lt;= &#123; Q[1:0], Q[2]&#125; ;</span><br>            Q[<span class="hljs-number">1</span>] &lt;= Q[<span class="hljs-number">0</span>] ; <span class="hljs-comment">//这里只是为了展示非阻塞赋值，</span><br>            Q[<span class="hljs-number">2</span>] &lt;= Q[<span class="hljs-number">1</span>] ; <span class="hljs-comment">//实际上，可打乱这3句的次序，无影响</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>非阻塞赋值是先计算出要“赋”的“值”，然后到块结束再统一“赋予”。例如上面的代码，就是利用非阻塞赋值来交换了三个变量的值。</p><p>本题的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always_comb,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always_ff   <br>);<br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    <span class="hljs-keyword">assign</span> out_assign = a ^ b;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        out_always_comb = a ^ b;    <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        out_always_ff &lt;= a ^ b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="ifelse语句">if…else…语句</h2><p>题目描述</p><p>if语句用于过程块内部，其对应的电路是二选一的选择器，</p><p>以下述代码为例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(*)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(condition) out = x;<br>  <span class="hljs-keyword">else</span> out = y;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>上述代码与下面的assign语句完全等效：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out = (condition) ? x : y;<br></code></pre></td></tr></table></figure><p>试创建一Verilog模块，分别采用assing语句和过程块内的if语句实现下述选择器电路：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192154335.png" /></p><p><strong>Hint：</strong> 1. if…else…可以嵌套使用</p><ol start="2" type="1"><li>使用if语句描述组合逻辑时，务必加上else语句，以免产生锁存器（数字电路设计中应尽力避免产生锁存器）</li><li>本题两个输出信号波形其实是完全一致的，原则上是为了训练大家采用assign和过程块内的if语句使用，所以希望大家能够两种方式都各自尝试一下</li></ol><h3 id="输入格式-10">输入格式</h3><p>信号a, b, 选择信号sel_b1, sel_b2</p><h3 id="输出格式-10">输出格式</h3><p>通过assign语句选择的信号out_assign 通过if语句选择的信号out_always</p><h3 id="代码和解析-9">代码和解析</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">input</span> sel_b1,<br>    <span class="hljs-keyword">input</span> sel_b2,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always); <br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    <span class="hljs-keyword">assign</span> out_assign = (sel_b1 &amp; sel_b2) ? b : a;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(sel_b1 &amp; sel_b2)<br>            out_always = b;<br>        <span class="hljs-keyword">else</span> <br>            out_always = a;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221010-20221016）</title>
    <link href="/2022/10/19/%E5%91%A8%E8%AE%B0%EF%BC%8820221010-20221016%EF%BC%89/"/>
    <url>/2022/10/19/%E5%91%A8%E8%AE%B0%EF%BC%8820221010-20221016%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第七周，总体来说算是比较满意的一周。本周主要是打了一个北京电赛，我们选的是滤波器题。怎么说呢？就是完全是临时乱抓，之前的培训完全没派上用场。培训了一堆什么画PCB，STM32，结果最后选了个模拟的题目，哈哈。好在最后算是把东西都完成了，也增进了和两位同学的友谊，就等下周末评测了，还行吧。</p><p>本周发生了一件乐事，就是微波把自己的实验排到了自己的理论课的时间，由此说明助教肯定不知道我们什么时候上理论课，多少有点离谱了。</p><p>书、二次元和游戏这周搞的比较少，毕竟要打电赛。</p><p>宿舍的浴室修好了，还挺好的，不错。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191630676.jpg" alt="电赛成品" /><figcaption aria-hidden="true">电赛成品</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191631922.jpg" alt="学校博物馆上新" /><figcaption aria-hidden="true">学校博物馆上新</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(10-20)</title>
    <link href="/2022/10/10/verilog10-20/"/>
    <url>/2022/10/10/verilog10-20/</url>
    
    <content type="html"><![CDATA[<p>这一部分主要是比特矢量。</p><span id="more"></span><h2 id="向量">向量</h2><h3 id="题目描述">题目描述</h3><p><strong>Hint:</strong> 向量是为了编写、阅读代码方便，将一组相关的信号用一个向量名称统一命名的方式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w;<br></code></pre></td></tr></table></figure><p>声明了一个8bit位宽的向量信号w，实际上代表的是8个1bit的wire型信号。 注意向量信号的声明是将位宽信息放在信号名之前，这与C语言不太一样。我们可以将向量信号中的一位或多位单独拿来使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] out_4;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] my_vector;<br><span class="hljs-comment">// 声明一个100bit的向量my_vector</span><br><span class="hljs-keyword">assign</span> out = my_vector[<span class="hljs-number">11</span>] &amp; my_vector[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 选择其中两位信号进行运算</span><br><span class="hljs-keyword">assign</span> out_4 = my_vector[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<br><span class="hljs-comment">// 选择其中4bit信号</span><br></code></pre></td></tr></table></figure><p><strong>任务目标：</strong> 创建一verilog模块，具有一个3bit位宽的输入向量信号，然后将其输出到3bit位宽的输出向量信号，同时再分别输出到3个1bit位宽的输出信号，如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102158555.png" /></p><h3 id="输入格式">输入格式</h3><p>1个3bit位宽的向量信号vec</p><h3 id="输出格式">输出格式</h3><p>1个与输入vec保持一致的3bit位宽向量信号<code>outv</code>； 3个1bit位宽信号<code>o0</code>, <code>o1</code>, <code>o2</code>，分别对应输入信号<code>vec</code>的三位</p><h3 id="代码和解析">代码和解析</h3><p>当位宽大于 1 时，<code>wire</code>或 <code>reg</code> 即可声明为向量的形式。这种“向量”也叫“比特矢量”，为的是强调它的每一位都是一个二进制位。一个比特矢量一般来说是这么定义的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] name;<br></code></pre></td></tr></table></figure><p>对于一个比特矢量来说，我们更应该把它看成一个“变量”或“数”，而尽可能不把它看成“数列”，这样可能会为思考带来些许方便。比如说，一个比特矢量是可以直接赋值的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">var</span>;<br><span class="hljs-keyword">var</span>=<span class="hljs-number">8&#x27;hFF</span>;<br></code></pre></td></tr></table></figure><p>这样的话，变量<code>var</code>就被赋予了8位二进制数<code>8'b1111_1111</code>的值，也就是十进制下的511。在比特矢量中，更靠“左”的位对应的“下标”的数字会更大。初看很奇怪，但是只要把左边的理解成二进制的“高位”，那么位越高数字越大，就很显然了。</p><p>在访问单个元素时，可以使用类似于“数组”的形式来访问。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(vec,outv,o2,o1,o0);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] vec;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]outv;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> o0,o1,o2;<br><br>    <span class="hljs-keyword">assign</span> outv = vec[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> o0=vec[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> o1=vec[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">assign</span> o2=vec[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量_续-1">向量_续 1</h2><h3 id="题目描述-1">题目描述</h3><p>创建一 Verilog 模块，将 16bit 输入信号 <code>in</code>分成两个 8bit 的信号 <code>out_hi</code>、<code>out_lo</code>，然后输出，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102225212.png" /></p><h3 id="输入格式-1">输入格式</h3><p>输入信号 <code>in</code>, 位宽 16bit，类型为 <code>wire</code>。</p><h3 id="输出格式-1">输出格式</h3><p>输出信号<code>out_hi</code>，位宽 8bit，为输入信号的高 8 位。 输出信号<code>out_lo</code>，位宽 8bit，为输入信号的低 8 位。</p><h3 id="代码和解析-1">代码和解析</h3><p>Verilog里面的比特矢量是可以以和Python里面的列表切片有点类似的方法使用的，就像这里面一样，<code>[15:8]</code>就表示取第15位到第8位。这个学名叫“part-select操作”。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]out_hi,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]out_lo<br>);<br><br><span class="hljs-keyword">assign</span> out_lo = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> out_hi = in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量_续2">向量_续2</h2><h3 id="题目描述-2">题目描述</h3><p>一个32bit的向量信号包含有4个字节（bit[31:24]、bit[23:16]等），创建一个电路，用以调整4个字节的顺序，该电路经常用于在不同大小端系统之间进行数据交互： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">AaaaaaaaBbbbbbbbCcccccccDddddddd</span> <span class="hljs-operator">=</span>&gt; DdddddddCcccccccBbbbbbbbAaaaaaaa<br></code></pre></td></tr></table></figure> 提示：part-select操作即可以用于赋值语句的左侧也可用于右侧。</p><h3 id="输入格式-2">输入格式</h3><p>1个 32bit 位宽的向量信号 in</p><h3 id="输出格式-2">输出格式</h3><p>1个 32bit 位宽的向量信号 out</p><h3 id="代码和解析-2">代码和解析</h3><p>正如题目所说的，part-select操作即可以用于赋值语句的左侧也可用于右侧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>);<br><br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>] = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>] = in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>] = in[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = in[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="位操作">位操作</h2><h3 id="题目描述-3">题目描述</h3><p>创建一个电路，包含两个 3bit 的输入信号 a 和 b，分别对 ab 进行按位或、逻辑或操作，以及将 ab 拼接成 6bit 信号后进行按位取反，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102234810.png" /></p><h3 id="输入格式-3">输入格式</h3><p>a = 3'b101 b = 3'b000</p><h3 id="输出格式-3">输出格式</h3><p>按位或：3'b101 逻辑或：1 拼接ab后再按位取反：6'b111010</p><h3 id="代码和解析-3">代码和解析</h3><p>这里主要区分一下按位操作和逻辑操作。在逻辑操作中，一个数如果不等于0（即所有位都是0），那么它代表“真”值，反之，如果所有位都是0，那么它代表“假”值。</p><p>Verilog中，比特矢量是可以拼接的。只需要用个大括号把两部分括起来就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] out_or_bitwise,<br>    <span class="hljs-keyword">output</span> out_or_logical,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] out_not<br>);<br>    <span class="hljs-keyword">assign</span> out_or_bitwise = a|b;<br>    <span class="hljs-keyword">assign</span> out_or_logical = a || b;<br>    <span class="hljs-keyword">assign</span> out_not = &#123;~b,~a&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="位操作2">位操作2</h2><h3 id="题目描述-4">题目描述</h3><p>创建一个组合逻辑电路，包含4bit输入（in[3:0]），和3个输出，分别为：</p><ul><li><code>out_and</code>：四输入与门的输出信号</li><li><code>out_or</code>：四输入或门的输出信号</li><li><code>out_xor</code>：四输出异或门的输出信号</li></ul><p>电路结构如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102241454.png" /></p><h3 id="输入格式-4">输入格式</h3><p>0 0 0 0</p><h3 id="输出格式-4">输出格式</h3><p>0 0 0</p><h3 id="代码和解析-4">代码和解析</h3><p>在Verilog中，可以把一个本来是二目运算符的按位算符放在一个比特矢量的前面，这表示从高位到低位一个一个依次用这个二目运算符计算，最后得到一个一位的结果。这种操作叫“归约操作符”。归约操作符包括：归约与<code>&amp;</code>，归约与非<code>~&amp;</code>，归约或<code>|</code>，归约或非<code>~|</code>，归约异或<code>^</code>，归约同或<code>~^</code>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_and,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_or,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_xor<br>);<br>    <span class="hljs-keyword">assign</span> out_and = &amp;in;<br>    <span class="hljs-keyword">assign</span> out_or = |in;<br>    <span class="hljs-keyword">assign</span> out_xor = ^in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量拼接">向量拼接</h2><h3 id="题目描述-5">题目描述</h3><p>part_selection用于选择向量信号中的一部分，而向量拼接算子{a,b,c}用于将多个信号组合成一个位宽更大的向量信号，如： <code>&#123;3'b111, 3'b000&#125;</code> 等同于 <code>6'b111000</code> <code>&#123;1'b1, 1'b0, 3'b101&#125;</code>等同于<code>5'b10101</code> <code>&#123;4'ha, 4'd10&#125;</code> 等同于 <code>8'b10101010</code> // 4'ha and 4'd10 are both 4'b1010 in binary 向量拼接时，每个信号都需要有明确的位宽，这样拼接后的信号才会有明确的位宽。例如，{1,2,3}就是非法的，因为无法确定各信号的位宽，语法检查时会报错。 向量拼接算子既可以用于赋值语句的左侧，也可用于右侧，如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>] out;<br><span class="hljs-keyword">assign</span> &#123;out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125; = in;<br><span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;<br><span class="hljs-keyword">assign</span> out = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;  <br></code></pre></td></tr></table></figure><p>创建Verilog电路，将6个5bit位宽的输入信号，以及2bit的常量信号2’b11拼接成32bit的向量信号，并将其拆成4个8bit的信号，分别赋值给4个输出信号，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102248499.png" /></p><h3 id="输入格式-5">输入格式</h3><p>6个5位宽的输入信号a,b,c,d,e,f</p><h3 id="输出格式-5">输出格式</h3><p>4个8位宽的信号w,x,y,z</p><h3 id="代码和解析-5">代码和解析</h3><p>正如题目中所说：向量拼接算子既可以用于赋值语句的左侧，也可用于右侧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] a, b, c, d, e, f,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w, x, y, z );<br>    <span class="hljs-keyword">assign</span> &#123;w,x,y,z&#125; = &#123;a,b,c,d,e,f,<span class="hljs-number">2&#x27;b11</span>&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量翻转">向量翻转</h2><h3 id="题目描述-6">题目描述</h3><p>创建verilog电路，将8bit的输入信号按bit翻转，并输出到输出端口，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102255765.png" /></p><h3 id="输入格式-6">输入格式</h3><p>8 bit in</p><h3 id="输出格式-6">输出格式</h3><p>8 bit out, 为in的向量翻转</p><h3 id="代码和解析-6">代码和解析</h3><p>想到翻转，我第一时间想到的是直接写成这样：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out=in[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>然而实践证明并不行，是因为 Verilog 不允许翻转向量的位顺序，所以还是只能一个一个赋值。</p><p>正确的代码是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out=&#123;in[<span class="hljs-number">0</span>],in[<span class="hljs-number">1</span>],in[<span class="hljs-number">2</span>],in[<span class="hljs-number">3</span>],in[<span class="hljs-number">4</span>],in[<span class="hljs-number">5</span>],in[<span class="hljs-number">6</span>],in[<span class="hljs-number">7</span>]&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="复制算子">复制算子</h2><h3 id="题目描述-7">题目描述</h3><p>复制算子是拼接算子的一种特殊情况，如<code>a=&#123;b,b,b,b,b,b&#125;</code>便可以写成<code>a=&#123;6&#123;b&#125;&#125;</code>的形式。复制算子的格式为：<code>&#123;num&#123;vector&#125;&#125;</code>，其中<code>num</code>必须为常量。如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">&#123;<span class="hljs-number">5</span>&#123;<span class="hljs-number">1&#x27;b1</span>&#125;&#125; <span class="hljs-comment">// 5&#x27;b11111 (or 5&#x27;d31 or 5&#x27;h1f)</span><br>&#123;<span class="hljs-number">2</span>&#123;a,b,c&#125;&#125; <span class="hljs-comment">// The same as &#123;a,b,c,a,b,c&#125;</span><br>&#123;<span class="hljs-number">3&#x27;d5</span>, &#123;<span class="hljs-number">2</span>&#123;<span class="hljs-number">3&#x27;d6</span>&#125;&#125;&#125; <span class="hljs-comment">// 9&#x27;b101_110_110</span><br></code></pre></td></tr></table></figure><p>创建一verilog电路，将一个8bit位宽的输入信号进行符号位扩展，并通过32bit的输出端口输出，如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102258111.png" /></p><h3 id="输入格式-7">输入格式</h3><p>8位in信号</p><h3 id="输出格式-7">输出格式</h3><p>32位out信号</p><h3 id="代码和解析-7">代码和解析</h3><p>关于复制算子，题目里已经说得很清楚了，照着写就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out <br>);<br>    <span class="hljs-keyword">assign</span> out = &#123;&#123;<span class="hljs-number">24</span>&#123;in[<span class="hljs-number">7</span>]&#125;&#125;,in&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="复制算子_2">复制算子_2</h2><h3 id="题目描述-8">题目描述</h3><p>创建一verilog电路，包含5个1bit输入，使所有输入两两进行同或（两bit相同时输出1，不同时输出0），并将结果通过25bit的向量信号输出，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102259350.png" /></p><h3 id="输入格式-8">输入格式</h3><p>1位的a,b,c,d,e</p><h3 id="输出格式-8">输出格式</h3><p>25位的out</p><h3 id="代码和解析-8">代码和解析</h3><p>使用复制算子实现该电路，可以大大减少代码量，提高编码效率。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a, b, c, d, e,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] out <br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] mid_1;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] mid_2;<br>    <span class="hljs-keyword">assign</span> mid_1=&#123;&#123;<span class="hljs-number">5</span>&#123;a&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;b&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;c&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;d&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;e&#125;&#125;&#125;;<br>    <span class="hljs-keyword">assign</span> mid_2=&#123;&#123;<span class="hljs-number">5</span>&#123;a,b,c,d,e&#125;&#125;&#125;;<br>    <span class="hljs-keyword">assign</span> out=~(mid_1 ^ mid_2);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="模块例化">模块例化</h2><h3 id="题目描述-9">题目描述</h3><p>通过前面一系列的练习，用户应当已经熟悉单个模块电路的设计了。对于功能上更复杂的电路模块，一般都是由若干子模块以及附加的功能电路构成的。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102301840.png" /></p><p>在模块实例化过程中，被例化模块的端口信号是最重要的，用户甚至可以不知道模块的内部结构。上图展示了一个非常简单的包含有子模块电路的电路结构，在此电路中，创建模块mod_a的一个实例化，并将该实例化模块的三个端口（<code>in1</code>,<code>in2</code>,<code>out</code>）与顶层电路的三个端口(<code>a</code>,<code>b</code>,<code>out</code>)直接连接，其中<code>mod_a</code>模块的代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a ( <span class="hljs-keyword">input</span> in1, <span class="hljs-keyword">input</span> in2, <span class="hljs-keyword">output</span> out );<br><span class="hljs-comment">// Module body</span><br><span class="hljs-keyword">assign</span> out = in1 &amp; in2; <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>模块实例化一般有两种语法格式，分别称为基于端口名称的实例化和基于端口位置的实例化。 基于位置的实例化和C语言中的函数调用类似（只是语法上类似，实际上该例化会产生实际的硬件电路），以上述<code>mod_a</code>模块的实例化为例，可以在上层模块中使用以下语句：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<span class="hljs-keyword">input</span> wa,<span class="hljs-keyword">input</span> wb,<span class="hljs-keyword">output</span> wc);<br>mod_a inst_name1(wa,wb,wc);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>其中<code>inst_name1</code>是<code>mod_a</code>模块的实例化名称，可以由用户自定义，通过这种例化方式，便实现了端口对应：<code>wa↔︎in1</code>, <code>wb↔︎in2</code>, <code>wc↔︎out</code>。 基于端口名称的实例化如下所示</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<span class="hljs-keyword">input</span> wa,<span class="hljs-keyword">input</span> wb,<span class="hljs-keyword">output</span> wc);<br>mod_a inst_name2(<br><span class="hljs-variable">.out</span>(wc),<br><span class="hljs-variable">.in1</span>(wa),<br><span class="hljs-variable">.in2</span>(wb));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>本教程推荐用户使用基于端口名称的例化方式，因为这种方式编写的代码可读性更强。 试创建一verilog电路，并按照上图中所示实例化<code>mod_a</code>模块（建议使用基于端口名称的方式实例化）。</p><p>Hint:</p><ul><li>推荐使用基于端口名称的实例化方式</li><li>模块调用就像是一个树形的层次结构，不允许循环调用，如a调用b，b又调用a，也不允许模块调用自身，即模块c中又实例化模块c。</li><li>不允许在进程块（如always、initial等）或赋值语句（如assign语句）内进行模块实例化</li><li>模块的实例化名称可以自定义，如在同一模块中要对一个模块多次实例化，需要有不同的实例化名称。</li></ul><h3 id="输入格式-9">输入格式</h3><p>一位线网型变量a、b</p><h3 id="输出格式-9">输出格式</h3><p>一位线网型变量out</p><h3 id="代码和解析-9">代码和解析</h3><p>正如上一篇文章中所说，模块实例化可以类比为C语言里面的函数调用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">input</span> a,<br>  <span class="hljs-keyword">input</span> b,<br>  <span class="hljs-keyword">output</span> out<br>);<br>  <br><span class="hljs-comment">// 请用户在下方编辑代码</span><br><br>mod_a mod_a_inst(<span class="hljs-variable">.in1</span>(a),<span class="hljs-variable">.in2</span>(b),<span class="hljs-variable">.out</span>(out));<br><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> mod_a ( <br>  <span class="hljs-keyword">input</span> in1, <br>  <span class="hljs-keyword">input</span> in2, <br>  <span class="hljs-keyword">output</span> out <br>);<br><span class="hljs-keyword">assign</span> out = in1 &amp; in2;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221003-20221009）</title>
    <link href="/2022/10/09/%E5%91%A8%E8%AE%B0-20221003-20221009/"/>
    <url>/2022/10/09/%E5%91%A8%E8%AE%B0-20221003-20221009/</url>
    
    <content type="html"><![CDATA[<p>这周是校历第六周。在本周，我的生活有些许改变。首先是学习了FPGA的Verilog开发的基本知识，基本上能独立刷题了，其次是开始以一个较高的频率在图书馆自习，最后是，能规律地安排每天的空闲时间。 周一，我和朋友一起去吃吉野家小火锅，然后她忘了做核酸了，我就陪她在海淀区找能24h核酸的医院。因为天气也降温了，我就想起之前的几个十一。19年的十一，我有很大一部分时间在图书馆学习，但是3号我从北京南站坐高铁去天津滨海新区站，听了幻奏；20年的十一，我也和车万群的群友们以及舍友们一起去听了幻奏华章。那时候我还和天津舍友说，下次去的时候，希望能多在天津待几天，而不是上午去下午回；21年的十一，本来幻奏是打算在北京办，也就不用去天津了，我去了IDO，看社团的朋友们在漫展的大舞台上演出，感觉很幸福，从IDO赶回宿舍以后，我迅速组装了刚到的电脑屏幕，然后和舍友一起看了上海幻奏的直播。总之前三年的十一，我基本都是在车万，具体来说是幻奏的陪伴下度过的。但是今年呢？我只想念两句古文：</p><blockquote><p>胜地不常，盛筵难再，兰亭已矣，梓泽丘墟。</p></blockquote><p>和</p><blockquote><p>向之所欣，俯仰之间，已为陈迹，犹不能不以之兴怀，况修短随化，终期于尽！</p></blockquote><p>那时的世界，万类竞发，生机勃勃，犹在眼前，短短三年过去，竟然一变而成为我的葬身之地了么？？另：吉野家小火锅挺好吃。</p><p>在学习方面，下一步，我要在每天醒来都对今天要做什么事情有一个比较明确的规划，这样的话效率会比较高。同时，应该认真规划一下两个科研项目的时间。电赛，说实话有点想摆了。</p><p>游戏方面继续玩赛博朋克，不过玩的少了一点。</p><p>继续读论中国，这个书很长，要读很久。</p><p>周日早上去海洋馆了，晚上又看了一遍凉宫春日的消失，依然很震撼。我看了不知道多少遍了，但是每看一遍就震撼一遍。</p><p>最近那个AI作图还挺火的。我朋友圈里面有支持的，也有反对的。有人说这是产业革命，这有可能是正确的。但就艺术来看，十九世纪末，照相技术的出现迫使艺术界走向了表现主义等现代主义风格，而不再以追求“像”为最高标准。在AI绘画的冲击下，下一个美学标准该如何定义？今后的艺术如何发展？百年未有之大变局，我非常的期待。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092337692.jpg" alt="可倒(导)不一定连续？" /><figcaption aria-hidden="true">可倒(导)不一定连续？</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092338021.jpg" alt="凉宫春日的消失" /><figcaption aria-hidden="true">凉宫春日的消失</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092338380.jpg" alt="图书馆" /><figcaption aria-hidden="true">图书馆</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092338157.jpg" alt="花园鳗" /><figcaption aria-hidden="true">花园鳗</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(1-10)</title>
    <link href="/2022/10/08/verilog1-10/"/>
    <url>/2022/10/08/verilog1-10/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="准备工作">准备工作</h2><ol type="1"><li><p>安装Vivado软件，VSCode软件，VSCode的Verilog插件</p></li><li><p>在环境变量中加入Vivado的XVlog，以便VSCode检查</p></li><li><p>在Vivado中新建一个project，除取名和选择路径以外一路Next即可。</p></li><li><p>来到了以下界面</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082304579.png" alt="image-20221008230354388" /><figcaption aria-hidden="true">image-20221008230354388</figcaption></figure><p>鼠标选择Constraints，点加号，在弹出的窗口中选择第二个选项，点Next，点Creat File新建一个文件，文件名最好是模块名。</p></li><li><p>点小齿轮（设置），点Text Editor，选择Custom Editor，输入<code>.../Microsoft VS Code/Code.exe -g [file name]</code>，点OK</p></li><li><p>先打开VSCode软件，再双击Vivado Sources/Design Sources里你刚刚新建的.v文件，弹出新VSCode窗口，于是可以开始写代码了。</p></li></ol><h2 id="输出1">输出1</h2><h3 id="题目描述">题目描述</h3><p>编写 Verilog 代码，使电路输出信号1</p><h3 id="输入格式">输入格式</h3><p>无输入</p><h3 id="输出格式">输出格式</h3><p>输出1，位宽为1</p><h3 id="代码和解析">代码和解析</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(out);<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>  <span class="hljs-keyword">assign</span> out = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这个题没什么好解析的，直接用<code>assign</code>赋值即可，主要熟悉基本的操作。Verilog的基本结构是模块，也就是这里面的<code>module</code>，一个模块代表一个功能单元。模块最基本的结构是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名称(端口列表);<br>    <span class="hljs-keyword">input</span> 数据类型(<span class="hljs-keyword">reg</span> 或 <span class="hljs-keyword">wire</span>) 输入端口表;<br>    <span class="hljs-keyword">output</span> 数据类型(<span class="hljs-keyword">reg</span> 或 <span class="hljs-keyword">wire</span>) 输出端口表;<br>    <span class="hljs-comment">//逻辑代码...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>上述的声明方法是Verilog-1995标准 风格，还有一种声明方法是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名 <span class="hljs-variable">#(参数声明1，参数声明2,...)</span><br>    (端口声明 端口<span class="hljs-number">1</span>，端口<span class="hljs-number">2</span>，...,<br>     端口声明 端口<span class="hljs-number">3</span>，端口<span class="hljs-number">4</span>,....);<br>    <span class="hljs-comment">//逻辑代码...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>以这种风格书写的本题代码是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">output</span> out<br>);<br>  <span class="hljs-keyword">assign</span> out = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="输出0">输出0</h2><p>把上题中的<code>1</code>变成<code>0</code>即可，略。</p><h2 id="wire">wire</h2><h3 id="题目描述-1">题目描述</h3><p>wire 是 Verilog 的关键字，用于表征信号类型的，其含义是线网。wire 可理解为物理连线，但又有所不同，因为 Verilog 中的 wire 是有方向的。例如设计一模块，模块名命名为 top_module，输入信号名为 in，输出信号名为 out，使 in 与 out 直连，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082321013.png" /></p><p>请使用 assign 语句将代码补充完整，使其实现上述电路图的功能。</p><h3 id="输入格式-1">输入格式</h3><p>任意</p><h3 id="输出格式-1">输出格式</h3><p>与输入完全相同</p><h3 id="代码和解析-1">代码和解析</h3><p>Verilog的变量有两种最基本的类型，即<code>wire</code>和<code>reg</code>，默认1位宽。</p><p><code>wire</code>如其名字所示，表示连线。驱动端信号的改变会立刻传递到输出的连线上。输入输出端口，如果不另行声明类型，都默认为`<code>wire</code>，如果使用<code>assign</code>的连续赋值语句，被赋值的变量都得是<code>wire</code>。</p><p><code>reg</code>的意思是寄存器，它能保持其值，直到它被赋于新的值。在行为建模中，在过程块(<code>always</code>块)中被赋值的变量必须是<code>reg</code>类型</p><p>还有其它类型，如整数、实数、比特矢量、数组，等用到了再说。</p><p>这个题的代码实现是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(in,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out = in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多个端口的模块">多个端口的模块</h2><h3 id="题目描述-2">题目描述</h3><p>wire是Verilog的关键字，用于表征信号类型的，其含义是线网，wire可理解为物理连线，但又有所不同，因为verilog中的wire是有方向的，例如设计一模块，模块名命名为top_module，输入信号名为in，输出信号名为out，使in与out直连，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082332727.png" /></p><p>请使用assign语句将代码补充完整，使其实现上述电路图的功能</p><h3 id="输入格式-2">输入格式</h3><p>1 1 1</p><h3 id="输出格式-2">输出格式</h3><p>1 1 1 1</p><h3 id="代码和解析-2">代码和解析</h3><p>这题没啥解析的，和上一题差不多。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,c,w,x,y,z);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b,c;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> w,x,y,z;<br>    <span class="hljs-keyword">assign</span> w=a;<br>    <span class="hljs-keyword">assign</span> x=b;<br>    <span class="hljs-keyword">assign</span> y=b;<br>    <span class="hljs-keyword">assign</span> z=c;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h2 id="非门">非门</h2><h3 id="题目描述-3">题目描述</h3><p>创建一个名为top_module的Verilog模块，实现非门的功能</p><h3 id="输入格式-3">输入格式</h3><p>无</p><h3 id="输出格式-3">输出格式</h3><p>无</p><h3 id="代码和解析-3">代码和解析</h3><p>在这个题里，我们要介绍一下连续赋值。总的来说，Verilog里有两种赋值，叫做过程赋值和连续赋值。其中过程赋值主要在<code>initial</code>或<code>always</code>块中使用，我们也是到时候再说，先来说连续赋值。</p><p>连续赋值的格式是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> 被赋值量 = 值;<br></code></pre></td></tr></table></figure><p>其中被赋值量只能是<code>wire</code>型的，值的类型没有限制。</p><p>本题的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> b;<br>    <span class="hljs-keyword">assign</span>  b = ~a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="与门">与门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082342033.png" /></p><p>和上一题差别不大</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=a&amp;b;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="或非门">或非门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082343150.png" /></p><p>和上一题的差别不大，或非的意思就是先或再非。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=~(a|b);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="同或门">同或门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082344430.png" /></p><p>和上一题差别不大，同或的意思就是俩信号一样就是0，不一样就是1，也就是异或取反。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=~(a^b);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="线网型中间信号">线网型中间信号</h2><h3 id="题目描述-4">题目描述</h3><p>之前的verilog模块结构都比较简单，输出信号可直接用输入信号的逻辑表达式表示出来，模块功能稍微复杂时，一般都会用到中间信号，以下图为例，输入信号in经过两个非门后输出到out端口，为了在verilog模块中表示两个非门中间的这跟信号，需要将其定义为线网型（wire）信号，此处我们命名为not_in。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082345009.png" /></p><p>上述模块的verilog代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> out;<br>);<br>    <span class="hljs-keyword">wire</span> not_in;<br>    <br>    <span class="hljs-keyword">assign</span> out=~not_in;<br>    <span class="hljs-keyword">assign</span> not_in=~in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请根据上述示例，完成下图中电路所对应的Verilog模块</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082346567.png" /></p><h3 id="输入格式-4">输入格式</h3><p>四个线网型变量a、b、c、d</p><h3 id="输出格式-4">输出格式</h3><p>两个线网型变量out、out_n</p><h3 id="代码和解析-4">代码和解析</h3><p>这个题属于稍微复杂一点的组合逻辑，需要用到中间变量。在做题以前，我们先观察一下他给我们的代码，里面有这么两句：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out=~not_in;<br><span class="hljs-keyword">assign</span> not_in=~in;<br></code></pre></td></tr></table></figure><p>有同学可能就问了，按照逻辑，难道不应该是<code>not_in</code>先有值，然后<code>out</code>才有值吗？怎么能先给<code>out</code>赋值呢？这就是Verilog的一个特点，那就是并行赋值。你不要把这两个语句当成C语言，先执行上面的，再执行下面的，而是要当成图里面那个电路，输入信号来的时候，<code>not_in</code>和<code>out</code>有先后之分吗？忽略光速和元件延时的情况下，显然没有。</p><p>根据给出的图，我们很容易写出下面的代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,c,d,out,out_n);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b,c,d;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out,out_n;<br>    <span class="hljs-keyword">wire</span> x,y;<br>    <span class="hljs-keyword">assign</span> x = (a&amp;b);<br>    <span class="hljs-keyword">assign</span> y = (c&amp;d);<br>    <span class="hljs-keyword">assign</span> out = x|y;<br>    <span class="hljs-keyword">assign</span> out_n=~(x|y);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>但是有个问题，就是我们不知道这个代码对不对。那么怎么知道我们的代码是怎么运行起来呢？在C语言里，我们一般是编译执行然后在控制台里输入一些数据，看输出是不是符合我们的期待。在Verilog中，我们也要给程序输入一些信号，看输出的信号是否符合我们的期待，但是这个过程比C语言的要复杂一些：我们还要再写一个Verilog代码，它叫做“testbench”。</p><p>首先我们回到Vivado软件，鼠标选择Constraints，点加号，在弹出的窗口中选择第<strong>三</strong>个选项，点Next，点Creat File新建一个文件，文件名最好是“模块名_tb”。这里的“tb”就是"testbench"的意思。然后，在Simulation Source里面就生产力testbench代码。</p><p>testbench代码的基本结构是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> 模块名_tb;<br>   <span class="hljs-keyword">reg</span> 输入端口名<span class="hljs-number">1</span>,输入端口名<span class="hljs-number">2</span>,...;<br>   <span class="hljs-keyword">wire</span> 输出端口名<span class="hljs-number">1</span>，输出端口名<span class="hljs-number">2</span>，...;<br>   模块名 模块的示例名(.端口名<span class="hljs-number">1</span>(端口<span class="hljs-number">1</span>),.端口名<span class="hljs-number">2</span>(端口<span class="hljs-number">2</span>),...);<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>       输入端口<span class="hljs-number">1</span>=值<span class="hljs-number">1_1</span>;输入端口<span class="hljs-number">2</span>=值<span class="hljs-number">1_2</span>;...<br>       #<span class="hljs-number">50</span>;<br>       输入端口<span class="hljs-number">1</span>=值<span class="hljs-number">2_1</span>;输入端口<span class="hljs-number">2</span>=值<span class="hljs-number">2_2</span>;...<br>       #<span class="hljs-number">50</span>;<br>       ...<br>       输入端口<span class="hljs-number">1</span>=值n_1;输入端口<span class="hljs-number">2</span>=值n_2;...<br>       #<span class="hljs-number">50</span>;<br>       <span class="hljs-built_in">$stop</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这里面有几个我们之前没见过的东西。首先是第一行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br></code></pre></td></tr></table></figure><p>这个以反撇号开头的语句叫做编译指令，用于说明参考时间单位和仿真时间精度。</p><p>然后是第五行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">模块名 模块的示例名(.端口名<span class="hljs-number">1</span>(端口<span class="hljs-number">1</span>),.端口名<span class="hljs-number">2</span>(端口<span class="hljs-number">2</span>),...);<br></code></pre></td></tr></table></figure><p>这个叫做“例化”，可以类比C语言里面的“调用”。在C语言中，调用一个函数只能按顺序传参，但是在Verilog里，可以像这里一样端口命名法传递信号。</p><p>然后是第十行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">#<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>这个的意思是延时50个时间单位。</p><p>于是，我们可以写出这道题的testbench代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> top_module_tb;<br>   <span class="hljs-keyword">reg</span> a, b, c, d;<br>   <span class="hljs-keyword">wire</span> out, out_n;<br>   top_module ul(<span class="hljs-variable">.a</span>(a),<span class="hljs-variable">.b</span>(b),<span class="hljs-variable">.c</span>(c),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.out</span>(out),<span class="hljs-variable">.out_n</span>(out_n));<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      a=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;d=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      <span class="hljs-built_in">$stop</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>呃，说实话，这个代码不是我写的，是我写的代码帮我写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入模块名称:&quot;</span>);<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入input信号个数：&quot;</span>);<br><span class="hljs-type">int</span> NumInput;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;NumInput);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;依次输入input信号名称：&quot;</span>);<br>string inputSign[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i) &#123;<br>cin &gt;&gt; inputSign[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入output信号个数：&quot;</span>);<br><span class="hljs-type">int</span> NumOutput;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;NumOutput);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;依次输入output信号名称：&quot;</span>);<br>string outputSign[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i) &#123;<br>cin &gt;&gt; outputSign[i];<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;`timescale 1ns / 1ps\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;module &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;_tb;\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;   reg &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i)&#123;<br>cout &lt;&lt; inputSign[i];<br><span class="hljs-keyword">if</span>(i!=NumInput) cout&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;;&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   wire &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i)&#123;<br>cout &lt;&lt; outputSign[i];<br><span class="hljs-keyword">if</span>(i!=NumOutput) cout&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;;&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; ul(&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i)<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; inputSign[i] &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; inputSign[i] &lt;&lt; <span class="hljs-string">&quot;),&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; outputSign[i] &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; outputSign[i] &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br><span class="hljs-keyword">if</span> (i != NumOutput) cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;);&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   initial begin&quot;</span> &lt;&lt; endl;<br><span class="hljs-type">int</span> pow2in = <span class="hljs-number">1</span> &lt;&lt; NumInput;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= pow2in<span class="hljs-number">-1</span>; ++i) &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;      &quot;</span>;<br><span class="hljs-type">int</span> temp = i, cnt = NumInput;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= NumInput; ++j)<br>cout &lt;&lt; inputSign[j] &lt;&lt; <span class="hljs-string">&quot;=0;&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span> (temp &amp;&amp; cnt&gt;=<span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; inputSign[cnt] &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; temp % <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>temp = temp / <span class="hljs-number">2</span>;<br>--cnt;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=cnt;j&gt;=<span class="hljs-number">1</span>;--j)&#123;<br>cout &lt;&lt; inputSign[j] &lt;&lt; <span class="hljs-string">&quot;=0;&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;      #50;&quot;</span>&lt;&lt;endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;      $stop;&quot;</span>&lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   end&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;endmodule&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存文件，点这个</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210090004442.png" alt="image-20221009000446371" /><figcaption aria-hidden="true">image-20221009000446371</figcaption></figure><p>Vivado就产生了对应的波形：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210090005315.png" alt="image-20221009000506234" /><figcaption aria-hidden="true">image-20221009000506234</figcaption></figure><p>我们就能照着这个看自己写的对不对了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220926-20221002）</title>
    <link href="/2022/10/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220926-20221002%EF%BC%89/"/>
    <url>/2022/10/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220926-20221002%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是第五周，我主要受三种情绪控制，其一是对十一假期的期盼，其二是十一假期的欢乐，其三是对十一只放三天的怒火。</p><p>原神3.1更新了，还挺好玩的，不过我不太喜欢这种地下迷宫，尤其是没有地图的这种，要吐了，晕。另外最近把赛博朋克2077又捡起来了，继续玩。下一部打算玩ever17。</p><p>日本史快看完了，下一本书准备看《论中国》。</p><p>又去打了打羽毛球，感觉强度有点大，当然其实是我太菜了（悲伤）</p><p>又看了一遍利兹与青鸟，不得不说是真的好看。于是我把我的二次元锐评完善了一些，在考虑要不要发到公众号上。</p><p>王老师找我做项目来着，选C++还是py我还是有点犹豫。如果算上这个，我手里现在有3个科研方面的项目了，会不会太多了？总之先做做看吧。</p><p>舍友请我们吃鹤一烤肉，不得不说四道口店比中关村店还是差太多了。尤其是饮料和水果这方面来说。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210042319974.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220919-20220925）</title>
    <link href="/2022/09/20/%E5%91%A8%E8%AE%B0%EF%BC%8820220919-20220925%EF%BC%89/"/>
    <url>/2022/09/20/%E5%91%A8%E8%AE%B0%EF%BC%8820220919-20220925%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220918</h2><p>这个电子电路2真尼玛逆天，上了三周课我还不知道在讲什么玩意，烦人。</p><p>当了复变助教了，感觉事不太多，钱也不太多，还行吧。</p><p>好多群友都保研了，恭喜，焦虑。</p><h2 id="section-1">20220919</h2><p>今晚屁也没干，游戏游戏没玩，作业作业没写，动画动画没看，盯着sb科研数据看了一晚上也没看出来什么结果。</p><p>不过赛博朋克是真的很好看，这周内打算写一篇不太短的评论，放在那个二次元合集里。此外，我还打算把二次元合集里面的评论扩充一下，改天发到公众号上。</p><p>从今天起，没课的早上要八点起床，没课的下午要两点起床。</p><h2 id="周记">周记</h2><p>这周懒了，我感觉一周记一次也挺好，哈哈。</p><p>这周有点麻啊，主要是突然感觉事情太多了，我看看啊，一个车的大创，一个10月中旬的电赛（我还啥也不会），一个11月中旬的数学竞赛，还有演化博弈科研，课内学习的就不说了。事情堆在一起，容易玉玉。而且电赛那sb stm32f3discovery上网查了半天也没有点靠谱资料，更加玉玉。总而言之这周比较郁闷，其根源在于事情太多而自己的效率太低。好在是把夏日重现补完了，上了实变函数，和朋友大吃了两顿，stm32实现了流水灯和指南针，SPI加速度计就摆烂了，也就没那么玉玉了，行吧。</p><p>原神两天没打了，3.1快更新吧，我等不及了。</p><p>好多群友都爆炎了，我也想爆炎，还有那卓越工程师计划，那是什么东西？</p><p>专属导师和四个朋友一起选了王君臣，不错。就是可怜了那一个我们都不认识的同学，不知道撞见小团体团建作何感想（）</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220912-20220918）</title>
    <link href="/2022/09/12/%E5%91%A8%E8%AE%B0%EF%BC%8820220912-20220918%EF%BC%89/"/>
    <url>/2022/09/12/%E5%91%A8%E8%AE%B0%EF%BC%8820220912-20220918%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>大三上第三周。</p><span id="more"></span><h2 id="section">20220912</h2><p>今天是2022年全部假期的倒数第三天。开了个会，打了会游戏，看了会书，写了会作业。</p><h2 id="section-1">20220913</h2><p>今天搞了一下科研</p><h2 id="section-2">20220914</h2><p>最近有两部很期待的动画更新了，分别是赛博朋克和四叠半，我很开心。</p><p>最近生活正在慢慢步入正轨，线下上课也恢复了，也有东西可看了。以后要争取每天八点起床。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209142355137.png" alt="image-20220914235336619" /><figcaption aria-hidden="true">image-20220914235336619</figcaption></figure><h2 id="section-3">20220915</h2><p>今天吃了个早饭，以后每天都要吃早饭。</p><p>今天上了DSP，写了写慕课作业。</p><p>以后要多出去自习。</p><h2 id="section-4">20220916</h2><p>今天玩了一会儿赛博朋克2077.</p><h2 id="section-5">20220917</h2><p>今天我干了一件值得在博客日记上大书特书的乐事，那就是我把我暑假陪朋友在西安玩的游记，里面的“去了”，“去玩了”全改成“调研了”，然后当社会实践报告交了。我暑假去钟楼、城墙、小寨、大雁塔、同盛祥、长安大排档调研了，好辛苦啊。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220905-20220911）</title>
    <link href="/2022/09/05/%E5%91%A8%E8%AE%B0%EF%BC%8820220905-20220911%EF%BC%89/"/>
    <url>/2022/09/05/%E5%91%A8%E8%AE%B0%EF%BC%8820220905-20220911%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>大三上第二周。</p><span id="more"></span><h2 id="section">20220905</h2><p>今天周一，上了两节课，写了微波线上作业，和朋友吃了个饭，开心。</p><p>今天刷了一整绝缘套，一个也没出，生气。</p><h2 id="section-1">20220906</h2><p>今日无事。</p><h2 id="section-2">20220907</h2><p>今天把微波作业写了，而且还和朋友自习了喵</p><p>本来说下周要线下上课，我看又没戏了，我佛了。</p><h2 id="section-3">200220908</h2><p>别急，再撑一天就放假。</p><p>DSP没太听懂，幸亏有网课。我对网课这个事物真是又爱又恨。怎么说呢，网课在使得没有资源的同学们享受教育这方面，以及对于像我这种笨笨的老师讲课听不懂的人来说，是很好的。但是现在网课成为了有些老师折磨学生的工具，把考核弄得极其复杂，这就不好了。</p><h2 id="section-4">20220909</h2><p>放假咯！</p><p>一觉醒来，老佛爷👍已经👎了......</p><p>今天找同学买了一本日本史，可以看一看。</p><h2 id="section-5">20220910</h2><p>今天去三大家里玩了。一开始的小满只有那么大一点儿，现在已经长得挺大的了，时间真快。</p><h2 id="section-6">20220911</h2><p>今天和朋友一起吃了个安妮餐厅，意大利菜。一个凯撒沙拉，一个四季披萨，一个大份海鲜意面，一个苹果派，俩人202。</p><p>凯撒沙拉没什么可说的，里面放的那个咸肉口感非常的不错，味道有点像咸蛋黄，可推荐。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255795.jpg" alt="凯撒沙拉和送的餐前面包" /><figcaption aria-hidden="true">凯撒沙拉和送的餐前面包</figcaption></figure><p>四季披萨很好吃，一张饼上有火腿、酸菜、茄子、蘑菇四种料，都还不错，除了我自己不太喜欢吃酸菜以外。用的芝士相当不错。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255034.jpg" alt="四季披萨" /><figcaption aria-hidden="true">四季披萨</figcaption></figure><p>海鲜意面的味道很有特色。餐厅标注的是辣，但是吃起来其实并不辣，倒像是“辛”。就很明显不是辣椒的味儿，而像是某种草的味儿。意面口感不错，但是那个饼有点咸了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255783.jpg" alt="海鲜面" /><figcaption aria-hidden="true">海鲜面</figcaption></figure><p>苹果派属实不好吃，太甜了，不知道意大利人怎么吃的，也不怕得糖尿病。送的冰激凌不错，香草味的，应该是用了真香草。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255927.jpg" alt="苹果派" /><figcaption aria-hidden="true">苹果派</figcaption></figure><p>上面四张食物的图片都是朋友拍的。</p><p>吃完以后去了颐和园。在颐和园里面走的时候有点伤感，因为上次来颐和园还是2019年9月初，那时我还没有入学，北京勃勃生机，万类竞发，犹在眼前。我在群里和朋友玩画图红包，笑得不亦乐乎。三年过去了，世界和我们都改变了很多，甚至连画图红包都没有了，真是可叹。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220829-20220904）</title>
    <link href="/2022/08/30/%E5%91%A8%E8%AE%B0%EF%BC%8820220829-20220904%EF%BC%89/"/>
    <url>/2022/08/30/%E5%91%A8%E8%AE%B0%EF%BC%8820220829-20220904%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220829</h2><p>今天上了模电2和微波，网课，感觉不如线下</p><p>想想上次线下上课还是4月，等于说是你航一个五一节放到现在了，我且看还能放几天</p><p>今天做核酸时看到的牌子。不觉得这很酷吗？作为一名学生我觉得这太酷了，很符合我对未来生活的想象。艺术并带着趣味。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208302354739.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section-1">20220830</h2><p>今天上了数电和体育。</p><p>我要立下目标：从今天起直到写完，每天至少写500字我的小说。</p><h2 id="section-2">20220831</h2><p>呜，今天早上上课上着上着就睡过去了，以后要在底下上课了呜。</p><h2 id="section-3">20220901</h2><p>今天学习效率还是不太高，要好好反思，打起精神来。</p><p>今天准备开始记账。</p><p>其实我越来越感觉，不论对开发商还是对消费者来说，所谓的氪金抽卡确实是比高价买断更先进的游戏付费方式。对消费者来说，氪金抽卡游戏的价格完全是由消费者来决定的，也就是说我想付多少钱就付多少钱，想不付多少钱就不付多少钱，而不是一定要先付个一二百乃至四五百才能玩，否则连体验都不能体验。我不体验体验怎么知道游戏好不好玩呢？那可能有人说我在饭店吃饭不也是先付钱再吃饭的吗？但是我一定要吃饭，却不一定要玩游戏。</p><p>对开发商来说，一定有很多不理性而且有很多钱的人有巨额氪金的情况，其给开发商带来收入不一定比买断制要低。而且免费也大大降低了游戏的门槛。譬如说我现在也给某款游戏充了若干元，对我来说其带来的乐趣是可以cover掉这一点消费的，而如果要我一次性付清这些钱才能玩游戏，那么我大概是肯定不想付的。</p><p>现在这种付费方式的最大缺点就是采取这种先进方式的游戏质量整体来说太差，和其付费方式的先进程度不能匹配，导致缺乏游戏性，对其游戏本身的批判蔓延到了对其付费方式的批判上。假以时日，当有能力制作优秀游戏的开发商意识到了这一点时，这样的付费方式一定会大行其道的，而且其实现在以及有这样的趋势了，我们拭目以待。</p><h2 id="section-4">20220902</h2><p>今天效率提高了一点，至少写了点作业，明天要继续进步。</p><p>今天科幻世界到了，我明天去取。</p><p>我打算从昨天起，不定期但以较高频率地在周记中发表一些篇幅不长的论述，字数不超过1000字，目的是提升我的逻辑语言能力。所以在写这些论述时，我首先尽量不使用梗，其次尽量不使用类比。</p><p>【键政预警】</p><p>其实我越来越感觉，中华文明即将成为全地球人类的希望。</p><p>首先，从近两年美、欧的乱象来看，他们是指望不上的。他们总是在内耗、在内斗、在垂直切分，搞什么LGBT巴拉巴拉这种无意义的事情。一个SLS咕咕了几年了？从我上初中时就开始吹逼，到现在也没见发射；马斯克不是说要去火星吗？亏我在重型猎鹰发射的时候还吹了一波，现在也只知道往近地轨道倒垃圾了。之前想要拿碳排放遏制中国的发展，最后反而是自己先坚持不下去了。他们甚至连联合起来遏制中国都做不到，还指望他们能做什么呢？一个新冠病毒，全地球齐心协力早在两年前就遏制完了的东西，拖拖拖拖到22年，还妄图利用大自然拉着少数掌握着真理的社会陪葬，这样的图谋是痴心妄想的。指望美、欧社会带动全人类向前走，已经不可能了，他们不把地球拖入万丈深渊，就谢天谢地了。</p><p>其次，中华文明是世界上最后的无神论灯塔。先进的无神论和中国特色社会主义思想必将为社会的发展提供澎湃的动力，这里不展开了，将来有机会单开一段。</p><p>戈尔巴乔夫前几天死了。苏联在冷战中的教训告诉我们，在大国积重难返时，一旦开始伤筋动骨地改制，那么下一步就只有崩溃了。可是已经积重难返了，不改制也是会渐渐没落的。美国事实上已经失败了，其积重难返已经显而易见了，无论是特朗普，还是拜登上台，已经没有回头路了，最大的区别无非是迅速惨败，还是日薄西山，当然还有一种选择，那就是投降。你们现在已经到了山穷水尽的地步，不要再做无谓的牺牲了。我们现在要面对的，正是这头巨兽垂死前最后的挣扎。进几年的经济形势还会更不好，生活还会更苦一些。但是我相信，未来十几年甚至几十年一定会大大地变好的。希望等我死掉了的时候，可以把我的骨灰发射到太阳系之外，而且我希望这并不需要花太多钱，并不显著地比把我埋到地里贵多少。我对这里的希望能实现有九成的把握，当然前提是在那之前我不出意外，哈哈</p><p>道路是曲折的，前途是光明的。</p><h2 id="section-5">20220903</h2><p>今天白天上课。我就觉得离奇，明明我的课表那么空，偏偏给周六放一节课，脑子有病？</p><p>今天报了个复变助教，不知道要不要我，无所谓了，反正活少钱少。</p><p>今天看了雀斑公主，锐评发到二刺螈评价合集里了。</p><h2 id="section-6">20220904</h2><p>今天歇息，没干啥事。</p><p>今天晚上下了个大雨，太刺激了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220822-20220828）</title>
    <link href="/2022/08/24/%E5%91%A8%E8%AE%B0%EF%BC%8820220822-20220828%EF%BC%89/"/>
    <url>/2022/08/24/%E5%91%A8%E8%AE%B0%EF%BC%8820220822-20220828%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220822</h2><p>今天花20块钱拿到了新校园卡，还挺好看的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208250021563.jpeg" alt="听说是纪念皮肤" /><figcaption aria-hidden="true">听说是纪念皮肤</figcaption></figure><h2 id="section-1">20220823</h2><p>今天不得不控诉一下Word这个软件的难用，不如latex一根脚趾头，不如markdown一根腿毛。</p><h2 id="section-2">20220824</h2><p>今天继续控诉一下Word这个软件的难用，不如latex一根脚趾头，不如markdown一根腿毛。</p><p>今天早上抢必胜客原神套餐没抢上，气死我了。明明北影节都能抢上的。</p><p>今天进原神也进不去，更新了一下显卡驱动好了。</p><p>今天玩了一会儿原神3.0，还挺好玩的。</p><p>今天嗓子有点疼，应该不是冠了吧。</p><h2 id="section-3">20220825</h2><p>今天打了一天森林书，没打完</p><h2 id="section-4">20220826</h2><p>今天把森林书打完了，太震撼了</p><h2 id="section-5">20220827</h2><p>今天做了原神新主线，观感还是不错的，希望mhy再接再厉。</p><p>今天发现微波还要考试，真nm离谱，哪有还没开学就考试的</p><h2 id="section-6">20220828</h2><p>今天是暑假的最后一天，但是其实也不是，因为明天是上网课。从2022年5月1日起，北航就一直在上网课，我倒要看看能上到什么时候。</p><p>今天看了《教父》</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第12届北影节游记</title>
    <link href="/2022/08/22/12%E5%B1%8A%E5%8C%97%E5%BD%B1%E8%8A%82%E6%B8%B8%E8%AE%B0/"/>
    <url>/2022/08/22/12%E5%B1%8A%E5%8C%97%E5%BD%B1%E8%8A%82%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这两天看了三部电影，应该是我有生以来在电影院看电影最频繁的一段时间。</p><span id="more"></span><h2 id="首先评价一下这三座电影院">首先评价一下这三座电影院</h2><h3 id="红剧场">红剧场</h3><p>“红剧场”，原名叫做“北京崇文区工人文化宫大剧场”。在此之前，我曾和朋友一起去海淀区工人文化宫看过一场《波斯语课》，所以说看到电影院的气质感到有些亲切。总的来说就是比较质朴的气质，值得一提的是，这是我这辈子第一次在二楼看电影，体验比想象中要好，各位有兴趣可以尝试一下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035665.jpg" alt="红剧场外景" /><figcaption aria-hidden="true">红剧场外景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035759.jpg" alt="红剧场内景" /><figcaption aria-hidden="true">红剧场内景</figcaption></figure><h3 id="深影国际影城">深影国际影城</h3><p>很现代化的影院，座椅和设备什么的比红剧场好很多，装潢也很漂亮。值得一提的是，似乎是这座影院养活了它所在的“哇沃生活广场”，这个广场的一二层都是饭店，生意很一般，整个三层都是影院。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035634.jpg" alt="深影国际影城" /><figcaption aria-hidden="true">深影国际影城</figcaption></figure><h3 id="天幕新彩云国际影城">天幕新彩云国际影城</h3><p>在中央新影旁边的一个院子里，进放映厅不让带水。它的巨幕厅非常非常巨大且震撼，一定要体验一次。一个趣事是，之前我和朋友曾在此看过《指环王3王者归来》，但是当甘道夫点燃烽火台时，影厅着火了。可能是影厅自带4D功能吧（笑)</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035294.jpg" alt="天幕新彩云" /><figcaption aria-hidden="true">天幕新彩云</figcaption></figure><h2 id="再来说一下这三部电影剧透预警">再来说一下这三部电影（剧透预警）</h2><h3 id="攻壳机动队">攻壳机动队</h3><figure><img src="https://lain.bgm.tv/pic/cover/l/53/9f/237_a8aEP.jpg" alt="GHOST IN THE SHELL / 攻殻機動隊 攻壳机动队" /><figcaption aria-hidden="true">GHOST IN THE SHELL / 攻殻機動隊 攻壳机动队</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220037972.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：90</p><p>关键字：哲学、科幻、赛博朋克</p><p>锐评：《攻壳机动队》，押井守导演，1995年首映。影片风格朦胧，节奏工整饱满，平衡统一。科幻构想和哲学思考作为一部27年前的电影相当前卫。</p><h3 id="峠qiǎ-最后的武士">峠(qiǎ) 最后的武士</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182351048.jpeg" alt="峠 最后的武士" /><figcaption aria-hidden="true">峠 最后的武士</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220039035.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：84</p><p>关键字：复古、时代、剑戟</p><p>锐评：本来刚看完的时候我给它了非常高的评价，现在回想了以后还是适当下调了一点。在剧中，役所广司饰演的主角是一个思想开阔的和平主义者，但在历史的剧变中被困在了最后一个武士的躯壳里。一个思想先进的人，因为要坚守忠义，被迫守卫行将就木的秩序。整部电影的节奏是庄严肃穆的时代感，正如刘慈欣所说“时间静默地切开一切”，而我们只能看着主角在时代的剧变中一步步走向自己的悲剧。影片中也有温馨的“闲笔”，例如八音盒以及舞蹈情节，调剂了肃穆的基调。役所广司的表演相当精彩，没得说。本片的缺点在于：运镜上世纪五六十年代那味儿太重了，有点刻意了；而且对战争场面的刻画并不尽如人意；没有特别好地展现主角的国际视野和和平主义精神，只是由主角的嘴说出，并没有太多的行为等其它侧面来刻画。不过瑕不掩瑜，值得一看！</p><h3 id="平家物语-犬王">平家物语 犬王</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220040886.jpeg" alt="犬王" /><figcaption aria-hidden="true">犬王</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220040966.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：89</p><p>关键字：表现主义、音乐、live、汤浅政明</p><p>锐评：汤浅政明导演。汤浅政明是现代动画总最具想象力和无拘束的监督之一，这部作品和他之前的作品，例如《春宵苦短，少女前进吧！》一样，深具表现主义风格。影片中live场景很多，演出极具张力，在电影院看非常震撼。故事很简单，基调有些悲戚苍凉。用琵琶演奏出电吉他音色很神奇。另外，这是这三部电影里唯一有特典的一部。希望别的电影也能有点特典233333</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
      <tag>电影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220815-20220821）</title>
    <link href="/2022/08/18/%E5%91%A8%E8%AE%B0%EF%BC%8820220815-20220821%EF%BC%89/"/>
    <url>/2022/08/18/%E5%91%A8%E8%AE%B0%EF%BC%8820220815-20220821%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220815</h2><p>今天我爸开会去了，我就是自己玩。</p><p>首先去了这个啤酒博物馆</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181052168.jpg" alt="啤酒博物馆" /><figcaption aria-hidden="true">啤酒博物馆</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181005625.jpg" alt="啤酒博物馆门口的街道" /><figcaption aria-hidden="true">啤酒博物馆门口的街道</figcaption></figure><p>啤酒博物馆主要介绍青岛啤酒的历史和啤酒的制作方法，还送给我了两杯酒。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181005347.jpg" alt="当日原浆" /><figcaption aria-hidden="true">当日原浆</figcaption></figure><p>挺好喝的其实。但是我自己酒量太小，两杯就喝的有点晕了。</p><p>去完博物馆本来准备逛中山路的，但是中山路在施工，遗憾。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181006716.jpg" alt="施工中的中山路" /><figcaption aria-hidden="true">施工中的中山路</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181007966.jpg" alt="一个模型漫画商店" /><figcaption aria-hidden="true">一个模型漫画商店</figcaption></figure><p>从中山路走到天主教堂，中间有很多街边的小超市，都在卖散装啤酒。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181007027.jpg" alt="散装啤酒" /><figcaption aria-hidden="true">散装啤酒</figcaption></figure><p>因为之前已经喝了两杯了，我怕我醉了， 就买了一斤果啤，葡萄味的，以前没喝过。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181008944.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这是天主教堂，周围有很多现充。首先说明，我不是现充，你见过哪个现充一个人在街上逛游的？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181007790.jpg" alt="天主教堂" /><figcaption aria-hidden="true">天主教堂</figcaption></figure><p>旁边的那个什么青岛名建筑展览挺坑人的，都是沙盘，还有一堆卖东西的。</p><p>从天主教堂出来以后走去栈桥。在栈桥上正走着呢突然下雨了，下得还特别地大。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181010433.jpg" alt="栈桥" /><figcaption aria-hidden="true">栈桥</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181011640.jpg" alt="从栈桥拍大雨中的青岛天际线" /><figcaption aria-hidden="true">从栈桥拍大雨中的青岛天际线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181012884.jpg" alt="大雨中在海上游泳的人" /><figcaption aria-hidden="true">大雨中在海上游泳的人</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181012246.jpg" alt="雨停了以后的青岛天际线" /><figcaption aria-hidden="true">雨停了以后的青岛天际线</figcaption></figure><p>然后坐地铁去大学路，听说这是个网红路。<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181052162.jpg" alt="大学路" /></p><p>为什么要叫大学路呢？是因为旁边是中国海洋大学吗？那知春路能不能改名为北航路啊</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181015059.jpg" alt="网红墙和给网红墙拍照的人" /><figcaption aria-hidden="true">网红墙和给网红墙拍照的人</figcaption></figure><p>我就知道一沾上网红准没好事。</p><p>晚上没干啥事情，喝了个崂山白花蛇草水。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181016351.jpg" alt="白花蛇草水" /><figcaption aria-hidden="true">白花蛇草水</figcaption></figure><p>这玩意是什么味儿呢？有人说是“烂茄子味”，我感觉是在海水里泡发霉了的凉席的味。</p><h2 id="section-1">20220816</h2><p>今天一大早起来发现北京健康宝弹窗了，举办了一下，一个小时以后又好了，很神奇，也有点慌。</p><p>早上九点去海军博物馆。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181021957.jpg" alt="去海军博物馆路上见到的喵喵" /><figcaption aria-hidden="true">去海军博物馆路上见到的喵喵</figcaption></figure><p>说来惭愧，其实我买的黄牛票，不过只有30块钱，完全值回票价，也算行吧。就是我到现场发现即使网上没票了也能现场约，但是一看就现场人那么多感觉还是买票好。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181020971.jpg" alt="海军博物馆" /><figcaption aria-hidden="true">海军博物馆</figcaption></figure><p>这地方人相当的不少。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181022057.jpg" alt="领导人题词" /><figcaption aria-hidden="true">领导人题词</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181022200.jpg" alt="军舰" /><figcaption aria-hidden="true">军舰</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181022459.jpg" alt="舰炮" /><figcaption aria-hidden="true">舰炮</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181023043.jpg" alt="舰载机" /><figcaption aria-hidden="true">舰载机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181023371.jpg" alt="纪念碑" /><figcaption aria-hidden="true">纪念碑</figcaption></figure><p>在军博转了一个早上，因为东西真的很多。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181026237.jpg" alt="海军博物馆的椅子" /><figcaption aria-hidden="true">海军博物馆的椅子</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181026762.jpg" alt="大小错落有致的阀门，有一种艺术感" /><figcaption aria-hidden="true">大小错落有致的阀门，有一种艺术感</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181026267.jpg" alt="军舰" /><figcaption aria-hidden="true">军舰</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181027246.jpg" alt="导弹" /><figcaption aria-hidden="true">导弹</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181027202.jpg" alt="战斗机" /><figcaption aria-hidden="true">战斗机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181027806.jpg" alt="从军舰上看栈桥" /><figcaption aria-hidden="true">从军舰上看栈桥</figcaption></figure><p>本来还说去海底世界sakana的，结果人实在是太多了，算了，下次再sakana。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181028528.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>下午我爸会开完了，我们一起去了小鱼山公园，这个公园主要是爬山看观景台，能把青岛各大景点一览无余，非常推荐。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181029802.jpg" alt="从小鱼山看八大关" /><figcaption aria-hidden="true">从小鱼山看八大关</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181032263.jpg" alt="从小鱼山看栈桥" /><figcaption aria-hidden="true">从小鱼山看栈桥</figcaption></figure><p>然后坐隧道公交车去了金沙滩。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181032845.jpg" alt="这是一个剧院" /><figcaption aria-hidden="true">这是一个剧院</figcaption></figure><p>金沙滩的沙子很细，挺好看的，有很多游泳的人。</p><p>晚上吃了个海鲜大品牌，俩大老爷们没吃完，50块钱，牛得很。</p><h2 id="section-2">20220817</h2><p>圣诞节快乐！</p><p>今天从青岛启程去北京。一路上有惊无险，终于顺利抵达了北京。</p><p>到了北京并没有直接回学校，而是先去了北京国际电影节。</p><p>是和朋友一起看的《攻壳机动队 ghost in the shell》。相当具有哲思，需要注意的是这是一部27年前的电影。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181034263.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181036464.jpg" alt="红剧场" /><figcaption aria-hidden="true">红剧场</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181036651.jpg" alt="北影" /><figcaption aria-hidden="true">北影</figcaption></figure><p>顺便一提，这是我这辈子第一次在二楼看电影。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181037794.jpg" alt="二层" /><figcaption aria-hidden="true">二层</figcaption></figure><p>回宿舍以后宿舍变阿富汗了，逆天。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181048353.jpg" alt="宿舍" /><figcaption aria-hidden="true">宿舍</figcaption></figure><h2 id="section-3">20220818</h2><p>今天早上维护了一下博客，下午做了核酸，晚上又看了一场电影。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182350300.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这个小徽章是填一个调查问卷送的，北影主题的，挺好看的。</p><p>这部电影不是二次元，我就把影评写在这里了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182351048.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>个人评分：84</p><p>关键字：复古、时代、剑戟</p><p>锐评：本来刚看完的时候我给它了非常高的评价，现在回想了以后还是适当下调了一点。在剧中，役所广司饰演的主角是一个思想开阔的和平主义者，但在历史的剧变中被困在了最后一个武士的躯壳里。一个思想先进的人，因为要坚守忠义，被迫守卫行将就木的秩序。整部电影的节奏是庄严肃穆的时代感，正如刘慈欣所说“时间静默地切开一切”，而我们只能看着主角在时代的剧变中一步步走向自己的悲剧。影片中也有温馨的“闲笔”，例如八音盒以及舞蹈情节，调剂了肃穆的基调。役所广司的表演相当精彩，没得说。本片的缺点在于：运镜上世纪五六十年代那味儿太重了，有点刻意了；而且对战争场面的刻画并不尽如人意；没有特别好地展现主角的国际视野和和平主义精神，只是由主角的嘴说出，并没有太多的行为等其它侧面来刻画。不过瑕不掩瑜，值得一看！</p><h2 id="section-4">20220819</h2><blockquote><p>苏联公民们：</p><p>在我们祖国和我国各族人民命运面临严峻危急的时刻，我们向你们发出呼吁！我们伟大的祖国面临致命的危险！由戈尔巴乔夫发起并开始的改革政策，原想作为保障国家迅速发展和使社会生活民主化的手段，却因种种原因已走入死胡同。失去信仰、冷漠和绝望取代了最初的热情和希望。各级政权失去了居民的信任。在社会生活中，玩弄权术取代了对国家和公民命运的关心。对国家各级机构进行恶毒的嘲弄。整个国家实际上已失去控制。</p></blockquote><p>咳咳，跑题了。</p><p>今天有一个伟大的发现，就是冰杯真是个神奇的东西。</p><h2 id="section-5">20220820</h2><p>今天辅导员说西安人赞不返校。我越来越觉得我能返校真是个奇迹。</p><p>记一次和冠神赛跑：</p><p>我一开始是准备20几号返校，但是发现有个北京国际电影节，于是决定17号返校。到了13号决定去先青岛玩，再从青岛直接返校。这时候西安只有2个确诊，还在雁塔区。到了16号了突然感觉火车票太早了，想改签一下，就发现健康宝弹窗了，然后我就申诉了一下，就把弹窗解了。然而当天下午西安就出了几个高风险区，也就是如果我没及时发现弹窗，很可能就没那么容易解了。我17号一大早早上六点多就坐火车去北京，11点到了北京，然后先去看了北影节再去学校。前脚刚进学校没有几个小时，长安区就出了确诊。也就是如果我没去青岛，如果16号没想着改签一下，等等，都有可能回不来了。而现在我在宿舍写下这段记叙，心有余悸。</p><h2 id="section-6">20220821</h2><p>今天看了犬王，太爽了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220808-20220814）</title>
    <link href="/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220808-20220814%EF%BC%89/"/>
    <url>/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220808-20220814%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220808</h2><p>今天北影节的片单出了，我想看教父、攻壳机动队和平家物语。</p><p>今天是世界猫咪日，喵喵~</p><h2 id="section-1">20220809</h2><p>今天深感自己文学功底的浅陋，哎！</p><p>今天我爸说他要去青岛出差，可以带我去。我明天查一查青岛有什么。</p><p>今天细田守的雀斑公主定档了，可以和群友一起看，喵呜。</p><p>今天出了一档子逆天的事，什么不让老师加群什么的，纯粹的脑弹了属于是</p><h2 id="section-2">20220810</h2><p>今天继续写了小说，不过还没更新</p><p>今天继续看了大秦帝国</p><h2 id="section-3">20220811</h2><p>今天继续写了小说，不过还没更新</p><p>今天继续看了大秦帝国</p><p>今天做了个西红柿炒鸡蛋吃，好吃</p><h2 id="section-4">20220812</h2><p>今天和高中朋友date了捏</p><h2 id="section-5">20220813</h2><p>今天主要是收拾东西。其实我真的不想带那么多衣服，学校里衣服就很多了已经。</p><h2 id="section-6">20220814</h2><p>今天从西安去青岛了。</p><p>做的飞机是东航的天合联盟的涂装机，小惊喜</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180954989.jpg" alt="座机" /><figcaption aria-hidden="true">座机</figcaption></figure><p>青岛有个新冠路，相当的震撼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180953922.jpg" alt="“新冠高架路”中的“新”和“冠”,是新疆路和冠县路的首字组合体。" /><figcaption aria-hidden="true">“<em>新冠高架路</em>”中的“新”和“冠”,是新疆路和冠县路的首字组合体。</figcaption></figure><p>下午去了八大关景区。青岛很神奇，它的路都是以别的地方的名字来命名的，比如“八大关”就均以中国古代军事关隘命名，包括纵向连接香港西路的紫荆关路、宁武关路和韶关路，以及横向交织的武胜关路、嘉峪关路、函谷关路、正阳关路、临淮关路、居庸关路和山海关路。八大关最让我震撼的就是这个浮在半空中的雾，这是暖湿空气平流到较冷的下垫面上，下部冷却而形成的雾，叫做平流雾。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180957121.jpg" alt="平流雾" /><figcaption aria-hidden="true">平流雾</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180958568.jpg" alt="从八大关看海" /><figcaption aria-hidden="true">从八大关看海</figcaption></figure><p>晚上去了奥帆中心和五四广场，据说是青岛夜景最漂亮的地方，过去一看确实挺震撼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181001106.jpg" alt="奥帆中心的青岛会议中心" /><figcaption aria-hidden="true">奥帆中心的青岛会议中心</figcaption></figure><p>这个会议中心真的好漂亮，大悬挑大屋顶，大气磅礴。好看！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181001357.jpg" alt="青岛夜景" /><figcaption aria-hidden="true">青岛夜景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181002688.jpg" alt="五四广场" /><figcaption aria-hidden="true">五四广场</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你我皆非人</title>
    <link href="/2022/08/09/%E5%B9%A1%E7%84%B6%E6%82%94%E6%82%9F%EF%BC%88%E6%9A%82%E5%AE%9A%EF%BC%89/"/>
    <url>/2022/08/09/%E5%B9%A1%E7%84%B6%E6%82%94%E6%82%9F%EF%BC%88%E6%9A%82%E5%AE%9A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>自己写的软科幻小说，献丑献丑，这两天持续连载。</p><span id="more"></span><h2 id="第一节">第一节</h2><p>刺耳的警报声从耳机里传出，宪贞才从神游中惊醒。不用说，他又在想那些十几年前的怪事了。</p><p>十几年前，庆田宪贞还是一个意气风发的少年，一切都是那么地幸福，少年和少女一起逛灯会，一起共进晚餐，每晚在电话里互诉衷肠，还有青涩的第一次拥抱和初吻.....她性格热烈奔放，是火一样的少女。一切都那么地美好，直到宪贞的一场车祸夺走了这一切。一开始，宪贞几乎就要死掉了。可是经过抢救，宪贞竟然基本痊愈了，连主刀的老教授也只能感叹一声：医学奇迹。但是，自此之后，她就消失了，就只留下了一张纸条，上面写着“对不起”，而另一面则写着“别来找我”。</p><p>一开始宪贞被愤怒冲昏了头脑，但过了两个月就被疑惑取代。如果只是因为担心车祸后的我拖累自己于是离开也就算了，直接人间蒸发是闹哪样呢？在这两个月里，宪贞问遍了朋友、家人、同学、老师，甚至警察，但是都没有得到任何回答。</p><p>时间在滚滚向前，切开了一切。十几年前迷梦也在慢慢地成为过眼云烟。其信然耶？其梦耶？宪贞有时也有些恍惚。不过宪贞毕业以后就进入了警局，做到了分管失踪人口的小队长，这是千真万确的。</p><p>宪贞看了一眼电脑，是紧急警务通告。</p><p>科技发达的现在，一般事件并不会被推上宪贞的案头。先不说还在试运行的AI追查系统，单单是遍布全城的天眼，找回几个偷偷从后门溜进黑网吧的高中生也不是什么难事。于是宪贞这个小队长的工作，渐渐也从全城到处开着车巡逻，变成了坐在办公室里敲敲键盘鼠标。而像这样发紧急通告的，一年满打满算在这座城市也就两三起。</p><p>一个人鱼纪念中学女生的失踪案，孩子名叫星奈花，成绩平平，但也算得上乖巧，只是最近一个月放学回家越来越晚，直到有一天放学后再也没回来，父母吓得直接报了警。</p><p>宪贞心里一紧，他也知道现在科技的强大，而如果连科技也找不到的人，用人力找无异于大海捞针，更别说最新的AI追查系统只有在面对失踪几年乃至十几年的对象，才会表现出明显优势。</p><p>宪贞操作天眼查询这个女孩子的行踪，发现在失踪哪天，她放学后直接去了一家咖啡店，自己一人进了包间，然后不知所踪，记录就此消失。宪贞到了咖啡店，一边问老板有没有注意到有人只进来了却没出去。老板被问得一头雾水，回应说店里人来人往，实在难以注意。那有人没付账走了么？宪贞又问。“没有啊，现在都是扫码点单了，哪还有没付账一说。”老板回答。宪贞道了谢，转身离开了咖啡厅。</p><p>说来也奇怪，宪贞自从当上了小队长以后，只遇到过三起能被摆上案头的失踪案件，其中一件顺利解决了，而另一件的线索，恰恰也是在这间咖啡厅断掉的。有一瞬间，宪贞怀疑这个咖啡厅可能大有问题，但转念一想，这里是离中学区最近的咖啡厅之一，学生想谈谈事情，大多也会选择这里，人流量相当大，几乎成了学校的第二食堂：从概率论的角度来说，似乎并不足以判定咖啡厅就是有问题。</p><p>宪贞坐上车，输入了失踪少女的家的位置。少女的家坐落在一片老旧小区里，宪贞把警车停到巷口，一个人挤进昏暗而狭窄的小巷，找到了少女的家。</p><p>按响门铃，开门的是一对夫妻，年龄不轻，估摸着有四五十岁了。男主人头上有了些许银点，而女主人则一直是担忧而后悔的表情。他们的衣服虽说整洁，但也略有发白，看样子经历过的年岁不少。打眼一看，就知道他们是最典型的工薪家庭，有些收入，但也绝供不起挥霍浪费。客厅没有墙纸，一面墙上贴着几张奖状。勤勤恳恳的普通父母，拖拽着家庭走在还算有希望的道路上——本来应该是这样的。</p><p>“啊，是庆田警官吧，请进请进”。父亲先开了口，把宪贞迎进了客厅，还给他倒了一杯茶水。</p><p>“三天以前，她就和往常一样出去上学，再也没回来过。”女主人垂着头说道。宪贞拿出笔记本假装做起了笔记，但实际上，这句话已经在案卷中被他看了不下十遍了。</p><p>“当天她有什么异样呢？有闹情绪之类的吗？”宪贞追问道。</p><p>“没有啊，就是和往常一样出门，然后就没有回来了。”女主人低声答道，男主人接起了话茬：“说到异样，最近一个月里她确实有时候很晚回来，有时候夜不归宿。问她去干什么了，基本都是说和同学一起玩游戏去了。我给她同学打电话，也确实得到了相同的回答，说是在玩最近很火的那个什么《圆神》。我寻思着玩游戏不算什么大事，只要把学习搞好，平时放松一下也不是不行，就没有细问。”</p><p>“但是上周开始女儿身上有时候开始出现了伤痕，也不大，问就说是磕了碰了，不要紧。而且第二天起来就好了，我们也就没细问。谁知道......哎！”</p><p>“不都是怪你不操心吗！女儿只有这一个月成天不回来，你就光打打电话就算完事了？你怎么就不知道拦一下......现在可好！都是你的错！”女主人突然站起来，边哭边捶打着男主人。宪贞拉开他俩，坐定以后，又确认了她的学校，班级之后，留下联系方式便离去了。</p><p>宪贞坐进车里，整理了一下思绪。好吧，至少出现了一点点有意思的线索，也就是那些伤痕。女孩身上出现不大的伤痕，那么女孩是不是有一个崇尚暴力的男朋友呢？然后女孩害怕父母反对，总之就是和男友私奔了。多半是被高年级的海王骗了吧！这个傻女子。“小度，去人鱼中学！”宪贞下了决定。</p><p>正在为您规划路线，预计时间十分钟。</p><p>挺近的，估计为这房子也花了不少钱，宪贞心想。人鱼纪念中学是当地相当有名的升学高中，坊间向来有踏进人鱼就等于半只脚踏进名大学的说法，学费不高，而且从来只看考试成绩录取，交钱不顶用。至于这个诡异的名字，据说是赞助商的癖好吧。</p><p>人鱼中学最近安装了“学生大数据系统”，是全国十所试点的中学之一。学生大数据系统除了能记录学生的姓名、班级、成绩、奖惩等基本信息以外，还可以针对成绩下滑严重、沉迷网络游戏、迟到早退的同学作出预警，甚至可以通过学生们在食堂、浴室、图书馆等地的刷卡签到进行大数据聚类分析，形成学生们的关系图谱。虽然这系统在刚刚推行时引起了很大的关于隐私方面的争议，但它也做到了校内各资源的整合，带来了很大的生活便利，再加上试点的学校也不多，大家久而久之也就默认它的存在了。</p><p>宪贞调取了星奈花的大数据，所有警告项目前面都是一个绿色的对勾，也不知道是幸运还是不幸。只有沉迷网络游戏这一数值最近有增长趋势，印证了父母的证词，但也没到需要警报的程度。接下来就是分析关系图谱了。如果最近有很强的关系形成，就可以沿着“暴力海王”的思路继续追查了。</p><p>宪贞把关系图谱的数据下载下来，导入警方专用的绘图软件中，输入密码后，便生成了可视化的动态关系图谱。计算显示，她最近在和人交往的概率不超过2%——不管是男的还是女的。星奈花在一个月前的社交圈子很稳定，在一个月之内的社交圈子也很稳定。更蹊跷的是，这两个圈子似乎很不一样。</p><p>宪贞把图谱保存下来，又问了星奈花的朋友，也没有得到什么异样的回答，她最近既没有闹情绪，也没有和之前的圈子决裂，总之一切看起来都很正常，除了上课有些打不起精神以外。至于第二个圈子，显得也很正常，只是里面的同学都在玩《圆神》，这看起来就像是星奈花游戏刚入坑，找“大佬”带一样。宪贞问完以后，就离开了人鱼中学。</p><h2 id="第二节">第二节</h2><p>“哎哟我真是草了，怎么又摊上这档子事。”回到办公室的宪贞刚坐到椅子上就开始头大。他整理了一下目前能确定的疑点，首先就是莫名其妙又能迅速痊愈的伤痕，第二个疑点就是一个月前社交圈子的变动。宪贞抱怨道：“真是邪乎到家了！打个游戏能打出伤来，还能把人打没了？我倒要看看这个‘圆神’是个什么东西！”</p><p>同事听到了宪贞的话，便随口接道：“圆神你都不知道？恁游戏最近红得发紫了都，那个开发商，美冬（Mifuyu）科技，以前还名不见经传地，去年发布了圆神，一跃成为了咱们市的重点企业嘞”，同事打了两下键盘，“诺，美冬科技，原来叫什么玛吉斯，光它的增长就占了咱市去年经济增长总量的25%！纳税大户，好得很呐。你要想入坑可以加下我好友，我回头带你哈~”</p><p>宪贞下班后，并没有像往常一样去居酒屋，而是直接向自己的公寓奔去。“5100啊，帮我搜一下这个圆神”，宪贞对他的智能音箱说道。</p><p>好的，正在为您搜索相关信息：</p><blockquote><p>游戏发生在一个被称作“银之庭”的幻想世界，在这里，被神选中的人将被授予“灵魂宝石”，导引魔法之力。玩家将扮演一位名为“魔法少女”的神秘角色，在自由的旅行中邂逅性格各异、能力独特的少女同伴们，和她们一起击败强敌，找回失散的亲人——同时，逐步发掘“灵魂”的真相。</p><p>——维基百科</p></blockquote><p>“那你能给我下一个么？”，宪贞心想，我倒要看看这游戏有什么魔力。</p><p>“下载完成，请带上眼镜，进入VR游戏室体验游戏”智能音箱提示道。宪贞带上眼镜，走上跑步机，系上安全带后，进入了《圆神》的世界。</p><p>首先映入宪贞眼帘的是游戏的登录界面，一座在云上的城市，道路上铺满了略显突兀的鲜花，一位没有面目的白衣女神从天上驾着马车降下，粉色的长发延申到屏幕之外，似乎有无限长。待游戏加载完成后，这位女神来到他的面前，他点击进入了游戏。</p><p>游戏一开始，黄色卷发的loli麻美（宪贞控制的主角）和父母一起乘车郊游，忽然不知道从哪儿窜出来一辆大货车，向主角一行人的车径直撞过去。主角的父母当场去世，主角的视角也在慢慢变成深红色。正当视野即将变成全黑色时，不知道从哪儿窜出来一只明亮的白色生物。从某种意义上来说，这个生物体态和猫有点类似。但是它的嘴是“<span class="math inline">\(\omega\)</span>”形，有两大片从白色到粉红的，像头巾一样的结构从耳朵中冒出来，而它的尾巴也比猫大得多。</p><p>这个生物说话了，却没有开口：“和我签订契约，成为魔法少女吧！麻美，你的愿望是什么？”</p><p>“请，请让我活下去。”屏幕上只有这一个选项。</p><p>“好了，接受它吧，这就是你的命运。”白色生物的“头巾”伸长并且插入了麻美的胸口。麻美的视野恢复了正常，并发现眼前有一个闪着金黄色光芒的宝石。</p><p>宪贞伸手摘下了这颗宝石，游戏正式开始了。</p><p>麻美活了下来，她的父母却没有这么幸运。</p><p>她在白色生物的引导下慢慢往家所在的小城走去。小城的风格是三十年前的画风，看起来有些古朴的质感。一路上，麻美和白色生物边走边聊。白色生物说自己叫做“丘比”，和著名的沙拉酱同名，自己的使命就是来拯救处于危难或彷徨中的少女们，实现她们的愿望并带领她们适应新的生活。</p><p>快到城市时，麻美看到了一个奇怪的生物。在写实画风的游戏中，这个生物却像是从纸上剪下来直接贴在视野里的一样。而且画风相当潦草，边缘还在不停地抖动。这时，丘比说话了：“轻轻地念‘变身’，然后跟着那个生物。”</p><p>麻美用只有自己和麦克风能听到的声音轻轻地念了一声“变身”，之间手中的黄色宝石飞了出去，闪烁着金色的光芒。麻美身上的便服也变成了一身华丽的衣装，手中拿着一柄短剑，身边还漂浮着明黄色的缎带。麻美放轻脚步，慢慢地跟着那个神秘的生物。尽管城市中道路错综复杂，但是当她的方向正确，或者靠近“猎物”时，宝石的闪光频率便会加大，所以找到“猎物”的位置倒也不难。终于，麻美把猎物逼到了一条断头路上，她挥动身边的缎带，把猎物绑缚起来，又用手上的短剑结束了猎物的生命。这时，系统界面弹出一个提示，说这种猎物叫做“使魔”，属于“魔女”的仆役。</p><p>“是魔女的仆役？那么魔女是什么？”，麻美问。丘比答道：“其实魔女才是你们要打的主要目标哦~如果见到使魔就打的话，不仅会浪费自己的魔力，还很难通过它找到魔女的踪影。”</p><p>“在你使用魔法时，你的魔力就会损耗。魔力越损耗，灵魂宝石就越污浊。当灵魂宝石完全浑浊时，会有相当不好的事情发生也说不定...而击杀魔女以后，掉落的物品除了升级素材以外，最重要的就是这个东西，悲叹之种”，丘比向麻美眼前投送了一张图片，悲叹之种就像一根被银针穿过的葡萄。丘比继续说道：“悲叹之种可以清洁你的灵魂宝石，只要把它们放在一起就行了。”</p><p>“那么，如果我一直不战斗，只是在大世界里面逛街，是不是就没事了？”宪贞抛出了自己的疑问。</p><p>丘比似乎早有准备，立刻答道：“减少战斗确实能延缓灵魂宝石的浑浊，但是并不能完全避免。你的负面情绪，负面的身体状态，灵魂宝石都会自动用魔法帮你修复，而且这个功能你并不能自己选择开启或关闭，所以久而久之你的灵魂宝石还是会浑浊。接下来教你几招常用的技能吧......那么，如果没有其它问题的话，我就走咯。如果有问题就叫我，我会马上出现的。”丘比说完，从麻美肩膀上跳下去，消失不见了。</p><p>“哦...”麻美有些迷茫。她并不是没有问题，倒不如说满脑子都是问题，整个脑子都是“loading”状态，所以没法提出来问题。“算啦，走一步看一步吧！”麻美下定决心。</p><p>麻美变回了普通少女的形态，一边把玩着自己的灵魂宝石，一边在城市里逛街。在一个小巷子的转角处，她发现了一个用银针穿过的紫色球体，钉在墙面上。“这不是那个什么悲叹之种吗，在这里是可以直接拿的意思吗？”</p><p>麻美伸手把悲叹之种拔了下来。紧接着，她周围的世界扭曲并折叠，变成了一个漩涡，被吸进了那个悲叹之种留下的小小窟窿里。取代世界的，是另一幅光怪陆离的光景。这个奇异的世界和版画有些类似，色彩相当鲜艳，而且画风相当潦草，边缘还在不停地抖动，就像是哪个小孩子的涂鸦。之前遇到的“使魔”，放在大世界里确实很突兀，放在这个奇幻的空间倒是毫无违和感。现在麻美似乎身处一个走廊里，走廊的墙壁上布满了会动的画，描述着不知道是哪个少女的短暂的一生，走廊的地上铺着鲜艳的鲜花，尽管踩起来丝毫没有鲜花的柔软。</p><p>麻美继续沿着走廊往前走，途中遇到了很多使魔，大多数并没有纠缠她太久，她也没有一直和使魔战斗。又走了几十步，空间一下子变大了起来，直到变成了一个大厅。处于大厅之中的，除了许多使魔之外，还有一个巨大的怪物。只见这怪物有三四个人那么高，通体黑红色，好像将熄未熄的木炭；她的周围，有无数鲜红色的蝴蝶飞舞，好似木炭往四周抛洒的火星。一条提示出现在了麻美面前：</p><blockquote><p>Lv.30 烈焰之魔女，性质是挥霍。泪水和歌喉被耗尽后，她决定挥霍一切生命之火，烧尽世界的救赎。</p></blockquote><p>魔女！麻美眼中只看到了这个词，原来这就是自己的主要敌人：魔女。难耐内心的激动，麻美立刻变身，提起缎带和短剑冲了上去，丝毫没有意识到自己只有5级。</p><p>刚靠近烈焰之魔女，麻美首先感到的是刺骨的严寒，进而是难以言说的酷热。黑红的炭山对麻美吐出火舌，麻美只得左右腾挪躲闪。在火舌和冰柱之间，麻美渐渐地体力不支。魔女似乎也不耐烦了，从身体中掏出一根冒着火舌的长鞭举到空中，对着麻美迎面劈下来。麻美见躲闪不及，硬着头皮受了这一击。区区5级的麻美，又哪里是30级的魔女的敌手？</p><p>麻美只见自己的视野又变黑了，她知道这是“濒死”的现象。她吓得暂停了游戏，从背包中找到能回血的食品胡吃海塞。就这样，麻美一边可怜地往魔女身边凑近，用她的缎带和短剑抛光；一边转身腾挪躲避火舌和冰柱，一边不停地按暂停键，吃应急食品来回血。但是食品终究有吃完的时候，而此时魔女的血量还有五分之四。就当麻美准备放弃，闷着头挨下下一击时，她的眼前突然弹出一个提示：</p><p>“玩家 福蒂亚 正申请加入你的世界”</p><p>就像在洪水中摸到救命稻草一般，麻美立刻同意了她的申请。90级的福蒂亚来到了麻美身边，只一击，就杀死了烈焰的魔女。</p><p>“诺，悲叹之种，你拿走吧，反正我还有好多。”福蒂亚开口了。麻美好像是还没缓过劲来，只是走上前去，拿起了悲叹之种。</p><p>“喂喂，我问你啊，你是刚刚才入坑的吧？怎么找到这里来了？”福蒂亚又问道，“这里可不是新人该来的地方。”</p><p>“啊，我，我就是在城里瞎转了转，不知道怎么就来了......”麻美也不知道怎么回答。</p><p>“哦...这样啊。”福蒂亚不知道怎么，好像有点失望。但她又迅速恢复了刚刚的热情，继续说道“我给你说啊，打怪之前先看一眼等级，Ok？这种Boss不能打就不要乱打。还有就是，你这个角色的技能是可以升级的吧，升到五级以后就能用枪哦，比你现在用的短剑好用多了吧......”她又讲了讲游戏最基本的机制和技巧，就离开了麻美的世界。</p><p>“是这样啊......”麻美缓了缓，照着弗蒂娅说的找了几个等级低的怪物打了打，又给自己的角色升了几级，也就下线了。</p><p>摘下眼镜，离开VR游戏室，宪贞躺在床上回味着自己的《圆神》时光。不得不承认，这游戏能火确实有它的原因的，在其它这种二次元游戏都是氪金抽卡片的换皮游戏的时候，圆神居然有如此奇妙的画风以及宽广的地图。剧情设定到现在倒是没看出什么端倪，看着像上世纪末流行的经典子供向魔法少女。但这一切和失踪案有什么关系呢？罢了，先睡觉吧......宪贞关掉了灯。</p><h2 id="第三节">第三节</h2><p>尽管灯关了，头放到枕头上了，被子也放到身体上了，却怎么也睡不着觉，就感觉心脏上压着一块大石头一样。往日柔和的月光，今天却显得有些刺眼了。宪贞不断地在脑子中整理着昨天一整天的所见所闻。先是咖啡店，然后是身上莫名其妙的伤痕，再是社交圈子的微妙变化，最后是——《圆神》。圆神中又有两个人物，丘比应该是机器人先不说了，这个福蒂亚倒是让人印象颇为深刻，毕竟算是救人于水火之中嘛。火一样的性格，可能也是自己喜欢的类型......等等</p><p>宪贞彻底睡不着了。无论是福蒂亚说话的声音，还是说话的方式，都让宪贞越想越不对劲。宪贞从床上挣扎起来，又进入游戏室，调取了游戏过程的录像，截取了最后福蒂亚出现的那一段以后，拷贝到了自己的U盘里。</p><p>宪贞躺回了床上，一遍又一遍地咂摸着这短短的两句话。不是内容，而是语调和声音。最终他还是和着这段声音进入了梦乡。在梦里，他屡次感觉马上就要捅破那层窗户纸了，但是最终还是没有结果。</p><p>第二天早上，宪贞按时上班时，没有忘记带着他的U盘。宪贞知道，虽然手上这个星奈花的案子暂时还没有头绪，但是论起找人，在市里他说自己的第二，也没人敢说自己是第一。他刚到局里，就溜进了超算机房。而这台超算上，正运行着还在调试的AI追查系统。这套AI追查系统脱胎于宪贞自己大学的科创项目，在大学时期为他带来了倚叠如山的荣誉，基本上来说也是宪贞能如此顺利的当上警察并如坐火箭一般升职的敲门砖。它不仅仅能根据面部、声纹、虹膜等等生物特征在高效地查找人物信息，更厉害的是，一旦知道了一个人的DNA信息，以及任意一个时刻的生物特征，它便能使用人工智能推演出未来某个时刻的特征，包括说话的声音，以及面容等等。它在刚刚投入使用的那一年，便一举帮助几十个被拐卖的儿童找到了父母，而所需要的信息只是出生时的一张照片和一滴血。</p><p>宪贞颤抖着输入了系统的登录密码，然后试着把U盘插到电脑上。当然第一下肯定是插反了的，他又把U盘倒过来，还是插不进去，直到第三次，U盘才精准地滑进了USB口。宪贞深吸一口气，擦了擦手上的汉，把那一段音频拖进了AI追查系统的输入框里，再深吸一口气，按下“确定”：</p><blockquote><p>找到0个目标：第0个/共0个。</p></blockquote><p>这套AI追查系统还没见到过这样的惨败，甚至于宪贞都没有想起来做一个没找到时候的UI界面。毕竟...一个人怎么可能是不存在的呢？宪贞之前一直是这样想的。</p><p>宪贞现在才想起来把自己扔进椅子里，又给自己倒了杯冷水，喝了一大口。一个人怎么可能是不存在的呢？宪贞在问自己。已经死了？不可能，死人也有记录。失踪了？同理。不对不对，这都是一个人消失的情况，而不是一个不存在的人冒出来的情况。反过来想，如果这个人一开始就没有登记过呢？这样的话不就找不到了吗？但是如果连他的父母、兄弟姐妹都匹配不出来，是不是有点太过分了？总不可能一整个家族都没登记吧？</p><p>宪贞把那杯水一口喝完，锁上电脑，又离开了超算房。他决定先冷静冷静。</p><p>上午，专案组里召开了关于星奈花失踪事件的会议，宪贞讲解了一下昨天调查时的记录，讲了讲自己遇到的几个疑点以后就结束了，他的同事们也没有提出什么太有价值的见解。</p><p>散会以后，宪贞又溜进了超算房。就在屁股刚挨到椅子上时，一个念头突然划过——怎么就没考虑到“福蒂亚”用了伪声器的可能呢？毕竟以前所有使用AI追查系统的目标都相当的“配合”——至少不会蓄意捣乱。宪贞将那段录音先用逆伪声器还原，又轻车熟路地拖到了追查系统的输入框里，按下了enter键。此时，屏幕上出现了结果。</p><p>一张宪贞熟悉得不能再熟悉的面孔出现在了屏幕上。从某种意义上来说，“显示这张照片”就是这套AI追查系统在宪贞大学时被写出来时的终极意义——没错，那就是宪贞日思夜想了十几年的那个她。</p><p>宪贞的心脏漏跳了一派，瞬间感觉四肢冰冷，呼吸加速，有无数鲜血涌上大脑。尽管他在梦中见到过无数次这个画面，但是要说在现实中突然冷不丁地出现，他并没有做好心理准备。正当他准备开心地大喊时，他注意到了图片右下角的匹配度：只有12%。</p><p>12%的匹配度，系统认为“福蒂亚”有88%的可能性并不是宪贞曾经的女友。但是，系统并没有给出匹配度更高的人选。这代表着，在全国以及世界上共享了数据库的国家的范围内，AI追查系统还是没有找出“福蒂亚”的真身。同时，系统提示：“福蒂亚”，这名据推断为19岁零五个月正负两个月的少女，有46%的可能性是她的妹妹，另有41%的可能性是她的女儿，剩下的1%则是其它从数学上可以忽略的可能。</p><p>她有妹妹吗？宪贞可以肯定地回答，没有。不仅仅是在恋爱中的交谈得知，系统中也没有关于她的妹妹的任何信息。那可能是她失踪后才出生的妹妹，而且基于各种各样的原因没有登记呢？宪贞也迅速排除了这个可能。首先不去登记在这个时代以及是相当困难是事情了，基本等同于黑户，没有身份信息也很难登录游戏；其次，即使这位妹妹是宪贞车祸当天出生的，到现在也不过十八岁三个月零五天，和AI推断的年龄并不相符。那么是女儿吗？呃......宪贞打心眼里不愿意去想象这个可能性。但是依旧是年龄对不上。</p><p>排除了AI给出的两个最有可能的情况，似乎又陷入了死胡同。但一个巨大的进展已经出现了，那就是“福蒂亚”肯定和她有说不清道不明的关系。</p><p>宪贞仔细咂摸着“19岁零五个月”这个年龄，他的脑中莫名有一道光出现。这道光接管了宪贞身体的控制权，操纵着宪贞的手，在AI追查系统的“生理信息预测”功能上点了一下“×”。这个功能本来是宪贞的得意之作，是他付出了无数精力和心血的最终结晶。而如果关闭了这个功能，也就意味着系统将暂时失去按时间流逝推演的能力。接着，这道光继续操纵着宪贞的手按下了“查询”。</p><p>两分钟后，结果出现了。</p><p>屏幕上还是那个女孩，不过这时，右下角的匹配度变成了99.99%。当然，还有一个黄色的警告符号，指示着生理信息预测功能未在运行。</p><p>看到这个结果，宪贞反而像是释然了一般，长出一口气，坐回了椅子里。这个结果意味着什么呢？显然，它意味着十八年前的，宪贞的初恋女友，不知道是经过时空旅行还是怎样，突然出现在了现在这个世界，她现在也在玩《圆神》，用户名是“福蒂亚”。</p><p>十八年的追寻终于有了结果，但是却又带来了一系列问题，其中最大的问题就是：时间旅行并不可能实现，这是常识中的常识。</p><p>宪贞觉得自己的脑子快要被这两个女人的失踪案搅和成一团乱麻了。首先是星奈花的失踪案，然后是自己十八年前的女友的失而复得案，两个事件都疑点重重。星奈花的神秘伤痕，社交圈子的变动，“圆神”，以及“圆神”中“福蒂亚”——也就是宪贞十八年前人间蒸发的女友。有一句话说得好，你手里攥着千头万绪，工作是千头万绪，攥着一千个线头，但是一次针眼只能穿过一条线。宪贞决定还是从自己的女友入手比较好，说没有私心的成分是不可能的，而且他感觉，自己和（前？）女友打交道，应该也比较熟练。那就下班回到家以后继续玩玩《圆神》吧，应该还能在游戏里见到她。</p><p>宪贞刚回到家，屁股还没坐到沙发上，电话突然响了。一边祈祷着不是新的警情通报，宪贞一边拿起了电话。是一个外国号码，不知道是哪个国家的，看着像是什么南太平洋岛国，和电话一起来的还有反诈骗中心的警告短信。作为一名警察，逗逗骗子扮猪吃老虎也算是乐趣之一，于是宪贞接起了电话。</p><p>“喂，你是宪贞吧，我是福蒂亚。按我对你的了解，你现在大概知道我是谁了吧，要是知道了就来咖啡厅见一面，偶哇！”</p><p>怎么说呢，还是熟悉的热情似火。当然，宪贞也是很乐意见上一见的，不如说是非常想见一面的。于是宪贞直接让AI管家预订了出租车，一边快步往小区大门跑去，当然，职业带来的潜意识让宪贞没有忘记带上一个纽扣录像机。</p><p>【未完】</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科幻</tag>
      
      <tag>同人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220801-20220807）</title>
    <link href="/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220801-20220807%EF%BC%89/"/>
    <url>/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220801-20220807%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220801</h2><p>建军节，补记的，忘了。</p><h2 id="section-1">20220802</h2><p>今天去户县练了一天车，明天考科目三。</p><h2 id="section-2">20220803</h2><p>考个科目三真尼玛一波三折，早上去了先是没车，等到中午再去，然后又让等着。第一圈的时候开到一半下了场暴雨，安全员给踩了，又等了好久，第二圈才过，等回到家就九点了。</p><p>另：今天是我的生日，但年度总结咕了，过两天补。</p><h2 id="section-3">20220804</h2><p>今天复习（预习）科目四。</p><h2 id="section-4">20220805</h2><p>今天考过了科目四，但是那地方的打印机坏了，让我写个地址把证邮寄过去。下午见了一个同学，一起逛了西工大地铁站、大唐西市和高新区。不得不说北航输麻了。</p><h2 id="section-5">20220806</h2><p>今天看了一天大秦帝国。</p><h2 id="section-6">20220807</h2><p>今天早上去练车，中文吃水盆羊肉，下午睡觉。</p><p>水盆羊肉好吃，带的烧饼更好吃，有股面香味，鉴定为彳亍。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高中记忆拾贝</title>
    <link href="/2022/07/26/%E9%AB%98%E4%B8%AD%E8%AE%B0%E5%BF%86%E6%8B%BE%E8%B4%9D/"/>
    <url>/2022/07/26/%E9%AB%98%E4%B8%AD%E8%AE%B0%E5%BF%86%E6%8B%BE%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>转载自个人公众号。</p><span id="more"></span><h2 id="高三">高三</h2><p>说起高考，我对高考，或者“高三”的记忆是什么呢？两年过去了，如果让我说起我对高三的TOP印象（不分顺序），可能会有如下几个场景：</p><ol type="1"><li><p>第一节晚自习下课，和基友一起在操场散步，谈论二次元。他给我口述动画片，不得不说确实挺好看。操场上灯光并不是很亮，我俩就看着像月亮一样的灯光绕着走圈圈。后来我给他送了这个动画片的原作。</p></li><li><p>高三唯一一次哭，是因为理化生三科改理综以后我突然之间就获得了很大很大的优势（因为我自己写字比较快，能答完。好多大佬不会安排时间，第一次没答完题）。然后理综练得越来越多，大家越来越熟练，我的优势突然之间就没有那么大了，就突然慌了，然后当时杂乱的事情又比较多，就一下子就崩溃了，不过好得也很快。后来一看，这算啥事儿啊2333.</p></li><li><p>模考不想去了，直接给老师发个短信说不想去了，然后和父母看电影，散步，逛公园。爽。</p></li><li><p>每次模考完了以后，成绩当晚就出了。老师就拿着那张排名单往教室后面一贴，大家都怀着忐忑的心情一拥而上。</p></li><li><p>五楼考场，阳光明媚，闭着眼睛吹风，很舒服。不过我每次在五楼都发挥得不是很好，不知道为啥。</p></li><li><p>5月12日，放假。我写了一张大表安排时间，把座位搬到了落地窗前，“悠然见南山”，真的是终南山噢！然后严格按照这张大表复习，效果真的特别特别好。爸爸的厨艺在这一个月也增长很多。非常快乐，非常好。</p></li><li><p>和同桌一起体育课在操场打羽毛球。我们每次体育课都打球，其他人好多都拿个小本本在卷，不过他们都卷不过我俩 哈哈哈哈。</p></li></ol><p>啊，想不起来，就这些吧。我曾经问过我那个基友和那个同桌“你觉得高三生活是‘地狱’吗？”，他们都斩钉截铁地回答，不是。没有什么拼搏的汗水，没有什么崩溃的泪水，没有动员会上的热泪盈眶，没有什么地狱般的生活，普普通通地过完了，拿到了自己最期望的高考成绩，不多不低。网上人说的那些，纪录片、电视剧里说的那些东西一个都没出现。没什么实感就结束了。</p><p>整个高三一年，我根本没有什么“熬夜学习到凌晨两三点”，“拼命学习”，“刷完了多少本题”，“追着老师问问题”，“用完了多少笔芯”之类的“拼搏”的经历;也没有做到“杜绝一切娱乐”,基本上每天都能玩到手机（家长不太管），我高三甚至看完了一套凉宫春日小说，补了三四部番，还听了很多音乐（主要是东方吧）。甚至在6月6日晚上，我也是照常看了2集动画片（我还记得，是少女歌剧）然后平常地睡觉了。总之，整个高三，我就是平平常常的，老师说什么，我就干什么，基本上就是完成作业，额外做的题特别少。学校要求6：50到校，我基本6：45到；23：30放学我基本上不会拖超过5分钟。</p><p>太平淡了，啥也没有，就这样结束了。</p><p>所以我才会关注高考新闻，想凭吊一下青春吧，哈哈哈哈。</p><h2 id="高一高二">高一高二</h2><p>上次写了高三，这次就来写写我的高一和高二。说实话，高一和高二的生活，真的比高三有意思很多。如果要找“ Gauss 节点”的话，大概有这么几个节点：</p><ol type="1"><li><p>高一的朗诵比赛，我们选的是《长恨歌》，不得不说效果是真的非常非常好啊，尤其是那位女同学“迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共？”的时候，真的，都差点哭出来了。虽然最后得的奖不是很高（现在想起来也有点生气，made),但是算是高中三年生活的一个很好的开始吧。</p></li><li><p>然后就开始学电竞，刷OJ。之所以学电竞是被朋友撺掇的，当时电脑课老师问有没有学电竞的，他先举手，然后又把我的手举起来了，于是就开始学电竞。我高中三年最正确的选择之一，居然是别人替我作出的，哈哈哈哈。</p></li><li><p>第一次月考，考完运动会。班主任是位生物老师，她把我拉去帮忙改卷子了。之后我的生物一直学得非常好，或许应该好好感谢她。</p></li><li><p>电竞上课要上到很晚，有一次我们练习完了以后，整个教学楼全黑了，好几扇门也锁起来了。我们转了几圈终于出去了，哈哈大笑。</p></li><li><p>我的经历就是到了这个高一结束，竞赛课内两开花，成绩都挺好。然后班主任就把我调到竞赛班去了。我说另请高明吧，我实在我也不是谦虚，她说别的老师已经把你夸上天了，我就念了两句诗，叫：“...”（其实没念）。我实在是不觉得这个竞赛班是个好东西，一开始我们开了个班会，常务副校长同志语出惊人：“你们难道来高新一中就是为了上个西交吗？”，一下子给我整麻了。后来发现这竞赛班tm真不是人待的地方，整个物理“动量”部分就讲了十分钟，然后就发一堆难度巨大的题让做，我哪里会做，然后就啥也没学会。期中考试考了个全年级四百多名，洗澡的时候在浴室哭了一场，”心之壁“ DEF+5000。然后就爬回了一个“重点班”（高新一中有三级班：平行班、重点班、竞赛班）。于是我就刷到了一个成就：在高一一年，遍历高新一中的所有级别班次，听过所有理科老师的课程。</p></li><li><p>竞赛班没有作业，也不学文科。但是到了重点班突然要考文科，我直接发动【高速制作】，期末的文科三科考了285分，超高吧，嘻嘻。</p></li><li><p>高二我就来到了四班，其实我还是很喜欢四班的，在这里认识了几个好朋友。不过我的高二生活的前半段主要是在学竞赛，就在那个三楼的《网络实验室》里，做题，刷题，讲题，中午就听音乐，直到很晚才回家。第一次吃了学校的晚饭，挺难吃的。假期上课的时候就和同学们一起过马路吃肉夹馍。这段时光确实非常的快乐，肆意吮吸知识的感觉，非常非常的爽。也认识了好朋友，直到现在都是好朋友。但是做题就是另一回事儿了哈哈哈哈哈。看了珂朵莉，很好看。</p></li><li><p>高二暑假的时候非常非常的热。那时候有个梗图，说西安地表温度65度，吐鲁番63度。每天下午，我们要从高新一中走到初中部去上课，哈哈哈。</p></li><li><p>2017年11月11日，我永远记得。D1T1当场把我送走。当天中午心态基本就崩溃了。D2发挥的比D1好，但是也无济于事。然后就心态很崩嘛，当时刚好看完了珂朵莉，那心情，哎，你懂吧又哭了几场。也很感谢家长，和竞赛的队友，和班里的同学能及时把我拉起来，”心之壁“DEF +10000.</p><p>然后七天以后就是期中考试，理所应当地考了倒数。不过值得吹一下的是，生物还是仅仅用学过了的知识依然拿到了全班前十。</p></li><li><p>凉宫春日是我永远的光。我永远爱凉宫春日。没有凉宫春日就没有现在的我。虽然主要还是我自己努力的原因，如果说父母同学输入的是活化能，那么她就是大大降低了活化能的催化剂。一个月学完一个学期所有科目，从倒数第一拿到全班前十，奇迹的复活！</p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207262350119.jpeg" alt="奇迹の复活" /><figcaption aria-hidden="true">奇迹の复活</figcaption></figure><ol start="11" type="1"><li><p>高二下的一开始就是学考。学考组织了四次模拟，如果政史地理化生中任意一个科目考的分不是很高，就要《补习》。但是我一次都没《补习》。甚至历史还进入过全校前十，整得文科班老师对着他们班大发雷霆：你们就连个理科生都考不过吗？</p></li><li><p>高一高二的时候我们组织了研学旅行，分别是去了关中民俗博物院、白鹿原、华清池，一个我忘了名字的红色景点，和一个我忘了名字的山水景点等，还是很快乐的。</p></li><li><p>有一天早上起来发现下了大雪，学校停课了，于是直接去看了《星球大战》的电影。</p></li><li><p>暑假，入坑了东方。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220725-20220731）</title>
    <link href="/2022/07/26/%E5%91%A8%E8%AE%B0%EF%BC%8820220725-20220731%EF%BC%89/"/>
    <url>/2022/07/26/%E5%91%A8%E8%AE%B0%EF%BC%8820220725-20220731%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220725</h2><p>今天没做什么事，打游戏，看书，写代码，读论文等。</p><h2 id="section-1">20220726</h2><p>今天开了个组会，我竟然还“进度挺快”，震撼。</p><p>北航地方，历代大规模开学几十余次，是非曲折难以论说，但史家无不注意到，正是在这个大学，决定了多少代人生的盛衰兴亡、此兴彼落。</p><p>二〇二〇年十月，也正是在北航城郊，我有幸亲率数十健儿前去天津游玩，大获全胜！</p><p>我不明白，为什么大家都在谈论着“申请出校”，仿佛这大学对我们决定了凶多吉少。二〇一九年，我从西安踏上征途，开始了大学生活，老师学长竭诚欢迎，真可谓占尽天时，那种勃勃生机、万物竟发的境界，犹在眼前。短短三年之后，这里竟至于一变而成为我们的葬身之地了么？</p><h2 id="section-2">20220727</h2><p>今天玩了一天，一点也没学习。</p><h2 id="section-3">20220728</h2><p>今天终于开始动笔写我的小说了（）先完善一下大纲，预计下周起在本站上连载，不知道能写多少。</p><h2 id="section-4">20220729</h2><p>今天继续打游戏，看书，写小说大纲</p><h2 id="section-5">20220730</h2><p>今天去看了一个浮世绘画展，还挺不错的。曲江创意谷也不错。</p><p>今天晚上吃了烤肉。</p><h2 id="section-6">20220731</h2><p>今天下午停电了，去电影院避暑，看了《独行月球》，还不错，能打75/100分。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220718-20220724）</title>
    <link href="/2022/07/19/%E5%91%A8%E8%AE%B0%EF%BC%8820220718-20220724%EF%BC%89/"/>
    <url>/2022/07/19/%E5%91%A8%E8%AE%B0%EF%BC%8820220718-20220724%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220718</h2><p>今天朋友来家里玩了，晚上去昆明池看了看夜景，可惜有点下雨。</p><p>今天看了规则网络上的博弈，还读懂了代码。明天复现一下。</p><p>今天是京阿尼纵火事件三周年。</p><blockquote><p>夢を、育てます（培育梦想）</p><p>夢を、描きます（描绘梦想）</p><p>夢を、届けたい（想要传递梦想）</p><p>発想する会社。</p></blockquote><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207191023641.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section-1">20220719</h2><p>今天主要是写了一下规则网络PDG的代码，玩了一下原神新活动，感觉还是挺好玩的。</p><h2 id="section-2">20220720</h2><p>无语，今天扁桃体发炎了，去医院打了一晚上吊针，难顶</p><h2 id="section-3">20220721</h2><p>今天跑了一下和自己博弈的PDG，以及改成了雪堆博弈的。</p><p>今天玩了猫猫模拟器，还挺好玩的。</p><p>今天读了《故事》，</p><h2 id="section-4">20220722</h2><p>今天白天下了一天雨，下午天晴了，去昆明池了。今天的昆明池还是非常好看的，能见度非常高，而且还有很多喵喵。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242157635.jpg" alt="云销雨霁，彩彻区明" /><figcaption aria-hidden="true">云销雨霁，彩彻区明</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242157514.jpg" alt="潦水尽而寒潭清,烟光凝而暮山紫" /><figcaption aria-hidden="true">潦水尽而寒潭清,烟光凝而暮山紫</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242158212.jpg" alt="喵呜" /><figcaption aria-hidden="true">喵呜</figcaption></figure><h2 id="section-5">20220723</h2><p>今天把带Q-learning的规则网络PDG跑通了，效果比较理想</p><p>晚上去沣河大桥了。</p><h2 id="section-6">20220724</h2><p>今天玩了好多游戏，看了好多动画，还看了火箭发射。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人看过的各动画锐评：二</title>
    <link href="/2022/07/17/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84%EF%BC%9A%E4%BA%8C/"/>
    <url>/2022/07/17/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84%EF%BC%9A%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本文记录我看过的各动画作品，不一定全，也不一定看完了，电影动画都有。然后可能会进行个人主观感受相当强烈的《锐评》。在评价中，个人的情绪、心理、主观观感有相当大的比重，评价也很短，很随性。所以如果和你心目中的差距比较大不要喷哈。</p><p>如果真的要写长评或者认真去评价我会写单独的文章，这个就看一乐。</p><p>第一部分合集：<a href="https://blog.sakizuki.site/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/">本人看过的各动画锐评：一</a></p><span id="more"></span><p>简要评分标准如下：</p><table><thead><tr class="header"><th>评分</th><th>标准</th></tr></thead><tbody><tr class="odd"><td>95+</td><td>【极优】非常优秀的作品，让我印象深刻</td></tr><tr class="even"><td>85+</td><td>【优】各方面都很优秀的作品，或有非常打动我的长处</td></tr><tr class="odd"><td>75+</td><td>【良】良好的作品，我心中的“平均水平”</td></tr><tr class="even"><td>60+</td><td>【合格】合格的作品，没有什么亮点</td></tr><tr class="odd"><td>60-</td><td>【不合格】有明显短板的作品，不堪卒读</td></tr></tbody></table><p>当然上面的“平均水平”的意思是全部动画的平均水平，而不是我看过的平均水平。我尽量把平均分控制在85分左右。</p><h2 id="凉宫春日的消失100">凉宫春日的消失：100</h2><figure><img src="https://lain.bgm.tv/pic/cover/l/9b/9b/3375_33BCV.jpg" alt="凉宫春日的消失" /><figcaption aria-hidden="true">凉宫春日的消失</figcaption></figure><p>个人评分：100</p><p>关键字：穿越、科幻、京阿尼</p><p>锐评：我在前一篇里面说《叛逆的物语》是我第二喜欢的动画电影，那么《凉宫春日的消失》就是我最喜欢的动画电影。自从我第一次看完这部电影以后，每年的12月18日，我都多了一项固定的活动：观看《凉宫春日的消失》。这部作品对我的影响非常大，甚至于塑造了我近年来的三观。</p><p>《凉宫春日》对我来说，很可能就是我热爱动画的意义所在。</p><blockquote><p>要到几岁才开始不相信圣诞老人的存在，这种无聊到家的话题对我来说根本不痛不痒的，不过，如果说到我是几岁开始不相信圣诞老人，那个只存在于幻想世界的穿着红衣服的老公公的存在，我能很确定的说，我根本打从一开始就不相信，我知道幼儿园圣诞节庆祝会时出现的圣诞老人是假的，即使没有撞见老妈正在亲吻圣诞老人，机灵的我也早就怀疑只在圣诞节才工作的老头子是否真的存在了，不过，那些外星人、未来人、幽灵、妖怪、超能力者，还有邪恶组织以及和他们战斗的动画特摄漫画英雄，我发现他们根本不存在于这个世界的时候已经很晚了，不，说不定我早就发现了，只不过一直不想承认而已，因为我的内心深处是十分渴望那些外星人、未来人、幽灵、妖怪、超能力者，还有邪恶组织能够出现在眼前的，不过，现实却是意外地残酷，于是我开始常常惊叹世界的物理法则是多么正确，不知何时开始我就不再热心地观看电视上的UFO特别节目或灵异节目了，宇宙人？未来人？超能力者？这种东西怎么可能存在嘛，不过还是希望他们存在啊...我就像是参考着真实与幻想之间的最大公约数般渐渐地长大了，初中毕业之后，我也从这种小孩子的幻想中毕业了，逐渐习惯了这个世界的平凡，我就这样没啥感慨地成为了高中生——然后遇到了那家伙.....</p></blockquote><p>要到几岁才开始不相信圣诞老人的存在，我能很确定地说，我根本打从一开始就不相信。我们每个人小时候总是充满着各种各样的幻想，甚至是一小段枯燥的文字也能唤起我们无限的遐想，看着一个普普通通的飞机模型，就可以想象这架飞机是怎么遨游在蓝天上的，看着泡澡时泡沫在水中出现又消失，脑中已经在想象一个历经千年波澜壮阔的“泡沐帝国”的兴衰荣辱了，更不要提把三角板夹到笔夹上当战斗机这种事情了。可是当我们长大后，在周围各种各样人无数次地提醒下，我们会不再相信那些不存在的幻想，而只会去关心诸如一日三餐这种一成不变而又真实存在的日常琐事，只因为我们被告知现实就是现实，渐渐地我们开始变得麻木，开始变得循规蹈矩，开始变得安于现状。我们被人无数次地提醒着，现实就是现实，梦想就是梦想。一个人还没找齐的小小社团说自己要进军全国第一，这是梦想；一个小小城市里的普通初中生说自己要上清华北大，这是梦想；都上中学了，也该有点对现实的自觉了吧？</p><p>而凉宫春日则不这样，她不在意什么现实，而只是跟着那些虚无的想法前进。当然，这样的人在现实世界中几乎看不到，那么我们不妨把它当作作者的“理想模型”。而回首人类历史时，我们不难发现，正是“幻想”，正是“虚无的想法”，推动了人类文明的进程。人类的历史就是幻想的历史，人类的历史正是由一个一个的“团长”们写就的。</p><p>一个在地上生活了几万年的物种，突然说自己要飞上蓝天，在二百多年前，这还是十足的幻想。但是现在呢？人类不仅飞上了蓝天，还登上了月球，人类的双手的延申、人类的眼耳的延申，人类的思想的延申，已经到达了冥王星轨道，甚至已经越过了太阳系，向着更远处的星空前进。这，还是幻想吗？</p><p>自古以来只有大雨天才会降下的白色神罚，在三百多年前，这还是十足的幻想。但是现在呢？这天下降下的神罚已经走进了每一家每一户的角落，我能写下这篇文字，也要拜这小小的电流所赐。这，还是幻想吗？</p><p>过直线外一点至少有两条直线与之平行，在四百多年前，这当然是异想天开，是十足的幻想。可是非欧几何成了相对论的基础，现如今所有的定位卫星离了相对论都无法工作。这，还是幻想吗？</p><p>决定人类行动的是情感，推动时代前进的呢？正是那些满怀梦想，充满激情，大胆想象的狂人亦或是疯子们一次一次地用超乎寻常的想象力改变了我们习以为常的世界。而动画艺术，对我而言就象征着想象力，一切都没有限制，在一个个奇妙有趣的异世界中，我们流泪欢笑，一切都是那么地富有激情和浪漫色彩。这也正是我热爱动画艺术的原因。</p><blockquote><p>Day by day うんざりだよね だから</p><p>Day by Day 生活是如此腻味</p><p>堂々と断っちゃう 君になりなよ</p><p>你该堂堂正正拒绝 随心所欲地活着</p></blockquote><p>说完了《凉宫春日》的精神，该说说《凉宫春日的消失》这部电影本身了。这是一部堪称完美的剧场版动画。接近3个小时的片长，绝佳的制作水平（甚至为了体现人物的心理活动，在多处制作了细致的人物表情。而表现手法也深入人心，我印象最深的一段是：阿虚问三味线，你能听懂我说话吗？能就伸右手，不能就伸左手，而三味线的回答则是打了个滚。一段生活中的小小片段，就把世界和阿虚断绝关系的疏远感和无助感体现得淋漓尽致。他心中的疑问，只能被这冰冷世界的表面所反射，少年想做的事情并非是这个世界需要他做的事情，他能听到的并非世界的呼唤，而是自己的发问在这庞大世界中空洞的回音。而原作中大段的心理描写，在电影中则以意识流来处理，而这一段，以标志性的“阿虚踩自己”为代表，也堪称影史经典了，多说无益，自己去看看吧！配乐采用了钢琴曲为主的配乐，即使直接把OST拿出来也很好听。这部电影是没有短板，堪称完美的六边形战士，是《凉宫春日》系列动画中最浓墨重彩的一笔。</p><h2 id="颠倒的帕特玛73">颠倒的帕特玛：73</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207180050015.jpeg" alt="颠倒的帕特玛" /><figcaption aria-hidden="true">颠倒的帕特玛</figcaption></figure><p>个人评分：73</p><p>关键字：科幻，反乌托邦，爱情，世界观</p><p>锐评：一部很可惜的作品。世界观和设定是很亮眼的，可惜用了这么个世界观讲了一个观感一般的故事，感情线也有点粗糙，颇有高汤煮泡面的感觉。</p><h2 id="普罗米亚85">普罗米亚：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207180053299.jpeg" /></p><p>个人评分：85</p><p>关键字：作画，奇幻，燃</p><p>锐评：底子是一个很王道的故事，但是这么一个王道的故事做出来的整体质量很不错。就像是我来朗读《滕王阁序》和人家朗诵家来朗读《滕王阁序》一样，底子是一样的，但是观感就是有区别。情节安排方面，很紧凑，没什么尿点。而艺术风格就非常亮眼了，非常有扳机社风格，大色块，三角形。一言以蔽之：曰：燃得批爆，值得一爽。</p><h2 id="秒速五厘米80">秒速五厘米：80</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242234613.jpeg" /></p><p>个人评分：82</p><p>关键字：恋爱、新海诚、小品</p><p>锐评：挺好看的一个小片子，就是看着也太着急了，急死我了。不知道为什么，第一个故事给我的感触是最深，最有代入感的，但是我明明没有经历过这样的事情，怎么回事呢？可能只是因为我在雪中坐过公交车？搞不明白了，哈哈。</p><h2 id="朝花夕誓于离别之朝束起约定之花83">朝花夕誓——于离别之朝束起约定之花：83</h2><p><img src="https://lain.bgm.tv/pic/cover/l/0e/1e/218971_PC00Z.jpg" /></p><p>个人评分：83</p><p>关键字：亲情、奇幻、治愈、温柔</p><p>个人锐评：一部很温柔的电影。画面精良，镜头也没什么大差错。整个电影就给人一种娓娓道来的，温柔平和的感觉，人物情感丰富，设定引人入胜，鉴定为好。</p><h2 id="福音战士新剧场版序85">福音战士新剧场版：序：85</h2><p><img src="https://lain.bgm.tv/pic/cover/l/e5/7c/772_yFW6i.jpg" /></p><p>个人评分：85</p><p>关键字：高清重制、EVA、科幻、萝卜</p><p>锐评：就是高清重制版，画质和节奏都比TV好不少，鉴定为彳亍。美术风格就是完全的痞子风辣。</p><h2 id="福音战士新剧场版破90">福音战士新剧场版：破：90</h2><p><img src="https://lain.bgm.tv/pic/cover/l/6f/ab/3302_rEfZV.jpg" /></p><p>个人评分：90</p><p>关键字：EVA、科幻、萝卜</p><p>锐评：从这部开始就不是高清重制版了，对剧情走向有比较大的改动。整体基调比TV积极（......），两段的配乐还是很震撼人心的，虽然不知道为什么，可能这就是艺术吧。</p><h2 id="福音战士新剧场版q52">福音战士新剧场版：Q：52</h2><p><img src="https://lain.bgm.tv/pic/cover/l/a6/bb/22505_O197k.jpg" /></p><p>个人评分：52</p><p>关键字：EVA、科幻、萝卜</p><p>锐评：垃圾得一批，没看终之前还以为看不懂是我的问题，看了终以后才知道就是这作品的问题。故事云里雾里，人员全员谜语，叙事完全失败。等于只有画面和配乐能给点分了。这人设我还不太喜欢，我的第一部不及格献给这部作品。</p><h2 id="福音战士新剧场版终90">福音战士新剧场版：终：90</h2><p><img src="https://lain.bgm.tv/pic/cover/l/04/dc/29883_jQ4Hz.jpg" /></p><p>个人评分：90</p><p>关键字：EVA、科幻、萝卜、告别</p><p>锐评：一部非常好的告别作。虽然看完以后还有很多谜团没有解开，不过也不需要在意了，就是这样的感觉。剧里剧外的人都补完了，再见了，所有的EVA。</p><h2 id="平家物语82">平家物语：82</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208271617155.jpeg" alt="平家物語 平家物语" /><figcaption aria-hidden="true">平家物語 平家物语</figcaption></figure><p>个人评分：82</p><p>关键字：历史，山田尚子，温柔</p><p>锐评：这部动画原创了一个叫做“琵琶”的人物作为主视角，时间流转，她却不会老去。琵琶的眼睛能预知未来，我们也早已知晓了平家的未来，琵琶似乎是观众的化身。这个创意还是很有意思的。整体观感，怎么说呢，就像用红楼梦的打开方式看三国演义。本片艺术风格采取了和版画、浮世绘风格类似的画风，很有特点；细节安排丰富，美术引人入胜，镜头也比较有实验性。但本片信息量实在太大，对于不具备相关历史知识的人而言看起来有些费劲；且本片对“悲剧”的刻画似乎并不完美，在很多地方用喜剧化的演出来表现悲剧，有些煞风景。总而言之，是一部佳作，希望山田尚子再接再厉（</p><p>最后提醒大家：坚持辩证唯物主义，不要发毒誓，神仙收命不办事，说的就是你，平重盛</p><h2 id="龙与雀斑公主73">龙与雀斑公主：73</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209050015658.jpeg" alt="竜とそばかすの姫 龙与雀斑公主" /><figcaption aria-hidden="true">竜とそばかすの姫 龙与雀斑公主</figcaption></figure><p>个人评分：73</p><p>关键字：音乐、vtb</p><p>锐评：这个电影，在电影院和不在电影院看，完全是两种体验。为什么呢？因为它的音乐很好听但是剧情太拉跨。人物太多，有些人物不知道出现的意义是什么；内容太多，看得出来想讲很多东西，但是东一榔头西一棒槌，一个也没讲深入。不过至少故事比泡泡好，哈哈。而且女主和她爸那个亲情线还挺温馨的。另外，我觉得女主本身比她在U世界里面那个皮好看。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220711-20220717）</title>
    <link href="/2022/07/11/%E5%91%A8%E8%AE%B0%EF%BC%8820220711-20220717%EF%BC%89/"/>
    <url>/2022/07/11/%E5%91%A8%E8%AE%B0%EF%BC%8820220711-20220717%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><h2 id="section">20220711</h2><p>今天和同学去吃了个自助烤肉，然后去参观了一下高新一中遗址。哎！时过境迁，人是物非啊！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207112306073.png" alt="image-20220711230530007" /><figcaption aria-hidden="true">image-20220711230530007</figcaption></figure><blockquote><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。</p><p>阁中帝子今何在？槛外长江空自流！</p></blockquote><p>回家的时候坐了个双层巴士，看着走了三年还是六年的回家路，回忆涌上心头。当年我也就是在这条路上和初中同学一起背政治历史的，也是在这条路上和高中同学一起玩玩闹闹的，高三也是六点多的时候从这条路上上学，晚上十一点从这条路上回家的。哎，怎么就搬家了呢，我是真不想搬家，那里才是我心中永远的家。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207112230010.png" alt="永远滴家" /><figcaption aria-hidden="true">永远滴家</figcaption></figure><p>朋友们明天就要来西安了，后天就能去玩了，开心。</p><p>今天还看了两集十二国记。</p><h2 id="section-1">20220712</h2><p>今天学了《网络科学导论》的前两章和第三章的一部分，小写了点代码。</p><h2 id="section-2">20220713</h2><p>今天早上逛了钟楼</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132319209.jpg" alt="小雨，钟楼，南大街" /><figcaption aria-hidden="true">小雨，钟楼，南大街</figcaption></figure><p>其实我自己也好久没上钟楼了，今天和朋友们一起上。我记得以前钟楼还能敲呢，现在也不给敲了</p><p>然后去了易俗社，转了个博物馆，喝了个茶话弄</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132320896.jpg" alt="四人，秦腔，茶话弄" /><figcaption aria-hidden="true">四人，秦腔，茶话弄</figcaption></figure><p>下午先去了碑林</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132321332.jpg" alt="碑林，石刻，唐玄宗" /><figcaption aria-hidden="true">碑林，石刻，唐玄宗</figcaption></figure><p>说实在的，我是西安人，我也没去过碑林。今天是我第一次去碑林，请了一位讲解员，确实收获不少知识。比如说书法的演变啊，包括异体字之类的，还挺有趣的。</p><p>碑林出来以后就是书院门</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132322185.jpg" alt="古玩，字画，书院门" /><figcaption aria-hidden="true">古玩，字画，书院门</figcaption></figure><p>书院门就是一条卖古玩字画的街，古色古香的，很有文化气息。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132323619.jpg" alt="暗巷，精裱，路边摊" /><figcaption aria-hidden="true">暗巷，精裱，路边摊</figcaption></figure><p>晚上上了城墙。以前都是在元宵节看灯会上城墙的，很热闹；而今天城墙上没有多少人，很静谧，也挺舒服的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132325782.jpg" alt="静谧，古城，红灯笼" /><figcaption aria-hidden="true">静谧，古城，红灯笼</figcaption></figure><p>城墙根底下有好多小众文艺范儿的酒吧，还有人唱歌，我在城墙上面的人也跟着沾光，不错。</p><h2 id="section-3">20220714</h2><p>今天的行程是：早上去小雁塔和西安博物院，中午吃长安大排档，下午转一转高新区</p><p>西安博物院的玻璃展览，展出了很多欧洲国家古代的玻璃。很惊讶两千年前的玻璃竟然已经能做出透明的效果的，我想如果中国古代也有这样的透明玻璃，化学会不会有更好的发展呢？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162252034.jpg" alt="千年前的欧洲玻璃瓶子" /><figcaption aria-hidden="true">千年前的欧洲玻璃瓶子</figcaption></figure><p>这是小雁塔公园。以前都是逛庙会的时候来，现在没多少人，园子里郁郁葱葱，也有一种别样的美感。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162254088.jpg" alt="小雁塔" /><figcaption aria-hidden="true">小雁塔</figcaption></figure><p>中午去吃了长安大排档。这个算是一个网红店，但是出品还算不错。我们点了一个葫芦鸡，一个口蘑炒牛肉，一个孜然牛肉。葫芦鸡的肉比较软烂，它的一个特色是蘸料有一个橘子辣酱，比较有新意，而且这个橘子辣酱还是比较好吃。口蘑炒牛肉是一个咸鲜的口，孜然牛肉孜然味儿不多，而且有点辣。总的来说还算不错。<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162257951.jpg" alt="葫芦鸡" /></p><p>下午先从小寨去大兴善寺。大兴善寺的安静和小寨的喧闹形成了鲜明的对比，很有意思。大兴善寺里面有很多乌龟，和猫猫。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162303684.jpg" alt="大兴善寺的猫猫" /><figcaption aria-hidden="true">大兴善寺的猫猫</figcaption></figure><p>最后去高新区逛了逛，到这个咖啡街区喝了个瑞幸咖啡。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162305086.jpg" alt="瑞幸" /><figcaption aria-hidden="true">瑞幸</figcaption></figure><p>这天晚上和同学重温了来自深渊，真好看</p><h2 id="section-4">20220715</h2><p>今天早上去了陕西省博物馆。这次最震撼我的是这个兽头人身俑。只能说古代人玩挺大。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162308762.jpg" alt="省博" /><figcaption aria-hidden="true">省博</figcaption></figure><p>中午吃了张记，一如既往的好吃。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162311442.jpg" alt="张记" /><figcaption aria-hidden="true">张记</figcaption></figure><p>下午去了大雁塔，还爬了大雁塔，累的要死。爬完以后说，本来还想着明天爬骊山，我看拉倒吧</p><p>爬完塔以后吃了个陕十三，就是个冰激淋店</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162313574.jpg" alt="陕十三" /><figcaption aria-hidden="true">陕十三</figcaption></figure><p>去了西安美术馆，看同学许的有趣愿望</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162313673.jpg" alt="什么凉宫春日" /><figcaption aria-hidden="true">什么凉宫春日</figcaption></figure><p>晚上听了音乐会</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162314969.jpg" alt="音乐会" /><figcaption aria-hidden="true">音乐会</figcaption></figure><h2 id="section-5">20220716</h2><p>今天去了兵马俑，我是西安人，今天还是第一次去兵马俑。去的时候下了雨，骊山笼罩在云雾之中，还挺好看的，不过就是爬不成了。上次来骊山是高中研学旅行的时候，就没成功爬上去，这次还是没爬，可惜。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162317658.jpg" alt="兵马俑" /><figcaption aria-hidden="true">兵马俑</figcaption></figure><p>兵马俑还算是很震撼的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162318776.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>中午在景区吃了个biangbiang面，一般，醋放太多了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162318398.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>晚上去洒金桥转了转，愉快的西安之旅到此就告一段落了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162319003.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section-6">20220717</h2><p>今天坐公交车回家了，下午玩了玩原神，晚上和高中打竞赛的几个同学出去吃饭。吃完饭以后看到一个彩票机，一个同学买了一张，没中，我寻思着我也买一张，结果就中了60，笑死我了，人生买第一次彩票就中了。什么嘛，我还挺能买的嘛。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈什么是二次元</title>
    <link href="/2022/07/07/%E6%B5%85%E8%B0%88%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    <url>/2022/07/07/%E6%B5%85%E8%B0%88%E4%BA%8C%E6%AC%A1%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>从“原神是不是二次元”说开去。</p><span id="more"></span><p>原神是不是二次元呢？在文章的一开始，我可以给出答案：在我心中，原神是二次元。</p><p>那么，什么是所谓的“二次元”呢？二次元，在平常的语境中，有两种含义。第一种，是指二维动画艺术，及其衍生作品，第二种含义，则是喜欢第一种作品的人。在我看来，这两种含义是有机地结合在一起的。</p><p>我第一次接触现代网络上最普遍意义的“二次元”，应该是在高一刚刚开学，也就是2016年的10月份。基于各种机缘巧合<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="说来搞笑，这里的“机缘巧合”是我在看一个《康熙怒斥群臣》的鬼畜时，“正大光明匾”升上来的一刻，弹幕里有人发了个“御坂美琴”。">[1]</span></a></sup>,我看的第一部是“二次元”是《某科学的超电磁炮》。但是很神奇的是，在接下来的一年中，我自己只是在不断地，一遍又一遍地去看这一部动画（实际上是两部，毕竟还有一个S）。所以说我认为，我真正的“入宅番”并不是《某科学的超电磁炮》，而是《末日时在做什么？有没有空？可以来拯救吗？》。在看过这部以后，我才开始找各种“二次元”动画片看，后来又陆续看了《凉宫春日的忧郁》，《工作细胞》，等等，不再一一列举了。后来在大学，我又在学校的二次元社团（也是学校最大的社团）里，担任了2-3年的职务。</p><p>那么在我心中，什么是二次元呢？其实我自己在选阅作品时是有一种很强烈的倾向的，也就是我很喜欢“幻想艺术”。相比于基于所有人的常理所构建的世界的作品，我更喜欢奇幻、科幻，这种“给世界一刀，看世界带伤运转”的作品。这一点，从我的博客的封面图也可以看得出来。为什么呢？我想，我在欣赏“二次元”作品时，是在躲避现实世界。</p><p>这时候，你就要说了：桀桀，又避世了吧？所以说二次元都是现实世界不如意的fw。是这样的吗？不是。如果真的说“避世”，那可能确实有一点。但是我之所以用了“躲避”，而不是“逃避”，正是为了说明这一点。躲避不同于逃避，逃避有恐惧的含义，而躲避，只是累了。二次元不等同于“社恐”，也不等同于“死宅”，当然也不等于“没有男/女朋友的人”（笑）。我可以白天在底下坐着几百人的讲台上激情洋溢地讲课，也可以和期中考试挂科了的同学坐下来谈心，但这不影响我到了晚上点开一集动画片，和美少女们在剑与魔法的世界中遨游吧？我不恐惧社交，也不是不擅长与社交，我只是很单纯的，不喜欢社交。现实世界太累了，压力太大了，人和人打交道，总要我打起十二分精神，开动所有的CPU，算这，算那。于是我选择了一个更加温暖柔情的世界来做我的避风港。</p><p>那么为什么王者荣耀在我眼中不是二次元，而原神则是呢？明明看艺术风格，王者荣耀也挺二次元的。没错，艺术风格只是一方面，“二次元”这个概念最核心的东西是和内容相关的，是提炼出来的那种纯粹。这种纯粹既可以理解为对现实世界的简单化，也可以理解为对现实世界的升华。王者荣耀这种游戏，激励人玩下去的是“人超越人的快乐”，是“人与人”之间的优越感，是“人与人”之间的攀比心。我这里这么强调“人与人”，正是为了说明，这样的游戏的本质还是社交，是现实世界中人和人的关系。而促使包括我自己在内的很大一部分人游玩原神的动机，则是为了体会那个风和日丽，鸟语花香，高山大川，千里冰封的“异世界”。甘雨一箭的伤害是一万还是十万很重要吗？圣遗物是暴击爆伤还是生命防御很重要吗？在一个小黑屋里杀光敌人，是用了一分钟，还是用了30秒，这很重要吗？当我驻足在风神像前，用风物之诗琴朴拙地弹奏一曲仅仅在我脑中存在过的旋律时，当我看到浅濑神社门前的猫猫云彩时，当我登上寒天之钉俯瞰大陆时，我想，这才是我游戏的意义。可以看出，这个相比现实世界更加温暖柔情的世界正是担当了我的避风港。因此，在我看来，原神是二次元，证毕。</p><p>当然，也有喜欢《原神》的人们，他们更关心在一个小黑屋里杀光敌人，是用了一分钟，还是用了30秒，或者说，他们关心的是有没有比别人更快。那么在这样的玩家看来，原神就不是二次元。在喜欢看剧情，喜欢看人物介绍的人看来，明日方舟是二次元；在把所有人物都当作数值和机制的集合，当作“塔”，一心一意地只为了拿到全世界最快的满级危机合约的玩家看起来，明日方舟就不是二次元。当然，这些玩家没有高下之分，这里说的，只是“是不是二次元”。</p><p>写到这里，可以说“二次元”理论的大厦已经基本建成了，只是上空还漂浮着两朵乌云。</p><p>首先，你刚刚说过，“二次元”这个概念最核心的东西是和内容相关的，是提炼出来的那种纯粹。那么我就要问了，照你这么说，电影电视剧也是二次元！小说也是二次元！这合理吗？</p><p>是的，这不合理。首先我们来说说电影电视剧的事。电影电视剧有一个特点，那就是它们是“实拍”的。无论特效做得再花里胡哨，这改变不了它们是实拍的本质。既然是实拍，那么我在观看的时候，就会不由自主地往真正的现实世界上去投影。我就会想，这些事情怎么可能发生呢？在现实世界里，他们肯定会这样这样，那样那样，然后怎样怎样~，最后落得一个悲惨的下场，所以说这电视剧拍得一点都不好。但是在观看动画作品时，和现实世界略有相似却大相径庭的画风每时每刻都在提醒我：这是你的避风港，把你的那些CPU都关掉，放松一下吧。</p><p>至于小说是不是二次元，在我看来是很模糊的。毕竟还有“轻小说”这种东西。不过我倾向于认为：小说就是二次元！因为在读小说的时候，我在脑子自然地构建着一整个世界。这就是文字艺术的魅力。（P.S. 当然，主角是美少女的最好。）</p><p>好好好，算你混过去了。那么第二点，我要一击致命了！那就是：动漫社为什么会存在？既然你们“二次元”都在躲避社交，那么一群二次元们怎么混在一起社交，不觉得矛盾么？所谓的动漫社，不过是现充聚会罢了！</p><p>必须承认的是，动漫社里面有现充<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="现充分为严现充和宽现充。严现充特指有男/女朋友的人；而宽现充则指有现充行为模式的人。现充行为模式是一套现充的行为模式（什么废话），包括但不限于：吃饭时，打球时，看电影/电视剧/动画时不专注于自己正做的事情，而专注于聊天；乐于社交（注意，还是提醒各位读者，乐于不同于擅于，不乐于不同于不擅于）等。严现充和宽现充不互相包含，但大部分严现充都是宽现充。这里的现充指的是宽现充。">[2]</span></a></sup>。但是，二次元也不少。为什么呢？二次元们躲避社交，不代表二次元们不需要社交。二次元和二次元之间，当然可以有基于二次元形成的纽带。当御坂美琴拿出硬币时，当珂朵莉拿起不属于她的杀人圣剑冲向无边无际的兽之海时，当凉宫春日大声说出“让世界变得更热闹”时，当阿瑠的歌在阿瑠死后不知道多少年响起时，当鹿目圆献出自己的“存在”来消灭魔女时......当在满屏“泪目”弹幕的那一刻，我，确实能感受到有很多和我一样的二次元宅宅，在为了虚拟世界中的虚拟女孩感动。那一刻，我们的心是连在一起的，是通过一个名叫“鹿目圆”的虚拟世界的虚拟女孩连在一起的。在某种意义上，在这一刻，我们这些素昧平生的二次元之间的距离，比我在现实世界中打起十二分精神，开动所有的CPU，算这，算那，来进行社交的对象的关系近得多。在人与人之间真诚地交流自己的兴趣时（当然这里的兴趣并不局限于二次元），也就不需要打起十二分精神算这算那了。因为此时的人是单纯的人，此时的世界是单纯的世界。这一刻联系着我们的，并不是所谓的“社交技巧”，甚至不是二次元作品本身，在我看来，这一刻联系着我们的，是人类的本性，是对善良和爱，感动和泪水，正义和激昂的确信。在这一刻，我似乎相信，即使在现实世界中，也有人在追寻着理想国。于是，我便能关掉CPU，放下十二分精神，只用自己的本性，和同好们畅谈鹿目圆，畅谈珂朵莉，畅谈阿瑠，畅谈他们背后的人类的最最美好的品性，和平时并不相信存在的理想国。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>说来搞笑，这里的“机缘巧合”是我在看一个《康熙怒斥群臣》的鬼畜时，“正大光明匾”升上来的一刻，弹幕里有人发了个“御坂美琴”。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>现充分为严现充和宽现充。严现充特指有男/女朋友的人；而宽现充则指有现充行为模式的人。现充行为模式是一套现充的行为模式（什么废话），包括但不限于：吃饭时，打球时，看电影/电视剧/动画时不专注于自己正做的事情，而专注于聊天；乐于社交（注意，还是提醒各位读者，乐于不同于擅于，不乐于不同于不擅于）等。严现充和宽现充不互相包含，但大部分严现充都是宽现充。这里的现充指的是宽现充。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220704-20220710）</title>
    <link href="/2022/07/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220704-20220710%EF%BC%89/"/>
    <url>/2022/07/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220704-20220710%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><h2 id="section">20220704</h2><p>今天没干什么事。早上在一个没有空调的球馆里打球，热得半死，也累得半死。下午没有做事，晚上把大决战看完了。</p><p>明天该收拾东西了。马上要回西安了。我真期待我的朋友们来西安玩啊。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207042231143.jpg" alt="管人" /><figcaption aria-hidden="true">管人</figcaption></figure><p>笑死，怎么专门把“管人”涂掉，什么隐喻。</p><p>昨天忘了说了，我真是气个半死，他妈整个魔女文画风的倒计时，我还以为是回天的预告，结果不是。</p><blockquote><p>你把大家都叫出来，就是为了说这点事啊？</p></blockquote><h2 id="section-1">20220705</h2><p>今天和朋友去国家图书馆看书了。确实很厉害啊，书是真的多。我看了一本《化物语》，感觉还是相当有意思的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207062305004.jpg" alt="国图" /><figcaption aria-hidden="true">国图</figcaption></figure><p>悄悄说一句，我有点不太理解来国图看网课的人，何必呢（）</p><h2 id="section-2">20220706</h2><p>今天回到了西安，标志着暑假生活正式开始（不是）。西安的堂食都G了，本来还想去吃烤肉的，只能再等等了。</p><p>朋友想要报计组的助教，我还挺羡慕的。其实去年当助教我自己也挺开心的，只可惜下学期课太多，太难，事情太多，实在是没有时间了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207062303919.jpg" alt="阿房宫站" /><figcaption aria-hidden="true">阿房宫站</figcaption></figure><p>到达世界最高站，阿房宫站！</p><blockquote><p>覆压三百余里，隔离天日。骊山北构而西折，直走咸阳。二川溶溶，流入宫墙。五步一楼，十步一阁；廊腰缦回，檐牙高啄；各抱地势，钩心斗角。盘盘焉，囷囷焉，蜂房水涡，矗不知其几千万落！长桥卧波，未云何龙？复道行空，不霁何虹？高低冥迷，不知西东。歌台暖响，春光融融；舞殿冷袖，风雨凄凄。一日之内，一宫之间，而气候不齐。</p><p>——《阿房宫赋》</p></blockquote><h2 id="section-3">20220707</h2><p>今天早上整了个域名，也就是blog.sakizuki.site，大家以后也可以通过这个域名来访问我的博客。</p><p>本来打算今天下午学习，结果真的学习了，学习的成果是把课本下载好了，哈哈。</p><p>今晚看了《走向共和》，看了3集。</p><h2 id="section-4">20220708</h2><p>今天早上看了看数电，下午打了一会儿苍彼，然后吃了吃安倍晋三的瓜，晚上看了走向共和。</p><h2 id="section-5">20220709</h2><p>今天把数电前两章看完了，还看了两集相合之物，一集彼岸花物语，三集走向共和，玩了一会儿苍彼，打了一会儿羽毛球。</p><p>今天西安疫情快结束了。</p><h2 id="section-6">20220710</h2><p>今天看完了走向共和，这个剧还是相当不错的。</p><p>今天还看了四集动画片，玩了一会儿游戏。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人看过的各动画锐评：一</title>
    <link href="/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/"/>
    <url>/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>本文记录我看过的各动画作品，不一定全，也不一定看完了，电影动画都有。然后可能会进行个人主观感受相当强烈的《锐评》。在评价中，个人的情绪、心理、主观观感有相当大的比重，评价也很短，很随性。所以如果和你心目中的差距比较大不要喷哈。</p><p>如果真的要写长评或者认真去评价我会写单独的文章，这个就看一乐。</p><span id="more"></span><p>简要评分标准如下：</p><table><thead><tr class="header"><th>评分</th><th>标准</th></tr></thead><tbody><tr class="odd"><td>95+</td><td>【极优】非常优秀的作品，让我印象深刻</td></tr><tr class="even"><td>85+</td><td>【优】各方面都很优秀的作品，或有非常打动我的长处</td></tr><tr class="odd"><td>75+</td><td>【良】良好的作品，我心中的“平均水平”</td></tr><tr class="even"><td>60+</td><td>【合格】合格的作品，没有什么亮点</td></tr><tr class="odd"><td>60-</td><td>【不合格】有明显短板的作品，不堪卒读</td></tr></tbody></table><p>当然上面的“平均水平”的意思是全部动画的平均水平，而不是我看过的平均水平。我尽量把平均分控制在85分左右。</p><h2 id="赛马娘-pretty-derby-第二季-83">赛马娘 Pretty Derby 第二季 ：83</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335693.jpeg" alt="赛马娘" /><figcaption aria-hidden="true">赛马娘</figcaption></figure><p>个人评分：83</p><p>关键字：励志、运动、拟人、<del>轻百合</del></p><p>锐评：好动画，节奏合适，燃虐有度。本动画可以做到合理改编历史事实，抓住主要矛盾，删除没必要体现黑暗的一面并加入偶像元素，使得动画的一体性更高，不至于有割裂感。就论故事来说其实也就是关于梦想和挫折的故事，的一个制作比较优秀的动画。但是这个改编实在是太新奇了，竟然把赛马这一项运动改编成动画，不得不打个高分。</p><h2 id="奇巧计程车95">奇巧计程车：95</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335781.jpeg" alt="taxi" /><figcaption aria-hidden="true">taxi</figcaption></figure><p>个人评分：95</p><p>关键字：群像、推理、<del>叙述性诡计</del>、剧情向</p><p>锐评：其实我自己对这种有叙述性诡计的作品就自带了好感度（久美子：这是什么？听起来有点色情）。最有趣的是本作的叙诡只有依靠“动画”这一载体才能实现（类似于《罗杰疑案》的叙诡只有依靠文字才能实现？hhhh），所以在我心中非常加分。</p><p>而且本作剧情相当优秀、环环相扣；都市感很强；人物群像塑造不空洞，而且有我很喜欢的画面（比如那个月下飞车）。一点点小遗憾在于一个很重要的剧情依赖巧合推动，有一点点操纵剧本的脱离感。</p><h2 id="泡泡61">泡泡：61</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335770.jpeg" alt="bb" /><figcaption aria-hidden="true">bb</figcaption></figure><p>个人评分：61</p><p>关键字：后新海诚、奇幻、恋爱</p><p>锐评：这部作品平庸到了极点，尽管STAFF各种牛逼，又是虚渊玄又是泽野弘之又是荒木哲郎的，但是做出来的东西只能说是感觉不如新海诚。那么这是怎么会事呢？</p><blockquote><p>配角1: シン (shin) 配角2: カイ (kai) 配角3: マコト (makoto)</p></blockquote><p>只能说是一目了然不言而喻了好吧。当然我这里只是说平庸，而不是说差劲。之所以说平庸，是因为我感觉这几个staff肯定能做出更让人眼前一亮的东西，这个只能说是让人十分失望。但是就片论片，画面和音乐都还算是比较好，算是及格了吧。</p><p>如果日后人们分析日本动画电影时提到“后新海诚主义”，那么这部作品一定首当其冲，作为代表性平庸之作载入史册。这里推荐赵冰的《固守与超越：美日动画电影母题研究》，有兴趣的不妨看一看。</p><h2 id="魔法少女小圆叛逆的物语96">魔法少女小圆：叛逆的物语：96</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335986.jpeg" alt="pn" /><figcaption aria-hidden="true">pn</figcaption></figure><p>（或有剧透）</p><p>关键字：剧情、百合、魔法少女、战斗、<del>看不懂</del></p><p>个人评分：96</p><p>锐评：神作！这是我心目中第二好看的动画电影。整个剧情看下来虽然初看不是很能看懂，但是其实很讲框架和逻辑，剧情发展得非常正规。而最后的转折更是画龙点睛之笔，如果整部作品在圆神把晓美焰接走后结束，那就太太太遗憾了——作为本篇主角的晓美焰，竟然没有为本篇主要矛盾的解决起到最关键的作用吗？可是新房创造性地、开天辟地 地设置了这个场景，设置了晓美焰撕裂圆神而成魔的结局，给本篇的整个结构画上了完美的句号。</p><h2 id="利兹与青鸟86">利兹与青鸟：86</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335970.jpeg" alt="lzyqn" /> 关键字：音乐、文艺、青春</p><p>个人评分：86</p><p>锐评：这部作品应该走的是文艺风，整体风格都比较淡雅，音乐也很好，百合也很好，而且画风和本篇差别比较大。故事淡雅轻灵，作画细致入微，更以嵌入童话的手法来创新叙事。通过清灵的作画、配乐和叙事，本作塑造了一个非常纯粹的世界：没有“世界VS她”的抉择，也没有三角恋，没有本篇中的“政治”因素（笑），有的只是两个高中女生之间细腻而青涩的感情。配乐和故事也进行了非常有机的结合。我在《音乐分析与鉴赏》的课程中就选择了《利兹与青鸟》的第三乐章，得了90好几分。在讨论这部作品时，经常有人讨论谁是利兹而谁是青鸟，在我看来，没有人是利兹也没有人是青鸟，或者说，两个人互为利兹与青鸟。利兹与青鸟童话中的故事不是在暗示霙和希美两人关系的正确解法，而是在暗示霙和希美的现状：两人之间无法传达的心意，和阴差阳错的误解。在电影最后，她们终于了解了自己和对方，真正的抱在了一起，脚步声也从一开始的不同频在最后变成了协调的声音。</p><h2 id="少女歌剧含剧场版87">少女歌剧（含剧场版）：87</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336273.jpeg" /> 关键字：百合、战斗、奇幻、演出</p><p>个人评分：87</p><p>锐评：这个动画我一开始是在19年准备高考的时候看的，看的时候有很多既视感，什么少革小圆的。我的高中在2019年5月12日就放假了，基本上来说，是这部动画陪我走过的高中生涯的最后一个月。至于看的契机，大概是感觉里面的美少女非常帅气吧。本作的剧情虽然有点弱势，但是Revue看着是真的爽，尤其是第一集里面爱城华恋进入地下剧场，然后她跳到舞台中央时的那一段BGM，简直让人颅内高潮。每场Revue加上音乐和歌唱都是一场视听盛宴，可能这就是动画的魅力吧。当然战斗美少女百合CP俺也很喜欢。而剧场版更是扬长避短，用极具张力的演出和音乐不断挑动观众的神经，是一部非常优秀的粉丝向剧场版。</p><h2 id="恋爱小行星78">恋爱小行星：78</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336349.jpeg" /> 关键字：天文、地理、校园、治愈</p><p>个人评分：78</p><p>锐评：这个动画就是比较良好的动画。所谓的“轻百合八股”，就是选取一个小众爱好，加一点校园，加一点美少女，加一点美少女贴贴。比较好的地方在于校园日常的塑造，偶尔会出现那么一两个让我既视感很强的片段，女孩子的人设也很可爱。这部和“传统轻百合”还有一点区别，就是现实主义色彩更加浓重，也有很多三次元的联动。但是缺点没有完全把天文地理的魅力展现出来，知识和动画结合的略有些生硬。</p><h2 id="魔女之旅80">魔女之旅：80</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336761.jpeg" /> 关键字：公路、百合、<del>屑</del>、奇幻、单元剧</p><p>个人评分：80</p><p>锐评：人设大于剧情，伊雷娜的人设确实很讨喜，毕竟是讨论度极高的“屑魔女”嘛。百合+生草小片段的处理也算是版本答案，这一点在《莉克莉斯》中被发扬光大了。但是就是说作者的故事写的水平确实是差了一点。小说前期确实写的不怎么样，后面有些改观。改天要去看看《奇诺之旅》。</p><h2 id="来自深渊第一部深魂黎明85">来自深渊（第一部+深魂黎明）：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336929.jpeg" /> 关键字：世界观、虐、奇幻、冒险</p><p>个人评分：85</p><p>锐评：其实我看这部是看了2部总集篇+1部剧场版。只能说这个世界构建得实在是太有意思了，壮丽、神秘而精美，如果做成开放世界游戏肯定非常非常好玩，如果有个靠谱的游戏公司来做的话就太好了（现在这个游戏，我说句不好听的，感觉不如原神）。在世界观以及如此优秀的情况下剧情没有拉跨，就已经非常值得一看了，况且剧情也很精彩呢。这部动画在我看来是非常“遗憾”的动画，第一遗憾在创造了这么精彩的世界观，但是没有展开介绍，情节推进的速度太快，还没来得及欣赏这一层的生态呢，就要继续往下走了。第二遗憾在如果某些“血腥”或者说“恶趣味”的情节不要表现得这么露骨，让人看着心惊胆战（这部片是PG12真的合理吗？），它有可能本来会得到更高的评价，而不是让“土笔恶趣味”的阴影一直伴随着它。当然，这也可能是来自深渊之所以是来自深渊的原因吧，谁知道呢？</p><h2 id="末日时在做什么有没有空可以来拯救吗95">末日时在做什么？有没有空？可以来拯救吗？：95</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336289.jpeg" /> 关键字：奇幻、末世、恋爱、诺斯替</p><p>个人评分：95</p><p>锐评：这部作品应该对我的影响是非常非常大的，是我真正的“二次元入坑作”。当时是17年吧，我是在打OI的时候被同学（以及刷题网站？hhhh）安利到了这部番 <del>，然后就感受到了二次元的魅力，变成了萌萌二次元</del> 。第一集的斯卡布罗集市就非常地抓人眼球，然后就是这个摇摇欲坠又精致的异世界，然后就是珂朵莉和威廉甜甜的恋爱，然后就是刀子。鲁迅说过：“悲剧就是把美好的东西撕碎给人看”，在这部作品中我确实是体会到了悲剧带给我的震撼。后来我在NOIP2017被 <span class="math inline">\(ab-a-b\)</span> 背刺了以后，也是不停地在听这个动画里的歌，我记得里面有一句是：</p><blockquote><p>We never say good bye and never see again</p></blockquote><p>虽然说这部动画现在看来有这样那样的问题，诸如什么制作贫穷、宏大的世界观和渺小的爱情故事不搭配之类的问题，但是这些都不妨碍现在的我替2017年的我打出95分的高分，因为它在我心中永远是【神作】：非常优秀的作品，让我印象深刻。</p><p>另：本动画的原作小说也非常值得一看，今年还入围了日本星云奖。我最喜欢的是其中的第四本，在这一本中视角回到了500年前，作者将插叙手法运用得炉火纯青，带我领略了500年前大灾变的始末，和“叹月的最初之兽”的悲叹。</p><h2 id="索玛丽与森林之神70">索玛丽与森林之神：70</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336213.jpeg" /> 关键字：旅行、日常、萝莉、催泪</p><p>个人评分：70</p><p>锐评：我记得我看这部的原因就是它和上面说的末日时是一个公司做的。不过这部没给我留下太大印象，可能是不太对我胃口。就光记得催泪催得有点太生硬了。</p><h2 id="lovelive76">Lovelive！：76</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336901.jpeg" /> 关键字：偶像、校园、青春</p><p>个人评分：76</p><p>锐评：单就动画作品来看其实这部比较平凡，算是良作，说好听点就是淳朴吧，当成歌舞片看还挺好的。当然如果加上偶像企划等等一系列内容就另说了。但是这篇文章还是以动画评价为主，所以给到一个良作的档。</p><h2 id="轻音少女89">轻音少女：89</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336552.jpeg" /> 关键字：校园、青春、日常、<del>meta</del></p><p>个人评分：89</p><p>锐评：一部相当优秀的作品，各方面素质都不弱。这部作品是我在2019年高考后看的第一部动画。刚刚结束高中生活的我看着几个可爱的女孩子慢慢走完高中生活的感觉，很奇妙呢。而且在我看的时候她们高考出分和我高考出分是同步的，是同一天，也算是一个别样的体验了，这也是对我来说这部作品的关键字里面有 <del>meta</del> 的原因。其实我感觉这不正是我想要的青春吗。喜欢了什么就义无反顾地开始学习，钱不够了就大家一起打工赚钱，放课后的偷懒，上台前的特训，一起向着目标努力，一起经历疯疯傻傻的生活。最后的最后要毕业了，要分开了，以前一起做过什么很多都记不起来了呢，只记得十分地快乐幸福。 在我刚进大学的时候给我很多很多帮助的18级的前辈，比如aikx、喵燐、赫卡、半宅、薛汐、马老师、mlz、Sky等等，也马上就要毕业了。真伤感啊。</p><h2 id="吹响吧上低音号95">吹响吧！上低音号：95</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336575.jpeg" /> 关键字：社团、青春、音乐、古典、轻百合、励志</p><p>个人评分：95</p><p>锐评：我的高中完全没有社团这种东西的存在，但我却对这部作品的共鸣很强烈，这是为什么呢？其实是因为我把我的竞赛经历投射到了9妹子她们搞吹奏乐身上。我觉得这简直 <strong>完全同构</strong> 好吧，目标都是一路过关斩将， <strong>全国大会出席</strong> ，而且还有什么选拔、合宿（指集训）、等等。唯一的缺点就是9妹子找到了女朋友和男朋友，但我没找到，话虽如此，也算是认识了几个非常要好的朋友。</p><p>除开个人因素，本作作画精美；音乐极其优秀，大大加强了我对古典音乐的兴趣，我有一个相当大的愿望，就是能在音乐厅里欣赏一次本作的经典音乐，如《三日月之舞》、《利兹与青鸟》、《吹响吧！上低音号》、《北宇治四重奏》等。剧情多线交织，详略得当，总集篇的删减也算比较合理。总之来说综合素质可圈可点，所以：</p><p><strong>什么时候出第三季！！！！！！</strong></p><p>（反转了，已经出了）</p><h2 id="比宇宙更远的地方86">比宇宙更远的地方：86</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336539.jpeg" /> 关键字：青春，南极，浪漫</p><p>个人评分：86</p><p>锐评：其实从2019年元旦起，我有一个每年的12月31日都要一晚上看一部动画来跨年的习惯。19年我看的是《凉宫春日》（虽然不知道是几刷了），20年我看的是《紫罗兰永恒花园》，21年我看的就是《比宇宙更远的地方》。这部吸引我的关键字是“宇宙”，虽然实际上和宇宙没有什么关系。但并不影响这是部好作品。能把正值青春期孩子们的烦恼，友情，人际交往等关系充分表现出来，题材也很浪漫，虽然不是宇宙，但那是南极耶！！</p><h2 id="寒蝉鸣泣之时含解不含其它90">寒蝉鸣泣之时（含解，不含其它）:90</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336347.jpeg" /> 关键字：爱，悬疑，猎奇，友情</p><p>个人评分：90</p><p>锐评：一部爱与友情的治愈史诗，比较优秀的游戏改编作品。本作的最大有点一是设置精巧而符合逻辑的悬疑，二是让人看到美好的结局时的欣慰。尽管有着恐怖、血腥等等的形式，但是观众们拨开一层层漆黑的外壳时，最终却得到了晶莹剔透的果实。如果画风能更精致一点，然后血腥暴力稍微少一点就好了。毕竟一开始我也是忍着恐惧在看hhhh</p><h2 id="派对浪客诸葛孔明83">派对浪客诸葛孔明：83</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336014.jpeg" /></p><p>关键字：穿越、偶像、轻松、搞笑</p><p>个人评分：83</p><p>锐评：“酱酱<sub>爱7ki7ki棒棒</sub>”本作 算是四月黑马，观感尚佳，值得期待第二季。虽然名字乍一看挺逆天的，但是可以看出制作人员对孔明和三国历史还是有一定程度的了解的，不是光套个名字就硬上。另外英子莫名地合我的xp，总感觉很是喜欢这种帅帅的二次元女孩子，大加分！制作确实有点穷了，多来点钱应该会更好。</p><h2 id="未闻花名73">未闻花名：73</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336249.jpeg" /></p><p>关键字：友情、伤感、治愈</p><p>个人评价：72</p><p>锐评：这部是一部非常著名的动画，但是就我个人来说，没对我有什么太大的感触。氛围营造得有点刻意，不太好共情。好在ed还挺好听，算是挽回一点评价。</p><h2 id="来自新世界82">来自新世界：82</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336315.jpeg" /></p><p>关键字：科幻，反乌托邦，轻改</p><p>个人评分：82</p><p>锐评：这是一部很有经典气息科幻作品。什么是科幻小说的经典气息呢？科幻小说，也就是幻想和构造的艺术——作者假定一种技术或科学现象，以此假定为种子来进行逻辑推演，开花结果，最终形成了一篇精彩的作品，这才叫经典的科幻。正如前些年热映的《Arrival》中的“外星语言”、《三体》中的三体运动、《诗云》中的“穷举所有诗词”一样。很喜欢我忘了是谁说过的一句话：“科幻文学就是给世界一刀，看世界带病运转的样子”。（当然，多说两句题外话，科幻艺术并不能因为科幻而放弃艺术，毕竟大家看动画小说，看得还是人物塑造、故事情节以及情感，而不是线性代数课本。所以说，科幻作品以点子为基础，而以人物和故事为核心。并不是说一个人越“懂科学”，他所写出的科幻小说就越好）在这个层面，本作也是基于一个核心点子（即咒力，简单来说就是人的武力值近乎于无限地增大，锐利的矛能轻松击破所有的盾），然后推演文明如何演进。作为科幻作品，本作的内部的逻辑能够自洽，设定严谨，有着深刻的社会学思辨，非常难得。这部动画的原作实在是太强了，以至于能掩盖掉动画制作的种种缺陷，所谓瑕不掩瑜。但是还是推荐所有对这部作品有兴趣的人优先去阅读原作，如果实在是不想读文字再来看动画，真的。</p><h2 id="紫罗兰永恒花园85">紫罗兰永恒花园：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336150.jpeg" /></p><p>关键字：画面，京阿尼，奇幻</p><p>评分：85</p><p>锐评：这部是我看过的画面最强大的TV动画，没有之一。在视听领域，这部动画应该可以说是做到了极致。剧情的薄弱没有掩盖到视听方面给我带来的震撼。太可惜了，如果剧本能再好好打磨一下，应该可以说是神作了。我之前提到过我有每年看一部动画片跨年的习惯，这部是我在2019年12月31日看的。之后回家以后和朋友看了外传剧场版，应该是1月20号前后，从影院一出来，一看手机，冠神遍地开花，于是我的前途命运被彻底改变了（笑）</p><p>这一部分到20篇为止，之后的我会另开一贴更新，敬请期待。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于离散系统和Z变换的那些事</title>
    <link href="/2022/07/03/%E5%85%B3%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E5%92%8CZ%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/07/03/%E5%85%B3%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E5%92%8CZ%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>离散系统和Z变换，与连续系统和Laplace变换很像，但也有些不同，可以对比学习。 本文合计5598字。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="离散时间信号与系统">离散时间信号与系统</h2><h3 id="常用基本序列">常用基本序列</h3><ol type="1"><li><p>单位样值序列（对应冲激函数） <span class="math display">\[\delta(n)=\begin{cases}1 &amp; n=0\\\\0 &amp; \text{others}\end{cases}\]</span> 于是，仿照把任意信号分解成冲激函数和的形式，我们可以把任意序列分解成单位样值序列的和的形式，并且这个操作比在连续函数里更直观，即： <span class="math display">\[x(n)=\sum_{m=-\infty}^{\infty} x(m)\delta(n-m) \]</span></p></li><li><p>单位阶跃序列（对应单位阶跃函数） <span class="math display">\[u(n)=\begin{cases}1 &amp; n\geq 0\\\\0 &amp; n&lt;0\end{cases}\]</span> 类似于单位冲激函数和单位阶跃函数的关系，有： <span class="math display">\[u(n)=\sum_{m=-\infty}^{n}\delta(m)\]</span> 和单位阶跃函数不同，<span class="math inline">\(u(0)\)</span>有明确定义，为<span class="math inline">\(1\)</span>.</p></li><li><p>矩形序列</p><p>矩形序列<span class="math inline">\(G_N(n)\)</span>指的是从0开始（含0），含<span class="math inline">\(N-1\)</span>个<span class="math inline">\(1\)</span>的序列，即： <span class="math display">\[G_N(n)=\begin{cases}1 &amp; n\in[0,n)\\\\0 &amp; \text{others}\end{cases}\]</span> 矩形序列是两个单位阶跃序列的组合。有： <span class="math display">\[G_N(n)=u(n)-u(n-N)\]</span></p></li><li><p>（单边）指数序列 <span class="math display">\[x(n)=a^nu(u)\]</span> 当<span class="math inline">\(|a|&lt;1\)</span>时收敛，<span class="math inline">\(|a|&gt;1\)</span>和<span class="math inline">\(a=-1\)</span>时发散。</p><p>当<span class="math inline">\(a&lt;0\)</span>时会在<span class="math inline">\(x\)</span>轴两侧摆动。</p></li><li><p>正弦序列</p><p>正弦序列是由正弦函数采样的序列，有： <span class="math display">\[x(n)=A\sin(\omega t+\varphi)|_{t=nT_s}=A\sin(\omega nT_s+\varphi)\]</span> 其中<span class="math inline">\(T_s\)</span>是采样周期。定义数字角频率： <span class="math display">\[\Omega=\omega T_s\]</span> 与正弦函数不同，正弦序列不一定是周期序列。当且仅当 <span class="math display">\[\frac{2\pi} {\Omega}\]</span> 是有理数时，正弦序列才是周期序列。</p></li></ol><h3 id="离散序列基本运算">离散序列基本运算</h3><p>一般的运算和连续信号（函数）没有多少区别。需要注意的是压扩运算。压扩运算需要去除某些点，或者补充某些0点。</p><h3 id="离散时间系统">离散时间系统</h3><p>离散时间系统的描述和连续时间系统差别不大。不同于连续时间系统中常用积分器，离散时间系统中常用延时器，其符号为一个方框中写了一个“D”，作用是输入<span class="math inline">\(x(n)\)</span>，输出<span class="math inline">\(x(n-1)\)</span>。</p><p>记忆与无记忆、线性与非线性、时变与时不变、稳定与不稳定的含义和连续时间系统没有区别。</p><h3 id="差分方程时域求解方法">差分方程时域求解方法</h3><p>离散时间系统的数学表达式常用差分方程来表示，一般差分方程的形式为： <span class="math display">\[a_0y(n)+a_1y(n-1)+\cdots+a_Ny(n-N)=b_0x(n)+b_1x(n-1)+\cdots+b_My(n-M)\]</span> 求解的过程和微分方程类似：首先将方程右边置0求得齐次解；然后根据激励信号的特点选取含待定系数的特解，代入方程求得特解；再将齐次解和特解相加得完全解；最后代入 <strong>初始条件</strong> 求待定系数。</p><ol type="1"><li><p>求齐次解</p><p>将方程右边置0，得： <span class="math display">\[\sum_{k=0}^Na_ky(n-k)=0\]</span> 特征方程为： <span class="math display">\[\sum_{k=0}^Na_k\lambda^{N-k}=0\]</span> 这是一个关于<span class="math inline">\(\lambda\)</span>的多项式方程。求解特征方程得到特征根<span class="math inline">\(\lambda_1\cdots\lambda_N\)</span>。</p><p>如果<span class="math inline">\(\lambda_i\)</span>是单根或者共轭复根，那么齐次解中含有一项： <span class="math display">\[C_i\lambda_i^n\]</span> 如果<span class="math inline">\(\lambda_j\)</span>是<span class="math inline">\(r\)</span>重根，那么齐次解中含有项： <span class="math display">\[C_1n^{r-1}\lambda_j^n+C_2n^{r-2}\lambda_j^n+\cdots+C_{r-1}n\lambda_j^n+C_r\lambda_j^n\]</span></p></li><li><p>选取特解</p><p>常见激励和它对应的特解如下：</p><table><thead><tr class="header"><th style="text-align: center;">激励<span class="math inline">\(x(n)\)</span></th><th style="text-align: center;">特解</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(n^m\)</span></td><td style="text-align: center;"><span class="math inline">\(\sum_{i=0}^m P_{m-i}n^{m-i}\)</span></td><td style="text-align: center;">所有特征根不为1</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(n^m\)</span></td><td style="text-align: center;"><span class="math inline">\(n^r\sum_{i=0}^m P_{m-i}n^{m-i}\)</span></td><td style="text-align: center;">1是<span class="math inline">\(r\)</span>重特征根</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(P\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>不是特征根</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(P_1n\lambda^n+P_0\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>是特征单根</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\sum_{i=0}^rP_{r-i}n^{r-i}\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>是<span class="math inline">\(r\)</span>重特征根</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sin(\beta n)\)</span>或<span class="math inline">\(\cos(\beta t)\)</span></td><td style="text-align: center;"><span class="math inline">\(P\cos(\beta n)+Q\sin(\beta n)\)</span> 或 <span class="math inline">\(A\cos(\beta n-\theta)\)</span></td><td style="text-align: center;">其中<span class="math inline">\(Ae^{j\theta}=P+jQ\)</span>,<span class="math inline">\(e^{\pm j\theta}\)</span>不是特征根</td></tr></tbody></table></li></ol><blockquote><p>【例】求解差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>， <strong>起始条件</strong> 为<span class="math inline">\(y(-2)=\frac12,y(-1)=0\)</span>。</p><p>【解】特征方程为： <span class="math display">\[\lambda^2+3\lambda+2=0\]</span> 特征根为 <span class="math display">\[\lambda_1=-1,\lambda_2=-2\]</span> 则齐次解为 <span class="math display">\[y_h(h)=C_1(-1)^n+C_2(-2)^n\]</span> 由于<span class="math inline">\(x(n)=2^n\)</span>，2不是特征根，选特解形式为 <span class="math display">\[y_p(n)=P\cdot2^n\]</span> 代入方程，有： <span class="math display">\[P\cdot2^n+3P\cdot2^{n-1}+2P\cdot 2^{n-2}=2^n\]</span> 两边同时除以<span class="math inline">\(2^n\)</span>，有： <span class="math display">\[3P=1\]</span> 得特解： <span class="math display">\[y_p(n)=\frac 13\cdot2^n\]</span> 则完全解形式为： <span class="math display">\[y(n)=C_1(-1)^n+C_2(-2)^n+\frac 13\cdot 2^n\]</span> 代入初始条件.因为方程右边的激励只在<span class="math inline">\(n\geq0\)</span>处有定义，我们要把已知的<span class="math inline">\(y(-1),y(-2)\)</span>转换成<span class="math inline">\(y(0),y(1)\)</span>.有： <span class="math display">\[\begin{cases}y(0)+3y(-1)+2y(-2)=x(0)\\\\y(1)+3y(0)+2y(-1)=x(1)\end{cases}\]</span> 得： <span class="math display">\[y(0)=0,y(1)=2\]</span> 将上述条件代入完全解形式，得： <span class="math display">\[\begin{cases}C_1+C_2+\frac 13=0\\\\-C_1-2C_2+\frac 23=1\end{cases}\]</span> 于是可解得完全解： <span class="math display">\[y(n)=\frac 23(-1)^n -(-2)^n +\frac 13 \cdot2^n \ \ n\geq 0\]</span></p></blockquote><h3 id="零输入和零状态响应">零输入和零状态响应</h3><ol type="1"><li><p>零输入响应</p><p>零输入响应就是只考虑起始状态，而把输入置0时，系统的响应。也就是 <span class="math display">\[\begin{cases}\sum_{i=0}^N a_iy_{zi}(n-i)=0\\\\[2ex]y_{zi}(-1)=y(-1)\\\\y_{zi}(-2)=y(-2)\\\\\cdots\\\\y_{zi}(-N)=y(-N)\end{cases}\]</span> 的解。其中<span class="math inline">\(y_{zi}\)</span>表示零输入（Zero Input）。</p></li><li><p>零状态响应</p><p>零状态响应的意思是起始状态全为0，仅仅考虑外加激励，所引起的响应。也就是 <span class="math display">\[\begin{cases}\sum_{i=0}^N a_iy_{zs}(n-i)=\sum_{i=0}^N b_ix(n-i)\\\\y(-1)=y(-2)=\cdots=0\end{cases}\]</span> 其中<span class="math inline">\(y_{zs}(n)\)</span>表示零状态（Zero State）。</p></li></ol><p>可以通过零输入响应和零状态响应求和的办法求解全响应。</p><blockquote><p>【例】求解差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>，初始条件为<span class="math inline">\(y(0)=1,y(1)=2\)</span>。</p><p>【解】特征方程为： <span class="math display">\[\lambda^2+3\lambda+2=0\]</span> 特征根为 <span class="math display">\[\lambda_1=-1,\lambda_2=-2\]</span> 则齐次解为 <span class="math display">\[y_h(n)=C_1(-1)^n+C_2(-2)^n\]</span> 因为初始条件包含了激励信号的影响，因此需要求出起始条件为： <span class="math display">\[y(-2)=\frac12,y(-1)=0\]</span> 则有： <span class="math display">\[\begin{cases}C_1(-1)^{-1}+C_2(-2)^{-1}=0\\\\C_1(-1)^{-2}+C_2(-2)^{-2}=\frac 12\\\\\end{cases}\]</span> 解得零输入响应为： <span class="math display">\[y_{zi}(n)=(-1)^n-2(-2)^n\]</span> 然后求零状态响应。由于<span class="math inline">\(x(n)=2^n\)</span>，2不是特征根，选特解形式为 <span class="math display">\[y_p(n)=P\cdot2^n\]</span> 代入方程，有： <span class="math display">\[P\cdot2^n+3P\cdot2^{n-1}+2P\cdot 2^{n-2}=2^n\]</span> 两边同时除以<span class="math inline">\(2^n\)</span>，有： <span class="math display">\[3P=1\]</span> 得特解： <span class="math display">\[y_p(n)=\frac 13\cdot2^n\]</span> 则零状态响应的形式为： <span class="math display">\[y_{zs}(n)=D_1(-1)^n+D_2(-2)^n+\frac 13 \cdot 2^n\]</span></p><p>因为求解的是零状态响应，因此此时系统的初始条件为：<span class="math inline">\(y(-1)=y(-2)=0\)</span>。代入差分方程，得初始条件： <span class="math display">\[y_{zs}(0)=0,y_{zs}(1)=1\]</span> 代入待定系数，解得： <span class="math display">\[y_{zs}(n)=-\frac 13(-1)^n+(-2)^n +\frac 13 \cdot (2^n)\]</span> 则全响应为 <span class="math display">\[\begin{aligned}y(n)&amp;=y_{zi}(n)+y_{zs}(n)\\\\&amp;=\frac 23(-1)^n -(-2)^n +\frac 13 \cdot2^n \ \ n\geq 0\end{aligned}\]</span></p></blockquote><h3 id="单位样值响应">单位样值响应</h3><p>单位响应就是激励信号是<span class="math inline">\(\delta(n)\)</span>时的零状态响应。它具有齐次解的形式，而且具有固定起始条件，即： <span class="math display">\[h(-N+1)=0,h(-N+2)=0,\cdots,h(0)=1\]</span></p><blockquote><p>【例】求以下系统的单位样值响应 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=2x(n-1)+x(n-2)\]</span> 【解】先求系统 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 的单位样值响应<span class="math inline">\(h_1\)</span>，再由线性时不变特性求<span class="math inline">\(h(n)\)</span>.</p><p>齐次解的形式为： <span class="math display">\[h_1(n)=[C_1(-1)^n+C_2(-2)^n]u(n)\]</span> 代入固定起始条件<span class="math inline">\(h(-1)=0,h(0)=1\)</span>： <span class="math display">\[\begin{cases}-C_1-\frac 12 C_2=0\\\\C_1+C_2=1\end{cases}\]</span> 得： <span class="math display">\[h_1(n)=[(-1)^(n+1)+2(-2)^n]u(n)\]</span> 有： <span class="math display">\[\begin{aligned}h(n)&amp;=2h_1(n-1)+h_1(n-2)\\\\&amp;=2[(-1)^n+2(-2)^{n-2}]u(n-1)+[(-1)^{n-1}+2(-2)^{n-2}]u(n-2)\\\\&amp;=\frac {\delta(n)}2+(-1)^nu(n)-1.5(-2)^nu(n)\end{aligned}\]</span></p></blockquote><h3 id="卷积和">卷积和</h3><p>两个序列<span class="math inline">\(x(n)\)</span>和<span class="math inline">\(h(n)\)</span>的“卷积和”定义如下： <span class="math display">\[y(n)=x(n)\bigotimes h(n)=\sum_{m=-\infty}^\infty x(m)h(n-m)\]</span> 卷积和具有交换律、结合律、分配律，此外，还有：</p><ol type="1"><li><p>移不变性 <span class="math display">\[x_1(n-m)\bigotimes x_2(n+k)=y(n-m+k)\]</span></p></li><li><p>序列和单位样值序列的卷积 <span class="math display">\[x(n)\bigotimes h(n-m)=x(n-m)\]</span></p></li><li><p>序列和单位阶跃序列的卷积 <span class="math display">\[x(n)\bigotimes u(n)=\sum_{i=-\infty}^n x(n)\]</span></p></li></ol><p>在计算两个有限长度序列的卷积时，可以像列乘法竖式一样，先把两个序列右对齐，然后算“乘法”（只是不进位），即：</p><ol type="1"><li>两序列右对齐</li><li>逐个样值对应相乘，不进位</li><li>同列乘积相加</li></ol><p>得到的结果<span class="math inline">\(y(n)\)</span>的第一个数的下标是两个原始序列的第一个数的下标的和。</p><p>对于无穷长序列一般只能通过定义公式计算。</p><h2 id="离散时间信号与系统变换域分析">离散时间信号与系统变换域分析</h2><h3 id="z变换"><span class="math inline">\(Z\)</span>变换</h3><p>类似于拉普拉斯变换，Z变换也分为双边和单边。</p><p>双边<span class="math inline">\(Z\)</span>变换的定义如下： <span class="math display">\[X(z)={\mathscr Z}[x(n)]=\sum_{n=-\infty}^\infty x(n)z^{-n}\]</span> 单边<span class="math inline">\(Z\)</span>变换的定义如下： <span class="math display">\[X(z)={\mathscr Z}[x(n)]=\sum_{n=0}^\infty x(n)z^{-n}\]</span></p><p>那么为什么和拉普拉斯变换这么像呢？这是因为<span class="math inline">\(Z\)</span>变换可以从拉普拉斯变换导出。</p><p>考虑对一个连续时间信号<span class="math inline">\(x(t)\)</span>进行时间间隔为<span class="math inline">\(T\)</span>的理想冲激抽样，抽样所得的信号记为<span class="math inline">\(x_s(t)\)</span>，则有： <span class="math display">\[x_s(t)=x(t)\cdot \delta_T(t)=\sum_{n=-\infty}^\infty x(nT)\delta(t-nT)\]</span> 对上式取<span class="math inline">\(Z\)</span>变换，有： <span class="math display">\[X_s(s)={\mathscr L}[x_s(t)]=\int_{0}^{\infty}\left[\sum_{n=-\infty}^\infty x(nT)\delta(t-nT)\right]e^{-st} {\mathbf d}t\]</span> 对调积分求和、利用冲激函数性质，有： <span class="math display">\[X_s(s)=\sum_{n=-\infty}^\infty x(nT)e^{-snT} \]</span> 设<span class="math inline">\(z=e^{sT}\)</span>，由于<span class="math inline">\(T\)</span>是给定常数，则<span class="math inline">\(z\)</span>是<span class="math inline">\(s\)</span>的函数，则有： <span class="math display">\[X_s(z)=\sum_{n=-\infty}^\infty x(nT)z^{-n}\]</span> 在一般的离散系统中，让<span class="math inline">\(T=1\)</span>，则有： <span class="math display">\[X_s(z)=\sum_{n=-\infty}^{\infty} x(n)z^{-n}\]</span> 一个序列的<span class="math inline">\(Z\)</span>变换，实际上是一个系数为这个序列的样值，变量为<span class="math inline">\(z^{-1}\)</span>的幂级数。即： <span class="math display">\[X(z)=\cdots+x(-2)z^2+x(-1)z^1+x(0)z^0+x(1)z^{-1}+x(2)z^{-2}+\cdots\]</span></p><h3 id="z变换的收敛域"><span class="math inline">\(Z\)</span>变换的收敛域</h3><p>既然是从拉普拉斯变换导出来的，而且还是幂级数，那就不得不讨论收敛域。</p><p>复习一下，分析里面判断级数收敛有很多方法，其中最常用的有达朗贝尔判别法，即对于变号级数， <span class="math display">\[\lim_{n\to \infty} \left|\frac{x(n+1)z^{-(n+1)} } {x(n)z^{-n} }\right|=\rho\]</span> 如果<span class="math inline">\(\rho&lt;1\)</span>，那么绝对收敛；如果<span class="math inline">\(\rho&gt;1\)</span>，那么发散。</p><p>结合拉普拉斯变换，我们把序列分成左边序列，右边序列，双边序列来讨论。由于 <span class="math display">\[z=e^{s}\]</span> 我们可以通过下图的方法来建立S平面和Z平面的联系。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/AAC37E072C27DA06CC75C6F0EE4975D9.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>有：</p><table><thead><tr class="header"><th>序列（函数）类型</th><th>Z变换收敛性形状</th><th>拉普拉斯变换收敛域形状</th></tr></thead><tbody><tr class="odd"><td>右边</td><td>以原点为中心的圆之外 <span class="math inline">\(\|z\|&gt;\|a\|\)</span></td><td>右半平面 <span class="math inline">\(Re[s]&gt;\alpha\)</span></td></tr><tr class="even"><td>左边</td><td>以原点为中心的圆之内 <span class="math inline">\(\|z\|&lt;\|b\|\)</span></td><td>左半平面 <span class="math inline">\(Re[s]&lt;\beta\)</span></td></tr><tr class="odd"><td>两边</td><td>以原点为圆心的圆环 <span class="math inline">\(\|z\|\in(a,b)\)</span></td><td>条带 <span class="math inline">\(Re[s]\in (\alpha,\beta)\)</span></td></tr></tbody></table><p>对于有限长的序列，收敛域是除去零点和无穷远点的整个Z平面。</p><h3 id="常见序列的z变换">常见序列的<span class="math inline">\(Z\)</span>变换</h3><table><thead><tr class="header"><th>序列名称</th><th>序列表达式</th><th><span class="math inline">\(Z\)</span>变换</th><th>收敛域</th></tr></thead><tbody><tr class="odd"><td>单位样值序列</td><td><span class="math inline">\(\delta(n)=(n=0)?1:0\)</span></td><td><span class="math inline">\(1\)</span></td><td>全平面</td></tr><tr class="even"><td>单位阶跃序列</td><td><span class="math inline">\(u(n)=(n\geq 0)?1:0\)</span></td><td><span class="math inline">\(\frac{z} {z-1}\)</span></td><td><span class="math inline">\(\|z\|&gt;1\)</span></td></tr><tr class="odd"><td>因果指数序列</td><td><span class="math inline">\(x(n)=a^nu(n)\)</span></td><td><span class="math inline">\(\frac{z} {z-a}\)</span></td><td><span class="math inline">\(\|z\|&gt;\|a\|\)</span></td></tr></tbody></table><h3 id="z变换的性质"><span class="math inline">\(Z\)</span>变换的性质</h3><p>设 <span class="math display">\[{\mathscr Z}[x(n)]=X(z),|z|\in(\alpha,\beta)\]</span></p><h4 id="时域性质">时域性质</h4><ol type="1"><li><p>反褶性质 <span class="math display">\[{\mathscr Z}[x(-n)]=X(z^{-1}),|z|\in(\frac 1\beta,\frac 1\alpha)\]</span></p></li><li><p>扩展性质 <span class="math display">\[{\mathscr Z}\left[x\left(\frac na \right)\right]=X(z^a),|z|\in (\alpha^{\frac 1a},\beta ^{\frac 1a})\]</span></p></li><li><p>位移性质</p><ol type="1"><li><p>单边</p><p>若<span class="math inline">\(x(n)\)</span>是双边序列，有： <span class="math display">\[{\mathscr Z}[x(n)u(n)]=X(z) ,|z|&gt;a\]</span> 则有： <span class="math display">\[{\mathscr Z}[x(n+m)u(n)]=z^m\left[ X(z)-\sum_{k=0}^{m-1} x(k)z^{-k} \right]\\\\{\mathscr Z}[x(n-m)u(n)]=z^{-m}\left[ X(z)+\sum_{k=-m}^{-1} x(k)z^{-k} \right]\\\\\]</span> 请注意这里的“位移”：<span class="math inline">\(x(n-m)u(n)\)</span>和拉普拉斯变换里的“位移”<span class="math inline">\(f(t-t_0)u(t-t_0)\)</span>，以及傅里叶变换里的“位移”<span class="math inline">\(f(t-t_0)\)</span>的区别。</p><p>特别的，如果<span class="math inline">\(x(n)\)</span>是因果序列，那么有： <span class="math display">\[\begin{aligned}{\mathscr Z}[x(n+m)u(n)]&amp;=z^m\left[ X(z)-\sum_{k=0}^{m-1} x(k)z^{-k} \right]\\\\{\mathscr Z}[x(n-m)u(n)]&amp;=z^{-m}X(z)\end{aligned}\]</span></p></li><li><p>双边</p><p>双边位移性质比较简单。 <span class="math display">\[{\mathscr Z}[x(n\pm m)]=z^{\pm m}X(z),|z|\in(\alpha,\beta)\]</span></p></li></ol></li><li><p>线性性质</p></li></ol><h4 id="频域性质">频域性质</h4><ol type="1"><li><p><span class="math inline">\(Z\)</span>域微分-序列线性加权 <span class="math display">\[{\mathscr Z}[n\cdot x(n)]=-z\frac{ {\mathbf d}X(z)} { {\mathbf d}z}\]</span></p></li><li><p><span class="math inline">\(Z\)</span>域压扩-序列指数加权 <span class="math display">\[{\mathscr Z}[a^n x(n)]=X\left(\frac za\right),\alpha&lt;\left|\frac za\right|&lt;\beta\]</span> 特殊的，如果要实现<span class="math inline">\(Z\)</span>域反褶运算，有： <span class="math display">\[{\mathscr Z}[(-1)^nx(n)]=X(-z)\]</span></p></li></ol><h4 id="其它性质">其它性质</h4><ol type="1"><li><p>时域卷积 <span class="math display">\[{\mathscr Z}[x_1(n)\bigotimes x_2(n)]=X_1(z)X_2(z)\]</span></p></li><li><p>初值定理</p><p>对于因果序列 <span class="math display">\[x(0)=\lim_{z\to \infty} X(z)\]</span></p></li><li><p>终值定理 <span class="math display">\[x(\infty)=\lim_{z\to 1}[(z-1)X(z)]\]</span></p></li></ol><h3 id="利用z变换性质求其它常用序列的z变换">利用<span class="math inline">\(Z\)</span>变换性质求其它常用序列的<span class="math inline">\(Z\)</span>变换</h3><ol type="1"><li><p>单位样值序列的平移<span class="math inline">\(\delta(n-m)\)</span></p><p>由时移性质，有： <span class="math display">\[{\mathscr Z}[\delta(n-m)]=z^{-m}\]</span></p></li><li><p>斜变序列<span class="math inline">\(x(n)=nu(n)\)</span></p><p>由<span class="math inline">\(Z\)</span>域微分-线性加权性质，有： <span class="math display">\[{\mathscr Z}[nu(n)]=-z\frac{ {\mathbf d} } {\mathbf dz}\left(\frac {z} {z-1}\right)=\frac{z} {(z-1)^2}\]</span></p></li><li><p>因果余弦序列<span class="math inline">\(x(n)=\cos(\omega_0 n)u(n)\)</span></p><p>由欧拉公式： <span class="math display">\[\cos(\omega_0 n)=\frac 12 \left(e^{j\omega_0n}+e^{-j\omega_0 n}\right)\]</span> 和已知的公式 <span class="math display">\[{\mathscr Z}[\left(e^{\pm j\omega_0}\right)^nu(n)]=\frac{z} {z-e^{\pm j\omega_0} },|z|&gt;1\]</span> 结合线性性质，得 <span class="math display">\[{\mathscr Z}[\cos(\omega_0 n)u(n)]=\frac{z^2 -z\cos(\omega_0)} {z^2-2z\cos \omega_0+1},|z|&gt;1\]</span> 同理，因果正弦序列为： <span class="math display">\[{\mathscr Z}[\sin(\omega_0 n)u(n)]=\frac{z\sin(\omega_0)} {z^2-2z\cos \omega_0+1},|z|&gt;1\]</span></p></li></ol><h3 id="逆z变换的求解">逆<span class="math inline">\(Z\)</span>变换的求解</h3><p>一般的线性时不变系统的<span class="math inline">\(Z\)</span>变换表达式往往具有有理多项式的形式。</p><h4 id="长除法">长除法</h4><p>长除法的意思就是根据<span class="math inline">\(Z\)</span>变换的定义，直接求解幂级数的系数，从而求解原始序列。</p><p>当收敛域形式为<span class="math inline">\(|z|&gt;a\)</span>时，幂级数表现出洛朗级数的形式，序列是右边序列，此时应把分母整理成降幂形式，再做长除法。</p><p>当收敛域形式为<span class="math inline">\(|z|&lt;b\)</span>时，幂级数表现出泰勒级数的形式，序列是左边序列，此时应把分母整理成升幂形式，再做长除法。</p><p>这种长除法只能得到序列的部分样值，而且多用于单边<span class="math inline">\(z\)</span>变换。对于双边<span class="math inline">\(z\)</span>变换，一般用部分分式展开法。</p><h4 id="部分分式分解法">部分分式分解法</h4><p>部分分式分解法的核心思想是把有理多项式分式分解成基本分式 <span class="math display">\[\frac{kz} {z-a}\]</span> 的和，然后由于 <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {z-a}\right]=ka^nu(n),|z|&gt;a\]</span> 或者 <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {z-a}\right]=-ka^nu(-n-1),|z|&lt;a\]</span> 来求解原始序列。</p><blockquote><p>【例】求解： <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{5z} {-3z^2+7z-2}\right]\]</span> 分收敛域为：(1) <span class="math inline">\(|z|&gt;2\)</span> (2) <span class="math inline">\(|z|\in (\frac 13 , 2)\)</span>两种情况。</p><p>【解】首先对 <span class="math display">\[\frac{X(z)} {z}=\frac{5} {-3z^2+7z-2}\]</span> 进行分解，过程略，如果不会请参考拉普拉斯变换部分相关内容。有： <span class="math display">\[\frac{X(z)} {z}=\frac{-1} {z-2}+\frac{1} {z-\frac{1} {3} }\]</span> 则： <span class="math display">\[X(z)=\frac{-z} {z-2}+\frac{z} {z-\frac{1} {3} }\]</span></p><ol type="1"><li><p>收敛域为<span class="math inline">\(|z|&gt;2\)</span></p><p>此时，有： <span class="math display">\[x(n)=-2^nu(n)+\left(\frac 13\right)^nu(n)\]</span></p></li><li><p>收敛域为<span class="math inline">\(|z|\in \left(\frac 13,2\right)\)</span></p><p>这时要考虑两个分式分别代表的收敛域是什么。因为线性组合的收敛域是各项的收敛域的交集。我们经分析，得：第一项对应收敛域<span class="math inline">\(|z|&lt;2\)</span>，第二项对应收敛域<span class="math inline">\(|z|&gt;\frac 13\)</span>。(如果反过来，那么收敛域就是空集，这和题目不符)，因此： <span class="math display">\[x(n)=2^nu(-n-1)+\left(\frac 13\right)^nu(n)\]</span></p></li></ol></blockquote><p>对于右边序列，如果出现共轭复根的情况，即 <span class="math display">\[\frac{kz} {z^2+a}\]</span> 则有 <span class="math display">\[\begin{aligned}\frac{kz} {z^2+a}&amp;=\frac{\frac{k} {\sqrt a}\cdot \frac{z} {\sqrt a} } {\left(\frac z{\sqrt a}\right)^2+1}\\\\&amp;=\frac{k} {\sqrt a}\frac{\frac{z} {\sqrt a}\sin \frac \pi 2} {\left(\frac z{\sqrt a}\right)^2-2\left(\frac z{\sqrt a}\right)\cos\frac \pi 2 +1}\\\\&amp;\to \frac{k} {\sqrt a}\cdot \sqrt{a}^n\cdot \sin\left(\frac{\pi} {2}n\right)u(n)\end{aligned}\]</span> 可以使用<code>mathematica</code>验证上述推导，输入：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">ZTransform</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">a</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">^</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">n</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">*</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">n</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-variable">n</span><span class="hljs-operator">,</span> <span class="hljs-variable">z</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>输出： <span class="math display">\[\frac{k z} {a+z^2}\]</span> 对于2阶重极点，有： <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {(z-a)^2}\right]=a^{n-1}knu(n)\]</span> 对于更高阶的极点，有： <span class="math display">\[{\mathscr Z}\left[\frac{kz} {(z-a)^r}\right]=\frac{k} {(r-1)!}a^{n-r+1}\prod_{i=0}^{r-2}(n-i)=k a^{n-r+1} \binom{n} {r-1}\]</span></p><h3 id="用z变换求解差分方程">用<span class="math inline">\(Z\)</span>变换求解差分方程</h3><p>一般差分方程的形式如下： <span class="math display">\[\sum_{k=0}^N a_ky(n-k)=\sum_{r=0}^M b_rx(n-r)\]</span> 对等式两边取<span class="math inline">\(Z\)</span>变换： <span class="math display">\[\sum_{k=0}^N a_kz^{-k}\left[Y(z)+\sum_{l=-k}^{-1}y(l)z^{-l}\right]=\sum_{r=0}^M b_rz^{-r}\left[X(z)+\sum_{m=-r}^{-1}x(m)z^{-m}\right]\]</span> 则系统全响应（的<span class="math inline">\(Z\)</span>变换）为： <span class="math display">\[Y(z)=\frac{\sum_{r=0}^M b_rz^{-r}\left[X(z)+\sum_{m=-r}^{-1}x(m)z^{-m}\right]} {\sum_{k=0}^Na_kz^{-k} }-\frac{\sum_{k=0}^N\left[a_kz^{-k}\cdot\sum_{l=-k}^{-1}y(l)z^{-l}\right]} {\sum_{k=0}^Na_kz^{-k} }\]</span> 其中第一项代表零状态响应，第二项代表零输入响应。</p><p>......麻了没？这么多分式，<span class="math inline">\(\sum\)</span>，我打着都麻。其实这玩意很简单的，下面通过一个例题给大家表演一下。</p><blockquote><p>【例】差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>， <strong>起始条件</strong> 为<span class="math inline">\(y(-2)=2,y(-1)=0\)</span>。求零输入、零状态和全响应。</p><p>【解】对方程两边取<span class="math inline">\(Z\)</span>变换，有： <span class="math display">\[Y(z)+3\left[z^{-1}Y(z)+y(-1)\right]+2\left[z^{-2}Y(z)+y(-2)+y(-1)z^{-1}\right]=X(z)\]</span> 代入数据： <span class="math display">\[(1+3z^{-1}+2z^{-2})Y(z)+4=\frac{z} {z-2}\]</span> 则： <span class="math display">\[\begin{aligned}Y(z)&amp;=\frac {-4} {1+3z^{-1}+2z^{-2} }+\frac{1} {1+3z^{-1}+2z^{-2} }\frac{z} {z-2}\\\\&amp;=\frac{-4z^2} {z^2+3z+2}+\frac{z^2} {z^2+3z+2}\frac{z} {z-2}\end{aligned}\]</span> 其中第一项代表零状态响应，第二项代表零输入响应。有： <span class="math display">\[Y_{zi}(z)=\frac{4z} {z+1}+\frac{-8z} {z+2}\]</span></p><p><span class="math display">\[Y_{zs}(z)=\frac{-\frac 13 z} {z+1}+\frac{z} {z+2}+\frac{\frac 13 z} {z-2}\]</span></p><p>则： <span class="math display">\[y_{zi}(n)=4(-1)^n-8(-2)^n\\\\y_{zs}(n)=-\frac 13 (-1)^n+(-2)^n+\frac 13 (2)^n\]</span> (<span class="math inline">\(n\geq 0\)</span>)</p></blockquote><h3 id="离散系统传递函数">离散系统传递函数</h3><p>就是单位样值响应（零状态）<span class="math inline">\(h(n)\)</span>的<span class="math inline">\(Z\)</span>变换<span class="math inline">\(H(z)\)</span>,一般有如下形式：</p><p><span class="math display">\[H(z)=\frac{\sum_{r=0}^M b_rz^{-r} } {\sum_{k=0}^N a_kz^{-k} }=G\frac{\prod _{r=1}^M (1-o_rz^{-1})} {\prod_{k=0}^N (1-p_kz^{-1})}\]</span></p><p>其中<span class="math inline">\(o\)</span>就是零点，<span class="math inline">\(p\)</span>就是极点。对于因果序列而言，极点分布和<span class="math inline">\(h(n)\)</span>大致时域形状的关系如下：</p><table><thead><tr class="header"><th><span class="math inline">\(H(z)\)</span>极点位置</th><th><span class="math inline">\(h(n)\)</span>时域形状</th></tr></thead><tbody><tr class="odd"><td>单位圆内实数</td><td>指数衰减序列</td></tr><tr class="even"><td>单位圆内共轭复数</td><td>衰减的正弦序列</td></tr><tr class="odd"><td>单位圆外实数</td><td>指数增长序列</td></tr><tr class="even"><td>单位圆外共轭复数</td><td>增长的正弦序列</td></tr><tr class="odd"><td>单位圆上实数</td><td>常序列（一阶）或逐渐增大</td></tr><tr class="even"><td>单位圆上共轭复数</td><td>幅度为常数或逐渐增大的正弦序列</td></tr></tbody></table><p>由此可以看出极点分布和系统稳定性的关系。另外，这个表也可以由<span class="math inline">\(s-z\)</span>平面变换得出。</p><p>至于因果性，那就更简单了。只要系统函数的极点分布在<span class="math inline">\(Z\)</span>平面内的一个半径有限的圆内就行，即保证收敛域为 <span class="math display">\[|z|&gt;R\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假计划</title>
    <link href="/2022/07/02/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/"/>
    <url>/2022/07/02/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>雄心壮志！！</p><span id="more"></span><h2 id="游戏">游戏</h2><ul><li>苍之彼方的四重奏</li><li>梅时露霁书~雨潺海汐间~</li><li>传送门</li><li>传送门2</li><li>Outer Wildes</li><li>OPUS龙脉常歌</li></ul><h2 id="动画片">动画片</h2><ul><li>无职转生</li><li>相合之物</li><li>白箱</li><li>奇诺之旅</li><li>摇曳露营2</li></ul><h2 id="书">书</h2><ul><li>科幻世界</li><li>固守与超越</li></ul><p>啊嗯，宏伟的计划！</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于分离变量法和物质极化的那些事</title>
    <link href="/2022/07/01/%E5%87%89%E5%AE%AB%E7%A7%8B%E6%9C%88/"/>
    <url>/2022/07/01/%E5%87%89%E5%AE%AB%E7%A7%8B%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<p>这部分写的有点混乱，主要原因是我自己也没搞得太明白。还是希望大家多多在评论里交流。</p><span id="more"></span><p>[toc]</p><h2 id="静电位拉普拉斯方程的变量可分离解">静电位拉普拉斯方程的变量可分离解</h2><p>拉普拉斯方程： <span class="math display">\[\nabla^2\Phi=0\]</span></p><h3 id="直角坐标系中">直角坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=X(x) Y(y) Z(z)=(A x+B)(C y+D)(E z+F)\]</span> 一般解： <span class="math display">\[\Phi(x, y, z)=\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{x} x\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{y} y\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{z} z\]</span> 满足： <span class="math display">\[\pm K_x^2\pm K_y^2\pm K_z^2=0\]</span> 选试探解时，必须从分割线两边选取，不能只取一边。</p><h3 id="柱坐标系中">柱坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=\left(A+B \ln r_ { c } \right)(C+D \varphi)(F+G z)\]</span> 其中第一项的物理意义是：<span class="math inline">\(z\)</span>方向上无限长均匀带电直线线电荷周围的电场。</p><p>一般解： <span class="math display">\[\Phi(\vec { r } )=\left(A r_ { C } ^ { n } +B r_ { C } ^ { -n } \right)(C \sin n \varphi+D \cos n \varphi)\]</span> 其物理意义如下：</p><ol type="1"><li><span class="math inline">\(n=1,B=C=0\)</span>：<span class="math inline">\(x\)</span>方向匀强电场</li><li><span class="math inline">\(n=1,B=D=0\)</span>：<span class="math inline">\(y\)</span>方向匀强电场</li><li><span class="math inline">\(n=1,A=C=0\)</span>​：沿着<span class="math inline">\(x\)</span>轴放置的二维电偶极子</li><li><span class="math inline">\(n=1,A=D=0\)</span>：沿着<span class="math inline">\(y\)</span>轴放置的二维电偶极子</li><li>对于整数<span class="math inline">\(n\)</span>，系统是一个<span class="math inline">\(2n\)</span>偶极子。当<span class="math inline">\(A\neq 0\)</span>时， 有放置在无穷远处多极子形式；当<span class="math inline">\(B\neq0\)</span>时，有放置在原点的多极子形式</li></ol><p>需要注意的是：上述系统的总电荷量都是0，只有平凡解中式<span class="math inline">\(\left(A+B \ln r_ { c } \right)\)</span>对应的系统总电荷量不为零。因此，系统有没有净电荷，可以作为判断要不要取<span class="math inline">\(\left(A+B \ln r_ { c } \right)\)</span>的依据。</p><h3 id="球坐标系中">球坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=\left(A+\frac { B }  { r_ { s }  } \right)\left[C+D \ln \left(\tan \frac { \theta }  { 2 } \right)\right](F+G \varphi)\]</span> 其物理意义为：</p><ol type="1"><li>第一项表示了位于原点的点电荷</li><li>第二项是在一个空间两圆锥面之间夹着的区域的电荷分布</li><li>第三项是空间角域的电荷分布</li></ol><p>一般解： <span class="math display">\[\Phi(\vec { r } ) =\left[A r_ { S } ^ { n } +\frac { B }  { r_ { S } ^ { n+1 }  } \right] P_ { n } ^ { m } (\cos \theta)(C \sin m \varphi+D \cos m \varphi)\ \ (m\leq n)\]</span> 如果系统的总电荷量为0，它的电位中就不可能有$ { r_s } <span class="math inline">\(出现，因此只会有一般解中\)</span>n<span class="math inline">\(的形式出现。如果一个系统中总电荷量不是0，那么就可以有\)</span> { r_s } $出现。</p><h2 id="边界条件的选取规则">边界条件的选取规则</h2><h3 id="边界电位已知的系统">边界电位已知的系统</h3><p>直接写出边界上<span class="math inline">\(\Phi\)</span>等于已知的电位即可。</p><h3 id="带有自然边界条件的系统">带有自然边界条件的系统</h3><p>对于一个<strong>分布在有限区域的源</strong>（例如：给出某边界的电压表达式，在某表面上有电荷等），观察点离他越远，他对观察点的 <strong>场</strong> 的影响就越小。如果源在某个方向是无限的，那么在无限远处电位是常数，只有电场趋于零。如果源确实是有限的（例如：球面），那么可以认为电位在无穷远点是0，此时电场当然也是零。因此，有： <span class="math display">\[r\to \infty,E\to 0\]</span> 对于在某个方向无限的情况，特别地，如果在系统中给出了“地”，或者和地相连的零电位面，而且当前<span class="math inline">\(r\to \infty\)</span>的这个方向附近存在零电位面，那么这个条件很可能也可以被进一步加强为： <span class="math display">\[r\to \infty,\Phi\to 0\]</span> 在系统的原点处，往往有极值定理。这说明：在<span class="math inline">\(r=0\)</span>处，电位应该有限，即： <span class="math display">\[r\to 0,\Phi=0\]</span></p><h3 id="导数边界条件">导数边界条件</h3><p>在载流导体和空气的边界，电容器的边缘处，往往有： <span class="math display">\[\frac { \partial \Phi }  { \partial n } =0\]</span> 在有面自由电荷分布的边界上，有： <span class="math display">\[\varepsilon_0\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_0\frac { \partial \Phi_1 }  { \partial n } =\eta\]</span> 如果上面的情况是在两个电介质的交界处，有： <span class="math display">\[\varepsilon_0\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_0\frac { \partial \Phi_1 }  { \partial n } =\eta_f+\eta_p\]</span> 或 <span class="math display">\[\varepsilon_1\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_2\frac { \partial \Phi_1 }  { \partial n } =\eta_f\]</span></p><p>在两个电导率不同的材料的交界面上，有： <span class="math display">\[\sigma_1\frac { \partial \Phi_1 }  { \partial n } =\sigma_1\frac { \partial \Phi_1 }  { \partial n } \]</span></p><h3 id="带有趋势性边界条件的静电系统">带有趋势性边界条件的静电系统</h3><p>近区：点电荷、电偶极子等，如果放在原点，那么<span class="math inline">\(r_s\to 0\)</span>时，电位趋向于点电荷和电偶极子的电荷。</p><p>远区：如果在一个看起来就很“大”的系统，例如：遍布于全空间的匀强电场中放入一个导体球，那么当<span class="math inline">\(r_s\to \infty\)</span>时，场分布应该和那么很“大”的系统一样。</p><h2 id="试探解的选取规则">试探解的选取规则</h2><h3 id="直角坐标系中-1">直角坐标系中</h3><p>首先确定：电位和哪些坐标量有关，和哪些坐标量无关。</p><p>然后，检查电位是否在某个方向线性变化。这里一般是看边界条件。如果确实线性变化，选平凡解。</p><p>然后，看系统在某坐标量上的零点个数。如果有超过1个零点，那么这个坐标量应该考虑三角函数形式。否则，可以考虑指数函数形式。需要特别注意的是：<span class="math inline">\(\cosh\)</span>函数是没有零点的。</p><p>然后，看对称性。三角函数中，<span class="math inline">\(\sin\)</span>是奇函数，<span class="math inline">\(\cos\)</span>是偶函数。在指数形式函数中，<span class="math inline">\(\sinh\)</span>是奇函数，<span class="math inline">\(\cosh\)</span>是偶函数。</p><h3 id="柱坐标系中-1">柱坐标系中</h3><p>在柱坐标系中确定<span class="math inline">\(n\)</span>的值时，应结合边界条件，看看边界条件中给出的是（例如）： <span class="math display">\[r_c=b,\Phi_1=\Phi_2=V_0\sin 2\varphi\]</span> 这时候<span class="math inline">\(n\)</span>就是2。如果边界条件是（例如）： <span class="math display">\[r_ { C } =R, \Phi_ { 1 } (\vec { r } )=\Phi_ { 2 } (\vec { r } )=V_ { 0 }  \cos \varphi\]</span> 这时候<span class="math inline">\(n\)</span>显然是<span class="math inline">\(1\)</span>，同时也可以确定<span class="math inline">\(C,D\)</span>的存在性。</p><p>如果系统中存在净电荷量，或者只和<span class="math inline">\(r_c\)</span>有关，那么可以考虑平凡解的<span class="math inline">\((A+B\ln r_c)\)</span>项。</p><h3 id="球坐标系中-1">球坐标系中</h3><p>首先也要确定<span class="math inline">\(n,m\)</span>的取值。如果系统和<span class="math inline">\(\phi\)</span>无关，那么这时候<span class="math inline">\(m\)</span>显然是0，这种情况很简单。如果不能确定，应看边界条件中有没有和勒让德函数形式契合的。如果有，那么<span class="math inline">\(n,m\)</span>的取值也随之确定。</p><p>如果系统和<span class="math inline">\(\theta,\varphi\)</span>看起来都没有关系，可以选取平凡解<span class="math inline">\((A+B/r_s)\)</span>。如果系统很契合“两个圆锥面”的物理情景，可选择平凡解的第二项。</p><h2 id="有物质存在时的场定律">有物质存在时的场定律</h2><h3 id="极化">极化</h3><h4 id="极化强度矢量">极化强度矢量</h4><p>定义式: <span class="math display">\[P=\lim_ { \Delta V\to 0 } \frac { \sum_ { i=1 } ^n p_i }  { \Delta V } \]</span> 其中ΔV是空间中的小体积元，pi是ΔV中一个电偶极子的电偶极矩。还有一个计算式： <span class="math display">\[P=\chi_e\varepsilon_0E\]</span> 其中<span class="math inline">\(\chi_e\)</span>是极化率。这个式子只有在非永久极化时才能使用。</p><h4 id="极化与高斯定律">极化与高斯定律</h4><p>有极化电荷密度： <span class="math display">\[\rho_P=-\nabla\cdot P\]</span> 由这个式子，可导出边界条件： <span class="math display">\[\eta_P=-i_n\cdot(P_1-P_2)\]</span> 宏观极化模型下的高斯定律： <span class="math display">\[\nabla\cdot(\varepsilon_0E+P)=\rho_f\]</span> 如果令电位移矢量<span class="math inline">\(D\)</span> <span class="math display">\[D=\varepsilon_0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=(1+\chi_e)\varepsilon_0E=\varepsilon_r\varepsilon_0E\]</span> 有： <span class="math display">\[\nabla\cdot D=\rho_f\]</span> 写成积分形式： <span class="math display">\[\oint_sD \mathrm { d } a=\iiint_v\rho_f \mathrm { d } V\]</span> 还可以导出以下两个边界条件： <span class="math display">\[i_n\cdot\varepsilon_0(E_1-E_2)=\eta_f+\eta_p\\i_n\cdot(D_1-D_2)=\eta_f\]</span></p><h4 id="极化与安培环路定律">极化与安培环路定律</h4><p>极化电流： <span class="math display">\[J_p=\frac { \partial P }  { \partial t } \]</span> 修正的安培环路定律： <span class="math display">\[\nabla\times H=J_f+\frac { \mathbf { d } D }  { \mathbf { d } t } \]</span> 积分形式： <span class="math display">\[\oint_cH\mathbf { d } s=\iint_sJ\mathbf { d } a+\frac { \mathbf { d }  }  { \mathbf { d } t } \iint_sD\mathbf { d } a\]</span></p><h4 id="求解问题思路">求解问题思路</h4><ol type="1"><li><p>永久极化问题</p><p>在永久极化的情况下，<span class="math inline">\(P=\chi_e\varepsilon_0E\)</span>不能用，这时候<span class="math inline">\(P\)</span>一般会直接告诉你。我们一般用 <span class="math display">\[\rho_P=-\nabla\cdot P\]</span> 求出极化电荷分布，然后把极化电荷当成电荷，用已知电荷求场的思路解决问题。</p></li><li><p>非永久极化问题</p><p>这时候一般用分离变量法求出场分布，然后再用<span class="math inline">\(D=\varepsilon E\)</span>求出电位移矢量，然后进一步求解极化电荷等等。</p></li></ol><h3 id="磁化">磁化</h3><p>这里只介绍磁荷模型，因为它可以导出电磁对偶关系。</p><h4 id="磁化强度矢量">磁化强度矢量</h4><p><span class="math display">\[M=\lim_ { \Delta V\to0 } \frac { \sum_ { i=1 } ^N m_i }  { \Delta V } \]</span></p><p>由电磁对偶关系（这里是<span class="math inline">\(\mu_0M\)</span>和<span class="math inline">\(P\)</span>对偶），就能直接得出：</p><p>磁荷密度： <span class="math display">\[\rho_M=-\nabla\cdot\mu_0M\]</span> 磁流密度： <span class="math display">\[J_M=\frac {   { \bf d }   }   {   {  \bf d  }  t  }  (\mu_0M)\]</span> 定义磁感应强度<span class="math inline">\(B\)</span>: <span class="math display">\[B=\mu_0(1+\chi_m)H=\mu H\]</span></p><h4 id="磁化与电磁感应定律">磁化与电磁感应定律</h4><p><span class="math display">\[\nabla \times E=-\frac { \partial B }  { \partial t } \]</span></p><p>积分形式： <span class="math display">\[\oint_cE  {  \bf d  }  s=-\frac {  { \bf d }  }  {  { \bf d } t } \iint_sB { \bf d } a\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220627-20220703）</title>
    <link href="/2022/06/27/%E5%91%A8%E8%AE%B0%EF%BC%8820220627-20220703%EF%BC%89/"/>
    <url>/2022/06/27/%E5%91%A8%E8%AE%B0%EF%BC%8820220627-20220703%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><hr /><h2 id="section">20220627</h2><p>今天应该是基本结束了信号的复习，接下来只需要刷题就好了。</p><p>其实我以及开始畅想暑假要学什么，玩什么，下学期要学什么，玩什么了，哈哈哈。</p><h2 id="section-1">20220628</h2><p>今天继续刷信号的题，把信号的试卷出完了。</p><p>今天随机到了珂朵莉的ed，使我又回忆起了高中的生活。也不知道将来刷到哪首歌时，会让我回忆起现在的生活呢？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/C17FFB52A07BBB3E64407394300FB095.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>自从你航换了个党委书记以来，算是一天比一天阳间了，搞得我都想劝人报北航了，哈哈</p><h2 id="section-2">20220629</h2><p>完全不知道信号怎么复习，很恼怒。原因在于课本习题没答案。为什么习题会没有答案呢？没有答案的习题有什么意义呢？这不是管杀不管埋吗？世界上所有不带答案的习题都应该被扫进历史的垃圾篓。</p><p>今天在学校吃了个盖浇面，我其实很少在学校吃面，值得纪念。 <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/CC40121BE2038415C8AB4FAF54B42184.jpg" alt="img" /></p><p>相合之物还挺好看的，舒缓温馨，适合睡前看。</p><h2 id="section-3">20220630</h2><p>今天是疯狂星期四，大吃了一顿，爽。 <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/D464DF8998ED4A290E615EBA0C2003D1.jpg" alt="img" /></p><p>哎我真是服了这个2系，真是有意思，一个是你个线上虚拟仿真实验还要手写报告，还要把电路图打印下来再拍照上传？脱裤子放屁？？你说<span class="math inline">\(m\)</span>倍的以<span class="math inline">\(10\)</span>为底<span class="math inline">\(b\)</span>的对数呢？</p><p>一个是你考试，还不让用北航信纸，还非得用A4纸，还每页都得写《本人已知悉并将遵守.......相关内容》</p><p>对对对，还不让我扔期末答题纸，说是《开学上交》，真无语</p><h2 id="section-4">20220701</h2><p>放假咯！！</p><p>清华今天改了报备制，你航明天改，所以说</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/035D82F0B81D23332666DC2700B53EC1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><span class="math display">\[\text{北航}=\text{清华}\bigotimes \delta(t-1)\]</span></p><p>你航封了两个月，终于解封了，不知道这次能坚持多久。</p><h2 id="section-5">20220702</h2><p>哎，今天西安怎么突然出来一个阳性？本来还想带朋友来西安玩的......希望能快点好起来。</p><p>今天看完了《大决战》第一部，明天继续看第二部。</p><p>过两天，或者明天，试一下<code>Hugo</code></p><h2 id="section-6">20220703</h2><p>今天看完了大决战第二部，淮海战役。</p><p>今天换了个博客框架，感觉还挺好看的。</p><p><code>PicGO</code>的日志文件竟然有30G大，嫩逆天，不知道怎么搞的。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于傅里叶变换的那些事</title>
    <link href="/2022/06/27/%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/27/%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>所谓的变换，也就是信号的正交分解。如果两个函数的内积为<span class="math inline">\(0\)</span>，我们称为这两个函数正交。那么对于任意信号<span class="math inline">\(f(t)\)</span>，都可以写成一组正交函数系的和的形式（可以对比正交向量理解），这就是信号的正交分解。通过正交分解，可以对信号的特性有进一步的认识，也可以简化信号的分析和计算。</p><span id="more"></span><h2 id="傅里叶级数">傅里叶级数</h2><p>傅里叶级数是 <strong>周期信号</strong> 基于正交函数系<span class="math inline">\(\{e^{j\omega t}\}\)</span>的正交分解。</p><h3 id="三角函数形式的傅里叶级数">三角函数形式的傅里叶级数</h3><p>三角函数形式的傅里叶级数就是我们最熟悉的傅里叶级数。对于满足以下条件的函数<span class="math inline">\(f(t)\)</span>:</p><ul><li>周期函数，周期为<span class="math inline">\(T_1\)</span>，角频率为<span class="math inline">\(\omega_1=2\pi/T_1\)</span></li><li>间断点个数有限（可数）</li><li>极大极小值个数有限（可数）</li><li>绝对可积</li></ul><p>有： <span class="math display">\[f(t)=a_{0}+\sum_{n=1}^{\infty}\left(a_{n} \cos n \omega_{1} t+b_{n} \sin n \omega_{1} t\right)\]</span> 其中<span class="math inline">\(a_0\)</span>叫直流分量，<span class="math inline">\(a_n\)</span>叫<span class="math inline">\(n\)</span>次谐波余弦分量，<span class="math inline">\(b_n\)</span>叫<span class="math inline">\(n\)</span>次谐波正弦分量。有计算公式： <span class="math display">\[a_0=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \mathrm{d} t\]</span></p><p><span class="math display">\[a_n=\frac{2} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \cos n \omega_{1} t \mathrm{~d} t\]</span></p><p><span class="math display">\[b_n=\frac{2} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \sin n \omega_{1} t \mathrm{~d} t\]</span></p><p>当然，也可通过和差化积公式，转换成只有正弦或余弦分量的形式，此处不再赘述。</p><p>有： <span class="math display">\[a_n=a_{-n},-b_n=b_{-n}\]</span></p><h3 id="指数形式傅里叶级数">指数形式傅里叶级数</h3><p>因为： <span class="math display">\[\sin x=\frac{1} {2j}(e^{jx}-e^{-jx})\]</span></p><p><span class="math display">\[\cos x=\frac 12 (e^{jx}+e^{-jx})\]</span></p><p>代入三角函数形式傅里叶级数中，就能得到指数形式傅里叶级数。这里给出部分关键步骤供参考。 <span class="math display">\[\begin{aligned}f(t)&amp;=a_{0}+\sum_{n=1}^{\infty}\left(a_{n} \cos n \omega_{1} t+b_{n} \sin n \omega_{1} t\right)\\\\&amp;=a_{0}+\sum_{n=1}^{\infty}\left(\frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t}+\frac{a_{n}+j b_{n} } {2} e^{-j n \omega_{1} t}\right)\\\\&amp;=a_{0}+\sum_{n=1}^{\infty} \frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t}+\sum_{n=-\infty}^{-1} \frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t} &amp; a_n=a_{-n},-b_n=b_{-n}\\\\&amp;=\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\end{aligned}\]</span> 其中 <span class="math display">\[F\left(n \omega_{1}\right)=\begin{cases}a_{0}, &amp; n=0 \\\\ \frac{a_{n}-j b_{n} } {2}, &amp; n \neq 0\end{cases}\]</span> 即 <span class="math display">\[F(n\omega_1)=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) e^{-j n \omega_{1} t} \mathrm{d} t\]</span> 可以看出，<span class="math inline">\(F\left(n \omega_{1}\right)\)</span>一般而言是一个复数。它的模长和幅角满足： <span class="math display">\[|F\left(n \omega_{1}\right)|=\frac 12 \sqrt{a_n^2+b_n^2}\]</span></p><p><span class="math display">\[\tan \varphi_n=-\frac{b_n} {a_n}\]</span></p><h3 id="函数的对称性和傅里叶级数">函数的对称性和傅里叶级数</h3><p>因为<span class="math inline">\(\cos\)</span>是偶函数，<span class="math inline">\(\sin\)</span>是奇函数，所以函数本身的奇偶对称性和傅里叶系数的奇偶对称性有关系。</p><table><thead><tr class="header"><th style="text-align: center;">信号</th><th style="text-align: center;"><span class="math inline">\(a_n\)</span></th><th style="text-align: center;"><span class="math inline">\(b_n\)</span></th><th style="text-align: center;"><span class="math inline">\(F(n\omega_1)\)</span></th><th style="text-align: center;"><span class="math inline">\(\varphi_n\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">奇函数</td><td style="text-align: center;">0</td><td style="text-align: center;">不为0</td><td style="text-align: center;">纯虚数</td><td style="text-align: center;"><span class="math inline">\(\pm \pi/2\)</span></td></tr><tr class="even"><td style="text-align: center;">偶函数</td><td style="text-align: center;">不为0</td><td style="text-align: center;">0</td><td style="text-align: center;">实数</td><td style="text-align: center;"><span class="math inline">\(\pm \pi\)</span></td></tr><tr class="odd"><td style="text-align: center;">奇谐函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="在一个周期里的两个半周期里呈现奇对称的函数，即$f(t)=-f(t\pm \frac T2)$​">[1]</span></a></sup></td><td style="text-align: center;">只含奇次谐波</td><td style="text-align: center;">只含奇次谐波</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td></tr><tr class="even"><td style="text-align: center;">偶谐函数</td><td style="text-align: center;">只含直流分量和偶次谐波</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td></tr></tbody></table><p>我们需要注意到：一个“偶谐函数”，和一个周期为<span class="math inline">\(T_1/2\)</span>的函数，实质上是一回事。</p><h3 id="从傅里叶级数看傅里叶变换">从傅里叶级数看傅里叶变换</h3><p>傅里叶级数只能描述周期函数。但是我如果非得描述非周期函数，又会怎么样呢？我们来考虑一下怎么把非周期函数强行变成周期函数，其实只需要让周期<span class="math inline">\(T\)</span>趋向于无穷大就好了。</p><p>对于 <span class="math display">\[F(n\omega_1)=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) e^{-j n \omega_{1} t} \mathrm{d} t\]</span> 让<span class="math inline">\(T\)</span>趋向于无穷大，则<span class="math inline">\(\omega\)</span>趋向于无穷小。因为函数满足绝对可积条件，所以右边是一个有限值比无穷大，趋向于0。而左边因为<span class="math inline">\(\omega\)</span>趋向于无穷小，取值点趋向于连续。有没有发现，这个过程有一点点像随机变量从连续型变成离散型时，分布列的变化情况（一方面，取值趋向于无穷小；另一方面，自变量趋向于连续）。于是，类似于“概率论”的知识，我们也可以定义“频谱密度函数”，让<span class="math inline">\(n\omega_1\to\omega\)</span>，有 <span class="math display">\[F(\omega)=\int_{-\infty}^\infty f(t)e^{-j\omega t}\mathrm{d}t\]</span> 这就是我们常说的傅里叶变换。</p><h2 id="傅里叶变换">傅里叶变换</h2><h3 id="傅里叶变换的定义式">傅里叶变换的定义式</h3><p><span class="math display">\[F(\omega)=\int_{-\infty}^\infty f(t)e^{-j\omega t}\mathrm{d}t\]</span></p><h3 id="基本信号及其傅里叶变换">基本信号及其傅里叶变换</h3><ol type="1"><li><p>矩形脉冲信号（门信号）</p><p>即： <span class="math display">\[G_N(t)=\begin{cases}1 &amp; |t|&lt;N\\\\0 &amp; |t|&gt;N\end{cases}\]</span> 有： <span class="math display">\[\mathscr{F}[G_N(t)]=2N\mathrm{Sa}(\omega N)\]</span></p></li><li><p>单边指数信号 <span class="math display">\[f_1(t)=\begin{cases}e^{-at} &amp; t\geq 0\\\\0 &amp; \text{others}\end{cases}\]</span> 则 <span class="math display">\[\mathscr{F}[f_1(t)]=\frac {1} {a+j\omega}\]</span> 类似地， <span class="math display">\[f_2(t)=\begin{cases}0 &amp; t\geq 0\\\\e^{bt} &amp; t&lt;0\end{cases}\]</span> 则 <span class="math display">\[\mathscr{F}[f_2(t)]=\frac 1{b-j\omega}\]</span></p></li><li><p>“偶”双边指数信号</p><p>把前面两个单边指数信号加起来就行了。 <span class="math display">\[f(t)=e^{-a|t|}\]</span> 则 <span class="math display">\[\mathscr{F}\left[e^{-a|t|}\right]=\frac{2a} {a^2+\omega^2}\]</span></p></li><li><p>符号函数 <span class="math display">\[\text{sgn}(t)=\begin{cases}1 &amp; t&gt;0\\\\0 &amp; t=0\\\\-1 &amp; t&lt;0\end{cases}\]</span> 为求符号函数的傅里叶变换，先求“奇双边指数函数”的傅里叶变换，然后让指数系数趋向于0即可。</p><p>奇双边指数函数，即 <span class="math display">\[f(t)=\begin{cases}e^{-at} &amp;t&gt;0\\\\-e^{-at} &amp; t&lt;0\end{cases}\]</span></p><p><span class="math display">\[\mathscr{F}[f(t)]=\frac{-2j\omega} {a^2+\omega^2}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220627114355617.png" alt="image-20220627114355617" /><figcaption aria-hidden="true">image-20220627114355617</figcaption></figure><p>当<span class="math inline">\(a\to0\)</span>时，这个函数就趋向于<span class="math inline">\(\text{sgn}(t)\)</span>。如图是<span class="math inline">\(a=0.01\)</span>的图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220627114553417.png" alt="image-20220627114553417" /><figcaption aria-hidden="true">image-20220627114553417</figcaption></figure><p>则有： <span class="math display">\[\mathscr{F}[\text{sgn}(t)]=\frac 2{j\omega}\]</span></p></li><li><p>冲激信号 <span class="math display">\[\mathscr{F}[\delta(t)]=1\]</span></p></li><li><p>阶跃信号 <span class="math display">\[\mathscr{F}[u(t)]=\pi \delta(\omega)+\frac 1{j\omega}\]</span> 这个结果可以通过符号函数平移得到。</p></li></ol><h3 id="傅里叶变换的性质">傅里叶变换的性质</h3><p>如果有： <span class="math display">\[\mathscr F[f(t)]=F(\omega)\]</span> 则有：</p><h4 id="基于定义的性质">基于定义的性质</h4><ol type="1"><li><p>对称性 <span class="math display">\[\mathscr F[F(t)]=2\pi f(-\omega)\]</span></p></li><li><p>奇虚偶实性</p><ul><li><span class="math inline">\(|F(\omega)|\)</span>是偶函数</li><li><span class="math inline">\(\varphi(\omega)\)</span>是奇函数</li><li>如果<span class="math inline">\(f(t)\)</span>是实偶函数，则<span class="math inline">\(F(\omega)\)</span>是实偶函数</li><li>如果<span class="math inline">\(f(t)\)</span>是实奇函数，则<span class="math inline">\(F(\omega)\)</span>是虚奇函数</li></ul></li></ol><h4 id="基于时间运算的性质">基于时间运算的性质</h4><ol type="1"><li><p>反褶性质 <span class="math display">\[\mathscr F[f(-t)]=F(-\omega)=F^*(\omega)\]</span></p></li><li><p>时移性质 <span class="math display">\[\mathscr F[f(t-t_0)]=F(\omega)e^{-j\omega t_0}\]</span> 可以说：时移不改变幅频特性，而改变相频特性。</p></li><li><p>压扩性质 <span class="math display">\[\mathscr F[f(at)]=\frac 1{|a|}F\left(\frac \omega a\right)\]</span> 对于频域带限信号，时域的压缩和扩展，会导致频谱范围的增大和减小，频率分量的减少和增加。</p></li><li><p>时域综合性质 <span class="math display">\[\mathscr F[f(at+b)]=\frac 1{|a|}F\left(\frac \omega a\right)e^{j\omega\frac ba}\]</span></p></li><li><p>线性</p></li><li><p>时域微分性质 <span class="math display">\[\mathscr F[f&#39;(t)]=j\omega F(\omega)\]</span> 进一步： <span class="math display">\[\mathscr F[f^{(n)}(t)]=(j\omega)^nF(\omega)\]</span> 因为函数加上任意常数后，微分都相同。在运用这个性质时，要把信号的直流分量提取出来单独处理。例如：尝试利用时域微分性质和线性性质分别由<span class="math inline">\(\text{sgn}(t)\)</span>函数的傅里叶变换计算<span class="math inline">\(u(t)\)</span>的傅里叶变换，并比较结果。</p></li><li><p>时域积分性质 <span class="math display">\[\mathscr F\left[\int_{-\infty}^t f(\tau)\mathrm d\tau\right]=\frac {F(\omega)} {j\omega}+\pi F(0)\delta(\omega)\]</span></p></li></ol><h4 id="基于频域运算的性质">基于频域运算的性质</h4><ol type="1"><li><p>频移性质 <span class="math display">\[\mathscr F[f(t)e^{j\omega_0 t}]=F(\omega-\omega_0)\]</span></p></li><li><p>频域微分-时域线性加权性质 <span class="math display">\[\mathscr F[t^nf(t)]=j^n \frac{\mathrm d^nF(\omega)} {\mathrm d \omega^n}\]</span></p></li></ol><h4 id="卷积性质">卷积性质</h4><ol type="1"><li><p>时域卷积 <span class="math display">\[\mathscr F[f_1(t)\bigotimes f_2(t)]=F_1(\omega)F_2(\omega)\]</span></p></li><li><p>频域卷积 <span class="math display">\[\mathscr F[f_1(t)f_2(t)]=\frac 1{2\pi}F_1(\omega)\bigotimes F_2(\omega)\]</span></p></li></ol><h3 id="由变换的性质计算常用信号的傅里叶变换">由变换的性质计算常用信号的傅里叶变换</h3><ol type="1"><li><p>直流信号<span class="math inline">\(E\)</span></p><p>由 <span class="math display">\[\mathscr F[\delta(t)]=1\]</span> 因对称性，有： <span class="math display">\[\mathscr F[1]=2\pi \delta(\omega)\]</span> 因线性，有： <span class="math display">\[\mathscr F[E]=2\pi E\delta(\omega)\]</span></p></li><li><p><span class="math inline">\(f(t)=1/t\)</span></p><p>由 <span class="math display">\[\mathscr F[\text{sgn} (t)]=\frac 2{j\omega}\]</span> 因对称性，有： <span class="math display">\[\mathscr F\left[\frac 2{jt}\right]=2\pi\text{sgn}(-\omega)\]</span> 因线性，有： <span class="math display">\[\mathscr F\left[\frac 1 t\right]=-j\pi\text{sgn}(\omega)\]</span></p></li><li><p>正余弦信号</p><p>由 <span class="math display">\[\mathscr F[1]=2\pi\delta(\omega)\]</span> 因频移性质，有： <span class="math display">\[\mathscr F[e^{j\omega_0t}]=2\pi\delta(\omega-\omega_0)\\\\\mathscr F[e^{-j\omega_0t}]=2\pi\delta(\omega+\omega_0)\\\\\]</span> 因三角函数分解公式： <span class="math display">\[\sin \omega_0t=\frac{1} {2j}(e^{j\omega_0t}-e^{-j\omega_0t})\\\\\cos \omega_0t=\frac 12 (e^{j\omega_0t}+e^{-j\omega_0t})\]</span> 有： <span class="math display">\[\mathscr F[\sin(\omega_0 t)]=-j\pi [\delta(\omega-\omega_0)-\delta(\omega+\omega_0)]\\\\\mathscr F [\cos(\omega_0 t)]=\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]\]</span></p></li><li><p>三角脉冲信号</p><p>定义三角脉冲信号<span class="math inline">\(T_\tau(t)\)</span>为形如下面的信号，计算傅里叶变换。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/2BED7AAC8763AB14671045D511389210.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由 <span class="math display">\[\mathscr F[G_N(t)]=2N\text{Sa}(N\omega)\]</span> 则三角脉冲信号<span class="math inline">\(T_\tau(t)\)</span>是门信号的卷积，具体地： <span class="math display">\[T_\tau(t)=\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\bigotimes\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\]</span> 由于 <span class="math display">\[\mathscr F\left[\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\right]=\sqrt{\tau}\text{Sa}\left(\frac \tau2\omega\right)\]</span> 和卷积性质，有： <span class="math display">\[\mathscr F[T_\tau(t)]=\tau\text{Sa}^2\left(\frac \tau2 \omega\right)\]</span></p></li></ol><p>现将常用信号的傅里叶变换归纳如下：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(f(t)\)</span></th><th style="text-align: center;"><span class="math inline">\(F(\omega)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\delta(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\delta (t-t_0)\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{-j\omega t_0}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(2\pi\delta(\omega)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{j\omega_0t}\)</span></td><td style="text-align: center;"><span class="math inline">\(2\pi\delta(\omega-\omega_0)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\pi\delta(\omega)-\frac 1{j\omega}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(sgn(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac 2{j\omega}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\cos(\omega_0t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sin(\omega_0t)\)</span></td><td style="text-align: center;"><span class="math inline">\(-j\pi [\delta(\omega-\omega_0)-\delta(\omega+\omega_0)]\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(e^{-a\|t\|}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{2a} {a^2+\omega^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(G_N(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(2NSa(N\omega)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_\tau(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\tau\text{Sa}^2\left(\frac \tau2 \omega\right)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-at}u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {j\omega+a}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1/t\)</span></td><td style="text-align: center;"><span class="math inline">\(-j\pi\text{sgn}(\omega)\)</span></td></tr></tbody></table><p>这里提出一个趣味问题：</p><blockquote><p>【例】：是否存在一个时域、频域都有限的信号？</p><p>【解】：不存在。如果时域有限，则信号可以表示为： <span class="math display">\[f(t)=f(t)G_N(t-t_0)\]</span> 而<span class="math inline">\(G_N(t)\)</span>的傅里叶变换的频带是无限的。卷积之后，频带也是无限长的。频域有限情况同理可知。</p></blockquote><h3 id="周期信号的傅里叶变换">周期信号的傅里叶变换</h3><p>在之前，我们研究的是周期信号的傅里叶级数，和非周期信号的傅里叶变换。现在为了把它们都纳入傅里叶分析的框架中，我们要讨论周期信号的傅里叶变换。</p><p>我们都知道，周期信号的傅里叶系数<span class="math inline">\(F(n\omega)\)</span>叫“频谱函数”，而非周期信号的傅里叶变换<span class="math inline">\(F(\omega)\)</span>叫“频谱密度函数”。那么如果我们非要用频谱密度函数来表示频谱函数，那么结果应该是出现在其角频率各次谐波处的冲激函数。（请联想概率论中，如果我们非要用“概率密度函数”来表示离散分布的“分布函数”，那么会出现什么现象？）</p><p>周期函数的傅里叶系数和它一个周期内函数的傅里叶变换的关系为：</p><p><span class="math display">\[F(n\omega_1)=\left.\frac 1{T_1}F_1(\omega)\right|_{\omega=n\omega_1}\]</span></p><p>对于周期函数的傅里叶级数</p><p><span class="math display">\[f(t)=\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\]</span></p><p>作傅里叶变换：</p><p><span class="math display">\[\mathscr F\left[\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\right]=\sum_{n=-\infty}^{\infty}F(n\omega_1)\mathscr F[e^{jn\omega_1 t}]\]</span></p><p>由于频移性质：</p><p><span class="math display">\[\mathscr F [e^{jn\omega_1 t}]=2\pi\delta(\omega-n\omega_1)\]</span></p><p>故：</p><p><span class="math display">\[\mathscr F[f(t)]=\mathscr F\left[\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\right]=2\pi\sum_{n=-\infty}^{\infty}F(n\omega_1)\delta(\omega-n\omega_1)\]</span></p><p>这就是一般周期信号的傅里叶变换。</p><h4 id="典型周期信号的傅里叶变换">典型周期信号的傅里叶变换</h4><ol type="1"><li><p>正余弦信号</p><p>正余弦信号的傅里叶变换我们之前已经求过了。现在我们可以从一个新的视角来考虑这个问题。对于余弦信号而言，有：</p><p><span class="math display">\[\cos(\omega_1 t)=\frac 12(e^{j\omega_1 t}+e^{-j\omega_1t})\]</span></p><p>则其傅里叶级数的系数为：</p><p><span class="math display">\[F(n\omega_1)|_{n=\pm 1}=\frac 12\]</span></p><p>则其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[\cos(\omega_1 t)]=\pi[\delta(\omega-\omega_1)+\delta(\omega+\omega_1)]\]</span></p></li><li><p>周期冲激信号</p><p>周期冲激信号经常被用来采样，所以也算是一个常用的信号。我们来看一下它的傅里叶变换。</p><p>周期冲激信号的定义是：</p><p><span class="math display">\[\delta_{T_1}(t)=\sum_{n=-\infty}^{\infty}\delta(t-nT_1)\]</span></p><p>其傅里叶系数为：</p><p><span class="math display">\[F(n\omega_1)=\left.\frac 1{T_1}F_1(\omega)\right|_{\omega=n\omega_1}=\frac1{T_1}\]</span></p><p>则其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[\delta_{T_1}(t)]=\frac {2\pi} {T_1}\sum_{n=-\infty}^\infty \delta(\omega-n\omega_1)=\omega_1\sum_{n=-\infty}^\infty \delta(\omega-n\omega_1)\]</span></p><p>可以看出：周期冲激信号的傅里叶变换也是周期冲激信号。</p></li><li><p>周期矩形脉冲信号</p><p>周期矩形脉冲信号有两个参数：周期<span class="math inline">\(T_1\)</span>，脉宽<span class="math inline">\(\tau\)</span>，即：<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/AFA6FB4DBB59084944CDA2465162854F.png" alt="img" /></p><p>记作：<span class="math inline">\(G_{T_1,\tau}(t)\)</span>，图中<span class="math inline">\(E=1\)</span>.</p><p>在一个周期中，其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[G_{0,\tau}(t)]=\tau\text{Sa}\left(\frac{\omega\tau} {2}\right)\]</span></p><p>则周期矩形脉冲的傅里叶系数为</p><p><span class="math display">\[F(n\omega_1)=\frac{\tau} {T_1}\text{Sa}\left(\frac{n\omega_1\tau} {2}\right)\]</span></p><p>故周期矩形脉冲的傅里叶变换为</p><p><span class="math display">\[\tau\omega_1\sum_{n=-\infty}^{\infty}\text{Sa}\left(\frac{n\omega_1\tau} {2}\right)\delta(\omega-n\omega_1)\]</span></p></li></ol><h3 id="抽样">抽样</h3><p>一个基本的抽样过程等效于以下的模型：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/BEE55B4CEAA391E54CF074AFBC5F30B1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里的"<span class="math inline">\(\bigotimes\)</span>"是乘法的意思。即有：</p><p><span class="math display">\[f_s(t)=f(t)p(t)\]</span></p><p>这里的<span class="math inline">\(p(t)\)</span>就是脉冲信号，比如说周期冲激信号，周期矩形脉冲信号等等。</p><p>利用傅里叶变换的卷积定理，有（这里要熟练掌握冲激函数的卷积性质）：</p><p><span class="math display">\[\mathscr F[f_s(t)]=\frac 1{T_s}\sum_{n=-\infty}^{\infty}P_0(n\omega_s)F(\omega-n\omega_s)\]</span></p><p>也就是说，抽样信号的频谱是连续信号频谱以<span class="math inline">\(\omega_s\)</span>为周期的周期延拓，并收到脉冲信号频谱<span class="math inline">\(P_0(n\omega_s)\)</span>和脉冲信号周期<span class="math inline">\(T_s\)</span>的加权。</p><p>于是，我们发现，如果要求不发生频域混叠，那么原始连续信号必须在频域是带限信号。但是这实际上是不可能存在的。但是信号的主要频域往往确实是有限的，其它部分的分量可以忽略不计，为此我们可以定义<span class="math inline">\(-3\text{dB}\)</span>带宽，零点带宽等带宽（记作<span class="math inline">\(\omega_m\)</span>），把信号近似为一个频域带限信号。</p><p>那么，一个带限信号<span class="math inline">\(f(t)\)</span>,如果其频谱存在在频域区间<span class="math inline">\([-\omega_m,\omega_m]\)</span>，则可用抽样值唯一表示<span class="math inline">\(f(t)\)</span>,抽样值的间隔不能大于<span class="math inline">\(T_s=\frac{1} {2f_m}\)</span>,其中<span class="math inline">\(f_m=\frac{\omega_m} {2\pi}\)</span>，否则会发生频域混叠，这就是奈奎斯特采样定理。我们把<span class="math inline">\(f_s=2f_m\)</span>称作“奈奎斯特频率”，这是不发生频域混叠的最小抽样频率。</p><p>为了从抽样信号中恢复出原始信号，对理想冲激抽样，我们用一个截止频率为<span class="math inline">\(\omega_c\)</span>，幅度增益为<span class="math inline">\(T_s\)</span>的零延时低通滤波器即可，其中<span class="math inline">\(\omega_c\)</span>满足<span class="math inline">\(\omega_c\in[\omega_m,\omega_s-\omega_m]\)</span>.对于理想矩形脉冲抽样，滤波器的幅度增益应为<span class="math inline">\(T_s/(E\tau)\)</span></p><h2 id="连续系统实频域分析">连续系统实频域分析</h2><p>所谓的连续系统实频域分析，也就是利用傅里叶变换来分析连续系统。在本节，将首先介绍系统传递函数的概念，再介绍一类比较理想的系统：无失真系统，然后分析一类具体的系统：低通滤波器。</p><h3 id="系统频率响应">系统频率响应</h3><p>定义系统单位冲激响应<span class="math inline">\(h(t)\)</span>的傅里叶变换为系统频率响应。即：</p><p><span class="math display">\[H(\omega)=\int_{-\infty}^\infty h(t)e^{-j\omega t}\mathrm d t\]</span></p><p>如果系统的激励为<span class="math inline">\(e(t)\)</span>,激励的傅里叶变换为<span class="math inline">\(E(\omega)\)</span>，那么对系统的响应的傅里叶变换，有：</p><p><span class="math display">\[R(\omega)=E(\omega)\cdot H(\omega)\]</span></p><p>如果系统输入的是复指数信号<span class="math inline">\(e^{j\omega_0 t}\)</span>，那么有：</p><p><span class="math display">\[R=2\pi\delta(\omega-\omega_0)H(\omega)\]</span></p><p>则有：</p><p><span class="math display">\[r(t)=\frac 1{2\pi}\int_{-\infty}^{\infty}2\pi\delta(\omega-\omega_0)H(\omega)e^{j\omega t}\mathrm d t=e^{j\omega_0t}H(\omega_0)\]</span></p><p>这说明：系统对不同频率的正弦信号的幅度和相位加权不相同；不同的系统对相同频率的正弦信号的幅度和相位的加权也不相同。</p><p>对于频率响应<span class="math inline">\(H(\omega)\)</span>，称<span class="math inline">\(|H(\omega)|\)</span>为系统的幅频响应，而<span class="math inline">\(\varphi(\omega)\)</span>为系统的相频响应。</p><p>如果系统用微分方程</p><p><span class="math display">\[C_0r^{(n)}(t)+C_1r^{(n-1)}(t)+\cdots+C_nr(t)=E_0e^{(m)}(t)+E_1e^{(m-1)}(t)+\cdots+E_me(t)\]</span></p><p>可以直接写出其频率响应：</p><p><span class="math display">\[H(\omega)=\frac{\sum_{i=0}^nC_i(j\omega)^{n-i} } {\sum_{j=1}^m E_{j}(j\omega)^{m-j} }\]</span></p><p>在已知频率响应和激励，求系统响应时，一般有两种思路。其一是系统激励以傅里叶级数形式给出，这时只需要针对每个谐波分量计算对应的幅频响应和相频响应，然后把响应作用于激励即可。另一种思路是先求出激励的傅里叶变换，然后用图像和系统频率响应相乘，得到响应的傅里叶变换，最后得到结果。</p><h3 id="无失真系统">无失真系统</h3><p>输出响应能再现系统的输入，只有出现时刻和幅度不同，即没有改变输入波形的形状，这种系统叫做无失真系统。那么把冲激信号输入系统，就可以得到无失真系统的频响：</p><p><span class="math display">\[H(\omega)=ke^{-j\omega t_0}\]</span></p><p>则其幅频，相频特性如下：</p><p><span class="math display">\[|H(\omega)|=k\\\\\varphi(\omega)=-\omega t_0\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/33FCDB8A45A057AE5F76B35B9A69EBCE.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>相频特性是一条直线的含义是：相频特性表示了系统的延时，对信号的所有频率分量，应该有相同的延时，即相位附加值相同。例如输入<span class="math inline">\(E_1\sin(\omega_1t)\)</span>，那么理应得到输出<span class="math inline">\(E_1\sin\left[\omega(t+\varphi(\omega))\right]=E_1\sin\left[\omega(t+\frac{\varphi(\omega)} {\omega})\right]\)</span>，于是，为了对不同的频率分量得到相同的附加相移，就需要：</p><p><span class="math display">\[\forall \omega_1,\omega_2,\frac{\varphi(\omega_1)} {\omega_1}=\frac{\varphi(\omega_2)} {\omega_2}\]</span></p><h3 id="低通滤波器">低通滤波器</h3><p>理想滤波器是在特定频段范围内的无失真传输系统。这里之所以只讨论低通滤波器，是其它滤波器可以由低通滤波器转换而来。具体如何转换，我们后面再说。</p><p>理想低通滤波器的频响特性如下：</p><p><span class="math display">\[H(\omega)= \begin{cases}e^{-j \omega t_{0} } &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p>注意，切不可以以为理想低通滤波器的频响函数是频域门函数，因为还要考虑附加相移（时域延迟）。有：</p><p><span class="math display">\[|{H}(\omega)|= \begin{cases}1 &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p><span class="math display">\[\varphi(\omega)= \begin{cases}-\omega t_{0} &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p>对频响函数作傅里叶逆变换，可得单位冲激响应：</p><p><span class="math display">\[h(t)=\frac{\omega_{c} } {\pi} \cdot \text{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right]\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/DF189DDD56F929706856BF8B26DA1D67.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="其它滤波器">其它滤波器</h4><ul><li><p>高通滤波器</p><p>无失真全通系统-低通滤波器=高通滤波器。因而，有：</p><p><span class="math display">\[H_{h}(\omega)=e^{-\mathrm{j} \omega t_{0} }\left[1-u\left(\omega+\omega_{c}\right)+u\left(\omega-\omega_{c}\right)\right]\]</span></p><p><span class="math display">\[h_{h}(t)=\delta\left(t-t_{0}\right)-h_{l}(t)=\delta\left(t-t_{0}\right)-\frac{\omega_{c} } {\pi} \cdot \mathrm{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right]\]</span></p></li><li><p>带通滤波器</p><p>带通滤波器可以由理想低通滤波器频响向两侧搬移，再对相频特性进行修正得到。</p><p><span class="math display">\[H_{b}(\omega)=e^{-\mathrm{j} \omega_{0} }\left[\left(u\left(\omega+\omega_{h}\right)-u\left(\omega+\omega_{l}\right)\right)+\left(u\left(\omega-\omega_{l}\right)-u\left(\omega-\omega_{h}\right)\right)\right]\]</span></p><p><span class="math display">\[h_{b}(t)=\frac{2 \omega_{c} } {\pi} \cdot \operatorname{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right] \cos \left[\omega_{0}\left(t-t_{0}\right)\right]\]</span></p><p>其中</p><p><span class="math display">\[\omega_{c}=\frac{\omega_{h}-\omega_{l} } {2}, \omega_{0}=\frac{\omega_{h}+\omega_{l} } {2}\]</span></p></li></ul><h3 id="系统的因果性">系统的因果性</h3><p>我们都知道，<span class="math inline">\(LTI\)</span>系统因果的充要条件是：</p><p><span class="math display">\[h(t)=h(t)u(t)\]</span></p><p>现在我们从频域考虑这个问题。</p><h4 id="佩里维纳准则">佩里维纳准则</h4><p>一个幅频响应绝对可积的系统物理可实现的必要条件是：</p><p><span class="math display">\[\int_{-\infty}^{\infty}\frac{|\ \ln|H(\omega)|\ |} {1+\omega^2}\mathrm d\omega&lt;\infty\]</span></p><p>从直观角度考虑，佩里维纳准则要求系统的幅频响应不能衰减得太快。特别的，如果幅频响应在某个连续频带上为<span class="math inline">\(0\)</span>，那么系统就不可实现。</p><h4 id="希尔伯特变换">希尔伯特变换</h4><p>接下来从时域入手，讨论判断系统因果性的充要条件。</p><p>从用卷积性质计算<span class="math inline">\(h(t)u(t)\)</span>的傅里叶变换入手，设<span class="math inline">\(H(\omega)=R(\omega)+jX(\omega)\)</span>，那么<span class="math inline">\(R,X\)</span>构成一希尔伯特变换对。所谓的希尔伯特变换是指：</p><p><span class="math display">\[\hat{x}(t)=\mathscr H[x(t)]=x(t)\bigotimes\frac1{\pi t}\]</span></p><p>把卷积展开，有：</p><p><span class="math display">\[\begin{aligned}\hat{x}(t) &amp;=\frac{1} {\pi} \int_{-\infty}^{\infty} x(\tau) \frac{1} {t-\tau} d \tau \\\\&amp;=-\frac{1} {\pi} \int_{-\infty}^{\infty} x(t+\tau) \frac{1} {\tau} d \tau \\\\&amp;=\frac{1} {\pi} \int_{-\infty}^{\infty} x(t-\tau) \frac{1} {\tau} d \tau\end{aligned}\]</span></p><p>对一个系统作希尔伯特变换，实质上是将其经过一个<span class="math inline">\(\pi/2\)</span>相移器（注意：这里不是时移）。</p><p>希尔伯特变换将在《随机过程理论》中再次详细说明，这里只提两个重要性质：</p><ul><li><p><span class="math display">\[\mathscr F[\hat{x}(t)]=-j\mathscr F[x(t)]sgn(\omega)\]</span></p></li><li><p><span class="math display">\[\mathscr H[\hat{x}(t)]=-x(t)\]</span></p></li></ul><p>则系统因果的充要条件是：频响函数<span class="math inline">\(H(\omega)\)</span>的实部和虚部是一对希尔伯特变换对。</p><h3 id="相关定理以及能量和功率">相关定理，以及能量和功率</h3><p>为了动态地描述两个信号的相关关系，避免基于内积定义的相关系数所带来的种种漏洞.</p><p>对于能量信号，我们定义相关函数：</p><p><span class="math display">\[R_{12}(\tau)=\int_{-\infty}^{\infty}f_1(t)f^*_2(t-\tau)\mathrm dt\]</span></p><p>定义自相关函数：</p><p><span class="math display">\[R(\tau)=\int_{-\infty}^{\infty} f(t) f^{*}(t-\tau) d t\]</span></p><p>如果信号是功率信号，上面的积分可能不收敛。定义功率信号的相关函数：</p><p><span class="math display">\[R_{12}(\tau)=\lim _{T \rightarrow \infty} \frac{1} {T} \int_{-\frac{T} {2} }^{\frac{T} {2} } f_{1}(t) f_{2}^{*}(t-\tau) \mathrm{d} t\]</span></p><p>自相关函数：</p><p><span class="math display">\[R(\tau)=\lim _{T \rightarrow \infty} \frac{1} {T} \int_{-\frac{T} {2} }^{\frac{T} {2} } f(t) f^{*}(t-\tau) d t\]</span></p><p>在下学期学的《随机过程理论》中，我们将从期望的角度重新认识相关函数。</p><p>有“相关定理”：</p><p><span class="math display">\[\mathscr{F}\left[R_{12}(\tau)\right]=F_{1}(\omega) F_{2}^{*}(\omega)\]</span></p><p>进一步，对自相关函数：</p><p><span class="math display">\[\mathscr{F}[R(\tau)]=|F(\omega)|^{2}\]</span></p><p>联想到帕塞瓦尔定理：</p><p><span class="math display">\[\int_{-\infty}^{\infty}|f(t)|^2\mathrm d t=\int_{-\infty}^{\infty}|F(2\pi f)|^2\mathrm d f\]</span></p><p>我们可以令<span class="math inline">\(\varepsilon(\omega)=|F(\omega)|^2\)</span>为“能量密度函数”，也叫“能量谱函数”，它反映了能量在频域上的分布。则能量谱函数和能量信号自相关函数是一对傅里叶变换对。</p><p>对于功率信号，定义功率谱函数：</p><p><span class="math display">\[p(\omega)=\lim_{T\to \infty}\frac{|F_T(\omega)|^2} {T}\]</span></p><p>则功率信号的功率谱函数和自相关函数也是一对傅里叶变换对，这叫做“维纳辛钦定理”。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>在一个周期里的两个半周期里呈现奇对称的函数，即<span class="math inline">(f(t)=-f(tT2))</span>​ <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验3：离散时间系统特性分析</title>
    <link href="/2022/06/22/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A3/"/>
    <url>/2022/06/22/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A3/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第三个实验，离散时间系统特性分析</p><span id="more"></span><h2 id="实验目的">实验目的</h2><ol type="1"><li><p>深入理解单位样值相应，离散系统的频率响应的概念；</p></li><li><p>掌握通过计算机进行求得离散系统的单位样值相应，以及离散系统的频率响应的方法。</p></li></ol><h2 id="实验原理">实验原理</h2><p>对于离散系统的单位样值而言，在实际处理过程中，不可能选取无穷多项的取值。往往是选取有限项的取值，当然这里会产生一个截尾误差，但只要这个误差在相对小一个范围里，可以忽略不计。</p><p>另外，在一些实际的离散系统中，往往不是事先就能得到描述系统的差分方程的，而是通过得到系统的某些相应值，则此时系统的分析就需借助计算机的数值处理来进行，得到描述系统的某些特征，甚至进而得到描述系统的数学模型。</p><p>本实验首先给出描述系统的差分方程，通过迭代的方法求得系统的单位样值响应，进而求得该离散系统的频率响应。限于试验条件，虽然给出了系统方程，但处理的方法依然具有同样的实际意义。</p><p>具体的方法是：</p><p>1．在给定系统方程的条件下，选取激励信号为<span class="math inline">\(\delta(n)\)</span>，系统的起始状态为零状态，通过迭代法，求得系统的单位样值响应<span class="math inline">\(h(n)(n=0,1,\cdots,N)\)</span></p><p>2．利用公式 <span class="math display">\[H(e^{j\Omega})=\sum_{n=0}^Nh(n)e^{-j\Omega n},\Omega\in[0,2\pi]\]</span> 计算系统的频率响应。</p><h2 id="实验内容">实验内容</h2><h3 id="求单位样值响应">求单位样值响应</h3><p>已知系统： <span class="math display">\[y(n)-1.3y(n-1)-0.4y(n-2)=x(n-1)\]</span> 求单位样值响应。</p><p>可以用迭代法求解，迭代公式为： <span class="math display">\[y(n)=x(n-1)+1.3y(n-1)+0.4y(n-2)\]</span></p><h3 id="求系统幅频响应">求系统幅频响应</h3><p>利用公式 <span class="math display">\[H(e^{j\Omega})=\sum_{n=0}^Nh(n)e^{-j\Omega n},\Omega\in[0,2\pi]\]</span> 计算系统的频率响应。</p><p>需要注意，计算出的<span class="math inline">\(H(e^{j\Omega})\)</span>是一个复数，但是C语言对复数的支持并不是很好，因此我们可以分别计算实部和虚部。有：</p><p><span class="math display">\[\Re\left[H(e^{j\Omega})\right]=\sum_{k=0}^{10}h(k)\cos(-\Omega k)\\\\\Im\left[H(e^{j\Omega})\right]=\sum_{k=0}^{10}h(k)\sin(-\Omega k)\\\\\text{Amp}=|H(e^{j\Omega})|=\sqrt{\Re ^2+\Im ^2}\\\\\varphi=\arctan(\frac{\Re\left[H(e^{j\Omega})\right]}{\Im\left[H(e^{j\Omega})\right]})\]</span></p><h2 id="实验代码及其流程图">实验代码及其流程图</h2><p>实验流程图如下：</p><p><img src="" /><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/234.bmp" alt="234" /></p><p>实验代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM2.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-type">int</span> x[MAXN];<br><span class="hljs-type">double</span> h[MAXN], t[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">h_</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> h[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>x[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>t[i] = i;<br>h[i] = x[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1.3</span> * <span class="hljs-built_in">h_</span>(i - <span class="hljs-number">1</span>) - <span class="hljs-number">0.4</span> * <span class="hljs-built_in">h_</span>(i - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>, h[i]);<br>&#125;<br><span class="hljs-type">double</span> w[MAXN], amp[MAXN], phi[MAXN];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">2</span> * PI; i += <span class="hljs-number">0.1</span> * PI) &#123;<br><span class="hljs-type">double</span> a = <span class="hljs-number">0.0</span>, b = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">10</span>; ++j) &#123;<br>a += h[j] * <span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span> * j * i);<br>b += h[j] * <span class="hljs-built_in">sin</span>(<span class="hljs-number">-1</span> * j * i);<br>&#125;<br><span class="hljs-type">double</span>  tem_phi = <span class="hljs-built_in">atan2</span>(b, a);<br>w[cnt] = i;<br>amp[cnt] = <span class="hljs-built_in">sqrt</span>(a * a + b * b);<br>phi[cnt] = tem_phi;<br>++cnt;<br>&#125;<br>PPMdata background, axis, grid, line;<br>background = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br><span class="hljs-function">Graph <span class="hljs-title">H</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;response.ppm&quot;</span>)</span></span>;<br><span class="hljs-function">Graph <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, PI, <span class="hljs-number">5.0</span>, <span class="hljs-number">2.5</span> * PI, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;amp-fre.ppm&quot;</span>)</span></span>;<br><span class="hljs-function">Graph <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, PI, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.5</span> * PI, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;pha-fre.ppm&quot;</span>)</span></span>;<br>A.<span class="hljs-built_in">drawXY</span>(w, amp, cnt);<br>P.<span class="hljs-built_in">drawXY</span>(w, phi, cnt);<br>H.<span class="hljs-built_in">drawXY</span>(t, h, <span class="hljs-number">11</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8.4f %8.4f %8.4f\n&quot;</span>, w[i], amp[i], phi[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验结果">实验结果</h2><h3 id="系统单位样值响应">系统单位样值响应</h3><table><thead><tr class="header"><th><span class="math inline">\(n\)</span></th><th><span class="math inline">\(\delta(n)\)</span></th><th><span class="math inline">\(h(n)\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>0.000000</td></tr><tr class="even"><td>1</td><td>0</td><td>1.000000</td></tr><tr class="odd"><td>2</td><td>0</td><td>1.300000</td></tr><tr class="even"><td>3</td><td>0</td><td>1.290000</td></tr><tr class="odd"><td>4</td><td>0</td><td>1.157000</td></tr><tr class="even"><td>5</td><td>0</td><td>0.988100</td></tr><tr class="odd"><td>6</td><td>0</td><td>0.821730</td></tr><tr class="even"><td>7</td><td>0</td><td>0.673009</td></tr><tr class="odd"><td>8</td><td>0</td><td>0.546220</td></tr><tr class="even"><td>9</td><td>0</td><td>0.440882</td></tr><tr class="odd"><td>10</td><td>0</td><td>0.354659</td></tr></tbody></table><p>响应-时间图如下</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/response.jpg" alt="response" /><figcaption aria-hidden="true">response</figcaption></figure><h3 id="系统幅频和相频特性">系统幅频和相频特性</h3><table><thead><tr class="header"><th><span class="math inline">\(\Omega\)</span></th><th><span class="math inline">\(\text{Amp}(\Omega)\)</span></th><th><span class="math inline">\(\varphi(\Omega)\)</span></th></tr></thead><tbody><tr class="odd"><td>0.0000</td><td>8.5716</td><td>0.0000</td></tr><tr class="even"><td>0.3142</td><td>6.1182</td><td>-1.3645</td></tr><tr class="odd"><td>0.6283</td><td>2.1370</td><td>-2.1140</td></tr><tr class="even"><td>0.9425</td><td>1.7731</td><td>-2.2523</td></tr><tr class="odd"><td>1.2566</td><td>0.7426</td><td>-2.7356</td></tr><tr class="even"><td>1.5708</td><td>0.9027</td><td>-2.5992</td></tr><tr class="odd"><td>1.8850</td><td>0.3754</td><td>-3.0217</td></tr><tr class="even"><td>2.1991</td><td>0.6304</td><td>-2.8331</td></tr><tr class="odd"><td>2.5133</td><td>0.2467</td><td>-3.1356</td></tr><tr class="even"><td>2.8274</td><td>0.5384</td><td>-3.0404</td></tr><tr class="odd"><td>3.1416</td><td>0.2124</td><td>3.1416</td></tr><tr class="even"><td>3.4558</td><td>0.5384</td><td>3.0404</td></tr><tr class="odd"><td>3.7699</td><td>0.2467</td><td>3.1356</td></tr><tr class="even"><td>4.0841</td><td>0.6304</td><td>2.8331</td></tr><tr class="odd"><td>4.3982</td><td>0.3754</td><td>3.0217</td></tr><tr class="even"><td>4.7124</td><td>0.9027</td><td>2.5992</td></tr><tr class="odd"><td>5.0265</td><td>0.7426</td><td>2.7356</td></tr><tr class="even"><td>5.3407</td><td>1.7731</td><td>2.2523</td></tr><tr class="odd"><td>5.6549</td><td>2.1370</td><td>2.1140</td></tr><tr class="even"><td>5.9690</td><td>6.1182</td><td>1.3645</td></tr><tr class="odd"><td>6.2832</td><td>8.5716</td><td>0.0000</td></tr></tbody></table><p>幅频曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/amp-fre.jpg" alt="amp-fre" /><figcaption aria-hidden="true">amp-fre</figcaption></figure><p>相频曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/pha-fre.jpg" alt="pha-fre" /><figcaption aria-hidden="true">pha-fre</figcaption></figure><h2 id="实验总结">实验总结</h2><p><span class="math inline">\(0\)</span>时对应的是低频，<span class="math inline">\(\pi\)</span>时对应的是高频，通过幅频特性曲线可以看出，本系统是离散的低通滤波器。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220620-20220626）</title>
    <link href="/2022/06/21/%E5%91%A8%E8%AE%B0%EF%BC%8820220620-20220626%EF%BC%89/"/>
    <url>/2022/06/21/%E5%91%A8%E8%AE%B0%EF%BC%8820220620-20220626%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><hr /><h2 id="section">20220620</h2><p>今天学完了电磁场的所有知识。明天大概就可以开始刷题了。 八分之一个西瓜竟然只要3元，真便宜。</p><h2 id="section-1">20220621</h2><p>今天继续复习电磁场，刷往年题。 明天早上小刷一下模电，下午晚上继续电磁场。刷点难题。</p><h2 id="section-2">20220622</h2><p>我虽然拼上命读，仍然是弄混了，结果一个字也记不住。几天来，头都读晕了，真难。时变双机位时变考试时变疫情时变世界时变我自己，我急了我急了我急了我急了我急了我急了我急了</p><h2 id="section-3">20220623</h2><p>没做什么有意义的事——妈的，这些混蛋教授，不但不知道自己泄气，还整天考，不是你考，就是我考，考他娘的什么东西？电磁场考过了，星期日还有一次考——真混蛋，讲的简直不成东西，又考，像什么话。</p><h2 id="section-4">20220624</h2><p>今天继续紧张刺激地复习模电。今天做了一套题，又补充了一下知识。 今天躺在床上突然被警报声吵醒，我还以为是地震了，其实是高温橙色预警。这才6月下旬耶，全国的温度就直逼40度，是不是地球快爆炸了？ 今天更新了一下博客的标题，感觉好文艺 今天准备看一集相合之物，我还下载了欧比旺，等闲下来再看</p><h2 id="section-5">20220625</h2><p>今天又和朋友自习了，开心。复习了模电，摆烂了。 今天是真的热，我和朋友自习到晚上十点，一出新主楼门，一股热风，和吹风机一样。风又大，又热，真实绝了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220626001926223.png" alt="妈的好几把热" /><figcaption aria-hidden="true">妈的好几把热</figcaption></figure><p>今天喝了两瓶饮料，其中有一瓶叫“橘皮乌龙”，很好喝，我认为大家都应该尝一尝。 今天看了一集欧比王。 我在拼多多买的东西过了半个月了还不发货，果然是骗子软件，当不得真。 今天听说原神和必胜客要联动，好好好，我就是OP捏。</p><h2 id="section-6">20220626</h2><p>今天模电考完了，题多的要死，抄都抄不完，感觉要寄了。 今天摆烂一晚上，爽爽。 昨天忘了说了，昨天我的裤兜帮我安装了10个应用，打了1个电话。 明天要把信号的傅里叶部分写了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于电磁场辐射的那些事</title>
    <link href="/2022/06/21/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E8%BE%90%E5%B0%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/21/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E8%BE%90%E5%B0%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>这部分主要讨论的是电磁波是如何产生的。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="时变场的位函数">时变场的位函数</h2><p>这一部分不是重点，我写完其它的再来写。</p><h2 id="时变电偶极子的辐射">时变电偶极子的辐射</h2><h3 id="时变电偶极子">时变电偶极子</h3><p>时变电偶极子是由大小相等、方向相反的两个点电荷<span class="math inline">\(\pm q(t)\)</span>组成的，其中<span class="math inline">\(q(t)\)</span>按正弦形式变化。这两个点电荷间距为<span class="math inline">\(\mathbf{d}s\to 0\)</span>，电偶极子的有效长度（也叫电尺寸）为<span class="math inline">\(\mathbf{d}s/\lambda\)</span>。有时，需要对电偶极子的电尺寸进行检验，看它是不是满足“远小于一”的条件。如果不满足，不应用电偶极子模型分析。</p><p>对于电偶极子之间的电流，有关系式：</p><p><span class="math display">\[I(t)=\frac{\mathbf{d}q(t)} {\mathbf{d}t}\]</span></p><p>写成复数形式，就是</p><p><span class="math display">\[\dot{I}=j\omega \dot{q}\]</span></p><h3 id="全空间电磁场表达式">全空间电磁场表达式</h3><p>磁场：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>电场</p><p><span class="math display">\[\begin{cases}&amp;\dot{E}_{r_{s} }=-\frac{\dot{I} d s \beta^{2} \eta 2 \cos \theta} {4 \pi}\left[\frac{1} {\left(j \beta r_{s}\right)^{2} }+\frac{1} {\left(j \beta r_{s}\right)^{3} }\right] e^{-j \beta r_{s} } \\\\&amp;\dot{E}_{\theta}=-\frac{\dot{I} d s \beta^{2} \eta \sin \theta} {4 \pi}\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }+\frac{1} {\left(j \beta r_{s}\right)^{3} }\right] e^{-j \beta r_{s} }\end{cases}\]</span></p><p>其中，有：</p><p><span class="math display">\[\frac{\beta} {\omega \varepsilon}=\frac{1} {c \varepsilon}=\frac{\sqrt{\mu \varepsilon} } {\varepsilon}=\eta\]</span></p><p>这个<span class="math inline">\(\eta\)</span>就是波阻抗。</p><h3 id="时变电偶极子场的讨论">时变电偶极子场的讨论</h3><h4 id="近区场">近区场</h4><p>满足<span class="math inline">\(\beta r_s&lt;&lt;1\)</span>的条件，观察点<span class="math inline">\(P\)</span>离电偶极子比较近，这个区域称为近区。</p><p>在近区中，有：</p><p><span class="math display">\[(\beta r_s)^{-3}&gt;&gt;(\beta r_s)^{-2}&gt;&gt;(\beta r_s)^{-1}\]</span></p><p>而且</p><p><span class="math display">\[e^{-j\beta r_s}=0\]</span></p><p>对于磁场，本来<span class="math inline">\(\tilde{H}\)</span>的表达式是：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>中括号中第一项省去，后面的<span class="math inline">\(\exp\)</span>项省去，有：</p><p><span class="math display">\[\dot{H}_{\varphi\text{近} }\approx \frac{\dot{I} d s \sin \theta} {4 \pi r_{s}^{2} }\]</span></p><p>同理，对于电场，有：</p><p><span class="math display">\[\tilde{E}_{\text{近} }\approx \frac{\dot{I} d s} {4 \pi j \omega \varepsilon} \cdot \frac{1} {r_{s}^{3} }\left[i_{r s} 2 \cos \theta+i_{\theta} \sin \theta\right]\]</span></p><p>我们观察电场和磁场表达式，容易发现，近区场的主要成分是似静场，也就是近似于静电（磁）场的场。它的复坡印廷矢量是一个纯虚数，于是，这部分的能量不会被辐射出现，好像是被束缚在了近区，因此似静场也叫<strong>“束缚场”</strong>。我们可以说：时变电偶极子近区场的主要成分是束缚场；<strong>但是不可以说：近区场就是束缚场。</strong></p><h4 id="远区场">远区场</h4><p>当<span class="math inline">\(\beta r_s&gt;&gt;1\)</span>时，观察点<span class="math inline">\(P\)</span>离电偶极子很远，这样的区域称为远区。</p><p>在远区中，有：</p><p><span class="math display">\[(\beta r_s)^{-1}&gt;&gt;(\beta r_s)^{-2}&gt;&gt;(\beta r_s)^{-3}\]</span></p><p>对于磁场，本来<span class="math inline">\(\tilde{H}\)</span>的表达式是：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>中括号中的第二项省去，有：</p><p><span class="math display">\[\dot{H}_{\varphi\text{远} } \approx \frac{i d s \sin \theta} {4 \pi r_{s} } j \beta e^{-j \beta r_{s} }=j \frac{i d s \sin \theta} {2 \lambda r_{s} } e^{-j \beta r_{s} }\]</span></p><p>很多同学可能不知道这个等号是怎么回事。我来说明一下：</p><p>有波长公式：</p><p><span class="math display">\[\lambda f=c\]</span></p><p>又有：</p><p><span class="math display">\[\omega=2\pi f\]</span></p><p>因此：</p><p><span class="math display">\[\lambda=\frac{2\pi c} {\omega}\]</span></p><p>又因为：</p><p><span class="math display">\[c=\frac 1{\sqrt{\mu\varepsilon} }\]</span></p><p>因此：</p><p><span class="math display">\[2\lambda\beta=2\cdot\frac{2\pi} {\omega\sqrt{\mu\varepsilon} }\cdot\omega\sqrt{\mu\varepsilon}=4\pi\]</span></p><p>可以看出，掌握电磁场中各个量的代换关系，是非常重要的。</p><p>同理，对于电场，有：</p><p><span class="math display">\[\dot{E}_{\theta} \approx j \eta \frac{\dot{I} d s} {2 \lambda r_{s} } \sin \theta e^{-j \beta r_{s} }\]</span></p><p>计算坡印廷矢量：</p><p><span class="math display">\[\tilde{S}=\frac{1} {2} \tilde{E} \times \widetilde{H}^{*}=i_{r_{s} } \frac{1} {2} \eta\left|\dot{H}_{\varphi}\right|^{2}\]</span></p><p>可以看出，在远区，电磁场有一个向外发射的功率流。远区中，电磁场携带的能量会全部辐射出去，因此远区场的 <strong>主要部分</strong> ，也就是和<span class="math inline">\(r_s^{-1}\)</span>成正比的这部分，被称为辐射场。辐射场中电场和磁场同相位，在等相位面上，电磁场振幅按照<span class="math inline">\(\sin \theta\)</span>规律变化，因此辐射波是一个非均匀球面波。</p><p>必须说明的是：辐射场在近区也是存在的，不过十分微弱，不起主导作用。即：近区场也有能量发射的部分，远区场也有能量交换的部分，这里讨论的只是占主导作用的部分。因此 <strong>不能说：近区场就是束缚场，远区场就是辐射场</strong> 。随着<span class="math inline">\(r_s\)</span>的增长，辐射场（即反比于<span class="math inline">\(r_s\)</span>的项）比其它反比于<span class="math inline">\(r_s\)</span>高次方的项减少的慢，因此辐射场渐渐起了主导作用。用一个示意图描述，就是：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620233646037.png" alt="image-20220620233646037" /><figcaption aria-hidden="true">image-20220620233646037</figcaption></figure><h4 id="方向性函数">方向性函数</h4><p>方向性函数的定义：</p><p><span class="math display">\[F(\theta,\varphi)=\frac{|E(\theta,\varphi)|} {|E_maxx|}\]</span></p><p>在时变电偶极子的情况下，有：</p><p><span class="math display">\[F(\theta,\varphi)=|\sin \theta|\]</span></p><p>在Mathematica中运行代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">SphericalPlot3D</span><span class="hljs-punctuation">[</span><br> <span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">\[Theta]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Theta]</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Pi</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Phi]</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以看出它长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620234231700.png" alt="image-20220620234231700" /><figcaption aria-hidden="true">image-20220620234231700</figcaption></figure><p>其E面方向图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620234857788.png" alt="image-20220620234857788" /><figcaption aria-hidden="true">image-20220620234857788</figcaption></figure><p>H面方向图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620235040126.png" alt="image-20220620235040126" /><figcaption aria-hidden="true">image-20220620235040126</figcaption></figure><h4 id="辐射功率和辐射电阻">辐射功率和辐射电阻</h4><p>时变电偶极子的辐射功率为：</p><p><span class="math display">\[\dot{P}_r=\oint_A\tilde{S}\mathbf{d}a=\frac \pi 3\eta I^2\left(\frac{ds} {\lambda}\right)^2\]</span></p><p>由</p><p><span class="math display">\[P=I^2R\]</span></p><p>得辐射电阻：</p><p><span class="math display">\[R_r=\frac{2\pi} {3}\eta\left(\frac{ds} {\lambda}\right)^2\]</span></p><h2 id="时变磁偶极子的辐射">时变磁偶极子的辐射</h2><h3 id="时变磁偶极子">时变磁偶极子</h3><p>时变磁偶极子的模型是一个面积为<span class="math inline">\(a\)</span>，载有电流<span class="math inline">\(I(t)\)</span>的导线环。当导线环的大小远远小于波长时，可以视为一个时变磁偶极子。</p><h3 id="电磁对偶原理">电磁对偶原理</h3><p>在讨论时变磁偶极子之前，首先来介绍电磁对偶原理。在之前，曾经提到过对称形式场定律：</p><p><span class="math display">\[\begin{cases}\nabla \times \boldsymbol{H}=\varepsilon_{0} \frac{\partial \boldsymbol{E} } {\partial t}+\boldsymbol{J} \\\\\nabla \cdot \varepsilon_{0} \boldsymbol{E}=\boldsymbol{\rho} \\\\\nabla \cdot \boldsymbol{J}=-\frac{\partial \rho} {\partial t}\end{cases}\]</span></p><p><span class="math display">\[\begin{cases}\nabla \times \boldsymbol{E}=-\mu_{0} \frac{\partial \boldsymbol{H} } {\partial t}-\boldsymbol{J}_{\mathrm{M} } \\\\\nabla \cdot \mu_{0} \boldsymbol{E}=\rho_{\mathrm{M} } \\\\\nabla \cdot \boldsymbol{J}_{\mathrm{M} }=-\frac{\partial \rho_{\mathrm{M} }} {\partial t}\end{cases}\]</span></p><p>这两组方程形式完全相同，只是第一个式子的源是电流、电荷；而第二个式子的源是磁流，磁荷。因此，如果一个只含电流、电荷源的系统的解<span class="math inline">\(E_1\)</span>,<span class="math inline">\(H_1\)</span>已经求得，那么对于一个其它完全相同，只是把电流换成磁流，把电荷换成磁荷的新系统，它的解<span class="math inline">\(E_2\)</span>和<span class="math inline">\(H_1\)</span>，<span class="math inline">\(H_2\)</span>和<span class="math inline">\(E_1\)</span>应该有完全一样的形式</p><p>不妨对比一般性的两个系统a和b，如下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/73D6797EF70B879E8BF95BC4795FE7A4.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>两个系统有完全相同的区域和边界，只是把电流和磁流，电荷和磁荷调换。那么存在以下的代换关系：</p><p><span class="math display">\[\begin{aligned}E&amp;\to H\\\\H&amp;\to E\\\\\rho &amp;\to -\rho_M\\\\\rho_M &amp;\to -\rho\\\\J&amp;\to-J_M\\\\J_M &amp;\to-J\\\\\varepsilon &amp;\to -\mu\\\\\mu &amp;\to -\varepsilon\end{aligned}\]</span></p><p>如果上面系统<span class="math inline">\((a)\)</span>的解<span class="math inline">\(E_a,H_a\)</span>已经求出，按照上面的代换关系，就可以立刻得到系统<span class="math inline">\((b)\)</span>的解。</p><h3 id="全空间电磁场表达式-1">全空间电磁场表达式</h3><p>结合上面的电磁对偶关系，对于时变电偶极子式子里面的<span class="math inline">\(\beta/\eta=\omega\varepsilon\)</span>应该代换成<span class="math inline">\(-\beta\eta=-\omega\mu\)</span>,因此<span class="math inline">\(\eta\)</span>代换为<span class="math inline">\(-1/\eta\)</span>,还有关系<span class="math inline">\(\dot{I}ds\to-j\omega\mu\dot{I}a\)</span>，可以直接写出全空间电磁场表达式：</p><p><span class="math display">\[\begin{aligned}&amp;\dot{E}_{\varphi}(\boldsymbol{r})=\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} \sin \theta} {4 \pi}\left[\frac{1} {j \beta_{0} r_{s} }+\frac{1} {\left(j\beta_{0} r_{s}\right)^{2} }\right] e^{-j \beta_{0} r_{s} }  \\\\&amp;\dot{H}_{r_{s} }(\boldsymbol{r})=-\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} 2 \cos \theta} {4 \pi \eta_{0} }\left[\frac{1} {\left(j \beta_{0} r_{s}\right)^{2} }+\frac{1} {\left(j \beta_{0} r_{s}\right)^{3} }\right] e^{-j \beta_{0} r_{s} } \\\\&amp;\dot{H}_{\theta}(\boldsymbol{r})=-\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} \sin \theta} {4 \pi \eta_{0} }\left[\frac{1} {j \beta_{0} r_{s} }+\frac{1} {\left(j \beta_{s} r_{\omega}\right)^{2} }+\frac{1} {\left(j \beta_{s} r_{0}\right)^{3} }\right] e^{-j\beta_{0} r_{s} } \end{aligned}\]</span></p><h3 id="时变磁偶极子场的讨论">时变磁偶极子场的讨论</h3><h4 id="近区场-1">近区场</h4><p>近区场应该保留<span class="math inline">\((\beta r_s)\)</span>的最低次项（也就是<span class="math inline">\(\frac{1} {\beta r_s}\)</span>的最高次项）,删去<span class="math inline">\(e\)</span>的指数项，有：</p><p><span class="math display">\[E_\varphi\approx\frac{-j\omega\mu_0\dot{I}a\sin \theta} {4\pi r_s^2}\]</span></p><p><span class="math display">\[H\approx \frac{j\omega\mu_0\dot{I}a} {4\pi j\omega \mu_0}\frac{1} {r_s^3}(i_{rs}2\cos\theta+i_\theta\sin \theta)=\frac{\dot{I}a} {4\pi}\frac{1} {r_s^3}(i_{rs}2\cos\theta+i_\theta\sin \theta)\]</span></p><h4 id="远区场-1">远区场</h4><p><span class="math display">\[H_{远}-\frac{\pi \dot{I}a} {\lambda^2r_s}\sin \theta e^{-j\beta_0r_s}\]</span></p><p><span class="math display">\[E_{远}=\frac{\pi\eta\dot{I}a} {\lambda^2r_s}\sin\theta e^{-j\beta_0r_s}\]</span></p><h4 id="方向性函数-1">方向性函数</h4><p><span class="math display">\[F(\theta,\varphi)=|\sin \theta|\]</span></p><p>形状和电偶极子完全一样，但是E和H面的图要对换。</p><h4 id="辐射功率和辐射电阻-1">辐射功率和辐射电阻</h4><p>由电磁对偶原理，有：</p><p><span class="math display">\[P_r=\frac{\pi} {3\eta}\frac{\omega^2\mu^2I^2a^2} {\lambda^2}\]</span></p><p>化简后， 有：</p><p><span class="math display">\[P_r=\frac{4} {3}\pi^3\eta\frac{I^2a^2} {\lambda^2}\]</span></p><p>在自由空间中，把<span class="math inline">\(\eta=120\pi\)</span>代入，有：</p><p><span class="math display">\[P_r=160\pi^4\frac{I^2a^2} {\lambda^2}\]</span></p><p>辐射电阻为：</p><p><span class="math display">\[R_r=\frac{4\pi^3a^2\eta} {3\lambda^2}\]</span></p><h2 id="其它天线简述">其它天线简述</h2><h3 id="半波天线">半波天线</h3><p>可以理解为电偶极子天线长度变成半个波长。线天线的端点总是电流的波节点，中心点为波腹点。</p><p>方向性函数为：</p><p><span class="math display">\[F(\theta,\varphi)=\frac{\cos(\frac \pi 2\cos \theta)} {\sin \theta}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220621114342987.png" alt="image-20220621114342987" /><figcaption aria-hidden="true">image-20220621114342987</figcaption></figure><p>它的指向性比交变电偶极子更窄。</p><p>天线长度越大，方向函数的零、极点越多，主向越向轴线靠拢。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于电磁场的能量的那些事</title>
    <link href="/2022/06/20/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E7%9A%84%E8%83%BD%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/20/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E7%9A%84%E8%83%BD%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>这章的核心是坡印廷定理。</p><span id="more"></span><hr /><h2 id="静电场和静磁场的能量">静电场和静磁场的能量</h2><p>在自由空间的分布电荷系统中，有两种方法计算系统蕴含的静电场能量： <span class="math display">\[W_E=\frac 12\iiint_V \varPhi(r)\rho(r) \mathbf{d}V\]</span> 和 <span class="math display">\[W_E=\iiint_V\frac 12\varepsilon_0\boldsymbol{E}(r)\cdot \boldsymbol{E}(r)\mathbf{d}V\]</span> 其中，定义电场能量密度 <span class="math display">\[w_E=\frac 12\varepsilon_0\boldsymbol{E}(r)\cdot \boldsymbol{E}(r)=\frac 12 \mu_0 |\boldsymbol{E}(r)|^2\ \ \text{(J/m$^3$)}\]</span> 对于点电荷系统来说，原则上不能利用电场能量密度<span class="math inline">\(w_E\)</span>来计算电场能，因为积分不收敛，会得到一个无穷大的结果，此时，只能使用 <span class="math display">\[W_E=\frac 12 \sum_{i=1}^nq_i\varPhi_i\]</span> 来计算。其中<span class="math inline">\(\varPhi_i\)</span>是在点电荷<span class="math inline">\(q_i\)</span>的位置上，除去<span class="math inline">\(q_i\)</span>以外的所有其它电荷产生的电势。有： <span class="math display">\[\varPhi_i=\sum_{k=1,k\neq i}^n \frac {q_k}{4\pi \varepsilon_0r_{ki}}\]</span> 对于自由空间中的电流系统，有磁场能计算公式： <span class="math display">\[W_H=\iiint_V \frac 12 \mu_0\boldsymbol{H}(r)\cdot\boldsymbol{H}(r)\mathbf{d}V\]</span> 于是可以定义磁能密度： <span class="math display">\[w_H=\frac 12 \mu_0\boldsymbol{H}(r)\cdot\boldsymbol{H}(r)=\frac 12 \mu_0 |\boldsymbol{H}(r)|^2\ \  \text{(J/m$^3$)}\]</span> 当然也有类似电场能的另一个公式： <span class="math display">\[W_H=\frac 12\sum_{i=1}^n \Psi_iI_i\]</span> 其中<span class="math inline">\(\Psi_i\)</span>表示系统中和线电流回路<span class="math inline">\(C_i\)</span>交链的磁通量。这个公式很少用到。</p><h2 id="坡印廷定理">坡印廷定理</h2><p>坡印廷定理的基本表达式为： <span class="math display">\[-\nabla \cdot \vec{S}(\vec{r}, t)=p(\vec{r}, t)+\frac{\partial w(\vec{r}, t)}{\partial t}\]</span> 其中<span class="math inline">\(S\)</span>是坡印廷矢量，定义为： <span class="math display">\[\vec{S}(\vec{r}, t)=\vec{E}(\vec{r}, t) \times \vec{H}(\vec{r}, t)\]</span> 其中各项的含义为：</p><ul><li><span class="math inline">\(-\nabla \cdot \vec{S}(\vec{r}, t)\)</span>，即坡印廷矢量的负散度。它表示外界向电磁场中某点所提供的功率流密度。</li><li><span class="math inline">\(p(\vec{r}, t)\)</span>，它表示电磁场对这点的电磁荷提供的电磁功率密度。</li><li><span class="math inline">\(\frac{\partial w(\vec{r}, t)}{\partial t}\)</span>，它表示电磁场在这点蕴含的能量密度的增加率。</li></ul><p>从整体上来说，也就是：外界向一点提供的电磁能必定用于对处在该点的电磁荷做功，和增加电磁场在该点的电磁能。</p><p>在物质中的坡印廷定理有以下形式： <span class="math display">\[-\nabla \cdot \vec{S}(\vec{r}, t)+p_{s}(\vec{r}, t)=p_{d}(\vec{r}, t)+p_{P}(\vec{r}, t)+p_{M}(\vec{r}, t)+\frac{\partial }{\partial t}[w_E(\vec{r}, t)+w_E(\vec{r}, t)]\]</span> 其中：</p><ul><li><p><span class="math inline">\(p_S\)</span>表示电源向电磁场提供的功率。有： <span class="math display">\[p_s(\vec{r},t)=-J_s(\vec{r},t)\cdot E(\vec{r},t)\]</span> 需要注意这里的符号。符号的意思是如果<span class="math inline">\(J_s(\vec{r},t)\cdot E(\vec{r},t)&gt;0\)</span>，这时候实际上是电磁场给电源充电。</p></li><li><p><span class="math inline">\(p_d\)</span>表示由于物质的电阻性而转化为焦耳热的功率。有： <span class="math display">\[p_d(\vec{r},t)=\sigma|\boldsymbol{E}(\vec{r},t)|^2\]</span></p></li><li><p><span class="math inline">\(p_P\)</span>表示用来增加物质极化程度的功率。有： <span class="math display">\[p_P(\vec{r},t)=\boldsymbol{E}(\vec{r},t)\cdot \frac{\partial \boldsymbol{P}(\vec{r},t)}{\partial t}\]</span> 其中<span class="math inline">\(P(\vec{r},t)\)</span>是极化强度，对于简单媒质来说，有： <span class="math display">\[\boldsymbol{P}(\vec{r},t)=\chi_e\varepsilon_0\boldsymbol{E}(\vec{r},t)\]</span> 其中<span class="math inline">\(\chi_e\)</span>是电极化率。</p></li><li><p><span class="math inline">\(p_M\)</span>表示用来增加物质磁化程度的功率。有： <span class="math display">\[p_M(\vec{r},t)=\boldsymbol{H}(\vec{r},t)\cdot \mu_0\frac{\partial \boldsymbol{M}(\vec{r},t)}{\partial t}\]</span></p></li><li><p>上面四条加起来称为“物质消耗的功率”,也就是坡印廷定理一般表达式的<span class="math inline">\(p(\vec{r},t)\)</span>，特殊地，对于电阻性导体，只存在<span class="math inline">\(p_d\)</span>。</p></li><li><p><span class="math inline">\(w_E,w_H\)</span>表示电磁场的储能。</p></li></ul><p>在做题时，还会遇到一个模型，叫“同轴电缆”，一开始我完全不知道它是啥玩意。其实，“同轴电缆”是一个由两部分导体组成的系统，“内导体”是一个半径为<span class="math inline">\(a\)</span>的圆柱体，“外导体”是一片半径为<span class="math inline">\(b\)</span>的圆柱面，这俩是同心的。制造同轴电缆的导体可能是理想的，也可能不是理想的。在一端的内外导体之间，往往接有圆对称的电压源。</p><h2 id="物质中的极化能和磁化能">物质中的极化能和磁化能</h2><h3 id="电容器的能量极化能">电容器的能量：极化能</h3><p>对于公式： <span class="math display">\[p_P(\vec{r},t)=\boldsymbol{E}(\vec{r},t)\cdot \frac{\partial \boldsymbol{P}(\vec{r},t)}{\partial t}\]</span> 将 <span class="math display">\[\boldsymbol{P}(\vec{r},t)=\chi_e\varepsilon_0\boldsymbol{E}(\vec{r},t)\]</span> 代入，可推导得： <span class="math display">\[p_P(\vec{r},t)=\frac{\partial}{\partial t}\left[\frac 12 \boldsymbol{P}(\vec{r},t)\cdot \boldsymbol{E}(\vec{r},t)\right]\]</span> 于是有极化能密度： <span class="math display">\[w_P(\vec{r},t)=\frac 12\boldsymbol{P}(\vec{r},t)\cdot \boldsymbol{E}(\vec{r},t)\]</span> "极化能"的意思，就是电容器两个导体板子中间夹的那一坨电介质因为要极化所以得到的能量。为了完整讨论电介质的能量，我们还要加上电场的能量，即： <span class="math display">\[w_E(\vec{r},t)=\frac 12 \varepsilon_0|E(\vec{r},t)|^2\]</span> 有电能密度： <span class="math display">\[\begin{aligned}w_e&amp;=w_p+w_E\\&amp;=\frac 12E(\vec{r},t)\cdot D(\vec{r},t)\end{aligned}\]</span> 其中<span class="math inline">\(D(\vec{r},t)\)</span>叫电位移矢量，定义如下： <span class="math display">\[D=\varepsilon_0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=(1+\chi_e)\varepsilon_0E=\varepsilon_r\varepsilon_0E\]</span> 于是： <span class="math display">\[w_e=\frac 12 \varepsilon E^2\]</span></p><p>再结合电分里面的电容公式： <span class="math display">\[W_c=\frac 12 CV^2\]</span> 就能求出电容量。</p><h3 id="电感器的能量磁化能">电感器的能量：磁化能</h3><p><span class="math display">\[p_M(\vec{r},t)=\boldsymbol{H}(\vec{r},t)\cdot \mu_0\frac{\partial \boldsymbol{M}(\vec{r},t)}{\partial t}\]</span></p><p>其中<span class="math inline">\(M\)</span>叫磁化强度，有： <span class="math display">\[\mu_0M=(\mu-\mu_0)H\]</span> 在单值简单介质中，有磁化能密度： <span class="math display">\[w_M=\frac 12 \mu_0H(\vec{r},t)\cdot M(\vec{r},t)\]</span> 再加上磁场本身的能量，就有磁能密度： <span class="math display">\[w_H=\frac 12 B\cdot H=\frac 12 \mu H^2\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统课程设计：频分复用系统设计</title>
    <link href="/2022/06/16/%E4%BF%A1%E5%8F%B7%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <url>/2022/06/16/%E4%BF%A1%E5%8F%B7%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是大作业，频分复用系统设计</p><span id="more"></span><h2 id="实验目的">实验目的</h2><p>本次实验尝试设计一种频分复用系统，接收三个带限信号，通过选取不同的调制频率<span class="math inline">\(\omega_c\)</span>，将所需传输的信号的频谱搬移到不同频段，在同一物理信道中传输多路信号。频分复用的原理框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/41CA9D78D2872ED5A23ED8B6346EC6EC.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="实验过程">实验过程</h2><h3 id="读取信号">读取信号</h3><p>输入信号以列表的方式给出，表的形式如下：</p><table><thead><tr class="header"><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(f_1(t)\)</span></th><th><span class="math inline">\(f_2(t)\)</span></th><th><span class="math inline">\(f_3(t)\)</span></th></tr></thead><tbody><tr class="odd"><td>-10</td><td>-0.0498</td><td>0.0032</td><td>0.0031</td></tr><tr class="even"><td>-9.9</td><td>-0.0424</td><td>0.0023</td><td>0.0032</td></tr><tr class="odd"><td>-9.8</td><td>-0.0344</td><td>0.0015</td><td>0.0031</td></tr><tr class="even"><td>-9.7</td><td>-0.0258</td><td>0.0008</td><td>0.003</td></tr><tr class="odd"><td>-9.6</td><td>-0.0167</td><td>0.0004</td><td>0.0028</td></tr><tr class="even"><td>-9.5</td><td>-0.0073</td><td>0.0001</td><td>0.0025</td></tr><tr class="odd"><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr class="even"><td>9.8</td><td>-0.0344</td><td>0.0015</td><td>0.0031</td></tr><tr class="odd"><td>9.9</td><td>-0.0424</td><td>0.0023</td><td>0.0032</td></tr></tbody></table><p>读取数据相关的程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> T[MAXN], f1[MAXN], f2[MAXN], f3[MAXN];<br>tf tf_f1[MAXN], tf_f2[MAXN], tf_f3[MAXN];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;T[cnt], &amp;f1[cnt], &amp;f2[cnt], &amp;f3[cnt]) != EOF) &#123;<br>tf_f1[cnt] = (tf) &#123;T[cnt], f1[cnt]&#125;;<br>tf_f2[cnt] = (tf) &#123;T[cnt], f2[cnt]&#125;;<br>tf_f3[cnt] = (tf) &#123;T[cnt], f3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> length = cnt;<br></code></pre></td></tr></table></figure><p>其中<code>tf</code>结构体是为运算方便定义的结构，其中有两个<code>double</code>型量，即<code>t</code>和<code>f</code>，用来存储时间-信号表。</p><p>原始信号的波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616164757519.png" alt="image-20220616164757519" /><figcaption aria-hidden="true">image-20220616164757519</figcaption></figure><h3 id="获取原始信号的频域图像分析频域特征">获取原始信号的频域图像，分析频域特征</h3><p>对三个原始信号作傅里叶变换，并绘制频域图像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> W[MAXN], F1[MAXN], F2[MAXN], F3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-3.0</span>; w &lt;= <span class="hljs-number">3.0</span>; w += <span class="hljs-number">0.01</span>) &#123;<br>    W[cnt] = w;<br>    F1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f1, length);<br>    F2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f2, length);<br>    F3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f3, length);<br>    ++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">inputWSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;inputW.ppm&quot;</span>)</span></span>;<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F1, cnt, line_blue);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F2, cnt, line_green);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F3, cnt, line_red);<br>inputWSignal.<span class="hljs-built_in">draw</span>();<br></code></pre></td></tr></table></figure><p>其中<code>fourierTransform</code>函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, tf f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].t - f[<span class="hljs-number">0</span>].t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].f * <span class="hljs-built_in">cos</span>(w * f[i].t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>绘制出的频域波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616164823488.png" alt="image-20220616164823488" /><figcaption aria-hidden="true">image-20220616164823488</figcaption></figure><p>可以看出，输入的三个信号都是带限信号。有： <span class="math display">\[\omega_{m1}=1\\\omega_{m2}=2\\\omega_{m3}=\frac \pi 2\]</span> 因此，我们可以使用频分复用的方法把这三个信号合在一个信道中传输。</p><h3 id="频域搬移和信道组合">频域搬移和信道组合</h3><p>由公式： <span class="math display">\[g(t)=\sum_{i=1}^3 f_i(t)\cos(\omega_it)\]</span> 我们可以将这三个信号的频域进行搬移，并组合在一个信道中进行传输。其中<span class="math inline">\(\cos(\omega_it)\)</span>就起到了幅度调制，频域搬移的作用。这是因为： <span class="math display">\[\begin{aligned}\mathscr{F}[f(t)\cos(\omega_0 t)]&amp;=\frac{1}{2\pi}\mathscr{F}[f(t)]\bigotimes\mathscr{F}[\cos(\omega_0 t)]\\&amp;=\frac{1}{2\pi}F(\omega)\bigotimes\pi[\delta(\omega+\omega_0)+\delta(\omega-\omega_0)]\\&amp;=\frac 12[F(\omega+\omega_0)-F(\omega-\omega_0)]\end{aligned}\]</span> 在选择载波频率时，考虑到原始采样频率为<span class="math inline">\(f=10\text{Hz}\)</span>，所以载波频率分别选择 <span class="math display">\[\omega_1=5,\omega_2=12.5,\omega_3=20\]</span> 这部分的代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> omega1 = <span class="hljs-number">5.0</span>, omega2 = <span class="hljs-number">12.5</span>, omega3 = <span class="hljs-number">20.0</span>;<br><span class="hljs-type">double</span> g[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br>tf tf_g[MAXN];<br><span class="hljs-type">int</span> g_length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>g[cnt] = (f1[cnt] * <span class="hljs-built_in">cos</span>(omega1 * t) + f2[cnt] * <span class="hljs-built_in">cos</span>(omega2 * t) + f3[cnt] * <span class="hljs-built_in">cos</span>(omega3 * t));<br>tf_g[cnt] = (tf) &#123;t, g[cnt]&#125;;<br>++cnt;<br>&#125;<br>g_length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">GT</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GT.ppm&quot;</span>)</span></span>;<br>GT.<span class="hljs-built_in">drawXY</span>(T, g, cnt, line_blue);<br><span class="hljs-type">double</span> G[MAXN], w2[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>w2[cnt] = w;<br>G[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_g, g_length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">GW</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GW.ppm&quot;</span>)</span></span>;<br>GW.<span class="hljs-built_in">drawXY</span>(w2, G, cnt, line_blue);<br></code></pre></td></tr></table></figure><p>同时分别画出了<span class="math inline">\(g(t)\)</span>的时域、频域图像，如下：</p><p>时域图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616172004693.png" alt="image-20220616172004693" /><figcaption aria-hidden="true">image-20220616172004693</figcaption></figure><p>频域图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616171953072.png" alt="image-20220616171953072" /><figcaption aria-hidden="true">image-20220616171953072</figcaption></figure><p>可见：已经实现了频域搬移。</p><h3 id="使用带通滤波器接受信号">使用带通滤波器接受信号</h3><p>在解调过程中，使用带通滤波器接受信号。对于三个信号，分别采用中心频率为<span class="math inline">\(\omega_i\)</span>，通过频带宽度为<span class="math inline">\(\omega_{mi}\)</span>的带通滤波器。信号<span class="math inline">\(g(t)\)</span>经过带通滤波器以后，被分为了三路信号。对这三路信号，每一路再乘以<span class="math inline">\(\cos(\omega_i t)\)</span>，就把频带移动到了中间。如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616172628586.png" alt="image-20220616172628586" /><figcaption aria-hidden="true">image-20220616172628586</figcaption></figure><p>我们再对这三个信号过一个低通滤波器，就能恢复出原来的信号了。</p><p>这部分的代码如下：</p><ol type="1"><li><p>通过带通滤波器分开三路信号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> G1[MAXN], G2[MAXN], G3[MAXN];<br>wF wF_g1[MAXN], wF_g2[MAXN], wF_g3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(G1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G1));<br><span class="hljs-built_in">memset</span>(G2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G2));<br><span class="hljs-built_in">memset</span>(G3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G3));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>G1[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, w);<br>G2[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">12.5</span>, <span class="hljs-number">5.0</span>, w);<br>G3[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">20.0</span>, PI, w);<br>wF_g1[cnt] = (wF) &#123;w, G1[cnt]&#125;;<br>wF_g2[cnt] = (wF) &#123;w, G2[cnt]&#125;;<br>wF_g3[cnt] = (wF) &#123;w, G3[cnt]&#125;;<br>++cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分别再乘以<span class="math inline">\(\cos(\omega_i t)\)</span>再次搬移频域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> G1length = cnt;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> fG1[MAXN], fG2[MAXN], fG3[MAXN];<br>tf tf_fG1[MAXN], tf_fG2[MAXN], tf_fG3[MAXN];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>fG1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g1, G1length);<br>fG2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g2, G1length);<br>fG3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g3, G1length);<br>fG1[cnt] *= <span class="hljs-built_in">cos</span>(omega1 * t);<br>fG2[cnt] *= <span class="hljs-built_in">cos</span>(omega2 * t);<br>fG3[cnt] *= <span class="hljs-built_in">cos</span>(omega3 * t);<br>tf_fG1[cnt] = (tf) &#123;t, fG1[cnt]&#125;;<br>tf_fG2[cnt] = (tf) &#123;t, fG2[cnt]&#125;;<br>tf_fG3[cnt] = (tf) &#123;t, fG3[cnt]&#125;;<br>++cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过低通滤波器，恢复原始信号，并绘制出输出信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> GfG1[MAXN], GfG2[MAXN], GfG3[MAXN];<br>wF wf_gfg1[MAXN], wf_gfg2[MAXN], wf_gfg3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>GfG1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG1, g_length);<br>GfG2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG2, g_length);<br>GfG3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG3, g_length);<br>GfG1[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG2[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG3[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>wf_gfg1[cnt] = (wF) &#123;w, GfG1[cnt]&#125;;<br>wf_gfg2[cnt] = (wF) &#123;w, GfG2[cnt]&#125;;<br>wf_gfg3[cnt] = (wF) &#123;w, GfG3[cnt]&#125;;<br>++cnt;<br>&#125;<br>length = cnt;<br><span class="hljs-type">double</span> finalf1[MAXN], finalf2[MAXN], finalf3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10</span>; t &lt;= <span class="hljs-number">10</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>finalf1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg1, length);<br>finalf2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg2, length);<br>finalf3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg3, length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">outputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;output.ppm&quot;</span>)</span></span>;<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf1, cnt, line_blue);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf2, cnt, line_green);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf3, cnt, line_red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><p>输出信号的波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616173101518.png" alt="image-20220616173101518" /><figcaption aria-hidden="true">image-20220616173101518</figcaption></figure><p>可以看出，本次实验较好地完成了频分复用信号传输的任务。</p><p>计算三个信号的均方误差，有：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">MSE1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000048221</span><br><span class="hljs-attribute">MSE2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000652</span><br><span class="hljs-attribute">MSE3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000173</span><br></code></pre></td></tr></table></figure><p>可以看出，这个系统的效果还是比较理想。</p><h2 id="实验心得体会">实验心得体会</h2><p>本次实验我综合运用了《信号与系统》课程的相关知识，如奈奎斯特采样定理、傅里叶变换的相关内容，完成了综合信号传输系统的设计，对我的学习非常的有帮助。</p><h2 id="附录">附录</h2><p>本次实验完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM2.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 3000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDTH 1920</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIGHT 1080</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forvec(TYPE,NAME,IT) for(vector<span class="hljs-string">&lt;TYPE&gt;</span>::iterator IT=NAME.begin();IT!=NAME.end();++IT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forset(TYPE,NAME,IT) for(set<span class="hljs-string">&lt;TYPE&gt;</span>::iterator IT=NAME.begin();IT!=NAME.end();++IT)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*fun_p)</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">double</span> t, f;<br>&#125; tf;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">wF</span> &#123;<br><span class="hljs-type">double</span> w, F;<br>&#125; wF;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierInvTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> t, wF f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].w - f[<span class="hljs-number">0</span>].w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].F * <span class="hljs-built_in">cos</span>(t * f[i].w) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans / (<span class="hljs-number">2.0</span> * PI);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, tf f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].t - f[<span class="hljs-number">0</span>].t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].f * <span class="hljs-built_in">cos</span>(w * f[i].t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bandPassFilter</span><span class="hljs-params">(<span class="hljs-type">double</span> center, <span class="hljs-type">double</span> band, <span class="hljs-type">double</span> w)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(w - center) &lt; (band / <span class="hljs-number">2.0</span>) || <span class="hljs-built_in">fabs</span>(w + center) &lt; (band / <span class="hljs-number">2.0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><span class="hljs-comment">//return (fabs(w - center) &lt; (band / 2.0)) ? 1.0 : 0.0;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;inputSignal.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>PPMdata background, axis, grid, line_blue, line_green, line_red;<br>background = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line_blue = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br>line_green = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">66</span>, <span class="hljs-number">96</span>, <span class="hljs-number">45</span>);<br>line_red = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">193</span>, <span class="hljs-number">50</span>, <span class="hljs-number">142</span>);<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> T[MAXN], f1[MAXN], f2[MAXN], f3[MAXN];<br>tf tf_f1[MAXN], tf_f2[MAXN], tf_f3[MAXN];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;T[cnt], &amp;f1[cnt], &amp;f2[cnt], &amp;f3[cnt]) != EOF) &#123;<br>tf_f1[cnt] = (tf) &#123;T[cnt], f1[cnt]&#125;;<br>tf_f2[cnt] = (tf) &#123;T[cnt], f2[cnt]&#125;;<br>tf_f3[cnt] = (tf) &#123;T[cnt], f3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">inputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;input.ppm&quot;</span>)</span></span>;<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f1, cnt, line_blue);<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f2, cnt, line_green);<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f3, cnt, line_red);<br>inputSignal.<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-type">double</span> W[MAXN], F1[MAXN], F2[MAXN], F3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-3.0</span>; w &lt;= <span class="hljs-number">3.0</span>; w += <span class="hljs-number">0.01</span>) &#123;<br>W[cnt] = w;<br>F1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f1, length);<br>F2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f2, length);<br>F3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f3, length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">inputWSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;inputW.ppm&quot;</span>)</span></span>;<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F1, cnt, line_blue);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F2, cnt, line_green);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F3, cnt, line_red);<br>inputWSignal.<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-type">double</span> omega1 = <span class="hljs-number">5.0</span>, omega2 = <span class="hljs-number">12.5</span>, omega3 = <span class="hljs-number">20.0</span>;<br><span class="hljs-type">double</span> g[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br>tf tf_g[MAXN];<br><span class="hljs-type">int</span> g_length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>g[cnt] = (f1[cnt] * <span class="hljs-built_in">cos</span>(omega1 * t) + f2[cnt] * <span class="hljs-built_in">cos</span>(omega2 * t) + f3[cnt] * <span class="hljs-built_in">cos</span>(omega3 * t));<br>tf_g[cnt] = (tf) &#123;t, g[cnt]&#125;;<br>++cnt;<br>&#125;<br>g_length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">GT</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GT.ppm&quot;</span>)</span></span>;<br>GT.<span class="hljs-built_in">drawXY</span>(T, g, cnt, line_blue);<br><span class="hljs-type">double</span> G[MAXN], w2[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>w2[cnt] = w;<br>G[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_g, g_length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">GW</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GW.ppm&quot;</span>)</span></span>;<br>GW.<span class="hljs-built_in">drawXY</span>(w2, G, cnt, line_blue);<br><br><span class="hljs-type">double</span> G1[MAXN], G2[MAXN], G3[MAXN];<br>wF wF_g1[MAXN], wF_g2[MAXN], wF_g3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(G1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G1));<br><span class="hljs-built_in">memset</span>(G2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G2));<br><span class="hljs-built_in">memset</span>(G3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G3));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>G1[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, w);<br>G2[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">12.5</span>, <span class="hljs-number">5.0</span>, w);<br>G3[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">20.0</span>, PI, w);<br>wF_g1[cnt] = (wF) &#123;w, G1[cnt]&#125;;<br>wF_g2[cnt] = (wF) &#123;w, G2[cnt]&#125;;<br>wF_g3[cnt] = (wF) &#123;w, G3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> G1length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">Gerr</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;Gerr.ppm&quot;</span>)</span></span>;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> fG1[MAXN], fG2[MAXN], fG3[MAXN];<br>tf tf_fG1[MAXN], tf_fG2[MAXN], tf_fG3[MAXN];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>fG1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g1, G1length);<br>fG2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g2, G1length);<br>fG3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g3, G1length);<br>fG1[cnt] *= <span class="hljs-built_in">cos</span>(omega1 * t);<br>fG2[cnt] *= <span class="hljs-built_in">cos</span>(omega2 * t);<br>fG3[cnt] *= <span class="hljs-built_in">cos</span>(omega3 * t);<br>tf_fG1[cnt] = (tf) &#123;t, fG1[cnt]&#125;;<br>tf_fG2[cnt] = (tf) &#123;t, fG2[cnt]&#125;;<br>tf_fG3[cnt] = (tf) &#123;t, fG3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">double</span> GfG1[MAXN], GfG2[MAXN], GfG3[MAXN];<br>wF wf_gfg1[MAXN], wf_gfg2[MAXN], wf_gfg3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>GfG1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG1, g_length);<br>GfG2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG2, g_length);<br>GfG3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG3, g_length);<br>GfG1[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG2[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG3[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>wf_gfg1[cnt] = (wF) &#123;w, GfG1[cnt]&#125;;<br>wf_gfg2[cnt] = (wF) &#123;w, GfG2[cnt]&#125;;<br>wf_gfg3[cnt] = (wF) &#123;w, GfG3[cnt]&#125;;<br>++cnt;<br>&#125;<br>length = cnt;<br><span class="hljs-type">double</span> finalf1[MAXN], finalf2[MAXN], finalf3[MAXN];<br><span class="hljs-type">double</span> MSE[<span class="hljs-number">4</span>];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10</span>; t &lt;= <span class="hljs-number">10</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>finalf1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg1, length);<br>finalf2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg2, length);<br>finalf3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg3, length);<br>MSE[<span class="hljs-number">1</span>]+=(finalf1[cnt]-f1[cnt])*(finalf1[cnt]-f1[cnt]);<br>MSE[<span class="hljs-number">2</span>]+=(finalf2[cnt]-f2[cnt])*(finalf2[cnt]-f2[cnt]);<br>MSE[<span class="hljs-number">3</span>]+=(finalf3[cnt]-f3[cnt])*(finalf3[cnt]-f3[cnt]);<br>++cnt;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i) MSE[i]/=(cnt*<span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MSE%d = %.9lf\n&quot;</span>,i,MSE[i]);<br><span class="hljs-function">Graph <span class="hljs-title">outputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;output.ppm&quot;</span>)</span></span>;<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf1, cnt, line_blue);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf2, cnt, line_green);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf3, cnt, line_red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>"arrayToPPM2.hpp"</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 999999999</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstdio&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstdlib&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cmath&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFuncY(x1,y1,x2,y2,y) ((y-y1)*(x2-x1)/(y2-y1)+x1)</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*fun_P)</span> <span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;<br><span class="hljs-function">T <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;<br>a = b;<br>b = c;<br>&#125;<br><br><span class="hljs-function">PPMdata <span class="hljs-title">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>PPMdata ans;<br>ans.r = r, ans.g = g, ans.b = b;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">private</span>:<br>PPMdata **matrix;<br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> height;<br><span class="hljs-type">double</span> centerX;<br><span class="hljs-type">double</span> centerY;<br><span class="hljs-type">double</span> rangeX;<br><span class="hljs-type">double</span> rangeY;<br><span class="hljs-type">double</span> gridX;<br><span class="hljs-type">double</span> gridY;<br>PPMdata line, grid, bgc, axis;<br><span class="hljs-type">char</span> *fileName;<br><br><span class="hljs-type">double</span> stepX, stepY;<br><span class="hljs-type">bool</span> drawed;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> idth,<br>      <span class="hljs-type">int</span> eight,<br>      <span class="hljs-type">double</span> enterX,<br>      <span class="hljs-type">double</span> enterY,<br>      <span class="hljs-type">double</span> angeX,<br>      <span class="hljs-type">double</span> angeY,<br>      <span class="hljs-type">double</span> ridX,<br>      <span class="hljs-type">double</span> ridY,<br>      PPMdata ine,<br>      PPMdata rid,<br>      PPMdata ack,<br>      PPMdata xis,<br>      <span class="hljs-type">char</span> *fName);<br>~<span class="hljs-built_in">Graph</span>();<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> y2,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> size,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawPos</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">drawXY</span><span class="hljs-params">(<span class="hljs-type">double</span> *x, <span class="hljs-type">double</span> *y, <span class="hljs-type">int</span> arrayLen,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num2MatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">bool</span> flag)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>Graph::<span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> idth,<br>             <span class="hljs-type">int</span> eight,<br>             <span class="hljs-type">double</span> enterX,<br>             <span class="hljs-type">double</span> enterY,<br>             <span class="hljs-type">double</span> angeX,<br>             <span class="hljs-type">double</span> angeY,<br>             <span class="hljs-type">double</span> ridX,<br>             <span class="hljs-type">double</span> ridY,<br>             PPMdata ine,<br>             PPMdata rid,<br>             PPMdata ack,<br>             PPMdata xis,<br>             <span class="hljs-type">char</span> *fName) &#123;<br>width = idth;<br>height = eight;<br>centerX = enterX;<br>centerY = enterY;<br>rangeX = angeX;<br>rangeY = angeY;<br>gridX = ridX;<br>gridY = ridY;<br>line = ine;<br>grid = rid;<br>bgc = ack;<br>axis = xis;<br>fileName = fName;<br>drawed = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br>matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PPMdata *) * height);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(width, <span class="hljs-built_in">sizeof</span>(PPMdata));<br>&#125;<br><br>stepX = rangeX / (width * <span class="hljs-number">1.0</span>);<br>stepY = rangeY / (height * <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>matrix[i][j] = bgc;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br><span class="hljs-built_in">drawPos</span>(<span class="hljs-built_in">num2MatPos</span>(centerX + i * gridX, <span class="hljs-number">1</span>), j, grid);<br><span class="hljs-built_in">drawPos</span>(<span class="hljs-built_in">num2MatPos</span>(centerX - i * gridX, <span class="hljs-number">1</span>), j, grid);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">drawPos</span>(j, <span class="hljs-built_in">num2MatPos</span>(centerY + i * gridY, <span class="hljs-number">0</span>), grid);<br><span class="hljs-built_in">drawPos</span>(j, <span class="hljs-built_in">num2MatPos</span>(centerY - i * gridY, <span class="hljs-number">0</span>), grid);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br><span class="hljs-built_in">drawPos</span>(i, height / <span class="hljs-number">2</span>, axis);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-built_in">drawPos</span>(width / <span class="hljs-number">2</span>, i, axis);<br>&#125;<br><br>&#125;<br><br>Graph::~<span class="hljs-built_in">Graph</span>() &#123;<br><span class="hljs-keyword">if</span> (drawed == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Object has been deleted!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::draw</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (drawed) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This Graph has been drawed in %s.\n&quot;</span>, fileName);<br>&#125;<br><span class="hljs-built_in">freopen</span>(fileName, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = height - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; --i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">fclose</span>(stdout);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>drawed = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Graph::num2MatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">bool</span> flag)</span> </span>&#123;<br><span class="hljs-comment">//flag=1 x else y</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(width / <span class="hljs-number">2</span> + (num - centerX) / rangeX * width);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">return</span> (<span class="hljs-type">int</span>)(height / <span class="hljs-number">2</span> + (num - centerY) / rangeY * height);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::drawPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> size,PPMdata color)</span> </span>&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">num2MatPos</span>(x, <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> v = <span class="hljs-built_in">num2MatPos</span>(y, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br><span class="hljs-type">int</span> U = u + i, V = v + j;<br><span class="hljs-keyword">if</span> (U &gt;= width || U &lt; <span class="hljs-number">0</span> || V &gt;= height || V &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> matrix[V][U] = color;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::drawPos</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, PPMdata color)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> matrix[v][u] = color;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph::drawLine</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2,PPMdata color)</span> </span>&#123;<br><span class="hljs-type">int</span> u1, u2, v1, v2;<br>u1 = <span class="hljs-built_in">num2MatPos</span>(x1, <span class="hljs-number">1</span>);<br>u2 = <span class="hljs-built_in">num2MatPos</span>(x2, <span class="hljs-number">1</span>);<br>v1 = <span class="hljs-built_in">num2MatPos</span>(y1, <span class="hljs-number">0</span>);<br>v2 = <span class="hljs-built_in">num2MatPos</span>(y2, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (u1 &gt;= width || u1 &lt; <span class="hljs-number">0</span> || u2 &gt;= width || u2 &lt; <span class="hljs-number">0</span> || v1 &gt;= height || v1 &lt; <span class="hljs-number">0</span> || v2 &gt;= height || v2 &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawLineError:out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">double</span> k = INF;<br><span class="hljs-keyword">if</span> (u2 != u1)<br>k = (v2 * <span class="hljs-number">1.0</span> - v1 * <span class="hljs-number">1.0</span>) / (u2 * <span class="hljs-number">1.0</span> - u1 * <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(k) &gt;= <span class="hljs-number">2.0</span>) &#123;<br><span class="hljs-keyword">if</span> (y1 &gt; y2) &#123;<br><span class="hljs-built_in">swap</span>(x1, x2);<br><span class="hljs-built_in">swap</span>(y1, y2);<br>&#125;<br>k=(x2-x1)/(y2-y1);<br><span class="hljs-type">double</span> x11=x1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> y = y1; y &lt;= y2; y += stepY) &#123;<br><span class="hljs-built_in">drawPoint</span>(x11, y, <span class="hljs-number">1</span>,color);<br>x11+=stepY*k;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(x1&gt;x2)&#123;<br><span class="hljs-built_in">swap</span>(x1,x2);<br><span class="hljs-built_in">swap</span>(y1,y2);<br>&#125;<br>k=(y2-y1)/(x2-x1);<br><span class="hljs-type">double</span> y11=y1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> x = x1; x &lt;= x2; x += stepX) &#123;<br><span class="hljs-built_in">drawPoint</span>(x, y11, <span class="hljs-number">1</span>,color);<br>y11+=stepX*k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph::drawXY</span><span class="hljs-params">(<span class="hljs-type">double</span> *x, <span class="hljs-type">double</span> *y_save, <span class="hljs-type">int</span> arrayLen,PPMdata color)</span> </span>&#123;<br><br><span class="hljs-type">double</span> *y = (<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) * (arrayLen + <span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i)<br>y[i] = y_save[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawXYError:X is not increasing.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawXYError:X out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br><span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (i &gt;= arrayLen) <span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">drawLine</span>(x[i - <span class="hljs-number">1</span>], y[i - <span class="hljs-number">1</span>], x[i], y[i],color);<br>&#125;<br><span class="hljs-built_in">free</span>(y);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于平面电磁波的那些事</title>
    <link href="/2022/06/15/%E5%85%B3%E4%BA%8E%E5%B9%B3%E9%9D%A2%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/15/%E5%85%B3%E4%BA%8E%E5%B9%B3%E9%9D%A2%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>主要是课本和PPT的总结，加了一点点我学习时的疑问和感悟。电磁场是真™的难，能学懂的都是神人，反正我是学不懂，哈人。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="平面电磁波相关概念">平面电磁波相关概念</h2><ul><li>等相面：同一时刻，空间振动相位相同的点连成的面</li><li>等幅面：同一时刻，空间振动幅度相同的点连成的面</li><li>平面波：等相面是平面的波</li><li>均匀平面波：也叫UPW，指等相面和等幅面重合的平面波。即：在均匀平面波的等相面上，波有相同的振幅</li><li>球面波：等相面是球面的波</li><li>柱面波：等相面是柱面的波</li><li>TEM波：电场强度和磁场强度矢量在传播方向上的分量为0的电磁波。均匀平面波一定是TEM波，反之不然。例：均匀球面波也是TEM波。</li></ul><h2 id="自由空间平面电磁波的时域解">自由空间平面电磁波的时域解</h2><p>由麦克斯韦方程组的推导，设源量为0，各量不随<span class="math inline">\(x,y\)</span>变化而变化（即等相位面是<span class="math inline">\(xoy\)</span>平面）。</p><p>由于 <span class="math display">\[\begin{aligned}\nabla\cdot \varepsilon_0E=0\\\\\nabla\cdot \mu_0H=0\end{aligned}\]</span> 因此<span class="math inline">\(E,H\)</span>的<span class="math inline">\(z\)</span>分量和<span class="math inline">\(z\)</span>无关。</p><p>由于 <span class="math display">\[\nabla \times H=\varepsilon \frac{\partial E} {\partial t}\]</span> 考虑<span class="math inline">\(i_z\)</span>分量，有： <span class="math display">\[\frac{\partial H_y} {\partial x}-\frac{\partial H_z} {\partial y}=\varepsilon _0\frac{\partial E_z} {\partial t}=0\]</span> 则<span class="math inline">\(E\)</span>的<span class="math inline">\(z\)</span>分量和时间无关(同理，<span class="math inline">\(H\)</span>也是)。因此<span class="math inline">\(E_z,H_z\)</span>是和时间，空间都没有关系的常数。在讨论时变场时不考虑常量，因此。 <span class="math display">\[\begin{aligned}E(z,t)=i_xE_x(z,t)+i_yE_y(z,t)\\\\H(z,t)=i_xH_x(z,t)+i_yH_y(z,t)\\\\\end{aligned}\]</span> 代入麦克斯韦方程 <span class="math display">\[\begin{aligned}\nabla \times E=-\mu_0\frac{\partial H} {\partial t}\\\\\nabla \times H=\varepsilon \frac{\partial E} {\partial t}\\\\\end{aligned}\]</span> 有 <span class="math display">\[\begin{cases}\frac{\partial E_y} {\partial z}=\mu_0\frac{\partial H_x} {\partial t}\\\\[2ex]\frac{\partial H_x} {\partial z}=\varepsilon_0\frac{\partial E_y} {\partial t}\\\\\end{cases}\]</span> 和 <span class="math display">\[\begin{cases}\frac{\partial E_x} {\partial z}=-\mu_0\frac{\partial H_y} {\partial t}\\\\[2ex]\frac{\partial H_y} {\partial z}=-\varepsilon_0\frac{\partial E_x} {\partial t}\\\\\end{cases}\]</span></p><p>一维波动方程（以第二组为例）： <span class="math display">\[\begin{aligned}\frac{\partial E_x} {\partial z^2}=\mu_0\varepsilon_0\frac{\partial^2 E_x} {\partial t^2}\\\\\frac{\partial^2 H_y} {\partial z^2}=\mu_0\varepsilon_0\frac{\partial^2H_y} {\partial t^2}\end{aligned}\]</span> 写成统一的形式： <span class="math display">\[\frac{\partial^2 u} {\partial z^2}=\frac{1} {v^2}\frac{\partial ^u} {\partial t^2}\]</span> 它的解实际上是宗量为<span class="math inline">\((z\pm vt)\)</span>的任意二阶可微分函数，即： <span class="math display">\[u=f(z\pm vt)\]</span> 那么结合麦克斯韦方程组，在电磁场中，它的解为： <span class="math display">\[\begin{aligned}E_x=f_1(z-vt)+f_2(z+vt)=E_x^+ + E_x^-\\\\H_y=\sqrt{\frac{\varepsilon_0} {\mu_0} }[f_1(z-vt)-f_2(z+vt)]=H_y^+ + H_y^-\end{aligned}\]</span> 同理，对1，有： <span class="math display">\[\begin{aligned}E_y=E_y^+ + E_y^-\\\\H_x=H_x^+ + H_x^-\end{aligned}\]</span> 那么所有沿着<span class="math inline">\(z\)</span>传播的平面波都可以写成上面四个解的线性组合。对于<span class="math inline">\(E\)</span>，有： <span class="math display">\[E=i_x(A_1E_x^+ + B_1E_x^-)+i_y(A_2E_y^+ + B_2E_y^-)\]</span> 于是，均匀平面波有这些传播特性：</p><ol type="1"><li><p>电场方向和磁场方向总和波的传播方向，也就是波印庭矢量的方向垂直，即： <span class="math display">\[S=E\times H\]</span></p></li><li><p>自由空间中，相速度等于光速，有： <span class="math display">\[v=c=(\mu_0\varepsilon_0)^{-1/2}\]</span></p></li><li><p>空间中任意一点，电场和磁场的波形和相位都相同，而且他们的数值之比是常数，这个比叫空间波阻抗，有： <span class="math display">\[\eta_0=\frac{|E|} {|H|}=\sqrt{\frac{\mu_0} {\varepsilon_0} }=120\pi\]</span></p></li><li><p>空间中任意一点，电场和磁场正交</p></li><li><p>空间中任意一点，电场和磁场的能量密度相等。</p></li></ol><p>## 正弦时变场和复数场定律</p><p>对于一个瞬时正弦时变场： <span class="math display">\[A(r,t)=i_xA_x(r)\cos\left[\omega t+\theta_x(r)\right]+i_yA_y(r)\cos\left[\omega t+\theta_y(r)\right]+i_zA_z(r)\cos\left[\omega t+\theta_z(r)\right]\]</span> 可以借鉴“相量法”的思想，把它写成复矢量形式： <span class="math display">\[A(r,t)=\Re[\tilde{A}(r)e^{j\omega t}]\]</span> 其中<span class="math inline">\(\tilde{A}(r)\)</span>就是我们所说的正弦量的复表示。有： <span class="math display">\[\tilde{A}(r)=i_xA_x(r)\angle\theta_x(r)+i_yA_y(r)\angle\theta_y(r)+i_zA_z(r)\angle\theta_z(r)\]</span> 在麦克斯韦方程组中，把对时间求导的<span class="math inline">\(\frac{\partial } {\partial t}\)</span>换成<span class="math inline">\(j\omega\)</span>，把各量换成复矢量表示，就得到了复数场定律。</p><p><strong>简单媒质</strong>中复数场定律如下： <span class="math display">\[\begin{aligned}\nabla \times \tilde{E}(\vec{r})&amp;=-j \omega \mu \widetilde{H}(\vec{r}) \\\\\nabla \times \widetilde{H}(\vec{r})&amp;=\tilde{J}_{f}(\vec{r})+j \omega \varepsilon \widetilde{E}(\vec{r}) \\\\\nabla \cdot \varepsilon \tilde{E}(\vec{r})&amp;=\dot{\rho}_{f}(\vec{r}) \\\\\nabla \cdot \mu \widetilde{H}(\vec{r})&amp;=0 \\\\\nabla \cdot \tilde{J}_{f}(\vec{r})&amp;=-j \omega \dot{\rho}_{f}(\vec{r})\end{aligned}\]</span></p><h2 id="正弦均匀平面波">正弦均匀平面波</h2><p>由复数场定律可导出<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>齐次亥姆霍兹方程： <span class="math display">\[\begin{aligned}\Delta\tilde{E}(r)+\beta^2\tilde{E}(r)=0\\\\\Delta\tilde{H}(r)+\beta^2\tilde{H}(r)=0\end{aligned}\]</span> 其中 <span class="math display">\[\beta=\omega\sqrt{\mu\varepsilon}=\frac{2\pi} {\lambda}\]</span> 我们知道沿<span class="math inline">\(z\)</span>传播的均匀平面波有两组独立的解<span class="math inline">\(\dot{E}_x-\dot{H}_y\)</span>和<span class="math inline">\(\dot{E}_y-\dot{H}_x\)</span>，只需讨论第一组，有解： <span class="math display">\[\dot{E}_x(z)=\dot{E}_{m_1}e^{j\beta z}+\dot{E}_{m_2}e^{ -j\beta z}\]</span> 结合 <span class="math display">\[\nabla\times\tilde{E}(r)=-j\omega\tilde{H}(r)\]</span> 可以求出<span class="math inline">\(\dot{H}_y\)</span>.</p><p>写出对应的时域表达式，有： <span class="math display">\[\begin{aligned}E_x(z,t)&amp;=\Re[\dot{E}_x(z)e^{j\omega t}]\\\\&amp;=|\dot{E}_{m1}|\cos(\omega t+\beta z+\alpha_1)+|\dot{E}_{m2}|\cos(\omega t-\beta z+\alpha_2)\\\\&amp;=|\dot{E}_{m1}|\cos\left[\beta(z+vt)+\alpha_1\right]+|\dot{E}_{m2}|\cos\left[\beta(z-vt)+\alpha_2\right]\end{aligned}\]</span> 其中<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(\dot{E}_m\)</span>的幅角。于是，各项的物理意义便很明显了：复振幅<span class="math inline">\(\dot{E}_m\)</span>反映了电场在<span class="math inline">\(z=0\)</span>点的初始振幅和相位，而<span class="math inline">\(e^{\pm j\beta z}\)</span>反映了相位随空间位置的变化和波的传播情况。其中<span class="math inline">\(\beta\)</span>称为空间相位常数。</p><h3 id="复数场极化方向的判断">复数场极化方向的判断</h3><p>电场的极化方向也就是说电场矢量尖端在和电磁场传播方向垂直的平面上划出的轨迹形状。有圆、椭圆、线极化三种。在判断复数场的极化方向时，有以下的操作步骤。</p><p>对于复数场 <span class="math display">\[\begin{aligned}\tilde{E}(r)&amp;=\dot{E}_me^{-j\beta z}\\\\&amp;=[E_R(z)+j\cdot E_I(z)]e^{-j\beta z}\end{aligned}\]</span></p><ol type="1"><li><p>线极化：以下三条件<strong>任意</strong>满足一项 <span class="math display">\[E_R(z)=0,\ E_I(z)=0, E_R(z)//E_I(z)\]</span></p></li><li><p>圆极化：<strong>同时</strong>满足以下条件 <span class="math display">\[E_R(z)\cdot E_I(z)=0 ,\ |E_R(z)|=|E_I(z)|\]</span></p></li><li><p>椭圆极化：其余情况。</p></li></ol><p>判断左旋还是右旋的方法是：在右手系（即右手从<span class="math inline">\(x\)</span>轴握向<span class="math inline">\(y\)</span>轴，大拇指指向<span class="math inline">\(z+\)</span>方向）中，画出电磁场传播方向（也就是波因亭矢量的方向）、<span class="math inline">\(E_R\)</span>、<span class="math inline">\(E_I\)</span>，然后用右手从<span class="math inline">\(E_I\)</span>向<span class="math inline">\(E_R\)</span>握，如果大拇指指向<span class="math inline">\(S\)</span>，那么就是右旋，否则是左旋。</p><h3 id="空间任意方向电磁场的表达">空间任意方向电磁场的表达</h3><p>前面我们讨论的都是沿着<span class="math inline">\(z\)</span>轴的电磁场。如果指向<span class="math inline">\(i_xa+i_yb+i_zc\)</span>的电磁场，我们就要改变<span class="math inline">\(e\)</span>的指数。有： <span class="math display">\[\tilde{E}(r)=\dot{E}_me^{-j(ax+by+cz)}\]</span> 这时，<span class="math inline">\(\beta=\sqrt{a^2+b^2+c^2}\)</span>.</p><p>通过例题来感受一下。</p><blockquote><p>【例】已知均匀平面波的电场为 <span class="math display">\[E(\boldsymbol{r},t)=10(i_x+2i_y+E_zi_z)\cos(\omega t+3x-y-z)\]</span> 求：传播方向（用单位矢量表示），波长，角频率，极化状态，磁场（用复矢量表示）</p><p>【解】 <span class="math display">\[\begin{aligned}\tilde{E}(\boldsymbol{r})&amp;=\dot{E}_0e^{-j\boldsymbol{\beta \cdot r} }\\\\&amp;=10(i_x+2i_y+E_zi_z)e^{-j(-3x+y+z)}\\\\\end{aligned}\]</span> 波的传播方向： <span class="math display">\[\boldsymbol{i}_\beta=\frac{\boldsymbol{\beta} } {|\boldsymbol{\beta}|}=\frac{-3i_x+i_y+i_z} {\sqrt{3^2+1+1} }=\left(\frac{-3} {\sqrt{11} },\frac 1{\sqrt{11} },\frac 1{\sqrt{11} }\right)\]</span> 波长： <span class="math display">\[\lambda=\frac{2\pi} {\beta}=\frac{2\pi} {\sqrt{11} }=1.89\text{(m)}\]</span> 角频率： <span class="math display">\[\omega=\beta c=3\sqrt{11}\times 10^8 \text{(rad/s)}\]</span> 由于电场方向和电磁场传播方向应该正交，即： <span class="math display">\[\boldsymbol{\beta}\cdot \dot{E}_0=0\]</span> 则解得<span class="math inline">\(E_z=1\)</span></p><p>由于满足 <span class="math display">\[\Im[E_0]=0\]</span> 因此是线极化波。</p><p>由 <span class="math display">\[H=\frac 1{\eta_0}i_\beta\times\tilde{E}(r,t)\]</span> 可求得<span class="math inline">\(H\)</span>.</p></blockquote><h2 id="复数形式场的功率讨论">复数形式场的功率讨论</h2><h3 id="复矢量乘积的意义">复矢量乘积的意义</h3><p>容易证明：两个复矢量的共轭叉（点）积的实部的一半等于相应的正弦时变量叉（点）积的时间平均值。</p><p>即： <span class="math display">\[\langle\vec{A}(t) \times \vec{B}(t)\rangle=\frac{1} {2} \operatorname{Re}\left(\tilde{A} \times \tilde{B}^{*}\right)\]</span></p><p><span class="math display">\[\langle\vec{A}(t) \cdot \vec{B}(t)\rangle=\frac{1} {2} \operatorname{Re}\left(\tilde{A} \cdot \tilde{B}^{*}\right)\]</span></p><p>证明提示：</p><p>用公式 <span class="math display">\[\vec{A}(t)=\frac{1} {2}\left[\tilde{A} e^{j \omega t}+\tilde{A}^{*} e^{-j \omega t}\right]\]</span> 把时变量运算式中的时变量和复矢量关联起来。</p><h3 id="复数坡印廷矢量">复数坡印廷矢量</h3><p>在前面，我们学过时域坡印廷矢量： <span class="math display">\[\boldsymbol{S}(\boldsymbol{r},t)=\boldsymbol{E}(\boldsymbol{r},t)\times\boldsymbol{H}(\boldsymbol{r},t)\]</span> 将电场，磁场的时域表达式用复数形式来表示，即： <span class="math display">\[\begin{aligned}\boldsymbol{E}(\boldsymbol{r},t)=\frac 12[\tilde{E}(r)e^{j\omega t}+\tilde{E}^*(r)e^{-j\omega t}]\\\\\boldsymbol{H}(\boldsymbol{r},t)=\frac 12[\tilde{H}(r)e^{j\omega t}+\tilde{H}^*(r)e^{-j\omega t}]\end{aligned}\]</span> 代入： <span class="math display">\[\boldsymbol{S}(\boldsymbol{r},t)=\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)]+\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)2^{j2\omega t}]\]</span> 定义复数坡印廷矢量： <span class="math display">\[\tilde{S}(r)=\frac 12 \tilde{E}(r)\times\tilde{H}^*(r)\]</span> 则有： <span class="math display">\[\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)]=\langle S(r,t)\rangle=\Re[\tilde{S}(r)]\]</span> 于是，我们可以说：复数坡印廷矢量的实部表示有功功率流密度，虚部可以解释为无功功率流密度。（这里可以类比电路分析中的复功率<span class="math inline">\(\dot{P}=\dot{V}_m\dot{I}_m/2=P+jQ\)</span>）</p><h3 id="复数坡印廷定理">复数坡印廷定理</h3><p>复数坡印廷定理的微分形式表达式如下： <span class="math display">\[-\nabla \cdot \tilde{S}(\vec{r})-\frac{1} {2}\left[\tilde{E}(\vec{r}) \cdot \tilde{J}_{S}^{*}(\vec{r})\right]=\frac{1} {2}\left[\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})\right]+j 2 \omega\left[\frac{\mu} {4}|\widetilde{H}(\vec{r})|^{2}-\frac{\varepsilon} {4}|\tilde{E}(\vec{r})|^{2}\right]\]</span> 为了理解其中各项物理意义，解释如下：</p><ul><li><p>等号左边第二项 <span class="math display">\[\Re\left[-\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{S}^{*}(\vec{r})\right]=\langle J_s(r,t)\times E(r,t)\rangle=\langle p_s(r,t)\rangle\]</span> 这一项表示电源提供的有功功率</p></li><li><p>等号右边第一项 <span class="math display">\[\Re\left[\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})\right]=\langle p_d(r,t)\rangle\]</span> 这一项表示电阻消耗的功率（即焦耳热功率）。注意：因为 <span class="math display">\[\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})=\frac 12\sigma |\tilde{E}(r)|^2\]</span> 所以这一项实际上是纯实数。</p></li><li><p>等号右边第二项 <span class="math display">\[\frac{\mu} {4}|\widetilde{H}(\vec{r})|^{2}=\langle\frac 12 \mu H(r,t)\cdot H(r,t)\rangle=\langle w_m(r,t)\rangle\]</span> 这一项可以理解为电感能量，也是纯实数（乘以前面的系数就是纯虚数了）</p></li><li><p>等号右边第三项 <span class="math display">\[\frac{\varepsilon} {4}|\tilde{E}(\vec{r})|^{2}=\langle\frac 12 \varepsilon E(r,t)\cdot E(r,t)\rangle=\langle w_e(r,t)\rangle\]</span> 这一项可以理解为电容的能量。</p></li></ul><p>我们把上面那个式子的实部和虚部拆开，有：</p><ul><li><p>实部： <span class="math display">\[\langle-\nabla \cdot \vec{S}(\vec{r}, t)\rangle+\left\langle p_{s}(\vec{r}, t)\right\rangle=\left\langle p_{d}(\vec{r}, t)\right\rangle\]</span> 电磁场向某点提供的电磁功率密度的时间平均值（有功电磁功率密度）与电源向该点提供的电磁功率密度的时间平均值（有功电磁功率密度）之和，等于该点焦耳热损耗功率密度的时间平均值。</p></li><li><p>虚部 <span class="math display">\[-\operatorname{Im}[\nabla \cdot \tilde{S}(\vec{r})]+q_{S}(\vec{r})=2 \omega\left[\left\langle w_{m}(\vec{r}, t)\right\rangle-\left\langle w_{e}(\vec{r}, t)\right\rangle\right]\]</span> 电磁场和电源向某点提供的无功电磁功率密度等于该点的磁能功率密度时间平均值和电能功率密度时间平均值之差的<span class="math inline">\(2𝜔\)</span>倍</p></li></ul><h2 id="平面波在有耗媒质中的传播">平面波在有耗媒质中的传播</h2><p>有耗媒质的根本特征是其电导率<span class="math inline">\(\sigma\)</span>不为零，进而，其中的传导电流<span class="math inline">\(J_d\)</span>不为零。因此，电磁波在其中传播时会产生损耗。特别的，如果电导率很高，以至于成为导体（例如金属），那么电磁波在其中几乎不能传播，只能在表面传播，这叫做“趋肤效应”。电磁波不能在理想导体中传播。</p><p>考虑复数形式的修正安培环路定律： <span class="math display">\[\nabla \times \tilde{H}(r)=\tilde{J}+j\omega \varepsilon\tilde{E}(r)\]</span> 将 <span class="math display">\[\tilde{J}=\sigma\tilde{E}(r)\]</span> 代入，有： <span class="math display">\[\nabla \times \tilde{H}(r)=\sigma\tilde{E}(r)+j\omega \varepsilon\tilde{E}(r)=j\omega\left(\frac{\sigma} {j\omega}+\varepsilon\right)\tilde{E}(r)\]</span> 定义复介电常数： <span class="math display">\[\dot{\varepsilon}=\left(\frac{\sigma} {j\omega}+\varepsilon\right)\]</span> 用复介电常数替换复麦克斯韦方程组中<strong>所有</strong>的介电常数，就能得到有耗媒质中的场定律。</p><p>需要注意的是，这时候波阻抗也变成了复数，即： <span class="math display">\[\dot{\eta}=\frac{\mu} {\dot{\varepsilon} }\]</span> 仿照前面的过程<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，导出复亥姆霍兹方程。仿照传播常数(波数)<span class="math inline">\(\beta\)</span>，定义复传播常数 <span class="math display">\[\dot{k}=\omega\sqrt{\dot{\varepsilon}\mu}=\beta-j\alpha\]</span> 那么，在有耗媒质中传播的电磁波的电场和磁场的复表示如下： <span class="math display">\[\begin{aligned}&amp;\widetilde{E}(r)=\hat{\imath}_{x} \dot{E}_{x 0} e^{-\alpha z} e^{-j \beta z}=\hat{\imath}_{x}\left|\dot{E}_{x 0}\right| e^{j \varphi_{x 0} } e^{-\alpha z} e^{-j \beta z} \\\\&amp;\widetilde{H}(r)=\hat{\imath}_{y} \frac{\dot{E}_{x 0} } {\dot{\eta} } e^{-\alpha z} \cdot e^{-j \beta z}=\hat{\imath}_{y}\left|\frac{\dot{E}_{x 0} } {\dot{\eta} }\right| e^{j\left(\varphi_{x 0}-\varphi_{\eta}\right)} e^{-\alpha z} e^{-j \beta z}\end{aligned}\]</span> 这里之所以要特意把<span class="math inline">\(\dot{E}_{x0}\)</span>以及<span class="math inline">\(\dot{E}_{x0}/\dot{\eta}\)</span>拆开成模长-幅角模式来写，是为了体现平面波在有耗媒质中的传播特点。</p><p>在有耗无源简单媒质中传播的均匀平面波是一个沿传播方向衰减的均匀平面波，衰减因子用<span class="math inline">\(\alpha\)</span>表示。电磁波频率越高，衰减因子越大，最终会趋向于 <span class="math display">\[\max \alpha=\frac {\sigma} {2}\sqrt{\frac{\mu} {\varepsilon} }\]</span> <strong>且磁场与电场不再同相</strong>。这是因为波阻抗不再是实数。</p><h3 id="导体的趋肤效应">导体的趋肤效应</h3><p>导体的电导率<span class="math inline">\(\sigma\)</span>越大，衰减因子也就越大。透入深度表示幅度衰减为<span class="math inline">\(e^{-1}\)</span>的深度，对良导体，其值为： <span class="math display">\[\delta=\sqrt{\frac 2{\omega\sigma\mu} }\]</span></p><h2 id="平面波的反射和折射">平面波的反射和折射</h2><h3 id="相关概念">相关概念</h3><ul><li><p>入射线：入射波波矢量<span class="math inline">\(\boldsymbol{\beta}_i\)</span>所在的直线</p></li><li><p>入射面：同时包含入射线和界面法线的平面</p></li><li><p>入射角：入射线和法线的夹角</p></li><li><p>反射线：反射波波矢量<span class="math inline">\(\boldsymbol{\beta}_r\)</span>所在的直线</p></li><li><p>反射面：同时包含反射线和界面法线的平面</p></li><li><p>反射角：反射线和法线的夹角</p></li><li><p>折射线：折射波波矢量<span class="math inline">\(\boldsymbol{\beta}_\tau\)</span>所在的直线</p></li><li><p>折射角：折射线和界面法线的夹角</p></li><li><p>垂直极化：线极化波的电场和入射面垂直</p></li><li><p>平行极化<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>：线极化波的电场和入射面平行</p></li><li><p>媒质的折射指数（折射率）： <span class="math display">\[n=\sqrt{\mu_r\varepsilon_r}\]</span> 其中<span class="math inline">\(\mu_r,\varepsilon_r\)</span>是相对磁导率和相对介电常数<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p></li><li><p>媒质的波数： <span class="math display">\[\beta=\omega\sqrt{\mu_1\varepsilon_1}=\beta_0n_1\]</span></p></li><li><p>媒质的波阻抗： <span class="math display">\[\eta_1=\sqrt{\frac{\mu_1} {\varepsilon_1} }=\eta_0\sqrt{\frac{\mu_{r1} } {\varepsilon_{r1} }}\]</span></p></li><li><p>Snell定律</p><ul><li>反射线和折射线都在入射面内</li><li>反射角等于入射角</li><li>折射角和入射角的正弦之比等于折射率之比，也等于波数之比和波的传播速度之比。</li></ul></li><li><p>光密（疏）介质：一个媒质的折射指数（折射率）越大，光（电磁波）在其中传播的速度越慢，波数<span class="math inline">\(\beta\)</span>越大，它就越可以被称为光密介质。真空是最疏的介质。</p></li></ul><h3 id="自由空间和理想导体界面的反射">自由空间和理想导体界面的反射</h3><h4 id="正入射">正入射</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/5711CB1D86975C4E56B6223EE37219FC.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图所示，入射波为 <span class="math display">\[\begin{aligned}\tilde{E}(r)=i_x\dot{E}_{i0}e^{-j\beta_0z}\\\\\tilde{H}(r)=i_y\frac{\dot{E}_{i0} } {\eta_0}e^{-j\beta_0z}\end{aligned}\]</span> 那么反射波的形式为： <span class="math display">\[\begin{aligned}\tilde{E}_r(r)=i_x\dot{E}_{r0}e^{j\beta_0z}\\\\\tilde{H}_r(r)=i_y\frac{\dot{E}_{r0} } {\eta_0}e^{j\beta_0z}\end{aligned}\]</span> 下面求<span class="math inline">\(\dot{E}_{r0}\)</span>。由边界条件： <span class="math display">\[i_n\times(\tilde{E}_1-\tilde{E}_2)=0\]</span> 其中： <span class="math display">\[\begin{aligned}\tilde{E}_1&amp;=\tilde{E}_i+\tilde{E}_r\\\\\tilde{E}_2&amp;=0\\\\i_n&amp;=-i_z\end{aligned}\]</span> 代入，得： <span class="math display">\[\dot{E_{r0} }=-\dot{E}_{i0}\]</span> 则有： <span class="math display">\[\begin{aligned}\tilde{E}_r(r)=-i_x\dot{E}_{i0}e^{j\beta_0z}\\\\\tilde{H}_r(r)=-i_y\frac{\dot{E}_{i0} } {\eta_0}e^{j\beta_0z}\end{aligned}\]</span> 合成波表达式为<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>： <span class="math display">\[\begin{aligned}\tilde{E}(r)=-2j\cdot i_x \dot{E}_{i0}\sin \beta_0z\\\\\tilde{H}(r)=2\cdot i_y\frac{\dot{E}_{i0} } {\eta_0}\cos \beta_0z\end{aligned}\]</span> 为了研究合成波的性质，我们把它转换到时域： <span class="math display">\[\begin{aligned}E(r,t)=i_x\cdot2|\dot{E}_{i0}|(\sin\beta_0z)\sin(\omega t+\varphi)\\\\H(r,t)=i_y\cdot\frac{2} {\eta_0}|\dot{E}_{i0}|(\cos\beta_0z)\cos(\omega t+\varphi)\end{aligned}\]</span> 我们可以看到，这表达了一列驻波。在驻波中电场和磁场有所谓“三个90度”关系，即：</p><ul><li>电场和磁场在空间分布上的相位差为90度。这说明：电场最强的 <strong>地方</strong> 磁场最弱。</li><li>电场和磁场在时间分布上的相位差为90度。这说明：电场最强的 <strong>时刻</strong> 磁场最弱。</li><li>电场和磁场在空间方向上相差90度。</li></ul><p>在驻波中，没有能量指向性的传播，只有能量形式的转换。</p><h4 id="斜入射">斜入射</h4><p>首先以垂直极化为例分析问题：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220617223348.png" /></p><p><strong>特别注意：不要看着这张图上面画了线，就以为电磁波“只在那条线上存在”，我们这里讨论的是平面波，入射波、反射波都在<span class="math inline">\(z&lt;0\)</span>整个空间上存在，所以可以直接合成，不需要也不应该考虑位置。</strong></p><p>入射方向： <span class="math display">\[\vec{\beta}_{i}=\beta_{0}\left(i_{x} \sin \theta_{i}+i_{z} \cos \theta_{i}\right)\]</span> 反射方向： <span class="math display">\[\vec{\beta}_{r}=\beta_{0}\left(i_{x} \sin \theta_{r}-i_{z} \cos \theta_{r}\right)\]</span> 那么，分别有入射场和反射场： <span class="math display">\[\begin{aligned}\tilde{E}_{i} &amp;=i_{y} \dot{E}_{i 0} e^{-j \vec{\beta}_{i} \cdot \vec{r} }=i_{y} \dot{E}_{i 0} e^{-j \beta_{0}\left(x \sin \theta_{i}+z \cos \theta_{i}\right)} \\\\\tilde{E}_{r} &amp;=i_{y} \dot{E}_{r 0} e^{-j \beta_{0}\left(x \sin \theta_{r}-z \cos \theta_{r}\right)}\end{aligned}\]</span> 由边界条件计算，得： <span class="math display">\[\dot{E}_{r0}=-\dot{E}_{i0}\]</span> 那么空间中的合成电场为：</p>$$<span class="math display">\[\begin{aligned}\tilde{E}&amp;=\tilde{E}_{i}+\tilde{E}_{r}=i_{y}\left[\dot{E}_{i 0} e^{-j \beta_{0}(x \sin \theta+z \cos \theta)}-\dot{E}_{i 0} e^{-j \beta_{0}(x \sin \theta-z \cos \theta)}\right]\\\\&amp;=i_{y} \dot{E}_{i 0}\left(e^{-j \beta_{0} z \cos \theta}-e^{j \beta_{0} z \cos \theta}\right) e^{-j \beta_{0} x \sin \theta}\\\\&amp;=-i_{y} \dot{E}_{i 0} j 2 \sin \left(\beta_{0} z \cos \theta\right) e^{-j \beta_{0} x \sin \theta} \end{aligned}\]</span><p>$$</p><p>记 <span class="math inline">\(\beta_0\cos \theta=\beta_z,\beta_0\sin\theta=\beta_x\)</span> ，有：</p><p><span class="math display">\[\tilde{E}=-i_{y} 2 j \dot{E}_{i 0} \sin \beta_{z} z \cdot e^{-j \beta_{x} x}\]</span></p><p>再由麦克斯韦方程组可求得磁场。</p><p>观察<span class="math inline">\(\tilde{E}\)</span>的表达式，我们发现有以下特点：</p><ol type="1"><li>在<span class="math inline">\(x\)</span>是常数的平面上，<span class="math inline">\(e^{-j\beta_xx}\)</span>是常数，所以<span class="math inline">\(x=C\)</span>是波的等相面。在<span class="math inline">\(x=C\)</span>的平面上，场量按三角函数形式分布，波显示出驻波性质。</li><li>在<span class="math inline">\(z\)</span>是常数的平面上，<span class="math inline">\(\sin \beta_zz\)</span>是常数，波的表达式表现出一般平面波的形式，是行波。而且在等相面上振幅不是常数，是非均匀平面波。</li><li>于是，我们可以发现：合成波只在<span class="math inline">\(x\)</span>方向有能量传输，而在<span class="math inline">\(z\)</span>方向没有。</li></ol><p>正入射时，入射波和反射波的合成波形成了一种特殊的传播方式，我们称之为驻波。 <strong>斜入射时，入射波和反射波的合成波也形成了一种特殊的传播方式，我们称之为导行波。</strong> 这里的电场指向<span class="math inline">\(y\)</span>，和传播方向垂直，我们称之为横电波（TE波）。</p><p>导行波的等相面是 <span class="math display">\[\omega t-\beta_x x=C\]</span> 因此，其相速度为 <span class="math display">\[v_p=\frac c {\sin\theta}\]</span> 神奇！相速度超过了光速！但是我们都知道光速是无论如何不能超过的，这是怎么回事呢？我们要先理解相速度和群速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/v2-192809449ccca511cddfb1735ed54b8d_720w.gif" alt="这个图片只用来说明相速度和群速度的概念" /><figcaption aria-hidden="true">这个图片只用来说明相速度和群速度的概念</figcaption></figure><ul><li>相速度是等相位面传播的速度，也就是图中红色方块的速度。</li><li>群速度的波包移动的速度，是能量传递的速度，也就是绿色圆点移动的速度。</li></ul><p>我们可以看出，只有群速度是真正的速度。譬如说，我拿着一个激光笔扫过夜空，那么激光笔在云层上反射的光点可能会具有非常非常非常高的速度，那么难道说真的有物体在以这个速度移动吗？不是这样的。相速度只是一种“看起来”的速度，是一个虚假的速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/0F8C440DC9578247F927A8C922F4A842.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图，在这个情景中，黑色的实线和虚线是等相位面，蓝色是相速度，绿色是群速度，红色是光速。这么一说大家应该可以理解了。在一个周期里，导行波过<span class="math inline">\(A\)</span>点的等相位面的相位传到了<span class="math inline">\(C\)</span>点，从<span class="math inline">\(X\)</span>方向看，就像是相位从<span class="math inline">\(B\)</span>移动到了<span class="math inline">\(C\)</span>，而此时能量只是从A移动到了<span class="math inline">\(C’\)</span>。</p><p>在平行极化时，合成波的磁场是横向的，电场是<span class="math inline">\(xOz\)</span>面内的椭圆极化波。合成波依然在<span class="math inline">\(x\)</span>方向表现行波，在<span class="math inline">\(z\)</span>方向表现为驻波。这种波叫横磁波（TM波）。</p><h3 id="在两种理想介质分界面处的反射和折射">在两种理想介质分界面处的反射和折射</h3><p>这里讨论的是两种均匀、线性、各向同性、无耗理想介质分界面处的反射和折射。</p><h4 id="两种无耗介质交界面的垂直入射">两种无耗介质交界面的垂直入射</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/12414515.png" /></p><p>入射波为 <span class="math display">\[\begin{aligned}\tilde{E}(r)=i_x\dot{E}_{i0}e^{-j\beta_0z}\\\\\tilde{H}(r)=i_y\frac{\dot{E}_{i0} } {\eta_0}e^{-j\beta_0z}\end{aligned}\]</span> 不难写出反射波，折射波的表达式：只需要把入射波中的<span class="math inline">\(E_{i0}\)</span>换成<span class="math inline">\(E_{r0},E_{\tau 0}\)</span>，再注意一下方向就行了，十分的简单。我们的问题现在是：<span class="math inline">\(E_{i0}\)</span>和<span class="math inline">\(E_{r0},E_{\tau 0}\)</span>的关系是？</p><p>由边界条件： <span class="math display">\[\begin{aligned}i_{n} \times\left.\left(\tilde{E}_{1}-\tilde{E}_{2}\right)\right|_{z=0}=0 \quad \\\\i_{n} \times\left.\left(\widetilde{H}_{1}-\widetilde{H}_{2}\right)\right|_{z=0}=\tilde{k}_{f}=0\end{aligned}\]</span> 得： <span class="math display">\[\left\{\begin{array} {l}\dot{E}_{i 0}+\dot{E}_{r 0}=\dot{E}_{\tau 0} \\\\\dot{H}_{i 0}-\dot{H}_{r 0}=\dot{H}_{\tau 0} \Rightarrow \frac{\dot{E}_{i 0} } {\eta_{1} }-\frac{\dot{E}_{r 0} } {\eta_{1} }=\frac{\dot{E}_{\tau 0} } {\eta_{2} }\end{array}\right.\]</span></p><p>于是有反射系数： <span class="math display">\[\Gamma=\frac{\dot{E}_{r 0} } {\dot{E}_{i 0} }=\frac{\eta_{2}-\eta_{1} } {\eta_{2}+\eta_{1} }\]</span> 透射系数： <span class="math display">\[T=\frac{\dot{E}_{\tau 0} } {\dot{E}_{i 0} }=\frac{2 \eta_{2} } {\eta_{2}+\eta_{1} }\]</span></p><h4 id="三层介质垂直入射无反射条件">三层介质垂直入射无反射条件</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220617234904444.png" /></p><p>一般来说应用场景是：I是空气（真空），III是玻璃，II是增透膜，要求你调整增透膜的<span class="math inline">\(\eta_2\)</span>和厚度。有以下两种情况都能达到目的：</p><ol type="1"><li><span class="math inline">\(\eta_1=\eta_3,d=n\lambda_2/2\)</span></li><li><span class="math inline">\(\eta_2=\sqrt{\eta_1\eta_3},d=(2n+1)\lambda_2/4\)</span></li></ol><p>请注意，这里的波长是在介质2中的波长。电磁场在不同介质中，频率是不会变 ，而波长会变。</p><h4 id="斜入射-1">斜入射</h4><p>还是以垂直极化为例：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220617235606731.png" /></p><p>同样，由边界条件计算反射、透射系数，有：</p><p>反射系数： <span class="math display">\[\Gamma_{\perp}=\frac{\dot{E}_{r 0} } {\dot{E}_{i 0} }=\frac{\eta_{2} \cos \theta_{1}-\eta_{1} \cos \theta_{2} } {\eta_{2} \cos \theta_{1}+\eta_{1} \cos \theta_{2} }\]</span></p><p>透射系数： <span class="math display">\[T_{\perp}=\frac{\dot{E}_{\tau 0} } {\dot{E}_{i 0} }=\frac{2 \eta_{2} \cos \theta_{1} } {\eta_{2} \cos \theta_{1}+\eta_{1} \cos \theta_{2} }\]</span></p><p>有时候会出现一些神奇的现象：</p><ul><li><p>全反射</p><p>全反射无论是磁介质（<span class="math inline">\(\mu_r\neq 1\)</span>）还是电介质（<span class="math inline">\(\varepsilon_r\neq 1\)</span>）都可以产生。当从光密介质射入光疏介质时，当入射角达到一个临界值<span class="math inline">\(\theta_c\)</span>时，反射线和介质表面重合（反射角是<span class="math inline">\(\pi/2\)</span>），这时称为出现全反射现象，<span class="math inline">\(\theta_c\)</span>是全反射临界角。有： <span class="math display">\[\sin \theta_c=\frac{n_2} {n_1}\]</span></p></li><li><p>全折射 当入射波垂直极化时，在电介质交界面，不会出现全折射现象，只有磁介质交界面才会出现。无论从疏到密，还是从密到疏，都能发生全折射现象。全折射的临界角<span class="math inline">\(\theta_{P_\perp}\)</span>称为布茹斯特角。有： <span class="math display">\[\theta_{P_\perp}=\sqrt{\frac{\mu_2} {\mu_1+\mu_2} }\]</span></p></li></ul><p>我写了一个代码来计算反射系数和折射系数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">er1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质1的相对介电常数&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">mur1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质1的相对磁导率&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">er2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质2的相对介电常数&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">mur2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质2的相对磁导率&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">eta0</span><span class="hljs-operator">=</span><span class="hljs-number">120</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">;</span><br><span class="hljs-variable">eta1</span><span class="hljs-operator">=</span><span class="hljs-variable">eta0</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur1</span><span class="hljs-operator">/</span><span class="hljs-variable">er1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">eta2</span><span class="hljs-operator">=</span><span class="hljs-variable">eta0</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur2</span><span class="hljs-operator">/</span><span class="hljs-variable">er2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">n1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur1</span><span class="hljs-operator">*</span><span class="hljs-variable">er1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">n2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur2</span><span class="hljs-operator">*</span><span class="hljs-variable">er2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span><span class="hljs-built_in">ArcSin</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">*</span><span class="hljs-variable">n1</span><span class="hljs-operator">/</span><span class="hljs-variable">n2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Gammaa</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">-</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Tt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span> <span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Gammaa</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Tt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">theta</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-operator">,</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span><span class="hljs-built_in">PlotLegends</span><span class="hljs-operator">-&gt;</span><span class="hljs-string">&quot;Expressions&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>例如，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>会给出图像</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220618114117442.png" alt="全反射现象示意图" /><figcaption aria-hidden="true">全反射现象示意图</figcaption></figure><p>全反射现象十分明显。</p><p>再例如输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>会给出图像</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220618114215103.png" alt="全折射现象示意图" /><figcaption aria-hidden="true">全折射现象示意图</figcaption></figure><p>从疏介质射入密介质，这里发生了全折射。</p><hr /><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>由于<span class="math inline">\(\nabla\times\tilde{E}(r)=-j\omega\mu\tilde{H}(r)\)</span>，两边取旋度，有<span class="math inline">\(\nabla\times\nabla\times\tilde{E}(r)=-j\omega\mu\nabla \times \tilde{H}(r)\)</span>，代入<span class="math inline">\(\nabla \times \tilde{H}(r)=j\omega\varepsilon\tilde{E}(r)\)</span>，并结合矢量公式<span class="math inline">\(\nabla\times\nabla\times A=\nabla[\nabla \cdot A]-\Delta A\)</span>即可推出。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>由于<span class="math inline">\(\nabla\times\tilde{E}(r)=-j\omega\mu\tilde{H}(r)\)</span>，两边取旋度，有<span class="math inline">\(\nabla\times\nabla\times\tilde{E}(r)=-j\omega\mu\nabla \times \tilde{H}(r)\)</span>，代入<span class="math inline">\(\nabla \times \tilde{H}(r)=j\omega\varepsilon\tilde{E}(r)\)</span>，并结合矢量公式<span class="math inline">\(\nabla\times\nabla\times A=\nabla[\nabla \cdot A]-\Delta A\)</span>即可推出。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>椭圆极化波和圆极化波可以分解成两个垂直的线极化波，进而，可以分解成垂直极化和平行极化波。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>相对磁导率（介电常数）意思是媒质中的磁导率（介电常数）和真空中的比值。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p><span class="math inline">\(\sin x=\frac{1} {2j}(e^{jx}-e^{-jx})\)</span>,<span class="math inline">\(\cos x=\frac{1} {2}(e^{jx}+e^{-jx})\)</span><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告4：集成运放实验2</title>
    <link href="/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A4/"/>
    <url>/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A4/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第四个实验，运用555定时器和集成运放的实验。</p><span id="more"></span><h2 id="方波发生器">方波发生器</h2><p>LM555是一款具有精确定时功能的芯片，利用其工作原理，可以实现脉冲波发射电路。在电路正常工作时，可以通过调节滑动变阻器<span class="math inline">\(R_1\)</span>，来调节脉冲波的占空比。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607230056150.png" alt="image-20220607230056150" /><figcaption aria-hidden="true">image-20220607230056150</figcaption></figure><h2 id="锯齿波发生器">锯齿波发生器</h2><p>锯齿波的产生原理是对方波进行积分。在这里使用一个单运放积分器即可。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220608223724447.png" alt="image-20220608223724447" /><figcaption aria-hidden="true">image-20220608223724447</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220608223742381.png" alt="image-20220608223742381" /><figcaption aria-hidden="true">image-20220608223742381</figcaption></figure><h2 id="正弦波发生器">正弦波发生器</h2><p>正弦波发生器的工作原理是对脉冲波进行滤波得到基波分量，这里使用一个单运放有源滤波器进行滤波。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220609113906066.png" alt="image-20220609113906066" /><figcaption aria-hidden="true">image-20220609113906066</figcaption></figure><h2 id="系统级实验">系统级实验</h2><p>系统级实验需要把前面三项实验组合在一起，其中三次谐波分量的生成需要一个带通滤波器。还应该考虑电路之间的互相影响，调节元器件参数。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220613142835570.png" alt="image-20220613142835570" /><figcaption aria-hidden="true">image-20220613142835570</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220613142910664.png" alt="image-20220613142910664" /><figcaption aria-hidden="true">image-20220613142910664</figcaption></figure><h2 id="感想与体会">感想与体会</h2><p>这部分就自己写哈</p><hr /><p>本实验各文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E5%AE%9E%E9%AA%8C%202%EF%BC%88555%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89.zip">集成运放实验2 555定时器 下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告3：集成运放实验1</title>
    <link href="/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A3/"/>
    <url>/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A3/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第三个实验，集成运放实验1。</p><span id="more"></span><h2 id="单运放波形发生器">单运放波形发生器</h2><p>考虑到波形近似的可能，在方波生成器参考点引入反馈，可以获得近似三角波的波形。其中电容<span class="math inline">\(C_1\)</span>较大时可以获得良好的积分曲线，但是同时可能导致波形发生器的频率太低，也就是说信号的幅度，周期，频率是相互制约的。综合考虑实验要求，<span class="math inline">\(C_1\)</span>选择<span class="math inline">\(1\mu F\)</span>。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607204743998.png" alt="image-20220607204743998" /><figcaption aria-hidden="true">image-20220607204743998</figcaption></figure><h2 id="单运放加法器">单运放加法器</h2><p>考虑到正相加法器的电阻参数是互相关联的，不能单独调整，而且信号源的内阻会影响电路的增益，而反相加法器实现简单，调试方便，因此这里选用反相加法电路。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607204102829.png" alt="image-20220607204102829" /><figcaption aria-hidden="true">image-20220607204102829</figcaption></figure><h2 id="单运放四阶滤波器">单运放四阶滤波器</h2><p>此处采用四阶带通有源滤波器设计，其滤波效果更好，带外衰减比较大。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607214307585.png" alt="image-20220607214307585" /><figcaption aria-hidden="true">image-20220607214307585</figcaption></figure><h2 id="比较器">比较器</h2><p>对速度要求不高时，采用无穷大阻抗反馈可以把普通运算放大器作为比较器使用。故采用如图所示的设计。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607221123119.png" alt="image-20220607221123119" /><figcaption aria-hidden="true">image-20220607221123119</figcaption></figure><h2 id="系统级实验">系统级实验</h2><p>系统级实验是前面四个实验的组合，级联时需要考虑前后级模块的匹配问题，适当调整参数。三</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607224348279.png" alt="image-20220607224348279" /><figcaption aria-hidden="true">image-20220607224348279</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607224402833.png" alt="image-20220607224402833" /><figcaption aria-hidden="true">image-20220607224402833</figcaption></figure><h2 id="感想与体会">感想与体会</h2><p>这部分就自己写哈。</p><hr /><p>本次实验各文件下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E5%AE%9E%E9%AA%8C%201.zip">集成运放实验1下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220613-20220619）</title>
    <link href="/2022/06/13/%E5%91%A8%E8%AE%B0%EF%BC%8820220613-20220619%EF%BC%89/"/>
    <url>/2022/06/13/%E5%91%A8%E8%AE%B0%EF%BC%8820220613-20220619%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="section">20220613</h2><blockquote><p>今天是6月13号，晚上的8：36</p></blockquote><p>经典咏流传。没想到这么快就迎来《考试周破防》一周年了。一年以前的北京，还是一个能出去打剧本杀，然后在酒店通宵的北京。可是现在......哎，不提也罢。</p><p>今天早上虽然起来了，但是好像没做什么事情。下午做完了信号实验，然后确定了一下信号大作业的题目。</p><p>看看，不做计划就是这样：基本上啥也没干。所以明天要做计划。</p><p><strong>明天早上要八点半起来！然后写电磁场作业、再复习复习电磁场，下午上课，晚上先做电影大作业再做信号大作业。</strong></p><p>我的模电、信号实验报告都会在这学期彻底结束以后放在博客上。相关的实验文件和代码会放在GitHub上。</p><h2 id="section-1">20220614</h2><p>今天写了电磁场作业，但是没写完。写了军理卷子，信号大作业，信号大作业也没做完，但是感觉工作量还算可以了。</p><p>明天要做这些事：复习电磁场的平面波部分，最好能写篇笔记；写完电磁场作业；写完信号大作业；复习模电的频响部分；写电影大作业，重要程度从高到低。</p><p>今天我的一个朋友去澳门大学参观的申请被通过了，挺好的。我们的境外大学的项目又硬核、又是线上、还贵，我也不太想参加。</p><p>今天我们班得了优秀团支部，虽然不知道这玩意有啥用，但总之就是优秀吧。</p><h2 id="section-2">20220615</h2><p>今天复习了电磁场的平面波部分，写了篇笔记；写完了电磁场作业；写完了信号大作业；还写了个🐌报告。</p><p>别的没什么值得说的了。平淡的一天。</p><p>今天下了个百合游戏，感觉应该挺好玩。</p><h2 id="section-3">20220616</h2><p>今天继续复习了电磁场，但是还有问题没搞明白，那就是“导行波”到底是个什么东西。</p><p>今天写完了信号大作业的实验，复习了一下模电的频响和运放部分。</p><p>今天点了个外卖，叫“堡藏”，一个虾仁鸡肉饼汉堡和一个鱼肉肉卷，汉堡还不错，肉卷感觉菜有点多了，总之也还算可以，打分能打个75。不过这家默认给甜辣酱，好评。</p><p>今天看完了派对咖孔明，观感不错，期待第二季。</p><p>把相合之物加进补番序列中。</p><h2 id="section-4">20220617</h2><p>本学年度最后一课，堂堂结束！ 今天主要学了电磁场，把平面电磁波相关的部分算是彻底搞完了，开心。 明天要学模电。就是这样。 哎，xc，真奇怪，为什么总有那么多神神秘秘的说法呢？我只是想生活得简单一点。</p><h2 id="section-5">20220618</h2><p>今天把电磁场平面波的博客发出去了，而且还比较粗略地把模电的知识点都过了一遍。接下来就该刷题、刷PPT了。模电没法写博客，图太多了，画图太累。</p><p>我趣，我多长时间没看动画了？夏日重现都忘了看了！！明天一定看。</p><p>明天要：做模电题，复习电磁场的能量部分，写信号课后题作业。出卷子的作业等考完模电再说。</p><h2 id="section-6">20220619</h2><p>今天学习的内容：电影大作业，体育大作业，博雅材料，信号课后题</p><p>另外今天我还做了一件非常有意义的事情！那就是，彻底整理并记录了一下我的桌子上的杂物！！总计121件！！！牛逼吧！！！！</p><p>今天看了夏日重现。</p><p>明天要：做模电题，复习电磁场的能量部分，从现在到模电考完我再看一眼信号我就是狗。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xc能为宅宅做的35件实事</title>
    <link href="/2022/06/11/xc%E8%83%BD%E4%B8%BA%E5%AE%85%E5%AE%85%E5%81%9A%E7%9A%8435%E4%BB%B6%E5%AE%9E%E4%BA%8B/"/>
    <url>/2022/06/11/xc%E8%83%BD%E4%B8%BA%E5%AE%85%E5%AE%85%E5%81%9A%E7%9A%8435%E4%BB%B6%E5%AE%9E%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>1. 承担一半（或以上）的小组作业或科研工作。</strong></p><p>你需要承担自己份内的小组作业，按时完成，不需请求，不找借口。要知道，我们当前的习惯性的任务分配模式，包括我们对此的观念，都是非常有利于xc的，是宅宅歧视的。作为支持宅权主义的xc，你有责任与这些传统观念抗争。如果说宅权主义是理论，那么多写两行代码就是实践。请在接下来的一周记录你写了多少代码，并和你组中的宅宅作比较，看看任务分配是否平均。</p><p><strong>2. 在与群友、同事的关系中，承担一半（或以上）的精神支持工作。</strong></p><p>你要认识到，宅宅所承担的情绪劳动要比xc多得多[注1]，而这项劳动会占据他们实现个人抱负的时间和精力。</p><p>[注1]：读者自证不难</p><p><strong>3. 购买二次元的文化产品。</strong></p><p>不管你是喜欢法国电影、天体物理学，还是棒球、观鸟……请保证二次元的声音和宅宅创作的文化产品出现在你的文化消费清单之中。如果此前你的消费清单上从没出现过二次元的作品，现在就努力把它们找出来吧。</p><p><strong>4. 给宅宅留出空间。</strong> 宅宅出门在外都会觉得缺乏安全感并感到紧张，尤其是在晚间出行或单独出行的时候。这种不安全感在有陌生xc接近并且抱在一起互相啃食时会加剧。想一想有多少宅宅曾经在公共场合被xc虐待，你就知道宅宅的这种恐惧并非无缘无故。同时请注意，即使你不是那种真会对宅宅造成威胁的xc，也请不要随意离他们太近，因为他们没法在大街上判断出你到底危不危险。</p><p>举个例子：在公交上，请优先坐在情侣旁边、而不是宅宅旁边的空座上。如果你与独自走夜路的宅宅同路，请穿到马路对面走，避免跟在他身后，这样他就不用担心自己是否被虐狗了。</p><p><strong>5. 请充分利用自己的xc身份制止宅宅歧视。</strong></p><p>例如：公开反驳那些在群里秀恩爱的线虫。如果在酒吧里、在聚会上、在地铁上……看到你的宅宅朋友似乎正苦于应付面前的情侣，都请你友好地上前打断他们，为你的宅宅朋友制造出一个可以脱身的机会。 我知道做这样的事情可能会非常困难和尴尬，而且大家都不太清楚究竟怎么做才更合适，但是总该去努力尝试一下。如果自己一时的尴尬能让宅宅感到更舒适，那这么做也是值得的。</p><p><strong>6. 如果有宅宅告诉你“这是xc对我的歧视”，请相信他。</strong></p><p><strong>7. 请弄清楚什么情况下是可以秀恩爱的。</strong></p><p><strong>8. 承担被移出群聊的责任。</strong></p><p><strong>9. 每天观看一集动画片</strong></p><p><strong>10. 接受进步的文化娱乐观念。</strong></p><p><strong>11. 如果你看电影，请平等地做观赏者。</strong></p><p>你在看xc电影时，也同时要看等量（或以上）的二次元儿电影。</p><p><strong>12. 注意到并反对那些在无形中强化了xc和宅宅角色分工的行为。</strong></p><p>比如说吃饭的时候，请观察是不是基本上只有宅宅在认真吃饭，而xc们则在一旁聊天娱乐，高谈阔论。如果是这样，请主动改变这种情况，并说服其他xc跟你一起这样做。</p><p><strong>13. 请留心自己与身边的宅宅之间是否存在明显和不明显的权利差异。</strong></p><p>请努力意识到所有基于种族、阶级、性别、性取向、年龄等因素的固有结构性权利差异。当你受益于这些结构性不平等时，你要能意识到自己究竟享有了哪些特权，并尝试打破这些不平等，以实现权利的均衡。</p><p><strong>14. 请将真诚和尊重作为与宅宅保持群友关系和同事关系的前提。</strong></p><p>你与宅宅交往的方式基本可以反映出你对宅宅的价值观。如果你像对待垃圾一样对待自己的群友，那不管你有多支持宅权主义理论都没用。</p><p><strong>15. 请不要做宅宅歧视的线上旁观者。</strong></p><p>如果在网络上，尤其是社交网络上看到宅宅歧视言论或行为，请一定站起来质疑它们。</p><p><strong>16. 当你和宅宅在一个组里时，请对自己的财务状况负责。</strong></p><p>如果你不能对自己的财务状况负起责任来，你的组员必定会因此受牵连。由于宅宅收入普遍低于xc，但是宅宅的寿命又普遍长于xc，所以这也是个宅权议题。</p><p><strong>17. 请对自己的健康负责。</strong></p><p><strong>18. 不要盯着宅宅看或者对他们的生活评头论足。</strong></p><p><strong>19. 留意媒体中出现的各种专家和重要信息提供者的属性。</strong></p><p>当你在电视中看到或者在文章中读到某位专家的观点，请注意一下这些专家是不是都是xc，他们的观点是不是都是从xc的角度提出的，或者请至少想一想，若是从宅宅的角度来看这个问题，可能会有哪些不同。</p><p><strong>20. 请确保你也有一些宅宅偶像和榜样。</strong></p><p><strong>21. 在生活中向他人夸赞你身边宅宅的优点和成就。</strong></p><p>当你在日常对话和交流中提到某个你知道的宅宅时，请正面积极地评价他。请利用自己的关系网为你的宅宅朋友提供与他人合作共事的机会。</p><p><strong>22. 在你的xc朋友面前表现得正直一点（也就是说，不要因为xc情义就纵容他那些对宅宅失礼的行为）。</strong></p><p>当你的男性朋友表现得很大xc主义的时候（例如胡乱秀恩爱，侮辱宅宅等等），请做一个正直的朋友，去劝阻他。你的正直想法仅仅停留在脑中是不够的，要说出口，让他们意识到自己的错误。</p><p><strong>23. 不要嫌你的群友“死宅”，他“死宅”可能是因为你“线虫”。</strong></p><p>注：特意采用“死宅”来翻译“otaku”，是想提醒大家注意，这个中文词汇本身就很有宅宅歧视的意味。</p><p><strong>24. 仅仅承认你有宅宅歧视的倾向和保守老旧的思想是不够的，你得付诸行动，做出改变。</strong></p><p><strong>25. 将宅宅当做朋友看待。</strong></p><p>如果你没有二次元朋友，请弄明白为什么。尝试交一些宅宅朋友，并确保你和他的友谊是真诚可信的、有意义的。我们越多与他人接触，多关心别人，越能建立一个更平等的社会。</p><p><strong>26. 寻找宅宅领袖或导师（也就是说成为宅宅的下属）</strong></p><p>如果你在寻找一名导师，或者想到某个组织当志愿者，请去找二次元组织或者由二次元领导的组织。你可以从权威的宅宅身上学到很多东西。</p><p><strong>27. 请对每一个二次元角色的生日负责。</strong></p><p>请记住你自己的宅宅群友喜欢的lp的生日、纪念日和重要活动的日期。</p><p><strong>28. 不要对宅宅的xp指手画脚。</strong></p><p><strong>29. 千万不要提议与需要出门宅宅朋友同行。</strong></p><p><strong>30. 将宅权主义融入你与其他xc的日常交谈中。</strong></p><p><strong>31. 如果你在酒精或者npy的作用下可能会对宅宅有失礼的行为，那就请你不要摄入酒精或者npy。</strong></p><p><strong>32. 请留意你所占据的公共空间，不管是身体上的还是情绪上的，不要占据过多的，超出基本需求的空间。</strong></p><p><strong>33. 真正着手解决地位不平等问题。</strong></p><p><strong>34. 要明白你的xc是一种与生俱来的特权，并努力放弃你所拥有的特权；不要以为宅宅是与生俱来的劣势，也不要觉得克服这种劣势仅仅是宅宅的责任。</strong></p><p><strong>35. 认同自己“宅权主义者”的身份。</strong></p><p>将宅权主义当做是一种自然地、平常的、无可争议的信念，因为本来就应该是这样的。不要躲藏掩饰，不要使用“人道主义者”或者“宅权主义同盟”这样的概念，因为这会让人们更容易觉得“宅权主义”是个很恐怖的字眼儿。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220606-20220612）</title>
    <link href="/2022/06/08/%E5%91%A8%E8%AE%B0%EF%BC%8820220606-20220612%EF%BC%89/"/>
    <url>/2022/06/08/%E5%91%A8%E8%AE%B0%EF%BC%8820220606-20220612%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><hr /><h2 id="section">20220606</h2><p>因为这篇是8号才想起来写的，所以忘了。今日无事。 今天配置了一下Typora自动上传图片。</p><h2 id="section-1">20220607</h2><p>今天做了一天模电实验。前四个实验的报告我已经发在博客里了，不过是Hide模式，防止抄袭吧。 555定时器生成三角波的实验还没调出来。 今天出考表了。焦虑。一方面是，我热爱知识，但我痛恨考试。另一方面是，一学期又碌碌无为地过去了。</p><h2 id="section-2">20220608</h2><p>今天可以说是学了一天电磁场。主要学了平面波、复数形式场定律的内容，清了一下作业。复数形式场定律很像相量法，可以结合起来学。 另外：今天看了真理元素的《这才是电真正的工作原理》，感觉受益匪浅。这个视频主要讨论了如果导线长度非常非常长，但是在电源旁边有一个灯泡 <img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220608182609659.png" alt="image-20220608182609659" /> 那么打开开关，灯泡过多久才会亮的问题。电路中能量通过电磁场在空间中传播，而不是靠电子携带。开关闭合前电路中已经有正负电荷分布，开关闭合后电荷重新分配，这一过程产生的电磁波以开关为中心，以光速向外扩散，受这一电磁波影响的导线即会接收到能量，出现电流。 另外这个视频的背景也非常的有趣，一言以之，曰：</p><blockquote><p>真理越辩越明。</p></blockquote><p>一位我高考时候加的学弟也高考了。祝福他有美好的前程。</p><p>555定时器生成三角波的实验调出来了，生成正弦波的还没有。老是削顶失真。</p><h2 id="section-3">20220609</h2><p>今天早上做了基物实验《太阳能电池》，这是我的最后一个基物实验，也很可能是我人生中最后一次参与标题中有“物理”二字的课程。虽然不是和物理“say goodbye”吧，也是蛮感慨的。</p><blockquote><p>再见了，所有的“物理”。</p></blockquote><p>所以这次的B站视频以《One last kiss》作为BGM。</p><p>下午学了信号，晚上复习了信号，写了总结，无需多言。</p><p>今天发了助学金。</p><p>上周六的抽代出分了，90多分，还行，挺好的。我的数学二学位也快毕业了。</p><p>555定时器生成正弦波的实验调出来了。</p><p>今天洗了澡。</p><h2 id="section-4">20220610</h2><p>今天学了一下AB分离法。</p><p>不会吧不会吧，不会真的只有我做了模电实验吧，这下小丑竟是我自己了。</p><p>晚上吃了朋友送的榴莲蛋糕，好吃。</p><p>哈哈哈，这互联网又搞笑了，怎么回事呢？</p><p>明天要：总结模电笔记，学电磁场，晚上写Z变换笔记。</p><h2 id="section-5">20220611</h2><p>结果是今天早上和下午写了Z变换笔记，晚上把期中考前的模电总结了。</p><p>明天应当继续学习电磁场。</p><p>今晚和朋友一起自习了，还下雨了，挺开心的。要是没有考试就更是开心了。</p><p>为什么只有我的电路能仿真？？难道是我的问题？？？</p><h2 id="section-6">20220612</h2><p>麻了呀，越起越晚，我咋这么fw呢？明天一定要早起！</p><p>今天学了一下电磁场，写完了Z变换，做完了模电实验。</p><p>今天吃了个牛肉卷外卖，很好吃捏。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告2：差分放大电路仿真与分析</title>
    <link href="/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A2/"/>
    <url>/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A2/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第二个实验，差分放大电路。</p><span id="more"></span><hr /><h2 id="差分放大电路">差分放大电路</h2><h3 id="普通差分放大电路">普通差分放大电路</h3><p>实验原始电路图如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607164117446.png" alt="image-20220607164117446" /><figcaption aria-hidden="true">image-20220607164117446</figcaption></figure><h4 id="直流工作点分析">直流工作点分析</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607164142482.png" alt="image-20220607164142482" /><figcaption aria-hidden="true">image-20220607164142482</figcaption></figure><table><thead><tr class="header"><th style="text-align: center;">Variable</th><th style="text-align: center;">Operating point value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V(1)-V(11)/V</td><td style="text-align: center;">12.22515</td></tr><tr class="even"><td style="text-align: center;">I(Q3[IB])/uA</td><td style="text-align: center;">2.07344</td></tr><tr class="odd"><td style="text-align: center;">I(Q3[IC])/uA</td><td style="text-align: center;">359.1267</td></tr><tr class="even"><td style="text-align: center;">I(Q3[IE])/uA</td><td style="text-align: center;">-361.20014</td></tr></tbody></table><p>即： <span class="math display">\[V_{be}=12.23\text{mV}\\I_b=2.07\mu\text{A}\\I_c=359 \mu\text{A}\\I_e=-361\mu\text{A}\]</span> 三极管工作在放大区。</p><h4 id="测量静态工作电流">测量静态工作电流</h4><p>测量电路及结果如图所示，电流表设置为直流模式：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607164553377.png" alt="image-20220607164553377" /><figcaption aria-hidden="true">image-20220607164553377</figcaption></figure><p>电流源提供的静态工作电流约<span class="math inline">\(722\mu\text{A}\)</span>.</p><h4 id="测量输入输出电阻">测量输入、输出电阻</h4><p>测量输入电阻，在输入部分测量电流和电压，相除即可得到输入电阻。</p><p>测量电路和结果如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165012310.png" alt="image-20220607165012310" /><figcaption aria-hidden="true">image-20220607165012310</figcaption></figure><p>有： <span class="math display">\[R_i=\frac VI=33750\Omega\]</span> 测量输出电阻，分别测量开关<span class="math inline">\(S_1\)</span>打开和闭合时的电压，通过公式计算输出电阻。</p><p>测量电路和结果如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165247200.png" alt="image-20220607165247200" /><figcaption aria-hidden="true">image-20220607165247200</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165316048.png" alt="image-20220607165316048" /><figcaption aria-hidden="true">image-20220607165316048</figcaption></figure><p>有： <span class="math display">\[R_o=\frac{V_2-V_1}{V_1}R_L=1059\Omega\]</span></p><h4 id="测量单端输出差模放大倍数">测量单端输出差模放大倍数</h4><p>在输出端、输入端接入电压表，测量并求比值。</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165450973.png" alt="image-20220607165450973" /> <span class="math display">\[A=\frac{V_o}{V_i}=5.94\]</span></p><h4 id="用仪表测量幅频相频曲线">用仪表测量幅频、相频曲线</h4><p>把波特测试仪连入电路并测量。</p><p>电路：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165832111.png" alt="image-20220607165832111" /><figcaption aria-hidden="true">image-20220607165832111</figcaption></figure><p>结果：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607110325379.png" alt="image-20220607110325379" /><figcaption aria-hidden="true">image-20220607110325379</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607110341367.png" alt="image-20220607110341367" /><figcaption aria-hidden="true">image-20220607110341367</figcaption></figure><h4 id="用交流分析给出幅频相频曲线">用交流分析给出幅频、相频曲线</h4><p>在“仿真”中选择交流分析，选定合适的参数和输出量并进行仿真。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607110425299.png" alt="image-20220607110425299" /><figcaption aria-hidden="true">image-20220607110425299</figcaption></figure><h4 id="温度扫描">温度扫描</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607111351195.png" alt="image-20220607111351195" /><figcaption aria-hidden="true">image-20220607111351195</figcaption></figure><p>单管放大器电路以及温度扫描：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607111249985.png" alt="image-20220607111249985" /><figcaption aria-hidden="true">image-20220607111249985</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607111230796.png" alt="image-20220607111230796" /><figcaption aria-hidden="true">image-20220607111230796</figcaption></figure><p>由此可见，差放有抑制温漂的功能。</p><h4 id="最大不失真输出电压">最大不失真输出电压</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607172410632.png" alt="image-20220607172410632" /><figcaption aria-hidden="true">image-20220607172410632</figcaption></figure><p>最大不失真输出电压约为11.94V。</p><h3 id="有源负载差分放大电路">有源负载差分放大电路</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607172622665.png" alt="image-20220607172622665" /><figcaption aria-hidden="true">image-20220607172622665</figcaption></figure><p>有<span class="math inline">\(1k\Omega\)</span>负载时，放大倍数约为10.41。</p><p>这个电路的特点有：</p><ol type="1"><li>单端输出</li><li>共模抑制比无穷多</li><li>差模电压增益很大</li></ol><h2 id="cmos差分放大电路">CMOS差分放大电路</h2><h3 id="原始电路图">原始电路图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607192057086.png" alt="image-20220607192057086" /><figcaption aria-hidden="true">image-20220607192057086</figcaption></figure><p>在选取管子时，应该右键管子编辑模型，以将L、N的长度编辑到书上给定的长度。</p><h3 id="直流工作点分析-1">直流工作点分析</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607192231241.png" alt="image-20220607192231241" /><figcaption aria-hidden="true">image-20220607192231241</figcaption></figure><p>查询手册，得：<span class="math inline">\(V_{GS(th)}=1.6\text{V}\)</span> <span class="math display">\[V_{GS}=V_2-V_1=2.36&gt;V_{GS(th)}\\V_{DS}=V_4-V_1=3.65&gt;V_{GS}-V{GS(th)}\]</span> 因此，工作在恒流区。</p><h3 id="测量差模放大倍数">测量差模放大倍数</h3><p>在一端设置<span class="math inline">\(10\)</span>mV输入信号，并测定单端输出电压，电路图和结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607193641714.png" alt="image-20220607193641714" /><figcaption aria-hidden="true">image-20220607193641714</figcaption></figure><p>如图，有： <span class="math display">\[A_{vd1}=\frac{V_o}{V_i}=78\]</span> 用示波器测量波形如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607195027828.png" alt="image-20220607195027828" /><figcaption aria-hidden="true">image-20220607195027828</figcaption></figure><h3 id="测量共模放大倍数">测量共模放大倍数</h3><p>在两端端设置彼此相同的1V输入信号，并测定单端输出电压，电路图和结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607194543351.png" alt="image-20220607194543351" /><figcaption aria-hidden="true">image-20220607194543351</figcaption></figure><p>如图所示，两边放相同的信号源，测量共模放大倍数。有： <span class="math display">\[A_{vc1}=\frac{V_o}{V_i}=0.054\]</span> 用示波器测量波形：<img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607194857656.png" alt="image-20220607194857656" /></p><h3 id="填写记录表格">填写记录表格</h3><p>共模抑制比计算公式为： <span class="math display">\[K_{CMR}=\frac{A_{vd1}}{A_{vc1}}\]</span></p><table><thead><tr class="header"><th>参数</th><th><span class="math inline">\(V_{i1}\)</span></th><th><span class="math inline">\(V_{o1}\)</span></th><th><span class="math inline">\(A_{vd1}\)</span></th><th><span class="math inline">\(V_{ic}\)</span></th><th><span class="math inline">\(V_{o1}\)</span></th><th><span class="math inline">\(A_{vc1}\)</span></th><th><span class="math inline">\(K_{CMR}\)</span></th></tr></thead><tbody><tr class="odd"><td>值</td><td>9.996mV</td><td>769.686mV</td><td>78</td><td>1V</td><td>54.45mV</td><td>0.054</td><td>1444.44</td></tr></tbody></table><h2 id="感想和体会">感想和体会</h2><p>这部分就自己写哈</p><hr /><p>本次实验各文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8.zip">差分放大器实验下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告1：共射放大器和射极跟随器</title>
    <link href="/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A1/"/>
    <url>/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A1/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第一个实验，共射放大器和射极跟随器。</p><span id="more"></span><h2 id="共射放大器的分析和设计">共射放大器的分析和设计</h2><h3 id="实验目的">实验目的</h3><ol type="1"><li><p>进一步了解 Multisim 的各项功能，熟练掌握其使用方法，为后续课程打好基础。</p></li><li><p>通过使用 Multisim 来仿真电路，测试如图 1 所示的单管共射放大电路的静态工作点、电压放大倍数、输入电阻和输出电阻，并观察静态工作点的变化对输出波形的影响。</p></li><li><p>加深对放大电路工作原理的理解和参数变化对输出波形的影响。</p></li><li><p>观察失真现象，了解其产生的原因。</p></li></ol><h3 id="实验原理图">实验原理图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530203406386.png" alt="image-20220530203406386" /><figcaption aria-hidden="true">image-20220530203406386</figcaption></figure><h3 id="实验内容及仿真数据">实验内容及仿真数据</h3><h4 id="进行直流工作点分析判断工作状态">进行直流工作点分析，判断工作状态</h4><p>用“分析”-“Analyses and simulation”工具中的“直流工作点”分析，得结果如下：</p><table><thead><tr class="header"><th style="text-align: center;">Variable</th><th style="text-align: center;">Operating point value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V(4)-V(5)</td><td style="text-align: center;">6.76596</td></tr><tr class="even"><td style="text-align: center;">V(3)-V(5)</td><td style="text-align: center;">0.618865</td></tr><tr class="odd"><td style="text-align: center;">I(Q1[IB])</td><td style="text-align: center;">6.21E-06</td></tr><tr class="even"><td style="text-align: center;">I(Q1[IC])</td><td style="text-align: center;">0.000967</td></tr><tr class="odd"><td style="text-align: center;">I(Q1[IE])</td><td style="text-align: center;">-0.00097</td></tr></tbody></table><p>则有： <span class="math display">\[V_{be}=V(3)-V(5)=0.618865 \text{V}\\V_{ce}=V(4)-V(5)=6.76596\text{V}\\I_b=6.21\mu\text{A}\\I_c=967\mu\text{A}\\I_e=-970\mu\text{A}\]</span> 可知：管子工作在放大区。</p><h4 id="测量输入电阻">测量输入电阻</h4><p>使用万用表器件，测量电路以及测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530205610684.png" alt="image-20220530205610684" /><figcaption aria-hidden="true">image-20220530205610684</figcaption></figure><p>有结果：</p><table><thead><tr class="header"><th>项目</th><th>值</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(U_i\)</span></td><td>3.794mV</td></tr><tr class="even"><td><span class="math inline">\(I_i\)</span></td><td>1.209μA</td></tr></tbody></table><p>计算： <span class="math display">\[\begin{aligned}R_i&amp;=\frac{U_i}{I_i}\\&amp;=\frac{3.794\times10^{-3}}{1.209\times 10^{-6}}\\[1.5ex]&amp;=3138.13\ \Omega\end{aligned}\]</span> 故输入电阻为<span class="math inline">\(3138.13\Omega\)</span>，此时的频率为<span class="math inline">\(1\text{kHz}\)</span></p><h4 id="测量输出电阻">测量输出电阻</h4><p>为测量输出电阻，将信号源置<span class="math inline">\(0\)</span>，将负载电阻从电路中取出，换成信号源，用电流表测量输出支路电流。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530212159779.png" alt="image-20220530212159779" /><figcaption aria-hidden="true">image-20220530212159779</figcaption></figure><p>则有： <span class="math display">\[\begin{aligned}R_o&amp;=\frac{U_o}{I_o}\\&amp;=\frac{10\times10^{-3}}{3.922\times10^{-6}}\\[1.5ex]&amp;=2549.71\Omega\end{aligned}\]</span> 所以输出电阻为<span class="math inline">\(2549.71\Omega\)</span></p><h4 id="用测量仪表测定幅频相频曲线">用测量仪表测定幅频、相频曲线</h4><p>如图所示，将波特分析仪连入电路：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530214705599.png" alt="image-20220530214705599" /><figcaption aria-hidden="true">image-20220530214705599</figcaption></figure><p>选择“幅值”模式，调整范围：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530214736718.png" alt="image-20220530214736718" /><figcaption aria-hidden="true">image-20220530214736718</figcaption></figure><p>选择“相位”模式：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530221124547.png" alt="image-20220530221124547" /><figcaption aria-hidden="true">image-20220530221124547</figcaption></figure><h4 id="用交流分析测幅频相频曲线">用交流分析测幅频、相频曲线</h4><p>用“分析”-“Analyses and simulation”工具中的“交流分析”，如图设置参数：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530221813255.png" alt="image-20220530221813255" /><figcaption aria-hidden="true">image-20220530221813255</figcaption></figure><p>将输出设置为<span class="math inline">\(V(6)\)</span>，开始分析：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530221847557.png" alt="image-20220530221847557" /><figcaption aria-hidden="true">image-20220530221847557</figcaption></figure><h4 id="分别在5-个频点利用示波器测出输入和输出的关系并仔细观察放大倍数和相位差">分别在5 个频点利用示波器测出输入和输出的关系，并仔细观察放大倍数和相位差</h4><p>电路连接方式如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530222634242.png" alt="image-20220530222634242" /><figcaption aria-hidden="true">image-20220530222634242</figcaption></figure><ol type="1"><li>30Hz</li></ol><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530231206151.png" alt="image-20220530231206151" /><figcaption aria-hidden="true">image-20220530231206151</figcaption></figure><p>图中<span class="math inline">\(T_1\)</span>，<span class="math inline">\(T_2\)</span>分别对应输入、输出通道的最大值。由<span class="math inline">\(\Delta \varphi=2\pi f(T_2-T_1)\)</span>可知： <span class="math display">\[   \max V_i=6.620\text{mV} \\   \max V_o=65.526\text{mV} \\   \Delta \varphi=51.132\degree   \]</span></p><ol start="2" type="1"><li><p>1kHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530232304194.png" alt="image-20220530232304194" /> <span class="math display">\[\max V_i=5.334\text{mV} \\\max V_o=238.006\text{mV} \\\Delta \varphi=168.75\degree\]</span></p></li><li><p>100kHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530232540514.png" alt="image-20220530232540514" /> <span class="math display">\[\max V_i=5.282\text{mV} \\\max V_o=236.081\text{mV} \\\Delta \varphi=181.548\degree\]</span></p></li><li><p>4MHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530233003943.png" alt="image-20220530233003943" /> <span class="math display">\[\max V_i=1.582\text{mV} \\\max V_o=73.091\text{mV} \\\Delta \varphi=180\degree\]</span></p></li><li><p>100MHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530233500579.png" alt="image-20220530233500579" /> <span class="math display">\[\max V_i=193.301\mu\text{V} \\\max V_o=2.919\text{mV} \\\Delta \varphi=258.228\degree\]</span></p></li></ol><p>汇总，得：</p><table><thead><tr class="header"><th>f/Hz</th><th>max <span class="math inline">\(V_i\)</span>/mV</th><th>max<span class="math inline">\(V_o\)</span>/mV</th><th><span class="math inline">\(\Delta \varphi/\degree\)</span></th><th><span class="math inline">\(A\)</span></th></tr></thead><tbody><tr class="odd"><td>30</td><td>6.620</td><td>65.526</td><td>51.132</td><td>9.90</td></tr><tr class="even"><td>1k</td><td>5.334</td><td>238.006</td><td>168.75</td><td>44.62</td></tr><tr class="odd"><td>100k</td><td>5.282</td><td>236.081</td><td>181.548</td><td>44.70</td></tr><tr class="even"><td>4M</td><td>1.582</td><td>73.091</td><td>180</td><td>46.20</td></tr><tr class="odd"><td>100M</td><td>0.193</td><td>2.919</td><td>258.228</td><td>15.12</td></tr></tbody></table><h3 id="最大不失真输出电压的优化">最大不失真输出电压的优化</h3><h4 id="原电路最大不失真输出电压">原电路最大不失真输出电压</h4><p>原电路如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605152356360.png" alt="image-20220605152356360" /><figcaption aria-hidden="true">image-20220605152356360</figcaption></figure><p>设置信号源电压为变量<span class="math inline">\(v_i\)</span>，用参数扫描功能，从<span class="math inline">\(5\text{mV}\)</span>到<span class="math inline">\(15\text{mv}\)</span>扫描，用瞬态分析，分析时间设置为一个周期，即<span class="math inline">\(0.001\text{ms}\)</span>，得图形：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605152905709.png" alt="image-20220605152905709" /><figcaption aria-hidden="true">image-20220605152905709</figcaption></figure><p>可见在约<span class="math inline">\(10\text{mV}\)</span>时出现饱和失真。将信号源设置为<span class="math inline">\(10\text{mV}\)</span>，用示波器分析</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605153150707.png" alt="image-20220605153150707" /><figcaption aria-hidden="true">image-20220605153150707</figcaption></figure><p>可得最大不失真电压为<span class="math inline">\(4.5\text{mV}\)</span>左右。</p><h4 id="调整电阻后的最大不失真输出电压">调整电阻后的最大不失真输出电压</h4><p>调整<span class="math inline">\(R_1\)</span>,<span class="math inline">\(R_2\)</span>的比值，加入射级电阻，电路及参数扫描结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605151534469.png" alt="image-20220605151534469" /><figcaption aria-hidden="true">image-20220605151534469</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605151417177.png" alt="image-20220605151417177" /><figcaption aria-hidden="true">image-20220605151417177</figcaption></figure><p>将信号源设置为<span class="math inline">\(211\text{mV}\)</span>，用示波器分析：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605153340470.png" alt="image-20220605153340470" /><figcaption aria-hidden="true">image-20220605153340470</figcaption></figure><p>此时输出电压约为<span class="math inline">\(2.2\text{V}\)</span>，比之前的电路提升了487.8倍。</p><h4 id="添加有源负载后的最大不失真电压">添加有源负载后的最大不失真电压</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220702230017279.png" alt="image-20220702230017279" /><figcaption aria-hidden="true">image-20220702230017279</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220702230157561.png" alt="image-20220702230157561" /><figcaption aria-hidden="true">image-20220702230157561</figcaption></figure><p>最大不失真输出电压进一步提高到了<span class="math inline">\(3.13V\)</span>左右。</p><h2 id="射极跟随器分析与设计">射极跟随器分析与设计</h2><h3 id="实验目的-1">实验目的</h3><ol type="1"><li>使用Multisim搭建仿真电路图，测定电路的静态工作点、电压放大倍数、输入电阻、输出电阻、观察静态工作点的变化对输入、输出特性的影响。</li><li>设计有源负载射随器</li><li>了解失真现象</li></ol><h3 id="原始电路图">原始电路图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606233327519.png" alt="image-20220606233327519" /><figcaption aria-hidden="true">image-20220606233327519</figcaption></figure><h3 id="射随器仿真实验">射随器仿真实验</h3><h4 id="进行直流工作点分析判断工作状态-1">进行直流工作点分析，判断工作状态</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606202123233.png" alt="image-20220606202123233" /><figcaption aria-hidden="true">image-20220606202123233</figcaption></figure><p>结果如下：</p><table><thead><tr class="header"><th>Variable</th><th>Operating point value</th></tr></thead><tbody><tr class="odd"><td>I(Q1[IC])</td><td>0.001601</td></tr><tr class="even"><td>V(3)-V(1)</td><td>0.63146175</td></tr><tr class="odd"><td>V(vcc)-V(1)</td><td>7.89915</td></tr></tbody></table><p>则有： <span class="math display">\[V_{be}=0.631\text{V}\\V_{ce}=7.899\text{V}\\I_c=1.6\text{mA}\]</span> 由此可见，管子工作在放大区。</p><h4 id="测量输入电阻-1">测量输入电阻</h4><p>电路及仿真结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606204235062.png" alt="image-20220606204235062" /><figcaption aria-hidden="true">image-20220606204235062</figcaption></figure><p>则有： <span class="math display">\[I_i=\frac{u_1}{R_4}=2.5\times10^{-8}\text{A}\\U_i=9.255\text{mV}\\R_i=356.44\text{k}\Omega\]</span></p><h4 id="测量输出电阻-1">测量输出电阻</h4><p>电路及相关测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606210346703.png" alt="image-20220606210346703" /><figcaption aria-hidden="true">image-20220606210346703</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606210415737.png" alt="image-20220606210415737" /><figcaption aria-hidden="true">image-20220606210415737</figcaption></figure><p>设开关闭合时电压为<span class="math inline">\(V_1\)</span>，开关打开时电压为<span class="math inline">\(V_2\)</span>，有： <span class="math display">\[R_0=\frac{V_2-V_1}{V_1}R_l=17.7\Omega\]</span></p><h4 id="用测量仪表测定幅频相频曲线-1">用测量仪表测定幅频、相频曲线</h4><p>电路图如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606213854747.png" alt="image-20220606213854747" /><figcaption aria-hidden="true">image-20220606213854747</figcaption></figure><p>测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606214506998.png" alt="image-20220606214506998" /><figcaption aria-hidden="true">image-20220606214506998</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606214610105.png" alt="image-20220606214610105" /><figcaption aria-hidden="true">image-20220606214610105</figcaption></figure><h4 id="用交流分析测幅频相频曲线-1">用交流分析测幅频、相频曲线</h4><p>结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606215412272.png" alt="image-20220606215412272" /><figcaption aria-hidden="true">image-20220606215412272</figcaption></figure><h4 id="最大不失真输出电压">最大不失真输出电压</h4><p>由参数扫描得，射随器最大不失真输出电压为<span class="math inline">\(7.158\text{V}\)</span></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606231952324.png" alt="image-20220606231952324" /><figcaption aria-hidden="true">image-20220606231952324</figcaption></figure><h3 id="有源负载射随器仿真实验">有源负载射随器仿真实验</h3><h4 id="直流工作点分析">直流工作点分析</h4><p>电路图和直流工作点分析结果如下，其中绿色部分为镜像电流源负载</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606221933500.png" alt="image-20220606221933500" /><figcaption aria-hidden="true">image-20220606221933500</figcaption></figure><table><thead><tr class="header"><th>Variable</th><th>Operating point value</th></tr></thead><tbody><tr class="odd"><td>I(Q1[IC])</td><td>0.00160115</td></tr><tr class="even"><td>V(3)-V(1)</td><td>0.63146373</td></tr><tr class="odd"><td>V(vcc)-V(1)</td><td>7.89959</td></tr></tbody></table><p>工作点和上个实验中射随器工作点基本一致。</p><h4 id="测量输入电阻-2">测量输入电阻</h4><p>电路图和相关测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230225977.png" alt="image-20220606230225977" /><figcaption aria-hidden="true">image-20220606230225977</figcaption></figure><p>有： <span class="math display">\[R_i=\frac{V_S}{V_i-V_s}R_6=429.42\text{kV}\]</span></p><h4 id="测量输出电阻-2">测量输出电阻</h4><p>电路图和相关测量结果如下：<img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606225533334.png" alt="image-20220606225533334" /></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606225549913.png" alt="image-20220606225549913" /><figcaption aria-hidden="true">image-20220606225549913</figcaption></figure><p>设开关闭合时电压为<span class="math inline">\(V_1\)</span>，开关打开时电压为<span class="math inline">\(V_2\)</span>，有： <span class="math display">\[R_0=\frac{V_2-V_1}{V_1}R_l=17.7\Omega\]</span></p><h4 id="用测量仪表测定幅频相频曲线-2">用测量仪表测定幅频、相频曲线</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230655603.png" alt="image-20220606230655603" /><figcaption aria-hidden="true">image-20220606230655603</figcaption></figure><p>测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230740927.png" alt="image-20220606230740927" /><figcaption aria-hidden="true">image-20220606230740927</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230803991.png" alt="image-20220606230803991" /><figcaption aria-hidden="true">image-20220606230803991</figcaption></figure><h4 id="用交流分析测幅频相频曲线-2">用交流分析测幅频、相频曲线</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606231140129.png" alt="image-20220606231140129" /><figcaption aria-hidden="true">image-20220606231140129</figcaption></figure><h4 id="最大不失真输出电压-1">最大不失真输出电压</h4><p>由参数扫描得，有源负载射随器最大不失真输出电压为<span class="math inline">\(7.920\text{V}\)</span></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606231847858.png" alt="image-20220606231847858" /><figcaption aria-hidden="true">image-20220606231847858</figcaption></figure><p>修改电路，再进行参数扫描</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606232942274.png" alt="image-20220606232942274" /><figcaption aria-hidden="true">image-20220606232942274</figcaption></figure><p>得最大不失真输出电压为<span class="math inline">\(9.621\text{V}\)</span>,比最初提升了<span class="math inline">\(34.41\%\)</span></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606232756093.png" alt="image-20220606232756093" /><figcaption aria-hidden="true">image-20220606232756093</figcaption></figure><h2 id="感想和体会">感想和体会</h2><p>这部分大家就自己写哈。</p><hr /><p>本次实验涉及到的各个文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E5%85%B1%E5%B0%84%E6%94%BE%E5%A4%A7%E5%99%A8%E5%92%8C%E5%B0%84%E6%9E%81%E8%B7%9F%E9%9A%8F%E5%99%A8.zip">共射放大器和射极跟随器实验下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理统计重点内容梳理</title>
    <link href="/2022/05/31/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2022/05/31/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>周日就要考了，救命...... 另外，本文只是考试内容，有很多很好玩的内容，如方差分析，逐次回归，正交试验等没有涉及。</p><span id="more"></span><p>@[toc]</p><h2 id="估计">估计</h2><h3 id="umvue一致最小方差无偏估计">UMVUE一致最小方差无偏估计</h3><p><strong>定义（一致最小方差无偏估计）</strong> ：设<span class="math inline">\(U_q\)</span>表示参数<span class="math inline">\(q(\theta)\)</span>所有的方差有限的估计组成的集合，如果存在无偏估计<span class="math inline">\(T*(\mathbf{x})\)</span>，使得： <span class="math display">\[Var_\theta(T^*(x))\leq Var_\theta(T(x))\]</span> 对任何<span class="math inline">\(\theta\)</span>,任何<span class="math inline">\(T(x)\in U_q\)</span>成立，那么<span class="math inline">\(T^*(x)\)</span>就是一致最小方差无偏估计。</p><p>一般来说，我们可以用完全充分统计量的方法来寻找一致最小方差无偏估计。首先看几个概念：</p><p><strong>定义（统计量）</strong> :<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是来自总体<span class="math inline">\(X\)</span>的样本，那么仅和<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>有关的函数<span class="math inline">\(T(x_1,\cdots,x_n)\)</span>就是一个 <strong>统计量</strong></p><p><strong>定义（充分统计量）</strong> :设总体分布族为<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>,<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是来自总体<span class="math inline">\(X\)</span>的样本，<span class="math inline">\(T\)</span>是统计量。如果给定<span class="math inline">\(T=t\)</span>，样本的条件分布函数<span class="math inline">\(F_\theta(\{x\}|t)\)</span>和参数<span class="math inline">\(\theta\)</span>无关，那么称<span class="math inline">\(T\)</span>是充分统计量。</p><p><strong>定理（因子分解定理）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，统计量<span class="math inline">\(T\)</span>充分，等价于：存在一个定义在<span class="math inline">\(I\times\Theta\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="$I$是$T(x)$的值域，$\Theta$是$\theta$的值域">[2]</span></a></sup>上的实函数<span class="math inline">\(g(t,\theta)\)</span>，和定义在样本空间上的不依赖于参数<span class="math inline">\(\theta\)</span>的实函数<span class="math inline">\(h(x)\)</span>，使得对于样本的联合分布有： <span class="math display">\[p(x;\theta)=g(T(x),\theta)\cdot h(x)\]</span> 对样本空间上的每一个<span class="math inline">\(x\)</span>都成立。</p><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自泊松总体的<span class="math inline">\(n\)</span>个样本，求充分统计量。</p><p>【解】联合分布： <span class="math display">\[p(\{x\};\lambda)=\frac{e^{-n\lambda} } {x_1!x_2!\cdots x_n!}\lambda^{\sum_{i=1}^nx_i}\]</span> 取 <span class="math display">\[T=\sum x_i,g(T,\lambda)=e^{-n\lambda}\lambda^T,h(x)=\frac 1{x_1!x_2!\cdots x_n!}\]</span> 有 <span class="math display">\[p(\{x\};\lambda)=g(T,\lambda)h(x)\]</span> 则<span class="math inline">\(T=\sum x_i\)</span>是充分统计量。</p></blockquote><p><strong>定义*（完全统计量）</strong> ：对于总体<span class="math inline">\(X\)</span>的分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，<span class="math inline">\(g(X)\)</span>是随机变量，如果有：“对一切<span class="math inline">\(\theta\)</span>，<span class="math inline">\(E_\theta[g(x)]=0 \to P_\theta[g(x)=0]=1\)</span>”，则称这个分布族是完全分布族。如果统计量<span class="math inline">\(T\)</span>的分布族是完全的，那么<span class="math inline">\(T\)</span>就是完全统计量。</p><p><strong>定理（充分性定理）</strong> ：设<span class="math inline">\(\{x\}\)</span>是来自总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>的<span class="math inline">\(n\)</span>个简单样本，如果联合密度函数（联合分布列）可以分解为： <span class="math display">\[p(\{x\},\theta)=c(\theta)h(\{x\})\exp\left\{ \sum_{k=1}^mw_k(\theta)T_k(\{x\}) \right\}\]</span> 其中：</p><ul><li><span class="math inline">\(h(\{x\})\)</span>仅是<span class="math inline">\(x_1,\cdots,x_n\)</span>的函数</li><li><span class="math inline">\(w=[w_1(\theta),\cdots,w_k(\theta)]\)</span>是定义在<span class="math inline">\(\Theta^m\)</span>空间上的取值为<span class="math inline">\(A\subset{\mathbb R}^m\)</span>的向量函数</li><li><span class="math inline">\(c(\theta)\)</span>仅是<span class="math inline">\(\theta\)</span>的函数</li></ul><p>如果<span class="math inline">\(A\)</span>包含内点，那么<span class="math inline">\(T_1,\cdots,T_m\)</span>都是完全充分的。</p><blockquote><p>【例】设<span class="math inline">\(\{x\}\)</span>是来自二项分布<span class="math inline">\(B(1,\theta)\)</span><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="$B(n,p)$表示重复$n$次试验，每次试验成功的概率为$p$，成功的试验数目。这里实际上退化成了两点分布。">[3]</span></a></sup>总体的<span class="math inline">\(n\)</span>个简单样本，求<span class="math inline">\(\theta\)</span>的完全充分统计量。</p><p>【解】联合分布列： <span class="math display">\[\begin{aligned}p(\{x\};\theta)&amp;=\prod_{i=1}^n \theta^{x_i}(1-\theta)^{1-x_i}\\\\&amp;=(1-\theta)^n\exp\left\{ \ln\frac{\theta} {1-\theta}\sum_{i=1}^n x_i \right\}\end{aligned}\]</span> 取：</p><ul><li><span class="math inline">\(w=\ln\frac{\theta} {1-\theta}\)</span>，<span class="math inline">\(m=1\)</span></li><li><span class="math inline">\(c(\theta)=(1-\theta)^n\)</span></li><li><span class="math inline">\(h(\{x\})=1\)</span></li><li><span class="math inline">\(T=\sum x_i\)</span></li></ul><p>则<span class="math inline">\(T\)</span>是完全充分统计量。</p></blockquote><p><strong>定理（Lehmann-Scheffe定理）</strong>： 设<span class="math inline">\(S(x)\)</span>是完全充分统计量，<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(q(\theta)\)</span>的方差有限的无偏估计，则 <span class="math display">\[T(x)=E_\theta[\varphi(x)|S(x)]\]</span> 是<span class="math inline">\(q(\theta)\)</span>的一致最小方差无偏估计。</p><p>Lehmann-Scheffe定理实际上提供了两种根据完全充分统计量<span class="math inline">\(S(x)\)</span>寻求<span class="math inline">\(q(\theta)\)</span>的UMVUE的路径：</p><ol type="1"><li><p>如果能获得<span class="math inline">\(q(\theta)\)</span>的无偏估计<span class="math inline">\(\varphi(x)\)</span>，那么直接按照公式计算即可。</p><blockquote><p>【例】设<span class="math inline">\(\{x\}\)</span>是来自泊松总体的<span class="math inline">\(n\)</span>个简单样本，求<span class="math inline">\(q(\lambda)=e^{-\lambda}\)</span>的UMVUE。</p><p>【解】泊松分布列为： <span class="math display">\[p(x;\lambda)=\frac{\lambda^x} {x!}e^{-\lambda}=e^{-\lambda}\frac 1{x!}\exp(\ln (\lambda) x)\ \ x=0,1,2,\cdots\]</span> 则联合分布列的分解： <span class="math display">\[p(\{x\};\theta)=e^{-n\lambda}\prod_{i=1}^n\frac{1} {x_i!}\exp(\ln \lambda \sum_{i=1}^n x_i)\]</span> 取：</p><ul><li><span class="math inline">\(S(x)=\sum x_i\)</span></li><li><span class="math inline">\(w(\lambda)=\ln \lambda\)</span>,<span class="math inline">\(m=1\)</span></li><li><span class="math inline">\(c(\lambda)=e^{-n\lambda}\)</span></li><li><span class="math inline">\(h=\prod \frac{1} {x_i!}\)</span></li></ul><p>则<span class="math inline">\(S\)</span>是完全充分统计量。</p><p>接下来寻找<span class="math inline">\(q(\lambda)\)</span>的无偏估计。取 <span class="math display">\[\varphi(x)=I_{x_1=0}(x_1,\cdots,x_n)\]</span> 其中<span class="math inline">\(I\)</span>是指示函数<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="指示函数$I_a()$：当条件$a$为真时为$1$，反之为$0$.">[4]</span></a></sup>.</p><p>则： <span class="math display">\[E_\lambda[\varphi(x)]=P[x_1=0]=e^{-n\lambda}\]</span> 故<span class="math inline">\(\varphi\)</span>是<span class="math inline">\(q(\lambda)\)</span>的无偏估计。则有： <span class="math display">\[T=E[\varphi|S(x)=s]\]</span> 则有： <span class="math display">\[T=\frac{P[x_1=0]P[\sum_{k=2}^nx_k=s]} {P[\sum_{k=1}^nx_k=s]}\]</span> 由于泊松分布的和是泊松分布，<span class="math inline">\(\lambda\)</span>参数求和，则： <span class="math display">\[T=\left(\frac{n-1} {n}\right)^{\sum x_i}\]</span></p></blockquote></li><li><p>由于<span class="math inline">\(T(x)\)</span>一定是<span class="math inline">\(S(x)\)</span>的函数，因此如果能获取<span class="math inline">\(S(x)\)</span>的函数<span class="math inline">\(h(S(x))\)</span>，并将其无偏化，则可以获得UMVUE。</p><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>个简单样本，其中<span class="math inline">\(\mu\)</span>是已知量，求<span class="math inline">\(\sigma^2\)</span>的UMVUE。</p><p>【解】样本的联合密度函数为： <span class="math display">\[p(\{x\};\sigma^2)=(2\pi\sigma^2)^{-\frac{n} {2} }\exp\left\{-\frac{1} {2\sigma^2}\sum_{i=1}^{n}(x_i-\mu)^2 \right\}\]</span> 取：</p><ul><li><span class="math inline">\(c(\sigma^2)=(2\pi\sigma^2)^{-\frac n2}\)</span></li><li><span class="math inline">\(h(\{x\})=1\)</span></li><li><span class="math inline">\(w(\sigma^2)=-\frac{1} {2\sigma^2},m=1\)</span></li><li><span class="math inline">\(S(x)=\sum(x_i-\mu)^2\)</span></li></ul><p>则<span class="math inline">\(S(x)\)</span>是完全充分统计量。由于 <span class="math display">\[E[S(x)]=E\left[\sum(x_i-\mu)^2\right]=n\sigma^2\]</span> 则： <span class="math display">\[E\left[\frac{1} {n}S(x)\right]=\sigma^2\]</span> 于是<span class="math inline">\(S/n\)</span>既是待估计量的无偏估计，也是完全充分统计量<span class="math inline">\(S\)</span>的函数，因此 <span class="math display">\[\frac Sn=\frac 1n \sum_{i=1}^n(x_i-\mu)^2\]</span> 是待估计量的UMVUE。</p></blockquote></li></ol><h3 id="有效估计">有效估计</h3><h3 id="矩估计">矩估计</h3><p>矩估计法的思想是基于替换原理，用样本矩替换相应的总体矩，进而求出某些待估计参数的过程。</p><p>其中的样本矩的意思是根据<span class="math inline">\(n\)</span>次抽样算出来的矩，比如说抽样<span class="math inline">\(n\)</span>次的样本是<span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span>，那么<span class="math inline">\(k\)</span>阶样本原点矩就是 <span class="math display">\[A_k=\frac 1n\sum_{i=1}^n x_i^k\]</span> 而总体矩的意思是将待估计参数代入分布的理论形式中，通过理论分析计算期望而得出的矩。假如待估计参数是<span class="math inline">\(\theta\)</span>,那么<span class="math inline">\(k\)</span>阶总体原点矩是 <span class="math display">\[\mu_k=E_\theta[X^k]\]</span> 求矩估计的一般步骤是：将待估计的参数<span class="math inline">\(q(\theta)\)</span>表示成各阶总体矩<span class="math inline">\(\mu_k\)</span>的函数,然后用样本矩替换总体矩，就可以获得矩估计。</p><blockquote><p>【例】总体<span class="math inline">\(X\)</span>服从<span class="math inline">\([a,b]\)</span>上的均匀分布，也就是说，其概率密度函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="$p(x;a,b)$的含义是：该函数以$x$为自变量，有两个参数$a$和$b$">[1]</span></a></sup>为： <span class="math display">\[p(x;a,b)=\begin{cases}\frac{1} {b-a} &amp;x\in[a,b]\\\\0 &amp;\text{others}\end{cases}\]</span> <span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span>是总体<span class="math inline">\(X\)</span>的简单抽样样本。求<span class="math inline">\(a,b\)</span>的矩估计。</p><p>【解】设<span class="math inline">\(\mu_1=E[x],v_2=D[x]\)</span>,有： <span class="math display">\[\begin{cases}\mu_1=\frac{1} {2}(a+b)\\\\[2ex]v_2=\frac{1} {12}(b-a)^2\\\\[2ex]\end{cases}\]</span> 解方程，可得： <span class="math display">\[a=\mu_1-\sqrt{3v_2}\\\\b=\mu_1+\sqrt{3v_2}\]</span> 用样本均值替换总体均值，用样本方差替换二阶中心矩，有： <span class="math display">\[\mu_1 \to \bar{x}\\\\v_2 \to \frac{1} {n}\sum_{i=1}^n(x_i-\bar{x})^2\]</span> 则可得<span class="math inline">\(a,b\)</span>的矩估计： <span class="math display">\[a=\bar{x}-\sqrt{\frac 3n\sum_{i=1}^n(x_i-\bar{x})^2}\\\\b=\bar{x}+\sqrt{\frac 3n\sum_{i=1}^n(x_i-\bar{x})^2}\]</span></p></blockquote><h3 id="极大似然估计">极大似然估计</h3><p>极大似然估计的思想是：如果在一次试验中产生了一个结果，那么一般认为试验条件对这个结果的发生有利，也就是这个结果发生的概率最大。</p><p>一般步骤是：先求出一个似然函数<span class="math inline">\(L(\theta;x_1,x_2,\cdots,x_n)\)</span>，它以待估计量<span class="math inline">\(\theta\)</span>为自变量，以试验结果为参数，它的含义是当前试验结果出现的概率。然后通过将<span class="math inline">\(L\)</span>(因为概率往往是乘积形式，有时我们也用<span class="math inline">\(\ln L\)</span>)对<span class="math inline">\(\theta\)</span>求偏导的方法，得出<span class="math inline">\(L\)</span>取得上界时<span class="math inline">\(\theta\)</span>的值，并将其作为估计结果。</p><blockquote><p>【例】总体<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.其中<span class="math inline">\(\mu,\sigma^2\)</span>的参数空间为<span class="math inline">\(\mu\in{\mathbb R},\sigma^2&gt;0\)</span>，<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是简单样本，求<span class="math inline">\(\mu,\sigma^2\)</span>的极大似然估计。</p><p>【解】总体的密度函数为： <span class="math display">\[p(x;\mu,\sigma^2)=\frac{1} {\sqrt{2\pi\sigma^2} }\exp(\frac{-(x-\mu)^2} {2\sigma^2})\]</span> 则有“似然函数”： <span class="math display">\[\begin{aligned}L(\mu,\sigma^2;x_1,\cdots,x_n)=\prod_{i=1}^np(x_1;\mu,\sigma^2)\end{aligned}\]</span> 则 <span class="math display">\[\ln L=-\frac n2\ln(2\pi)-\frac n2 \ln(\sigma^2)-\frac 1{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\]</span> 分别对<span class="math inline">\(\mu,\sigma^2\)</span>求导，得： <span class="math display">\[\begin{cases}\frac{\partial \ln L} {\partial \mu}=\frac{1} {\sigma^2}\sum_{i=1}^n(x_i-\mu)=0\\\\\frac{\partial \ln L} {\partial \sigma^2}=-\frac n{2\sigma^2}+\frac 1{2(\sigma^2)^2}\sum_{i=1}^n(x_i-\mu)=0\end{cases}\]</span> 解得： <span class="math display">\[\mu=\bar{x}\\\\\sigma^2=\frac 1n \sum(x_i-\bar{x})^2\]</span></p></blockquote><h3 id="区间估计定义">区间估计（定义）</h3><p><strong>定义（区间估计）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，如果存在两个统计量<span class="math inline">\(T_1(x),T_2(x)\)</span>，对于给定的<span class="math inline">\(\alpha\)</span>，有： <span class="math display">\[P\left\{\theta\in [T_1(x),T_2(x)]\right\}\geq 1-\alpha\]</span> 对任意<span class="math inline">\(\theta\)</span>都成立，称<span class="math inline">\([T_1,T_2]\)</span>是参数<span class="math inline">\(\theta\)</span>置信度为<span class="math inline">\(1-\alpha\)</span>的区间估计。</p><p>区间估计的含义是，假设做<span class="math inline">\(m\)</span>组重复试验，每组抽取<span class="math inline">\(n\)</span>个样本，这样就可以得到<span class="math inline">\(m\)</span>个区间<span class="math inline">\([T_1,T_2]\)</span>。在这<span class="math inline">\(m\)</span>个区间中，大约有<span class="math inline">\(100(1-\alpha)\%\)</span>包含<span class="math inline">\(\theta\)</span>的真值。我们不能说<span class="math inline">\(\theta\)</span>落入区间<span class="math inline">\([T_1,T_2]\)</span>的概率是<span class="math inline">\(1-\alpha\)</span>，这是因为<span class="math inline">\(\theta\)</span>的真值是一个客观存在的不变量。</p><h3 id="minimax估计">Minimax估计</h3><p><strong>定义（Minimax估计）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，<span class="math inline">\(G_q\)</span>是由待估参数<span class="math inline">\(q(\theta)\)</span>的估计量（决策函数）<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="决策函数的自变量是样本$\{x\}$，因变量是对待估计量的估计">[5]</span></a></sup>组成的集合，如果存在<span class="math inline">\(T^*\in G_q\)</span>，有： <span class="math display">\[\sup_{\theta\in\Theta}R(\theta,T^*)\leq\sup_{\theta\in\Theta}R(\theta,T)\]</span> 对任意<span class="math inline">\(T\in G_q\)</span>成立，则称<span class="math inline">\(T^*\)</span>是Minimax估计。其中<span class="math inline">\(R(\theta,T)\)</span>是风险函数，定义如下： <span class="math display">\[R(\theta,T)=E_\theta[L(\theta,T(x))]\]</span> 其中<span class="math inline">\(L(\theta,T)\)</span>是损失函数，意思是当待估计量是<span class="math inline">\(\theta\)</span>，然后你估计它为<span class="math inline">\(T(x)\)</span>时产生的损失。</p><blockquote><p>【例】总体服从两点分布<span class="math inline">\(B(1,p)\)</span>，<span class="math inline">\(p \in \{\frac 14,\frac12\}\)</span>，损失函数如下表所示，求<span class="math inline">\(p\)</span>的Minimax估计。</p><table><thead><tr class="header"><th><span class="math inline">\(p\)</span></th><th><span class="math inline">\(a_1=1/4\)</span></th><th><span class="math inline">\(a_2=1/2\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(p_1=1/4\)</span></td><td>1</td><td>4</td></tr><tr class="even"><td><span class="math inline">\(p_2=1/2\)</span></td><td>3</td><td>2</td></tr></tbody></table><p>【解】仅仅取1个观察值，那么总共有4种决策函数：</p><ol type="1"><li><p><code>T1=1/4</code></p></li><li><p><code>T2=(x==0)?1/4:1/2</code></p></li><li><p><code>T3=(x==0)?1/2:1/4</code></p></li><li><p><code>T4=1/2</code></p><p>响应的风险表如下：</p><table><thead><tr class="header"><th><span class="math inline">\(T_i\)</span></th><th><span class="math inline">\(R(p_1,T_i)\)</span></th><th><span class="math inline">\(R(p_2,T_i)\)</span></th><th><span class="math inline">\(\max R\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>3</td><td>3</td></tr><tr class="even"><td>2</td><td>7/4</td><td>5/2</td><td>5/2</td></tr><tr class="odd"><td>3</td><td>13/4</td><td>5/2</td><td>13/4</td></tr><tr class="even"><td>4</td><td>4</td><td>2</td><td>4</td></tr></tbody></table><p>例如，我们求<span class="math inline">\(R(p_2,T_2)\)</span>: <span class="math display">\[\begin{aligned}R(p_2,T_2)&amp;=E_{p_2}[L(p_2,T_2)]\\\\&amp;=P_{p_2}\{x=0\}L(p_2,1/4)+P_{p_2}\{x=1\}L(p_2,1/2)\\\\&amp;=\frac 12\times 3+\frac 12 \times 2\\\\&amp;=\frac 52\end{aligned}\]</span> 在第四列中选取最小的，所以应该选<span class="math inline">\(T_2\)</span>。</p></li></ol></blockquote><h2 id="假设检验">假设检验</h2><h3 id="结合实际问题的假设检验">结合实际问题的假设检验</h3><p>对于正态总体而言，有：</p><ol type="1"><li><p>单个方差已知时总体均值的检验 <span class="math display">\[H_0:\mu=\mu_0\ \ H_1:\mu\neq\mu_0\]</span> 检验统计量为： <span class="math display">\[z=\frac{\bar{x}-\mu_0} {\sigma/\sqrt{n} }\sim N(0,1)\]</span> 这种检验方法叫做“<span class="math inline">\(z\)</span>检验”</p><p>拒绝域为： <span class="math display">\[W=\{|z|\geq z_{1-\frac\alpha 2}\}\]</span></p></li><li><p>单个方差未知时总体均值的检验 <span class="math display">\[H_0:\mu=\mu_0\ \ H_1:\mu\neq\mu_0\]</span> 检验统计量： <span class="math display">\[t=\frac{\bar{x}-\mu_0} {S/\sqrt{n} }\sim t(n-1)\]</span> 这种检验方式叫做<span class="math inline">\(t\)</span>检验。</p><p>拒绝域： <span class="math display">\[W=\left\{\frac{\bar{x}-\mu_0} {S/\sqrt{n} }\geq t_{1-\frac \alpha2}(n-1)\right\}\]</span></p></li><li><p>单个均值未知时方差的检验 <span class="math display">\[H_0:\sigma^2=\sigma_0^2\]</span> 检验统计量： <span class="math display">\[\chi^2=\frac{(n-1)S^2} {\sigma_0^2} \sim \chi^2(n-1)\]</span> 拒绝域： <span class="math display">\[W=\{\chi^2\leq\chi^2_{\frac \alpha2}(n-1)\}\cup \{\chi^2\geq\chi_{1-\frac \alpha2}^2(n-1)\}\]</span></p></li><li><p>单个均值已知时方差的检验 <span class="math display">\[H_0:\sigma^2=\sigma_0^2\]</span> 检验统计量： <span class="math display">\[\chi^2=\frac 1{\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\sim\chi^2(n)\]</span> 拒绝域: <span class="math display">\[W=\{\chi^2\leq\chi^2_{\frac \alpha2}(n)\}\cup \{\chi^2\geq\chi_{1-\frac \alpha2}^2(n)\}\]</span></p></li><li><p>两个总体均值相等的检验</p><ol type="1"><li><p>两个方差<span class="math inline">\(\sigma_1,\sigma_2\)</span>已知</p><p>检验统计量： <span class="math display">\[z=\frac{\bar{x}-\bar{y} } {\sqrt{\frac{\sigma_1^2} {n_1}+\frac{\sigma^2_2} {n_2} }}\]</span></p><p>拒绝域： <span class="math display">\[W=\{|z|\geq z_{1-\frac\alpha 2}\}\]</span></p></li><li><p>两个方差未知但相等</p><p>检验统计量： <span class="math display">\[S^2_w=\frac{(n_1-1)S^2_1+(n_2-1)S_2^2} {n_1+n_2-2}\\\\t=\frac{\bar{x}-\bar{y} } {S_w\sqrt{\frac 1{n_1}+\frac1{n_2} }}\sim t(n_1+n_2-2)\]</span> 拒绝域 <span class="math display">\[W=\{|t|\geq t_{1-\frac \alpha2}(n_1+n_2-2)\}\]</span></p></li><li><p>方差情况未知但样本数相等</p><p>检验统计量 <span class="math display">\[z_i=x_i-y_i\\\\t=\frac{\bar{z} } {S_z/\sqrt{n} }\sim t(n-1)\]</span> 拒绝域 <span class="math display">\[W=\{|t|\geq t_{1-\frac \alpha2}(n-1)\}\]</span></p></li></ol></li></ol><h3 id="umpt一致最优势检验">UMPT一致最优势检验</h3><p>首先我们明确几个概念</p><p><strong>定义（检验函数）</strong> 检验函数<span class="math inline">\(\varphi(x)\)</span>一般定义如下： <span class="math display">\[\varphi(x)=I_{x\in W}(x)\]</span> 也就是拒绝域上的示性函数，即： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;x\in W\\\\0, &amp;\text{others}\end{cases}\]</span> 当检验函数为1时，选择拒绝<span class="math inline">\(H_0\)</span>。这样的检验函数叫非随机化检验函数。如果得到样本<span class="math inline">\(x\)</span>后，以概率<span class="math inline">\(\varphi(x)\)</span>，这就是随机化检验函数。</p><p><strong>定义（检验的势函数）</strong> 样本观测值落入拒绝域的概率称为势函数<span class="math inline">\(g(\theta)\)</span>.</p><p><strong>定义（检验的水平）</strong> 对于给定的<span class="math inline">\(\alpha\in[0,1]\)</span>,如果检验<span class="math inline">\(\varphi(x)\)</span>对所有<span class="math inline">\(\theta\in\Theta_0\)</span>满足<span class="math inline">\(E_{\theta}[\varphi(x)]\leq\alpha\)</span>，称<span class="math inline">\(\varphi(x)\)</span>的水平是<span class="math inline">\(\alpha\)</span></p><p>一个自然的比较检验的优劣的方式是：在相同的检验水平<span class="math inline">\(\alpha\)</span>下，如果 <span class="math display">\[E_{\theta_1}[\varphi_1(x)]\geq E_{\theta_1}[\varphi_2(x)]\]</span> 那么就说<span class="math inline">\(\varphi_1\)</span>比较好。</p><p><strong>定理（N-P引理）</strong> 对于假设检验问题： <span class="math display">\[H_0:\theta= \theta_0\ \ \ H_1:\theta=\theta_1\]</span> 以及给定检验水平<span class="math inline">\(\alpha\)</span>,有：</p><ol type="1"><li><p>存在非负常数<span class="math inline">\(k\)</span>，检验 <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;L(x)\geq k\\\\1, &amp;L(x)&lt; k\\\\\end{cases}\]</span> 满足 <span class="math display">\[E_{\theta_0}[\varphi(x)]=\alpha\]</span> 而且检验函数<span class="math inline">\(\varphi(x)\)</span>是水平为<span class="math inline">\(\alpha\)</span>的最优势检验。其中<span class="math inline">\(L(x)\)</span>是似然比统计量： <span class="math display">\[L(x)=\frac{p(x;\theta_1)} {p(x;\theta_0)}\]</span></p></li><li><p>如果检验函数<span class="math inline">\(\varphi(x)\)</span>是水平为<span class="math inline">\(\alpha\)</span>的最优势检验，那么一定存在非负常数<span class="math inline">\(k\)</span>，使得<span class="math inline">\(\varphi(x)\)</span>满足（1）的第一个式子，如果有<span class="math inline">\(E_{\theta_1}[\varphi(x)]\leq 1\)</span>，那么第二个式子也满足。</p></li></ol><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自正态总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>维简单随机样本，<span class="math inline">\(\mu\geq 0,\sigma\)</span>已知。对于假设： <span class="math display">\[H_0:\mu=0\ \ H_1:\mu=\mu_1&gt;0\]</span> 求水平为<span class="math inline">\(\alpha\)</span>的最优势检验。</p><p>【解】检验函数具有如下形式： <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;L(x)\geq k\\\\1, &amp;L(x)&lt; k\\\\\end{cases}\]</span> 其中<span class="math inline">\(L(x)\)</span>满足： <span class="math display">\[\begin{aligned}L(x)&amp;=\frac{p(x;\mu_1)} {p(x;0)}\\\\&amp;=\exp\left\{\frac{n\mu_1\bar{x} } {\sigma^2}-\frac{n\mu_1^2} {2\sigma^2}\right\}\end{aligned}\]</span> <span class="math inline">\(k\)</span>由 <span class="math display">\[E_{\mu=0}[\varphi(x)]=P_{\mu=0}\{L(x)\geq k\}=\alpha\]</span> 确定。</p><p>由于<span class="math inline">\(L(x)\)</span>随<span class="math inline">\(\bar{x}\)</span>单增，因此 <span class="math display">\[\{x|L(x)\geq k\}=\{x|\bar{x}\geq c\}\]</span> 对于给定的<span class="math inline">\(\alpha\)</span>，有： <span class="math display">\[P_{\mu=0}\{L(x)\geq k\}=P_{\mu=0}\{\bar{x}\geq c\}=1-\Phi\left(\frac{c} {\sigma/\sqrt{n} }\right)=\alpha\]</span> 得<span class="math inline">\(c=\sigma z_{1-\alpha}/\sqrt{n}\)</span></p><p>则检验函数： <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;\bar(x)\geq c\\\\1, &amp;\bar(x)&lt; c\\\\\end{cases}\]</span></p></blockquote><p><strong>定义（一致最优势检验）</strong> 如果检验问题是： <span class="math display">\[H_0:\theta\in \Theta_0\ \ \ H_1:\theta\in\Theta_1\]</span> 对于<span class="math inline">\(\Theta_0\)</span>中的每个<span class="math inline">\(\theta\)</span>，<span class="math inline">\(\varphi\)</span>都是最优势检验，那么<span class="math inline">\(\varphi\)</span>称为一致最优势检验。</p><p><strong>定理（UMPT的确定） </strong> 对于单参数的密度函数（分布列）<span class="math inline">\(p(x;\theta)\)</span>，如果可以表示为： <span class="math display">\[p(x;\theta)=d(\theta)h(x)\exp\{c(\theta)T(x)\}\]</span> 其中<span class="math inline">\(c(\theta)\)</span>严格单增，那么对于检验问题： <span class="math display">\[H_0:\theta\leq \theta_0\ \ H_1:\theta&gt;\theta_0\]</span></p><ol type="1"><li><p>水平为<span class="math inline">\(\alpha\)</span>的UMPT存在，为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;T(x)&gt; c\\\\r, &amp;T(x)=c\\\\0, &amp;T(x)&lt; c\\\\\end{cases}\]</span> 常数<span class="math inline">\(c,r\)</span>由<span class="math inline">\(E_{\theta_0}[\varphi(x)]=\alpha\)</span>确定。</p></li><li><p>势函数<span class="math inline">\(g(\theta)=E_{\theta}[\varphi(x)]\)</span>单增。</p></li></ol><p>注解：</p><ol type="1"><li><p>如果<span class="math inline">\(c(\theta)\)</span>单减，结论仍然成立，只需将检验函数中的不等号调换。</p></li><li><p>对于检验问题： <span class="math display">\[H_0:\theta=\theta_0\ \ H_1:\theta&gt;\theta_0\]</span> 结论完全照原样成立。</p></li><li><p>对于检验问题 <span class="math display">\[H_0:\theta\geq \theta_0\ \ H_1:\theta&lt;\theta_0\]</span> 只需取<span class="math inline">\(\theta&#39;=-\theta\)</span>即可。</p></li></ol><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自正态总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>维简单随机样本，<span class="math inline">\(\mu\)</span>已知，<span class="math inline">\(\sigma^2\)</span>未知，求检验： <span class="math display">\[H_0:\sigma^2\leq \sigma_0^2\ \ H_1:\sigma^2&gt;\sigma_0^2\]</span> 的UMPT。</p><p>【解】对于联合密度函数，有： <span class="math display">\[p(x;\theta)=\left(\frac{1} {\sqrt{2\pi\sigma^2} }\right)^n\exp\left\{-\frac{1} {2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\right\}\]</span> 其中：</p><ol type="1"><li><span class="math inline">\(d(\sigma^2)=\left(\frac{1} {\sqrt{2\pi\sigma^2} }\right)^n\)</span></li><li><span class="math inline">\(h(x)=1\)</span></li><li><span class="math inline">\(c(\sigma^2)=-\frac{1} {2\sigma^2}\)</span></li><li><span class="math inline">\(T(x)=\sum_{i=1}^n(x_i-\mu)^2\)</span></li></ol><p>则UMPT存在，为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;T(x)\geq c\\\\0, &amp;T(x)&lt; c\\\\\end{cases}\]</span> 由 <span class="math display">\[E_{\sigma^2}[\varphi(x)]=P_{\sigma_0^2}\left\{\frac{1} {\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\geq\frac{c} {\sigma_0^2} \right\}=\alpha\]</span> 其中 <span class="math display">\[\frac{1} {\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\sim \chi^2(n)\]</span> 故 <span class="math display">\[c=\sigma_0^2\chi^2_{1-\alpha}(n)\]</span> 综上所述，UMPT为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;\sum_{i=1}^n(x_i-\mu)^2\geq \sigma_0^2\chi^2_{1-\alpha}(n)\\\\0, &amp;\sum_{i=1}^n(x_i-\mu)^2&lt; \sigma_0^2\chi^2_{1-\alpha}(n)\\\\\end{cases}\]</span></p></blockquote><h2 id="分布">分布</h2><p>由正态分布导出的三大分布：</p><h3 id="chi2分布"><span class="math inline">\(\chi^2\)</span>分布</h3><p>设<span class="math inline">\(X_1\cdots X_n\)</span>是服从<span class="math inline">\(N(0,1)\)</span>的随机变量，而且互相独立，则 <span class="math display">\[\sum_{i=1}^nX_i^2 \sim \chi^2(n)\]</span> 叫做：服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(\chi^2\)</span>分布。</p><h3 id="t分布"><span class="math inline">\(t\)</span>分布</h3><p>设<span class="math inline">\(X\sim N(0,1),Y\sim\chi^2(n)\)</span>，而且相互独立，则 <span class="math display">\[\frac{X} {\sqrt{Y/n} }\sim t(n)\]</span> 叫做：服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(t\)</span>分布，也叫学生分布。</p><h3 id="f分布"><span class="math inline">\(F\)</span>分布</h3><p>设<span class="math inline">\(X\sim \chi^2(n_1),Y\sim\chi^2(n_2)\)</span>，而且相互独立，则 <span class="math display">\[\frac{X/n_1} {Y/n_2}\sim F(n_1,n_2)\]</span></p><h3 id="分位数">分位数</h3><p>对于随机变量<span class="math inline">\(X\)</span>的分布函数<span class="math inline">\(F(x)\)</span>，给定实数<span class="math inline">\(p\in[0,1]\)</span>，若： <span class="math display">\[p\{X\leq x_p\}=F(x_p)=p\]</span> 称<span class="math inline">\(x_p\)</span>是此概率分布的<span class="math inline">\(p\)</span>分位数。</p><h2 id="线性回归">线性回归</h2><p>证明：<span class="math inline">\(e=Y-\hat{Y}\)</span>和<span class="math inline">\(\hat{\beta}=(X&#39;X)^{-1}X&#39;Y\)</span>不相关。</p><p>证明：<span class="math inline">\(e=[I_n-X(X&#39;X)^{-1}X&#39;]Y\)</span></p><p>由 <span class="math display">\[Cov(Ax,By)=ACov(x,y)B&#39;\]</span> 得： <span class="math display">\[\begin{aligned}Cov(e,\hat{\beta})&amp;=Cov([I_n-X(X&#39;X)^{-1}X&#39;]Y,(X&#39;X)^{-1}X&#39;Y)\\\\&amp;=[I_n-X(X&#39;X)^{-1}X&#39;]D[Y][(X&#39;X)^{-1}X&#39;]&#39;\\\\&amp;=\sigma^2[I_n-X(X&#39;X)^{-1}X&#39;][(X&#39;X)^{-1}X&#39;]&#39;\\\\&amp;=\sigma^2[(X&#39;X)^{-1}X]-[X(X&#39;X)^{-1}(X&#39;(X&#39;X)^{-1}X)]\\\\&amp;=\sigma^2[(X&#39;X)^{-1}X-X(X&#39;X)^{-1}]\\\\&amp;=0\end{aligned}\]</span></p><h2 id="主成分分析">主成分分析</h2><p>设总体<span class="math inline">\(\boldsymbol{x}=(x_1,x_2,\cdots,x_p)&#39;\)</span>是<span class="math inline">\(p\)</span>元总体，<span class="math inline">\(E[\boldsymbol{x}]=\boldsymbol{\mu},Var(\boldsymbol{x})=\boldsymbol{\Sigma}=(\sigma_{ij})\)</span>。我们的目标是把这<span class="math inline">\(p\)</span>个指标综合成少数几个指标，也就是所谓的主成分。要求这几个指标能尽量多地反应原来<span class="math inline">\(p\)</span>个指标所提供的信息，而且彼此不相关。</p><p>首先考虑把这<span class="math inline">\(p\)</span>个指标全综合到一个数值<span class="math inline">\(y_1\)</span>里，有： <span class="math display">\[y_1=u_1x_1+\cdots+u_px_p=\boldsymbol{u&#39;x}\]</span> 因为方差越大，信息量越大，所以我们的目的是：在<span class="math inline">\(\boldsymbol{u&#39;u}=1\)</span>的条件下，让<span class="math inline">\(Var(y)=\boldsymbol{u&#39;\Sigma u}\)</span>最大。</p><p>有如下定理：</p><p><strong>定理</strong> ：设<span class="math inline">\(\boldsymbol{\Sigma}\)</span>的特征值从大到小依次是<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_p\geq0\)</span>,<span class="math inline">\(\lambda_i\)</span>对应的单位特征向量为<span class="math inline">\(\boldsymbol{a_i}\)</span>，则：</p><ol type="1"><li>在<span class="math inline">\(\boldsymbol{u&#39;u}=1\)</span>的条件下，<span class="math inline">\(\boldsymbol{u&#39;\Sigma u}\)</span>在<span class="math inline">\(\boldsymbol{u=a_1}\)</span>时取得最大值<span class="math inline">\(\lambda_1\)</span></li><li>在<span class="math inline">\(\boldsymbol{u&#39;u}=1,\boldsymbol{u&#39;a_i}=0\)</span>的条件下（<span class="math inline">\(i=1,2,3,\cdots,k-1\)</span>），<span class="math inline">\(\boldsymbol{u&#39;\Sigma u}\)</span>在<span class="math inline">\(u=a_k\)</span>处取得最大值<span class="math inline">\(\lambda_k\)</span></li></ol><p>于是，我们称<span class="math inline">\(y_1=\boldsymbol{u&#39;a_1}\)</span>为第一主成分，如果信息量仍然不够，应该选择第二主成分。由于要保证主成分之间的独立性，则条件应该加上<span class="math inline">\(Cov(y_1,y_2)=\boldsymbol{a&#39;_1\Sigma u}=\lambda\boldsymbol{u&#39;a_1}=0\)</span>,于是遵循（2）的规则继续取就行了。如此这样不断地取，直到累计方差贡献率 <span class="math display">\[\frac{\lambda_1+\cdots+\lambda_k} {\lambda_1+\lambda_2+\cdots+\lambda_p}\]</span> 达到预设值（往往为百分之七十五），就结束分析。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><span class="math inline">(p(x;a,b))</span>的含义是：该函数以<span class="math inline">(x)</span>为自变量，有两个参数<span class="math inline">(a)</span>和<span class="math inline">(b)</span> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><span class="math inline">(I)</span>是<span class="math inline">(T(x))</span>的值域，<span class="math inline">()</span>是<span class="math inline">()</span>的值域 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><span class="math inline">(B(n,p))</span>表示重复<span class="math inline">(n)</span>次试验，每次试验成功的概率为<span class="math inline">(p)</span>，成功的试验数目。这里实际上退化成了两点分布。 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>指示函数<span class="math inline">(I_a())</span>：当条件<span class="math inline">(a)</span>为真时为<span class="math inline">(1)</span>，反之为<span class="math inline">(0)</span>. <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>决策函数的自变量是样本<span class="math inline">({x})</span>，因变量是对待估计量的估计 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数定义整理：第二弹</title>
    <link href="/2022/05/27/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E5%BC%B9/"/>
    <url>/2022/05/27/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p>环为什么叫做环？</p><span id="more"></span><hr /><h2 id="第三章-环与域">第三章 环与域</h2><p><strong>定义1（加群）</strong> .一个交换群叫做加群，当这个群的代数运算叫做”加法“，并用符号<span class="math inline">\(+\)</span>表示。</p><p><strong>定义2（环）</strong> .一个集合<span class="math inline">\(R\)</span>叫做一个环，当：</p><ol type="1"><li><span class="math inline">\(R\)</span>是一个加群，即<span class="math inline">\(R\)</span>对一个叫加法的代数运算作成一个交换群</li><li><span class="math inline">\(R\)</span>对另一个叫做乘法的代数运算封闭</li><li>这个乘法适合结合律</li><li>这里的加法和乘法适合左右分配律</li></ol><blockquote><p>例如：全体整数作成的集合对普通加法和乘法构成一个环。需要注意的是，环的定义中的乘法并不总满足交换律。</p></blockquote><p><strong>定义3（交换环）</strong> .一个环<span class="math inline">\(R\)</span>被称作交换环，当： <span class="math display">\[\forall a,b\in R,ab=ba\]</span> <strong>定义4（环的单位元）</strong> 如果一个环<span class="math inline">\(R\)</span>中存在一个元素<span class="math inline">\(e\)</span>,使得 <span class="math display">\[\forall a\in R,ea=ae=a\]</span> 那么这个<span class="math inline">\(e\)</span>叫做环<span class="math inline">\(R\)</span>的单位元。环并不总有单位元。</p><blockquote><p>例如：全体偶数对普通加法和普通乘法作成环，但是没有单位元。</p></blockquote><p><strong>定义5（零因子）</strong> .如果在一个环里，<span class="math inline">\(a\neq0,b\neq0\)</span>但是<span class="math inline">\(ab=0\)</span>，那么<span class="math inline">\(a\)</span>是环中的一个左零因子，<span class="math inline">\(b\)</span>是环中的一个右零因子。</p><blockquote><p>例如：对于所有形如<span class="math inline">\(\begin{pmatrix}x&amp;0\\y&amp;0\\\end{pmatrix}\)</span>的矩阵，对普通矩阵加法和普通矩阵乘法构成的环而言，有： <span class="math display">\[\begin{pmatrix}1 &amp; 0\\0 &amp;0\\\end{pmatrix}\begin{pmatrix}0 &amp; 0\\1 &amp; 0\\\end{pmatrix}=\begin{pmatrix}0 &amp; 0\\0 &amp;0\\\end{pmatrix}\]</span> 于是<span class="math inline">\(\begin{pmatrix}1 &amp; 0\\0 &amp;0\\\end{pmatrix}\)</span>是一个左零因子，<span class="math inline">\(\begin{pmatrix}0 &amp; 0\\1 &amp; 0\\\end{pmatrix}\)</span>是一个右零因子。</p></blockquote><blockquote><p>在一个没有零因子的环中两个消去律都成立，并且如果有任意一个消去律成立，就没有零因子。</p></blockquote><p><strong>定义6（整环）</strong> 符合以下性质的环<span class="math inline">\(R\)</span>叫做整环：</p><ol type="1"><li>乘法适合交换律</li><li><span class="math inline">\(R\)</span>有单位元<span class="math inline">\(1\)</span></li><li><span class="math inline">\(R\)</span>没有零因子</li></ol><p><strong>定义7（除环）</strong> 符合以下性质的环<span class="math inline">\(R\)</span>叫做除环：</p><ol type="1"><li><span class="math inline">\(R\)</span>至少包含一个不为<span class="math inline">\(0\)</span>的元</li><li><span class="math inline">\(R\)</span>有单位元</li><li><span class="math inline">\(R\)</span>的每一个不为<span class="math inline">\(0\)</span>的元有一个逆元</li></ol><blockquote><p>显然，除环没有零因子，而且除环中的元素（除了0）对于乘法来说构成群。在一个除环中，只要<span class="math inline">\(a\neq 0\)</span>,我们就能拿<span class="math inline">\(a\)</span>去除任意一个元<span class="math inline">\(b\)</span>，这就是除环名字的来历。</p></blockquote><p><strong>定义8（域）</strong> 一个交换除环叫做一个域。</p><p><strong>定义9（环的特征）</strong> 一个无零因子环<span class="math inline">\(R\)</span>的非零元的相同的（对于加法来说）的阶叫做环的特征。</p><blockquote><p>环的特征如果有限，那么它一定是个素数。</p></blockquote><p><strong>定义10（子环）</strong> 一个环<span class="math inline">\(R\)</span>的子集<span class="math inline">\(S\)</span>如果对<span class="math inline">\(R\)</span>的代数运算也作成一个环，那么它叫做<span class="math inline">\(R\)</span>的子环。</p><p><strong>定义11（多项式）</strong> 假设<span class="math inline">\(R_0\)</span>是一个有单位元的交换环，<span class="math inline">\(R\)</span>是<span class="math inline">\(R_0\)</span>的子环，且包含<span class="math inline">\(R_0\)</span>的单位元。我们在<span class="math inline">\(R_0\)</span>中取出一个元<span class="math inline">\(x\)</span>。一个可以写成 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n\]</span> 的<span class="math inline">\(R_0\)</span>的元叫做<span class="math inline">\(R\)</span>上的<span class="math inline">\(x\)</span>的多项式。</p><p><strong>定义12（多项式环）</strong> 我们把所有<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式放在一个集合中，叫做<span class="math inline">\(R[x]\)</span>，那么<span class="math inline">\(R[x]\)</span>叫做<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式环。</p><p><strong>定义13（未定元，次数）</strong> <span class="math inline">\(R_0\)</span>的一个元<span class="math inline">\(x\)</span>叫做<span class="math inline">\(R\)</span>上的一个未定元，如果<span class="math inline">\(R\)</span>中不存在不全为零的<span class="math inline">\(a_0,a_1,a_2,\cdots,a_n\)</span>，使得 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n=0\]</span> <span class="math inline">\(R\)</span>上的一个未定元<span class="math inline">\(x\)</span>的一元多项式只能用一种方法写成 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n ,a_n\neq0\]</span> 的形式。其中<span class="math inline">\(n\)</span>叫做多项式的次数。</p><p><strong>定义14（无关未定元）</strong> <span class="math inline">\(R_0\)</span>上的<span class="math inline">\(n\)</span>个元<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>叫做<span class="math inline">\(R\)</span>上的无关未定元，假如任何一个<span class="math inline">\(R\)</span>上<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>的多项式都不为零，除非系数全为零。</p><p><strong>定义15（理想）</strong> 环<span class="math inline">\(R\)</span>的一个子环<span class="math inline">\({\mathfrak A}\)</span>叫做一个 <strong>理想子环，简称理想</strong> ，当：</p><ol type="1"><li><span class="math inline">\(a,b\in{\mathfrak A}\to a-b\in {\mathfrak A}\)</span></li><li><span class="math inline">\(a\in{\mathfrak A},r\in R\to ra,ar\in{\mathfrak A}\)</span></li></ol><blockquote><p>一个环有两个平凡的理想，分别的只含零元的零理想、R自己（单位理想）</p></blockquote><p><strong>定义16（主理想）</strong> 给定一个环<span class="math inline">\(R\)</span>，取其中的一个元素<span class="math inline">\(a\)</span>，利用<span class="math inline">\(a\)</span>作成一个集合<span class="math inline">\({\mathfrak A}\)</span>,其中包含所有形如： <span class="math display">\[(x_1ay_1+\cdots+x_may_m)+sa+st+na\]</span> （其中<span class="math inline">\(x,y,s,t\in R\)</span>，<span class="math inline">\(n\)</span>是整数）形式的元。那么<span class="math inline">\({\mathfrak A}\)</span>是含有<span class="math inline">\(a\)</span>的最小理想，叫做由<span class="math inline">\(a\)</span>生成的 <strong>主理想</strong> ，用<span class="math inline">\((a)\)</span>表示。</p><p>特别地：</p><ul><li>如果<span class="math inline">\(R\)</span>是交换环，<span class="math inline">\((a)\)</span>的元都可以写成<span class="math inline">\(ra+na\)</span>的形式。其中<span class="math inline">\(r\in R,n\)</span>是整数</li><li>如果<span class="math inline">\(R\)</span>有单位元，<span class="math inline">\((a)\)</span>的元都可以写成<span class="math inline">\(\sum x_iay_i\)</span>的形式。</li><li>如果<span class="math inline">\(R\)</span>既是交换环由于单位元，那么<span class="math inline">\((a)\)</span>都可以写成<span class="math inline">\(ra\)</span>的形式。</li></ul><p><strong>定义17（生成理想）</strong> <span class="math inline">\({\mathfrak A}\)</span>叫做由<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span> <strong>生成的理想</strong> ，用<span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span>来表示。<span class="math inline">\({\mathfrak A}\)</span>包含所有可以写成 <span class="math display">\[s_1+s_2+\cdots+s_n(s_1\in(a_i))\]</span> 的元。</p><p><strong>定义18（剩余类环）</strong> 给定一个环<span class="math inline">\(R\)</span>，<span class="math inline">\({\mathfrak A}\)</span>是它的一个理想。就加法来看，<span class="math inline">\({\mathfrak A}\)</span>是<span class="math inline">\(R\)</span>的不变子群，这样<span class="math inline">\({\mathfrak A}\)</span>的陪集 <span class="math display">\[[a],[b],\cdots\]</span> 作成<span class="math inline">\(R\)</span>的一个分类，我们把这些类叫做模<span class="math inline">\({\mathfrak A}\)</span>的剩余类，<span class="math inline">\(\bar{R}\)</span>是所有模<span class="math inline">\({\mathfrak A}\)</span>的剩余类组成的集合，它也是一个环，我们称其为 <strong>剩余类环</strong> ，记作： <span class="math display">\[R/{\mathfrak A}\]</span></p><blockquote><p>事实上，<span class="math inline">\(R\)</span>和<span class="math inline">\(\bar{R}\)</span>同态。</p></blockquote><p><strong>定义19（最大理想）</strong> 一个环<span class="math inline">\(R\)</span>的一个不等于<span class="math inline">\(R\)</span>的理想<span class="math inline">\({\mathfrak A}\)</span>叫做 <strong>最大理想</strong> ，当除了<span class="math inline">\(R\)</span>和<span class="math inline">\({\mathfrak A}\)</span>以外，没有包含<span class="math inline">\({\mathfrak A}\)</span>的理想。</p><p>最大理想有时候也叫做极大理想。如果<span class="math inline">\(R\)</span>是有单位元的交换环，<span class="math inline">\({\mathfrak A}\)</span>是<span class="math inline">\(R\)</span>的理想，那么<span class="math inline">\(R/{\mathfrak A}\)</span>是一个域等价于<span class="math inline">\({\mathfrak A}\)</span>是最大理想。</p><p><strong>定义20（商域）</strong> 一个域<span class="math inline">\(Q\)</span>叫做一个环<span class="math inline">\(R\)</span>的 <strong>商域</strong> ，假如<span class="math inline">\(Q\)</span>包含<span class="math inline">\(R\)</span>，并且<span class="math inline">\(Q\)</span>恰好由 <span class="math display">\[\frac{a}{b}\ \ (a,b\in R,b\neq 0)\]</span> 组成。</p><h2 id="第四章-整环里的因子分解">第四章 整环里的因子分解</h2><p><strong>定理1（整数环上唯一分解定理）</strong> 一个整数可以唯一地写成若干个素数的乘积。</p><p><strong>定义21（整除,因子）</strong> 我们说整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(a\)</span>可以被整环<span class="math inline">\(I\)</span>中的另一个元<span class="math inline">\(b\)</span> <strong>整除</strong> ，当能在<span class="math inline">\(I\)</span>中找出一个元<span class="math inline">\(c\)</span>，使得 <span class="math display">\[a=bc\]</span> 如果<span class="math inline">\(a\)</span>能被<span class="math inline">\(b\)</span>整除，记作<span class="math inline">\(b|a\)</span>，我们说<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的 <strong>因子</strong>。</p><p><strong>定义22（单位，相伴元）</strong> 整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(\varepsilon\)</span>叫做<span class="math inline">\(I\)</span>的一个 <strong>单位</strong> ，当<span class="math inline">\(\varepsilon\)</span>是有逆元的元。<span class="math inline">\(b\)</span>叫做<span class="math inline">\(a\)</span>的 <strong>相伴元</strong> ，假如 <span class="math display">\[b=\varepsilon a\]</span></p><blockquote><p>例如，整数环中有两个单位，分别是<span class="math inline">\(1\)</span>和<span class="math inline">\(-1\)</span>；整复数环中有四个单位，分别是<span class="math inline">\(\pm 1\)</span>,<span class="math inline">\(\pm i\)</span>。显然，单位的乘积、单位的逆元也是单位。</p></blockquote><p><strong>定义23（平凡因子、真因子）</strong> 单位和<span class="math inline">\(a\)</span>的相伴元叫做<span class="math inline">\(a\)</span>的 <strong>平凡因子</strong> ，<span class="math inline">\(a\)</span>的其它因子叫做<span class="math inline">\(a\)</span>的 <strong>真因子</strong> 。</p><p><strong>定义24（素元）</strong> 一个整环<span class="math inline">\(I\)</span>的一个既不是零元、也不是单位、还没有真因子的元<span class="math inline">\(p\)</span>叫做 <strong>素元</strong> 。</p><blockquote><p>这样的话，单位元和素元的积也是素元。</p></blockquote><p><strong>定义25（唯一分解）</strong> 我们说一个整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(a\)</span>在<span class="math inline">\(I\)</span>里有 <strong>唯一分解</strong> ，假如：</p><ol type="1"><li><span class="math inline">\(a=p_1p_2\cdots p_r\)</span>，其中<span class="math inline">\(p_i\)</span>是素元</li><li>若同时<span class="math inline">\(a=q_1q_2\cdots q_s\)</span>，其中<span class="math inline">\(q\)</span>是素元，那么<span class="math inline">\(r=s\)</span>，并且我们可以把<span class="math inline">\(q_i\)</span>的次序调换一下，使得<span class="math inline">\(\forall i,q_i=p_i\varepsilon\)</span></li></ol><blockquote><p>一个整环的泠鸢和单位显然是没有唯一分解的，但是其实不是零元也不是单位的元也不一定有唯一分解，例如在环<span class="math inline">\(I=\{a+\sqrt{3}bi|a,b\in {\mathbb Z}\}\)</span>中的元<span class="math inline">\(4\)</span>，有： <span class="math display">\[4=2\times2=(1+\sqrt{3}i)\times(1-\sqrt{3}i)\]</span></p></blockquote><p><strong>定义26（唯一分解环）</strong> 如果一个整环<span class="math inline">\(I\)</span>的每一个不是零元也不是单位的元都能唯一分解，那么<span class="math inline">\(I\)</span>叫做 <strong>唯一分解环</strong> 。</p><p><strong>定义27（公因子，最大公因子）</strong> 如果一个元<span class="math inline">\(c\)</span>能同时整除<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，这个元<span class="math inline">\(c\)</span>叫做<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>的 <strong>公因子</strong> 。如果公因子<span class="math inline">\(d\)</span>能被每个公因子整除，那么这个<span class="math inline">\(d\)</span>叫做 <strong>最大公因子</strong> 。</p><p><strong>定义28（互素）</strong> 一列数的最大公因子是单位，那称这一列数 <strong>互素</strong> 。</p><p><strong>定义29（主理想环）</strong> 如果整环<span class="math inline">\(I\)</span>的每个理想都是主理想，那么称<span class="math inline">\(I\)</span>是 <strong>主理想环</strong> 。</p><blockquote><p>主理想环有个很重要的性质：在主理想环中构造一个序列<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，其中后项一定是前项的真因子，那么这个序列长度有限。而且一个主理想环一定是唯一分解环。</p></blockquote><p><strong>定义30（欧氏环）</strong> 一个满足下列性质的整环<span class="math inline">\(I\)</span>叫做 <strong>欧氏环</strong> ：</p><ol type="1"><li><p>有一个从<span class="math inline">\(I\)</span>的非零元所组成的集合到自然数集合的映射<span class="math inline">\(\phi\)</span>存在</p></li><li><p>对于<span class="math inline">\(I\)</span>中一个非零元<span class="math inline">\(a\)</span>，<span class="math inline">\(I\)</span>中任何元<span class="math inline">\(b\)</span>都可写成 <span class="math display">\[b=qa+r\ \ (q,r\in I)\]</span> 的形式，且有：<span class="math inline">\(r=0\)</span>或<span class="math inline">\(\phi(r)&lt;\phi(a)\)</span></p></li></ol><blockquote><p>所有欧氏环都是主理想环，于是也是唯一分解环。而且一个域<span class="math inline">\(F\)</span>上的一元多项式环<span class="math inline">\(F[x]\)</span>是一个欧氏环。</p></blockquote><p><strong>定义31（本原多项式）</strong> <span class="math inline">\(I[x]\)</span>的一个元<span class="math inline">\(f(x)\)</span>叫做本原多项式，假如<span class="math inline">\(f(x)\)</span>系数的最大公因子是单位。</p><p>如果有<span class="math inline">\(f(x)=g(x)h(x)\)</span>，那么<span class="math inline">\(f(x)\)</span>是本原多项式，当且仅当<span class="math inline">\(g(x),h(x)\)</span>是本原多项式。</p><p><strong>定义32（多项式的根）</strong> <span class="math inline">\(I\)</span>的元<span class="math inline">\(a\)</span>叫做<span class="math inline">\(I[x]\)</span>的多项式<span class="math inline">\(f(x)\)</span>的一个 <strong>根</strong> ，当且仅当<span class="math inline">\(f(a)=0\)</span></p><p><strong>定义33（多项式的重根）</strong> <span class="math inline">\(I\)</span>的元<span class="math inline">\(a\)</span>叫做<span class="math inline">\(I[x]\)</span>的多项式<span class="math inline">\(f(x)\)</span>的一个 <strong><span class="math inline">\(k\)</span>重根</strong> ，假如<span class="math inline">\(f(x)\)</span>能被<span class="math inline">\((x-a)^k\)</span>整除，其中<span class="math inline">\(k\)</span>大于1.</p><p><strong>定义34（多项式的导数）</strong> 对于多项式 <span class="math display">\[f(x)=\sum_{i=0}^na_ix^i\]</span> 其导数为 <span class="math display">\[f&#39;(x)=\sum_{i=1}^{n}ia_ix^{i-1}\]</span></p><h2 id="第五章扩域">第五章：扩域</h2><p><strong>定义35（扩域）</strong> 一个域<span class="math inline">\(E\)</span>叫做一个域<span class="math inline">\(F\)</span>的 <strong>扩域</strong> ，当<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域</p><p>例如：实数域是有理数域的扩域，复数域是实数域的扩域。</p><blockquote><p>事实上，令<span class="math inline">\(E\)</span>是一个域，如果<span class="math inline">\(E\)</span>的特征是无穷大，那么它含有一个和有理数域同构的子域；如果<span class="math inline">\(E\)</span>的特征是素数<span class="math inline">\(p\)</span>，那么它含一个和<span class="math inline">\(R/(p)\)</span>同构的子域，其中<span class="math inline">\(R\)</span>是整数环，<span class="math inline">\((p)\)</span>是由<span class="math inline">\(p\)</span>生成的主理想。</p></blockquote><p><strong>定义36（素域）</strong> 一个域叫做一个 <strong>素域</strong> ，假如它不含任何真子域。</p><p><strong>定义37（单扩域）</strong> 添加一个元素<span class="math inline">\(\alpha\)</span>于域<span class="math inline">\(F\)</span>中所得的扩域<span class="math inline">\(F(\alpha)\)</span>叫做<span class="math inline">\(F\)</span>的一个单扩域</p><p><strong>定义38（代数元）</strong> 如果对于域<span class="math inline">\(F\)</span>中的一个元素<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(F\)</span>中存在不全为零的元<span class="math inline">\(a_1,\cdots,a_n\)</span>，使得： <span class="math display">\[a_0+a_1\alpha+a_2\alpha+\cdots+a_n\alpha^n=0\]</span> 那么<span class="math inline">\(\alpha\)</span>叫做 <strong>代数元</strong> 。如果这样的<span class="math inline">\(a_1,\cdots,a_n\)</span>不存在，<span class="math inline">\(\alpha\)</span>就叫做 <strong>超越元</strong> 。</p><blockquote><p>代数数就是整数环上的代数元。</p></blockquote><p><strong>定义39（极小多项式）</strong> <span class="math inline">\(F[x]\)</span>中满足<span class="math inline">\(p(\alpha)=0\)</span>的次数最低的多项式 <span class="math display">\[p(x)=x^n+a_{n-1}x^{n-1}+\cdots+a_0\]</span> 叫做<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(F\)</span>上的 <strong>极小多项式</strong> ，<span class="math inline">\(n\)</span>叫做<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(F\)</span>上的 <strong>次数</strong></p><p><strong>定义40（代数扩域）</strong> 如果域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>的每一个元都是<span class="math inline">\(F\)</span>的代数元，那么<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F\)</span>的 <strong>代数扩域（扩张）</strong> 。</p><blockquote><p>假如<span class="math inline">\(K\)</span>是<span class="math inline">\(F\)</span>的扩域，那么<span class="math inline">\(K\)</span>可以视作是<span class="math inline">\(F\)</span>上的一个向量空间（对于<span class="math inline">\(K\)</span>的加法和<span class="math inline">\(F\times K\to K\)</span>的乘法）。也就是说，对于任意<span class="math inline">\(K\)</span>上的元素<span class="math inline">\(\alpha\)</span> ，存在一组来自于<span class="math inline">\(K\)</span>的基，使<span class="math inline">\(\alpha\)</span>可以被那些基线性表出，而表示的基的各项系数都在<span class="math inline">\(F\)</span>内。</p><p>例如：复数域是实数域的扩域，而复数域的“基”就是<span class="math inline">\(1\)</span>和<span class="math inline">\(i\)</span></p></blockquote><p><strong>定义41（有限扩域，扩域的次数）</strong> 如果域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>作为<span class="math inline">\(F\)</span>上的向量空间的维数为<span class="math inline">\(n\)</span>，那么<span class="math inline">\(n\)</span>称作扩域<span class="math inline">\(E\)</span>在<span class="math inline">\(F\)</span>上的 <strong>次数</strong> ，记作<span class="math inline">\((E:F)=n\)</span>.此时<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F\)</span>的一个 <strong>有限扩域</strong> 。</p><blockquote><p>若有 <span class="math display">\[F\subset I\subset E\]</span> 则有 <span class="math display">\[(E:F)=(E:I)(I:F)\]</span></p></blockquote><p><strong>定义42（多项式的分裂域/根域）</strong> 域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F[x]\)</span>的<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(F\)</span>上的一个 <strong>分裂域（也叫根域）</strong> ，如果：</p><ol type="1"><li><p>在<span class="math inline">\(E[x]\)</span>中，<span class="math inline">\(f(x)\)</span>可以分解为一次因子的积 <span class="math display">\[f(x)=a_n(x-\alpha_1)(x-\alpha_2)\cdots(x-\alpha_n)\]</span></p></li><li><p>在一个比<span class="math inline">\(E\)</span>小的域中，<span class="math inline">\(f(x)\)</span>不能被这样分解。</p></li></ol><blockquote><p>有： <span class="math display">\[E=F(\alpha_1,\alpha_2\cdots,\alpha_n)\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于用R语言进行方差分析的乐子二则</title>
    <link href="/2022/05/23/%E5%85%B3%E4%BA%8E%E7%94%A8R%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%90%E5%AD%90%E4%BA%8C%E5%88%99/"/>
    <url>/2022/05/23/%E5%85%B3%E4%BA%8E%E7%94%A8R%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%90%E5%AD%90%E4%BA%8C%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>我们都知道R语言是非常强的统计工具，今天想着用R语言来做数理统计作业，却被摆了两道，哈哈。</p><span id="more"></span><h2 id="方差分析">方差分析</h2><p>要讨论这两则乐子，首先要知道什么是方差分析。</p><h3 id="单变量方差分析">单变量方差分析</h3><p>单因素方差分析可以看成基础统计中两样本<span class="math inline">\(t\)</span>检验的一个推广， 要比较试验观测值的某个因变量（称为“指标”）按照一个分组变量（称为“因素”）分组后， 各组的因变量均值有无显著差异。</p><p>设因素A有p个不同的水平<span class="math inline">\(A_1,A_2,\cdots,A_p\)</span>,在每个水平下，总体<span class="math inline">\(X_i\sim N(\mu_i,\sigma^2)\)</span>,需要检验的是这<span class="math inline">\(p\)</span>个样本的平均值有没有显著差异，即： <span class="math display">\[H_0:\mu_1=\mu_2=\cdots=\mu_p\]</span> 一般地，我们在每个水平中抽取<span class="math inline">\(r\)</span>个样本，形成如下的样本表：</p><table><thead><tr class="header"><th><span class="math inline">\(A_1\)</span></th><th><span class="math inline">\(x_{11}\)</span></th><th><span class="math inline">\(x_{12}\)</span></th><th><span class="math inline">\(\cdots\)</span></th><th><span class="math inline">\(x_{1r}\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(A_2\)</span></td><td><span class="math inline">\(x_{21}\)</span></td><td><span class="math inline">\(x_{22}\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(x_{2r}\)</span></td></tr><tr class="even"><td><span class="math inline">\(\cdots\)</span></td><td></td><td></td><td><span class="math inline">\(\cdots\)</span></td><td></td></tr><tr class="odd"><td><span class="math inline">\(A_P\)</span></td><td><span class="math inline">\(x_{p1}\)</span></td><td><span class="math inline">\(x_{p2}\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(x_{pr}\)</span></td></tr></tbody></table><p>【例】：用R语言对下列数据进行方差分析：</p><table><thead><tr class="header"><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr class="odd"><td>58</td><td>58</td><td>48</td></tr><tr class="even"><td>64</td><td>69</td><td>57</td></tr><tr class="odd"><td>55</td><td>71</td><td>59</td></tr><tr class="even"><td>66</td><td>64</td><td>47</td></tr><tr class="odd"><td>67</td><td>68</td><td>49</td></tr></tbody></table><p>【解】先把表格转换成纵列形式</p><table><thead><tr class="header"><th>grp</th><th>y</th></tr></thead><tbody><tr class="odd"><td>A</td><td>58</td></tr><tr class="even"><td>A</td><td>64</td></tr><tr class="odd"><td>A</td><td>55</td></tr><tr class="even"><td>A</td><td>66</td></tr><tr class="odd"><td>A</td><td>67</td></tr><tr class="even"><td>B</td><td>58</td></tr><tr class="odd"><td>B</td><td>69</td></tr><tr class="even"><td>B</td><td>71</td></tr><tr class="odd"><td>B</td><td>64</td></tr><tr class="even"><td>B</td><td>68</td></tr><tr class="odd"><td>C</td><td>48</td></tr><tr class="even"><td>C</td><td>57</td></tr><tr class="odd"><td>C</td><td>59</td></tr><tr class="even"><td>C</td><td>47</td></tr><tr class="odd"><td>C</td><td>49</td></tr></tbody></table><p>将上表保存为<code>R1.csv</code>，在”我的文档“中。在R软件中输入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">data <span class="hljs-operator">&lt;-</span> read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;R1.csv&quot;</span><span class="hljs-punctuation">)</span><br>data<br></code></pre></td></tr></table></figure><p>可以读入数据，并展示数据。</p><p>然后建立方差分析模型，在R软件中输入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>y<span class="hljs-operator">~</span>grp<span class="hljs-punctuation">,</span>data<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>即可输出分析结果，如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value  Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>   <br>grp          <span class="hljs-number">2</span>    <span class="hljs-number">520</span>  <span class="hljs-number">260.00</span>   <span class="hljs-number">9.176</span> <span class="hljs-number">0.00382</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">12</span>    <span class="hljs-number">340</span>   <span class="hljs-number">28.33</span>                   <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们看到<code>grp</code>的<span class="math inline">\(P_r\)</span>值有<span class="math inline">\(0.00382&lt;0.05\)</span>，所以可以认为各组之间有显著差异。</p><h3 id="双变量方差分析">双变量方差分析</h3><p>在实际任务中，影响实验结果的因素可能不止一个，这时就要用到双变量方差分析（或者正交实验）。在两个因素的实验中，不但每一个因素会对结果起作用，而且两个因素联合起来往往也会对结果起作用。如果你不能理解这个结论，不妨设想这样一个例子：工人在工厂工作时，对工人效率的影响因素有工人和机器。如果工人专业技能高、机器运行状况好，那么效率很自然地就会比较高。但是一个资质平平的工人如果对某个状况一般的机器非常熟悉，以至于把这个机器什么时候会出现什么误差都记得滚瓜烂熟，那么把他俩结合起来，也有可能获得很高的效率。</p><p>为了进行双变量方差分析，进行双因素重复性实验，得到的数据表往往是这样给出的：</p><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320029199.png" /></p><p>这时，我就美美地开始做题了！</p><h2 id="第一道题">第一道题</h2><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320064532.png" /></p><p>我一看这不简单？于是美美列了个表：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B   Y<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">106</span><br><span class="hljs-number">4</span>  <span class="hljs-number">4</span> <span class="hljs-number">1</span>  <span class="hljs-number">98</span><br><span class="hljs-number">5</span>  <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">102</span><br><span class="hljs-number">6</span>  <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">112</span><br><span class="hljs-number">7</span>  <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">105</span><br><span class="hljs-number">8</span>  <span class="hljs-number">8</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">9</span>  <span class="hljs-number">1</span> <span class="hljs-number">2</span>  <span class="hljs-number">95</span><br><span class="hljs-number">10</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>  <span class="hljs-number">94</span><br><span class="hljs-number">11</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">105</span><br><span class="hljs-number">12</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span>  <span class="hljs-number">97</span><br><span class="hljs-number">13</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-number">98</span><br><span class="hljs-number">14</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">112</span><br><span class="hljs-number">15</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">103</span><br><span class="hljs-number">16</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span>  <span class="hljs-number">92</span><br><span class="hljs-number">17</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>  <span class="hljs-number">89</span><br><span class="hljs-number">18</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>  <span class="hljs-number">88</span><br><span class="hljs-number">19</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>  <span class="hljs-number">87</span><br><span class="hljs-number">20</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>  <span class="hljs-number">95</span><br><span class="hljs-number">21</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span>  <span class="hljs-number">97</span><br><span class="hljs-number">22</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">101</span><br><span class="hljs-number">23</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span>  <span class="hljs-number">97</span><br><span class="hljs-number">24</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span>  <span class="hljs-number">90</span><br><span class="hljs-number">25</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>  <span class="hljs-number">83</span><br><span class="hljs-number">26</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>  <span class="hljs-number">84</span><br><span class="hljs-number">27</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>  <span class="hljs-number">90</span><br><span class="hljs-number">28</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">90</span><br><span class="hljs-number">29</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">88</span><br><span class="hljs-number">30</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span>  <span class="hljs-number">94</span><br><span class="hljs-number">31</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span>  <span class="hljs-number">88</span><br><span class="hljs-number">32</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span>  <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>读取数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">X<span class="hljs-operator">=</span>read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;R.csv&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>建立模型并分析：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod<span class="hljs-operator">&lt;-</span>aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">+</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">1</span>   <span class="hljs-number">74.0</span>    <span class="hljs-number">74.0</span>   <span class="hljs-number">2.385</span>    <span class="hljs-number">0.133</span>    <br>B            <span class="hljs-number">1</span>  <span class="hljs-number">926.4</span>   <span class="hljs-number">926.4</span>  <span class="hljs-number">29.857</span> <span class="hljs-number">6.99e-06</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">29</span>  <span class="hljs-number">899.8</span>    <span class="hljs-number">31.0</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其中：</p><table><thead><tr class="header"><th>项目</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Df</td><td>自由度</td></tr><tr class="even"><td>Sum Sq</td><td>平方和</td></tr><tr class="odd"><td>Mean Sq</td><td>均方</td></tr><tr class="even"><td>F value</td><td>F值</td></tr><tr class="odd"><td>Pr(&gt;F)</td><td>p值</td></tr></tbody></table><p>哈哈，聪明的你一定看出问题了吧，那就是这俩的自由度都是<span class="math inline">\(1\)</span>，这是怎么会事呢？</p><p>原来是因为我的两个标签<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都用了数字，而R语言里的数据类型有数字、字符等。它把我们的1，2，3，...当成了一个连续变量，于是就出错了。当然这个问题可以用<code>ac.factor()</code>函数解决，但是我直接把标签换成字母也能解决。</p><p>修改了以后的输出为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">7</span>  <span class="hljs-number">747.5</span>   <span class="hljs-number">106.8</span>   <span class="hljs-number">12.78</span> <span class="hljs-number">2.62e-06</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>B            <span class="hljs-number">3</span>  <span class="hljs-number">977.3</span>   <span class="hljs-number">325.8</span>   <span class="hljs-number">39.00</span> <span class="hljs-number">9.12e-09</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">21</span>  <span class="hljs-number">175.4</span>     <span class="hljs-number">8.4</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个结果是正确的。我们可以发现<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都对结果有不可忽视的影响。</p><h2 id="第二道题">第二道题</h2><p>三位操作工分别在四台不同的机器上操作了3天，其产量如下表所示：</p><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320084039.png" /></p><p>于是我想当然哈，以为三次实验，加一下就好了，于是列了这么个表：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B  Y<br><span class="hljs-number">1</span>  a x <span class="hljs-number">47</span><br><span class="hljs-number">2</span>  b x <span class="hljs-number">51</span><br><span class="hljs-number">3</span>  <span class="hljs-built_in">c</span> x <span class="hljs-number">48</span><br><span class="hljs-number">4</span>  d x <span class="hljs-number">60</span><br><span class="hljs-number">5</span>  a y <span class="hljs-number">54</span><br><span class="hljs-number">6</span>  b y <span class="hljs-number">45</span><br><span class="hljs-number">7</span>  <span class="hljs-built_in">c</span> y <span class="hljs-number">51</span><br><span class="hljs-number">8</span>  d y <span class="hljs-number">48</span><br><span class="hljs-number">9</span>  a z <span class="hljs-number">55</span><br><span class="hljs-number">10</span> b z <span class="hljs-number">63</span><br><span class="hljs-number">11</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">54</span><br><span class="hljs-number">12</span> d z <span class="hljs-number">51</span><br></code></pre></td></tr></table></figure><p>建立模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">+</span>B<span class="hljs-operator">+</span>A<span class="hljs-operator">:</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq<br>A            <span class="hljs-number">3</span>   <span class="hljs-number">8.25</span>    <span class="hljs-number">2.75</span><br>B            <span class="hljs-number">2</span>  <span class="hljs-number">81.50</span>   <span class="hljs-number">40.75</span><br>A<span class="hljs-operator">:</span>B          <span class="hljs-number">6</span> <span class="hljs-number">220.50</span>   <span class="hljs-number">36.75</span><br></code></pre></td></tr></table></figure><p>根据<span class="math inline">\(F\)</span>值，我们可以看出....欸我<span class="math inline">\(F\)</span>值呢？咋没了？</p><p>这是因为，在”加和“（或者求平均值）的时候，就顺带消除了<span class="math inline">\(A\times B\)</span>的影响。这是因为<span class="math inline">\(A\times B\)</span>的离差平方和为： <span class="math display">\[S_{A\times B}=\sum_{i=1}^p\sum_{j=1}^q\sum_{k=1}^r (\bar{x}_{ij\cdot} -\bar{x}_{i\cdot \cdot } - \bar{x}_{\cdot j \cdot } +\bar{x})^2\]</span> 对于多次重复实验，应该把它们分拆开，每次都单独算。列表如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B  Y<br><span class="hljs-number">1</span>  a x <span class="hljs-number">15</span><br><span class="hljs-number">2</span>  b x <span class="hljs-number">17</span><br><span class="hljs-number">3</span>  <span class="hljs-built_in">c</span> x <span class="hljs-number">15</span><br><span class="hljs-number">4</span>  d x <span class="hljs-number">18</span><br><span class="hljs-number">5</span>  a y <span class="hljs-number">19</span><br><span class="hljs-number">6</span>  b y <span class="hljs-number">15</span><br><span class="hljs-number">7</span>  <span class="hljs-built_in">c</span> y <span class="hljs-number">18</span><br><span class="hljs-number">8</span>  d y <span class="hljs-number">15</span><br><span class="hljs-number">9</span>  a z <span class="hljs-number">16</span><br><span class="hljs-number">10</span> b z <span class="hljs-number">19</span><br><span class="hljs-number">11</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">12</span> d z <span class="hljs-number">17</span><br><span class="hljs-number">13</span> a x <span class="hljs-number">15</span><br><span class="hljs-number">14</span> b x <span class="hljs-number">17</span><br><span class="hljs-number">15</span> <span class="hljs-built_in">c</span> x <span class="hljs-number">17</span><br><span class="hljs-number">16</span> d x <span class="hljs-number">20</span><br><span class="hljs-number">17</span> a y <span class="hljs-number">19</span><br><span class="hljs-number">18</span> b y <span class="hljs-number">15</span><br><span class="hljs-number">19</span> <span class="hljs-built_in">c</span> y <span class="hljs-number">17</span><br><span class="hljs-number">20</span> d y <span class="hljs-number">16</span><br><span class="hljs-number">21</span> a z <span class="hljs-number">18</span><br><span class="hljs-number">22</span> b z <span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">24</span> d z <span class="hljs-number">17</span><br><span class="hljs-number">25</span> a x <span class="hljs-number">17</span><br><span class="hljs-number">26</span> b x <span class="hljs-number">17</span><br><span class="hljs-number">27</span> <span class="hljs-built_in">c</span> x <span class="hljs-number">16</span><br><span class="hljs-number">28</span> d x <span class="hljs-number">22</span><br><span class="hljs-number">29</span> a y <span class="hljs-number">16</span><br><span class="hljs-number">30</span> b y <span class="hljs-number">15</span><br><span class="hljs-number">31</span> <span class="hljs-built_in">c</span> y <span class="hljs-number">16</span><br><span class="hljs-number">32</span> d y <span class="hljs-number">17</span><br><span class="hljs-number">33</span> a z <span class="hljs-number">21</span><br><span class="hljs-number">34</span> b z <span class="hljs-number">22</span><br><span class="hljs-number">35</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">36</span> d z <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>建立模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">*</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">3</span>   <span class="hljs-number">2.75</span>   <span class="hljs-number">0.917</span>   <span class="hljs-number">0.532</span> <span class="hljs-number">0.664528</span>    <br>B            <span class="hljs-number">2</span>  <span class="hljs-number">27.17</span>  <span class="hljs-number">13.583</span>   <span class="hljs-number">7.887</span> <span class="hljs-number">0.002330</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span> <br>A<span class="hljs-operator">:</span>B          <span class="hljs-number">6</span>  <span class="hljs-number">73.50</span>  <span class="hljs-number">12.250</span>   <span class="hljs-number">7.113</span> <span class="hljs-number">0.000192</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">24</span>  <span class="hljs-number">41.33</span>   <span class="hljs-number">1.722</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们可以看到，效率主要和工人的水平以及工人和机器的交互有关。</p><p>哈哈，我是铸币。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于拉普拉斯变换的那些事</title>
    <link href="/2022/05/21/%E5%85%B3%E4%BA%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/05/21/%E5%85%B3%E4%BA%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>拉普拉斯变换在许多工程技术和科学研究领域中有着广泛的应用，特别是在力学系统、电学系统、自动控制系统、可靠性系统以及随机服务系统等系统科学中都起着重要作用。本文大概写了一下常用的拉普拉斯变换技巧，非常的详细，我感觉任何人都能看懂。 本文约5200字，阅读时间22分钟。</p><span id="more"></span><h2 id="拉普拉斯变换概述">拉普拉斯变换概述</h2><p>说到拉普拉斯变换，就不得不提到奥列弗·赫维赛德。不得不说这位更是重量级，尽管大家可能不认识他，但是大家一定知道<code>Heaviside()</code>函数（在Mathematica中是<code>HeavisideTheta[]</code>函数）,这就是所谓的单位阶跃函数，我们一般简写为<span class="math inline">\(u(t)\)</span>或者<span class="math inline">\(\varepsilon(t)\)</span>。而且他在电子信息领域还有很多重要的贡献，比如说归纳整理了麦克斯韦方程组。而这里我们要说的是，他提出了运算微积分的思想，把常微分方程转换成了代数方程。具体地，他提出了微分算子<span class="math inline">\(p\)</span>: <span class="math display">\[p^n \leftrightarrow\frac{ {\mathbf d}^n()} { {\mathbf d}t^n}\]</span> 积分算子： <span class="math display">\[\frac{1} {p}\leftrightarrow \int_{-\infty}^t(){\mathbf d}\tau\]</span> 于是就能把常微分方程化成代数方程了。这种想法在当时并不被学界认可，但是我们现在发现这就是拉普拉斯变换的前身。</p><p>......扯远了，那么什么是拉普拉斯变换呢？我们都知道傅里叶变换很好用，但是要用它就必须得满足狄利特雷条件，其中有一条就是<span class="math inline">\(f(t)\)</span>绝对可积，这可不是什么简单的条件，于是就导致很多常见的函数没有傅里叶变换。那么为了推广傅里叶变换，给<span class="math inline">\(f(t)\)</span>乘上一个很强的衰减系数<span class="math inline">\(e^{-\sigma t}\)</span>,这时很多函数就变得绝对可积了。</p><p>容易发现，<span class="math inline">\(e^{-\sigma t}\)</span>往往在<span class="math inline">\(t&gt;0\)</span>的时候才表现出”衰减“的性质，于是我们往往讨论单边拉普拉斯变换，即： <span class="math display">\[{\mathscr L}[f(t)]=F(s)=\int_{0-}^{\infty}f(t)e^{-(\sigma +j\omega)t} {\mathbf d}t\]</span> 其中<span class="math inline">\(s={\sigma + j\omega}\)</span>.</p><p>拉普拉斯变换需要讨论收敛域的问题。我们把让上述无穷积分收敛的<span class="math inline">\(s\)</span>所在的区域称为收敛域。收敛域的边界是平行于虚轴的直线。对于右边信号而言，收敛域往往是<span class="math inline">\(Re[s]&gt;\alpha\)</span>的形式，也就是右半边平面。在讨论右边信号和单边拉普拉斯变换时，往往省去对收敛域的讨论。但对于双边拉普拉斯变换来说，一定要讨论收敛域。因为此时对于同一个<span class="math inline">\(F(s)\)</span>，不同的收敛域会导致反变换的结果不同。</p><h2 id="拉普拉斯变换性质">拉普拉斯变换性质</h2><p>设<span class="math inline">\({\mathscr L}[f(t)]=F(s)\)</span>，则</p><p>拉普拉斯变换常用的性质有：</p><h3 id="时域性质">时域性质</h3><ol type="1"><li><p>时移性质： <span class="math display">\[{\mathscr  L}[f(t-t_0)u(t-t_0)]=F(s)e^{-st_0}\]</span> 需要注意到：<span class="math inline">\(f(t-t_0)u(t-t_0)\)</span>、<span class="math inline">\(f(t-t_0)u(t)\)</span>、<span class="math inline">\(f(t-t_0)\)</span>是互不相同的。</p></li><li><p>压扩(相似)性质： <span class="math display">\[{\mathscr  L}[f(at)]=\frac{1} {a}F(\frac{s} {a})\]</span></p></li><li><p>线性性质</p></li><li><p>时域微分性质： <span class="math display">\[\begin{aligned}{\mathscr L}[\frac{ {\mathbf d}^n f(t)} { {\mathbf d}t}]&amp;=s^nF(s)-s^{n-1}f(0_-)-s^{n-2}f&#39;(0_-)-\cdots-f^{(n-1)}(0_-)\\\\&amp;=s^nF(s)-\sum_{k=0}^{n-1}s^{n-1-k}f^{(k)}(0_-)\end{aligned}\]</span></p><p>如果<span class="math inline">\(f(t)\)</span>为因果信号，即<span class="math inline">\(f(t)=f(t)u(t)\)</span>，那么： <span class="math display">\[{\mathscr  L}[\frac{ {\mathbf d}^n f(t)} { {\mathbf d}t}]=s^nF(s)\]</span> 我们看出这个形式和前面所说的”微分算子“有异曲同工之妙。这也是用拉普拉斯变换解微分方程的基础。</p></li><li><p>时域积分性质： <span class="math display">\[{\mathscr  L}[\int_{-\infty}^tf(\tau){\mathbf d}\tau]=\frac{F(s)} {s}+\frac{f^{(-1)}(0_-)} {s}\]</span></p></li></ol><h3 id="频域性质">频域性质</h3><ol type="1"><li><p>频移性质： <span class="math display">\[{\mathscr  L}[e^{s_0t}f(t)]=F(s-s_0)\]</span> 请注意和时移性质之间的区别。时间变成<span class="math inline">\(t-t_0\)</span>，乘的指数因子也是<span class="math inline">\(e^{-st_0}\)</span>，但是频域变成<span class="math inline">\(s-s_0\)</span>后，乘的指数因子却是<span class="math inline">\(e^{s_0t}\)</span>，符号不同。</p></li><li><p>频域微分性质： <span class="math display">\[{\mathscr  L}[-tf(t)]=\frac{ {\mathbf d}F(s)} { {\mathbf d}s}\]</span> 同样，注意符号。一般的，有： <span class="math display">\[{\mathscr  L}[(-t)^nf(t)]=\frac{ {\mathbf d}^nF} { {\mathbf d}s^n}\]</span></p></li><li><p>频域积分性质： <span class="math display">\[{\mathscr  L}[\frac{f(t)} {t}]=\int_s^\infty F(\lambda){\mathbf d}\lambda\]</span></p></li></ol><h3 id="其它定理">其它定理</h3><p>对于卷积运算，有卷积性质：</p><ol type="1"><li>时域卷积</li></ol><p><span class="math display">\[{\mathscr  L}[f_1(t)\bigotimes f_2(t)]=F_1(s)F_2(s)\]</span></p><ol start="2" type="1"><li>频域卷积 <span class="math display">\[{\mathscr  L}[f_1(t)f_2(t)]=\frac{1} {2\pi j}F_1(s)\bigotimes F_2(s)\]</span> 频域卷积很少用到。</li></ol><p>此外，还有终、初值定理：</p><ol type="1"><li><p>初值定理 <span class="math display">\[f(0_+)=\lim_{s\to \infty}sF(s)\]</span></p></li><li><p>终值定理 <span class="math display">\[\lim_{t\to \infty}f(t)=\lim_{s\to 0}sF(s)\]</span></p></li></ol><h2 id="常用拉普拉斯变换表">常用拉普拉斯变换表</h2><table><thead><tr class="header"><th style="text-align: center;">原函数</th><th style="text-align: center;">像函数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span>或<span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s}\)</span></td></tr></tbody></table><p>就一个？没错。因为其它的常用的基本上都能用性质推导出来。</p><ol type="1"><li><p><span class="math inline">\(t^n\)</span></p><p>由频域微分性质<span class="math inline">\({\mathscr L}[(-t)^nf(t)]=\frac{ {\mathbf d}^nF} { {\mathbf d}s^n}\)</span>，将<span class="math inline">\(f(t)=u(t),F=s^{-1}\)</span>代入，可得： <span class="math display">\[{\mathscr  L}[t^n]=\frac{n!} {s^{n+1} }\]</span></p></li><li><p><span class="math inline">\(e^{at}\)</span></p><p>由频移性质<span class="math inline">\({\mathscr L}[e^{s_0t}f(t)]=F(s-s_0)\)</span>可得： <span class="math display">\[{\mathscr  L}[e^{at}]=\frac{1} {s-a}\]</span></p></li><li><p><span class="math inline">\(t^ne^{at}\)</span></p><p>对<span class="math inline">\(t^n\)</span>的拉普拉斯变换应用频移性质，有： <span class="math display">\[{\mathscr  L}[t^n e^{at}]=\frac{n!} {(s-a)^{n+1} }\]</span></p></li><li><p><span class="math inline">\(\cos (\omega t)\)</span></p><p>由 <span class="math display">\[\cos(\omega t)=\frac{1} {2}(e^{-j\omega t}+e^{j\omega t})\]</span> 运用<span class="math inline">\(e^{at}\)</span>的拉普拉斯变换，可得 <span class="math display">\[{\mathscr  L}[\cos (\omega t)]=\frac{s} {s^2+\omega ^2}\]</span></p></li><li><p><span class="math inline">\(\sin (\omega t)\)</span></p><p>由 <span class="math display">\[\sin(\omega t)=\frac{1} {2j}(e^{j\omega t}-e^{-j\omega t})\]</span> 得 <span class="math display">\[{\mathscr  L}[\sin(\omega t)]=\frac{\omega} {s^2+\omega ^2}\]</span></p></li></ol><p>虽说如此，表格还是需要的。现归纳如下：</p><table><thead><tr class="header"><th style="text-align: center;">原函数</th><th style="text-align: center;">像函数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac 1s\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{n!} {s^{n+1} }\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s-a}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(te^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {(s-a)^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t^ne^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{n!} {(s-a)^{n+1} }\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sin (\omega t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\omega} {s^2+\omega^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\cos (\omega t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{s} {s^2+\omega^2}\)</span></td></tr></tbody></table><h2 id="多项式分式的拉普拉斯逆变换">多项式分式的拉普拉斯逆变换</h2><p>一个有理真分式形式的拉普拉斯变换式可以写成： <span class="math display">\[F(s)=\frac{N(s)} {D(s)}\]</span> 其中<span class="math inline">\(N\)</span>和<span class="math inline">\(D\)</span>都是多项式，<span class="math inline">\(D\)</span>的次数更高。接下来讲解如何计算这样的式子的拉普拉斯反变换。</p><p>基于代数方程的理论，上面的式子可以写成： <span class="math display">\[F(s)=\frac{K_1} {(s-p_1)}+\frac{K_1} {(s-p_1)}+\cdots+\frac{K_n} {(s-p_n)}\]</span> 即分解成很多小分式的和，其中<span class="math inline">\(p\)</span>为<span class="math inline">\(D\)</span>的根。多项式的根可能有单根、多重根，共轭复数根三种情况，我们来分别讨论。</p><h3 id="单根">单根</h3><p>单根对应的小分式为： <span class="math display">\[\frac{K_i} {s-p_i}\]</span> 在计算时，只需要给<span class="math inline">\(F(s)\)</span>两边同时乘以<span class="math inline">\((s-p_i)\)</span>，这样就能把这个极点消掉了，然后将<span class="math inline">\(s=p_i\)</span>代入<span class="math inline">\((s-p_i)F(s)\)</span>中（温馨提示：不要看到<span class="math inline">\((s-p_i)\)</span>乘以什么什么的形式就以为是0哦！），就能算出<span class="math inline">\(K_i\)</span>了。</p><p>这个小分式对应的原函数是<span class="math inline">\(K_ie^{p_it}\)</span>.</p><p>举例如下：</p><blockquote><p>【例】计算下式的拉普拉斯反变换 <span class="math display">\[\frac{2s^2+3s+3} {s^3+6s^2+11s+6}\]</span> 【解】首先计算极点。打开计算器，按顺序输入：<kbd>设置</kbd> <kbd>8</kbd> <kbd>2</kbd> <kbd>3</kbd>，进入求解三次多项式方程的页面。输入<kbd>1</kbd> <kbd>=</kbd> <kbd>6</kbd> <kbd>=</kbd> <kbd>1</kbd> <kbd>1</kbd> <kbd>=</kbd> <kbd>6</kbd>，将分母的多项式输入计算器。按<kbd>=</kbd>，即可得到三个根为： <span class="math display">\[-3,-1,-2\]</span> 于是<span class="math inline">\(F(s)\)</span>可以写为： <span class="math display">\[\begin{aligned}F(s)&amp;=\frac{2s^2+3s+3} {(s+1)(s+2)(s+3)}\\&amp;=\frac{K_1} {s+1}+\frac{K_2} {s+2}+\frac{K_3} {s+3}\end{aligned}\]</span> 我们看到都是单根，于是继续进行求解。</p><p>按计算器<kbd>设置</kbd> <kbd>1</kbd>返回计算模式。依次在键盘上输入<kbd>-</kbd> <kbd>1</kbd> <kbd>STO</kbd> <kbd>(-)[即A]</kbd>，屏幕上显示</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> -&gt; A<br>      <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>意思是给变量A赋值为-1.</p><p>按<kbd>AC</kbd>，在计算器上输入<span class="math inline">\((s+1)F(s)\)</span>，即： <span class="math display">\[\frac{2A^2+3A+3} {(A+2)(A+3)}\]</span> 按<kbd>=</kbd>,屏幕上的结果即为<span class="math inline">\(K_1=1\)</span></p><p>如法炮制，可以计算出<span class="math inline">\(K_2=-5,K_3=6\)</span></p><p>则原函数为 <span class="math display">\[f(t)=(e^{-t}+5e^{-2t}+6e^{-3t})u(t)\]</span></p></blockquote><h3 id="共轭复根">共轭复根</h3><p>共轭复根对应的小分式为： <span class="math display">\[\frac{K_1} {s-(a+bj)}+\frac{K_2} {s-(a-bj)}\]</span> 其中<span class="math inline">\(K_1\)</span>和<span class="math inline">\(K_2\)</span>是一对共轭复数。因为共轭复根归根结底也是单根，所以可以继续使用上面的解法来求解<span class="math inline">\(K_1,K_2\)</span>，但是只用求解其中的一个就行，因为它们共轭。假设<span class="math inline">\((a+bj)\)</span>对应的系数<span class="math inline">\(K_1=r\angle \theta=re^{i\theta}\)</span>,这对共轭复根对应的原函数为： <span class="math display">\[\begin{aligned}f(t)&amp;=re^{j\theta}e^{(a+bj)t}+re^{-j\theta}e^{(a-bj)t}\\&amp;=re^{at}(e^{j(bt+\theta)}+e^{-j(bt+\theta)})\\&amp;=2re^{at}\cos(bt+\theta)\end{aligned}\]</span></p><blockquote><p>【例】求解下式的拉普拉斯反变换： <span class="math display">\[\frac{2s+4} {s^2+2s+2}\]</span> 【解】按照上题的办法用计算器求解极点，得极点： <span class="math display">\[-1+j,-1-j\]</span> 于是原式可以写为： <span class="math display">\[\begin{aligned}F(s)&amp;=\frac{2s+4} {[s-(-1+j)][s-(-1-j)]}\\&amp;=\frac{K_1} {s-(-1+j)}+\frac{K_2} {s-(-1-j)}\end{aligned}\]</span> 下面求<span class="math inline">\(K_1\)</span>.按<kbd>设置</kbd> <kbd>2</kbd>进入复数计算模式，按<kbd>-</kbd> <kbd>1</kbd> <kbd>+</kbd> <kbd>ENG</kbd> 输入<span class="math inline">\(-1+j\)</span>，按<kbd>STO</kbd> <kbd>(-)</kbd>存入变量A中。输入 <span class="math display">\[\frac{2A+4} {A-(-1-j)}\]</span> 按<kbd>=</kbd>,屏幕上显示计算结果为<span class="math inline">\(K_1=1-j\)</span>.</p><p>按<kbd>shift</kbd> <kbd>设置</kbd> <kbd>↓</kbd> <kbd>2</kbd> <kbd>2</kbd>将复数显示切换为模长-幅角形式，屏幕上显示：<span class="math inline">\(\sqrt{2}\angle -45\)</span> ,这里的单位是度。按<kbd>shift</kbd> <kbd>设置</kbd> <kbd>2</kbd> <kbd>2</kbd>把角度单位改为弧度，屏幕上显示<span class="math inline">\(\sqrt{2}\angle -\frac{1} {4}\pi\)</span>.</p><p>那么对应的原函数为 <span class="math display">\[f(t)=2\sqrt{2}e^{-t}\cos(t-\frac{\pi} {4})u(t)\]</span></p></blockquote><h3 id="多重根">多重根</h3><p><span class="math inline">\(k\)</span>重根对应的小分式如下： <span class="math display">\[G(s)=\frac{K_1} {(s-p)^k}+\frac{K_2} {(s-p)^{k-1} }+\cdots+\frac{K_k} {s-p}\]</span> 给两边同时乘以<span class="math inline">\((s-p)^k\)</span>，有： <span class="math display">\[(s-p)^kG(s)=K_1+K_2(s-p)+\cdots +K_k(s-p)^{k-1}\]</span> 于是我们知道： <span class="math display">\[K_m=\frac{1} {(m-1)!}\frac{d^{m-1} } {ds^{m-1} }[(s-p)^kG(s)]_{s=p}\]</span> 这项对应的原函数为： <span class="math display">\[e^{pt}\left[\frac{K_1} {(k-1)!}t^{k-1}+\frac{K_2} {(k-2)!}t^{k-2}+\cdots+K_k\right]\]</span></p><blockquote><p>【例】求解下式的拉普拉斯反变换： <span class="math display">\[\frac{s^2} {(s+2)(s+1)^2}\]</span> 【解】因为题目已经帮我们因式分解好了，于是我们直接拆开： <span class="math display">\[F(s)=\frac{K_0} {s+2}+\frac{K_1} {(s+1)^2}+\frac{K_2} {s+1}\]</span> <span class="math inline">\(K_0\)</span>很容易计算，为<span class="math inline">\(4\)</span>。</p><p>对等式两端同时乘以<span class="math inline">\((s+1)^2\)</span>，有： <span class="math display">\[\frac{s^2} {s+2}=K_0\frac{(s+1)^2} {s+2}+K_1+(s+1)K_2\]</span> 将<span class="math inline">\(s=-1\)</span>代入得<span class="math inline">\(K_1=1\)</span></p><p>在计算器中输入： <span class="math display">\[\left. \frac{ {\mathbf d} } { {\mathbf d}x}\left(\frac{x^2} {x+2}\right) \right |_{x=-1}\]</span> 按等号，得<span class="math inline">\(K_2=-3\)</span>.</p><p>于是原函数为 <span class="math display">\[f(t)=(4e^{-2t}-3e^{-t}+te^{-t})u(t)\]</span></p></blockquote><h2 id="运算电路">运算电路</h2><p>运算电路说的就是在RLC电路中，通过把元件的时域<span class="math inline">\(u-i\)</span>微分方程通过拉普拉斯变换转换成代数方程然后求解的过程，其操作过程和相量法是相似的。具体来说：</p><h3 id="电阻">电阻</h3><p>形式不变，仍为<span class="math inline">\(R\)</span></p><h3 id="电容">电容</h3><p>如果电容的值为<span class="math inline">\(C\)</span>，初值条件为<span class="math inline">\(u_c(0_-)\)</span>，那么在运算电路中，电容模型变为<span class="math inline">\(\frac{1} {sC}\)</span>，并且串联一个和初值电压方向相同，值为<span class="math inline">\(\frac{1} {s}u_c(0_-)\)</span>的电压源。</p><h3 id="电感">电感</h3><p>如果电感的值为<span class="math inline">\(L\)</span>，初值条件为<span class="math inline">\(i_L(0_-)\)</span>，那么在运算电路中，电感模型变为<span class="math inline">\(Ls\)</span>，并且并联一个和初值电流方向相同的，值为<span class="math inline">\(\frac{1} {s}i_L(0_-)\)</span>的电流源。</p><h2 id="系统函数与响应的分解">系统函数与响应的分解</h2><p>在拉普拉斯变换下，系统函数有两种定义。</p><ol type="1"><li><p>基于单位冲激响应的定义： <span class="math display">\[H(s)={\mathscr L}[h(t)]=\int_{0-}^{\infty}h(t)e^{-st} {\mathbf d}t\]</span></p></li><li><p>基于一般激励的零状态响应的拉普拉斯变换<span class="math inline">\(R(s)\)</span>和激励的拉普拉斯变换<span class="math inline">\(E(s)\)</span>的比值的定义： <span class="math display">\[H(s)=\frac{R(s)} {E(s)}\]</span></p></li></ol><p>在之前的学习中，我们学过响应可以分为自由响应、强迫响应、暂态响应、稳态响应等部分，我们可以以拉普拉斯变换的视角来重新看待这些概念。</p><p>假设系统函数和输入激励只含一阶零极点，即： <span class="math display">\[H(s)=\frac{N(s)} {D(s)}=k_h\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\]</span></p><p><span class="math display">\[E(s)=k_e\frac{\prod_{l=1}^u(s-z_l)} {\prod _{k=1}^v(s-p_k)}\]</span></p><p>于是系统响应的拉普拉斯变换<span class="math inline">\(R=E\times H\)</span>为： <span class="math display">\[R(s)=k_hk_e\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\frac{\prod_{l=1}^u(s-z_l)} {\prod _{k=1}^v(s-p_k)}\]</span> 拉普拉斯逆变换，得系统的响应<span class="math inline">\(r(t)={\mathscr L}^{-1}[R(s)]\)</span>为： <span class="math display">\[r(t)=\left(\sum_{i=1}^nA_ie^{p_it}+\sum_{k=1}^vA_ke^{p_kt}\right)u(t)\]</span></p><h3 id="自由响应和强迫响应">自由响应和强迫响应</h3><p>我们可以看到，左边的求和式<span class="math inline">\(\sum_{i=1}^nA_ie^{p_it}\)</span>来自于<span class="math inline">\(H(s)\)</span>，是系统本身（的极点）决定的，对应于微分方程的齐次解。我们知道 <strong>齐次解和激励无关，所以称之为自由响应。</strong> 而<span class="math inline">\(\sum_{k=1}^vA_ke^{p_kt}\)</span>项来自于<span class="math inline">\(R(s)\)</span>，也就是微分方程的特解。我们知道 <strong>特解取决于外加激励，所以称之为强迫响应。</strong></p><h3 id="暂态响应和稳态响应">暂态响应和稳态响应</h3><p>我们将<span class="math inline">\(R(s)\)</span>的极点分成位于“左半平面”和“虚轴以及右半平面”的两类。位于左半平面的极点带来的响应会乘以一个<span class="math inline">\(e^{-at}\)</span>的系数（其中<span class="math inline">\(a&gt;0\)</span>)，因此如果时间比较长，便会近似等于<span class="math inline">\(0\)</span>。 <strong>这种左半平面的极点对应的响应是暂时的，因此称作暂态响应。</strong> 相反，位于虚轴或右半平面的极点带来的响应往往要不是<span class="math inline">\(\cos\)</span>震荡形式，要不会乘以一个<span class="math inline">\(e^{at}\)</span>的系数（其中<span class="math inline">\(a&gt;0\)</span>),这种响应 <strong>不会随着时间推移而消失，所以称为稳态响应。</strong></p><h2 id="系统框图">系统框图</h2><p>在之前的推文中其实我介绍了一种绘制系统框图的技术。现在我们来介绍一种基于拉普拉斯变换的，更简单的技术。</p><p>对于微分方程系统（<span class="math inline">\(n&gt;m\)</span>） <span class="math display">\[C_0r^{(n)}(t)+C_1r^{(n-1)}(t)+\cdots+C_nr(t)=E_0e^{(m)}(t)+E_1e^{(m-1)}(t)+\cdots+E_me(t)\]</span> 有系统函数 <span class="math display">\[H(s)=\frac{\sum_{j=0}^mE_js^{m-j} } {\sum_{i=0}^nC_is^{n-i} }\]</span> 因为我们系统框图里面一般都用积分器，所以我们也把系统函数进行一个变形（上下同除以<span class="math inline">\(s^n\)</span>）也就是把微分方程变成积分方程（方程两边进行<span class="math inline">\(n\)</span>次积分）： <span class="math display">\[H(s)=\frac{\sum_{j=0}^mE_js^{-n+m-j} } {\sum_{i=0}^nC_is^{-i} }\]</span> 这样的系统可以拆分成两个系统的级联,设置中间变量<span class="math inline">\(W(s)\)</span>： <span class="math display">\[H_1(s)=\frac{W(s)} {E(s)}=\frac 1 {\sum_{i=0}^nC_is^{-i} }\\H_2(s)=\frac{R(s)} {W(s)}=\sum_{j=0}^mE_js^{-n+m-j}\]</span> 经过变形， 有： <span class="math display">\[C_0W(s)=E(s)-W(s)\sum_{i=1}^nC_is^{-i}\\R(s)=W(s)H_2(s)\]</span> 于是框图如下所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653882298205.png" /></p><h2 id="系统幅相频特性和波特图">系统幅相频特性和波特图</h2><p>系统幅相频特性就是系统的响应随着输入信号频率的变化而变化的性质，而我们常用波特图来进行描述。波特图是一种比较特殊的绘图方式，其纵轴为<span class="math inline">\(20\lg H/\text{dB}\)</span>，横轴为<span class="math inline">\(\omega\)</span>，且横轴是对数坐标。（由于纵轴的<span class="math inline">\(\text{dB}\)</span>已经隐含了对数坐标的事实，所以其实是双对数图）</p><p>一般来说，线性时不变系统的传递函数可以写作： <span class="math display">\[H(s)=H_0\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\]</span> 其中<span class="math inline">\(\{z_1,z_2,\cdots,z_m\}\)</span>叫做系统的零点，<span class="math inline">\(\{p_1,p_2,\cdots,p_n\}\)</span>叫做系统的极点。如果一个系统稳定，那么其极点一定在左半平面，而且极点个数一定大于等于零点个数。</p><p>用<span class="math inline">\(j\omega\)</span>代替上面的<span class="math inline">\(s\)</span>，有： <span class="math display">\[H(j\omega)=H_0\frac{(j\omega-z_1)(j\omega-z_2)\cdots(j\omega-z_m)} {(j\omega-p_1)(j\omega-p_2)\cdots(j\omega-p_n)}\]</span> 取对数，因为对数可以把乘除式化为加减式，有幅频特性表达式： <span class="math display">\[\begin{aligned}20\lg H(\omega)&amp;=20\lg H_0\\&amp;+\left(20\lg \sqrt{\omega^2+z_1^2}+20\lg \sqrt{\omega^2+z_2^2}+\cdots+20\lg \sqrt{\omega^2+z_m^2}\right)\\&amp;-\left(20\lg \sqrt{\omega^2+p_1^2}+20\lg \sqrt{\omega^2+p_2^2}+\cdots+20\lg \sqrt{\omega^2+p_n^2}\right)\end{aligned}\]</span> 由于复数作积是相角相加，复数作商是相角相减，有相频表达式： <span class="math display">\[\varphi(\omega)=\tan^{-1}\left(-\frac\omega {z_1}\right )+\tan^{-1}\left(-\frac\omega {z_2}\right )+\cdots-\tan^{-1}\left(-\frac\omega {p_1}\right )-\cdots\]</span> 为表达方便，记： <span class="math display">\[\omega_z=-z,\omega_p=-p\]</span></p><h3 id="幅频波特图">幅频波特图</h3><h4 id="常数因子">常数因子</h4><p>即<span class="math inline">\(H&#39;(\omega)=K\)</span>项，有：</p><p><span class="math inline">\(20\lg H&#39;(\omega)=20\lg K\)</span>是常数</p><p><span class="math inline">\(\varphi(\omega)=0\)</span>恒为0</p><p>对应的图像如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653825965018.png" /></p><h4 id="jomega因子零零点因子"><span class="math inline">\(j\omega\)</span>因子（零零点因子）</h4><p>即<span class="math inline">\(H&#39;(\omega)=j\omega\)</span>，有：</p><p><span class="math inline">\(20\lg H&#39;(\omega)=20\lg \omega\)</span></p><p><span class="math inline">\(\varphi(\omega)=90\degree\)</span></p><p>对应的图像如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653825989648.png" /></p><h4 id="一般一阶零点因子">一般一阶零点因子</h4><p>即<span class="math inline">\(A(j\omega)=j\omega+\omega_z\)</span></p><p>可以变形为：<span class="math inline">\(A(j\omega)=\omega_z(1+\frac{j\omega} {\omega_z})\)</span></p><p>其中<span class="math inline">\(\omega_z\)</span>可以划归进常数因子，我们只需考虑<span class="math inline">\(A&#39;(\omega)=(1+j\frac{\omega} {z_i})\)</span>.有：</p><p><span class="math inline">\(20\lg A&#39;(\omega)=20\lg \sqrt{1+(\frac\omega{\omega_z})^2}\)</span></p><p><span class="math inline">\(\varphi&#39;(\omega)=\tan^{-1}\left(\frac{\omega} {\omega_z}\right)\)</span></p><p>我们观察幅频特性，它并不是一个非常容易画的函数。但是我们感性认识一下，发现它应该近似于一个线性函数。我们取零点为<span class="math inline">\(-10^1\)</span>，即<span class="math inline">\(\omega_z=10^1\)</span>，用mathematica 12绘制图像：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-number">20</span><span class="hljs-operator">*</span><span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-variable">x</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><span class="hljs-punctuation">)</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <br>  <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">100000</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826010267.png" /></p><p>我们发现它近似于一个与<span class="math inline">\(x\)</span>轴交于<span class="math inline">\(1\)</span>点，增长速度为<span class="math inline">\(20\text{dB}/\)</span>十倍频的直线。</p><p>如法炮制，绘制相频曲线：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">ArcTan</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-variable">x</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">100000</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826030142.png" /></p><p>以上两个图的横轴是<span class="math inline">\(10^x \omega_{zi}\)</span>上面的那个指数，所以你看着是<span class="math inline">\(0\)</span>的地方，其实对应的是<span class="math inline">\(1\omega_z\)</span></p><p>于是，我们可以得到近似画法：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826050805.png" /></p><h4 id="极点因子">极点因子</h4><p>即： <span class="math display">\[A(\omega)=\frac{1} {j\omega+\omega_p}\]</span></p><p>可以变形为： <span class="math display">\[A(j\omega)=\frac{1} {w_p(j\frac{\omega} {\omega_p}+1)}\]</span> 同理，<span class="math inline">\(\omega_p^{-1}\)</span>也可以划归为常数因子，则： <span class="math display">\[A&#39;(\omega)=\frac 1 {j\frac \omega {\omega_p}+1}\]</span> 有：</p><p><span class="math inline">\(20\lg A&#39;(\omega)=-20\lg \sqrt{1+(\frac{\omega} {\omega_p})^2}\)</span></p><p><span class="math inline">\(\varphi&#39;(\omega)=-\tan^{-1}(\frac{\omega} {\omega_p})\)</span></p><p>这个其实就是前面一阶零点的相反数，也就不需要再拿软件画图看性质了。这里的<span class="math inline">\(\omega_p=-p_i\)</span>.简化图如下： <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826066834.png" /></p><h4 id="作图的一般流程">作图的一般流程</h4><ol type="1"><li><p>首先求出各零、极点，将网络函数写成 <span class="math display">\[H(j\omega)=H_0\frac{(j\omega-z_1)(j\omega-z_2)\cdots(j\omega-z_m)} {(j\omega-p_1)(j\omega-p_2)\cdots(j\omega-p_n)}\]</span> 的形式。</p></li><li><p>提取各零、极点因子的常数项，把零点和极点转换成<span class="math inline">\(\omega_z,\omega_p\)</span>,把它们都变成<span class="math inline">\((1+j\frac{\omega} {\omega_z})\)</span>、<span class="math inline">\(\frac{1} {1+j\frac{\omega} {\omega_p} }\)</span>的形式。这时，有： <span class="math display">\[H(j\omega)=H(0)\frac{(1+j\frac{\omega} {\omega_{z1} })(1+j\frac{\omega} {\omega_{z2} })\cdots(1+j\frac{\omega} {\omega_{zm} })} {(1+j\frac{\omega} {\omega_{p1} })(1+j\frac{\omega} {\omega_{p2} })\cdots(1+j\frac{\omega} {\omega_{pn} })}\]</span> 其中： <span class="math display">\[H(0)=H_0\frac{\prod _{i=1}^m \omega_{zi} } {\prod_{i=1}^n \omega_{p_i} }\]</span></p></li><li><p>根据叠加原理，结合上面各个因子的图像画出波特图。</p></li></ol><h2 id="系统稳定性的判断">系统稳定性的判断</h2><p>在<strong>6.2 暂态响应和稳态响应</strong>中，我们讨论过系统零极点的位置对系统的响应的影响。即：<span class="math inline">\(H(s)\)</span>的极点如果全部位于左半平面，则系统稳定。当虚轴存在一阶零点时，称为边界稳定或者震荡稳定；当右半平面有极点，或者虚轴上有高阶极点时，称系统不稳定。</p><ol type="1"><li><p>首先基于<span class="math inline">\(H(s)=N/D\)</span>的阶次进行分析。其中<span class="math inline">\(N\)</span>是<span class="math inline">\(m\)</span>阶多项式，<span class="math inline">\(D\)</span>是<span class="math inline">\(n\)</span>阶多项式。</p><p>如果<span class="math inline">\(m&gt;n\)</span>，系统一定存在一个无穷远点处的极点。基于这个事实，有以下系统稳定的必要条件：</p><ol type="1"><li><span class="math inline">\(m\leq n\)</span>是系统稳定的必要条件</li><li><span class="math inline">\(m&gt;n+1\)</span>时，系统一定不稳定</li></ol><p>因此，我们在前面几乎只讨论<span class="math inline">\(m\leq n\)</span>的系统。</p></li><li><p>基于分母多项式的根的分布判别</p><ol type="1"><li><p>必要条件</p><ol type="1"><li><span class="math inline">\(D(s)\)</span>的所有系数都同号</li><li><span class="math inline">\(D(s)\)</span>不缺项，或者缺全部的奇次或偶次项</li></ol><p>上面两个条件是必要条件，只要任一条件不被满足，系统就不是稳定的。但是即使全部满足，系统也不一定稳定。例如： <span class="math display">\[D(s)=2s^3+s^2+3s+9\]</span></p></li><li><p>劳斯判据</p><p>劳斯判据就是列劳斯表，然后看第一列是不是全同号。劳斯表是这样列的：</p><p>前两行，第一行从前往后是<span class="math inline">\(a_n,a_{n-2},a_{n-4},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>；第二行，是<span class="math inline">\(a_{n-1},a_{n-3},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>。设劳斯表第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素是<span class="math inline">\(m_{ij}\)</span>，在第三行之后，有： <span class="math display">\[m_{ij}=-\frac{1} {m_{i-1,i} }\begin{vmatrix}m_{i-2,1} &amp; m_{i-2,j+1}\\m_{i-1,1} &amp; m_{i-1,j+1}\\\end{vmatrix}\]</span> 如果出现<span class="math inline">\(0\)</span>，那就把它替换成一个<span class="math inline">\(\varepsilon&gt;0\)</span>极小量，然后继续算。 我写了个代码来进行这个过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100+10</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">hls</span><span class="hljs-params">(<span class="hljs-type">double</span> aa, <span class="hljs-type">double</span> ab, <span class="hljs-type">double</span> ba, <span class="hljs-type">double</span> bb)</span> </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  aa ab</span><br><span class="hljs-comment">  ba bb</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> aa * bb - ab * ba;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>;<br>&#125;<br><br><span class="hljs-type">double</span> epsilon = <span class="hljs-number">0.01</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入多项式的次数：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-type">double</span> a[MAXN], lis[MAXN][MAXN];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从低到高输入系数：&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;a[i]);<br>  <span class="hljs-type">int</span> lincnt;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; (n - (<span class="hljs-number">2</span> * (j - <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span>); ++j) &#123;<br>              lis[i][j] = a[n - (<span class="hljs-number">2</span> * (j - <span class="hljs-number">1</span>))];<br>              lincnt = j;<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>              <span class="hljs-keyword">if</span> (n - (<span class="hljs-number">2</span> * j - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) lis[i][j] = a[n - (<span class="hljs-number">2</span> * j - <span class="hljs-number">1</span>)];<br>              <span class="hljs-keyword">else</span> lis[i][j] = <span class="hljs-number">0</span>;<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>              lis[i][j] = <span class="hljs-built_in">hls</span>(lis[i - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], lis[i - <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>], lis[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], lis[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) / (-lis[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(lis[i][j]) &lt; eps) &#123;<br>                  <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>                      lis[i][j] = epsilon;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  flag = <span class="hljs-number">0</span>;<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 行全为0，系统不稳定，判定结束。\n&quot;</span>, i);<br>              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>          &#125;<br><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\&quot;%d\&quot;&quot;</span>, i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%+8.2f&quot;</span>, lis[i][j]);<br>      &#125;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> f = <span class="hljs-built_in">sgn</span>(lis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sgn</span>(lis[i][<span class="hljs-number">1</span>]) != f) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 行出现异号，不稳定.\n&quot;</span>, i);<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;稳定。\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，对于<span class="math inline">\(s^4+2s^3+8s^2+3s+4\)</span>，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&quot;1&quot;   <span class="hljs-string">+1</span>.00   <span class="hljs-string">+8</span>.00   <span class="hljs-string">+4</span>.00<br>&quot;2&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+3</span>.00   <span class="hljs-string">+0</span>.00<br>&quot;3&quot;   <span class="hljs-string">+6</span>.50   <span class="hljs-string">+4</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;4&quot;   <span class="hljs-string">+1</span>.77   <span class="hljs-string">+0</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;5&quot;   <span class="hljs-string">+4</span>.00   <span class="hljs-string">-0</span>.00   <span class="hljs-string">-0</span>.00<br>稳定。<br></code></pre></td></tr></table></figure><p>对于<span class="math inline">\(2s^4+2s^3+4s^2+4s+5\)</span>，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&quot;1&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+4</span>.00   <span class="hljs-string">+5</span>.00<br>&quot;2&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+4</span>.00   <span class="hljs-string">+0</span>.00<br>&quot;3&quot;   <span class="hljs-string">+0</span>.01   <span class="hljs-string">+5</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;4&quot; <span class="hljs-string">-996</span>.00   <span class="hljs-string">+0</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;5&quot;   <span class="hljs-string">+5</span>.00   <span class="hljs-string">-0</span>.00   <span class="hljs-string">+0</span>.00<br>第 4 行出现异号，不稳定.<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数定义整理：第一弹</title>
    <link href="/2022/05/20/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <url>/2022/05/20/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p>抽象代数课程概念繁杂，而且很多概念都使用了非常非常基础的字眼（例如“群”group，不觉得这是一个在日常生活中很基础的字吗？）因此，如果对基础概念不了如指掌，做题的时候很可能连题目也看不懂。本文整理一下抽象代数里面的概念，附带很有限的批注和定理，以供速查使用。</p><span id="more"></span><h2 id="基本概念">基本概念</h2><p><strong>定义 1(代数运算)</strong> . 一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span>的映射叫做一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span> 的代数运算。其中<span class="math inline">\(A^n\)</span>到<span class="math inline">\(A\)</span>的代数运算叫做<span class="math inline">\(A\)</span>上的<span class="math inline">\(n\)</span>元 运算。</p><p>例：定义<span class="math inline">\(A=\mathbb{Z},B=\{x|x\in \mathbb{Z}\ \&amp;\ x\neq 0\},D=\mathbb{Q}\)</span>,则除法： <span class="math display">\[(a,b)\to\frac ab = a/b\]</span> 是一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span>的代数运算。但是除法并不是<span class="math inline">\(\mathbb{Q}\)</span>上的二元运算。</p><p><strong>定义 2 (结合律)</strong>. 我们说一个<span class="math inline">\(A\)</span>上的代数运算<span class="math inline">\(\circ\)</span>适合结合律， 假如对于<span class="math inline">\(A\)</span>中的任意三个元<span class="math inline">\(a,b,c\)</span>，都有 <span class="math display">\[(a\circ b)\circ c=a\circ (b\circ c)\]</span> 其中<span class="math inline">\(a,b,c\)</span>不一定不相同。</p><p><strong>定义 3 (连算)</strong>. 假如对于<span class="math inline">\(A\)</span>的不少于<span class="math inline">\(2\)</span>个固定的元<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，对于下列的符号 <span class="math display">\[a_1\circ a_2 \circ \cdots a_n\]</span> 的任意一种加括号的方式<span class="math inline">\(\pi_i(a_1\circ a_2 \circ \cdots a_n)\)</span>都相等， 那么我们就把这些所有的<span class="math inline">\(\pi_i\)</span>用 <span class="math display">\[a_1\circ a_2 \circ \cdots a_n\]</span> 来表示， 叫做连算。</p><p>事实上，如果<span class="math inline">\(\circ\)</span>适合结合律，那么连算就存在。</p><p><strong>定义 4 (交换律)</strong>. 我们说一个<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(D\)</span>的代数运算<span class="math inline">\(\circ\)</span>适合交换律， 假如对于<span class="math inline">\(A\)</span>上的任意两个元<span class="math inline">\(a,b\)</span>，有： <span class="math display">\[a\circ b=b\circ a\]</span></p><p>事实上，如果<span class="math inline">\(\circ\)</span>同时适合交换律和结合律，那么连算式中 的元顺序就可以任意交换。</p><p><strong>定义 5 (分配律)</strong>. 对于<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span></p><p><span class="math inline">\(\bigotimes\)</span>是一个<span class="math inline">\(B\times A\)</span>到<span class="math inline">\(A\)</span>的代数运算。</p><p><span class="math inline">\(\bigoplus\)</span>是一个<span class="math inline">\(A\)</span>的代数运算。</p><p>假如对于<span class="math inline">\(B\)</span>的任意<span class="math inline">\(b\)</span>，<span class="math inline">\(A\)</span>的任意<span class="math inline">\(a_1,a_2\)</span>来说：</p><ol type="1"><li><p>有左分配律：假如 <span class="math display">\[b\bigotimes(a_1\bigoplus a_2)=(b\bigotimes a_1)\bigoplus(b\bigotimes a_2)\]</span></p></li><li><p>有右分配律：假如 <span class="math display">\[(a_1\bigoplus a_2)\bigotimes b=(a_1 \bigotimes b)\bigoplus(a_2 \bigotimes b )\]</span></p></li></ol><p><strong>定义 6 (满射)</strong>. 若是在一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>下，<span class="math inline">\(\bar{A}\)</span>的 每一个元都至少是<span class="math inline">\(A\)</span>中某一个元的象，那么<span class="math inline">\(\phi\)</span>叫做一个<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的 满射。</p><p>例如，<span class="math inline">\(f(x)=\sin(x)\)</span>就不是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的满射，因为不存在<span class="math inline">\(x\in \mathbb{R},f(x)=2\)</span> 但是，<span class="math inline">\(f(x)=\ln(x)\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的满射。</p><p><strong>定义 7 (单射)</strong>. 一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>，假如 <span class="math display">\[a\neq b\to \bar{a}\neq \bar{b}\]</span> 那么<span class="math inline">\(\phi\)</span>是一个单射。</p><p>例如，<span class="math inline">\(f(x)=x^2\)</span>就不是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的单射，因为<span class="math inline">\(1\neq -1\)</span>但是<span class="math inline">\(f(1)=f(-1)\)</span>. 但是，<span class="math inline">\(f(x)=e^x\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的单射。</p><p><strong>定义 8(一一映射)</strong> . 如果集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>既是满射又是单射，那么它就是一一映射。 一一映射的逆是一个<span class="math inline">\(\bar{A}\to A\)</span>的一一映射，用<span class="math inline">\(\phi^{-1}\)</span>表示。</p><p>例如，<span class="math inline">\(f(x)=x^3\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的一一映射。</p><p><strong>定义 9 (变换)</strong>. 一个<span class="math inline">\(A\to A\)</span>的映射叫做变换。</p><p><strong>定义 10 (同态映射)</strong>. 一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>叫做对于代数运算 <span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>的同态映射，假如在<span class="math inline">\(\phi\)</span>之下， 对于<span class="math inline">\(\forall a,b \in A\)</span>，只要 <span class="math display">\[a\to \bar{a},b\to \bar{b}\]</span> 就有。 <span class="math display">\[a\circ b\to \bar{a}\bar{\circ}\bar{b}\]</span> 如果<span class="math inline">\(\phi\)</span>还是个满射，那么就叫做同态满射。</p><p><strong>定义 11 (同构映射)</strong>. 如果一个同态满射还是一一映射，那么它就是同构映射。 如果<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同构，记作： <span class="math display">\[A\cong \bar{A}\]</span></p><p>事实上，如果对于<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>来说，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同构， 那么我们可以说，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>这两个集合对于这两个运算来说除了名字 以外没有区别。</p><p><strong>定义 12 (自同构)</strong>. 对于<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\circ\)</span>来说的一个<span class="math inline">\(A\to A\)</span>的同构映射称为一个对于<span class="math inline">\(\circ\)</span>来说的<span class="math inline">\(A\)</span>的自同构。</p><p><strong>定义 13 (关系)</strong>. 一个<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(\{T,F\}\)</span>的映射<span class="math inline">\(R\)</span>称作<span class="math inline">\(A\)</span>的元 之间的一个关系。如果<span class="math inline">\(R(a,b)=T\)</span>，那么称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>符合 这个关系，记作：<span class="math inline">\(aRb\)</span></p><p><strong>定义 14 (等价关系)</strong>. 如果关系<span class="math inline">\(\sim\)</span>满足以下三点：</p><ol type="1"><li><p><span class="math inline">\(\forall a\in A,a\sim a\)</span></p></li><li><p><span class="math inline">\(\forall a,b\in A,a\sim b\to b\sim a\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in A,a\sim b\wedge b\sim c\to a\sim c\)</span></p></li></ol><p>那么称这个关系为等价关系。</p><p>常见的等价关系有：等于、同余、矩阵相似、矩阵合同等。</p><p><strong>定义 15(分类)</strong> . 如果把集合<span class="math inline">\(A\)</span>分成若干个称作类的子集，使得A的每个元属于且仅属于一个 类，那么这些类的全体叫做集合<span class="math inline">\(A\)</span>的一个分类。</p><p>集合的一个分类决定了集合的元之间的一个等价关系。 集合的元之间的一个等价关系决定了集合的一个分类。</p><p><strong>定义 16 (代表和代表团)</strong>. 假如有一个集合的一个分类，那么一个类里面的任意一个元 叫做这个类的一个代表，由每个类的一个代表组成的集合叫做这个集合 的代表团。</p><h2 id="群论">群论</h2><p><strong>定义 17 (群的第一定义)</strong>. 一个不空集合<span class="math inline">\(G\)</span>和一个叫做乘法的代数运算组成的结构叫做一个群，如果：</p><ol type="1"><li><p>*<span class="math inline">\(\forall a,b\in G,ab\in G\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in G,a(bc)=(ab)c\)</span></p></li><li><p><span class="math inline">\(\forall a,b \in G,\exists x,y\in G\ {\mathbf s.t.} ax=b\wedge ya=b\)</span></p></li></ol><p><strong>定义 18 (群的第二定义)</strong>. 一个不空集合<span class="math inline">\(G\)</span>和一个叫做乘法的代数运算组成的结构叫做一个群，如果：</p><ol type="1"><li><p><span class="math inline">\(\forall a,b\in G,ab\in G\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in G,a(bc)=(ab)c\)</span></p></li><li><p><span class="math inline">\(\exists e\in G ,\forall a\in G,ea=a\)</span>,这个<span class="math inline">\(e\)</span>叫做左单位元</p></li><li><p><span class="math inline">\(\forall a\in G, \exists a^{-1}\in G,a^{-1}a=e\)</span></p></li></ol><p><strong>定义 19 (群的阶)</strong>. 一个元素有限的群叫做有限群，一个元素无限的群叫做无限群。 有限群元的个数叫做群的阶。</p><p><strong>定义 20 (交换群)</strong>. 如果<span class="math inline">\(\forall a,b\in G,ab=ba\)</span>，那么群<span class="math inline">\((G,\cdot)\)</span>称为交换群，也叫阿贝尔群。</p><p><strong>定义 21 (单位元)</strong>. 一个群<span class="math inline">\(G\)</span>的<strong>唯一</strong>能使 <span class="math display">\[ea=ae=e\]</span> 的元叫做群<span class="math inline">\(G\)</span>的单位元。</p><p><strong>定义 22 (逆元)</strong>. 对于群<span class="math inline">\(G\)</span>的每一个元<span class="math inline">\(a\)</span>，<span class="math inline">\(G\)</span>中存在<strong>唯一</strong>的一个元<span class="math inline">\(a^{-1}\)</span>， 使得 <span class="math display">\[a^{-1}a=aa^{-1}=e\]</span> 这个<span class="math inline">\(a^{-1}\)</span>叫做群<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的逆元。</p><p><strong>定义 23 (群中元素的阶）</strong>. 对于群<span class="math inline">\(G\)</span>中的一个元素<span class="math inline">\(a\)</span>,能够使得 <span class="math display">\[a^m=e\]</span> 的最小的正整数<span class="math inline">\(m\)</span>称作<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的阶。如果 不存在这样的<span class="math inline">\(m\)</span>，那么称元素<span class="math inline">\(a\)</span>的阶为无穷大。</p><p>例如：</p><ol type="1"><li><p>对于群<span class="math inline">\((\mathbb{R}+,\times)\)</span>,<span class="math inline">\(1\)</span>的阶为<span class="math inline">\(1\)</span>，其余每个元素的阶为<span class="math inline">\(\infty\)</span>.</p></li><li><p>对于群<span class="math inline">\((\{x|x^3=1,x\in \mathbb{C}\},\times)\)</span>,<span class="math inline">\(1\)</span>的阶为<span class="math inline">\(1\)</span>，其余元素的阶为<span class="math inline">\(3\)</span>.</p></li></ol><p><strong>定理 1 (消去律)</strong>. 一个群的乘法适合消去律： <span class="math display">\[\begin{cases}            ax=ax&#39; \to x=x&#39;\\            ya=y&#39;a \to y=y&#39;\\        \end{cases}\]</span></p><p><strong>定义 24 (有限群的另一定义)</strong>. 一个乘法和一个有限集合构成一个群，假如"封闭性"、"结合律"和"消去律"能被满足。</p><p><strong>定义 25 (变换群)</strong>. 首先我们用一种特殊的记法来表示变换： <span class="math display">\[\tau : a\to a&#39;=a^\tau\]</span> 我们把一个集合的所有变换放到一个集合里： <span class="math display">\[S=\{\tau,\lambda,\mu,\cdots\}\]</span> 看这个集合中的两个元<span class="math inline">\(\tau,\lambda\)</span>： <span class="math display">\[t:a\to a^\tau,\lambda:a\to a^\lambda\]</span> 于是给了一个元<span class="math inline">\(a\)</span>，我们可以得出一个唯一的元<span class="math inline">\((a^\tau)^\lambda\)</span>. 我们规定变换的乘积： <span class="math display">\[\tau\lambda : a\to (a^\tau)^\lambda=a^{\tau\lambda}\]</span> 那么一个集合<span class="math inline">\(A\)</span>的若干个一一变换对于上述规定的乘法作成的群叫做<span class="math inline">\(A\)</span>的一个变换群。</p><p>事实上，任何一个群都和一个变换群同构，任意一个抽象的群都能在变换群中找到一个具体的例子。</p><p><strong>定义 26 (置换)</strong>. 一个有限集合的一个一一变换叫做一个置换。</p><p><strong>定义 27(对称群)</strong> . 一个包含<span class="math inline">\(n\)</span>个元的集合的全体置换作成的群叫做<span class="math inline">\(n\)</span>次对称群，记作：<span class="math inline">\(S_n\)</span>.</p><p><strong>定义 28 (<span class="math inline">\(k\)</span>-循环置换)</strong>. <span class="math inline">\(S_n\)</span>中的一个把<span class="math inline">\(a_{i_1}\)</span>变到<span class="math inline">\(a_{i_2}\)</span>,把<span class="math inline">\(a_{i_2}\)</span>变到<span class="math inline">\(a_{i_3}\)</span>,<span class="math inline">\(\cdots\)</span> ,把<span class="math inline">\(a_{i_k}\)</span>变到<span class="math inline">\(a_{i_1}\)</span>，而使其它元不变的置换，叫做<span class="math inline">\(k\)</span>-循环置换。这样的 循环置换可以用以下<span class="math inline">\(k\)</span>个符号同时表示： <span class="math display">\[(i_1i_2\cdots i_k),(i_2i_3\cdots i_ki_1),\cdots (i_ki_1\cdots i_{k-1})\]</span></p><p>事实上，每个<span class="math inline">\(n\)</span>元置换<span class="math inline">\(\pi\)</span>都能写成若干个没有重复数字的循环置换的乘积。 事实上，每个有限群都和一个置换群同构。</p><p><strong>定义 29 (循环群)</strong>. 如果一个群<span class="math inline">\(G\)</span>的每一个元都是其中某一个固定元<span class="math inline">\(a\)</span>的乘方，那么 我们把<span class="math inline">\(G\)</span>叫做循环群，并用符号<span class="math inline">\(G=(a)\)</span>来表示，其中<span class="math inline">\(a\)</span>叫做<span class="math inline">\(G\)</span>的生成元。</p><p>其实<span class="math inline">\(G\)</span>的构造完全由<span class="math inline">\(a\)</span>的阶数<span class="math inline">\(n\)</span>决定。如果有限，那么<span class="math inline">\(G\)</span>同构于整数加群，否则 同构于模<span class="math inline">\(n\)</span>剩余类加群。</p><p><strong>定义 30 (子群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子集<span class="math inline">\(H\)</span>叫做<span class="math inline">\(G\)</span>的一个子群，假如 <span class="math inline">\(H\)</span>对于<span class="math inline">\(G\)</span>的乘法来说也构成一个群。</p><p><strong>定义 31 (陪集)</strong>. 对于一个群<span class="math inline">\(G\)</span>和它的一个子群<span class="math inline">\(H\)</span>,我们规定一个关系<span class="math inline">\(\sim\)</span>: <span class="math display">\[a\sim b \leftrightarrow ab^{-1}\in H\]</span> 那么由上述等价关系<span class="math inline">\(\sim\)</span>所决定的类叫做子群<span class="math inline">\(H\)</span>的右陪集，记作： <span class="math inline">\(Ha\)</span>，它刚好包含所有能写成 <span class="math inline">\(ha (h\in H)\)</span> 的<span class="math inline">\(G\)</span>的元。</p><p>如果把等价关系的定义换成： <span class="math display">\[a\sim b \leftrightarrow b^{-1}a\in H\]</span> 包含元<span class="math inline">\(a\)</span>的陪集叫做左陪集，用<span class="math inline">\(aH\)</span>表示。</p><p><strong>定义 32 (指数)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(H\)</span>的右陪集或左陪集（事实上，这俩一定相等）的个数 叫做<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>里的指数。</p><p><strong>定义 33 (不变子群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(N\)</span>叫做<span class="math inline">\(G\)</span>的不变子群，有：<span class="math inline">\(\forall a\in G,Na=aN\)</span></p><p>一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(N\)</span>是不变子群的充分必要条件是：<span class="math inline">\(\forall a\in G,n\in N \to ana^{-1}\in N\)</span></p><p><strong>定义 34 (中心)</strong>. 如果<span class="math inline">\(N\)</span>包含<span class="math inline">\(G\)</span>中所有有以下性质的元<span class="math inline">\(n\)</span>: <span class="math display">\[\forall a\in G,na=an\]</span> 那么<span class="math inline">\(N\)</span>是<span class="math inline">\(G\)</span>的一个不变子群。这个不变子群叫做中心。</p><p>简言之：中心和<span class="math inline">\(G\)</span>的每个元素可交换。</p><p><strong>定义 35 (商群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个不变子群<span class="math inline">\(N\)</span>的陪集作成的集合<span class="math inline">\(S\)</span>对于集合乘法构成一个群， 这个群叫做商群，记作<span class="math inline">\(G/N\)</span>.这里的"乘法"，指的是： <span class="math inline">\((xN)(yN)=(xy)N\)</span></p><p>一个群<span class="math inline">\(G\)</span>和它的每一个商群同态。</p><p><strong>定义 36 (核)</strong>. 如果<span class="math inline">\(\phi\)</span>是群<span class="math inline">\(G\)</span>到<span class="math inline">\(\bar{G}\)</span>的同态满射，那么<span class="math inline">\(\bar{G}\)</span> 的单位元<span class="math inline">\(\bar{e}\)</span>在<span class="math inline">\(\phi\)</span>下的所有逆象称为同态满射<span class="math inline">\(\phi\)</span>的核。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于微分方程和系统框图的那些事</title>
    <link href="/2022/05/18/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/05/18/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>昨天做了做作业，发现有通过系统框图写微分方程、和通过微分方程画系统框图这两种题目。初看完全摸不着头脑，但是只要把握<span class="math inline">\(LTI\)</span>系统的性质就很简单了。</p><span id="more"></span><h2 id="怎么通过系统框图写微分方程">怎么通过系统框图写微分方程？</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837378264.png" /></p><p>我们很容易想到，首先设一个中间变量<span class="math inline">\(x(t)\)</span>，这里我把<span class="math inline">\(x(t)\)</span>放在第二个积分器和<span class="math inline">\(\frac{1}{2}\)</span>倍乘器中间。那么两个积分器之间的信号就是<span class="math inline">\(x&#39;(t)\)</span>，第一个积分器前的信号就是<span class="math inline">\(x&#39;&#39;(t)\)</span>，根据两个累加器，我们可以列出方程： <span class="math display">\[\begin{cases}r(t)=-\frac{3}{2}x&#39;(t)+\frac{1}{2}x(t)\\e(t)+\frac{3}{8}x(t)-\frac{1}{4}x&#39;(t)=x&#39;&#39;(t)\end{cases}\]</span> 整理得： <span class="math display">\[\begin{cases}r(t)=-\frac{3}{2}x&#39;(t)+\frac{1}{2}x(t)\\e(t)=-\frac{3}{8}x(t)+\frac{1}{4}x&#39;(t)+x&#39;&#39;(t)\end{cases}\]</span> 那然后怎么消掉<span class="math inline">\(x(t)\)</span>呢？有人说，线性变换，加加减减就行了呀。没错，非常正确，但是我算不出来。我想了一想，发现了一种方法，可以立刻就把微分方程写出来：只需要把第<span class="math inline">\(2\)</span>个式子右边的<span class="math inline">\(&#39;x&#39;\)</span>统一换成<span class="math inline">\(&#39;r&#39;\)</span>，写在等号左边，然后把第<span class="math inline">\(1\)</span>个式子右边的<span class="math inline">\(&#39;x&#39;\)</span>统一换成<span class="math inline">\(&#39;e&#39;\)</span>，写在等号的右边，就大功告成啦！对这个题来说，就是： <span class="math display">\[r&#39;&#39;(t)+\frac{1}{4}r&#39;(t)-\frac{3}{8}r(t)=-\frac{3}{2}e&#39;(t)+\frac{1}{2}e(t)\]</span> 这么简单么？只替换两个字符就行了？为啥啊？其实，这利用了<span class="math inline">\(LTI\)</span>系统的性质。</p><p>我们把第二个式子也看作一个线性系统，输入<span class="math inline">\(e(t)\)</span>，输出<span class="math inline">\(x(t)\)</span>。那么如果我们把输入改为 <span class="math display">\[\frac{1}{2}e(t)-\frac{3}{2}e&#39;(t)\]</span> 此时这个小系统的输出是什么呢？显然，是 <span class="math display">\[\frac{1}{2}x(t)-\frac{3}{2}x&#39;(t)\]</span> 这是什么呢？结合方程组第一个式子，我们发现这就是<span class="math inline">\(r(t)\)</span>。</p><p>对于第二个式子所代表的,输入<span class="math inline">\(e\)</span>输出<span class="math inline">\(x\)</span>的系统 <span class="math display">\[e(t)=-\frac{3}{8}x(t)+\frac{1}{4}x&#39;(t)+x&#39;&#39;(t)\]</span> 现在我们输入了<span class="math inline">\(\frac{1}{2}e(t)-\frac{3}{2}e&#39;(t)\)</span>,输出了<span class="math inline">\(r(t)\)</span>，那么填进去，就有： <span class="math display">\[r&#39;&#39;(t)+\frac{1}{4}r&#39;(t)-\frac{3}{8}r(t)=-\frac{3}{2}e&#39;(t)+\frac{1}{2}e(t)\]</span> 完毕。</p><h2 id="怎么通过微分方程画系统框图">怎么通过微分方程画系统框图</h2><p>例如： <span class="math display">\[r&#39;&#39;(t)+5r&#39;(t)+6r(t)=9e&#39;(t)+5e(t)\]</span> 这个系统相对来说还是比较复杂的。我们遵循上一部分的思路，逆过来思考。</p><ol type="1"><li><p>设<span class="math inline">\(x(t)\)</span>是系统输入为<span class="math inline">\(e(t)\)</span>时的输出，即： <span class="math display">\[x&#39;&#39;(t)+5x&#39;(t)+6x(t)=e(t)\]</span></p></li><li><p>这时由于<span class="math inline">\(LTI\)</span>系统的线性时不变性质（把上面那个式子右边的<span class="math inline">\(e(t)\)</span>变成<span class="math inline">\(9e&#39;(t)+5e(t)\)</span>），有： <span class="math display">\[r(t)=9x&#39;(t)+5x(t)\]</span></p></li><li><p>把1.中的式子进行一个移项，变成： <span class="math display">\[x&#39;&#39;(t)=e(t)-5x&#39;(t)-6x(t)\]</span></p></li><li><p>现在可以开始画图了。因为是二阶系统，所以先画2个积分器，标上<span class="math inline">\(x(t)\)</span>,再画上加法器</p></li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837311836.png" /></p><ol start="5" type="1"><li>我们知道加法器是等号的来源，把上面两个等式画上去，就完成啦。</li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837321749.png" /></p><p>好了，现在你已经是系统框图大师啦！</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种基于纯C语言的函数绘图解决方案</title>
    <link href="/2022/05/16/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BA%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/05/16/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BA%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>本文尝试实现一种利用C语言绘制函数图像的方法。最终输出为PPM格式图片。 <span id="more"></span></p><h2 id="一ppm图片格式">一、PPM图片格式</h2><p>我们首先来看一下我们的问题：怎么用纯C语言写一个<code>plot()</code>函数。那么我们迎面而来遇到的第一个问题就是：我们平常使用的C语言，往往是在一个黑框框里面输入一堆数字，然后输出一堆数字，而现在却要展示一张图片，这怎么做呢？但是我们静下心来想一想，就会发现所谓的图片实际上也是文件，而文件就是可以用C语言的<code>freopen</code>读写的。但是我们平时读写的都是纯文本文件，现在却要写入一张图片文件。怎么做到呢？这时就需要一种非常简单的图片编码：PPM格式。</p><p>PPM格式是 Netpbm <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Netpbm#File_formats">[1]</span></a></sup>的一部分。这个项目使用和定义了几种图形格式。便携式像素映射格式（PPM）、便携式灰图格式（PGM） 和便携式位图格式（PBM） ，旨在便于在平台之间交换。</p><p>一个PPM文件由两部分组成，即文件头和数据流。文件头的第一部分是一个Magic Number，格式为<code>P%d</code>，表示了文件的类型，具体如下表所示：</p><table><thead><tr class="header"><th>类型</th><th>ASCII （普通）</th><th><strong>二进制（原始）</strong></th></tr></thead><tbody><tr class="odd"><td>便携式位图（PBM）</td><td>P1</td><td>P4</td></tr><tr class="even"><td>便携式灰度图（PGM）</td><td>P2</td><td>P5</td></tr><tr class="odd"><td>便携式像素映像（PPM）</td><td>P3</td><td>P6</td></tr></tbody></table><p>文件头的第二部分是两个数字，表示了图像的宽度和高度。</p><p>而PGM和PPM文件的文件头有第三部分，是一个数字，表示颜色（分量）的最大值。</p><p>数据流部分是以矩阵形式显示的像素点。接下来我们看几个例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">P1</span><br><span class="hljs-comment"># This is an example bitmap of the letter &quot;J&quot;</span><br><span class="hljs-attribute">6</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669222979.png" alt="123" /><figcaption aria-hidden="true">123</figcaption></figure><p>这是一个PBM（位图）格式的文件，其中0表示白色，1表示黑色。显示成图片的话是这个样子（放大了20倍）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">P2</span><br><span class="hljs-comment"># Shows the word &quot;FEEP&quot; (example from Netpbm man page on PGM)</span><br><span class="hljs-attribute">24</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">15</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个一个PGM（灰度图）的例子，我们可以看到第四行，这就是所谓“颜色（分量）的最大值”。它对应的图片是这个样子（当然也经过了放大）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669278002.png" /></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">P3           <span class="hljs-comment"># &quot;P3&quot; means this is a RGB color image in ASCII</span><br>3<span class="hljs-number"> 2 </span>         <span class="hljs-comment"># &quot;3 2&quot; is the width and height of the image in pixels</span><br>255          <span class="hljs-comment"># &quot;255&quot; is the maximum value for each color</span><br><span class="hljs-comment"># The part above is the header</span><br><span class="hljs-comment"># The part below is the image data: RGB triplets</span><br>255  <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># red</span><br> <span class="hljs-number"> 0 </span>255  <span class="hljs-number"> 0 </span> <span class="hljs-comment"># green</span><br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span>255  <span class="hljs-comment"># blue</span><br>255<span class="hljs-number"> 255 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># yellow</span><br>255<span class="hljs-number"> 255 </span>255  <span class="hljs-comment"># white</span><br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># black</span><br></code></pre></td></tr></table></figure><p>这是一个PPM图片的例子，我们可以看到每个像素点使用了三个数字来指定颜色，也就是我们所说的RGB。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669396133.png" /></p><p>到这里，你应该已经掌握了PPM格式图片怎么写了吧！</p><h2 id="二定义函数表">二、定义函数表</h2><p>为了方便绘图，首先我们定义PPM数据类型，由RGB三个颜色分量组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br></code></pre></td></tr></table></figure><p>这个结构体的构造函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span>;<br></code></pre></td></tr></table></figure><p>主要执行绘图功能的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span>;<br></code></pre></td></tr></table></figure><p>其中各参数的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>char *name</code></td><td>输出文件的文件名</td></tr><tr class="even"><td><code>PPMdata **matrix</code></td><td>PPM文件流矩阵，大小至少为height*width</td></tr><tr class="odd"><td><code>const double *x</code></td><td>采样点x坐标</td></tr><tr class="even"><td><code>double *y</code></td><td>采样点y坐标</td></tr><tr class="odd"><td><code>int width</code></td><td>整个图像的宽度 单位：像素</td></tr><tr class="even"><td><code>int height</code></td><td>整个图像的高度 单位：像素</td></tr><tr class="odd"><td><code>int arrayLen</code></td><td>采样点的数目</td></tr><tr class="even"><td><code>double centerX</code></td><td>图片中心点对应的直角坐标X</td></tr><tr class="odd"><td><code>double centerY</code></td><td>图片中心点对应的直角坐标Y</td></tr><tr class="even"><td><code>double rangeX</code></td><td>X直角坐标范围</td></tr><tr class="odd"><td><code>double rangeY</code></td><td>Y直角坐标范围</td></tr><tr class="even"><td><code>double gridX</code></td><td>X网格宽度（单位：直角坐标）</td></tr><tr class="odd"><td><code>double gridY</code></td><td>Y网格宽度（单位：直角坐标）</td></tr></tbody></table><p>将直角坐标量转化为像素量（矩阵下标量）的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span>;<br></code></pre></td></tr></table></figure><p>其中各参数的意义为：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>double num</code></td><td>待转换的直角坐标量x</td></tr><tr class="even"><td><code>double center</code></td><td>图片该方向中心点对应的直角坐标c</td></tr><tr class="odd"><td><code>double range</code></td><td>该方向直角坐标范围r</td></tr><tr class="even"><td><code>int picLen</code></td><td>图片该方向的像素大小p</td></tr></tbody></table><p>转换公式为： <span class="math display">\[p\left(\frac 12+\frac{x-c}{r}\right)\]</span> 在图像上绘制坐标点的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span><br></code></pre></td></tr></table></figure><p>各新参数的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>int x</code></td><td>要绘制的点的像素X坐标</td></tr><tr class="even"><td><code>int y</code></td><td>要绘制的点的像素Y坐标</td></tr><tr class="odd"><td><code>PPMdata color</code></td><td>颜色</td></tr><tr class="even"><td><code>int size</code></td><td>点的大小，最后绘制出来是一个<span class="math inline">\(2size+1\)</span>边长的正方形</td></tr></tbody></table><p>将<code>PPMdata</code>数据矩阵转换为<code>.ppm</code>图像文件的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName,PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br></code></pre></td></tr></table></figure><p>没有新的参数。</p><p>由于绘图时采用分段线性拟合算法，定义线性函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br></code></pre></td></tr></table></figure><p>这个定义的意思是：<span class="math inline">\(y=\text{linerFunc}(x_1,y_1,x_2,y_2,x)\)</span>表示一条经过<span class="math inline">\((x_1,y_2)\)</span>和<span class="math inline">\((x_2,y_2)\)</span>，以<span class="math inline">\(x\)</span>为自变量的直线。直线方程为： <span class="math display">\[y=(x-x_1)\frac{y_2-y_1}{x_2-x_1}+y_1\]</span></p><h2 id="三实现函数">三、实现函数</h2><p>这部分以<code>arrayToPPM()</code>函数的实现为主线，完整介绍各个函数的实现方法。</p><h3 id="第一步检测数据的合法性">第一步，检测数据的合法性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: X is not increasing.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: X out of range.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br>        <span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，为了方便，我们强制把像素大小设置为偶数。然后主要检查三个事：</p><ol type="1"><li><span class="math inline">\(x\)</span>坐标是否严格单调递增。若不是，返回错误并退出。</li><li><span class="math inline">\(x\)</span>坐标是否在范围内。若不是，返回错误并退出。</li><li><span class="math inline">\(y\)</span>坐标是否在范围内。若不是，强制将其设置在范围内。</li></ol><h3 id="第二步定义ppmdata颜色">第二步，定义PPMdata颜色。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">PPMdata background, axis, grid, line;<br>background = makePPMdata(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = makePPMdata(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = makePPMdata(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = makePPMdata(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br></code></pre></td></tr></table></figure><p>各变量的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>background</code></td><td>背景颜色</td></tr><tr class="even"><td><code>axis</code></td><td>主坐标轴颜色</td></tr><tr class="odd"><td><code>grid</code></td><td>网格颜色</td></tr><tr class="even"><td><code>line</code></td><td>要画的函数的颜色</td></tr></tbody></table><p>这里就用配色软件找一个好看的颜色就行。</p><h3 id="第三步绘制背景板">第三步，绘制背景板</h3><ol type="1"><li><p>画背景</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>        matrix[i][j] = background;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>画网格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br>        drawPoint(matrix, width, height, numToMatPos(centerX + i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>        drawPoint(matrix, width, height, numToMatPos(centerX - i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//纵向网格</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>        drawPoint(matrix, width, height, j, numToMatPos(centerY + i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>        drawPoint(matrix, width, height, j, numToMatPos(centerY - i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//横向网格</span><br></code></pre></td></tr></table></figure></li><li><p>画主坐标轴</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br>    drawPoint(matrix, width, height, i, height / <span class="hljs-number">2</span>, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>    drawPoint(matrix, width, height, width / <span class="hljs-number">2</span>, i, axis, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的“主坐标轴”，恒定位于图像的正中心。</p></li></ol><p>这里涉及到了<code>drawPoint()</code>函数。它的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br>            <span class="hljs-type">int</span> u = x + i, v = y + j;<br>            <span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">else</span> matrix[v][u] = color;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要还是要检测是不是越界了，不然容易<code>RE</code>.还有一个需要注意的地方就是第6行，这里的x和y互换了。为什么要互换呢？我们想一想矩阵下标的顺序和坐标的顺序有什么区别就好了。</p><h3 id="第四步画函数">第四步，画函数</h3><p>我们经过了这么长的准备，终于要开始画函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> stepX = rangeX / width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> X = centerX - rangeX / <span class="hljs-number">2</span>; X &lt; centerX + rangeX / <span class="hljs-number">2</span>; X += stepX) &#123;<br>    <span class="hljs-type">int</span> linerIndex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (X &lt; x[i]) &#123;<br>            linerIndex = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (linerIndex == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">double</span> u, v, Y;<br>        u = numToMatPos(X, centerX, rangeX, width);<br>        Y = linerFunc(x[linerIndex], y[linerIndex], x[linerIndex + <span class="hljs-number">1</span>], y[linerIndex + <span class="hljs-number">1</span>], X);<br>        v = numToMatPos(Y, centerY, rangeY, height);<br>        drawPoint(matrix, width, height, u, v, line, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然我们用的是分段线性拟合法，那么就要确认当前在哪个段里，也就是代码中的<code>linerIndex</code>变量。</p><p><code>X</code>就是枚举变量。如果当前比<code>x[]</code>数列中的最小值还小，那么不应该有图像，否则找到当前所在的段，然后画一条线段。</p><h3 id="第五步写文件">第五步，写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">matToPPM(name, matrix, width, height);<br></code></pre></td></tr></table></figure><p>这里<code>matToPPM</code>函数的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>    freopen(fileName, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    fclose(<span class="hljs-built_in">stdout</span>);<br>    freopen(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是重定向，输出，再重定向回来，没什么特别值得说明的。</p><h2 id="四试用一下">四、试用一下</h2><p>我们把上面那一堆函数和实现打包到一个<code>.h</code>文件里。然后我们写个代码调用一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> x[<span class="hljs-number">1001</span>], y[<span class="hljs-number">1001</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.1</span>) &#123;<br>        x[cnt] = i;<br>        y[cnt] = <span class="hljs-built_in">sin</span>(i*<span class="hljs-number">2.0</span>)/(i*<span class="hljs-number">2.0</span>);<br>        ++cnt;<br>    &#125;<br>    <span class="hljs-comment">//创建matrix 矩阵</span><br>    PPMdata **matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PPMdata *) * <span class="hljs-number">1080</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1080</span>; i++) <br>        matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1920</span>, <span class="hljs-keyword">sizeof</span>(PPMdata));<br>    <span class="hljs-type">char</span> c[]=<span class="hljs-string">&quot;out.ppm&quot;</span>;<br>    arrayToPPM(c, matrix, x, y, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3.14159</span>/<span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;complete.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码的功能是绘制 <span class="math display">\[y=\frac{\sin 2x}{2x}\]</span> 的图像。</p><p>编译运行，在目录下输出了一个<code>out.ppm</code>文件，打开：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669362308.png" /></p><p>大功告成咯！</p><h2 id="五更多讨论">五、更多讨论</h2><p>这个代码存在以下问题：</p><ol type="1"><li>面对函数变化率特别高的情况下表现不理想，会有间断的情况，如下图所示：</li></ol><p><span class="math display">\[   y=\tan x\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669353744.png" /></p><ol start="2" type="1"><li>需要人工指定的变量太多，日后我会开发一版能自动适应采样点，选择合适的坐标、范围的绘图函数。</li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://en.wikipedia.org/wiki/Netpbm#File_formats <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验2：信号的矩形脉冲抽样与恢复</title>
    <link href="/2022/05/10/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A2/"/>
    <url>/2022/05/10/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A2/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第二个实验，信号的矩形脉冲抽样与恢复</p><span id="more"></span><h2 id="一实验结果展示">一、实验结果展示</h2><h3 id="各频域图像">各频域图像</h3><ol type="1"><li><p><span class="math inline">\(F(\omega)\)</span>原始频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130549021.png" alt="image-20220604130549021" /><figcaption aria-hidden="true">image-20220604130549021</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130602889.png" alt="image-20220604130602889" /><figcaption aria-hidden="true">image-20220604130602889</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130625486.png" alt="image-20220604130625486" /><figcaption aria-hidden="true">image-20220604130625486</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130636810.png" alt="image-20220604130636810" /><figcaption aria-hidden="true">image-20220604130636810</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130648381.png" alt="image-20220604130648381" /><figcaption aria-hidden="true">image-20220604130648381</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130659596.png" alt="image-20220604130659596" /><figcaption aria-hidden="true">image-20220604130659596</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130713220.png" alt="image-20220604130713220" /><figcaption aria-hidden="true">image-20220604130713220</figcaption></figure></li></ol><h3 id="各时域图像">各时域图像</h3><ol type="1"><li><p><span class="math inline">\(F(\omega)\)</span>傅里叶反变换后时域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130724746.png" alt="image-20220604130724746" /><figcaption aria-hidden="true">image-20220604130724746</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样滤波后恢复的时域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130735531.png" alt="image-20220604130735531" /><figcaption aria-hidden="true">image-20220604130735531</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样滤波后恢复的时域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130746852.png" alt="image-20220604130746852" /><figcaption aria-hidden="true">image-20220604130746852</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样滤波后恢复的时域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130758457.png" alt="image-20220604130758457" /><figcaption aria-hidden="true">image-20220604130758457</figcaption></figure></li></ol><h2 id="二实验结果分析">二、实验结果分析</h2><p>由奈奎斯特抽样定理，一个带限信号<span class="math inline">\(f(t)\)</span>,如果其频谱存在在频域（角频率）区间<span class="math inline">\([-\omega_m,\omega_m]\)</span>，则可用抽样值唯一表示<span class="math inline">\(f(t)\)</span>,抽样值的间隔不能大于<span class="math inline">\(T_s=\frac{1}{2f_m}\)</span>,其中<span class="math inline">\(f_m=\frac{\omega_m}{2\pi}\)</span>.</p><p>在本实验中，<span class="math inline">\(\omega_m=\frac \pi2\)</span>，即采样的频率需要达到<span class="math inline">\(2\frac{\omega_m}{2\pi}=0.5\text{Hz}\)</span>。所以<span class="math inline">\(0.5\text{Hz}\)</span>和<span class="math inline">\(1\text{Hz}\)</span>采样后可以恢复，而<span class="math inline">\(0.2\text{Hz}\)</span>采样后就不能恢复出原来的波形。</p><h2 id="三实验代码">三、实验代码</h2><ol type="1"><li><p>实验用代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 5005</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.1415926535</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">double</span> <span class="hljs-params">(*fun_p)</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">F</span><span class="hljs-params">(<span class="hljs-type">double</span> omega)</span> &#123;<br><span class="hljs-keyword">return</span> ((omega &gt;= <span class="hljs-number">-0.5</span> * PI &amp;&amp; omega &lt;= <span class="hljs-number">0.5</span> * PI) ? <span class="hljs-built_in">cos</span>(omega) : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, fun_p f, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> step)</span> &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = left; t &lt;= right; t += step) &#123;<br>ans = ans + f(t) * <span class="hljs-built_in">cos</span>(w * t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fourierInvTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> t, fun_p f, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> step)</span> &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = left; w &lt;= right; w += step) &#123;<br>ans = ans + f(w) * <span class="hljs-built_in">cos</span>(w * t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans / (<span class="hljs-number">2.0</span> * PI);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">sample</span><span class="hljs-params">(<span class="hljs-type">double</span> t, <span class="hljs-type">double</span> fre, <span class="hljs-type">double</span> tau)</span> &#123; <span class="hljs-comment">//时域矩形抽样函数</span><br><span class="hljs-type">double</span> clc = <span class="hljs-number">1.0</span> / fre;<br>t = <span class="hljs-built_in">fabs</span>(t);<br><span class="hljs-type">double</span> res = <span class="hljs-built_in">fmod</span>(t, clc);<br><span class="hljs-keyword">if</span> (res &gt; (clc / <span class="hljs-number">2.0</span>)) res -= clc;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">fabs</span>(res) &lt;= (tau / <span class="hljs-number">2.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(<span class="hljs-type">double</span> w, <span class="hljs-type">double</span> fre, <span class="hljs-type">double</span> tau)</span> &#123;<br><span class="hljs-keyword">if</span> (w &gt;= -PI / <span class="hljs-number">2.0</span> &amp;&amp; w &lt;= PI / <span class="hljs-number">2.0</span>)<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> / fre) / tau;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">double</span> t[maxn], ft[maxn];<br>PPMdata **matrix;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> w[maxn], Fw[maxn];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-0.5</span> * PI - <span class="hljs-number">0.5</span>; w0 &lt;= <span class="hljs-number">0.5</span> * PI + <span class="hljs-number">0.5</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>w[cnt] = w0;<br>Fw[cnt] = F(w0);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out1.ppm&quot;</span>, matrix, w, Fw, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> * PI, <span class="hljs-number">3</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 1 finished------\n&quot;</span>);<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t0 = <span class="hljs-number">-20.0</span>; t0 &lt;= <span class="hljs-number">20.0</span>; t0 += <span class="hljs-number">0.1</span>) &#123;<br>t[cnt] = t0;<br>ft[cnt] = fourierInvTransform(t0, F, <span class="hljs-number">-0.5</span> * PI - <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span> * PI + <span class="hljs-number">0.5</span>, <span class="hljs-number">0.001</span>);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out2.ppm&quot;</span>, matrix, t, ft, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 2 finished------\n&quot;</span>);<br><br><span class="hljs-type">double</span> Fw_2[maxn], Fw_5[maxn], Fw_10[maxn];<br><br><br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-20.0</span>; i &lt;= <span class="hljs-number">20.0</span>; i += <span class="hljs-number">0.1</span>) &#123; <span class="hljs-comment">//计算傅里叶积分</span><br>Fw_2[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>Fw_5[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>Fw_10[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>++j;<br>&#125;<br>w[cnt] = w0;<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out3_1.ppm&quot;</span>, matrix, w, Fw_2, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out3_2.ppm&quot;</span>, matrix, w, Fw_5, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out3_3.ppm&quot;</span>, matrix, w, Fw_10, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 3 finished------\n&quot;</span>);<br><br><span class="hljs-type">double</span> Fw2_fil[maxn], Fw5_fil[maxn], Fw10_fil[maxn];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>Fw2_fil[cnt] = Fw_2[cnt] * filter(w0, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.01</span>);<br>Fw5_fil[cnt] = Fw_5[cnt] * filter(w0, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.01</span>);<br>Fw10_fil[cnt] = Fw_10[cnt] * filter(w0, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.01</span>);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out4_1.ppm&quot;</span>, matrix, w, Fw2_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4_2.ppm&quot;</span>, matrix, w, Fw5_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4_3.ppm&quot;</span>, matrix, w, Fw10_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> ft_2[maxn], ft_5[maxn], ft_10[maxn];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t0 = <span class="hljs-number">-20.0</span>; t0 &lt;= <span class="hljs-number">20.0</span>; t0 += <span class="hljs-number">0.1</span>) &#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>ft_2[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw2_fil[j] * <span class="hljs-number">0.01</span>;<br>ft_5[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw5_fil[j] * <span class="hljs-number">0.01</span>;<br>ft_10[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw10_fil[j] * <span class="hljs-number">0.01</span>;<br>++j;<br>&#125;<br>ft_2[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>ft_5[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>ft_10[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out4-4.ppm&quot;</span>, matrix, t, ft_2, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4-5.ppm&quot;</span>, matrix, t, ft_5, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4-6.ppm&quot;</span>, matrix, t, ft_10, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其中的<code>arratToPPM.h</code>是本人编写的绘图用代码库。文件内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 999999999</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span>;<br><br>PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">drawMatrix</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br><br><br><br>PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> &#123;<br>PPMdata ans;<br>ans.r = r, ans.g = g, ans.b = b;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span> &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(picLen / <span class="hljs-number">2</span> + (num - center) / range * picLen);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">drawMatrix</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color)</span> &#123;<br><span class="hljs-keyword">if</span> (x &gt;= width || x &lt; <span class="hljs-number">0</span> || y &gt;= height || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> matrix[y][x] = color;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br><span class="hljs-type">int</span> u = x + i, v = y + j;<br><span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> matrix[v][u] = color;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>freopen(fileName, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>fclose(<span class="hljs-built_in">stdout</span>);<br>freopen(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span> &#123;<br><br>matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PPMdata *) * height);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(width, <span class="hljs-keyword">sizeof</span>(PPMdata));<br>&#125;<br><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br><span class="hljs-type">double</span> *y_save=(<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>)*(arrayLen+<span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrayLen;++i) y_save[i]=y[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>y[i] = centerY - (y[i] - centerY);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR:X is not increasing.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR:X out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br><span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>&#125;<br>&#125;<br>PPMdata background, axis, grid, line;<br>background = makePPMdata(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = makePPMdata(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = makePPMdata(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = makePPMdata(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>matrix[i][j] = background;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br>drawPoint(matrix, width, height, numToMatPos(centerX + i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>drawPoint(matrix, width, height, numToMatPos(centerX - i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>drawPoint(matrix, width, height, j, numToMatPos(centerY + i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>drawPoint(matrix, width, height, j, numToMatPos(centerY - i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br>drawPoint(matrix, width, height, i, height / <span class="hljs-number">2</span>, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>drawPoint(matrix, width, height, width / <span class="hljs-number">2</span>, i, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">double</span> stepX = rangeX / width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> X = centerX - rangeX / <span class="hljs-number">2</span>; X &lt; centerX + rangeX / <span class="hljs-number">2</span>; X += stepX) &#123;<br><span class="hljs-type">int</span> linerIndex = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (X &lt; x[i]) &#123;<br>linerIndex = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (linerIndex == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">double</span> u, v, Y;<br>u = numToMatPos(X, centerX, rangeX, width);<br>Y = linerFunc(x[linerIndex], y[linerIndex], x[linerIndex + <span class="hljs-number">1</span>], y[linerIndex + <span class="hljs-number">1</span>], X);<br>v = numToMatPos(Y, centerY, rangeY, height);<br>drawPoint(matrix, width, height, u, v, line, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br>matToPPM(name, matrix, width, height);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s Draw finish!\n&quot;</span>,name);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height;++i)<br><span class="hljs-built_in">free</span>(matrix[i]);<br><span class="hljs-built_in">free</span>(matrix);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrayLen;++i) y[i]=y_save[i];<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验1：连续时间系统卷积的数值计算</title>
    <link href="/2022/04/06/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A1/"/>
    <url>/2022/04/06/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A1/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第一个实验，连续时间系统卷积的数值计算</p><span id="more"></span><h2 id="一实验原理">一、实验原理</h2><p>卷积积分不仅可以通过直接积分或查表的方法来求解，还可以用积分的数值计算方法来求解。在线性系统的分析过程中，有时会遇到复杂的激励信号，或者有时只是一组测试数据或曲线，冲激响应也可能出现同样的情况。显然，此时直接计算积分或查表都有困难，而采用近似的数值计算方法可以解决这个问题，求得卷积积分。</p><p>两个信号<span class="math inline">\(f_1(t)\)</span>和<span class="math inline">\(f_2(t)\)</span>的卷积<span class="math inline">\(f_1(t)*f_2(t)\)</span>定义为： <span class="math display">\[f_1(t)*f_2(t)=\int_{-\infty}^{\infty}f_1(t-\tau)f_2(\tau){\bf d}\tau\]</span> 在计算卷积积分时，我们通常采取“翻转→平移→相乘→叠加”的方法。</p><ol type="1"><li><p>将信号取值离散化，即以 Ts 为周期，对信号取值，得到一系列宽度间隔为 Ts 的矩形脉冲原信号的离散取值点，用所得离散取值点矩形脉冲来表示原来的连续时间信号；</p></li><li><p>将进行卷积的两个信号序列之一反转，与另一信号相乘，并求积分，所得为 t=0 时的卷积积分的值。以 Ts 为单位左右移动反转的信号，与另一信号相乘求积分，求的 t&lt;0 和 t&gt;0 时卷积积分的值；</p></li><li><p>将所得卷积积分值与对应的 t 标在图上，连成一条光滑的曲线，即为所求卷积积分的曲线。</p></li></ol><p>上述过程，在形式上，就是用 <span class="math display">\[\sum_{\tau=\tau_0}^{\tau_1}f_1(t-\tau)f_2(\tau)\Delta\tau\]</span> 来逼近<span class="math inline">\(f_1(t)*f_2(t)\)</span>。其中<span class="math inline">\(\tau_0\)</span>是一个很小的值，<span class="math inline">\(\tau_1\)</span>是一个很大的值，<span class="math inline">\(\Delta \tau\)</span>是每次<span class="math inline">\(\tau\)</span>增加的值。</p><h2 id="二实验内容">二、实验内容</h2><p><span class="math display">\[f_1(t)=u(t+2)-u(t-2)\\f_2(t)=t[u(t)-u(t-2)]+(4-t)[u(t-2)-u(t-4)]\]</span></p><p>用数值方法计算<span class="math inline">\(f_1*f_2\)</span>，将结果用表格列出，并画出图像。</p><h2 id="三实验过程">三、实验过程</h2><h3 id="程序框图">1. 程序框图</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091624871.png" alt="image-20220709162415460" /><figcaption aria-hidden="true">image-20220709162415460</figcaption></figure><h3 id="程序代码">2. 程序代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> dt = <span class="hljs-number">0.1</span>;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">u</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> (t &gt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> u(t + <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> t * <span class="hljs-number">1.0</span> * (u(t) - u(t - <span class="hljs-number">2</span>)) + (<span class="hljs-number">4</span> - t) * <span class="hljs-number">1.0</span> * (u(t - <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>freopen(<span class="hljs-string">&quot;ans.xls&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-2.5</span>; t &lt;= <span class="hljs-number">6.5</span>; t += dt) &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.01</span>) &#123;<br>ans += f1(t - i) * f2(i) * <span class="hljs-number">0.01</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f\t%.3f\n&quot;</span>, t, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果">3. 运行结果</h3><p><strong>部分表格：</strong></p><p>其中<span class="math inline">\(g(t)=f_1(t)*f_2(t)\)</span></p><table><thead><tr class="header"><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(g(t)\)</span></th><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(g(t)\)</span></th></tr></thead><tbody><tr class="odd"><td>-2</td><td>0</td><td>2.1</td><td>3.995</td></tr><tr class="even"><td>-1.9</td><td>0.005</td><td>2.2</td><td>3.981</td></tr><tr class="odd"><td>-1.8</td><td>0.019</td><td>2.3</td><td>3.957</td></tr><tr class="even"><td>-1.7</td><td>0.044</td><td>2.4</td><td>3.922</td></tr><tr class="odd"><td>-1.6</td><td>0.078</td><td>2.5</td><td>3.877</td></tr><tr class="even"><td>-1.5</td><td>0.123</td><td>2.6</td><td>3.823</td></tr><tr class="odd"><td>-1.4</td><td>0.177</td><td>2.7</td><td>3.758</td></tr><tr class="even"><td>-1.3</td><td>0.242</td><td>2.8</td><td>3.684</td></tr><tr class="odd"><td>-1.2</td><td>0.316</td><td>2.9</td><td>3.599</td></tr><tr class="even"><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td></tr></tbody></table><p>完整表格下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.xls">实验结果</a></p><p><strong>绘制图像：</strong></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091624863.png" alt="image-20220405220304046" /><figcaption aria-hidden="true">image-20220405220304046</figcaption></figure><p>使用Excel 365软件绘制图像。</p><h2 id="四解析求解和误差分析">四、解析求解和误差分析</h2><p>使用符号计算语言<code>Mathematica</code>运行下列代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-variable">t</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">(</span><span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-variable">t</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <br>      <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">4</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Convolve</span><span class="hljs-punctuation">[</span><span class="hljs-variable">f1</span><span class="hljs-operator">,</span> <span class="hljs-variable">f2</span><span class="hljs-operator">,</span> <span class="hljs-variable">t</span><span class="hljs-operator">,</span> <span class="hljs-variable">\[Tau]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-variable">g</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Tau]</span><span class="hljs-operator">,</span> <span class="hljs-operator">-</span><span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-built_in">PiecewiseExpand</span><span class="hljs-punctuation">[</span><span class="hljs-variable">g</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以得到卷积结果的解析式为： <span class="math display">\[g(\tau)=\begin{cases} \frac{1}{2} (\tau +2)^2 &amp; -2\leq \tau &lt;0 \\[1.5ex] \frac{1}{2} \left(-\tau ^2+4 \tau +4\right) &amp; 0\leq \tau &lt;4 \\[1.5ex] \frac{1}{2} \left(\tau ^2-12 \tau +36\right) &amp; 4\leq \tau &lt;6 \\[1.5ex] 0 &amp; \text{others}\end{cases}\]</span> 画出的图像为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091638947.png" alt="image-20220709163735914" /><figcaption aria-hidden="true">image-20220709163735914</figcaption></figure><p>将其代入程序，可计算得数值算法的均方误差 <span class="math display">\[\begin{aligned}\text{MSE}&amp;=\sum_{i=1}^n[ans_i-g(t_i)]^2\\&amp;=0.000029\end{aligned}\]</span> 计算代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> dt = <span class="hljs-number">0.1</span>;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">u</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> (t &gt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> u(t + <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> t * <span class="hljs-number">1.0</span> * (u(t) - u(t - <span class="hljs-number">2</span>)) + (<span class="hljs-number">4</span> - t) * <span class="hljs-number">1.0</span> * (u(t - <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span>&#123;<br><span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-number">-2</span> &amp;&amp; t&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (t+<span class="hljs-number">2.0</span>)*(t+<span class="hljs-number">2.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;t &amp;&amp; t&lt;=<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> (-t*t+<span class="hljs-number">4.0</span>*t+<span class="hljs-number">4.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">4</span>&lt;t &amp;&amp; t&lt;=<span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> (t*t<span class="hljs-number">-12.0</span>*t+<span class="hljs-number">36.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>freopen(<span class="hljs-string">&quot;ans.xls&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-type">double</span> e=<span class="hljs-number">0.0</span>;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-2.5</span>; t &lt;= <span class="hljs-number">6.5</span>; t += dt) &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.01</span>) &#123;<br>ans += f1(t - i) * f2(i) * <span class="hljs-number">0.01</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f\t%.3f\n&quot;</span>, t, ans);<br>e+=(ans-g(t))*(ans-g(t));<br>++cnt;<br>&#125;<br>fclose(<span class="hljs-built_in">stdout</span>);<br>freopen(<span class="hljs-string">&quot;CON&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MSE = %f&quot;</span>,e/(cnt*<span class="hljs-number">1.0</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
