<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>周记（20230730-20230831）</title>
    <link href="/2023/08/31/%E5%91%A8%E8%AE%B0%EF%BC%8820230730-20230831%EF%BC%89/"/>
    <url>/2023/08/31/%E5%91%A8%E8%AE%B0%EF%BC%8820230730-20230831%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>八月，也就是暑假的下半段。其实暑假的下半段并没有什么太多值得写的，大概有这么几件事吧</p><p>第一，就是在电影院看了《利兹与青鸟》和《吹响！上低音号 合奏比赛篇》，这还是挺不错的经历。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308311525186.png" alt="电影" /><figcaption aria-hidden="true">电影</figcaption></figure><p>第二，就是组织了一个故事接龙比赛，组织比赛的过程非常的劳神，因为要安排时间，逐一核查进展，和老师沟通审核，每一项对我这个社恐来说都是大挑战。但是至少最后评议得了个特别高的分，笑死。</p><p>第四，看了全新版高新一中，富丽堂皇，纯纯的汤臣一品</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308311524088.png" alt="高新一中" /><figcaption aria-hidden="true">高新一中</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308311525537.png" alt="高新一中大门口" /><figcaption aria-hidden="true">高新一中大门口</figcaption></figure><p>第三，就是接待npy来西安玩了两天，这也很劳神，当然不是说陪她玩劳神，陪她玩是很快乐的，而是因为我要同时</p><ol type="1"><li>劝阻她不要给我家送礼物</li><li>劝阻我家不要给她送礼物</li><li>劝她接收我家给她送的礼物</li></ol><p>与此同时，我家和她互相认为对方的劝阻是“客气一下”，我真受不了了。</p><p>第四，游泳了一个月，没瘦。主要原因是泳池的长度是25米，一开始把它当50米了，所以运动量等于打了个对折。</p><p>第五，报了个程设助教，然后因为朋友的推荐所以直接保送了，免试通过。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308311527035.png" alt="魏斯理汉堡" /><figcaption aria-hidden="true">魏斯理汉堡</figcaption></figure><p>今天的发电小作文写什么呢？写一写在我心中，解决台湾问题的最完美路径是什么。</p><p>有一个著名的景点，台湾那边写的是“三民主义统一中国”，而大陆这边写的是“一国两制统一中国”。在这里，你有没有发现有什么问题？没错，“社会主义”到哪里去了？我们为什么不说“社会主义统一中国”？原因很简单：在上世纪八十年代，我们并没有足够的道路自信、理论自信、制度自信、文化自信，当时并没有太多人相信“社会主义统一中国”，于是提出了符合上世纪八九十年代国情的“一国两制”，并在解决香港、澳门问题上发挥了举足轻重的积极作用。中国近二十年的爆炸式发展，是最疯狂的科幻作家也预料不到的，由此产生了一个问题：社会生产力可以在二十年间发生大爆炸，但是社会意识的转向需要一个过程，并不总是紧随着社会物质的发展。由此，才产生了2020年以来看似“割裂”的互联网大论战。在此，我提出“社会主义统一中国”的台湾问题解决方案。即：中国大陆目前所需要做的，主要是一步一步发展自己的产业，第二是稳住台海局势避免台湾悍然独立，第三是对台湾给予小恩小惠，待到国际大气候成熟时，在台湾内部营造省内的小气候，进而一举解放台湾。</p><p>请注意我的用词：解放台湾，而不是其它表达。其实读者可以留意一下这两者之间的区别，“解放”有将对面的人民从较差的生活环境中拯救起来之意。我的方案里没有讨论和平还是武力，这不重要。天津是武力解放的，北京是和平解放的，现在的天津和北京之间的区别很大吗？但是现在的事实是：台湾人，至少自以为自己的生活水平还是远高于大陆平均水平的，那么自然谈不上“解放”。所以有了前两步。</p><p>第一步，就是做好自己，一步一步地发展自己的产业，尤其是台湾省的优势产业：芯片。有人称中国为“发达国家粉碎机”，那么现在正是这个粉碎机该登场的时候了。既然台湾省不愿搭上这台人类有史以来最大的工业化发展“顺风车”，还要横躺在车前，那就不要怪粉碎机把你碾得粉身碎骨。等到中国大陆把台湾省的优势产业蚕食殆尽，台湾人民还怎么维持现在“高于大陆”的生活水平呢？</p><p>由俭入奢易，由奢入俭难。台湾地区作为“亚洲四小龙”之一，经历了飞速的发展。（插播一句，“亚洲四小龙”的出现，主要原因是中国共产党的存在，这话不会有人不认同吧？）那么，当台湾的支柱产业一个一个被粉碎之时，他们心理会怎么想呢？会因此仇视大陆，从而更加拒绝统一吗？有没有搞错，大陆只是在一步一步做自己的事而已，我们发展我们的产业，跟你有什么关系呢？勤奋劳动，改善生活，这也是犯罪吗？况且，我们不是还给了你“小恩小惠”，买了你几吨水果吗？那你们不能发展，难道终极原因不是因为你们自己太菜了吗？</p><p>一旦“自己太菜了”一出现，马上就会进入下一阶段。我们中国人是切切实实地体会过“自己太菜了”的，而且还是两次。第一次是鸦片战争，第二次是改革开放初期。那么这两次有什么共同点？聪明的你一定已经发现了：全社会的社会意识经历了急剧的变化，出现了完全自卑以至于彻底否定自己的思想。在第二次里，不少人完全丧失了对社会主义的理想信念，进而在某个春夏之交差点酿成大祸。那么台湾呢？他们的社会意识当然也会出现急剧的变化。当社会存在逐渐崩塌时，他们会不会说出“这一切都是制度的问题”呢？我觉得是会的。他们会彻底丧失对台湾制度的理想信念，进而，不用我们来解放台湾，台湾自己也会解放台湾。</p><p>生产力决定生产关系，社会存在决定社会意识。台湾作家龙应台有一句话，叫做“请用文明来说服我”，在说出这句话时，以龙应台为代表的台湾人显然是这样想的：我们台湾人是有高素质的，而你们大陆是“不自由”的、是低素质的，所以你不应该来“说服”我，甚至应该由我来“说服”你才对。即使你能霸占我的身体，可是你不能霸占我“文明”的精神，你一旦来霸占了，我就是文明世界的殉道者，我就是被蒙元消灭的大宋！可是当台湾的支柱产业一个一个被大陆粉碎的时候，台湾的“文明”还能保持多久呢？你是政府官员，经济越来越不好，你家越来越揭不开锅，你会不会开始收回扣？你是一个妈妈，孩子想在六一儿童节要个礼物，你没钱，你会不会去偷一个，至少是想一下？你是妻子，丈夫失业了，孩子又要上学，你会不会去红灯区转转？为什么不呢？只需要一晚上的功夫，燃眉之急不就解决了吗？你是丈夫，累了一天挣不到两个钱，晚上妻子回家还絮絮叨叨，抱怨没钱，抱怨你不如隔壁老王，你能忍住对人格的侮辱吗？刚好厨房里有把菜刀，也挺快的，是吧？请放心吧，到那时，暴力犯罪是会有的，欺诈勒索是会有的，贪污受贿是会有的，卖淫嫖娼是会有的，打骂孩子是会有的，随地大小便也是会有的，言论自由是会没有的。一旦失去了经济基础，文明必将跌落回野蛮，上层建筑必将自行调节，以匹配新的生产力，这就是社会存在决定社会意识，到那时，自然有“文明”出来说服你。“文明”可以是我们，也可以是台湾自己的“进步青年”。</p><p>当然，这一切还有一个小小的赠品。当我们把视角拉远，如果台湾从实行“自由民主”后的四小龙腾飞大富裕大发展，跌落到从垃圾堆里找烂菜叶子吃，大陆的观众会怎么看？还有什么比这更有说服力大型实景史诗级剧作，来论证“民主自由”的大失败呢？从此再也不会有人把“学习XX”挂在嘴上了：实行XX的台湾还烂在那呢，你要学他？</p><p>这个大战略有一个关键，就是台湾自己得配合。既不能悍然独立，逼迫大陆发动武统、高位接盘；也不能喊两句“九二共识”，然后欺骗大陆高强度扶持台湾自己的产业，若即若离地搭上“顺风车”。很遗憾，或者说很幸运，台湾人正在完全由自己的选择走在这条路上。他们非得自己走到铁轨中间，然后大声说：“你这辆纸糊的破车，我就不信你真的能压死我！”</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230720-20230730）</title>
    <link href="/2023/08/01/%E5%91%A8%E8%AE%B0%EF%BC%8820230720-20230730%EF%BC%89/"/>
    <url>/2023/08/01/%E5%91%A8%E8%AE%B0%EF%BC%8820230720-20230730%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这周最主要的事儿，当然是去了长春航空展</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010849590.png" alt="飞行表演队" /><figcaption aria-hidden="true">飞行表演队</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010849143.png" alt="运20" /><figcaption aria-hidden="true">运20</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010850905.png" alt="武直10释放干扰弹" /><figcaption aria-hidden="true">武直10释放干扰弹</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010850941.png" alt="运油20和歼20编队飞行" /><figcaption aria-hidden="true">运油20和歼20编队飞行</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010850802.png" alt="飞行表演队" /><figcaption aria-hidden="true">飞行表演队</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010851830.png" alt="飞行表演队" /><figcaption aria-hidden="true">飞行表演队</figcaption></figure><p>除此之外，还在长春的其它地方转了转</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010853018.png" alt="电影博物馆" /><figcaption aria-hidden="true">电影博物馆</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010854595.png" alt="真不同的溜肉段" /><figcaption aria-hidden="true">真不同的溜肉段</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010854564.png" alt="冷面" /><figcaption aria-hidden="true">冷面</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010854537.png" alt="轨道交通三号线" /><figcaption aria-hidden="true">轨道交通三号线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010854347.png" alt="这有山" /><figcaption aria-hidden="true">这有山</figcaption></figure><p>对长春的印象有三个，其一是饭菜的量很大，其二是公交车很少，其三是人很多。</p><p>回到北京以后，和npy去王府井转了转，主要目的是打卡孤独摇滚和索尼的联名，顺便还转了个书店。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010856324.png" alt="孤独摇滚" /><figcaption aria-hidden="true">孤独摇滚</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202308010856726.png" alt="书店里的少儿版国富论" /><figcaption aria-hidden="true">书店里的少儿版国富论</figcaption></figure><p>此外，我阅读了《中国共产党历史》全本（共四册）。</p><p>在去长春，回北京，回西安的火车上，我对未来的共产主义社会形态进行了一些思考。</p><p>首先共产主义社会的基本条件是物质生活的极大丰富。在马克思恩格斯，乃至列宁和毛泽东的时代，物质生活极大丰富是想象也不能想象的。但是多亏了技术，尤其是互联网的进步，现在可以想一想了。有人说，按需分配要求每个人都是圣人，不然人人都会去尽可能把物资据为己有，我看未必吧。难道现在每个人都在不停地用气瓶收集空气吗？难道有人会因为邮箱可以无限注册就不停地注册100个邮箱账号吗？完全没必要嘛。我们现在囤积物资（或者货币），其根本原因是物质没有极大丰富，所以我们得想着“万一没有了怎么办”。比如所谓的“囤盐潮”，不就是担心以后没有盐了吗？当盐这种物质在正常供应的时候，不会有人去囤积的。我们为什么不囤积空气？因为空气不会“万一没有了”。</p><p>在物质极大丰富的共产主义社会，所有生活物资都会和空气以及邮箱账号一样，不会“万一没有了”。所以你当然可以不停地向社会支取物资，堆积在自己身边，并且声称这是你自己的“私有财产”，但是社会会觉得你是一个奇怪的人，正如你在现在的社会看到有人不停地用气瓶收集空气一样。</p><p>再来说说“劳动是人的第一需要”。有人说，共产主义社会会人人都是懒汉，因为不用干活就能获取物资。那么不用干活能不能获取物资呢？当然可以，但是没有意义。因为劳动是人的第一需要，共产主义社会里的大部分人都在为马斯洛需求的第四阶乃至第五阶奔忙，而不像我们有的人还在为生存和安全工作。人们会认为，正是因为我在社会进行劳动，我对社会做出了贡献，我的生命才有价值。“什么？你不让我劳动，让我坐在家里等着物资上门？那我还怎么自我实现，怎么实现自己的价值呢？你是不是和我有仇？我是不是哪里得罪你了？”共产主义社会并不要求人人都是圣人，人人都大公无私地为社会做贡献。恰恰相反，人人自私地选择劳动，为的是实现自我的价值。说回段首，如果你就坐在家里等着物资上门，这当然可以，但是社会会觉得你是一个奇怪的人，正如你在现在的社会有人做着月薪十万的工作，但是每当拿到薪水就把钞票烧掉，然后去领低保一样。甚至还有人会觉得你才是真正大公无私的人，正如看到现在的慈善家，因为你无私地把自我实现的机会——人的第一需要——拱手让给了别人。</p><blockquote><p>在这里说一句题外话，我觉得大学的所有学生工作正是体现了“劳动是人的第一需要”，所以在大学里参加学生工作的人都是有共产主义情节的人。类似的工作还有维护论坛的版面。</p></blockquote><p>继续说劳动。那有人就问了，总得有人坐办公室，总得有人扫大街，那怎么办呢？我还要继续说，你说得对，当然有人坐办公室，有人扫大街。但是“怎么办”是什么意思，这是一个需要“办”的事情吗？我知道你想说，那坐办公室比扫大街舒服嘛，扫大街属于“脏活累活”嘛，怎么有人愿意干。那你就错了，你产生这种错觉的原因正是现在的技术不发达，还没有达到共产主义社会的需要。物质的极大丰富消灭了货币和阶级，而技术的极大发展会消灭过高的劳动强度——我用最粗粝的语言来说——扫大街当然可以坐在有空调的扫大街车里进行。到那时候，所有劳动都会变成无差别的人类劳动，没有什么区别。甚至你可以上午写代码，下午开场音乐会，晚上去扫大街。人家上午编编程下午弹弹琴怎么了？不都是劳动，不都是自我实现吗？正是因为现在这种受制于资本的岗位固化，和教育的不发达，导致你非得去甄别一个人一段时间内只能固定地干一种工作。</p><p>你前面说的这一堆都是基于物质极大丰富的，但是我觉得物质根本不可能极大丰富，举个例子，我就是想要毕加索的画，但是毕加索已经死了，他的画就那么几张，要是想要的人多了怎么办？你难道要阻止我在艺术上的自我实现吗？我还要说，你说得对，当然有很多人都想要毕加索的画，但是你得先问问自己为什么要。如果是因为它的艺术价值，那很好，有复制品。在技术极大发达的共产主义社会，完全可以从分子级别复制一副画。但是现在的社会上，有很多人想要毕加索的画并不全是因为艺术价值，而是因为它值钱，也就是说有商业价值。可是这是共产主义社会，货币都消亡了，值钱还有什么意义？艺术品的价值自然会回归到它本身的价值——凝结在其上的无差别人类劳动上。</p><p>你说毕加索的画能复制，这不假。但是如果我拿出“88888888”的电话号码，你又该如何应对？电话号码可不能复制吧，总不能在手机上输入88888888，结果接通了一万个电话，这不科学吧。确实，但是你仍然没有理解实质。你想要88888888这种电话号码的原因是什么？因为你有攀比心理，你觉得“靓号”就是尊贵的象征，你并不想你的电话号码是第9个自然数重复8遍构成的字符串，你想要的只是它身后所代表的身份和地位。但是在共产主义社会，已经无所谓谁尊贵谁不尊贵了，你当然可以因为你的电话号码是第9个自然数重复8遍构成的字符串所以自认为很尊贵，说不定还有几个人乐意陪你玩玩，但是社会不在乎。</p><p>好吧，物质说完了，再来说说家庭。我就是想草新垣结衣，我还想独占新垣结衣，而且想法和我一样的人肯定不少，但是新垣结衣只有一个，怎么办？你可别说克隆人哦~克隆人和本体肯定是不一样的，我就要本体。首先，你这个问题要一分为二地看，第一步：“我想独占女神怎么办”，第二步：“我想要新垣结衣怎么办”。</p><p>首先，你为什么想要“独占”女神？这源于现今社会的家庭观念。男女朋友交往的“独占性”是由家庭带来的，家庭带来的长期性，也就是“跟她一辈子”。但是在共产主义社会中，人人社会化抚养，人造子宫已经普及，家庭这个概念也会随之瓦解。每个人的性行为也只和自己有关，而无关什么家庭，你可以类比为目前社会的一夜情（当然我知道一夜情并不符合现代社会的道德，这个话题待会儿再说）——你无需为你的性对象的后半生负责，生育的事自有人造子宫和社会化抚养来替你操心。因为没有了家庭这个概念的牵绊，你可以选择全世界所有的适龄异性（LGBTG不讨论，换成适龄X性就行，没影响）来做你的性对象，即使99%都看不上你也没关系，剩下的1%也够你夜夜笙歌了。共产主义社会的性行为的神圣性会被消解，正如现在握握手一样。你在联谊舞会上一个异性邀请你跳支舞你会拒绝吗？</p><p>当然上面的道德观念现在看来是不可思议的。但是现在的道德观念在古人看来也是不可思议的不是吗？怎么这么多人在大街上露大腿，看来是道德沦丧了？什么年代，什么生产力基础，会有什么上层建筑，道德观念也是上层建筑的一种。对于目前的生产力而言，忠贞的婚姻观念仍然是社会稳定的基石。</p><p>那么第二步，我就想要新垣结衣怎么办？新垣结衣这样的明星是现代商业社会包装的产物，比她漂亮的也不是没有。当商业光环褪去以后，她只是一个普通的漂亮女人。</p><p>说了这么多，看得出来你很信仰共产主义社会。这次我要说你说错了，难道你会说“太阳一定从东边出来，月亮绕着地球转，这就是我的信仰”吗？很怪不是吗。共产主义社会就像“月亮绕着地球转”一样。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230605-20230719）</title>
    <link href="/2023/07/19/%E5%91%A8%E8%AE%B0%EF%BC%8820230605-20230719%EF%BC%89/"/>
    <url>/2023/07/19/%E5%91%A8%E8%AE%B0%EF%BC%8820230605-20230719%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>虽然是周记，但是这个涵盖了一个月，但是仍然叫做周记（笑）</p><p>这个月呢，没干别的，主要三件事。</p><p>第一，6月5日到6月25日，复习期末考试。我更新了很多笔记、实验报告在博客上，所以没有写周记。总之本科前六学期的所有考试均告结束，以后再也不用再卷考试了，也就是人生前16年所有为“往一张纸上填写正确答案”的所有努力，至此全部结束。接下来还要不断地填写正确答案，但是可能不再是答题卡上了。</p><p>6月24日，我搬了宿舍，因为原来猫娘乐园的猫娘们都毕业了，我很伤感，在24日晚上我一边收拾东西一边循环《毕业歌》：</p><blockquote><p>同学们大家起来</p><p>担负起天下的兴亡</p><p>听吧满耳是大众的嗟伤</p><p>看吧一年年国土的沦丧</p><p>我们是要选择战还是降</p><p>我们要做主人去拼死在疆场</p><p>我们不愿做奴隶而青云直上</p><p>我们今天是桃李芬芳</p><p>明天是社会的栋梁</p><p>我们今天弦歌在一堂</p><p>明天要掀起民族自救的巨浪</p><p>巨浪巨浪不断地增涨</p><p>同学们同学们快拿出力量</p><p>担负起天下的兴亡</p><p>巨浪巨浪不断地增涨</p><p>同学们同学们快拿出力量</p><p>担负起天下的兴亡</p></blockquote><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307192235450.png" alt="猫娘乐园" /><figcaption aria-hidden="true">猫娘乐园</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307192235946.png" alt="窗帘落地，乐园解体" /><figcaption aria-hidden="true">窗帘落地，乐园解体</figcaption></figure><p>第二，是6月26日到7月15日，这一段时间的主题是生产实习。虽然主题是生产实习，但是其实生产实习只占其中的一小部分。因为我是跟实验室实习的，所以不用每天几点到哪个地方坐着，只用完成老师布置的任务就行。所以这段时间除了完成实习内容以外，我还做了一些其它有意思的事情：</p><ol type="1"><li><p>打通了原子之心，并且准备以原子之心为引子写一篇介绍苏联科幻、苏联艺术的文章</p></li><li><p>参观了中国共产党历史展览馆：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307192238999.png" alt="党史馆" /><figcaption aria-hidden="true">党史馆</figcaption></figure></li><li><p>去了一家猫咖：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307192238379.png" alt="猫" /><figcaption aria-hidden="true">猫</figcaption></figure></li><li><p>考了个普通话：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307192239916.png" alt="普通话" /><figcaption aria-hidden="true">普通话</figcaption></figure><p>为什么要考这个呢？其中80%的原因是考着玩玩，而20%的原因是有一点点想考教师资格证。</p></li><li><p>进行了很多羽毛球和游泳的锻炼，大概合计有8~10次</p></li></ol><p>第三，是从7月16日到现在，生产实习已经结束，我进入了纯纯的玩环节。这两天继续推了E17，看了很多科幻小说，看了《长安三万里》，这是一部跳出了“封神”桎梏的国产动画电影，以高适的视点写李白，写唐朝的历史，写中国的文脉，是一部相当不错的电影，强烈推荐。然后旁听了一次庭审，其实没听太懂，但是还挺有意思的。</p><p>接下来开始神秘巨魔小作文环节。</p><p>首先，我在想什么叫“地球足够大，容得下中美两个大国”。这句话的意思是，中国和美国能够以正常国家之间的方式在地球上相处。中国最大的敌人不是美国，美国最大的敌人不是中国。中美两国有一个共同的、最大的敌人，它是一座会变形的怪物，它横亘整个近现代文明，一会儿叫“日不落”，一会儿叫“共产国际”，一会儿叫做“民主自由世界的灯塔”，目前它寄生在美国的身上，以美国的暴力机器作为它的后盾，吸吮着美国的血液，也吸吮着全世界的血液。它既不会考虑美国、中国或者全世界的国家的利益，也不会考虑美国人民、中国人民和全世界人民的利益。</p><p>现在很多人认为美国必须死，是认为它已经深深地和美国绑定在了一起——可是，美国曾经是多么伟大的国家啊！可是美国在战胜苏联的那一瞬间，“它”就从苏联身上攀附在了美国身上。中国面临的选择并不是如何战胜美国，而是要如何对待“它”。是想办法杀死它，然后和美国在地球上以正常国家之间的方式和平共处，还是去带上它的头盔，成为它新的靠山，去做全世界新的敌人。</p><p>英国选择了后者，美国选择了后者，最终，这些璀璨伟大的文明都没有“它”的毒手下幸存。回忆吧！当初高唱“最美好的前途”的拥有着崇高的理想信念的布尔什维克们，最终悍然入侵阿富汗，化身红鹰展翼的阴翳，饮下了这最甜蜜的毒药。</p><p>那我们呢？只要在未来的几十年内，中国共产党能对它发动最后的斗争，能够帮助美国革故鼎新刮骨疗毒，能够践行“世界人民大团结万岁”，那么人类的历史将进入全新的阶段，中国特色现代化“创造人类文明新形态”的要求将最终实现。否则，如果中国最终仍然接受了“它”的蛊惑，那么人类文明就到这里了。因为上一次苏联的惨死，已经大大打击了全人类探索新制度的积极性，之后的历史就是它继续在一个又一个璀璨的文明上横跳，然后把它们变成晦暗的恶魔，再寻找下一个宿主，人类文明将重新进入中世纪。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理实验</title>
    <link href="/2023/07/03/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/07/03/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>这实验挺神秘的其实，有好多地方我都感觉不太对劲，但是鉴于成绩还可以，还是放出来给大家参考一下。</p><span id="more"></span><h2 id="实验一一二阶系统的电子模拟及时域响应的动态测试">实验一：一、二阶系统的电子模拟及时域响应的动态测试</h2><h3 id="实验目的">实验目的</h3><ol type="1"><li><p>了解一、二阶系统阶跃响应及其性能指标与系统参数之间的关系。</p></li><li><p>学习单位阶跃响应性能指标的测试方法。</p></li></ol><h3 id="实验内容">实验内容</h3><ol type="1"><li>建立一阶系统的模型，观测并记录时间常数<span class="math inline">\(T\)</span>不同时的单位阶跃响应曲线，测定其调整时间(即过渡过程时间) <span class="math inline">\(t_s\)</span>。</li><li>建立二阶系统的数学模型，观测并记录不同阻尼比ζ时的单位阶跃响应曲线，测定其超调量<span class="math inline">\(M_p\)</span>及过渡过程时间<span class="math inline">\(t_s\)</span>。</li></ol><h3 id="实验原理">实验原理</h3><ol type="1"><li><p>一阶系统系统传递函数为：<span class="math inline">\(T(s)=K/(Ts+1)\)</span>。在实验当中始终取<span class="math inline">\(K=1\)</span>，取不同的时间常数<span class="math inline">\(T\)</span>分别为：<span class="math inline">\(0.25,0.5,1.0\)</span>。记录不同时间常数下单位阶跃响应曲线，测量并纪录其过渡过程时间<span class="math inline">\(t_s\)</span>，给出在时间常数不同时理论计算和实测的<span class="math inline">\(t_s\)</span>以及相应的阶跃响应曲线。</p></li><li><p>二阶系统系统传递函数为： <span class="math display">\[T(s)=\frac{\omega_n^2}{s^2+2\xi\omega_ns+\omega_n^2}\]</span></p><p>在实验中始终取<span class="math inline">\(\omega_n=1\)</span>弧度/秒，<span class="math inline">\(\xi\)</span>取不同的值、分别为：<span class="math inline">\(0.25,0.5,0.707,1.0\)</span>，观察并画出相应的单位阶跃响应曲线，测量超调量<span class="math inline">\(M_p\)</span>，计算过渡过程时间<span class="math inline">\(t_s\)</span>。</p></li></ol><h3 id="实验结果和代码">实验结果和代码</h3><h4 id="一阶系统">一阶系统</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031914649.jpg" alt="一阶系统图像" /><figcaption aria-hidden="true">一阶系统图像</figcaption></figure><table><thead><tr class="header"><th>T</th><th>Ts理论</th><th>Ts实测</th><th>误差</th></tr></thead><tbody><tr class="odd"><td>0.25</td><td>0.75</td><td>0.749</td><td>0.13%</td></tr><tr class="even"><td>0.5</td><td>0.15</td><td>0.15</td><td>0</td></tr><tr class="odd"><td>1</td><td>3</td><td>3</td><td>0</td></tr></tbody></table><p>误差产生的原因可能有A/D、D/A转换可能会有分辨力约束及量化精度引入的误差。一阶系统的阶跃输入响应是时间的单调函数，其理论的稳态误差为0。而瞬态响应的主要参数是其时间常数<span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span>越小，上升过程越快，调节时间越短，系统稳定就越迅速。仿真实验的结果与理论分析基本吻合。</p><p>实验代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">K=<span class="hljs-number">1</span>;<br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span>;<br>Tss=[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> Ts = xis<br>    sys=tf(K,[Ts,<span class="hljs-number">1</span>]);<br>    u=stepfun(t,<span class="hljs-number">0</span>);<br>    step(sys);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="二阶系统">二阶系统</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304060023976.jpg" alt="二阶阶跃响应" /><figcaption aria-hidden="true">二阶阶跃响应</figcaption></figure><p>图中蓝色-橙色-黄色-紫色线条依次是<span class="math inline">\(\xi\)</span>为<span class="math inline">\(0.25,0.5,0.707,1\)</span>时的单位阶跃响应。</p><table><thead><tr class="header"><th><span class="math inline">\(\xi\)</span></th><th><span class="math inline">\(Mp\)</span>理论（%）</th><th><span class="math inline">\(Mp\)</span>实测（%）</th><th><span class="math inline">\(t_s\)</span>理论</th><th><span class="math inline">\(t_s\)</span>实测</th></tr></thead><tbody><tr class="odd"><td>0.25</td><td>44.4</td><td>44.3</td><td>12</td><td>10.8</td></tr><tr class="even"><td>0.5</td><td>16.3</td><td>16.3</td><td>6</td><td>5.29</td></tr><tr class="odd"><td>0.707</td><td>4.32</td><td>4.33</td><td>4.24</td><td>2.93</td></tr><tr class="even"><td>1</td><td>0</td><td>0</td><td>3</td><td>4.74</td></tr></tbody></table><p>对于二阶系统，其阶跃响应主要由阻尼比<span class="math inline">\(\xi\)</span>及无阻尼自然频率<span class="math inline">\(\omega_n\)</span>决定。随着阻尼比增大，阶跃响应由欠阻尼过渡到临界阻尼再到过阻尼。欠阻尼状态下，阻尼比<span class="math inline">\(\xi\)</span>越大，超调量<span class="math inline">\(M_p\)</span>越小，平稳性越好，而调整时间<span class="math inline">\(T_s\)</span>也随之减短。在阻尼比<span class="math inline">\(\xi=0.707\)</span>时，超调量和调整时间都较小，可以认为是比较理想的瞬态响应，称为准最佳系统。当阻尼比增大到1时，阶跃响应成为单调的上升过程，类似于一阶系统。</p><p>实验代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">omega=<span class="hljs-number">1</span>;<br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span>;<br>xis=[<span class="hljs-number">0.25</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.707</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> xi = xis<br>    sys=tf(omega*omega,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*xi*omega,omega*omega]);<br>    u=stepfun(t,<span class="hljs-number">0</span>);<br>    step(sys);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="实验二频率响应测试">实验二：频率响应测试</h2><h3 id="实验目的-1">实验目的</h3><ol type="1"><li><p>掌握频率特性的测试原理及方法</p></li><li><p>学习根据所测定出的系统的频率特性，确定系统传递函数的方法。</p></li></ol><h3 id="实验内容-1">实验内容</h3><ol type="1"><li><p>测定给定环节的频率特性。</p></li><li><p>系统传递函数为： <span class="math display">\[G(s)=\frac{200}{s^2+10s+200}\]</span> 或 <span class="math display">\[G(s)=\frac{500}{s^2+10s+500}\]</span> 若正弦输入信号为<span class="math inline">\(U_i(t)=A_1\sin(\omega t)\)</span>，则当输出达到稳态时，其输出信号为<span class="math inline">\(U_o(t)=A_2 \sin (\omega t+\psi)\)</span> 。改变输入信号频率<span class="math inline">\(f_i=\frac \omega{2\pi}\)</span>值，便可测得二组和<span class="math inline">\(\frac{A_2}{A_1}\)</span>随<span class="math inline">\(f\)</span>（或<span class="math inline">\(\omega\)</span>）变化的数值，这个变化规律就是系统的幅频特性和相频特性。</p></li></ol><h3 id="实验原理-1">实验原理</h3><ol type="1"><li><p>幅频特性即测量输入与输出信号幅值<span class="math inline">\(A_1\)</span>和<span class="math inline">\(A_2\)</span>，并计算比值</p></li><li><p>实验采用“李沙育图形” 法进行相频特性的测试。以下简单介绍一下这种测试方法的原 理。设有两个正弦信号 <span class="math inline">\(X(\omega t)=X_m \sin (\omega t)\)</span> 和 <span class="math inline">\(Y(\omega t)=Y_m \sin (\omega t+\psi)\)</span>, 若以 <span class="math inline">\(X(t)\)</span> 为横轴, <span class="math inline">\(Y(t)\)</span> 为纵轴, 而以 <span class="math inline">\(\omega\)</span> 作为参变量, 则随着 <span class="math inline">\(\omega t\)</span> 的变化, <span class="math inline">\(X(t)\)</span> 和 <span class="math inline">\(Y(t)\)</span> 所确定的点的轨迹, 将在 <span class="math inline">\(X-Y\)</span> 平面上描绘 出一条封闭的曲线, 这个图形在物理学上称为“李沙育图形”（或李萨如图形）, 如下图所示。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031927247.png" alt="李沙育图形" /><figcaption aria-hidden="true">李沙育图形</figcaption></figure></li><li><p>相位差角 <span class="math inline">\(\psi\)</span> 的求法: 对于 <span class="math inline">\(X(\omega t)=X_m \sin (\omega t)\)</span> 及 <span class="math inline">\(Y(\omega t)=Y_m \sin (\omega t+\psi)\)</span>, 当 <span class="math inline">\(\omega t=0\)</span> 时, 有 <span class="math inline">\(X(0)=0\)</span>; <span class="math inline">\(Y(0)=Y_m \sin (\psi)\)</span> 。即 <span class="math inline">\(\psi=\arcsin \frac{Y(0)}{Y_m}\)</span>, 显然仅当 <span class="math inline">\(0 \leq \psi \leq \frac{\pi}{2}\)</span> 时, 该式才是成立的。</p></li></ol><p>提示1：根据实验内容，自行安排实验步骤，根据需要可以对表2.1适当修改。</p><p>提示2：简单起见，可以将某次测试结果作为参考完成报告，见下表</p><table><thead><tr class="header"><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(f\)</span>(Hz)</td><td>0.477</td><td>0.796</td><td>1.114</td><td>1.432</td><td>1.751</td><td>2.069</td><td>2.387</td><td>2.865</td><td>3.979</td><td>4.775</td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span>(rad/s)</td><td>3.000</td><td>5.000</td><td>7.000</td><td>9.000</td><td>11.000</td><td>13.000</td><td>15.000</td><td>18.000</td><td>25.000</td><td>30.000</td></tr><tr class="odd"><td><span class="math inline">\(A_2/A_1\)</span></td><td>1.035</td><td>1.108</td><td>1.216</td><td>1.362</td><td>1.453</td><td>1.428</td><td>1.421</td><td>1.211</td><td>0.820</td><td>0.369</td></tr><tr class="even"><td><span class="math inline">\(Y(0)/Y(m)\)</span></td><td>0.198</td><td>0.300</td><td>0.466</td><td>0.663</td><td>0.894</td><td>0.999</td><td>0.996</td><td>0.976</td><td>0.741</td><td>0.370</td></tr><tr class="odd"><td><span class="math inline">\(\psi(0)\)</span></td><td>-11.430</td><td>-17.436</td><td>-27.761</td><td>-41.546</td><td>-63.382</td><td>-86.967</td><td>-94.808</td><td>-102.564</td><td>-132.177</td><td>-158.256</td></tr></tbody></table><h3 id="实验结果">实验结果</h3><h4 id="绘制李萨如图像">绘制李萨如图像</h4><p>取传递函数为 <span class="math display">\[G(s)=\frac {200}{s^2+10s+200}\]</span> 分别取<span class="math inline">\(\omega=3,9,15,30\)</span>，绘制李萨如图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031929309.jpeg" alt="李萨如图像" /><figcaption aria-hidden="true">李萨如图像</figcaption></figure><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab">t=<span class="hljs-number">0</span>:<span class="hljs-number">0.001</span>:<span class="hljs-number">1000</span>;<br>f=<span class="hljs-number">3</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br><br>f=<span class="hljs-number">9</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br><br>f=<span class="hljs-number">15</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br><br>f=<span class="hljs-number">30</span>;<br>x=<span class="hljs-built_in">sin</span>(f.*t);<br>sys = tf(<span class="hljs-number">200</span>, [<span class="hljs-number">1</span> <span class="hljs-number">10</span> <span class="hljs-number">200</span>]);<br>y = lsim(sys, x, t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(x,y);<br></code></pre></td></tr></table></figure><h4 id="利用表格确定传递函数">利用表格确定传递函数</h4><p>设传递函数为 <span class="math display">\[G_0(\omega)=\frac{\omega_n^2}{s^2+2 \zeta \omega_n s+\omega_n^2}=\frac{1}{\sqrt{\left(1-\frac{\omega^2}{\omega_n^2}\right)^2+4 \zeta^2 \frac{\omega^2}{\omega_n^2}}} \exp \left(-\operatorname{arctg} \frac{2 \zeta \frac{\omega}{\omega_n}}{1-\frac{\omega^2}{\omega_n^2}}\right)\]</span> 假设传递函数是<span class="math inline">\(G(s)=\frac {200}{s^2+10s+200}\)</span>，理论上<span class="math inline">\(\omega_n=\sqrt{200}=14.14\)</span>时相移恰为-90°，实验测得的结果与理论基本一致。现在把<span class="math inline">\(\omega_n=14\)</span>代入，对于十个数据点计算<span class="math inline">\(\zeta\)</span>，有：</p><table><thead><tr class="header"><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td>0.355701</td><td>0.323482</td><td>0.337327</td><td>0.343293</td><td>0.364031</td><td>0.369706</td><td>0.321067</td><td>0.196532049</td><td>/</td><td>/</td></tr></tbody></table><p>有效数据的平均值为0.326，因此，计算出的传递函数为： <span class="math display">\[G(s)=\frac {196}{s^2+9.128s+196}\]</span> 实验测的的结果与理论基本吻合，但仍存在一定的误差，可能由下面的因素引起：</p><ol type="1"><li><p>A/D、D/A转换时存在转换及量化误差；</p></li><li><p>在MATLAB输出的李沙育图形上读取<span class="math inline">\(Y_0\)</span>和<span class="math inline">\(Y_m\)</span>时存在读数误差。<span class="math inline">\(\omega_n\)</span>附近的正椭圆一定程度上依靠主观判断。</p></li><li><p>测量数据时有读数偏差</p></li></ol><h2 id="实验三控制系统串联校正">实验三：控制系统串联校正</h2><h3 id="实验目的-2">实验目的</h3><ol type="1"><li><p>了解和掌握串联校正的分析和设计方法。</p></li><li><p>研究串联校正环节对系统稳定性及过渡过程的影响。</p></li></ol><h3 id="实验内容-2">实验内容</h3><ol type="1"><li><p>设计串联超前校正，验证和分析校正装置对系统稳定性及过渡过程的影响。</p></li><li><p>设计串联滞后校正，验证和分析校正装置对系统稳定性及过渡过程的影响。</p></li></ol><h3 id="实验原理-2">实验原理</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031936227.png" alt="系统结构图" /><figcaption aria-hidden="true">系统结构图</figcaption></figure><ol type="1"><li>系统结构图如上图所示, 校正装置 (环节) (传递函数为 <span class="math inline">\(G_c(s)\)</span> ) 串联在系统的 前向通道中, <span class="math inline">\(G_0(s)\)</span> 为末加矫正时原系统前向通道传递函数, 在本次实验中设定 <span class="math inline">\(G_0(s)=\frac{4}{s(s+1)}, H(s)=1\)</span>, 实验应用 MATLAB 软件实现。</li><li>末加矫正时, <span class="math inline">\(G_c(s)=1\)</span> 。</li><li>加串联超前校正时, <span class="math inline">\(G_c(s)=\frac{a T s+1}{T s+1},(a&gt;1)\)</span> 。在实验中, 给定 <span class="math inline">\(a=2.44, T=0.26\)</span>, 则 <span class="math inline">\(G_c(s)=\frac{0.63 s+1}{0.26 s+1}\)</span>, 计算系统性能指标参量, 分析校正环节对系统稳定性及过渡 过程的影响。</li><li>加串联滞后校正时, <span class="math inline">\(G_c(s)=\frac{b T s+1}{T s+1},(0&lt;\mathrm{b}&lt;1)\)</span> 。在实验中, 给定 <span class="math inline">\(b=0.12, T=83.33\)</span>, 则 <span class="math inline">\(G_c(s)=\frac{10 s+1}{83.33 s+1}\)</span>, 计算系统性能指标参量, 分析校正环节对系统稳定性及过渡过程的影响。</li></ol><h3 id="实验结果-1">实验结果</h3><p>阶跃响应图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305252210614.jpg" alt="三系统阶跃响应图" /><figcaption aria-hidden="true">三系统阶跃响应图</figcaption></figure><p>有：</p><table><thead><tr class="header"><th></th><th>超调量Mp/%</th><th>建立时间/s</th></tr></thead><tbody><tr class="odd"><td>原系统</td><td>44%</td><td>5.48</td></tr><tr class="even"><td>超前校正</td><td>23%</td><td>1.90</td></tr><tr class="odd"><td>滞后校正</td><td>20%</td><td>13.37</td></tr></tbody></table><p>波特图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305252210441.jpg" alt="波特图" /><figcaption aria-hidden="true">波特图</figcaption></figure><p>经计算，有：</p><table><thead><tr class="header"><th></th><th>截止频率/rad</th><th>稳定裕度/°</th></tr></thead><tbody><tr class="odd"><td>原系统</td><td>1.88</td><td>28</td></tr><tr class="even"><td>超前校正</td><td>2.38</td><td>47.4</td></tr><tr class="odd"><td>滞后校正</td><td>0.45</td><td>54.8</td></tr></tbody></table><p>由上述数据可以看出，进行了串联超前校正后，系统的调整时间<span class="math inline">\(ts\)</span>减小，系统响应的快速性改善；超调量<span class="math inline">\(Mp\)</span>降低，系统阻尼较大；系统的裕度增大，系统稳定性增强。进行了串联滞后校正后，系统的调整时间<span class="math inline">\(ts\)</span>增大，快速性减弱；但是系统超调量<span class="math inline">\(Mp\)</span>减小；提高了稳定裕量，稳定性增强，抑制高频干扰的能力改善。</p><p>实验代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;close all;<br><br>G0 = tf(<span class="hljs-number">4</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]);<br>G_lead = tf([<span class="hljs-number">0.63</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0.26</span>,<span class="hljs-number">1</span>]); <span class="hljs-comment">%超前校正</span><br>G_lag = tf([<span class="hljs-number">10</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">83.33</span>,<span class="hljs-number">1</span>]); <span class="hljs-comment">%滞后校正</span><br><br><span class="hljs-comment">%计算闭环传递函数</span><br>sys1_cl = G0/(<span class="hljs-number">1</span>+G0);<br>sys_lead_cl = (G0 * G_lead)/(<span class="hljs-number">1</span>+G0 * G_lead);<br>sys_lag_cl = (G0 * G_lag)/(<span class="hljs-number">1</span>+G0 * G_lag);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>step(sys1_cl);<span class="hljs-built_in">hold</span> on;<br>step(sys_lead_cl);<span class="hljs-built_in">hold</span> on;<br>step(sys_lag_cl);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;原系统&#x27;</span>,<span class="hljs-string">&#x27;超前校正&#x27;</span>,<span class="hljs-string">&#x27;滞后校正&#x27;</span>);<br><br><span class="hljs-comment">%计算开环传递函数</span><br>sys1_ol = G0;<br>sys_lead_ol= G0 * G_lead;<br>sys_lag_ol = G0 * G_lag;<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>bode(sys1_ol);<span class="hljs-built_in">hold</span> on;<br>bode(sys_lead_ol);<span class="hljs-built_in">hold</span> on;<br>bode(sys_lag_ol);<span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;原系统&#x27;</span>,<span class="hljs-string">&#x27;超前校正&#x27;</span>,<span class="hljs-string">&#x27;滞后校正&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="实验四采样控制系统研究">实验四：采样控制系统研究</h2><h3 id="实验目的-3">实验目的</h3><ol type="1"><li><p>了解信号的采样与恢复的原理及其过程，并验证香农定理。</p></li><li><p>掌握采样系统的瞬态响应与极点分布的对应关系。</p></li></ol><h3 id="实验原理-3">实验原理</h3><ol type="1"><li><p>采样：把连续信号转换成离散信号的过程叫采样。</p></li><li><p>采样定理：如果选择的采样角频率 <span class="math inline">\(\omega_s\)</span>, 满足 <span class="math inline">\(\omega_s \geq 2 \omega_{\max }\)</span> 条件 ( <span class="math inline">\(\omega_{\max }\)</span> 为连续信号频谱的上限频率), 那 么经采样所获得的脉冲序列可以通过理想的低通滤波器无失真地恢复原连续信号。</p></li><li><p>信号的复现: 零阶保持器是将采样信号转换成连续信号的元件, 是一个低通滤波器。其传递函数: <span class="math inline">\(\frac{1-e^{-T_s}}{s}\)</span>;</p></li><li><p>采样系统的极点分布对瞬态响应的影响: Z 平面内的极点分布在单位圆的不同位置, 其对应的瞬态分量是不同的。</p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031948590.png" alt="image-20230703194816495" /><figcaption aria-hidden="true">image-20230703194816495</figcaption></figure><h3 id="实验内容-3">实验内容</h3><p>在下图中, <span class="math inline">\(D(z)=U(z) / E(z)=1\)</span>, 系统被控对象脉冲传递函数为: <span class="math display">\[G(z)=\frac{Y(z)}{U(z)}=Z\left[\frac{1-e^{-T s}}{s} \frac{4}{s+1}\right]=\frac{4\left(1-e^{-T}\right)}{z-e^{-T}}\]</span> 系统闭环脉冲传递函数为: <span class="math display">\[\Phi(z)=\frac{G_w(z)}{1+G_w(z)}\]</span> 1. 改变采频率 <span class="math inline">\(T=0.01 s, 0.2 s, 0.5 s, 0.6 \mathrm{~s}\)</span>, 用 MATLAB 画出系统在阶跃信号作用下的过渡过程。</p><ol start="2" type="1"><li>在Z平面内讨论，当采样周期T变化时对系统稳定性的影响。</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031949836.png" alt="系统示意图" /><figcaption aria-hidden="true">系统示意图</figcaption></figure><h3 id="实验结果-2">实验结果</h3><p>采样周期<span class="math inline">\(T=0.01,0.2,0.5,0.6s\)</span>时对应的响应图如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306162101027.jpg" /></p><p>可以看出，当<span class="math inline">\(T=0.01,0.2\)</span>时，阶跃响应单调收敛，系统稳定。</p><p>当<span class="math inline">\(T=0.5s\)</span>时，阶跃响应震荡收敛，系统稳定。</p><p>当<span class="math inline">\(T=0.6s\)</span>时，阶跃响应震荡发散，系统不稳定。</p><p>系统闭环脉冲传递函数为： <span class="math display">\[\phi(z)=\frac{4-4e^{-T}}{z+4-5e^{-T}}\]</span> 特征根为 <span class="math display">\[z=5e^{-T}-4\]</span> 系统稳定的条件为<span class="math inline">\(|z|&lt;1\)</span>，即<span class="math inline">\(T&lt;0.51\)</span>。故当<span class="math inline">\(T=0.01,0.2,0.5s\)</span>时，系统是稳定的，而<span class="math inline">\(T=0.6s\)</span>时，系统是不稳定的。</p><p>根据分析可得：当闭环特征根位于单位圆内的正半轴上时，阶跃响应单调收敛，系统稳定；当闭环特征根位于单位圆内的负半轴上时，阶跃响应振荡收敛，系统稳定；当闭环特征根位于单位圆外时，阶跃响应发散，系统不稳定</p><p>在这个实验中，通过对具有开环传递函数的离散系统进行阶跃响应的分析，我得到了以下几点收获：</p><ol type="1"><li><p>离散系统稳定性条件：通过分析<span class="math inline">\(z\)</span>域稳定条件<span class="math inline">\(|z|&lt;1\)</span>，我们可以确定系统的稳定性范围。</p></li><li><p>采样时间对系统稳定性的影响：实验中使用了不同的采样时间T，观察到对应的阶跃响应特性。通过实验结果，我们发现只有当T满足一定条件时，系统才是稳定的。这进一步强调了合适的采样时间选择对系统稳定性的重要性。</p></li></ol><p>这个实验让我深入理解了离散控制系统的稳定性条件和阶跃响应特性。通过对离散系统的实验验证，加深了我对离散控制理论的理解和应用，同时也学习了Matlab的使用技巧。</p><p>实验代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 采样时间T分别为0.01秒，0.2秒，0.5秒，0.6秒</span><br>Ts = [<span class="hljs-number">0.01</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>];<br><span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> T = Ts<br>    syms z<br>    G = (<span class="hljs-number">4</span>*(<span class="hljs-number">1</span>-<span class="hljs-built_in">exp</span>(-T))/(z-<span class="hljs-built_in">exp</span>(-T)) );<br>    Phi = G/(<span class="hljs-number">1</span>+G);<br>    U = z/(z<span class="hljs-number">-1</span>);<br>    Y = U*Phi;<br>    y = iztrans(Y);<br>    fy = matlabFunction(y);<br>    t = <span class="hljs-number">0</span>:T:<span class="hljs-number">10</span>;<br>    n = t./T;<br>    y1=fy(n);<br>    y2=<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(n));<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>);<br>    <span class="hljs-built_in">plot</span>(t,y1,t,y2);<br>    <span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;响应&#x27;</span>,<span class="hljs-string">&#x27;激励&#x27;</span>);<br>    xlabel(<span class="hljs-string">&#x27;时间/s&#x27;</span>);ylabel(<span class="hljs-string">&#x27;响应&#x27;</span>);<br>    title(<span class="hljs-string">&quot;采样频率为T=&quot;</span>+num2str(T)+<span class="hljs-string">&quot;s时的响应&quot;</span>);<br>    <span class="hljs-built_in">i</span>=<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="实验五状态反馈与状态观测器">实验五：状态反馈与状态观测器</h2><h3 id="实验目的-4">实验目的</h3><ol type="1"><li><p>掌握用状态反馈进行极点配置的方法。</p></li><li><p>了解带有状态观测器的状态反馈系统。</p></li></ol><h3 id="实验原理-4">实验原理</h3><p>闭环系统的动态性能与系统的特征根密切相关，在状态空间的分析中可利用状态反馈来配置系统的闭环极点。这种校正手段能提供更多的校正信息，在形成最优控制率、抑制或消除扰动影响、实现系统解耦等方面获得广泛应用。在改善与提高系统性能时不增加系统零、极点，所以不改变系统阶数，实现方便。</p><p>考虑如下图所示的磁悬浮控制系统。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031953356.png" alt="磁悬浮控制系统" /><figcaption aria-hidden="true">磁悬浮控制系统</figcaption></figure><p>根据牛顿力学定律和回路电压定律, 可列写系统微分方程为: <span class="math display">\[\begin{gathered}M \ddot{y}=M g-K \frac{i^2}{y} &amp;(1)\\V=L \dot{i}+i R &amp;(2)\end{gathered}\]</span> 其中 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(M\)</span> 是小球的垂直位置和质量, <span class="math inline">\(g\)</span> 为重力加速度, <span class="math inline">\(K\)</span> 为反映磁力大小的常数, <span class="math inline">\(i 、 V\)</span> 、 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(L\)</span> 分别是回路电流、电压、电阻和电感。</p><p>式 (1) 为非线性微分方程, 需要对其进行线性化处理。假设小球的期望平衡点为 <span class="math inline">\(y_0\)</span>, 在 平衡点上小球保持静止, 其位置 <span class="math inline">\(y\)</span> 的各阶导数为零, 由式 (1) 可得对应的平衡电流为 <span class="math inline">\(i_0=\sqrt{\frac{M g}{K} y_0}\)</span>, 其对应的平衡电压为 <span class="math inline">\(V_0=i_0 R\)</span> 。在 <span class="math inline">\(\left(y_0, i_0\right)\)</span> 处对式 (1) 进行泰勒线性近似, 即: <span class="math display">\[M \ddot{y} \approx M g-\frac{K i_0^2}{y_0}-\left.\frac{2 K i}{y}\right|_{i_0, y_0} \Delta_i+\left.\frac{K i^2}{y^2}\right|_{i_0, y_0} \Delta_y \quad(3)\]</span> 其中 <span class="math inline">\(\Delta_i=i-i_0, \Delta_y=y-y_0\)</span> 。进一步定义 <span class="math inline">\(\Delta_V=V-V_0\)</span>, 可由式 (2) 和 (3) 得到: <span class="math display">\[\begin{gathered}M \ddot{\Delta}_y-\frac{K i_0^2}{y_0^2} \Delta_y+\frac{2 K i_0}{y_0} \Delta_i \approx 0 &amp;(4)\\\Delta_V=L \dot{\Delta}_i+R \Delta_i &amp;(5)\end{gathered}\]</span> 由此, 我们可以在期望平衡点 <span class="math inline">\(y_0\)</span> 附近, 采用线性控制方法进行系统设计, 其中控制变量 是在 <span class="math inline">\(V_0\)</span> 基础上的电压调节量 <span class="math inline">\(\Delta_V\)</span>, 输出变量是实际位置偏离期望平衡点 <span class="math inline">\(y_0\)</span> 的距离 <span class="math inline">\(\Delta_y\)</span> 。</p><h3 id="实验内容-4">实验内容</h3><p>仿真中的参数取值如下表所示。</p><table><thead><tr class="header"><th>变量</th><th>参数</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(y_0\)</span></td><td>0.01 m</td></tr><tr class="even"><td><span class="math inline">\(M\)</span></td><td>0.15 kg</td></tr><tr class="odd"><td><span class="math inline">\(g\)</span></td><td>9.81 <span class="math inline">\(m/s^2\)</span></td></tr><tr class="even"><td><span class="math inline">\(K\)</span></td><td>0.0001</td></tr><tr class="odd"><td><span class="math inline">\(R\)</span></td><td>1 <span class="math inline">\(\Omega\)</span></td></tr><tr class="even"><td><span class="math inline">\(L\)</span></td><td>1<span class="math inline">\(H\)</span></td></tr></tbody></table><h4 id="建立状态模型">建立状态模型</h4><p>针对式 (4) 和 (5), 选择状态变量为 <span class="math inline">\(\mathrm{x}=\left[\begin{array}{lll}\Delta_y &amp; \Delta_y &amp; \Delta_i\end{array}\right]^T\)</span>, 输入变量为 <span class="math inline">\(\Delta_V\)</span>, 输出变量为 <span class="math inline">\(\Delta_\nu\)</span>, 列写状态方程和输出方程。</p><p>状态方程： <span class="math display">\[x=Ax+Bu\]</span> 输出方程： <span class="math display">\[y=Cx+D\]</span> 由题中所给的<span class="math inline">\(\mathbf x=[\Delta_y,\dot{\Delta}_y,\Delta_i]^T\)</span>，且 <span class="math display">\[M \ddot{\Delta}_y-\frac{K i_0^2}{y_0^2} \Delta_y+\frac{2 K i_0}{y_0} \Delta_i \approx 0\]</span></p><p><span class="math display">\[\Delta _v=L\dot{\Delta}+R\Delta_i\]</span></p><p>得： <span class="math display">\[A=\left[\begin{array}{ccc}0 &amp; 1 &amp; 0 \\\frac{K \times i_0^2}{M \times y_0^2} &amp; 0 &amp; -\frac{2 \times K \times i_0}{M \times y_0} \\0 &amp; 0 &amp; -\frac{R}{L}\end{array}\right]\]</span></p><p><span class="math display">\[B=[0,0,1]^T,C=[1,0,0],D=0\]</span></p><p>编程计算：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y0=<span class="hljs-number">0.01</span>;<br>M=<span class="hljs-number">0.15</span>;<br>g=<span class="hljs-number">9.81</span>;<br>K=<span class="hljs-number">0.0001</span>;<br>R=<span class="hljs-number">1</span>;<br>L=<span class="hljs-number">1</span>;<br>i0=<span class="hljs-built_in">sqrt</span>(M*g*y0/K);<br>A=[ <span class="hljs-number">0</span>               <span class="hljs-number">1</span>  <span class="hljs-number">0</span>;<br>    K*i0^<span class="hljs-number">2</span>/(M*y0^<span class="hljs-number">2</span>) <span class="hljs-number">0</span> <span class="hljs-number">-2</span>*K*i0/(M*y0);<br>    <span class="hljs-number">0</span>               <span class="hljs-number">0</span> -R/L]<br>B=[<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;<span class="hljs-number">1</span>/L];<br>C=[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>];<br>D=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>得：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> =<br><br>         <span class="hljs-attribute">0</span>    <span class="hljs-number">1</span>.<span class="hljs-number">0000</span>         <span class="hljs-number">0</span><br>  <span class="hljs-attribute">981</span>.<span class="hljs-number">0000</span>         <span class="hljs-number">0</span>   -<span class="hljs-number">1</span>.<span class="hljs-number">6174</span><br>         <span class="hljs-attribute">0</span>         <span class="hljs-number">0</span>   -<span class="hljs-number">1</span>.<span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><h4 id="绘制输出曲线">绘制输出曲线</h4><p>将系统控制电压设为<span class="math inline">\(V_0\)</span>（即<span class="math inline">\(\Delta_v\)</span>和<span class="math inline">\(\Delta_i\)</span>初值为0）、用手将小球置于偏离预设位置0.01米处（即初值<span class="math inline">\(\Delta_y\)</span>为0.01），绘制系统输出曲线（即松手后小球相对预设位置的偏移量），并根据曲线说明系统稳定性？（提示：可使用lsim命令绘制输出曲线）</p><p>把<span class="math inline">\(\Delta_v,\Delta_i\)</span>初值设为零，<span class="math inline">\(\Delta_y\)</span>初值设为<span class="math inline">\(1\)</span>，绘制系统输出曲线：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307031959393.jpeg" alt="系统输出曲线" /><figcaption aria-hidden="true">系统输出曲线</figcaption></figure><p>代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%上一部分的代码</span><br>x0 = [<span class="hljs-number">0.01</span>;<span class="hljs-number">0</span>;<span class="hljs-number">0</span>];     <span class="hljs-comment">%初始状态</span><br>t = <span class="hljs-number">0</span>:<span class="hljs-number">0.001</span>:<span class="hljs-number">1</span>;<br>u = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(t));  <span class="hljs-comment">%零输入</span><br>sys = ss(A,B,C,D);<br>[y,t,x] = lsim(sys,u,t,x0);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,y);<br>xlabel(<span class="hljs-string">&#x27;t(s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;y(m)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;原系统输出曲线&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="可控性分析">可控性分析</h4><p>可以利用<code>ctrb</code>函数求解可控矩阵，有：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">rank(ctrb(A,B))<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span><br><br>     <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>系统可控。</p><h4 id="极点配置">极点配置</h4><p>如果系统可控，假设所有状态变量可测定（即可测出小球的位置、速度和电流），参考输入为<span class="math inline">\(r=0.001m\)</span>，采用状态反馈方法进行系统设计，如下图所示，给出状态反馈向量？系统要求：调节时间小于0.5秒、超调小于5%。（提示：可使用place或acker进行极点配置）。考虑与实验内容2相同的初始状态，绘制系统输出曲线，并验证：</p><ol type="1"><li>是否满足设计要求？</li><li>小球能否稳定在参考位置处，测定稳态误差并分析原因？</li></ol><p>对于该三阶系统，设置一个极点远离虚轴，将系统简化为一个二阶系统。由于要求调节时间小于0.5s，超调量小于5%，故将超调量设为4%，由 <span class="math display">\[M_p=e^{-\frac{\pi\xi}{\sqrt{1-\xi^2}}}\]</span> 可求得<span class="math inline">\(\xi=1/\sqrt 2\)</span>。设置<span class="math inline">\(\omega_n=35\sqrt 2\)</span>，则<span class="math inline">\(t_s=0.114s\)</span>。</p><p>进行状态反馈后，用<code>place</code>函数进行极点配置，得到 <span class="math display">\[K=[-2.16e6,-4.54e4,1069]\]</span> 并在参考输入为<span class="math inline">\(r=0.001m\)</span>得到新的偏移量输出曲线如下:</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202307032001124.jpeg" /></p><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%上一部分的代码</span><br>damp = <span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>);<br>wn = <span class="hljs-number">35</span>*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>);              <br>p1 = -damp*wn+wn*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>-damp^<span class="hljs-number">2</span>)*<span class="hljs-number">1</span><span class="hljs-built_in">i</span>;  <br>p2 = -damp*wn-wn*<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>-damp^<span class="hljs-number">2</span>)*<span class="hljs-number">1</span><span class="hljs-built_in">i</span>;    <br>p3 = <span class="hljs-number">-1000</span>;<br>K = place(A,B,[p1 p2 p3]);    <span class="hljs-comment">%状态反馈向量</span><br>r = <span class="hljs-number">0.001</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(t));<br>sys_c = ss(A-B*K,B,C,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>lsim(sys_c,r,t,x0);<br>title(<span class="hljs-string">&#x27;极点配置后系统输出曲线&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="" alt="image-20230703200824021" /><figcaption aria-hidden="true">image-20230703200824021</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理Matlab软件作业</title>
    <link href="/2023/06/30/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86Matlab%E8%BD%AF%E4%BB%B6%E4%BD%9C%E4%B8%9A/"/>
    <url>/2023/06/30/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86Matlab%E8%BD%AF%E4%BB%B6%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>《通信原理》课程的实践部分包含了四次Matlab作业，两个Matlab仿真实验和两个上电路板的虚拟仿真实验。涉及到Matlab编程的部分在下面，虚拟仿真实验的文件和报告在全文最后供下载。</p><span id="more"></span><h2 id="matlab作业一线性调制">Matlab作业一：线性调制</h2><p>(同上机实验一)</p><p>分别用计算机仿真AM、DSB、SSB模拟调制、解调过程，其中，调制信号（基带信号）<span class="math inline">\(m(t)=\cos 2\pi f_mt\)</span>。调制信号与载波频率自定，要求调制信号频率远小于载波频率。信号时长为8个调制信号周期。</p><p>输出结果包括：</p><ol type="1"><li><p>输入信号波形；</p></li><li><p>载波波形；</p></li><li><p>已调信号波形及其包络；</p></li><li><p>已调信号功率谱；</p></li><li><p>相干解调下变频之后、低通滤波之前的信号波形；</p></li><li><p>相干解调低通滤波之后的信号波形。</p></li></ol><h3 id="实验结果">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302202166.png" alt="AM调制" /><figcaption aria-hidden="true">AM调制</figcaption></figure><p>AM调制相关的图像如上所示。已调信号的包络完全反映了调制信号的波形。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302202293.png" alt="DSB调制" /><figcaption aria-hidden="true">DSB调制</figcaption></figure><p>DSB调制相关的图像如上所示。已调信号的包络不能完全反映调制信号的波形。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302203053.png" alt="SSB调制" /><figcaption aria-hidden="true">SSB调制</figcaption></figure><p>SSB调制相关的图像如上所示。已调信号的包络也不能完全反映调制信号的波形。</p><h3 id="实验代码">实验代码</h3><h4 id="am">AM</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.001</span>;<br>fm=<span class="hljs-number">1</span>;<br>fc=<span class="hljs-number">100</span>;<br>T=<span class="hljs-number">4</span>;<br>t=<span class="hljs-number">0</span>:dt:T;<br>mt=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);<span class="hljs-comment">%信号源</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;调制信号&#x27;</span>)<br>s_dsb=modulate(mt,fc,<span class="hljs-number">1</span>/dt,<span class="hljs-string">&#x27;am&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t,<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t));<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;载波信号&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t,s_dsb,t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;已调信号波形及其包络&#x27;</span>);<br>rt=s_dsb.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调下变频之后、低通滤波之前的信号波形&#x27;</span>);<br>[f,rf]=T2F(t,rt);<br>[t,rt]=bpf(f,rf,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*fm);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调低通滤波之后的信号波形&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br>    dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>    T=t(<span class="hljs-keyword">end</span>);<br>    df=<span class="hljs-number">1</span>/T;<br>    N=<span class="hljs-built_in">length</span>(st);<br>    f=-N/<span class="hljs-number">2</span> * df : df : N/<span class="hljs-number">2</span>*df-df;<br>    sf = fft(st);<br>    sf=T/N * fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>    dt=<span class="hljs-number">1</span>/Fmx;<br>    N=<span class="hljs-built_in">length</span>(sf);<br>    T=dt*N;<br>    t=<span class="hljs-number">0</span>:dt:T-dt;<br>    sff=ifftshift(sf);<br>    st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">bpf</span><span class="hljs-params">(f,sf,B1,B2)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    T=<span class="hljs-number">1</span>/df;<br>    hf=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(f));<br>    bf=[<span class="hljs-built_in">floor</span>(B1/df):<span class="hljs-built_in">floor</span>(B2/df)];<br>    bf1=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)+bf;<br>    bf2=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)-bf;<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    yf=hf.*sf.*<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f*<span class="hljs-number">0.1</span>*T);<br>    [t,st]=F2T(f,yf);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="dsb">DSB</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.001</span>;<br>fm=<span class="hljs-number">1</span>;<br>fc=<span class="hljs-number">100</span>;<br>T=<span class="hljs-number">4</span>;<br>t=<span class="hljs-number">0</span>:dt:T;<br>mt=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);<span class="hljs-comment">%信号源</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;调制信号&#x27;</span>)<br>s_dsb=modulate(mt,fc,<span class="hljs-number">1</span>/dt,<span class="hljs-string">&#x27;amdsb-tc&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t,<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t));<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;载波信号&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t,s_dsb);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;已调信号波形&#x27;</span>);<br>rt=s_dsb.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调下变频之后、低通滤波之前的信号波形&#x27;</span>);<br>[f,rf]=T2F(t,rt);<br>[t,rt]=bpf(f,rf,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*fm);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调低通滤波之后的信号波形&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br>dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>T=t(<span class="hljs-keyword">end</span>);<br>df=<span class="hljs-number">1</span>/T;<br>N=<span class="hljs-built_in">length</span>(st);<br>f=-N/<span class="hljs-number">2</span> * df : df : N/<span class="hljs-number">2</span>*df-df;<br>sf = fft(st);<br>sf=T/N * fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>dt=<span class="hljs-number">1</span>/Fmx;<br>N=<span class="hljs-built_in">length</span>(sf);<br>T=dt*N;<br>t=<span class="hljs-number">0</span>:dt:T-dt;<br>sff=ifftshift(sf);<br>st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">bpf</span><span class="hljs-params">(f,sf,B1,B2)</span></span><br>df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>T=<span class="hljs-number">1</span>/df;<br>hf=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(f));<br>bf=[<span class="hljs-built_in">floor</span>(B1/df):<span class="hljs-built_in">floor</span>(B2/df)];<br>bf1=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)+bf;<br>bf2=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)-bf;<br>hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>yf=hf.*sf.*<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f*<span class="hljs-number">0.1</span>*T);<br>[t,st]=F2T(f,yf);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h4 id="ssb">SSB</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.001</span>;<br>fm=<span class="hljs-number">1</span>;<br>fc=<span class="hljs-number">100</span>;<br>T=<span class="hljs-number">4</span>;<br>t=<span class="hljs-number">0</span>:dt:T;<br>mt=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);<span class="hljs-comment">%信号源</span><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,mt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;调制信号&#x27;</span>)<br>s_dsb=modulate(mt,fc,<span class="hljs-number">1</span>/dt,<span class="hljs-string">&#x27;amssb&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t,<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t));<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;载波信号&#x27;</span>)<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t,s_dsb);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;已调信号波形&#x27;</span>);<br>rt=s_dsb.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调下变频之后、低通滤波之前的信号波形&#x27;</span>);<br>[f,rf]=T2F(t,rt);<br>[t,rt]=bpf(f,rf,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*fm);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-built_in">plot</span>(t,rt);<span class="hljs-built_in">hold</span> on;<br>title(<span class="hljs-string">&#x27;相干解调低通滤波之后的信号波形&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br>    dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>    T=t(<span class="hljs-keyword">end</span>);<br>    df=<span class="hljs-number">1</span>/T;<br>    N=<span class="hljs-built_in">length</span>(st);<br>    f=-N/<span class="hljs-number">2</span> * df : df : N/<span class="hljs-number">2</span>*df-df;<br>    sf = fft(st);<br>    sf=T/N * fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>    dt=<span class="hljs-number">1</span>/Fmx;<br>    N=<span class="hljs-built_in">length</span>(sf);<br>    T=dt*N;<br>    t=<span class="hljs-number">0</span>:dt:T-dt;<br>    sff=ifftshift(sf);<br>    st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">bpf</span><span class="hljs-params">(f,sf,B1,B2)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    T=<span class="hljs-number">1</span>/df;<br>    hf=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(f));<br>    bf=[<span class="hljs-built_in">floor</span>(B1/df):<span class="hljs-built_in">floor</span>(B2/df)];<br>    bf1=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)+bf;<br>    bf2=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(f)/<span class="hljs-number">2</span>)-bf;<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    hf(bf1)=<span class="hljs-number">1</span>/<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*(B2-B1));<br>    yf=hf.*sf.*<span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*f*<span class="hljs-number">0.1</span>*T);<br>    [t,st]=F2T(f,yf);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h2 id="matlab作业二非线性调制">Matlab作业二：非线性调制</h2><p>用计算机仿真FM调制，其中，调制信号（基带信号）<span class="math inline">\(m(t)=\cos 2\pi f_mt\)</span>。调制信号与载波频率、幅度、调制指数等参数自定，要求调制信号频率远小于载波频率。信号时长为4个调制信号周期。</p><p>画出以下结果：</p><ol type="1"><li><p>输入信号波形；</p></li><li><p>载波波形；</p></li><li><p>已调信号波形及其包络；</p></li><li><p>试用fft分析已调波形功率谱（附加题，只加分，不减分）。</p></li></ol><h3 id="实验结果-1">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232226555.jpg" alt="FM调制图像" /><figcaption aria-hidden="true">FM调制图像</figcaption></figure><h3 id="实验代码-1">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 参数设置</span><br>fm = <span class="hljs-number">100</span>;               <span class="hljs-comment">% 调制信号频率</span><br>fc = <span class="hljs-number">1000</span>;             <span class="hljs-comment">% 载波频率</span><br>kf = <span class="hljs-number">800</span>;               <span class="hljs-comment">% 调制指数</span><br>fs = <span class="hljs-number">20000</span>;            <span class="hljs-comment">% 采样率</span><br>t = <span class="hljs-number">0</span>: <span class="hljs-number">1</span>/fs :<span class="hljs-number">4</span>/fm<span class="hljs-number">-1</span>/fs;  <span class="hljs-comment">% 时间向量，4个调制信号周期</span><br><br><span class="hljs-comment">% 生成调制信号</span><br>m = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fm*t);    <span class="hljs-comment">% 基带信号</span><br><br><span class="hljs-comment">% 生成载波信号</span><br>c = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t);    <span class="hljs-comment">% 载波信号</span><br><br><span class="hljs-comment">% FM 调制</span><br>s = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t + kf * <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * fm * t) / fm);<br><br><span class="hljs-comment">% 绘制输入信号波形</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t, m);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>title(<span class="hljs-string">&#x27;输入信号波形 (基带信号)&#x27;</span>);<br>grid on;<br><br><span class="hljs-comment">% 绘制载波波形</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(t, c);<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>title(<span class="hljs-string">&#x27;载波波形&#x27;</span>);<br>grid on;<br><br><span class="hljs-comment">% 绘制调制信号波形及其包络</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t, s);<br><span class="hljs-built_in">hold</span> on;<br>envelope = <span class="hljs-built_in">abs</span>(hilbert(s));    <span class="hljs-comment">% 计算调制信号包络</span><br><span class="hljs-comment">% plot(t, envelope, &#x27;r&#x27;);</span><br><span class="hljs-built_in">hold</span> off;<br>xlabel(<span class="hljs-string">&#x27;时间 (s)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>title(<span class="hljs-string">&#x27;调制信号波形及其包络&#x27;</span>);<br><span class="hljs-comment">% legend(&#x27;调制信号&#x27;, &#x27;包络&#x27;);</span><br>grid on;<br><br><span class="hljs-comment">% FFT 分析已调波形的功率谱</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>L = <span class="hljs-built_in">length</span>(s);                  <span class="hljs-comment">% 信号长度</span><br>f = (-fs/<span class="hljs-number">2</span>:fs/L:fs/<span class="hljs-number">2</span>-fs/L);     <span class="hljs-comment">% 频率向量</span><br>S = fftshift(fft(s));           <span class="hljs-comment">% 进行 FFT</span><br>P = <span class="hljs-built_in">abs</span>(S).^<span class="hljs-number">2</span> / L;              <span class="hljs-comment">% 计算功率谱</span><br><span class="hljs-built_in">plot</span>(f, P);<br>xlabel(<span class="hljs-string">&#x27;频率 (Hz)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;功率&#x27;</span>);<br>title(<span class="hljs-string">&#x27;已调波形功率谱&#x27;</span>);<br>grid on;<br></code></pre></td></tr></table></figure><h2 id="matlab作业三模拟信号数字化">Matlab作业三：模拟信号数字化</h2><p>用计算机仿真模拟信号数字化系统过程。量化器为均匀量化，量化范围<span class="math inline">\([-1,1]\)</span>V；输入信号假设服从均匀分布。二进制信道传输误比特率<span class="math inline">\(P=10^{-5}\)</span>。</p><p>分别仿真得到以下曲线，并将它们绘制在一张图中：</p><ol type="1"><li>量化比特<span class="math inline">\(N=11\)</span>（含符号位）、采用自然码编码时，作出输入信号平均功率从<span class="math inline">\(-60dBW\)</span>至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li><li>量化比特<span class="math inline">\(N=11\)</span>（含符号位）、采用折叠码编码时，作出输入信号平均功率从-60dBW至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li><li>量化比特<span class="math inline">\(N=12\)</span>（含符号位）、采用自然码编码时，作出输入信号平均功率从-60dBW至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li><li>量化比特<span class="math inline">\(N=12\)</span>（含符号位）、采用折叠码编码时，作出输入信号平均功率从-60dBW至0dBW（电阻1欧）间变化时输出信噪比变化曲线；</li></ol><p>关键：如何统计输出信噪比，关键是统计平均输出噪声功率按照输入信号平均功率生成多个（如10000）个样值，对每一个样值作为输入信号，进行量化、编码、信道传输（产生随机误码）和译码，将恢复出的样值与输入样值作差取平方得到样值误差功率。最后，取平均得到平均输出噪声功率。</p><h3 id="实验结果-2">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232235729.jpg" alt="仿真结果图" /><figcaption aria-hidden="true">仿真结果图</figcaption></figure><p>可以看出：在输入信号功率不大时，信噪比（dB）和功率（dB）成正比。当功率较大时，因为超出了量化范围，所以信噪比急剧减小。</p><h3 id="实验代码-2">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 信号数字化系统仿真模拟</span><br><br>P_in = <span class="hljs-built_in">logspace</span>(<span class="hljs-number">-3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">% 平均功率从-60dBW至0dBW（电阻1欧）间变化</span><br>SNR1=PCM(P_in,<span class="hljs-number">11</span>,<span class="hljs-number">0</span>);<br>SNR2=PCM(P_in,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>);<br>SNR3=PCM(P_in,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>);<br>SNR4=PCM(P_in,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>);<br>loglog(P_in,SNR1,<span class="hljs-string">&#x27;r.-&#x27;</span>,P_in,SNR2,<span class="hljs-string">&#x27;g.-&#x27;</span>,P_in,SNR3,<span class="hljs-string">&#x27;b.-&#x27;</span>,P_in,SNR4,<span class="hljs-string">&#x27;k.-&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;11位自然码&#x27;</span>, <span class="hljs-string">&#x27;11位折叠码&#x27;</span>,<span class="hljs-string">&#x27;12位自然码&#x27;</span>,<span class="hljs-string">&#x27;12位折叠码&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;输入信号功率&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;信噪比&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SNRs</span> = <span class="hljs-title">PCM</span><span class="hljs-params">(P_in,bits,TYPE)</span></span><br>    <span class="hljs-comment">% 编码，计算信噪比</span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">%   P_in：输入信号平均功率测试点</span><br>    <span class="hljs-comment">%   bits：量化比特数（含符号位）</span><br>    <span class="hljs-comment">%   TYPE：码型，0为自然码，1为折叠码</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">%   SNRs：对每个P_in的元素而言的平均噪声功率</span><br>    <br><br>    qrange = <span class="hljs-number">1</span>;  <span class="hljs-comment">% 量化范围</span><br><br>    L=<span class="hljs-built_in">length</span>(P_in);<br>    SNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L <span class="hljs-comment">%对每个功率P_in</span><br>    <br>        <span class="hljs-comment">% 生成符合功率要求的输入信号</span><br>        x_num=<span class="hljs-number">10000</span>;<br>        x = unifrnd(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,x_num);<br>        Px = sum(x .* x) / x_num;<br>        k = <span class="hljs-built_in">sqrt</span>(P_in(<span class="hljs-built_in">i</span>) / Px);<br>        x = x.*k;<br>        <br>        <span class="hljs-comment">%量化x</span><br>        delta = qrange / (<span class="hljs-number">2</span>^(bits<span class="hljs-number">-1</span>));<br>        x_level=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">abs</span>(x)./delta);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(x_level)<br>            <span class="hljs-keyword">if</span> x_level(<span class="hljs-built_in">j</span>)&gt;<span class="hljs-number">2</span>^(bits<span class="hljs-number">-1</span>)<br>                x_level(<span class="hljs-built_in">j</span>)=<span class="hljs-number">2</span>^(bits<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        x_q = <span class="hljs-built_in">sign</span>(x) .* (x_level .* delta + <span class="hljs-number">0.5</span>*delta);<br>        y_signal=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,x_num);<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:x_num <span class="hljs-comment">%对x信号中的每个点</span><br>            <span class="hljs-comment">%编码</span><br>            x_signal=x_q(<span class="hljs-built_in">j</span>);<br><br>            <span class="hljs-keyword">if</span>(x_signal&gt;<span class="hljs-number">0</span>)<br>                x_code=<span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-keyword">else</span><br>                x_code=<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">end</span><br>            x_bin=dec2bin(x_level(<span class="hljs-built_in">j</span>),bits<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">if</span>(TYPE==<span class="hljs-number">0</span>) <span class="hljs-comment">%自然码把对称码按位反转</span><br>                x_bin=flip(x_bin);<br>            <span class="hljs-keyword">end</span><br>            x_code=strcat(x_code,x_bin);<br>            <span class="hljs-comment">%传输</span><br>            BER = <span class="hljs-number">1e-5</span>;  <span class="hljs-comment">% 误比特率</span><br>            y_code=bsc(x_code,BER);<br>            <span class="hljs-comment">%译码</span><br>            y_bin=extractAfter(y_code,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(TYPE==<span class="hljs-number">0</span>) <span class="hljs-comment">%自然码把对称码按位反转</span><br>                y_bin=flip(y_bin);<br>            <span class="hljs-keyword">end</span><br>            y_level=bin2dec(y_bin);<br>            y_signal(<span class="hljs-built_in">j</span>)=y_level .* delta + <span class="hljs-number">0.5</span>*delta;<br>            <span class="hljs-keyword">if</span>(y_code(<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;0&#x27;</span>) <br>                 y_signal(<span class="hljs-built_in">j</span>) = y_signal(<span class="hljs-built_in">j</span>) * <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        error = y_signal - x;<br>        P_error = sum(error .* error) / x_num;<br>        SNR(<span class="hljs-built_in">i</span>)=P_in(<span class="hljs-built_in">i</span>) / P_error;<br>    <span class="hljs-keyword">end</span><br>    SNRs=SNR;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">bsc</span><span class="hljs-params">(x, BER)</span></span><br>    <span class="hljs-comment">% 二进制对称信道传输</span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">%   x：输入比特序列（0或1向量）</span><br>    <span class="hljs-comment">%   BER：误比特率</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">%   y：输出比特序列（0或1向量）</span><br>    s=<span class="hljs-built_in">size</span>(x);<br>    y=<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(x));<br>    y=char(y);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:s(<span class="hljs-number">2</span>)<br>        flag=<span class="hljs-built_in">rand</span>();<br>        <span class="hljs-keyword">if</span>(flag&gt;BER)<br>            y(<span class="hljs-built_in">i</span>)=x(<span class="hljs-built_in">i</span>);<br>        <span class="hljs-keyword">else</span><br>            temp=[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>];<br>            y(<span class="hljs-built_in">i</span>)=temp((x(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">flip</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-comment">%把01字符串序列反转</span><br>    <span class="hljs-comment">%输入：</span><br>    <span class="hljs-comment">%   x：原序列</span><br>    <span class="hljs-comment">%输出：</span><br>    <span class="hljs-comment">%   y：反转序列</span><br>    L=<span class="hljs-built_in">length</span>(x);<br>    y=x;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L<br>        <span class="hljs-keyword">if</span> x(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;1&#x27;</span><br>            y(<span class="hljs-built_in">i</span>)=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            y(<span class="hljs-built_in">i</span>)=<span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="matlab作业四数字信号基带传输">Matlab作业四：数字信号基带传输</h2><ol type="1"><li><p>用计算机画出升余弦滤波器时域、频域曲线；以及根升余弦滤波器时域、频域曲线。参数自定。</p></li><li><p>试用matlab仿真单极性非归零码、双极性非归零码的误码率，并将其误码率曲线绘制在一张图中。输入信噪比（x轴）变化范围为0:1:15dB，绘图函数<code>semilogy</code>，每个信噪比统计误码率时仿真的点数为1e5。（注：基本方法是随机产生1e5个二进制比特，然后进行码型映射，再给码型叠加噪声（按照信噪比计算噪声功率），最后进行判决，统计误码率）。</p></li></ol><h3 id="实验结果-3">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232242272.jpg" alt="滤波器" /><figcaption aria-hidden="true">滤波器</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305232243276.jpg" alt="误码率" /><figcaption aria-hidden="true">误码率</figcaption></figure><h3 id="实验代码-3">实验代码</h3><h4 id="滤波器实验">滤波器实验</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear all;<br>Fs = <span class="hljs-number">100</span>;<br>Ts = <span class="hljs-number">0.1</span>;<br>t = <span class="hljs-number">-5</span>*Ts:<span class="hljs-number">1</span>/Fs:<span class="hljs-number">5</span>*Ts;<br><br><span class="hljs-built_in">beta</span> = <span class="hljs-number">0.5</span>; <span class="hljs-comment">%升余弦滤波器参数</span><br><br>sinc_t=sinc(t/Ts)/Ts; <span class="hljs-comment">%系数</span><br>rc_tnum=<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">pi</span>*<span class="hljs-built_in">beta</span>*t/Ts); <span class="hljs-comment">%分子</span><br>rc_tden=<span class="hljs-number">1</span>-(<span class="hljs-number">2</span>*<span class="hljs-built_in">beta</span>*t/Ts).^<span class="hljs-number">2</span>; <span class="hljs-comment">%分母</span><br>pn=<span class="hljs-built_in">find</span>(<span class="hljs-built_in">abs</span>(rc_tden)&lt;<span class="hljs-number">1e-8</span>); <span class="hljs-comment">%除以零特判</span><br>rc_tden(pn) = <span class="hljs-built_in">inf</span>;<br>rc_t = rc_tnum./rc_tden;<br>gt = sinc_t .* rc_t;<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,gt);<br>xlabel(<span class="hljs-string">&#x27;时间&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;h(t)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;升余弦滤波器时域波形&#x27;</span>);<br><br>[f,sf]=T2F(t,gt);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(f,<span class="hljs-built_in">abs</span>(sf));<br>xlabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;H(w)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;升余弦滤波器频域波形&#x27;</span>);<br><br>sf2=<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(sf)) .* <span class="hljs-built_in">exp</span>(<span class="hljs-built_in">i</span>*<span class="hljs-built_in">angle</span>(sf));<br>[t2,st2]=F2T(f,sf2);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(t2,st2);<br>xlabel(<span class="hljs-string">&#x27;时间&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;h(t)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;根升余弦滤波器时域波形&#x27;</span>);<br><br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br><span class="hljs-built_in">plot</span>(f,<span class="hljs-built_in">abs</span>(sf2));<br>xlabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;H(w)&#x27;</span>);<br>title(<span class="hljs-string">&#x27;根升余弦滤波器频域波形&#x27;</span>);<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[f,sf]</span> = <span class="hljs-title">T2F</span><span class="hljs-params">(t,st)</span></span><br><span class="hljs-comment">%   时域转频域</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       t：时间</span><br><span class="hljs-comment">%       st：时间函数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%      f：频率</span><br><span class="hljs-comment">%      sf：频率函数</span><br>    <br>    dt=t(<span class="hljs-number">2</span>)-t(<span class="hljs-number">1</span>);<br>    T=t(<span class="hljs-keyword">end</span>)-t(<span class="hljs-number">1</span>);<br>    df=<span class="hljs-number">1.0</span>/T;<br>    N=<span class="hljs-built_in">length</span>(st);<br>    f=((-N/<span class="hljs-number">2</span>) * df):df:(((N/<span class="hljs-number">2</span>)*df)-df);<br>    sf = fft(st);<br>    sf=T/N*fftshift(sf);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[t,st]</span> = <span class="hljs-title">F2T</span><span class="hljs-params">(f,sf)</span></span><br>    df=f(<span class="hljs-number">2</span>)-f(<span class="hljs-number">1</span>);<br>    Fmx=(f(<span class="hljs-keyword">end</span>)-f(<span class="hljs-number">1</span>)+df);<br>    dt=<span class="hljs-number">1</span>/Fmx;<br>    N=<span class="hljs-built_in">length</span>(sf);<br>    T=dt*N;<br>    t=-T/<span class="hljs-number">2</span>:dt:T/<span class="hljs-number">2</span>-dt;<br>    sff=ifftshift(sf);<br>    st=Fmx*ifft(sff);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="误码率实验">误码率实验</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 仿真参数设置</span><br>SNR_dB = <span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">15</span>;     <span class="hljs-comment">% 信噪比范围（dB）</span><br>numBits = <span class="hljs-number">1e5</span>;       <span class="hljs-comment">% 仿真比特数</span><br><br>BER_NRZ = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(SNR_dB));<br>BER_RZ = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(SNR_dB));<br><br><span class="hljs-comment">% 随机产生比特序列</span><br>bits = randi([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-number">1</span>, numBits);<br><br><span class="hljs-comment">% 进行误码率仿真</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(SNR_dB)<br>    <span class="hljs-comment">% 生成高斯噪声</span><br>    noisePower = <span class="hljs-number">10</span>^(-SNR_dB(<span class="hljs-built_in">i</span>)/<span class="hljs-number">10</span>);   <span class="hljs-comment">% 噪声功率</span><br>    noise = <span class="hljs-built_in">sqrt</span>(noisePower) * <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, numBits);<br>    <br>    <span class="hljs-comment">% 单极性非归零码</span><br>    signal_NRZ = bits;     <br>    receivedSignal_NRZ = signal_NRZ + noise;<br>    <span class="hljs-comment">% 判决</span><br>    decodedBits_NRZ = receivedSignal_NRZ &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">% 误码率</span><br>    BER_NRZ(<span class="hljs-built_in">i</span>) = sum(bits ~= decodedBits_NRZ) / numBits;<br>    <br>    <span class="hljs-comment">% 双极性非归零码</span><br>    signal_RZ = <span class="hljs-number">2</span>*bits - <span class="hljs-number">1</span>;   <br>    receivedSignal_RZ = signal_RZ + noise;<br>    <span class="hljs-comment">% 判决</span><br>    decodedBits_RZ = receivedSignal_RZ &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">% 统计误码率</span><br>    BER_RZ(<span class="hljs-built_in">i</span>) = sum(bits ~= decodedBits_RZ) / numBits;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 绘制误码率曲线</span><br>semilogy(SNR_dB, BER_NRZ, <span class="hljs-string">&#x27;b-o&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_dB, BER_RZ, <span class="hljs-string">&#x27;r-*&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">hold</span> off;<br><br>xlabel(<span class="hljs-string">&#x27;信噪比 (dB)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;误码率&#x27;</span>);<br>title(<span class="hljs-string">&#x27;单极性非归零码（NRZ）与双极性非归零码（RZ）误码率曲线&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;NRZ&#x27;</span>, <span class="hljs-string">&#x27;RZ&#x27;</span>);<br>grid on;<br></code></pre></td></tr></table></figure><h2 id="上机实验二pcm-编码调制的-matlab-实现">上机实验二：PCM 编码调制的 MATLAB 实现</h2><p>设模拟信号<span class="math inline">\(x(t)=0.1\cos(0.15t)+1.5\sin (2.5t)+0.5\cos(4t)\)</span>，选取适当的抽样频率（需要满足无失真采样要求）。</p><ol type="1"><li>采用均匀量化，量化层数为各自学号的后四位mod（4）+4（例如学号为 19835412，后四位5412除以4求余为0，再加4为4），请设计均匀量化编码程序。</li><li>采用非均匀量化，设计A律13折线法的PCM编码程序</li></ol><p>要求输出：</p><ol type="1"><li>原始输入信号</li><li>抽样后信号</li><li>量化输出信号</li><li>编码结果</li></ol><h3 id="实验结果-4">实验结果</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304121656595.jpg" alt="均匀量化" /><figcaption aria-hidden="true">均匀量化</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304121656059.jpg" alt="A律13折线量化" /><figcaption aria-hidden="true">A律13折线量化</figcaption></figure><h3 id="实验代码-4">实验代码</h3><h4 id="均匀量化">均匀量化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.01</span>;<br>t=[<span class="hljs-number">0</span>:dt:<span class="hljs-number">20</span>];<br>xt=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,xt);<br>title(<span class="hljs-string">&quot;均匀量化原始输入信号&quot;</span>);<br><br><span class="hljs-comment">%抽样</span><br>fs=<span class="hljs-number">4</span>;<br>sdt=<span class="hljs-number">1</span>/fs;<br>t1=[<span class="hljs-number">0</span>:sdt:<span class="hljs-number">20</span>];<br>xt1=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t1)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t1)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t1);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>stem(t1,xt1,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化抽样后信号&quot;</span>);<br><br><span class="hljs-comment">%量化</span><br>N=<span class="hljs-built_in">mod</span>(<span class="hljs-number">5412</span>,<span class="hljs-number">4</span>)+<span class="hljs-number">4</span>; <span class="hljs-comment">%量化层数 为学号后四位%4+4</span><br>a=<span class="hljs-number">2.1</span>; <span class="hljs-comment">%幅度最大值</span><br>reg=[-a,a];<br>delta=(<span class="hljs-number">2</span>*a/N);<br>x_qt=xt1;<br>bit=<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(N));<br>code=<span class="hljs-string">&#x27;&#x27;</span>;<br>L=<span class="hljs-built_in">length</span>(t1);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>:N<br>        low=-a+<span class="hljs-built_in">j</span>*delta;<br>        high=low+delta;<br>        <span class="hljs-keyword">if</span> (low&lt;=xt1(<span class="hljs-built_in">i</span>) &amp;&amp; xt1(<span class="hljs-built_in">i</span>)&lt;=high)<br>            x_qt(<span class="hljs-built_in">i</span>)=low+delta/<span class="hljs-number">2</span>;<br>            code=strcat(code,dec2bin(<span class="hljs-built_in">j</span>,bit));<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>stem(t1,x_qt,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化输出信号&quot;</span>);<br>code<br><br>code_in_num=<span class="hljs-built_in">zeros</span>(bit*L);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:bit*L<br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>stem(<span class="hljs-number">1</span>:bit*L,code_in_num,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化输出编码&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="非均匀量化">非均匀量化</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dt=<span class="hljs-number">0.01</span>;<br>t=[<span class="hljs-number">0</span>:dt:<span class="hljs-number">10</span>];<br>xt=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(t,xt);<br>title(<span class="hljs-string">&quot;A律13折线原始输入信号&quot;</span>);<br><br>fs=<span class="hljs-number">4</span>;<br>sdt=<span class="hljs-number">1</span>/fs;<br>t1=[<span class="hljs-number">0</span>:sdt:<span class="hljs-number">20</span>];<br>xt1=<span class="hljs-number">0.1</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.15</span>.*t1)+<span class="hljs-number">1.5</span>.*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.5</span>.*t1)+<span class="hljs-number">0.5</span>.*<span class="hljs-built_in">cos</span>(<span class="hljs-number">4.</span>*t1);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>stem(t1,xt1,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;A律13折线抽样后信号&quot;</span>);<br><br>code=<span class="hljs-string">&#x27;&#x27;</span>;<br>a=<span class="hljs-number">2.1</span>;<br>L=<span class="hljs-built_in">length</span>(xt1);<br>x_qt=<span class="hljs-built_in">zeros</span>(L);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:L<br>    codei=<span class="hljs-string">&#x27;&#x27;</span>;<br>    flag=<span class="hljs-number">0</span>;<br>    x=<span class="hljs-built_in">floor</span>(xt1(<span class="hljs-built_in">i</span>)/a*<span class="hljs-number">2048</span>);<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>)<br>        codei=strcat(codei,<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">%符号码</span><br>        flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        codei=strcat(codei,<span class="hljs-string">&#x27;0&#x27;</span>);<br>        x=-x;<br>        flag=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">end</span><br>    <br>    start_level=[<span class="hljs-number">0</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>,<span class="hljs-number">256</span>,<span class="hljs-number">512</span>,<span class="hljs-number">1024</span>,<span class="hljs-number">2048</span>]; <span class="hljs-comment">%段落码电平范围</span><br>    interval   =[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>,  <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>]; <span class="hljs-comment">%量化间隔</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:(<span class="hljs-built_in">length</span>(start_level)<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">if</span>(start_level(<span class="hljs-built_in">j</span>)&lt;x &amp;&amp; x&lt;=start_level(<span class="hljs-built_in">j</span>+<span class="hljs-number">1</span>))<br>            codei=strcat(codei,dec2bin(<span class="hljs-built_in">j</span>,<span class="hljs-number">3</span>));<span class="hljs-comment">%段落码</span><br>            temp=<span class="hljs-built_in">floor</span>( ( x-start_level(<span class="hljs-built_in">j</span>) )/interval(<span class="hljs-built_in">j</span>) );<br>            codei=strcat(codei,dec2bin(temp,<span class="hljs-number">4</span>));<span class="hljs-comment">%段内码</span><br>            x_qt(<span class="hljs-built_in">i</span>)=flag*(start_level(<span class="hljs-built_in">j</span>)+interval(<span class="hljs-built_in">j</span>)*(temp+<span class="hljs-number">0.5</span>))*(a/<span class="hljs-number">2048</span>);<br>            <span class="hljs-comment">%恢复量化电平</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">end</span>   <br>    <span class="hljs-keyword">end</span><br>    code=strcat(code,codei);<br><span class="hljs-keyword">end</span><br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>stem(t1,x_qt,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;A律13折线量化输出信号&quot;</span>);<br><br>bit=<span class="hljs-number">8</span>;<br>code_in_num=<span class="hljs-built_in">zeros</span>(bit*L);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:bit*L<br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(code(<span class="hljs-built_in">i</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)<br>        code_in_num(<span class="hljs-built_in">i</span>)=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>stem(<span class="hljs-number">1</span>:bit*L,code_in_num,<span class="hljs-string">&#x27;.&#x27;</span>);<br>title(<span class="hljs-string">&quot;均匀量化输出编码&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="仿真实验资料">仿真实验资料</h2><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C.zip">通信原理虚拟仿真资料下载</a></p><p>提醒一下哈，这个软件很逆天，你直接双击这个文件是打不开的，得先到那个专用的网站里打开实验，然后等软件弹出，再在软件里面通过“打开文件”的方式才能打开这个文件。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理实验报告</title>
    <link href="/2023/06/30/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/06/30/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>数图成绩出来了，实验是满分，所以把报告和代码发出来给大家参考一下。</p><span id="more"></span><h2 id="实验一-图像变换实验">实验一 图像变换实验</h2><h3 id="实验目的">实验目的</h3><p>学会对图像进行傅立叶等变换，在频谱上对图像进行分析，增进对图像频域上的感性认识，并用图像变换进行压缩。</p><h3 id="实验内容">实验内容</h3><p>对Lena或cameraman图像进行傅立叶、离散余弦、哈达玛变换。在频域，对比他们的变换后系数矩阵的频谱情况，进一步，通过逆变换观察不同变换下的图像重建质量情况。</p><h3 id="实验要求">实验要求</h3><p>实验采用获取的图像，为灰度图像，该图像每象素由8比特表示。具体要求如下：</p><ol type="1"><li><p>对图像进行傅立叶变换、获得变换后的系数矩阵；</p></li><li><p>将傅立叶变换后系数矩阵的频谱用图像输出，观察频谱；</p></li><li><p>通过设定门限，将系数矩阵中95%的（小值）系数置为0，对图像进行反变换，获得逆变换后图像；</p></li><li><p>观察逆变换后图像质量，并比较原始图像与逆变后的峰值信噪比（PSNR）。</p></li><li><p>对输入图像进行离散余弦、哈达玛变换，重复步骤1-5；</p></li><li><p>比较三种变换的频谱情况、以及逆变换后图像的质量（PSNR）。</p></li><li><p>比较相同图像质量（PSNR）下，步骤（3）中三种变换的系数矩阵，最少需要保留的非零元素个数。一般而言，需要保留的非零元素越少，则将这种变换用于图像编码，越易于节省码率。</p></li></ol><h3 id="实验原理">实验原理</h3><p>图像傅里叶变换（Fourier Transform）是一种常用的信号处理技术，用于将图像从空域（时域）转换到频域。它基于傅里叶分析的原理，将图像表示为一系列频率分量的和，从而揭示了图像中不同频率的信息。</p><p>图像傅里叶变换的基本思想是，将一个图像视为不同频率的正弦和余弦波的叠加。通过将图像转换到频域，我们可以得到图像的频谱信息，即不同频率分量的幅度和相位。这使得我们能够分析图像中的高频、低频等特征，并进行一些相关的处理。、</p><p>离散余弦变换将一个图像从空域（时域）转换为频域。与傅里叶变换类似，它将图像表示为一系列频率分量的和，但DCT更适合于图像压缩应用，因为它将图像的大部分能量集中在较低频率分量上。</p><p>图像哈达玛变换的基本原理是基于哈达玛矩阵的线性变换。哈达玛矩阵是一种特殊的正交变换矩阵，具有正交、可逆和对称的性质。</p><h3 id="实验结果与分析">实验结果与分析</h3><p>首先将系数矩阵中95%的（小值）系数置为0，对图像进行反变换，获得逆变换后图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306302028143.jpg" alt="e1" /><figcaption aria-hidden="true">e1</figcaption></figure><table><thead><tr class="header"><th>变换类型</th><th>离散傅里叶变换</th><th>离散余弦变换</th><th>哈达玛变换</th></tr></thead><tbody><tr class="odd"><td>峰值信噪比PSNR</td><td>30.2933</td><td>31.5249</td><td>28.5448</td></tr></tbody></table><p>然后固定取门限后图像的峰值信噪比为PSNR=28.01，得各种变换需要置0的系数比例为：</p><table><thead><tr class="header"><th>变换类型</th><th>离散傅里叶变换</th><th>离散余弦变换</th><th>哈达玛变换</th></tr></thead><tbody><tr class="odd"><td>置0的系数比例</td><td>0.975</td><td>0.9825</td><td>0.9575</td></tr></tbody></table><p>可以看出，在三种变换中，离散余弦变换DCT是最适合进行图像压缩的一种。由频谱可以看出，傅里叶变换和离散余弦变换的频谱均有较明显的能量集中特性，变换域大值聚集在一小块区域，表现出来就是区域灰度值远高于其他区域，呈现亮色。由于这种特性，在变换域去掉 95%小值不至于对原图像效果产生太大影响</p><h3 id="实验代码">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">figure</span>=imread(<span class="hljs-string">&#x27;lena_std.tif&#x27;</span>); <br>gray_figure = rgb2gray(<span class="hljs-built_in">figure</span>);<span class="hljs-comment">%转换为灰度</span><br>gray_figure = im2uint8(gray_figure);<span class="hljs-comment">%转换为8bit</span><br>Size=<span class="hljs-built_in">size</span>(gray_figure);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>)<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>imshow(gray_figure);<br>title(<span class="hljs-string">&#x27;Lena 原图&#x27;</span>);<br><br>tic<br>fourier = fft2(gray_figure); <br>shiftf=fftshift(fourier); <span class="hljs-comment">%将零频分量移到频谱中心</span><br>toc<br>R=<span class="hljs-built_in">real</span>(shiftf); <span class="hljs-comment">% 傅立叶变换实部</span><br>I=<span class="hljs-built_in">imag</span>(shiftf); <span class="hljs-comment">% 傅立叶变换虚部</span><br>spec = <span class="hljs-built_in">sqrt</span>(R.^<span class="hljs-number">2</span>+I.^<span class="hljs-number">2</span>); <span class="hljs-comment">% 幅值</span><br>spec_norm =(spec-<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(spec)))/(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(spec))-<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(spec)))*<span class="hljs-number">255</span>; <span class="hljs-comment">% 归一化</span><br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>imshow(spec_norm); <span class="hljs-comment">% 显示原图像的频谱</span><br>title(<span class="hljs-string">&#x27;傅立叶变换的频谱图&#x27;</span>);<br><br>shiftf=threshold(shiftf,<span class="hljs-number">0.975</span>);<span class="hljs-comment">%0.975</span><br>refigure=ifft2(ifftshift(shiftf))/<span class="hljs-number">256</span> ;<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>imshow(refigure);<br>imwrite(refigure, <span class="hljs-string">&#x27;E1_output_image.tif&#x27;</span>, <span class="hljs-string">&#x27;tif&#x27;</span>);<br>title(<span class="hljs-string">&#x27;取门限后傅里叶变换还原图像&#x27;</span>);<br>PSNR = grayPSNR(gray_figure,<span class="hljs-number">256</span>*refigure,<span class="hljs-number">8</span>); <span class="hljs-comment">%计算 PSNR</span><br>PSNR<br><br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>imshow(gray_figure);<br>title(<span class="hljs-string">&#x27;Lena 原图&#x27;</span>);<br><br>tic<br>DCT=dct2(gray_figure); <span class="hljs-comment">%离散余弦变换</span><br>toc<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>imshow(<span class="hljs-built_in">abs</span>(DCT),[<span class="hljs-number">0</span> <span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;离散余弦变换&#x27;</span>)<br><br>DCT=threshold(DCT,<span class="hljs-number">0.9825</span>);<span class="hljs-comment">%0.9825</span><br>refigure=idct2(DCT);<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<br>imshow(refigure,[<span class="hljs-number">0</span> <span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;取门限后离散余弦变换还原图像&#x27;</span>);<br>PSNR = grayPSNR(gray_figure,refigure,<span class="hljs-number">8</span>); <span class="hljs-comment">%计算 PSNR</span><br>PSNR<br><br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>);<br>imshow(gray_figure);<br>title(<span class="hljs-string">&#x27;Lena 原图&#x27;</span>);<br><br>tic<br>H=<span class="hljs-built_in">hadamard</span>(Size(<span class="hljs-number">1</span>));<span class="hljs-comment">%哈达玛矩阵</span><br>gray_figure=double(gray_figure);<br>DHT=H*gray_figure*H./(<span class="hljs-number">512</span>^<span class="hljs-number">2</span>);<br>toc<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>);<br>imshow(DHT*<span class="hljs-number">2</span>^<span class="hljs-number">10</span>,[<span class="hljs-number">0</span>,<span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;哈达玛变换&#x27;</span>)<br><br>DHT=threshold(DHT,<span class="hljs-number">0.9575</span>);<span class="hljs-comment">%0.9575</span><br>refigure=H*DHT*H;<br>subplot(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>);<br>imshow(refigure,[<span class="hljs-number">0</span>,<span class="hljs-number">255</span>]);<br>title(<span class="hljs-string">&#x27;取门限后哈达玛变换还原图像&#x27;</span>);<br>PSNR = grayPSNR(gray_figure,refigure,<span class="hljs-number">8</span>); <span class="hljs-comment">%计算 PSNR</span><br>PSNR<br><br><span class="hljs-comment">% fourier = fft2(gray_figure); </span><br><span class="hljs-comment">% shiftf=fftshift(fourier); </span><br><span class="hljs-comment">% P=0.9:0.005:1.0;</span><br><span class="hljs-comment">% PSNRs=zeros(size(P));</span><br><span class="hljs-comment">% S=size(P);</span><br><span class="hljs-comment">% for i=1:S(2)</span><br><span class="hljs-comment">%     shiftf_temp=threshold(shiftf,P(i));</span><br><span class="hljs-comment">%     refigure=ifft2(ifftshift(shiftf_temp))/256 ;</span><br><span class="hljs-comment">%     PSNRs(i)=grayPSNR(gray_figure,256*refigure,8);</span><br><span class="hljs-comment">% end</span><br><span class="hljs-comment">% subplot(4,3,10);</span><br><span class="hljs-comment">% plot(P,PSNRs);</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PSNR</span> = <span class="hljs-title">grayPSNR</span><span class="hljs-params">(img1,img2,bit)</span></span><br><span class="hljs-comment">%   计算图像的峰值信噪比PSNR</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       img1：标准图像</span><br><span class="hljs-comment">%       img2：待比较图像</span><br><span class="hljs-comment">%       bit：图像每像素比特数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       PSNR：峰值信噪比（dB）</span><br>    Size=<span class="hljs-built_in">size</span>(img1);<br>    h=Size(<span class="hljs-number">1</span>);<br>    w=Size(<span class="hljs-number">2</span>);<br>    MAX=<span class="hljs-number">2</span>^bit<span class="hljs-number">-1</span>;<br>    img1=double(img1);<br>    img2=double(img2);<br>    MSE=sum(sum((img1-img2).^<span class="hljs-number">2</span>))/(h*w);     <span class="hljs-comment">% 均方差  </span><br>    PSNR=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(MAX/<span class="hljs-built_in">sqrt</span>(MSE));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matrix</span> = <span class="hljs-title">threshold</span><span class="hljs-params">(mat,P)</span></span><br><span class="hljs-comment">%   保留矩阵一定比例的数值而把其它点置零</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       mat：待操作矩阵，复数按幅值算</span><br><span class="hljs-comment">%       P：保留的比例（前P大的数值将被保留）</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       matrix：操作后的矩阵</span><br>    matrix=mat;<br>    Size=<span class="hljs-built_in">size</span>(mat);<br>    height=Size(<span class="hljs-number">1</span>);<br>    width=Size(<span class="hljs-number">2</span>);<br>    R=<span class="hljs-built_in">real</span>(mat); <span class="hljs-comment">% 傅立叶变换实部</span><br>    I=<span class="hljs-built_in">imag</span>(mat); <span class="hljs-comment">% 傅立叶变换虚部</span><br>    spec = <span class="hljs-built_in">sqrt</span>(R.^<span class="hljs-number">2</span>+I.^<span class="hljs-number">2</span>); <span class="hljs-comment">% 幅值</span><br>    spec_sort=<span class="hljs-built_in">sort</span>(<span class="hljs-built_in">reshape</span>(spec,[<span class="hljs-number">1</span>,width*height]));<span class="hljs-comment">%排序，取阈值</span><br>    limit=spec_sort(<span class="hljs-built_in">round</span>(width*height*P)); <span class="hljs-comment">%门限</span><br>    matrix(spec&lt;limit)=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题">问题</h3><p>在本实验中，助教会要求你就某一个变换为例，作出取门限的保留比例和图像PSNR的折线图，也就是上面代码中注释掉的那一部分。</p><p>备注：期末考试中考了哈达玛变换的编程题。</p><hr /><h2 id="实验二-图像增强复原实验">实验二 图像增强复原实验</h2><h3 id="实验目的-1">实验目的</h3><p>利用空间均值滤波和空间中值滤波对降质图像进行复原，比较不同滤波器处理后的图像间的差异与滤波器大小对结果的影响。</p><h3 id="实验内容-1">实验内容</h3><ol type="1"><li><p>利用空间均值滤波方法进行图像增强复原；</p></li><li><p>利用空间中值滤波方法进行图像增强复原。</p></li></ol><h3 id="实验要求-1">实验要求</h3><ol type="1"><li><p>输入图像采用实验1所获取的图像，编程实现为输入图像添加高斯噪声与椒盐（脉冲）噪声，程序需要能够指定噪声的均值和方差或两个噪声分量中每一个的概率。</p></li><li><p>对每一种方法通过计算复原出来的图像的峰值信噪比，比较不同空间掩码的大小的选择对去噪效果的影响。</p></li><li><p>将降质图像和利用最优参数恢复后的图像同时显示出来，以便比较。</p></li><li><p>实验部分应包括高斯噪声和椒盐噪声的生成过程，原始图像和添加噪声后的图像；加噪图像通过均值和中值滤波器后的结果及比较不同滤波器处理后的图像之间的差异，滤波器大小对结果的影响。</p></li></ol><h3 id="实验原理-1">实验原理</h3><p>空间均值滤波算法的基本思想是，对于图像中的每个像素，将其与周围像素的灰度值进行平均，然后用平均值来替代原始像素的灰度值。这样可以消除图像中的高频噪声，并减少图像中的细节信息。</p><p>空间中值滤波算法的基本思想是，在给定的邻域窗口内，将窗口内的像素按照灰度值进行排序，然后选择排序后的中间值作为当前像素的新值。这种方法能够有效地消除图像中的椒盐噪声和其他类型的离群值，同时保留图像的边缘信息。</p><h3 id="实验结果与分析-1">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301039108.png" alt="实验2图像结果" /><figcaption aria-hidden="true">实验2图像结果</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301040454.jpg" alt="加高斯噪声图像PSNR随滤波器卷积核大小变化" /><figcaption aria-hidden="true">加高斯噪声图像PSNR随滤波器卷积核大小变化</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301040209.jpg" alt="加椒盐噪声图像PSNR随滤波器卷积核大小变化" /><figcaption aria-hidden="true">加椒盐噪声图像PSNR随滤波器卷积核大小变化</figcaption></figure><p>从结果上来看，在椒盐噪声上，中值滤波的效果一般来说好于均值滤波；在高斯噪声上，两者性能差不多。</p><h3 id="实验代码-1">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear all;<br>img=imread(<span class="hljs-string">&#x27;E1_output_image.tif&#x27;</span>); <br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>);<br>imshow(img);<br>title(<span class="hljs-string">&#x27;原图&#x27;</span>);<br><br><span class="hljs-built_in">mean</span> = <span class="hljs-number">0</span>;  <span class="hljs-comment">% 均值</span><br>variance = <span class="hljs-number">100</span>;  <span class="hljs-comment">% 方差</span><br>noise = <span class="hljs-built_in">mean</span> + <span class="hljs-built_in">sqrt</span>(variance) * <span class="hljs-built_in">randn</span>(<span class="hljs-built_in">size</span>(img));  <span class="hljs-comment">% 高斯噪声</span><br>noisy_img = double(img) + noise;  <span class="hljs-comment">% 添加噪声</span><br>noisy_img = uint8(noisy_img);  <span class="hljs-comment">% 转回uint8类型</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>);<br>imshow(noisy_img);<br>title(<span class="hljs-string">&#x27;添加高斯噪声后图像&#x27;</span>);<br>grayPSNR(img,noisy_img,<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">% 定义滤波器大小</span><br>filter_size = <span class="hljs-number">3</span>;<br><span class="hljs-comment">% 对图像进行均值滤波</span><br>avg_filtered_img = imfilter(noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);<br>imshow(avg_filtered_img);<br>title(<span class="hljs-string">&#x27;高斯噪声-均值滤波&#x27;</span>);<br><br>mid_filtered_img = medfilt2(noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);<br>imshow(mid_filtered_img);<br>title(<span class="hljs-string">&#x27;高斯噪声-中值滤波&#x27;</span>);<br><br>MAX_FLITER=<span class="hljs-number">50</span>;<br>avg_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br>mid_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:MAX_FLITER<br>    filter_size=<span class="hljs-built_in">i</span>;<br>    avg_filtered_img = imfilter(noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>    mid_filtered_img = medfilt2(noisy_img, [filter_size filter_size]);<br>    avg_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,avg_filtered_img,<span class="hljs-number">8</span>);<br>    mid_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,mid_filtered_img,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">end</span><br><br>filter_size=<span class="hljs-number">5</span>;<br>mid_filtered_img = medfilt2(noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);<br>imshow(mid_filtered_img);<br>title(<span class="hljs-string">&#x27;高斯噪声-最优参数恢复效果（size=5，中值滤波）&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>imshow(img);<br>title(<span class="hljs-string">&#x27;原图&#x27;</span>);<br><br><span class="hljs-comment">% 添加椒盐噪声</span><br>density = <span class="hljs-number">0.05</span>;  <span class="hljs-comment">% 椒盐噪声比例</span><br>salt_pepper = <span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(img));  <span class="hljs-comment">% 随机数矩阵</span><br>sp_noisy_img=img;<br>sp_noisy_img(salt_pepper &lt; density) = <span class="hljs-number">0</span>;  <span class="hljs-comment">% 添加椒噪声</span><br>sp_noisy_img(salt_pepper &gt; <span class="hljs-number">1</span> - density) = <span class="hljs-number">255</span>;  <span class="hljs-comment">% 添加盐噪声</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>);<br>imshow(sp_noisy_img);<br>title(<span class="hljs-string">&#x27;添加椒盐噪声后图像&#x27;</span>);<br>grayPSNR(img,sp_noisy_img,<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">% 定义滤波器大小</span><br>filter_size = <span class="hljs-number">3</span>;<br><span class="hljs-comment">% 对图像进行均值滤波</span><br>sp_avg_filtered_img = imfilter(sp_noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);<br>imshow(sp_avg_filtered_img);<br>title(<span class="hljs-string">&#x27;椒盐噪声-均值滤波&#x27;</span>);<br><br>sp_mid_filtered_img = medfilt2(sp_noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>);<br>imshow(sp_mid_filtered_img);<br>title(<span class="hljs-string">&#x27;椒盐噪声-中值滤波&#x27;</span>);<br><br>MAX_FLITER=<span class="hljs-number">50</span>;<br>sp_avg_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br>sp_mid_PSNR=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,MAX_FLITER);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:MAX_FLITER<br>    filter_size=<span class="hljs-built_in">i</span>;<br>    sp_avg_filtered_img = imfilter(sp_noisy_img, fspecial(<span class="hljs-string">&#x27;average&#x27;</span>, [filter_size filter_size]));<br>    sp_mid_filtered_img = medfilt2(sp_noisy_img, [filter_size filter_size]);<br>    sp_avg_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,sp_avg_filtered_img,<span class="hljs-number">8</span>);<br>    sp_mid_PSNR(<span class="hljs-built_in">i</span>)=grayPSNR(img,sp_mid_filtered_img,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">end</span><br><br>filter_size=<span class="hljs-number">3</span>;<br>sp_mid_filtered_img = medfilt2(sp_noisy_img, [filter_size filter_size]);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<br>imshow(sp_mid_filtered_img);<br>title(<span class="hljs-string">&#x27;椒盐噪声-最优参数恢复效果（size=3，中值滤波）&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:MAX_FLITER,avg_PSNR,<span class="hljs-string">&#x27;r.-&#x27;</span>,<span class="hljs-number">1</span>:MAX_FLITER,mid_PSNR,<span class="hljs-string">&#x27;g.-&#x27;</span>);<br>title(<span class="hljs-string">&#x27;高斯噪声-PSNR随滤波器卷积核大小变化&#x27;</span>)<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;AVG&#x27;</span>,<span class="hljs-string">&#x27;MID&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:MAX_FLITER,sp_avg_PSNR,<span class="hljs-string">&#x27;r.-&#x27;</span>,<span class="hljs-number">1</span>:MAX_FLITER,sp_mid_PSNR,<span class="hljs-string">&#x27;g.-&#x27;</span>);<br>title(<span class="hljs-string">&#x27;椒盐噪声-PSNR随滤波器卷积核大小变化&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;AVG&#x27;</span>,<span class="hljs-string">&#x27;MID&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PSNR</span> = <span class="hljs-title">grayPSNR</span><span class="hljs-params">(img1,img2,bit)</span></span><br><span class="hljs-comment">%   计算图像的峰值信噪比PSNR</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       img1：标准图像</span><br><span class="hljs-comment">%       img2：待比较图像</span><br><span class="hljs-comment">%       bit：图像每像素比特数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       PSNR：峰值信噪比（dB）</span><br>    Size=<span class="hljs-built_in">size</span>(img1);<br>    h=Size(<span class="hljs-number">1</span>);<br>    w=Size(<span class="hljs-number">2</span>);<br>    MAX=<span class="hljs-number">2</span>^bit<span class="hljs-number">-1</span>;<br>    img1=double(img1);<br>    img2=double(img2);<br>    MSE=sum(sum((img1-img2).^<span class="hljs-number">2</span>))/(h*w);     <span class="hljs-comment">% 均方差  </span><br>    PSNR=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(MAX/<span class="hljs-built_in">sqrt</span>(MSE));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题-1">问题</h3><p>在本实验中，助教会根据空间域滤波的基本原理进行提问，你需要了解卷积核和原图相互作用的过程。然后，助教会问如果卷积核的大小为偶数时，卷积的结果会放在哪里。事实上，如果指定偶数大小的核 <a href="https://ww2.mathworks.cn/help/images/ref/imfilter.html?searchHighlight=imfilter&amp;s_tid=srchtitle_imfilter_1#btsmcj2-1-h"><code>h</code></a>，则核的中心是 <code>floor((size(h) + 1)/2)</code>。例如，四元素滤波器 <code>[0.25 0.75 -0.75 -0.25]</code> 的中心是第二个元素 <code>0.75</code>。此滤波器与五元素滤波器 <code>[0 0.25 0.75 -0.75 -0.25]</code> 的滤波结果相同。</p><hr /><h2 id="实验三-图像分割处理实验">实验三 图像分割处理实验</h2><h3 id="实验目的-2">实验目的</h3><ol type="1"><li><p>了解图像分割的基本原理，并利用图像分割算法进行图像分割处理；</p></li><li><p>掌握数学形态学的基本运算。</p></li></ol><h3 id="实验内容-2">实验内容</h3><ol type="1"><li><p>利用类间方差阈值算法实现图像的分割处理；</p></li><li><p>利用形态学处理进行处理结果修正。</p></li></ol><h3 id="实验要求-2">实验要求</h3><ol type="1"><li>实验用图如图6.2所示；</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301044776.png" alt="实验3原始图像" /><figcaption aria-hidden="true">实验3原始图像</figcaption></figure><ol start="2" type="1"><li><p>对输入图像进行平滑处理，以减小噪声对分割处理的影响，比较中值滤波范围取不同值时对图像滤波的效果；</p></li><li><p>利用类间方差阈值算法对滤波处理后图像进行分割处理，获取分割图像；</p></li><li><p>利用数学形态学中的腐蚀和膨胀运算处理，剔除分割处理结果中的一些细小的残余误分割点，在进行腐蚀和膨胀运算时可采用半径为r的圆形结构元素，注意比较选取不同r值时的处理结果（r分别取1、3、5）。</p></li></ol><h3 id="实验原理-2">实验原理</h3><p>大津法的基本思想是遍历所有可能的阈值，并计算每个阈值下的类间方差。类间方差是衡量图像分割质量的指标，它衡量了不同类别之间的差异程度。通过最大化类间方差，可以找到最佳阈值，以便将图像分成背景和目标两个类别。它的优点在于它是一种自适应的阈值选择方法，不需要预先指定阈值，而是根据图像的特性自动选择最佳阈值。它在处理具有双峰直方图的图像（例如目标和背景明显不同的图像）时表现良好，并且适用于各种类型的图像分割任务。</p><p>腐蚀操作通过对图像进行局部最小化来缩小或腐蚀图像中物体的边界，这种操作使图像中的物体边界变得更加平滑，并且可以用于去除小的噪声、分离物体之间的连接以及减小物体的尺寸。膨胀操作通过对图像进行局部最大化来扩展或膨胀图像中物体的边界，这种操作可用于连接物体、填充物体内的空洞、增大物体的尺寸以及消除图像中的小孔洞。</p><p>开闭运算是腐蚀和膨胀操作的组合。开运算先进行腐蚀操作，然后再进行膨胀操作。它可以用于平滑图像的轮廓、去除小的物体以及分离连接的物体。闭运算先进行膨胀操作，然后再进行腐蚀操作。它可以用于填充物体内的小孔洞、连接物体以及平滑图像的背景。</p><h3 id="实验结果与分析-2">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301044255.jpg" alt="实验3各图像结果" /><figcaption aria-hidden="true">实验3各图像结果</figcaption></figure><p>由实验结果可以看出，中值滤波效果抑制了图像中大部分噪声，而图像也被一定程度地模糊；经过图像分割之后，目标的轮廓被提取出来。开操作方向向外的角变圆滑了，但是方向向内的角未受影响。闭运算方向向内的角变圆滑了，方向向外的角未受影响。</p><h3 id="实验代码-2">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs matlab">img = imread(<span class="hljs-string">&quot;shiyan3.bmp&quot;</span>);<br>img = rgb2gray(img);<br>img = im2uint8(img);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>imshow(img);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>medianFilteredImages = cell(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>filterSizes = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];  <span class="hljs-comment">% 不同的滤波范围</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(filterSizes)<br>    medianFilteredImages&#123;<span class="hljs-built_in">i</span>&#125; = medfilt2(img, [filterSizes(<span class="hljs-built_in">i</span>), filterSizes(<span class="hljs-built_in">i</span>)]);<br>    subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br>    imshow(medianFilteredImages&#123;<span class="hljs-built_in">i</span>&#125;);<br>    title([<span class="hljs-string">&#x27;中值滤波 (&#x27;</span>, num2str(filterSizes(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27;x&#x27;</span>, num2str(filterSizes(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27;)&#x27;</span>]);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%选择PSNR最大的3x3进行后续操作</span><br>medianFilteredImage = medfilt2(img,[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]);<br>segmentedImage = imbinarize(medianFilteredImage);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>imshow(segmentedImage);<br>title(<span class="hljs-string">&#x27;分割后图像&#x27;</span>);<br><br><span class="hljs-comment">%形态学处理</span><br>cleanedSegmentedImages = cell(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>radius = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(radius)<br>    se = strel(<span class="hljs-string">&#x27;disk&#x27;</span>,radius(<span class="hljs-built_in">i</span>));<br>    erodedImage = imerode(segmentedImage, se);<span class="hljs-comment">%腐蚀</span><br>    cleanedSegmentedImages&#123;<span class="hljs-built_in">i</span>&#125; = imdilate(erodedImage,se);<span class="hljs-comment">%膨胀</span><br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>+<span class="hljs-built_in">i</span>);<br>    imshow(cleanedSegmentedImages&#123;<span class="hljs-built_in">i</span>&#125;);<br>    title([<span class="hljs-string">&#x27;开运算，半径为&#x27;</span>,num2str(radius(<span class="hljs-built_in">i</span>))]);<br><span class="hljs-keyword">end</span><br><br>se = strel(<span class="hljs-string">&#x27;disk&#x27;</span>,<span class="hljs-number">3</span>);<br>dilatedImage = imdilate(segmentedImage,se);<br>cleanedImage = imerode(dilatedImage,se);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>);<br>imshow(cleanedImage);<br>title(<span class="hljs-string">&#x27;闭运算，半径为3&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PSNR</span> = <span class="hljs-title">grayPSNR</span><span class="hljs-params">(img1,img2,bit)</span></span><br><span class="hljs-comment">%   计算图像的峰值信噪比PSNR</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       img1：标准图像</span><br><span class="hljs-comment">%       img2：待比较图像</span><br><span class="hljs-comment">%       bit：图像每像素比特数</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       PSNR：峰值信噪比（dB）</span><br>    Size=<span class="hljs-built_in">size</span>(img1);<br>    h=Size(<span class="hljs-number">1</span>);<br>    w=Size(<span class="hljs-number">2</span>);<br>    MAX=<span class="hljs-number">2</span>^bit<span class="hljs-number">-1</span>;<br>    img1=double(img1);<br>    img2=double(img2);<br>    MSE=sum(sum((img1-img2).^<span class="hljs-number">2</span>))/(h*w);     <span class="hljs-comment">% 均方差  </span><br>    PSNR=<span class="hljs-number">20</span>*<span class="hljs-built_in">log10</span>(MAX/<span class="hljs-built_in">sqrt</span>(MSE));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题-2">问题</h3><p>在本实验中，助教会问大津法的基本原理，类间方差和类内方差的概念，腐蚀与膨胀和开闭运算的基本知识，以及开闭运算的功能。</p><hr /><h2 id="实验四-用hough变换进行曲线的参数提取">实验四 用Hough变换进行曲线的参数提取</h2><h3 id="实验目的-3">实验目的</h3><ol type="1"><li><p>了解边缘检测算子的原理，并利用边缘算子对图像进行检测；</p></li><li><p>掌握Hough变换的基本原理。</p></li></ol><h3 id="实验内容-3">实验内容</h3><ol type="1"><li><p>分别将原始图像及加高斯噪声、椒盐噪声后的图像中圆形边缘检测出来；</p></li><li><p>用Hough变换对边缘进行参数提取。</p></li></ol><h3 id="实验要求-3">实验要求</h3><ol type="1"><li>实验用图像文件：原始图像（houghorg.bmp）、加高斯噪声后图像（houghgau.bmp）和加椒盐噪声后图像（houghsalt.bmp）；</li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301054271.png" alt="原始图像" /><figcaption aria-hidden="true">原始图像</figcaption></figure><ol start="2" type="1"><li><p>在含有噪声的背景下，先对图像中值滤波，再进行边缘检测；</p></li><li><p>将目标的边界提取出来。边缘检测算子可利用自带函数实现，使用Robert、Sobel和Laplacian算子；</p></li><li><p>利用Hough变换提取的参数绘制曲线，并叠加在噪声图像上。</p></li></ol><h3 id="实验原理-3">实验原理</h3><p>Robert、Sobel和Laplacian是常用的边缘检测算子，分别运用梯度或二阶微分等原理来对图像的边缘进行检测。</p><p>在<span class="math inline">\((x,y)\)</span>空间中，圆的方程为：</p><p><span class="math display">\[(x - a)^{2} + (y - b)^{2} = r^{2}\]</span></p><p>取<span class="math inline">\((a,b)\)</span>做变换空间，也因此在<span class="math inline">\((x,y)\)</span>空间中圆上任意一点<span class="math inline">\(\left( x_{i},y_{i} \right)\)</span>与<span class="math inline">\((a,b)\)</span>空间中的圆相对应：</p><p><span class="math display">\[\left( a - x_{i} \right)^{2} + \left( b - y_{i} \right)^{2} = r^{2}\]</span></p><p>在<span class="math inline">\((x,y)\)</span>空间中所有共圆的点在<span class="math inline">\((a,b)\)</span>空间中对应的曲线交于<span class="math inline">\(\left( a_{0},b_{0} \right)\)</span>，利用Hough变换的步骤，最终可以在累加数组中找到<span class="math inline">\(\left( a_{0},b_{0} \right)\)</span>点出现峰值，从而检测出在<span class="math inline">\((x,y)\)</span>空间中有一个以<span class="math inline">\(\left( a_{0},b_{0} \right)\)</span>为半径的圆</p><h3 id="实验结果与分析-3">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301055801.jpg" alt="加高斯噪声实验结果" /><figcaption aria-hidden="true">加高斯噪声实验结果</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301055749.jpg" alt="加椒盐噪声实验结果" /><figcaption aria-hidden="true">加椒盐噪声实验结果</figcaption></figure><p>观察实验结果，三种算子都能有效提取边界。</p><h3 id="实验代码-3">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;close all;<br><br>imgOrg = imread(<span class="hljs-string">&#x27;houghorg.bmp&#x27;</span>);<br>imgOrg = rgb2gray(imgOrg);<br>imgOrg = mat2gray(imgOrg);<br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>make(imgOrg);<br><br>imgSalt = imread(<span class="hljs-string">&#x27;houghsalt.bmp&#x27;</span>);<br>imgSalt = mat2gray(imgSalt);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>make(imgSalt);<br><br>imgGau = imread(<span class="hljs-string">&#x27;houghgau.bmp&#x27;</span>);<br>imgGau = mat2gray(imgGau);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br>make(imgGau);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge</span> = <span class="hljs-title">edgeRobert</span><span class="hljs-params">(image)</span></span><br><span class="hljs-comment">%Robert算子边缘提取</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       image：待处理图像</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       edge：提取的边缘</span><br>    Gx = [ <span class="hljs-number">1</span>  <span class="hljs-number">0</span>; <br>           <span class="hljs-number">0</span> <span class="hljs-number">-1</span>];<br>    Gy = [ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>; <br>          <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>];   <br><br>    edgeX = conv2(double(image), Gx, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    edgeY = conv2(double(image), Gy, <span class="hljs-string">&#x27;same&#x27;</span>);<br><br>    edgeMagnitude = <span class="hljs-built_in">sqrt</span>(edgeX.^<span class="hljs-number">2</span> + edgeY.^<span class="hljs-number">2</span>);<br>    edgeMagnitude = mat2gray(edgeMagnitude);<br>    edge = imbinarize(edgeMagnitude);<br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge</span> = <span class="hljs-title">edgeStobel</span><span class="hljs-params">(image)</span></span><br><span class="hljs-comment">%Stobelt算子边缘提取</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       image：待处理图像</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       edge：提取的边缘</span><br>    Gx = [<span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>; <br>          <span class="hljs-number">-2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2</span>; <br>          <span class="hljs-number">-1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>];<br>    Gy = [ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">1</span>; <br>           <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>; <br>          <span class="hljs-number">-1</span> <span class="hljs-number">-2</span> <span class="hljs-number">-1</span>];<br><br>    edgeX = conv2(double(image), Gx, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    edgeY = conv2(double(image), Gy, <span class="hljs-string">&#x27;same&#x27;</span>);<br><br>    edgeMagnitude = <span class="hljs-built_in">sqrt</span>(edgeX.^<span class="hljs-number">2</span> + edgeY.^<span class="hljs-number">2</span>);<br>    edgeMagnitude = mat2gray(edgeMagnitude);<br>    edge = imbinarize(edgeMagnitude);<br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge</span> = <span class="hljs-title">edgeLaplacian</span><span class="hljs-params">(image)</span></span><br><span class="hljs-comment">%Laplacian算子边缘提取</span><br><span class="hljs-comment">%   输入：</span><br><span class="hljs-comment">%       image：待处理图像</span><br><span class="hljs-comment">%   输出：</span><br><span class="hljs-comment">%       edge：提取的边缘</span><br>    H = fspecial(<span class="hljs-string">&#x27;laplacian&#x27;</span>);<br>    edgeResponse = conv2(double(image), H, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    edgeMagnitude = <span class="hljs-built_in">abs</span>(edgeResponse);<br>    edgeMagnitude = mat2gray(edgeMagnitude);<br>    edge = imbinarize(edgeMagnitude);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span><span class="hljs-params">(img)</span></span><br>    imgO=img;<br>    img = medfilt2(img, [<span class="hljs-number">9</span> <span class="hljs-number">9</span>]);<br>    edgeR=edgeRobert(img);<br>    edgeS=edgeStobel(img);<br>    edgeL=edgeLaplacian(img);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>    imshow(edgeR);<br>    title(<span class="hljs-string">&#x27;Robert算子边缘提取&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>    imshow(edgeS);<br>    title(<span class="hljs-string">&#x27;Stobel算子边缘提取&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>    imshow(edgeL);<br>    title(<span class="hljs-string">&#x27;Laplacian算子边缘提取&#x27;</span>);<br><br><span class="hljs-comment">%以下是Hough变换</span><br>    radiusRange = [<span class="hljs-number">20</span> <span class="hljs-number">500</span>]; <span class="hljs-comment">% 圆的半径范围</span><br><br>    [centersR, radiiR, metricR] = imfindcircles(edgeR, radiusRange,<span class="hljs-string">&#x27;Sensitivity&#x27;</span>,<span class="hljs-number">0.9</span>);<br>    <span class="hljs-comment">%Sensitivity是敏感度因子，随着敏感度因子的增大，imfindcircles 会检测到更多圆形目标，包括弱圆形和部分模糊圆形。更高的敏感度值也会增加错误检测的风险。</span><br>    [centersS, radiiS, metricS] = imfindcircles(edgeS, radiusRange,<span class="hljs-string">&#x27;Sensitivity&#x27;</span>,<span class="hljs-number">0.9</span>);<br>    [centersL, radiiL, metricL] = imfindcircles(edgeL, radiusRange,<span class="hljs-string">&#x27;Sensitivity&#x27;</span>,<span class="hljs-number">0.9</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>    imshow(imgO);<br>    viscircles(centersR, radiiR,<span class="hljs-string">&#x27;EdgeColor&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>    imshow(imgO);<br>    viscircles(centersS, radiiS,<span class="hljs-string">&#x27;EdgeColor&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>);<br>    imshow(imgO);<br>    viscircles(centersL, radiiL,<span class="hljs-string">&#x27;EdgeColor&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h3 id="问题-3">问题</h3><p>在本实验中，助教会问你关于Hough变换提取圆形的基本原理。</p><hr /><h2 id="实验五-手写数字识别">实验五 手写数字识别</h2><h3 id="实验目的-4">实验目的</h3><p>掌握分类、识别问题的实质，了解各种分类问题的机器学习方法，并至少掌握一种</p><h3 id="实验内容-4">实验内容</h3><p>对实验提供含噪声的手写数据库（MNIST）进行训练和测试，最终能够较为准确的识别数据库中的手写体数字。</p><h3 id="实验要求-4">实验要求</h3><p>编写一完整的程序，选取一种合适的机器学习方法，对实验提供的手写数据库（MNIST）进行训练和测试，最终能够较为准确的识别数据库中的手写体数字。</p><p>数据文件共分为训练集和测试集：</p><p>训练数据集：</p><p>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</p><p>Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</p><p>测试数据集：</p><p>Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</p><p>Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</p><h2 id="实验原理-4">实验原理</h2><p>卷积神经网络（Convolutional Neural Network，CNN）是一种深度学习模型，主要用于图像识别、目标检测和图像分类等任务。CNN的组成和原理如下：</p><p>卷积层：是CNN的核心组件。它通过使用一系列可学习的卷积核对输入图像进行卷积操作。</p><p>激活函：在卷积层的输出特征图上应用非线性激活函数，如ReLU，用于引入非线性变换。ReLU函数将负值置为零，并保留正值。这种非线性变换能够增强网络的表达能力，使其能够学习更复杂的特征。</p><p>池化层：用于降低特征图的空间尺寸，减少参数数量，并提取出重要的特征。常用的池化操作是最大池化，它从输入的局部区域中选择最大值作为输出。池化层还可以提供一定程度的平移不变性，使网络对输入的微小变化更加稳定。</p><p>全连接层：是在卷积层和输出层之间的一层。它将之前的卷积层或池化层的输出特征图展平为一维向量，并与权重相乘并进行偏置，最后通过激活函数得到最终的分类结果。全连接层能够学习到输入特征之间的复杂关系，用于分类和预测。</p><p>输出层：是CNN的最后一层，通常使用softmax函数将网络的输出转换为概率分布，用于多分类问题的预测。</p><p>CNN通过多个卷积层、激活函数、池化层和全连接层的堆叠，可以提取图像中的高级特征，并通过反向传播算法进行端到端的训练。通过大规模的数据集训练，CNN能够学习到复杂的特征表示，并在新的未见过的图像上进行准确的分类和预测。</p><h3 id="实验结果与分析-4">实验结果与分析</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301100419.png" alt="训练过程示意图" /><figcaption aria-hidden="true">训练过程示意图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301100378.png" alt="加噪声前识别示例" /><figcaption aria-hidden="true">加噪声前识别示例</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301100006.jpg" alt="加噪声后识别示例" /><figcaption aria-hidden="true">加噪声后识别示例</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306301101857.jpg" alt="预测准确率随噪声变化" /><figcaption aria-hidden="true">预测准确率随噪声变化</figcaption></figure><h3 id="实验代码-4">实验代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;close all;<br><br>digitDatasetPath = fullfile(matlabroot,<span class="hljs-string">&#x27;toolbox&#x27;</span>,<span class="hljs-string">&#x27;nnet&#x27;</span>,<span class="hljs-string">&#x27;nndemos&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;nndatasets&#x27;</span>,<span class="hljs-string">&#x27;DigitDataset&#x27;</span>);<br>imds = imageDatastore(digitDatasetPath, ...<br>    <span class="hljs-string">&#x27;IncludeSubfolders&#x27;</span>,<span class="hljs-built_in">true</span>,<span class="hljs-string">&#x27;LabelSource&#x27;</span>,<span class="hljs-string">&#x27;foldernames&#x27;</span>);<br><span class="hljs-comment">% figure;</span><br><span class="hljs-comment">% perm = randperm(10000,20);</span><br><span class="hljs-comment">% for i = 1:20</span><br><span class="hljs-comment">%     subplot(4,5,i);</span><br><span class="hljs-comment">%     imshow(imds.Files&#123;perm(i)&#125;);</span><br><span class="hljs-comment">% end</span><br><br>labelCount = countEachLabel(imds)<br>img = readimage(imds,<span class="hljs-number">1</span>);<br>imageSize = <span class="hljs-built_in">size</span>(img);<br><br>numTrainFiles = <span class="hljs-number">750</span>;<br>[imdsTrain,imdsValidation] = splitEachLabel(imds,numTrainFiles,<span class="hljs-string">&#x27;randomize&#x27;</span>);<br><br>layers = [<br>    imageInputLayer([<span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">%图像输入层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <span class="hljs-comment">%卷积层</span><br>    batchNormalizationLayer <span class="hljs-comment">%批量归一化层</span><br>    reluLayer <span class="hljs-comment">%ReLU层</span><br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">%最大池化层</span><br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>) <br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    maxPooling2dLayer(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Stride&#x27;</span>,<span class="hljs-number">2</span>)<br>    <br>    convolution2dLayer(<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;Padding&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>)<br>    batchNormalizationLayer<br>    reluLayer<br>    <br>    fullyConnectedLayer(<span class="hljs-number">10</span>) <span class="hljs-comment">%全连接</span><br>    softmaxLayer<br>    classificationLayer]; <span class="hljs-comment">%分类</span><br><br>options = trainingOptions(<span class="hljs-string">&#x27;sgdm&#x27;</span>, ... <span class="hljs-comment">%随机梯度下降法</span><br>    <span class="hljs-string">&#x27;InitialLearnRate&#x27;</span>,<span class="hljs-number">0.01</span>, ... <span class="hljs-comment">%学习率</span><br>    <span class="hljs-string">&#x27;MaxEpochs&#x27;</span>,<span class="hljs-number">4</span>, ... <span class="hljs-comment">%训练轮数</span><br>    <span class="hljs-string">&#x27;Shuffle&#x27;</span>,<span class="hljs-string">&#x27;every-epoch&#x27;</span>, ... <span class="hljs-comment">%随机化</span><br>    <span class="hljs-string">&#x27;ValidationData&#x27;</span>,imdsValidation, ... <span class="hljs-comment">%验证集</span><br>    <span class="hljs-string">&#x27;ValidationFrequency&#x27;</span>,<span class="hljs-number">30</span>, ... <span class="hljs-comment">%每隔30个训练迭代时进行一次验证</span><br>    <span class="hljs-string">&#x27;Verbose&#x27;</span>,<span class="hljs-built_in">false</span>, ...<br>    <span class="hljs-string">&#x27;Plots&#x27;</span>,<span class="hljs-string">&#x27;training-progress&#x27;</span>); <span class="hljs-comment">%显示训练过程的进度图</span><br><br>net = trainNetwork(imdsTrain,layers,options);<br>YPred = classify(net,imdsValidation);<br>YValidation = imdsValidation.Labels;<br><br><span class="hljs-comment">%显示20个无噪声识别示意图</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br>perm = randperm(<span class="hljs-number">2500</span>,<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">20</span><br>    subplot(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-built_in">i</span>);<br>    imshow(imdsValidation.Files&#123;perm(<span class="hljs-built_in">i</span>)&#125;);<br>    title(<span class="hljs-string">&#x27;预测值&#x27;</span>+string(YPred(perm(<span class="hljs-built_in">i</span>))));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%无噪声准确率</span><br>accuracy = sum(YPred == YValidation)/<span class="hljs-built_in">numel</span>(YValidation)<br><br>newImgArray = <span class="hljs-built_in">ones</span>([imageSize,<span class="hljs-number">2500</span>]);<br>newImgArray2 = <span class="hljs-built_in">ones</span>([imageSize,<span class="hljs-number">2500</span>]);<br><br><br><span class="hljs-comment">%复制测试集</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2500</span><br>    newImgArray(:,:,<span class="hljs-built_in">i</span>) = imread(imdsValidation.Files&#123;<span class="hljs-built_in">i</span>&#125;);<br><span class="hljs-keyword">end</span><br>Densitys = <span class="hljs-number">0</span>:<span class="hljs-number">0.005</span>:<span class="hljs-number">0.05</span>; <span class="hljs-comment">%椒盐噪声概率</span><br>accuracys = <span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(Densitys));<br><span class="hljs-comment">%加噪声</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(Densitys)<br>    <span class="hljs-built_in">i</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2500</span><br>        p=Densitys(<span class="hljs-built_in">i</span>);<br>        newImgArray2(:,:,<span class="hljs-built_in">j</span>) = addSaltAndPepperNoise(newImgArray(:,:,<span class="hljs-built_in">j</span>),p);<br>        YPred(<span class="hljs-built_in">j</span>,:)=classify(net,newImgArray2(:,:,<span class="hljs-built_in">j</span>));<br>    <span class="hljs-keyword">end</span><br>    accuracys(<span class="hljs-built_in">i</span>) = sum(YPred == YValidation)/<span class="hljs-built_in">numel</span>(YValidation);<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">plot</span>(Densitys,accuracys);<br>title(<span class="hljs-string">&#x27;预测准确率随椒盐噪声的概率变化的图像&#x27;</span>);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2500</span><br>    p=<span class="hljs-number">0.01</span>;<br>    newImgArray2(:,:,<span class="hljs-built_in">j</span>) = addSaltAndPepperNoise(newImgArray(:,:,<span class="hljs-built_in">j</span>),p);<br>    YPred(<span class="hljs-built_in">j</span>,:)=classify(net,newImgArray2(:,:,<span class="hljs-built_in">j</span>));<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>);<br>perm = randperm(<span class="hljs-number">2500</span>,<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">20</span><br>    subplot(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-built_in">i</span>);<br>    imshow(newImgArray2(:,:,perm(<span class="hljs-built_in">i</span>)));<br>    title(<span class="hljs-string">&#x27;预测值&#x27;</span>+string(YPred(perm(<span class="hljs-built_in">i</span>)))+<span class="hljs-string">&#x27;,实际值&#x27;</span>+string(YValidation(perm(<span class="hljs-built_in">i</span>))));<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noisyImage</span> = <span class="hljs-title">addSaltAndPepperNoise</span><span class="hljs-params">(image, noiseDensity)</span></span><br>    <span class="hljs-comment">% image: 输入的图像</span><br>    <span class="hljs-comment">% noiseDensity: 椒盐噪声概率</span><br>    <br>    salt_pepper = <span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(image)); <br>    noisyImage=image;<br>    noisyImage(salt_pepper &lt; noiseDensity) = <span class="hljs-number">0</span>;  <span class="hljs-comment">% 添加椒噪声</span><br>    noisyImage(salt_pepper &gt; <span class="hljs-number">1</span> - noiseDensity) = <span class="hljs-number">255</span>;  <span class="hljs-comment">% 添加盐噪声</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="问题-4">问题</h3><p>在本实验中，助教会问关于CNN基本原理的问题</p><h2 id="感悟与总结">感悟与总结</h2><p>在进行图像处理实验的过程中，我通过实践掌握了图像变换、图像增强复原、图像分割、曲线参数提取以及手写数字识别等五个部分的基本技术和方法。这次实验给我带来了许多收获和感悟。</p><p>在图像变换方面，我学会了使用离散傅立叶变换、离散余弦变换等方法对图像进行频域分析和压缩。通过观察变换后的系数矩阵的频谱情况，我更深入地理解了图像在频域上的特征表达。</p><p>在图像增强复原方面，我学习了空间均值滤波、中值滤波等技术，可以有效地去除图像噪声和模糊，并提升图像的质量和清晰度。这对于图像处理和分析来说非常重要，尤其在实际应用中能够提升图像的可视化效果。</p><p>在图像分割方面，我掌握了基于阈值分割和基于边缘检测的方法。通过调整阈值和应用边缘检测算子，我成功地将感兴趣的目标进行提取和分析。</p><p>通过学习和实践边缘检测算法和Hough变换，我了解到它在曲线参数提取方面的强大能力。通过投票累加器和阈值设定，我成功地从图像中提取出了曲线的参数。</p><p>手写数字识别让我简单认识了深度学习模型（如CNN）在图像分类和识别任务中的卓越性能。通过搭建并训练CNN模型，我能够准确地对手写数字进行分类和识别。</p><p>图像处理实验和课内知识结合紧密，通过完成上述五个实验，我对于课内各知识的掌握在实践中得以提升，同时也加强了对Matlab语言的理解和运用能力，提升了自己的综合能力。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理·采样系统和状态空间</title>
    <link href="/2023/06/17/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%C2%B7%E9%87%87%E6%A0%B7%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/06/17/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%C2%B7%E9%87%87%E6%A0%B7%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这两部分之间其实没啥太大联系，写在一起只是为了方便，就这样。</p><h2 id="采样系统分析">采样系统分析</h2><p>在前面讨论的系统中，信号都是连续时间信号，系统都是连续时间系统。在本节，将对有一处或者数处的信号是离散的（数码或者脉冲序列）的系统进行讨论。</p><p>关于奈奎斯特采样定理，已经提过非常非常多遍了，这里就略过了。只提一点：用<span class="math inline">\(f(t),G(s)\)</span>表示采样前的信号，系统；用<span class="math inline">\(f^*(t),G^*(s)\)</span>表示采样后的信号（冲击串）、系统。</p><h3 id="保持器">保持器</h3><p>由采样定理得，采样频率是输入信号频率的两倍以上时，可以通过理想低通滤波器把信号恢复出来。但是理想滤波器是不存在的，于是我们转而使用保持器来恢复信号。</p><ul><li><p>零阶保持器</p><p>零阶保持器是把采样时刻<span class="math inline">\(nT\)</span>的采样值恒定不变地保持到下一个采样时刻<span class="math inline">\((n+1)T\)</span>的电路。它的系统函数是 <span class="math display">\[G_h(s)=\frac{1-e^{Ts}}{s}\]</span></p></li><li><p>一阶保持器</p><p>一阶保持器是一种按线性规律外推的保持器，其外推规律是： <span class="math display">\[x_h(t)=x(kT)+\frac{x(kT)-x[(k-1)T]}{T}(t-kT)\]</span> 即：每个区间是线性函数，斜率是上一个区间的平均斜率</p><p>其传递函数是 <span class="math display">\[G_h(s)=T(1+Ts)\left(\frac{1-e^{Ts}}{Ts}\right)^2\]</span></p></li></ul><h3 id="z变换">Z变换</h3><p>Z变换是拉普拉斯变换的一种变形，也学过很多遍了。</p><h3 id="脉冲传递函数">脉冲传递函数</h3><p>类似于以前的系统传递函数，离散时间系统的特性可以用脉冲传递函数<span class="math inline">\(H(z)\)</span>来描述。对于开环系统</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20230617164044343.png" alt="image-20230617164044343" /><figcaption aria-hidden="true">image-20230617164044343</figcaption></figure><p>有： <span class="math display">\[C(s)=G(s)R^*(s)\]</span> 和 <span class="math display">\[C^*(s)=G^*(s)R^*(s)\]</span> 写成脉冲传递函数的形式，就是 <span class="math display">\[C(z)=G(z)R(z)\]</span> 一般来说，由连续部分求得脉冲传递函数的步骤是：</p><ol type="1"><li>由<span class="math inline">\(H(s)\)</span>求得<span class="math inline">\(h(t)\)</span></li><li>确定单位冲激响应序列<span class="math inline">\(h[nT]\)</span></li><li>求<span class="math inline">\(h[nT]\)</span>的Z变换，得<span class="math inline">\(H(z)\)</span></li></ol><p>在实际操作上，并没有这么麻烦。在进行接下来的说明之前，首先要辨析两个表达式： <span class="math display">\[G_1(z)G_2(z)\]</span> 指的是<span class="math inline">\(G_1(z)\)</span>和<span class="math inline">\(G_2(z)\)</span>两个表达式的乘积，两个系统之间通过采样开关串联，即：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306171550274.png" alt="image-20230617155047199" style="zoom:25%;" /></p><p>而 <span class="math display">\[G_1G_2(z)\]</span> 指的是先把两个连续时间系统级联，得到<span class="math inline">\(G_1G_2(s)=G_1(s)G_2(s)\)</span>，然后求出<span class="math inline">\(G_1G_2(s)\)</span>对应的Z变换形式，即为<span class="math inline">\(G_1G_2(z)\)</span>，即：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306171550672.png" alt="image-20230617154959581" style="zoom:25%;" /></p><p>这两种情况一般是不一样的。比如<span class="math inline">\(G_1(s)=1/(s+a),G_2(s)=1/(s+a)\)</span>，对于第一个串联系统，有： <span class="math display">\[G(z)=\frac{z^2}{(z-e^{-aT})(z-e^{-bT})}\]</span> 对于第二个串联系统，则有： <span class="math display">\[G(s)=\frac 1{b-a}\left(\frac{1}{s+a}+\frac{1}{s+b}\right)\]</span> 从而 <span class="math display">\[G(z)=\mathscr Z[G(s)]=\frac{\mathrm{e}^{-a T}-\mathrm{e}^{-b T}}{b-a} \frac{z}{\left(z-\mathrm{e}^{-a T}\right)\left(z-\mathrm{e}^{-b T}\right)}\]</span> 在分析闭环系统时，系统函数有时候不能直接求出（详见下面的例题），所以会转而求输出函数<span class="math inline">\(C(z)\)</span>，可以遵循以下步骤：</p><ol type="1"><li>从<span class="math inline">\(C(z)\)</span>开始逆着前向通道找到最靠近比较器的采样器，采样信号设为<span class="math inline">\(X(z)\)</span>；</li><li>利用前向通道和回路分别写出<span class="math inline">\(C(z)\)</span>和<span class="math inline">\(X(z)\)</span>的表达式，联立解出<span class="math inline">\(C(z)\)</span>。</li></ol><p>如果系统有多个反馈环，则：</p><ol type="1"><li>从比较器最靠近<span class="math inline">\(C(z)\)</span>的回路开始，每个回路找到一个<span class="math inline">\(X(z)\)</span>（没有则先归并该连续回路为一个连续环节），即<span class="math inline">\(X_n(z), \cdots , X_1(z)\)</span>；</li><li>用前向通道写出<span class="math inline">\(C(z)\)</span>的表达式，从<span class="math inline">\(n\sim 1\)</span>依次用各回路写出<span class="math inline">\(X(z)\)</span>表达式，联立<span class="math inline">\(n+1\)</span>个方程解出<span class="math inline">\(C(z)\)</span>。</li></ol><p>在实际操作时，先写<span class="math inline">\(C(s)\)</span>和<span class="math inline">\(X(s)\)</span>方程，再加星得到<span class="math inline">\(C^*(s)\)</span>和<span class="math inline">\(X^*(s)\)</span>方程，然后得到<span class="math inline">\(C(z)\)</span>和<span class="math inline">\(X(z)\)</span>方程.</p><blockquote><p>【例1】求以下系统的<span class="math inline">\(C(z)\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306171645961.png" alt="image-20230617164506904" /><figcaption aria-hidden="true">image-20230617164506904</figcaption></figure><p>【解】<span class="math inline">\(X(z)\)</span>已经在图中标好了。</p><ol type="1"><li><p>列方程： <span class="math display">\[\begin{cases}C(s)=G_2(s)X^*(s)\\X(s)=G_2(s)R(s)-G_1(s)H(s)G_2(s)X^*(s)\end{cases}\]</span></p></li><li><p>加星号（采样）：在加星号时，要分清楚一个表达式里面是系统、连续时间还是离散时间。对级联的系统、连续时间信号传入连续系统的部分合并为整体然后加星号，对离散时间信号传入系统的部分，只给系统加星号，离散时间信号保持不变，也不合并： <span class="math display">\[\begin{cases}C(s)=G_2^*(s)X^*(s)\\X(s)=G_2R^*(s)-G_1HG_2^*(s)X^*(s)\end{cases}\]</span></p></li><li><p>Z变换，就是把星号都去了，然后把<span class="math inline">\(s\)</span>换成<span class="math inline">\(z\)</span> <span class="math display">\[\begin{cases}C(z)=G_2(z)X(z)\\X(z)=G_2R(z)-G_1HG_2(z)X(z)\end{cases}\]</span></p></li><li><p>消元求解，有： <span class="math display">\[C(z)=\frac{G_2(z)G_1R(z)}{1+G_1HG_2(z)}\]</span></p></li></ol></blockquote><p>可以看出，在上面这个例子中，<span class="math inline">\(R\)</span>的存在形式是<span class="math inline">\(G_1R(z)\)</span>，并不能单独分出来，所以只能求到<span class="math inline">\(C(z)\)</span>，而不能求出系统函数。</p><h3 id="系统稳定性判定">系统稳定性判定</h3><p>采样系统稳定的充要条件是闭环系统的特征根全部都在<span class="math inline">\(z\)</span>平面的单位圆内，即<span class="math inline">\(|z|&lt;1\)</span>。为了复用以前的劳斯判据，需要找到一个变换<span class="math inline">\(z\to w\)</span>，把<span class="math inline">\(z\)</span>屏幕的单位圆映射到<span class="math inline">\(w\)</span>平面的虚轴之左。有： <span class="math display">\[z=\frac{w+1}{w-1}\]</span> 在应用时，把特征方程的<span class="math inline">\(z\)</span>全都替换成这个，然后对<span class="math inline">\(w\)</span>使用劳斯判据即可。</p><h3 id="系统的稳态误差">系统的稳态误差</h3><p>首先我们研究的是稳态误差，所以系统首先要有稳态，也就是稳定。所有不讨论稳定性而直接对稳态误差进行讨论的都没有意义。</p><p>则根据终值定理，系统稳态误差为 <span class="math display">\[e^*(\infty)=\lim_{z\to 1}(1-z^{-1})\frac {R(z)}{1+G(z)}\]</span> 如果是阶跃输入，即<span class="math inline">\(R(z)=z/(z-1)\)</span>，则 <span class="math display">\[e^*(\infty)=\frac 1{1+K_P}\]</span> 如果是斜坡输入，<span class="math inline">\(R(z)=Tz/(z-1)^2\)</span>，则 <span class="math display">\[e^*(\infty)=\frac T{K_v}\]</span> 如果是加速输入，<span class="math inline">\(r(t)=0.5t^2\)</span>，<span class="math inline">\(R(z)=T^2z(z+1)/2(z-1)^2\)</span>，则 <span class="math display">\[e^{*}(\infty)=\frac{T^2}{K_a}\]</span></p><p>总结如下：</p><table><thead><tr class="header"><th>输入</th><th>0</th><th>I</th><th>II</th><th>III</th><th>静态误差系数</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(r(t)=1\)</span></td><td><span class="math inline">\(\frac{1}{1+K_p}\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K_p=\lim_{z\to 1}G(z)\)</span></td></tr><tr class="even"><td><span class="math inline">\(r(t)=t\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(T/K_v\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K_v=\lim_{z\to 1}(z-1)G(z)\)</span></td></tr><tr class="odd"><td><span class="math inline">\(r(t)=0.5t^2\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(T^2/K_a\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K_a=\lim_{z\to 1}(z-1)^2G(z)\)</span></td></tr></tbody></table><p>型别指<span class="math inline">\(G(z)\)</span>分母包含<span class="math inline">\((z-1)\)</span>因子的个数，即<span class="math inline">\(z=1\)</span>处极点的个数</p><blockquote><p>【例】对采样周期<span class="math inline">\(T=0.2s\)</span>的系统 <span class="math display">\[G(z)=\frac{0.24z-0.16}{(z-1)^2}\]</span> 求输入为<span class="math inline">\(r(t)=1+t+0.5t^2\)</span>时的稳态误差</p><p>【解】有： <span class="math display">\[e^*(\infty)=\frac 1{K_p+1}+\frac T{K_v}+\frac{T^2}{K_a}\]</span> 其中<span class="math inline">\(K_p=K_v=\infty\)</span>，而 <span class="math display">\[\lim_{z\to 1}(z-1)^2G(z)=0.08\]</span> 所以稳态误差为 <span class="math display">\[e^*(\infty)=0+0+\frac{0.2^2}{0.08}=0.5\]</span></p></blockquote><h2 id="状态空间分析方法">状态空间分析方法</h2><p>状态空间分析方法是一种和前面讲的所有方法都不一样的方法。用传递函数描述系统只能反映系统输出和输入变量的关系，而不了解系统内部的变化情况，而且是建立在零初始状态的基础上的。而状态空间分析方法会客服这些困难。在介绍状态空间分析法前，需要定义：</p><ul><li><p>状态变量：如果以最少的<span class="math inline">\(n\)</span>个变量<span class="math inline">\(x_1(t),\cdots,x_n(t)\)</span>就能完整描述一个系统的行为，这<span class="math inline">\(n\)</span>个变量就称为一组状态变量</p></li><li><p>状态向量：把上面这<span class="math inline">\(n\)</span>个状态变量拼成一个列向量，就叫做状态向量</p></li><li><p>状态空间：以各状态变量为轴的空间是状态空间，状态向量是状态空间里的一个点</p></li><li><p>状态方程：描述状态变量和输入之间关系的一阶微分方程组： <span class="math display">\[\mathbf{\dot x}=A\mathbf x+B\mathbf {u}\]</span> 其中<span class="math inline">\(\mathbf x\)</span>是状态向量，<span class="math inline">\(\mathbf u\)</span>是<span class="math inline">\(r\)</span>维输入向量，<span class="math inline">\(A\)</span>是<span class="math inline">\(n\times n\)</span>矩阵，叫系统矩阵，<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times r\)</span>矩阵，叫输入控制阵</p></li><li><p>输出方程：描述系统输出和输入之间关系的方程组： <span class="math display">\[\mathbf y=C\mathbf x+D\mathbf u\]</span> 其中<span class="math inline">\(y\)</span>是<span class="math inline">\(m\)</span>维输出向量，<span class="math inline">\(C\)</span>是<span class="math inline">\(m\times n\)</span>输出矩阵，<span class="math inline">\(D\)</span>是<span class="math inline">\(m\times r\)</span>矩阵。<strong>一个线性时不变系统可用<span class="math inline">\((A,B,C,D)\)</span>直接描述。</strong></p></li></ul><h3 id="求解系统状态方程和输出方程">求解系统状态方程和输出方程</h3><p>对状态方程左右两边做拉普拉斯变换，有： <span class="math display">\[sX(s)-X(0)=AX(s)+BU(s)\]</span> 化简一下： <span class="math display">\[X(s)=(sI-A)^{-1}[X(0)+BU(s)]\]</span> 设预解矩阵 <span class="math display">\[\phi(s)=(sI-A)^{-1}=\frac{(sI-A)^*}{|sI-A|}\]</span> 所以系统的特征方程为<span class="math inline">\(|sI-A|=0\)</span>。则 <span class="math display">\[X(s)=\phi(s)X(0)+\phi(s)BU(s)\]</span> 同理，对输出方程有： <span class="math display">\[Y(s)=C\phi(s)X(0)+[C\phi(s)B+D]U(s)\]</span> 如果是零状态，则<span class="math inline">\(C\phi(s)B+D\)</span>在这里就起到了传递函数的作用，所以定义传递函数矩阵： <span class="math display">\[G(s)=C\phi(s)B+D\]</span></p><h3 id="可控和可观">可控和可观</h3><h4 id="概念和基本判别方法">概念和基本判别方法</h4><p>对于任意初始状态，如果存在一个控制量能在有限时刻将状态转译为零状态，则称系统状态可控。定义系统可控性阵为： <span class="math display">\[Q_c=[B\quad AB\quad A^2B\cdots\quad A^{n-1}B]\]</span> 如果有<span class="math inline">\(|Q_c|\neq0\)</span>，即<span class="math inline">\(Q_c\)</span>满秩，那么系统可控。</p><p>如果<span class="math inline">\(u(t)\)</span>已知，能由一段时间内的输出测量值唯一确定任意时刻的状态，称为系统可控。定义系统可控性阵为 <span class="math display">\[Q_o=[C\quad CA\cdots CA^{n-1}]^T\]</span> 如果它是满秩的，那么系统可观。</p><h4 id="标准型">标准型</h4><p>如果一个<span class="math inline">\(n\)</span>阶单输入系统可控，则一定存在一个可逆线性变换，将其变为可控标准型。系统的可控标准型为： <span class="math display">\[A_c=\begin{pmatrix}0&amp;1&amp;0&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\ddots&amp;\ddots&amp;\vdots\\0&amp;0&amp;\cdots&amp;\cdots&amp;0\\0&amp;0&amp;\cdots&amp;\cdots&amp;1\\-a_0&amp;-a_1&amp;\cdots&amp;\cdots&amp;-a_{n-1}\end{pmatrix},B_c=\begin{pmatrix}0\\\vdots\\0\\1\end{pmatrix},C_c=(\beta_0,\cdots,\beta_{n-1})\]</span> 此时，对应的系统函数为： <span class="math display">\[G(s)=\frac{\beta_{n-1} s^{n-1}+\cdots+\beta_1 s+\beta_0}{s^n+a_{n-1} s^{n-1}+\cdots+a_1 s+a_0}\]</span> 类似的，有可观测标准型： <span class="math display">\[A_o=\left[\begin{array}{ccccc}0 &amp; 0 &amp; \cdots &amp; 0 &amp; -a_0 \\1 &amp; \cdots &amp; \cdots &amp; 0 &amp; -a_1 \\0 &amp; \ddots &amp; &amp; \vdots &amp; \vdots \\\vdots &amp; &amp; \ddots &amp; \vdots &amp; \vdots \\0 &amp; \cdots &amp; 0 &amp; 1 &amp; -a_{n-1}\end{array}\right], \quad B_o=\left[\begin{array}{c}\gamma_0 \\\gamma_1 \\\vdots \\\gamma_{n-1}\end{array}\right]，C_o=[0,0,\cdots,1]\]</span> 对应的单输入单输出系统传递函数： <span class="math display">\[G(s)=\frac{\gamma_{n-1} s^{n-1}+\cdots+\gamma_1 s+\gamma_0}{s^n+a_{n-1} s^{n-1}+\cdots+a_1 s+a_0}\]</span> 把一个系统的一般形式化成可控标准型，遵循以下步骤：</p><ol type="1"><li><p>计算可控性矩阵<span class="math inline">\(Q_c\)</span></p></li><li><p>计算<span class="math inline">\(Q_c^{-1}\)</span>，记其最后一行为<span class="math inline">\(h^T\)</span></p></li><li><p>构造矩阵<span class="math inline">\(P\)</span>，并求逆 <span class="math display">\[\boldsymbol{P}=\left[\begin{array}{c}\boldsymbol{h}^T \\\boldsymbol{h}^T \boldsymbol{A} \\\boldsymbol{h}^T \boldsymbol{A}^2 \\\vdots \\\boldsymbol{h}^T \boldsymbol{A}^{n-1}\end{array}\right]\]</span></p></li><li><p>得<span class="math inline">\(\overline A=PAP^{-1},\overline B=PB,\overline C=CP^{-1},\overline D=D\)</span></p></li></ol><blockquote><p>【例】把以下系统化为可控标准型 <span class="math display">\[\dot{\boldsymbol{x}}=\left[\begin{array}{ccc}-2 &amp; 2 &amp; -1 \\0 &amp; -2 &amp; 0 \\1 &amp; -4 &amp; 0\end{array}\right] \boldsymbol{x}+\left[\begin{array}{l}0 \\1 \\1\end{array}\right] u\]</span> 【解】有： <span class="math display">\[Ab=\left[\begin{array}{c}1 \\-2 \\-4\end{array}\right],A^2b=\left[\begin{array}{c}-2 \\4 \\9\end{array}\right]\]</span> 得 <span class="math display">\[Q_c=[b\quad Ab\quad A^2b]=\left[\begin{array}{ccc}0 &amp; 1 &amp; -2 \\1 &amp; -2 &amp; 4 \\1 &amp; -4 &amp; 9\end{array}\right]\]</span> 求逆，有： <span class="math display">\[Q_c^{-1}=\left[\begin{array}{ccc}2 &amp; 1 &amp; 0 \\5 &amp; -2 &amp; -2 \\2 &amp; -1 &amp; 1\end{array}\right]\]</span> 取最后一行： <span class="math display">\[h^T=[2\quad -1\quad -1]\]</span> 所以 <span class="math display">\[P=\left[\begin{array}{c}h^T \\h^TA \\h^TA^2\end{array}\right]=\left[\begin{array}{ccc}2 &amp; -1 &amp; 1\\-3 &amp;2 &amp; -2 \\4 &amp; -2 &amp; 3\end{array}\right]\]</span> 所以 <span class="math display">\[\overline A=PAP^{-1}=\left[\begin{array}{ccc}0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\-2 &amp; -5 &amp; -4\end{array}\right]\]</span></p></blockquote><h3 id="状态反馈和极点配置">状态反馈和极点配置</h3><p>对于定常系统 <span class="math display">\[\begin{cases}\dot x=Ax+Bu\\y=Cx\end{cases}\]</span> 如果系统的输入<span class="math inline">\(u\)</span>和<span class="math inline">\(x\)</span>有关系，即 <span class="math display">\[u=hx+r\]</span> 这就叫做状态反馈系统。</p><p>对于系统<span class="math inline">\((A,B,C,0)\)</span>来说，其极点为特征方程<span class="math inline">\(|sI-A|=0\)</span>的根，如果系统不能达到设计指标，那么就需要修改系统的极点的位置，可以适当选取状态反馈变量<span class="math inline">\(h\)</span>，使得状态反馈系统的特征方程<span class="math inline">\(|sI-(A+Bh)|=0\)</span>的根满足性能要求。这样的过程就是极点配置过程。</p><p>只有系统<span class="math inline">\((A,B,C,0)\)</span>完全可控时，才能进行极点配置。</p><blockquote><p>【例】系统 <span class="math display">\[\begin{cases}\dot x=Ax+\begin{bmatrix}2\\1\end{bmatrix}u\\y=[1\quad 1]x\end{cases}\]</span> 的状态转移矩阵 <span class="math display">\[\phi(t)=\begin{bmatrix}e^{-t} &amp; 0\\\beta(e^{-t}-e^{-2t}) &amp; e^{-2t}\end{bmatrix}\]</span></p><ol type="1"><li>求<span class="math inline">\(A\)</span></li><li>计算传递函数，写出可控标准型</li><li>设<span class="math inline">\(\beta=1\)</span>，考虑状态反馈<span class="math inline">\(u=hx\)</span>，设计<span class="math inline">\(h\)</span>使得闭环系统极点为<span class="math inline">\(-1,-3\)</span></li></ol><p>【解】</p><ol type="1"><li><p>做拉普拉斯变换，有： <span class="math display">\[\phi(s)=\begin{bmatrix}\frac 1{s+1} &amp; 0\\\frac \beta{s+1}-\frac \beta{s+2} &amp; \frac 1{s+2}\end{bmatrix}\]</span> 由<span class="math inline">\(\phi=(sI-A)^{-1}\)</span>，先求<span class="math inline">\(\phi^{-1}\)</span>: <span class="math display">\[\phi^{-1}={(s+1)(s+2)}\begin{bmatrix}\frac 1{s+2} &amp; 0\\\frac{-\beta}{(s+1)(s+2)} &amp; \frac 1{s+1}\end{bmatrix}=\begin{bmatrix}{s+1} &amp; 0\\{-\beta} &amp; {s+2}\end{bmatrix}=sI-A\]</span> 所以 <span class="math display">\[A=\begin{bmatrix}-1 &amp; 0\\\beta &amp; -2\end{bmatrix}\]</span></p></li><li><p>传递函数(法1) <span class="math display">\[G(s)=C\phi(s)B=\frac{2\beta+2}{s+1}-\frac{2\beta-1}{s+2}\]</span> 即 <span class="math display">\[G(s)=\frac{s+2\beta+5}{s^2+3s+2}\]</span> 所以 <span class="math display">\[A=\begin{bmatrix}0 &amp; 1\\-2 &amp; -3\end{bmatrix},B=\begin{bmatrix}0\\1\end{bmatrix},C=[2\beta+5\quad 1]\]</span></p></li><li><p>有： <span class="math display">\[\begin{aligned}|sI-(A+BH)|&amp;=\det\begin{bmatrix}s-2H_1+1 &amp; -2H_2\\-H_1-1 &amp; s-H_2+2\end{bmatrix}\\&amp;=s^2+(3-2H_1-H_2)s+2-4H_1-3H_2\end{aligned}\]</span> 要达到题设要求的极点，则要求特征方程为 <span class="math display">\[(s+1)(s+3)=s^2+4s+3\]</span> 对比系数，解方程，得 <span class="math display">\[H=[-1\quad 1]\]</span></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理笔记·数字通信</title>
    <link href="/2023/06/09/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%C2%B7%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/06/09/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%C2%B7%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>虽然这里名叫数字通信，但是需要注意的是，数字通信实际包含三部分内容，即</p><ul><li><a href="https://suzumiyaakizuki.github.io/2023/05/23/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93/">数字信号基带传输</a></li><li>数字调制</li><li>差错控制编码</li></ul><p>但是因为如果单个文件太大、公式太多，写起来会有点卡顿，看起来也比较费劲，所以拆成两篇文章。这篇文章的主要内容是数字调制和差错控制编码。</p><h2 id="数字调制">数字调制</h2><h3 id="二进制调制ook">二进制调制OOK</h3><p>把幅度为<span class="math inline">\(2A\)</span>的单极性非归零码按DSB方式进行调制，得到的就是单极性二进制幅移键控（2ASK），也叫二进制启闭键控（OOK），系统框图如下（其实就是DSB调制的框图）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101922269.png" alt="OOK框图" style="zoom:25%;" /></p><p>即： <span class="math display">\[s(t)=a(t)\sqrt 2 \cos(2\pi f_ct+\phi)\]</span> 调制信号波形示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101926854.png" alt="OOK波形" /><figcaption aria-hidden="true">OOK波形</figcaption></figure><p>波形功率谱密度为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101930718.png" alt="OOK功率谱" /><figcaption aria-hidden="true">OOK功率谱</figcaption></figure><p>可以看出，这个功率谱旁瓣比较高，不是很好。那咋办呢？一种常见的设计就是加个成形滤波。我们采用根升余弦成形滤波，则波形图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101932719.png" alt="根升余弦OOK波形图" /><figcaption aria-hidden="true">根升余弦OOK波形图</figcaption></figure><p>功率谱如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101932930.png" alt="根升余弦功率谱" style="zoom:50%;" /></p><p>看着是不是顺眼多了。其带宽为 <span class="math display">\[\frac{1+\alpha}{T_b}\]</span> 里面的<span class="math inline">\(\alpha\)</span>是根升余弦滤波器的滚降因子。频谱效率为<span class="math inline">\(1/(1+\alpha)\)</span></p><p>在解调时，因为是DSB信号，所以可以用DSB信号的解调方法，比如相干解调</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101941159.png" alt="相干解调" /><figcaption aria-hidden="true">相干解调</figcaption></figure><p>其中MF是匹配滤波器，如果<span class="math inline">\(g(t)\)</span>是矩形窗，那么MF是积分清零器。</p><p>B点基带输入信号、噪声功率谱密度与上一章匹配滤波器输入信号、噪声功率谱密度完全一致，C点判决误符号率为 <span class="math display">\[p_s=Q\left(\frac A{\sqrt{n_0/2}}\right)\]</span> 因为<span class="math inline">\(E_b=E_s=\frac 12(0+4A^2)\)</span>，所以 <span class="math display">\[p_b=Q\left(\sqrt{\frac{E_b}{n_0}}\right)\]</span></p><p>此外，还可以使用包络检波器进行非相干解调。非相干解调的误比特率比相干解调略高，信噪比差在匹配滤波上。</p><h3 id="其余二进制调制">其余二进制调制</h3><h4 id="bpsk">BPSK</h4><p>对单极性非归零码进行相位调制，得到BPSK信号，框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102009621.png" alt="BPSK框图" /><figcaption aria-hidden="true">BPSK框图</figcaption></figure><p>信号表达式为： <span class="math display">\[s(t)=A\sqrt 2cos [2\pi f_ct+\pi  a(t)]\]</span> 其波形是在两种相反的相位（<span class="math inline">\(0,\pi\)</span>）之间切换的正弦波，即：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102010341.png" alt="BPSK波形" /><figcaption aria-hidden="true">BPSK波形</figcaption></figure><p>它也可以理解为一个DSB信号，即：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102011550.png" alt="BPSK调制（DSB版）" /><figcaption aria-hidden="true">BPSK调制（DSB版）</figcaption></figure><p>它和前面的OOK都是2ASK，不过其中一个的幅度是<span class="math inline">\(\{0,A\}\)</span>,而另一个是<span class="math inline">\(\{-A,A\}\)</span></p><p>与OOK相比，其功率谱中没有冲击分量，其余的形状和参数基本类似。</p><p>在解调上，包络检波器显然是不能用了，所以只能相干解调。输出判决误符号率是 <span class="math display">\[p_s=Q\left(\frac A{\sqrt{n_0/2}}\right)\]</span> 但是因为<span class="math inline">\(E_b=E_s=\frac 12 (A^2+A^2)\)</span>，所以： <span class="math display">\[p_b=Q\left(\sqrt{\frac{2E_b}{n_0}}\right)\]</span> 在相同<span class="math inline">\(E_b/n_0\)</span>的条件下，BPSK的误比特率比OOK更低.</p><h4 id="二进制频移键控2fsk">二进制频移键控2FSK</h4><p>把单极性非归零码进行FM调制，就得到2FSK。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102024865.png" alt="image-20230610202459784" style="zoom:25%;" /></p><p>信号表达式为： <span class="math display">\[s(t)=A \sqrt{2} \cos \left[2 \pi f_c t+2 \pi K_{F M} \int_{-\infty}^t a(\tau) d \tau\right]\]</span> 波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102025565.png" alt="2FSK波形" /><figcaption aria-hidden="true">2FSK波形</figcaption></figure><p>当然，如果至少为了实现频率切换，其实还有更方便的方法：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102027135.png" alt="更方便的2FSK" /><figcaption aria-hidden="true">更方便的2FSK</figcaption></figure><p>特别注意：这两个框图并不等价，主要差别在相位是否连续。第二个框图的表达式为 <span class="math display">\[s(t)=\left\{\begin{array}{l}s_1(t)=A \sqrt{2} \cos \left(2 \pi f_1 t+\phi_1\right), a(t)=0 \\s_2(t)=A \sqrt{2} \cos \left(2 \pi f_2 t+\phi_2\right), a(t)=1\end{array}\right.\]</span> 波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102032579.png" alt="image-20230610203256495" /><figcaption aria-hidden="true">image-20230610203256495</figcaption></figure><p>在实践中，一般要求这两个载波信号相互正交，具体来说，就是： <span class="math display">\[\frac{1}{T_s} \int_{k T_s}^{(k+1) T_s} s_1(t) s_2(t) d t=0\]</span> 满足要求的最小频差为<span class="math inline">\(1/2T_b\)</span></p><p>对于上面的那个表达式，可以改写为： <span class="math display">\[s(t)=  {[1-a(t)] A \cdot \sqrt{2} \cos \left(2 \pi f_1 t+\phi_1\right)+}a(t) A \cdot \sqrt{2} \cos \left(2 \pi f_2 t+\phi_2\right)\]</span> 这就是两个OOK之和</p><p>所以它的功率谱密度也是两个OOK之和，即：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102036246.png" alt="image-20230610203610136" /><figcaption aria-hidden="true">image-20230610203610136</figcaption></figure><p>主瓣带宽为<span class="math inline">\(2R_b+\Delta f\)</span></p><p>2FSK一般不用根升余弦脉冲来改善旁瓣，因为这是因为2FSK系统具有恒定的包络，而根号升余弦脉冲成形后的信号包络不是常数（恒包络调制容易实现高发射功率）。</p><p>因为是两个OOK之和，所以既可以用相干解调，也可以用非相干解调，误比特率也和OOK一样，为： <span class="math display">\[p_b=Q\left(\sqrt{\frac{E_b}{n_0}}\right)\]</span> 在相同<span class="math inline">\(E_b/n_0\)</span>的条件下，2FSK和OOK有相同的抗噪声性能</p><p>但如果载波幅度𝐴相同，则OOK的平均比特能量比2FSK小一半，此时OOK的误比特率比2FSK高</p><h4 id="二进制差分相移键控2dpsk">二进制差分相移键控2DPSK</h4><p>若将输入的比特序列先进行差分编码，然后进行BPSK调制，如下图所示，便形成了二进制差分相移键控.</p><p>波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102050391.png" alt="2DPSK" /><figcaption aria-hidden="true">2DPSK</figcaption></figure><p>图中是传号差分，即<span class="math inline">\(d=0\)</span>时相位不变，<span class="math inline">\(d=1\)</span>时相位翻转。</p><p>因为2DPSK从本质上来说还是BPSK，所以可以相干解调。但是2DPSK信息携带在前后两个比特的已调信号相位差上，因此其解调也可以直接检测这个相位差。这种方法叫差分相干解调，如下图所示。因为不需要提取载波，故其属于非相干解调。</p><p>差分译码器的输出是 <span class="math display">\[\hat d_k=\hat c_k \oplus \hat c_{k-1}\]</span> 所以2DPSK相干解调误比特率是 <span class="math display">\[P_s=P_b=2 Q\left(\sqrt{\frac{2 E_b}{n_0}}\right)\left[1-Q\left(\sqrt{\frac{2 E_b}{n_0}}\right)\right]\]</span> 近似为BPSK的两倍，而且会出现误码传播情况。</p><p>直观看一下各个二进制调制的误比特率：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102101982.png" alt="误比特率曲线" /><figcaption aria-hidden="true">误比特率曲线</figcaption></figure><blockquote><p>【例（2022期末）】某二进制数字信号码元传输速率是<span class="math inline">\(2\times 10^6baud\)</span>，分别采用2ASK、2PSK、2FSK系统传输，载波频率100MHz，FSK系统两个频率分别为<span class="math inline">\(f_1=95MHz,f_0=105MHz\)</span>，输入接收端解调器的信号振幅为<span class="math inline">\(A=40\mu V\)</span>，信道噪声是加性高斯白噪声，单边功率谱密度<span class="math inline">\(n_0=5\times 10^{-18} W/Hz\)</span>，求</p><ol type="1"><li>2ASK、2PSK、2FSK频带宽度</li><li>相干接收时，2ASK、2PSK、2FSK误码率</li></ol><p>【解】</p><ol type="1"><li><p>频带宽带，有：<span class="math inline">\(BW_{ASK}=BW_{PSK}=2R_b=4MHz\)</span></p><p><span class="math inline">\(BW_{FSK}=2R_b+\Delta f=14MHz\)</span></p></li><li><p><strong>对2ASK：</strong></p><p><span class="math inline">\(P_1=\frac 12 A^2=8\times 10^{-10}\)</span>，<span class="math inline">\(P_0=0\)</span></p><p>所以平均符号功率：<span class="math inline">\(P_s=\frac 12(P_1+P_0)=4\times 10^{-10}\)</span></p><p>时间为<span class="math inline">\(T_s=1/R_s=5\times 10^{-7}\)</span></p><p>则平均符号能量为<span class="math inline">\(E_s=P_sT_s=2\times 10^{-16}\)</span></p><p>代入 <span class="math display">\[P_e=Q\left(\sqrt{\frac{E_s}{n_0}}\right)=Q(2\sqrt{10})\]</span> <strong>对2PSK：</strong></p><p><span class="math inline">\(P_s=\frac 12A^2=8\times 10^{-10}\)</span></p><p>时间为<span class="math inline">\(T_s=1/R_s=5\times 10^{-7}\)</span></p><p>则平均符号能量为<span class="math inline">\(E_s=P_sT_s=4\times 10^{-16}\)</span></p><p>代入： <span class="math display">\[P_e=Q\left(\sqrt{\frac{2E_s}{n_0}}\right)=Q(4\sqrt{10})\]</span> <strong>对2FSK</strong>：</p><p><span class="math inline">\(P_s=\frac 12A^2=8\times 10^{-10}\)</span></p><p>时间为<span class="math inline">\(T_s=1/R_s=5\times 10^{-7}\)</span></p><p>则平均符号能量为<span class="math inline">\(E_s=P_sT_s=4\times 10^{-16}\)</span></p><p>代入： <span class="math display">\[P_e=Q\left(\sqrt{\frac{E_s}{n_0}}\right)=Q(4\sqrt{5})\]</span></p></li></ol></blockquote><h3 id="正交相移键控qpsk">正交相移键控QPSK</h3><p>可在BPSK的基础上叠加另一个正交载波的BPSK，两个BPSK各传一半数据，如下图所示，这种方式称为正交相移键控（QPSK）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102126707.png" alt="QPSK" /><figcaption aria-hidden="true">QPSK</figcaption></figure><p>在QPSK中，因为数据被串并转换了，所以符号间隔<span class="math inline">\(T_s=2T_b\)</span>。</p><p>发送单个符号<span class="math inline">\((a_{I,k},a_{Q,k})\)</span>时QPSK的数学表达式为： <span class="math display">\[\begin{aligned}s(t)=  \sqrt{2} A a_{I, k} g\left(t-k T_s\right) \cos \left(2 \pi f_c t+\phi\right)-  \sqrt{2} A a_{Q, k} g\left(t-k T_s\right) \sin \left(2 \pi f_c t+\phi\right)\end{aligned}\]</span> 化简得： <span class="math display">\[s(t)=2 g\left(t-k T_s\right) \cos \left(2 \pi f_c t+\phi+\theta_k\right)\]</span> 其中信号控制的是<span class="math inline">\(\theta_k\)</span>，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102145570.png" alt="QPSK相位数据对应表" /><figcaption aria-hidden="true">QPSK相位数据对应表</figcaption></figure><p>星座图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102145947.png" alt="image-20230610214557879" /><figcaption aria-hidden="true">image-20230610214557879</figcaption></figure><p>其功率谱密度是BPSK的两倍。</p><p>对QPSK的解调可以用I/Q两路BPSK解调器组合而成，每个BPSK的误比特率是 <span class="math display">\[p_b=Q\left(\sqrt{\frac{2E_b}{n_0}}\right)\]</span> 所以QPSK的误符号率是 <span class="math display">\[p_s=1-(1-p_b)^2\]</span> 当信噪比较高时，误符号率近似是误比特率的2倍</p><h4 id="oqpsk">OQPSK</h4><p>在普通QPSK中，有时候会出现包络起伏比较严重的情况。为了降低包络起伏程度，可以把两路信号在时间上错开，错开零点，这就叫OQPSK</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102151092.png" alt="QPSK和OQPSK" /><figcaption aria-hidden="true">QPSK和OQPSK</figcaption></figure><p>在发送端，将Q路的信号延迟<span class="math inline">\(T_b=T_s/2\)</span>即可。其功率谱、误码率等和QPSK相同。</p><h4 id="恒包络调制msk">恒包络调制MSK</h4><p>为了降低非线性失真的影响，希望数字调制的输出信号有较低的包络起伏。OQPSK就是为此目的提出的，它通过将Q路错开𝑇𝑏时间使包络的起伏显著减小。包络起伏最小的情况是无起伏，即包络是常数。包络是常数的调制称为恒包络调制。</p><p>在2FSK中，若FM调制的设计能使2FSK信号的两个频率的频差成为保持正交的最小间隔<span class="math inline">\(1/2T_s\)</span>，那就得到了最小频移键控MSK。</p><p>有： <span class="math display">\[s(t)==A \cos \left[2 \pi f_{\mathrm{c}} t+2 \pi K_{\mathrm{FM}} \int_{-\infty}^t a(\tau) \mathrm{d} \tau\right]\]</span> 其相位有： <span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} t} \varphi(t)=\frac{\pi}{2 T_{\mathrm{b}}} \cdot a(t)=\frac{\pi}{2 T_{\mathrm{b}}} \cdot \sum_{i=-\infty}^{\infty} b_i g\left(t-i T_{\mathrm{b}}\right)\]</span> 其中<span class="math inline">\(a(t)\)</span>是取值于<span class="math inline">\(\pm1\)</span>的双极性NRZ信号，<span class="math inline">\(g(t)\)</span>是持续时间为<span class="math inline">\([0,Ts]\)</span>,高度为1的矩形脉冲。<span class="math inline">\(b\in\{±1\}\)</span>代表双极性NRZ信号所携带的二进制数据。</p><p>MSK是用FM形成的，而不是用开关形成的，相位是连续的，而且可以绘出相位路径：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102212833.png" alt="MSK相位路径" /><figcaption aria-hidden="true">MSK相位路径</figcaption></figure><p>其在每一个比特间隔中都是连续线性变化，往上走还是往下走取决于<span class="math inline">\(b_i\)</span>的取值。如果<span class="math inline">\(b_i\)</span>是<span class="math inline">\(1\)</span>，那就是往上走，否则如果<span class="math inline">\(b_i=-1\)</span>就是往下走。</p><p>事实上如果OQASK使用了一种特殊的成型脉冲：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102216057.png" alt="特殊地成型脉冲" style="zoom:25%;" /></p><p>那它就是MSK。所以MSK的功率谱可以从OQPSK得到。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102217064.png" alt="MSK和QPSK的功率谱" /><figcaption aria-hidden="true">MSK和QPSK的功率谱</figcaption></figure><p>MSK的主瓣带宽是<span class="math inline">\(1.5/𝑇_𝑏\)</span>，QPSK的主瓣带宽是<span class="math inline">\(1/𝑇_𝑏\)</span></p><h3 id="高阶调制">高阶调制</h3><h4 id="mask">MASK</h4><p>类比于2ASK，其中M是符号数。在功率谱上，双极性MASK信号与BPSK一致（没有线谱），单极性MASK信号与OOK一致（有线谱）。MASK的误符号率已经在“数字信号基带传输”里分析过了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102154836.png" alt="双极性MASK误符号率曲线" /><figcaption aria-hidden="true">双极性MASK误符号率曲线</figcaption></figure><h4 id="qam">QAM</h4><p>类似于用俩载波正交BPSK构成QPSK，也可以用俩载波正交ASK构成QAM。</p><p>MQAM是由两路<span class="math inline">\(\sqrt M\)</span>ASK组成的：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102157477.png" alt="16QAM" /><figcaption aria-hidden="true">16QAM</figcaption></figure><p>误符号率： <span class="math display">\[p_s=1-\left(1-p_{s, \mathrm{ASK}}\right)^2 \approx \frac{4(\sqrt{M}-1)}{\sqrt{M}} Q\left(\sqrt{\frac{3}{M-1} \frac{E_s}{n_0}}\right)\]</span></p><h4 id="mfsk">MFSK</h4><p>MFSK的星座图是在M维欧氏空间的每个坐标轴上放一个点。</p><p>对某一个载频来说，开关时而接通，时而断开，形成一个OOK。因此可将MFSK信号看成是M个OOK信号的叠加。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102202551.png" alt="MFSK框图" /><figcaption aria-hidden="true">MFSK框图</figcaption></figure><p>主瓣带宽为： <span class="math display">\[B=\left|f_M-f_1\right|+2 R_s\]</span> 在频差按最佳设计的情况下，相邻载波的频差是1/(2𝑇𝑠 )=𝑅𝑠/2，主瓣带宽为 <span class="math display">\[B=\frac{M-1}{2} R_s+2 R_s=\frac{M}{2} R_s+1.5 R_s\]</span></p><h4 id="mpsk">MPSK</h4><p>MPSK的星座分布在圆上</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306102209338.png" alt="MPSK" /><figcaption aria-hidden="true">MPSK</figcaption></figure><h2 id="差错控制编码">差错控制编码</h2><p>在实际信道上传输数字信号时，由于信道传输特性不理想及加性噪声的影响，接收端所收到的数字信号不可避免地会发生错误。为了在给定信噪比情况下达到一定的误比特率指标，应该合理设计基带信号，选择调制解调方式，采用时域、频域均衡，使误比特率尽可能降低。但若误比特率仍不能满足要求，则必须采用信道编码（即差错控制编码），将误比特率进一步降低。</p><p>差错控制的基本思路是：在发送端给被传送的信息附带一些冗余的监督码元，这些监督码元和信息码元之间以某种规则建立联系，然后在接收端检验收到的信息是否符合这样的联系，如果不符合，那么就可以断定传输中出现了错误。</p><p>常用的差错控制方式主要有三种：检错重发（实时性不好），前向纠错（效率高，实时性好，可靠性低），混合ARQ。其中检错重发又有停发等候重发、返回重发、选择重发。</p><h3 id="检错和纠错的基本原理">检错和纠错的基本原理</h3><p>之前已经说了差错控制的基本思路，接下来举例说明一下。</p><p>比如三位二进制码共有八种，即：<code>000</code>,<code>001</code>,<code>010</code>,<code>011</code>,<code>100</code>,<code>101</code>,<code>110</code>,<code>111</code></p><p>如果都用来传递信息，那么不能检错。</p><p>但是如果只使用四个码<code>000</code>,<code>011</code>,<code>101</code>,<code>110</code>，其中前两位是要传递的信息，而最后一位是前两位的模2和，其它四个码是禁用码字。如果接收端接收到了禁用码字，那么就可以断言传输过程中出现了错误。这就是检错的过程。</p><p>在信道编码中，定义码组中非零位的数目为码组的重量，简称<strong>码重</strong>。</p><p>把两个码组中对应码位上具有不同二进制位的位数定义为两码组的距离，称为<strong>汉明距</strong>，简称<strong>码距</strong>。</p><p>如果要在一个码组内检测<span class="math inline">\(e\)</span>个误码，要求最小码距 <span class="math display">\[d_{min}\geq e+1\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092042269.png" alt="示意图" /></p><p>如图所示，如果误码个数不超过<span class="math inline">\(e\)</span>，则说明码组的位置移动不会离开半径为<span class="math inline">\(e\)</span>的多维球中。这意味着其它码组必须位于以<span class="math inline">\(C\)</span>为圆心，以<span class="math inline">\(e+1\)</span>为半径的圆上或圆外。</p><p>如果要在一个码组内纠正<span class="math inline">\(t\)</span>个误码，要求最小码距 <span class="math display">\[d_{min}\geq 2t+1\]</span> 示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092045497.png" alt="纠错示意图" /><figcaption aria-hidden="true">纠错示意图</figcaption></figure><p>只要这两个码字的移动范围不相交，那么就可以进行纠正。</p><p>如果要在一个码组内纠正<span class="math inline">\(t\)</span>个误码，同时检测<span class="math inline">\(e\)</span>个误码，则要求最小码距 <span class="math display">\[d_{min}\geq t+e+1\]</span> 示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092047657.png" alt="纠错检错示意图" /><figcaption aria-hidden="true">纠错检错示意图</figcaption></figure><h3 id="线性分组码">线性分组码</h3><p>将信息码分组，为每组信息位附加若干监督位，且信息位和监督位间的关系可由线性方程组表示的编码，称为线性分组码。这些码字构成一个群，性质有：</p><ul><li>任意两个码字的逐位模2和仍然是码字</li><li>码的最小距离等于非零码的最小重量</li></ul><p>比如前面提到的奇偶校验码，就是一种最简单的线性分组码，其偶校验关系为： <span class="math display">\[a_0\oplus a_1\cdots a_{n-1}=0\]</span> 接收时，计算 <span class="math display">\[s=a_1+a_2+\cdots+a_{n-1}\]</span> 这里的<span class="math inline">\(s\)</span>称为校正子或者伴随式，如果<span class="math inline">\(s=0\)</span>表示没有错误。</p><p>对于码总长为<span class="math inline">\(n\)</span>，信息位长度为<span class="math inline">\(k\)</span>，校验长度为<span class="math inline">\(r=n-k\)</span>的线性分组码，一般记作<span class="math inline">\((n,k)\)</span>线性分组码。例如上面的奇偶校验码就是<span class="math inline">\((n,n-1)\)</span>线性分组码。如果满足<span class="math inline">\(2^r-1\geq n\)</span>，则有可能构造出纠正一位甚至更多错误的分组码。</p><p>下面通过一个更加一般的例子来说明如何构造线性分组码。设<span class="math inline">\((n,k)\)</span>分组码中<span class="math inline">\(n=7\)</span>，要求校正一位错误，则<span class="math inline">\(r\geq 3\)</span>。现取<span class="math inline">\(r=3,k=4\)</span>，即为<span class="math inline">\((7,4)\)</span>分组码。用<span class="math inline">\(a_0a_1a_2a_3a_4a_5a_6\)</span> 表示一个码字，用<span class="math inline">\(s_1s_2s_3\)</span>表示三个校正子，假设<span class="math inline">\(s_1s_2s_3\)</span>和误码位置的关系如下表：</p><table><thead><tr class="header"><th>s1s2s3</th><th>误码位置</th><th>s1s2s3</th><th>误码位置</th></tr></thead><tbody><tr class="odd"><td>001</td><td>a0</td><td>101</td><td>a4</td></tr><tr class="even"><td>010</td><td>a1</td><td>110</td><td>a5</td></tr><tr class="odd"><td>100</td><td>a2</td><td>111</td><td>a6</td></tr><tr class="even"><td>011</td><td>a3</td><td>000</td><td>无误码</td></tr></tbody></table><p>先看<span class="math inline">\(s_1\)</span>，当误码位置为<span class="math inline">\(a_2,a_4,a_5\)</span>或<span class="math inline">\(a_6\)</span>时，<span class="math inline">\(s_1=1\)</span>，因此，有： <span class="math display">\[s_1=a_2+a_4+a_5+a_6\]</span> 如法炮制，对<span class="math inline">\(s_2\)</span>有： <span class="math display">\[s_2=a_1+a_3+a_5+a_6\]</span> 对<span class="math inline">\(s_3\)</span>有： <span class="math display">\[s_3=a_6+a_4+a_3+a_0\]</span> 假设<span class="math inline">\(a_3a_4a_5a_6\)</span>是用来承载信息的位，<span class="math inline">\(a_0a_1a_2\)</span>是校验位，则有： <span class="math display">\[\begin{cases}a_6+a_5+a_4+a_2=0\\a_6+a_5+a_3+a_1=0\\a_6+a_4+a_3+a_0=0\end{cases}\]</span> 移项一下，就是： <span class="math display">\[\left\{\begin{array}{l}a_2=a_6+a_5+a_4 \\a_1=a_6+a_5+a_3 \\a_0=a_6+a_4+a_3\end{array}\right.\]</span> 由此可以生成16个许用码字：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306092207213.png" alt="（7，4）分组码" /><figcaption aria-hidden="true">（7，4）分组码</figcaption></figure><p>如果把检验方程式写成比较完整的形式，有： <span class="math display">\[\left\{\begin{array}{l}1 \cdot a_6+1 \cdot a_5+1 \cdot a_4+0 \cdot a_3+1 \cdot a_2+0 \cdot a_1+0 \cdot a_0=0 \\1 \cdot a_6+1 \cdot a_5+0 \cdot a_4+1 \cdot a_3+0 \cdot a_2+1 \cdot a_1+0 \cdot a_0=0 \\1 \cdot a_6+0 \cdot a_5+1 \cdot a_4+1 \cdot a_3+0 \cdot a_2+0 \cdot a_1+1 \cdot a_0=0\end{array}\right.\]</span> 写成矩阵形式，有： <span class="math display">\[\left[\begin{array}{lllllll}1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{lllllll}a_6 &amp; a_5 &amp; a_4 &amp; a_3 &amp; a_2 &amp; a_1 &amp; a_0\end{array}\right]^T=\left[\begin{array}{l}0 \\0 \\0\end{array}\right]\]</span> 即： <span class="math display">\[Ha=0\]</span></p><p>这里的<span class="math inline">\(r\times n\)</span>矩阵<span class="math inline">\(H\)</span>​称为<strong>校验矩阵</strong>，信息位与校验位之间的校验关系完全由<span class="math inline">\(H\)</span>决定。矩阵中元素1表示相应位之间存在偶校验关系. <span class="math display">\[\mathbf{H}=\left[\begin{array}{llllllll}1 &amp; 1 &amp; 1 &amp; 0 &amp; \vdots &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 &amp; \vdots &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 &amp; \vdots &amp; 0 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{ll}\mathbf{P} &amp; \mathbf{I}_r\end{array}\right]\]</span> 其中<span class="math inline">\(P\)</span>是<span class="math inline">\(r\times k\)</span>阶矩阵，表示实际校验关系，而<span class="math inline">\(I\)</span>是<span class="math inline">\(r\)</span>阶单位阵，表示校验位是<span class="math inline">\(a_2a_1a_0\)</span>这三位。具有上面形式的校验矩阵称为<strong>系统形式校验矩阵</strong>。</p><p>对于生成方程，也可以写出其矩阵形式： <span class="math display">\[\left[\begin{array}{lll}a_2 &amp; a_1 &amp; a_0\end{array}\right]=\left[\begin{array}{llll}a_6 &amp; a_5 &amp; a_4 &amp; a_3\end{array}\right]\left[\begin{array}{lll}1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 1\end{array}\right]=\left[\begin{array}{llll}a_6 &amp; a_5 &amp; a_4 &amp; a_3\end{array}\right] \mathbf{Q}\]</span> 其中<span class="math inline">\(Q\)</span>是<span class="math inline">\(k\times r\)</span>矩阵，是<span class="math inline">\(P\)</span>的转置。如果给<span class="math inline">\(Q\)</span>的左边加上一个<span class="math inline">\(k\)</span>阶单位阵，那么就形成了一个新的矩阵<span class="math inline">\(G\)</span>，这个<span class="math inline">\(G\)</span>叫做<strong>“生成矩阵”</strong> <span class="math display">\[\mathbf{G}=\left[\begin{array}{ll}\mathbf{I}_k &amp; \mathbf{Q}\end{array}\right]=\left[\begin{array}{lllllll}1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\end{array}\right]\]</span> 那么如何利用生成矩阵生成码字呢？有： <span class="math display">\[\mathbf{a}^T=\left[\begin{array}{llll}a_6 &amp; a_5 &amp; a_4 &amp; a_3\end{array}\right] \mathbf{G}\]</span></p><blockquote><p>【例】某<span class="math inline">\((n,k)\)</span>线性分组码的监督（校验）矩阵是： <span class="math display">\[H=\left[\begin{array}{lllllll}1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span></p><ol type="1"><li>求<span class="math inline">\(n,k\)</span></li><li>求生成矩阵</li><li>现在要传输信息<code>110</code>，请写出生成码字</li><li>假设接收到了<code>B=1000011</code>，请纠正</li></ol><p>【解】</p><ol type="1"><li><p>因为<span class="math inline">\(H\)</span>是<span class="math inline">\(4\times 7\)</span>矩阵，所以<span class="math inline">\(n=7,k=n-r=3\)</span></p></li><li><p>因为 <span class="math display">\[H=[P\quad I_4]\]</span> 所以 <span class="math display">\[Q=P^T=\left[\begin{array}{lll}1&amp;1 &amp; 1 &amp; 0 \\0&amp;1 &amp; 1 &amp; 1 \\1&amp;1 &amp; 0 &amp; 1\end{array}\right]\]</span> 所以 <span class="math display">\[G=[I_k Q]=\left[\begin{array}{lllllll}1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1\end{array}\right]\]</span></p></li><li><p>当信息为<code>110</code>时，有： <span class="math display">\[A=[110]G=[1101001]\]</span> 所以信息是<code>1101001</code></p></li><li><p>由校正子： <span class="math display">\[S=BH^T=(1000011)\left[\begin{array}{llll}1 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 1 \\1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]=(1101)\]</span> 因为 <span class="math display">\[S=EH^T\]</span> 得校正子为<code>0010000</code>，所以纠错后的码字为<code>1010011</code></p></li></ol></blockquote><h3 id="汉明码">汉明码</h3><p>汉明码是最早发现，最知名的分组码之一。它有以下特点：</p><ul><li>码长<span class="math inline">\(n=2^m-1\)</span></li><li>信息码位<span class="math inline">\(k=2^m-m-1\)</span></li><li>校验码位：<span class="math inline">\(r=n-k=m\)</span></li></ul><p>根据系统需要，有时有必要对现有的码进行修改，使其码长、信息位数目等参数的取值更为灵活，以提高实用性。对码进行修改的方法有多种，最常用的是码的扩展与缩短，从而得到扩展码和缩短码</p><p>如果要加上一位对所有位进行整体校验的校验位，则汉明码变成<span class="math inline">\((2^m,2^m-m-1)\)</span>扩展汉明码，这会在校验矩阵<span class="math inline">\(H\)</span>的最右侧添加一列全0，然后在最上面（或者最下面）添加一行全1。此时信息位数目不变但是校验位数目增大，能够纠正的错误图样也会增大。</p><p>除了扩展，也可以通过删除信息位的方式来提升纠错能力。如果把<span class="math inline">\(H\)</span>矩阵最左侧的<span class="math inline">\(s\)</span>列删除，则相当于把<span class="math inline">\(G\)</span>矩阵中的左侧的单位阵删除<span class="math inline">\(s\)</span>列，然后把这些列中非零元对应的行也一并删除。示意图如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101019812.png" alt="删除码示意图" />、</p><h3 id="循环码">循环码</h3><p>循环码是一种满足任何许用码字经过循环移位一行的码字还是许用码字的线性分组码，同样具有线性分组码的封闭性。</p><p>为了用代数学理论研究循环码，可将码字用多项式来表示，称为码多项式。码字<span class="math inline">\(A=\left(a_{n-1} a_{n-2} \cdots a_1 a_0\right)\)</span>可表示为 <span class="math display">\[A(D)=a_{n-1} D^{n-1}+a_{n-2} D^{n-2}+a_{n-3} D^{n-3}+\cdots+a_1 D+a_0\]</span> 这里的<span class="math inline">\(D\)</span>叫做哑元，它本身没什么意义，但是它的幂次很有意义。</p><p>那么如果把码字向左循环移位记作<span class="math inline">\(A^{(i)}\)</span>，那么： <span class="math display">\[A^{(i)}(D) \equiv D^i A(D) \quad \bmod \quad\left(D^n+1\right)\]</span> 对于二元码，码多项式的系数只能从0和1中选取。0和1组成一个集合，并在该集合中定义两种运算：加法和乘法，运算规则如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101047937.png" alt="GF(2)上的运算" /><figcaption aria-hidden="true">GF(2)上的运算</figcaption></figure><p><span class="math inline">\(\{0,1,\oplus,\times\}\)</span>构成一个代数系，称为二元域，它是最小的有限域（伽罗华域），记作<span class="math inline">\(GF(2)\)</span></p><p>循环码完全由其码长<span class="math inline">\(𝑛\)</span>及生成多项式<span class="math inline">\(𝑔(𝐷)\)</span>所决定.<span class="math inline">\(g(D)\)</span>是一个能整除<span class="math inline">\(D^n+1\)</span>的<span class="math inline">\(r=n-k\)</span>阶多项式，也就是说，<span class="math inline">\(g(D)\)</span>是<span class="math inline">\(D^n+1\)</span>的一个因式。所有阶数低于<span class="math inline">\(n\)</span>并且能被<span class="math inline">\(g(D)\)</span>整除（即：是<span class="math inline">\(g(D)\)</span>的倍式）的多项式就构成一个<span class="math inline">\((n,k)\)</span>循环码。</p><p>例如，对于<span class="math inline">\((7,3)\)</span>循环码，<span class="math inline">\(g(D)=D^4+D^3+D^2+1\)</span>是<span class="math inline">\(D^7+1\)</span>的一个因子，有： <span class="math display">\[\begin{aligned} 0&amp;=g(D) \cdot 0 \\ D^4+D^3+D^2+1&amp;=g(D) \cdot 1 \\ D^5+D^4+D^3+D&amp;=g(D) \cdot D \\ D^6+D^5+D^4+D^2&amp;=g(D) \cdot D^2 \\ D^5+D^2+D+1&amp;=g(D) \cdot(D+1) \\ D^6+D^3+D^2+D&amp;=g(D) \cdot\left(D^2+D\right) \\ D^6+D^5+D^3+1&amp;=g(D) \cdot\left(D^2+1\right) \\ D^6+D^4+D+1&amp;=g(D) \cdot\left(D^2+D+1\right) \\\end{aligned}\]</span> 那么这八个多项式就构成一个有八个码组的<span class="math inline">\((7,3)\)</span>循环码。</p><p>循环码的生成矩阵，可以很容易地由生成多项式得到。先写出多项式矩阵 <span class="math display">\[G(D)=\left[\begin{array}{c}D^{k-1} g(D) \\D^{k-2} g(D) \\\vdots \\D^0 g(D)\end{array}\right]\]</span> 因为 <span class="math display">\[A(D)=M(D)G(D)\]</span> 对应于前面的 <span class="math display">\[a^T=a_c^TG\]</span> 所以对应的生成矩阵就是 <span class="math display">\[\mathbf{G}=\left[\begin{array}{lcccccc}g_{n-k} &amp; g_{n-k-1} &amp; \cdots &amp; g_0 &amp; 0 &amp; \cdots &amp; 0 \\0 &amp; g_{n-k} &amp; g_{n-k-1} &amp; \cdots &amp; g_0 &amp; \cdots &amp; 0 \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\0 &amp; \cdots &amp; 0 &amp; g_{n-k} &amp; g_{n-k-1} &amp; \cdots &amp; g_0\end{array}\right]\]</span> 这是一个循环移位矩阵。可以看出，这个矩阵很可能不是系统形式矩阵，因为左边不一定是单位阵。系统码码字的最左<span class="math inline">\(k\)</span>位是信息位，随后是<span class="math inline">\(r=n-k\)</span>位校验位，也就是说码多项式是 <span class="math display">\[A(D)=M(D)D^{n-k}+r(D)\]</span> 这里 <span class="math display">\[r(D)=r_{n-k-1} D^{n-k-1}+\cdots+r_0\]</span> 是校验多项式。那么<span class="math inline">\(A(D)\)</span>能被<span class="math inline">\(g(D)\)</span>整除的条件就是 <span class="math display">\[r(D)=M(D) D^{n-k} \bmod g(D)\]</span> 于是，构造系统循环码的步骤是先把信息多项式乘以<span class="math inline">\(D^{n-k}\)</span>，然后对<span class="math inline">\(g(D)\)</span>求余生成校验多项式，然后链接在一起。</p><p>系统形式的生成矩阵<span class="math inline">\(G=[I_k\quad Q]\)</span>，每行对应的信息多项式为<span class="math inline">\(m_i(D)=D^{k-i}\)</span></p><p>对应的校验多项式是 <span class="math display">\[r_i(D)=D^{n-i}\bmod g(D)\]</span> 因此系统循环码生成矩阵多项式的一般表示为 <span class="math display">\[G(D)=\left[\begin{array}{c}A_1(D) \\A_2(D) \\\vdots \\A_k(D)\end{array}\right]=\left[\begin{array}{c}D^{n-1}+r_1(D) \\D^{n-2}+r_2(D) \\\vdots \\D^{n-k}+r_k(D)\end{array}\right]\]</span> 对于所有线性分组码，非系统形式的生成矩阵经过高斯消元(初等行变换）运算也一定能够可以化为系统形式.</p><p>循环码的编码器可以用带反馈的线性移位寄存器来实现，如下图所示，以<span class="math inline">\(g(D)=D^6+D^5+D^4+D^3+1\)</span>为例：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306101505555.png" alt="线性移位寄存器" /><figcaption aria-hidden="true">线性移位寄存器</figcaption></figure><p>生成多项式哪一项有值，就在寄存器的第几个模块的后面增加一个异或门，这就是内接异或门触发电路的构成方法。</p><p>循环码的译码主要分三步进行：</p><ol type="1"><li><p>由接收到的码多项式𝐵(𝐷)计算校正子（伴随式）多项式𝑆(𝐷)： <span class="math display">\[S=BH^T\]</span> 对于循环码来说： <span class="math display">\[S(D) \equiv B(D) \bmod g(D) \equiv E(D) \bmod g(D)\]</span> 因此，循环码的校正子多项式<span class="math inline">\(S(D)\)</span>就是用接收到的码多项式除以生成多项式<span class="math inline">\(g(D)\)</span>所得到的余式</p></li><li><p>由校正子多项式<span class="math inline">\(S(D)\)</span>确定错误图样<span class="math inline">\(E(D)\)</span></p></li><li><p>将错误图样<span class="math inline">\(E(D)\)</span> 与<span class="math inline">\(B(D)\)</span>相加，纠正错误</p></li></ol><blockquote><p>【例】已知<span class="math inline">\((7,4)\)</span>循环码的生成多项式是<span class="math inline">\(g(D)=D^3+D+1\)</span>,求：</p><ol type="1"><li>系统生成矩阵</li><li>系统监督矩阵</li><li>信息码为<code>1101</code>，请编码</li></ol><p>【解】</p><ol type="1"><li><p>有多项式矩阵： <span class="math display">\[G(x)=\left[\begin{array}{c}x^3 g(x) \\x^2 g(x) \\x g(x) \\g(x)\end{array}\right]=\left[\begin{array}{c}x^6+x^4+x^3 \\x^5+x^3+x^2 \\x^4+x^2+x \\x^3+x+1\end{array}\right]\]</span> 即： <span class="math display">\[G=\left[\begin{array}{l}1011000 \\0101100 \\0010110 \\0001011\end{array}\right]\]</span> 经矩阵初等行变换，即给第一行加第三行和第四行，给第二行加第四行，有： <span class="math display">\[G=\left[\begin{array}{l}1000101 \\0100111 \\0010110 \\0001011\end{array}\right]\]</span></p></li><li><p>由<span class="math inline">\(H=[PI_r]\)</span>，有： <span class="math display">\[\mathbf{H}=[\mathbf{P} \mathbf{I} _r]=\left[\begin{array}{l}1110100 \\0111010 \\1101001\end{array}\right]\]</span></p></li><li><p><span class="math inline">\(A=MG\)</span>=<code>1101001</code></p></li></ol></blockquote><h3 id="分组码的误码性能">分组码的误码性能</h3><p>下面仅就二进制对称信道及加性白色高斯噪声信道的情形，对一些常用的线性分组码进行讨论。</p><h4 id="二进制对称信道">二进制对称信道</h4><p>意思即是把0误为1和把1误为0的概率一样，都是<span class="math inline">\(p_e\)</span>的信道。（忘了的话去看信息论）</p><p>不加纠错的误字率： <span class="math display">\[P_w=\sum_{i=1}^n p(i, n)=\sum_{i=1}^n\left(\begin{array}{l}n \\i\end{array}\right) p_e^i\left(1-p_e\right)^{n-i}\]</span> 加了纠错以后，如果纠错能力是<span class="math inline">\(t\)</span>，误字率的上界： <span class="math display">\[P_{w c}\leq\sum_{i=t+1}^n\left(\begin{array}{l}n \\i\end{array}\right) p_e^i\left(1-p_e\right)^{n-i}\]</span> 注意看<span class="math inline">\(\Sigma\)</span>符号的下面。</p><p>一般来说，对于译码后的误比特率取决于特定的码及译码器，可近似地有 <span class="math display">\[P_b \leq \sum_{i=t+1}^n \frac{i}{n}\left(\begin{array}{l}n \\i\end{array}\right) p_e^i\left(1-p_e\right)^{n-i}\]</span></p><h4 id="加性高斯白噪声信道">加性高斯白噪声信道</h4><p>考虑BPSK，原始误码率为： <span class="math display">\[p_b=Q\left(\sqrt{\frac{2E_c}{n_0}}\right)\]</span> 其中，<span class="math inline">\(E_c\)</span>为单位调制符号能量，<span class="math inline">\(n_0\)</span>为噪声单边功率谱密度。定义单位信息比特的能量为<span class="math inline">\(E_b\)</span>。如果没有差错控制编码，本来应该是<span class="math inline">\(E_c=E_b\)</span>的，所以前一节里面的BPSK误码率里面写的是<span class="math inline">\(E_b\)</span>。但是现在有了差错控制编码，有： <span class="math display">\[E_b=E_c\frac nk\]</span> 所以 <span class="math display">\[p_e=Q\left(\sqrt{\frac{2 E_b}{n_0} \frac{k}{n}}\right)\]</span></p><hr /><p>通信原理的笔记到这里就结束了。关于后面的同步、多址和复用，请收看：</p><p><a href="https://github.com/FuryMartin/EE-Notes/tree/master/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">FuryMartin的笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230515-20230604）</title>
    <link href="/2023/06/05/%E5%91%A8%E8%AE%B0%EF%BC%8820230515-20230604%EF%BC%89/"/>
    <url>/2023/06/05/%E5%91%A8%E8%AE%B0%EF%BC%8820230515-20230604%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>已经不得不通过查询相册来回忆一下这两周自己都干了什么，人老了（其实是人懒了）（逃）</p><p>这两周也没有什么别的，大概三件事，一个，恢复了七大不可思议的更新，第二个就是看了飞梦的两次表演（舞团和社庆），第三个舍友出去吃了顿毕业饭，如果说还有一点事那就是看完了死在火星上的上半部分，这对文化素质的熏陶是很重要的一个。</p><p>七大不可思议是个好东西，之前因为懒和忙所以忘了，现在恢复了更新，是好的。</p><p>飞梦的这两次表演我都没有参与，但是他们搞得都还不错，没出什么大乱子，这让我很欣慰。看来离了我地球还是能转的，这很好。</p><p>毕业饭吃的是基辅罗斯餐厅，我们剩下三个人人均200，其中一个舍友人均600.我最喜欢他家的大列巴、罐焖牛肉、鹅肝和猪肘子，很好吃。乌克兰将士在前方吃紧，我们在后方紧吃。</p><p>其实我已经积攒了很多创作的idea了，就等放假了（笑）</p><p>下学期准备锻炼锻炼身体，然后学学怎么让AI唱歌，因为我的创作的idea里面有两个都是填词。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306050955457.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息论笔记·信道和编码</title>
    <link href="/2023/05/26/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0%C2%B7%E4%BF%A1%E9%81%93%E5%92%8C%E7%BC%96%E7%A0%81/"/>
    <url>/2023/05/26/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0%C2%B7%E4%BF%A1%E9%81%93%E5%92%8C%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="离散信道及其容量">离散信道及其容量</h2><h3 id="信道的分类">信道的分类</h3><p>根据信道的输入输出特性，可以分为：</p><ol type="1"><li>离散信道：输入输出空间都是离散的</li><li>连续信道：输入输出空间都是连续的</li><li>半连续信道：输入输出空间中一个是离散的，而另一个是连续的</li><li>波形信道：输入输出都是时间的实函数</li></ol><p>根据信道的统计特性，可以分为：</p><ol type="1"><li>恒参信道：统计特性不随时间变化</li><li>变参信道：统计特性随时间变化</li></ol><p>根据信道的记忆特性，可以分为：</p><ol type="1"><li>无记忆信道：信道输出仅仅和当前的输入有关</li><li>有记忆信道：信道的输出还和过去的输入有关</li></ol><p>还有几种比较特殊的信道：</p><p>满足以下条件之一（其实三个条件等价）的信道称为无损信道，无损信道的输出完全由输入决定：</p><ol type="1"><li>总存在输出符号集合<span class="math inline">\(b_1,\cdots b_k\)</span>，满足<span class="math inline">\(P(Y\in b_i|x=x_i)=1\)</span></li><li>对于所有的输入分布，只要<span class="math inline">\(p(y_j)\neq 0\)</span>，则总有一个<span class="math inline">\(x_i\)</span>使得<span class="math inline">\(p(x_i|y_j)=0\)</span></li><li>对于所有的输入分布，已知<span class="math inline">\(Y\)</span>时，<span class="math inline">\(X\)</span>的不确定度为零，即<span class="math inline">\(H(X|Y)=0\)</span></li></ol><p>满足以下条件之一（其实两个条件等价）的信道称为无噪信道，无噪信道中不存在随机干扰：</p><ol type="1"><li>对于所有的<span class="math inline">\(x_i\)</span>，都存在一个<span class="math inline">\(y_j\)</span>，使得<span class="math inline">\(p(x_i|y_j)=1\)</span></li><li><span class="math inline">\(H(Y|X)=0\)</span></li></ol><p>既无损又无噪的信道叫做确定信道。</p><h3 id="离散无记忆信道">离散无记忆信道</h3><p>首先来讨论单符号离散信道。假设信道输入随机变量（总体）为<span class="math inline">\(X\)</span>，其取值为<span class="math inline">\(x\)</span>， <span class="math inline">\(x\in A=\{a_1 ,a_2 ,……,a_r\}\)</span>；输出随机变量为<span class="math inline">\(Y\)</span>，取值为<span class="math inline">\(y\)</span>， <span class="math inline">\(y\in B={b_1 ,b_2 , ……,b_s }\)</span>。信道传递概率为 <span class="math display">\[p(y|x)=P(Y=b_j|X=a_i)=p(b_j|a_i)\]</span> 于是，可以用一个<span class="math inline">\(p\)</span>组成的矩阵来描述这个信道，有： <span class="math display">\[\mathbf P=\begin{pmatrix}p_{11} &amp; p_{12} &amp; \cdots &amp;p_{1s}\\p_{21} &amp; p_{22} &amp; \cdots &amp;p_{2s}\\\cdots &amp; \cdots &amp; \cdots &amp;\cdots\\p_{r1} &amp; p_{r2} &amp; \cdots &amp;p_{rs}\end{pmatrix}\]</span> 其中<span class="math inline">\(p_{ij}=p(b_j|a_i)\)</span>。这个矩阵的每个元素都大于等于零，而且行和都是<span class="math inline">\(1\)</span>。</p><p>接下来介绍几个后面常用的名词，以免产生困扰：</p><ul><li><p>先验概率：指的是信源的统计特性，即： <span class="math display">\[p(a_i)=p(X=a_i)\]</span></p></li><li><p>前向概率：即信道传递概率，也就是上面那个矩阵里面的元素，表示已经收到信源为<span class="math inline">\(a_i\)</span>时信道输出<span class="math inline">\(b_j\)</span>的概率，即 <span class="math display">\[p(b_j|a_i)=p(Y=b_j|X=a_i)\]</span></p></li><li><p>输出符号概率：指的是输出的统计特性，即： <span class="math display">\[p(b_j)=p(Y=b_j)\]</span></p></li><li><p>后向概率：指的是目前已经知道输出是<span class="math inline">\(b_j\)</span>，在这个情况下信源是<span class="math inline">\(a_i\)</span>的概率，即： <span class="math display">\[p(a_i|b_j)=p(X=a_i|Y=b_j)\]</span></p></li><li><p>联合概率：指的是输入为<span class="math inline">\(a_i\)</span>而且输出为<span class="math inline">\(b_j\)</span>的概率，即： <span class="math display">\[p(a_ib_j)=p(X=a_i,Y=b_j)\]</span> 有： <span class="math display">\[p(a_ib_j)=p(b_j)p(a_i|b_j)=p(a_i)p(b_j|a_i)\]</span></p></li></ul><p>定义“信道疑义度”(损失熵)为： <span class="math display">\[\begin{aligned}H(X|Y) &amp;= E[H(X|b_j)]\\&amp;= \sum_{j=1}^s p(b_j)\cdot \left(\sum_{i=1}^r-p(a_i|b_j)\log p(a_i|b_j)\right)\\&amp;= -\sum_{j=1}^s\sum_{i=1}^r p(a_ib_j)\log p(a_i|b_j)\end{aligned}\]</span> 其物理意义为信宿收到全部符号Y后，对输入符号X尚存在的平均不确定程度。那么有：<span class="math inline">\(H(X|Y)\leq H(X)\)</span>，意思就是说，信宿接收到输出信号以后，总是要消除一些对信源的不确定度的。而平均互信息量就是来表征这一部分被消除的不确定度的： <span class="math display">\[I(X;Y)=H(X)-H(X|Y)\]</span> 平均互信息量是输入信源概率分布的上凸函数，是信道传递概率<span class="math inline">\(p(y|x)\)</span>的下凸函数。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305262226162.png" alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure><h3 id="无记忆扩展信道">无记忆扩展信道</h3><p>对于单符号无记忆信道来说，输入和输出的都是一个符号。如果一个信道的输入是单符号信道的信源的N次扩展（也就是长度为N的序列），输出是单符号信道信宿的N次扩展，那么这个信道就是单符号信道的N次扩展信道。</p><p>在一般的信道中，传输长度为N的信息，有如下的定理：</p><ol type="1"><li><p>如果输入和输出是<span class="math inline">\(N\)</span>长序列<span class="math inline">\(\mathbf {X,Y}\)</span>，且信道是无记忆的，亦即信道传递概率为： <span class="math display">\[p(\mathbf{y} \mid \mathbf{x})=\prod_{i=1}^N p\left(y_i \mid x_i\right)\]</span> 或者 <span class="math display">\[p\left(\beta_h \mid \alpha_k\right)=\prod_{i=1}^N p\left(b_{h_i} \mid a_{k_i}\right), k=1,2, \cdots, r^N, h=1,2, \cdots, s^N\]</span> 则有： <span class="math display">\[I(\mathbf{X} ; \mathbf{Y}) \leq \sum_{i=1}^N I\left(X_i ; Y_i\right)\]</span></p></li><li><p>如果输入和输出是<span class="math inline">\(N\)</span>长序列<span class="math inline">\(\mathbf {X,Y}\)</span>，且信源是无记忆的，即： <span class="math display">\[p(\boldsymbol{x})=\prod_{i=1}^N p\left(x_i\right)\]</span> 或者 <span class="math display">\[p\left(\alpha_k\right)=p\left(a_{k_1}\right) p\left(a_{k_2}\right) \cdots p\left(a_{k_N}\right), k=1,2, \cdots, r^N\]</span> 则： <span class="math display">\[I(\mathbf{X} ; \mathbf{Y}) \geq \sum_{i=1}^N I\left(X_i ; Y_i\right)\]</span></p></li></ol><h3 id="信道的组合">信道的组合</h3><p>级联信道的模型如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305262247587.png" alt="级联信道" /><figcaption aria-hidden="true">级联信道</figcaption></figure><p>对于级联信道中的互信息，有：</p><ol type="1"><li><p>级联信道中的平均互信息满足： <span class="math display">\[I(XY;Z)\geq I(Y;Z)\]</span> 等号取得的充要条件： <span class="math display">\[p(z|xy)=p(z|y)\]</span> 也就是说，输出变量<span class="math inline">\(z\)</span>只和<span class="math inline">\(y\)</span>有关，而和<span class="math inline">\(x\)</span>无关。进一步，<span class="math inline">\(X,Y,Z\)</span>构成了一个一阶马尔可夫链。</p><p>把上面两式右边的<span class="math inline">\(y\)</span>换成<span class="math inline">\(x\)</span>，定理仍然成立。</p></li><li><p>如果<span class="math inline">\(X,Y,Z\)</span>构成了一个一阶马尔可夫链，有： <span class="math display">\[I(X;Z)\leq I(X;Y)\]</span></p><p><span class="math display">\[I(X;Z)\leq I(Y;Z)\]</span></p><p>也就是说，在任意信息传输系统中，最后获得的信息至多是信源提供的信息，如果在传输过程中丢失了信息，而且以后的系统不触及输入端，那么丢失的信息就不能再恢复。</p></li></ol><h3 id="信道容量">信道容量</h3><p>对一个特定的信道而言，其信道容量是平均互信息量随输入符号集变化时的最大值： <span class="math display">\[C=\max _{p(x)}\{I(X;Y)\}\]</span> 相应的使得平均互信息量最大的信源概率分布称为最佳输入分布。信道容量<span class="math inline">\(C\)</span>仅和信道本身的统计特性有关，而和信源无关，其表征了信道传送信息的最大能力。例如，对于最简单的二元对称信道（输入输出符号集都是<span class="math inline">\(\{0,1\}\)</span>，传输过程中符号翻转的概率为<span class="math inline">\(p\)</span>），信源符号为<span class="math inline">\(1\)</span>的概率是<span class="math inline">\(\omega\)</span>，有： <span class="math display">\[I(X;Y)=H(\omega \overline p+\overline \omega p)-H(p)\]</span> 则： <span class="math display">\[C=1-H(p)\]</span> 事实上，研究信道的核心问题就是研究信道容量以及最佳输入分布，但是这其实比较困难，接下来会对几个特殊的信道进行分析。</p><h4 id="离散无噪信道">离散无噪信道</h4><ol type="1"><li><p>无损信道</p><p>无损信道的一个输入对应多个不相交的输出，输出端接收到<span class="math inline">\(Y\)</span>以后一定能知道发射端<span class="math inline">\(X\)</span>的状态，示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305271122498.png" alt="无损信道示意图" /><figcaption aria-hidden="true">无损信道示意图</figcaption></figure><p>一个典型的无损信道矩阵如下： <span class="math display">\[\mathbf{P}_{Y \mid X}=\left[\begin{array}{cccccc}\frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{6}{10} &amp; \frac{3}{10} &amp; \frac{1}{10} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\]</span> 它的行“不相互重叠”，且行和为一。</p><p>其信道疑义度（损失熵）<span class="math inline">\(H(X|Y)=0\)</span>。因为并不能根据输入<span class="math inline">\(a_i\)</span>断定输出会是哪一个<span class="math inline">\(b_i\)</span>，所以其噪声熵<span class="math inline">\(H(Y|X)&gt;0\)</span>。其信道容量为： <span class="math display">\[C=\max _{p(x)}H(X)=\log r\]</span> 最佳输入分布是等概分布。</p></li><li><p>确定信道</p><p>确定信道是一个输出对应多个互不相交的输入的信道，即发出信源<span class="math inline">\(a_i\)</span>，就一定能知道信道的输出<span class="math inline">\(b_j\)</span>。示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305271131747.png" alt="确定信道示意图" /><figcaption aria-hidden="true">确定信道示意图</figcaption></figure><p>一个典型的确定信道矩阵如下： <span class="math display">\[\mathbf{P}_{Y \mid X}=\left[\begin{array}{lll}1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\]</span> 信道矩阵中每一行只有一个<span class="math inline">\(1\)</span>，其余元素都是<span class="math inline">\(0\)</span>。</p><p>其噪声熵<span class="math inline">\(H(Y|X)=0\)</span>。因为并不能根据输出<span class="math inline">\(b_j\)</span>断定输入是哪一个<span class="math inline">\(a_i\)</span>，所以其损失熵<span class="math inline">\(H(X|Y)&gt;0\)</span>。</p><p>其信道容量为： <span class="math display">\[C=\max _{p(x)} H(Y)=\log s\]</span> 最佳输入分布是能让输出呈现等概分布的输入分布。</p></li><li><p>无损确定信道</p><p>既无损又确定的信道是无损确定信道。其矩阵是单位阵，输入输出之间有一一对应关系。</p></li></ol><h4 id="离散对称信道">离散对称信道</h4><p>若一个离散无记忆信道的信道矩阵中，每一行都是其它行的同一组元素的不同排列，则称此类信道为<strong>离散输入对称信道</strong>，一个典型的离散输入对称信道矩阵为： <span class="math display">\[\mathbf{P}=\left[\begin{array}{cccc}\frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{6} \\\frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{3}\end{array}\right]\]</span> 若一个离散无记忆信道的信道矩阵中，每一列都是其它列的同一组元素的不同排列，则称此类信道为<strong>离散输出对称信道</strong>，一个典型的离散输出对称信道矩阵为： <span class="math display">\[\mathbf{P}=\left[\begin{array}{ll}0.4 &amp; 0.6 \\0.6 &amp; 0.4 \\0.5 &amp; 0.5\end{array}\right]\]</span> 如果同时满足以上两个条件，则称之为<strong>离散对称信道</strong>，例如： <span class="math display">\[\mathbf{P}=\left[\begin{array}{ccc}\frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{6} \\\frac{1}{6} &amp; \frac{1}{2} &amp; \frac{1}{3} \\\frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{2}\end{array}\right]\]</span> 若一个离散无记忆信道，按照信道矩阵的行（即信道的输出集）可以将信道矩阵划分成<span class="math inline">\(n\)</span>个子矩阵，且每个子矩阵中的每一行（列）都是其它行（列）的同一组元素的不同排列，则称此类信道为<strong>离散准对称信道</strong>。例如下面的矩阵： <span class="math display">\[\mathbf{P}_2=\left[\begin{array}{lll}0.7 &amp; 0.1 &amp; 0.2 \\0.2 &amp; 0.1 &amp; 0.7\end{array}\right]\]</span> 可以划分为： <span class="math display">\[\left[\begin{array}{ll}0.7 &amp; 0.2 \\0.2 &amp; 0.7\end{array}\right]\left[\begin{array}{l}0.1 \\0.1\end{array}\right]\]</span> 离散准对称信道的最佳输入分布是等概分布。</p><p>如果一个离散对称信道有<span class="math inline">\(r\)</span>个输入符号和<span class="math inline">\(s\)</span>个输出符号，则输入是等概分布时达到信道容量<span class="math inline">\(C\)</span>，且： <span class="math display">\[C=\log s-H\left(p_1^{\prime}, p_2^{\prime}, \cdots, p_s^{\prime}\right)\]</span> 其中<span class="math inline">\(p&#39;_1,p&#39;_2,\cdots,p&#39;_s\)</span>是信道矩阵中的任何一行。</p><p>达到信道容量<span class="math inline">\(C\)</span>的概率分布是使输出为等概分布的信道输入分布。求离散对称信道的信道容量，实质是求一种输入分布<span class="math inline">\(p(x)\)</span>，它使输出熵<span class="math inline">\(H(Y)\)</span>达最大。<strong>对于对称信道，只有信道输入分布是等概分布时，输出才为等概分布。</strong></p><p>对于<strong>离散无记忆 <span class="math inline">\(N\)</span>次扩展信道</strong>，其信道容量等于单变量信道的信道容量的 <span class="math inline">\(N\)</span>倍,即： <span class="math display">\[C^N=NC\]</span></p><h2 id="无失真信源编码">无失真信源编码</h2><p>将信源产生的全部信息无损地送给信宿，这种信源编码称无失真信源编码。编码可以分为：</p><ul><li>定长码：所有码字长度相等的码</li><li>变长码：码字长度可能不相等的码</li></ul><p>或者</p><ul><li>奇异码：码组中有相同的码字</li><li>非奇异码：码组中没有相同的码字</li></ul><h3 id="分组码">分组码</h3><p>分组码指的是把信源符号集中的每一个符号<span class="math inline">\(s_i\)</span>都映射成一个固定的码字<span class="math inline">\(w_i\)</span>的编码规则。</p><p>设信源符号<span class="math inline">\(s_i\)</span>映射为一个固定的码字<span class="math inline">\(w_i\)</span>，则码<span class="math inline">\(\alpha_j=(s_{j_1},s_{j_2}\cdots s_{j_n})\)</span>映射为<span class="math inline">\(W_j=(w_{j_1},w_{j_2},\cdots,w_{j_n})\)</span>的分组码称为原分组码的<span class="math inline">\(N\)</span>次扩展码。</p><p>分组码能正确译码的必要条件是非奇异，这很直观，但是并不是充分的。</p><p>如果一个分组码对于任意的正整数<span class="math inline">\(N\)</span>，其<span class="math inline">\(N\)</span>次扩展码都是非奇异的，那么这样的分组码叫做<strong>唯一可译码</strong>，这是分组码能正确译码的充要条件。</p><p>虽然都是唯一可译码，但是译码方式仍有不同。考虑以下两种码：</p><table><thead><tr class="header"><th>符号</th><th>码1</th><th>码2</th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>2</td><td>10</td><td>01</td></tr><tr class="odd"><td>3</td><td>100</td><td>001</td></tr><tr class="even"><td>4</td><td>1000</td><td>0001</td></tr></tbody></table><p>对于码1来说，我接收到一个消息，比如<code>10</code>，此时我并不知道符号是<code>2</code>、<code>3</code>还是<code>4</code>。直到下一个符号到达，我接收到的消息变成<code>101...</code>，我才知道前面的符号是<code>2</code>。但是对于码2，当我接收到<code>01</code>时，我立刻就能知道这个符号是<code>2</code>。 把像码2这种接收到一个码字就能立刻译码的唯一可译码称为“<strong>即时码</strong>”。一个唯一可译码是即时码的充要条件是其中任何一个码都不是其它码的前缀。</p><h3 id="定长码">定长码</h3><h4 id="唯一可译定长码">唯一可译定长码</h4><p>对于有<span class="math inline">\(q\)</span>个符号的简单信源的<span class="math inline">\(N\)</span>次扩展信源，其存在基本码符号数为<span class="math inline">\(r\)</span>，扩展信源<span class="math inline">\(S^N\)</span>定长编码码长为<span class="math inline">\(L\)</span>的唯一可译码的条件为： <span class="math display">\[q^N\leq r^L\]</span> 这个定理更常用的形式是：唯一可译定长码的最短码长为： <span class="math display">\[L\geq N\frac{\log q}{\log r}\]</span></p><h4 id="定长信源编码定理">定长信源编码定理</h4><p>引理：设离散无记忆信源的熵为<span class="math inline">\(H(S)\)</span>，用码符号集<span class="math inline">\(X=(x_1,x_2\cdots x_r)\)</span>对<span class="math inline">\(S^N\)</span>进行长度为<span class="math inline">\(L\)</span>的定长编码，<span class="math inline">\(\forall \epsilon &gt;0,\delta&gt;0\)</span>，如果 <span class="math display">\[\frac LN \log r\geq H(s)+\epsilon\]</span> 则<span class="math inline">\(N\)</span>足够大时，译码错误率小于<span class="math inline">\(\delta\)</span>，反之，如果 <span class="math display">\[\frac LN \log r\leq H(s)-2\epsilon\]</span> 则<span class="math inline">\(N\)</span>足够大时，译码错误趋向于<span class="math inline">\(1\)</span>.</p><p>也就是说，当 <span class="math display">\[L\log r&gt;NH(s)\]</span> 即码长为<span class="math inline">\(L\)</span>的符号序列能携带的最大信息量大于<span class="math inline">\(N\)</span>次扩展信源的信息熵时，<span class="math inline">\(N\)</span>足够大时，就可以近似实现无失真传输。</p><p>对于定长编码，定义编码速率: <span class="math display">\[R=\frac{L\log r}{N}\]</span> 编码效率： <span class="math display">\[\eta = \frac {H(s)}{R}\]</span> 由定长信源编码定理知道，最佳编码效率为： <span class="math display">\[\eta = \frac{H(s)}{H(s)+\epsilon}\]</span> 如果允许错误概率<span class="math inline">\(p_e&lt;\delta\)</span>，信源长度<span class="math inline">\(N\)</span>要满足： <span class="math display">\[N\geq \frac{D[I(s_i)]}{\epsilon^2\delta}\]</span> 其中<span class="math inline">\(D[I(s_i)]\)</span>是自信息量的方差。代入，有： <span class="math display">\[N\geq \frac{D[I(s_i)]}{H^2(s)}\frac{\eta^2}{(1-\eta)^2\delta}\]</span></p><blockquote><p>【例】现有离散无记忆信源： <span class="math display">\[\begin{bmatrix}S\\P\end{bmatrix}=\begin{bmatrix}s_1 &amp; s_2\\\frac 34 &amp; \frac 14\end{bmatrix}\]</span> 对其采取等长二元编码，编码效率<span class="math inline">\(\eta = 0.96\)</span>，允许错误概率不大于<span class="math inline">\(10^{-5}\)</span>，求<span class="math inline">\(N\)</span>最少是多少</p><p>【解】信源信息熵为 <span class="math display">\[H(s)=\frac 34\log_2 \frac 43+\frac 14+\log_24=0.811\]</span> 自信息量的方差为： <span class="math display">\[\begin{aligned}D[I(s_i)]&amp;=E[I^2(s_i)]-E^2[I(s_i)]\\&amp;=\sum_{i=1}^2p_i(\log_2 p_i)^2-[H(s)]^2\\&amp;=0.4715\end{aligned}\]</span> 则 <span class="math display">\[N\geq \frac{0.4615}{0.811^2}\frac{0.96^2}{0.04^2\times 10^{-5}}=4.13\times 10^7\]</span></p></blockquote><h3 id="变长码">变长码</h3><p>变长码无需很长的码长就能实现高效率的无失真信源编码。关于信源符号数、码字长度之间应该满足什么条件，才能构成唯一可译码，有：</p><p>设信源符号集为<span class="math inline">\(S=(s_1\cdots s_q)\)</span>，码符号集为<span class="math inline">\(X=(x_1\cdots x_r)\)</span>，对信源进行编码，对应的码字为<span class="math inline">\(W=(W_1\cdots W_q)\)</span>，每个码的码长为<span class="math inline">\(l_1\cdots l_q\)</span>，则唯一可译即时码存在是充要条件是： <span class="math display">\[\sum_{i=1}^q r^{-l_i}\leq 1\]</span> 这叫“<strong>克拉夫特不等式</strong>”。</p><p>如果把上面的定理中的“唯一可译即时码”换成“唯一可译码”，其它都不变，定理仍然成立。</p><h4 id="变长编码定理">变长编码定理</h4><p>如果传输一个码符号需要<span class="math inline">\(t\)</span>秒，那么编码后信道每秒传输的信息量为： <span class="math display">\[R_t=\frac{H(s)}{\overline L t}\]</span> 则平均码长越短，<span class="math inline">\(R_t\)</span>越大，信息传输的速率越快。因此，人们感兴趣的码是平均码长最短的码。</p><p>对于固定的信源和码符号集，如果有一种唯一可译码的平均码长小于所有其它唯一可译码，则称其为紧致码。</p><p>对于离散无记忆信源<span class="math inline">\(S\)</span>及其<span class="math inline">\(N\)</span>次扩展信源<span class="math inline">\(S^N\)</span>，码符号集中有<span class="math inline">\(r\)</span>个符号，对<span class="math inline">\(S^N\)</span>进行编码，则总可以找到一种编码方式构成唯一可译码，而且码字平均长度满足： <span class="math display">\[\frac{H(S)}{\log r}+\frac 1N&gt;\frac{\overline L_N}{N}\geq \frac{H(S)}{\log r}\]</span> 当<span class="math inline">\(N\to \infty\)</span>，有： <span class="math display">\[\lim _{N\to \infty}\frac{\overline L_N}{N}=\frac{H(s)}{\log r}\]</span> 以下记： <span class="math display">\[H_r(S)=\frac{H(S)}{\log r}\]</span> 把这个结论推广到平稳遍历的有记忆信源，一般离散信源，马尔可夫信源，有： <span class="math display">\[\lim _{N\to \infty}\frac{\overline L_N}{N}=\frac{H_{\infty}}{\log r}\]</span> 类似的，定义变成编码的编码速率： <span class="math display">\[R=\frac{\overline L_N}{N}\log r\]</span> 编码效率： <span class="math display">\[\eta =\frac{H(S)}{R}=\frac{H_r(S)}{\overline L}\]</span></p><h4 id="变长码的编码方法">变长码的编码方法</h4><h5 id="香农编码">香农编码</h5><p>香农编码的编码方式如下：</p><ol type="1"><li><p>把信源发出的<span class="math inline">\(N\)</span>个符号按概率递减的顺序从上到下排列</p></li><li><p>按下式计算第<span class="math inline">\(i\)</span>个消息的二进制代码组的码长<span class="math inline">\(l_i\)</span>，并取整： <span class="math display">\[-\log p(s_i)\leq l_i&lt;-\log p(s_i)+1\]</span></p></li><li><p>计算第<span class="math inline">\(i\)</span>个消息的累加概率 <span class="math display">\[P_i =\sum_{k=1}^{i-1}p(s_k)\]</span></p></li><li><p>把累加概率转换成二进制小数，并截取小数点后的前<span class="math inline">\(l_i\)</span>位作为第<span class="math inline">\(i\)</span>个消息的编码。</p></li></ol><blockquote><p>【例】对以下信源进行香农编码</p><table><thead><tr class="header"><th>消息</th><th>s1</th><th>s2</th><th>s3</th><th>s4</th><th>s5</th><th>s6</th><th>s7</th></tr></thead><tbody><tr class="odd"><td>概率</td><td>0.2</td><td>0.19</td><td>0.18</td><td>0.17</td><td>0.15</td><td>0.1</td><td>0.01</td></tr></tbody></table><p>【解】香农编码表如下：</p><table><thead><tr class="header"><th>消息序号</th><th>消息概率</th><th>累加概率</th><th><span class="math inline">\(-\log p(s_i)\)</span></th><th>码组长度</th><th>二进制代码</th></tr></thead><tbody><tr class="odd"><td>s1</td><td>0.2</td><td>0</td><td>2.3</td><td>3</td><td>000</td></tr><tr class="even"><td>s2</td><td>0.19</td><td>0.2</td><td>2.4</td><td>3</td><td>001</td></tr><tr class="odd"><td>s3</td><td>0.18</td><td>0.39</td><td>2.4</td><td>3</td><td>011</td></tr><tr class="even"><td>s4</td><td>0.17</td><td>0.57</td><td>2.5</td><td>3</td><td>100</td></tr><tr class="odd"><td>s5</td><td>0.15</td><td>0.74</td><td>2.7</td><td>3</td><td>101</td></tr><tr class="even"><td>s6</td><td>0.1</td><td>0.89</td><td>3.3</td><td>4</td><td>1110</td></tr><tr class="odd"><td>s7</td><td>0.01</td><td>0.99</td><td>6.6</td><td>7</td><td>1111110</td></tr></tbody></table></blockquote><h5 id="霍夫曼编码">霍夫曼编码</h5><p>霍夫曼编码是一种紧致码，它的编码过程为：</p><ol type="1"><li>把<span class="math inline">\(q\)</span>个符号按概率分布从大到小的顺序排列</li><li>用<code>0</code>,<code>1</code>分别代表概率最小的两个信源，把这两个符号合并成一个新符号，从而得到包含<span class="math inline">\(q-1\)</span>个符号的缩减信源</li><li>把缩减信源的符号概率仍从大到小排序</li><li>重复2~3，直到信源只剩下两个符号为止，把这最后两个符号用<code>0</code>和<code>1</code>表示，然后从最后一级缩减信源开始向前返回，得到编码。</li></ol><blockquote><p>【例】对以下信源进行霍夫曼编码：</p><table><thead><tr class="header"><th>符号</th><th>s1</th><th>s2</th><th>s3</th><th>s4</th><th>s5</th></tr></thead><tbody><tr class="odd"><td>概率</td><td>0.4</td><td>0.2</td><td>0.2</td><td>0.1</td><td>0.1</td></tr></tbody></table><p>【解】</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306122233893.png" alt="image-20230612223226884" /><figcaption aria-hidden="true">image-20230612223226884</figcaption></figure></blockquote><h5 id="费诺码">费诺码</h5><p>费诺码的编码过程如下：</p><ol type="1"><li>把<span class="math inline">\(q\)</span>个符号按概率分布从大到小的顺序排列</li><li>把依次排列的信源符号依概率分为两大组，使两个组的概率和尽可能相等，然后给各组赋予一个二进制码符号<code>0</code>和<code>1</code></li><li>把上面这两大组中每一大组的符号再分成两部分，使得划分后两小组的概率和尽可能相等，然后给各组赋予一个二进制码符号<code>0</code>和<code>1</code></li><li>重复2~3，直到每个组都只剩下一个符号为止</li></ol><blockquote><p>【例】对以下信源进行费诺编码</p><table><thead><tr class="header"><th>符号</th><th>s1</th><th>s2</th><th>s3</th><th>s4</th><th>s5</th><th>s6</th><th>s7</th></tr></thead><tbody><tr class="odd"><td>概率</td><td>0.2</td><td>0.19</td><td>0.18</td><td>0.17</td><td>0.15</td><td>0.1</td><td>0.01</td></tr></tbody></table><p>【解】</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306122246232.png" alt="费诺码" /><figcaption aria-hidden="true">费诺码</figcaption></figure><p>平均码长为 <span class="math display">\[\overline L=2.74\]</span> 信息速率 <span class="math display">\[R=\frac{H(s)}{\overline{L}}=0.953\quad bit/\text{码元}\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理·数字信号基带传输</title>
    <link href="/2023/05/23/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93/"/>
    <url>/2023/05/23/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<p>在之前的调制部分，我们解决了信号的调制和编码的问题。接下来，我们将对数字信号如何在信道中更高效地传输的问题进行讨论。</p><p>传输分为两种，即基带传输和通带传输。基带传输无需进行进一步调制，只需要直接在信道中传输编码后的数字脉冲信号（即<code>01</code>串方波），一般多用于非带限信道，有线传输。</p><p>通带传输需要借调制进行频谱搬移，用于带限信道，一般是无线传输，但是也可以用于有线传输，比如DVB-C。</p><p>数字信号传输的方框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306061558358.png" alt="数字信号传输方框图" /><figcaption aria-hidden="true">数字信号传输方框图</figcaption></figure><h2 id="非带限信道码型设计">非带限信道码型设计</h2><p>码型设计是数字信息的电脉冲表示过程，其主要目的是使数字信息变换为适合于给定信道传输特性的频谱结构。其设计的基本原则有：</p><ul><li><p>尽量避免含有直流分量</p></li><li><p>码型变换过程应对任何信源具有透明性，和信源的统计特性无关</p></li><li><p>便于从基带信号中提取定时信息</p></li><li><p>具有检错能力</p></li><li><p>无误码扩散现象</p></li><li><p>当采用分组形式的传递码型时（如5B6B、4B3T码等），在接收端不但要从基带信号中提取位定时信息，</p><p>而且要恢复出分组同步信息，以便将收到的信号正确地划分成固定长度的码组</p></li><li><p>减少基带信号中的高频分量</p></li><li><p>编译码设备简单</p></li></ul><h3 id="二元码">二元码</h3><p>二元码的意思就是基带信号的幅度取值只有两种电平。常用的二元码有：</p><ul><li><p>单极性非归零码：</p><p>两个电平分别为<code>1</code>和<code>0</code>，传完一个符号后不归零</p></li><li><p>双极性非归零码：</p><p>两个电平分别为<code>1</code>和<code>-1</code>，传完一个符号后不归零</p></li><li><p>单极性归零码：</p><p>两个电平分别为<code>1</code>和<code>0</code>，每个符号前一半时间传输码，后一半时间归零</p></li><li><p>差分码：</p><p>差分码的传输依赖于当前符号和前一个符号的变化关系。</p><ul><li>传号差分码：电平从<code>0</code>开始，如果当前符号是<code>1</code>就翻转电平，如果是<code>0</code>则保持电平</li><li>空号差分码：电平从<code>0</code>开始，如果当前符号是<code>0</code>就翻转电平，如果是<code>1</code>则保持电平</li></ul></li></ul><p>各二元码的时域波形示例如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305241049672.png" alt="image-20230524104926672" /><figcaption aria-hidden="true">image-20230524104926672</figcaption></figure><p>其中非差分码的低频分量丰富，不适用于交流耦合的有线信道；非归零码的连续符号不适合提取定时信息；不具备检错能力；仅适用于近距离传输。</p><p>还有一些更高级的二元码：</p><ul><li><p>数字双相码（曼彻斯特码）</p><p>其特点是<code>1</code>和<code>0</code>的波形反向。生成方法是用单极性非归零码和时钟信号做模二和。</p></li><li><p>信号反转码</p><p><code>1</code>交替用确定相位的方波（<code>11</code>,<code>00</code>）表示，<code>0</code>用<code>01</code>表示</p><p>方便提取定时信息，有检错能力</p></li><li><p>米勒码</p><p><code>1</code>在码元中间跳变；单<code>0</code>不跳变；多个<code>0</code>在从第2个<code>0</code>起始跳变</p></li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305241103542.png" alt="高级二元码" /><figcaption aria-hidden="true">高级二元码</figcaption></figure><h3 id="三元码">三元码</h3><p>在三元码数字基带信号中，信号幅度取值有三个：<code>+1</code>、<code>0</code>、<code>-1</code>。</p><ul><li><p>AMI码</p><p>其实就是符号<code>1</code>交替变换为<code>+1</code>、<code>-1</code>的双极性归零码。</p><p>AMI码具有检错能力，其性能和信源的统计特性关系很密切，如果长时间出现连续<code>0</code>，会对定时提取造成困难。所以，使用AMI码前需要进行随机化操作，以使<code>1</code>、<code>0</code>出现的概率一致。</p></li><li><p>HDBn码</p><p>为了改进AMI码，提出HDBn码的概念。HDBn码是<span class="math inline">\(n\)</span>阶高密度双极性码的缩写，在HDBn码中信息<code>1</code>也交替地变换为<code>+1</code>与<code>-1</code>的归零码，但与AMI码不同的是：HDBn码中的连<code>0</code>数被限制为小于或等于<span class="math inline">\(n\)</span>。</p><p>当信息中出现<span class="math inline">\(n+1\)</span>个连<code>0</code>码时就用特定码组来取代，这种特定码组称为取代节。为了在接收端识别</p><p>出取代节，人为地在取代节中设置“破坏点”，在这些“破坏点”处传号极性交替规律受到破坏。</p><p>一般来说，用的最广泛的是HDB3码。其生成步骤如下：</p><ul><li>加<code>V</code>：检查4连<code>0</code>的情况，如果出现，将4连<code>0</code>编为一组，用<code>V</code>取代<code>0000</code>的最后一个<code>0</code>，变成<code>000V</code></li><li>加<code>B</code>：检查相邻的<code>V</code>中间非零符号的个数，如果是奇数，那么记为<code>000V</code>，如果是偶数，则记为<code>B00V</code></li><li>对信码加符号：将<code>1</code>和<code>B</code>看做整体，保证这个整体按正负交替的规律变化。此时可把<code>B</code>恢复为<code>1</code>或<code>-1</code></li><li>对<code>V</code>加符号：保证<code>V</code>和其前一个信码的符号一致。此时可把<code>V</code>恢复为<code>1</code>或<code>-1</code></li></ul><blockquote><p>【例】将信息<code>0100001100000101</code>进行HDB3编码。</p><p>【解】编码步骤如下：</p><ol type="1"><li>加V：<code>01 000V 11 000V 0101</code></li><li>加B：<code>01 000V 11 B00V 0101</code></li><li>对信码加符号：<code>0 +1 000V -1 +1 -100V 0 +1 0 -1</code></li><li>对V加符号：<code>0 +1 000 +1 -1 +1 -1 00 -1 0 +1 0 -1</code></li></ol></blockquote></li></ul><h2 id="符号映射与波形设计">符号映射与波形设计</h2><p>数字通信中，所需传输的往往是一个比特流，因此就需要一个符号序列去承载这个比特流。我们让这些符号在时间轴上，以<span class="math inline">\(Ts\)</span>为间隔均匀的排布，因此将其称为符号间隔/符号周期。由此，可定义符号速率为：<span class="math inline">\(R_s=1/T_s\)</span>。数字通信的比特速率为：<span class="math inline">\(R_b=R_s\log_2 M\)</span>，其中<span class="math inline">\(M\)</span>是数字通信的符号进制，就常用的二进制而言，符号速率等于比特速率。</p><p>比特需要转换为符号，这个过程称为符号映射。但是符号作为离散时间、离散幅度信号，不能直接传输，需要转换为连续时间、连续幅度的信号，一般是转换成准方波。这个过程叫做波形设计。</p><p>数字通信波形的统一数学表达式为： <span class="math display">\[a(t)=\sum_{k=-\infty}^\infty a_k g(t-kT_s)\]</span> 其中 <span class="math inline">\(g(t)\)</span>​称为成型脉冲，将离散的符号映射为通信波形。每一个符号周期内，以<span class="math inline">\(a_k\)</span>为幅度，独立产生一个成形脉冲；并将所有符号周期形成的脉冲进行叠加，得到最终的波形。如果<span class="math inline">\(g(t)\)</span>是矩形窗函数，那么就会得到一个方波，也就是之前非带限信道传输中的波形。</p><p>但是矩形窗函数是频域无限宽的信号，因此不能在带限信道中使用。带限信道中只能通过频域有限宽，时域无限宽的信号，那么既然时域无限宽，就有可能出现码间串扰。只有经过特别设计的<span class="math inline">\(g(t)\)</span>才没有码间串扰，比如之前采样定理中用到的信号核重建函数 <span class="math display">\[g(t)=\frac{\sin (\omega_0t)}{\omega_0 t}\]</span> 如果信号经传输后整个波形发生了变化，但只要其特定点的抽样值保持不变，那么用再次抽样的方法仍然可以准确无误地恢复原始信码。于是，有<strong>采样点无失真定理（也叫奈奎斯特第一准则）</strong>：</p><p>数字通信波形满足采样点无失真，即：<span class="math inline">\(a(kT_s)=a_k\)</span>，当且仅当： <span class="math display">\[\sum_{n=-\infty}^{\infty} G\left(f+\frac{n}{T_S}\right)=T_S\]</span> 即以<span class="math inline">\(R_s=1/T_s\)</span>为周期对其频谱进行延拓，其和为常数。</p><p>在验证时，一般将其频域响应<span class="math inline">\(G(\omega)\)</span>按照<span class="math inline">\(2\pi/T_s\)</span>为单位进行分段，然后把各分段都沿横轴的方向平移到<span class="math inline">\([-\pi/T_s,\pi/T_s]\)</span>之间，并把它们叠加起来。如果实部是常数，虚部是零，那么就符合条件。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305241608451.png" alt="验证示意图" /><figcaption aria-hidden="true">验证示意图</figcaption></figure><p>更进一步，只需验证其频域函数是否以<span class="math inline">\(R_s/2=1/2T_s\)</span>为中心互补对称即可。</p><p>频谱效率指的是单位频谱上所承载的通信速率，即 <span class="math display">\[\eta=\frac {R_b}{W}=\frac{R_s}{W}\log _2 M\]</span> 由奈奎斯特第一准则知，频谱效率有上界，即 <span class="math display">\[\eta \leq 2\log_2 M\]</span></p><h3 id="升余弦成形滤波器">升余弦成形滤波器</h3><p>理想低通滤波器是最好的，可是无法实现。在实际工程中，我们一般使用升余弦成型滤波器。其频域表达式为： <span class="math display">\[G(f)=\left\{\begin{array}{cl}T_s &amp; 0 \leq|f| \leq \frac{1-\alpha}{2 T_s} \\\frac{T_s}{2}\left\{1+\cos \left[\frac{\pi T_s}{\alpha}\left(|f|-\frac{1-\alpha}{2 T_s}\right)\right]\right\} &amp; \frac{1-\alpha}{2 T_s} \leq|f| \leq \frac{1+\alpha}{2 T_s} \\0 &amp; |f|&gt;\frac{1+\alpha}{2 T_s}\end{array}\right.\]</span> 可以看出：它是一个偶对称的函数，其下降沿起始于<span class="math inline">\(W=(1-\alpha)/(2T_s)\)</span>，终止于<span class="math inline">\(W=(1+\alpha)/(2T_s)\)</span>，带宽为 <span class="math display">\[W=\frac{1+\alpha}{2T_s}\]</span> 上面的式子太抽象了，看个图就清楚了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306061538840.png" alt="升余弦滤波器" /><figcaption aria-hidden="true">升余弦滤波器</figcaption></figure><p>直观来说，滚降系数<span class="math inline">\(\alpha\)</span>给出了下降沿的相对陡峭程度，其越小，下降沿越陡峭，频谱效率越高，物理上越难实现。一般不使用<span class="math inline">\(\alpha\leq 0.2\)</span>的升余弦滤波器。</p><h2 id="最佳接收与匹配滤波">最佳接收与匹配滤波</h2><p>在之前，我们假设了接收到的信号就是发射的信号，即信道的响应是<span class="math inline">\(H(f)=1\)</span>​。但是实际上，接收机前端会引入高斯白噪声，必须进行滤波处理，否则有大量带外噪声引入，影响通信质量。</p><p>在分析噪声时，因为主要的噪声来源是接收机本身的热噪声，所以采取加性高斯白噪声模型。其双边功率谱为： <span class="math display">\[P_N(f)=\frac{n_0}{2}\]</span> 此时，考虑传输一个符号<span class="math inline">\(a\)</span>，成形脉冲是<span class="math inline">\(g(t)\)</span>，那么我们能够观测和处理的信号是 <span class="math display">\[Y(t)=ag(t)+N(t)\]</span> 最直接想到的方法就是在<span class="math inline">\(g(t)\)</span>的最高点进行直接采样，但是这并不是最优的，因为这是因为信号能量遍布整个<span class="math inline">\(g(t)\)</span>的非零区域。最佳的接受方案应该是尽可能的接收<span class="math inline">\(g(t)\)</span>的能量，同时尽可能不接受<span class="math inline">\(N(t)\)</span>的能量。我们可以用一个权函数<span class="math inline">\(h(t)\)</span>对信号<span class="math inline">\(Y(t)\)</span>进行加权，然后进行积分，即： <span class="math display">\[\hat{a}=\int_{-\infty}^{\infty} Y(t) h(t) d t=a \int_{-\infty}^{\infty} g(t) h(t) d t+\int_{-\infty}^{\infty} h(t) N(t) d t\]</span> 于是我们的问题就变成了怎么设计这个<span class="math inline">\(h(t)\)</span>。有定理：</p><p>当且仅当<span class="math inline">\(h(t)=g(t)\)</span>时，信噪比 <span class="math display">\[S N R=\frac{\left[a \int_{-\infty}^{\infty} h(t) g(t) d t\right]^2}{E\left[\int_{-\infty}^{\infty} h(t) N(t) d t\right]^2}\]</span> 取得最大值，为： <span class="math display">\[S N R=\frac{a^2}{n_0 / 2} \int_{-\infty}^{\infty} g^2(t) d t\]</span></p><blockquote><p>【例】证明上面这个定理。</p><p>【解】从函数空间的角度来看，<span class="math inline">\(N(t)\)</span>是白噪声，在各个方向上均匀分布，因此和任何方向的函数做内积，结果输出的平均能量都是相同的。有： <span class="math display">\[\begin{aligned}&amp;E\left[\left|\int_{-\infty}^{\infty} N(t) h(t) d t\right|^2\right]\\&amp;=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} E[N(t) N(\tau)] h(t) h(\tau) d t d \tau\\&amp;=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} \frac{1}{2} n_0 \delta(t-\tau) h(t) h(\tau) d t d \tau\\&amp;=\frac{1}{2} n_0 \int_{-\infty}^{\infty} h^2(t) d t\end{aligned}\]</span> 于是，问题变成了求 <span class="math display">\[\frac{\left|\int_{-\infty}^{\infty} h(t) g(t) d t\right|^2}{\int_{-\infty}^{\infty} h^2(t) d t}\]</span> 的最大值的问题。也即，给定函数<span class="math inline">\(h(t)\)</span>的2-范数为1，最大化<span class="math inline">\(|\int h(t)g(t)dt|^2\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="本文中，所有省略了积分上下界的积分，都表示积分是从负无穷到正无穷。">[1]</span></a></sup>，那么显然当<span class="math inline">\(h(t)\)</span>和<span class="math inline">\(g(t)\)</span>在函数空间中同方向时，这个内积最大。严格来说，根据柯西-施瓦茨不等式 <span class="math display">\[\left(\int_a^b f(x) g(x) d x\right)^2 \leq \int_a^b f^2(x) d x \int_a^b g^2(x) d x\]</span> 有： <span class="math display">\[\frac{\left|\int_{-\infty}^{\infty} h(t) g(t) d t\right|^2}{\int_{-\infty}^{\infty} h^2(t) d t} \leq \frac{\int_{-\infty}^{\infty} h^2(t) d t \int_{-\infty}^{\infty} g^2(t) d t}{\int_{-\infty}^{\infty} h^2(t) d t}=\int_{-\infty}^{\infty} g^2(t) d t\]</span> 证毕。</p></blockquote><p>于是，最佳接收的系统框图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306062207714.png" alt="最佳接收系统框图" /><figcaption aria-hidden="true">最佳接收系统框图</figcaption></figure><p>我们可将此过程等效为<span class="math inline">\(Y(t)\)</span>通过一个线性系统，并对输出在<span class="math inline">\(t_0\)</span>时刻进行采样。因为上面这个线性系统蕴含了“匹配”的思想，因此被称为“匹配滤波器”。其冲激响应为： <span class="math display">\[h_m(t)=g(t_0-t)\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306062229034.png" alt="匹配滤波器和发送滤波器响应镜像对称" /></p><h3 id="匹配滤波器的信噪比分析">匹配滤波器的信噪比分析</h3><p>如果从一般的视角来分析匹配滤波器的信噪比增益，我们会发现是无穷大，因为<span class="math inline">\(Y(t)=s(t)+N(t)\)</span>​中噪声的功率是无穷大（因为功率谱密度是常数），因此它的信噪比是零，但是这显然没有什么意义。为了方便分析，我们将匹配滤波器等效为它本身与和它本身带宽相等理想低通滤波器的串联系统：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306062243827.png" alt="匹配滤波器信噪比增益计算模型" /><figcaption aria-hidden="true">匹配滤波器信噪比增益计算模型</figcaption></figure><p>记匹配滤波器、成形滤波器和理想低通滤波器的带宽都是<span class="math inline">\(W\)</span>，然后可以用理想低通滤波器作为基准，来分析匹配滤波器对信噪比的增益。</p><p><span class="math inline">\(Y(t)\)</span>通过理想滤波器以后，噪声的功率就被限制在了<span class="math inline">\(Wn_0\)</span>，注意到<span class="math inline">\(a^2\int g^2(t)dt\)</span>是一个符号的能量，而符号的速率是<span class="math inline">\(R_s\)</span>，所以信噪比为： <span class="math display">\[S N R_{i n}=\frac{R_s}{W} \frac{a^2}{n_0} \int_{-\infty}^{\infty} g^2(t) d t\]</span> 由前面的分析，匹配滤波后的信噪比是： <span class="math display">\[S N R=\frac{a^2}{n_0 / 2} \int_{-\infty}^{\infty} g^2(t) d t\]</span> 于是得到匹配滤波的增益是： <span class="math display">\[\lambda=\frac{2W}{R_s}\]</span> 可以看到：频谱效率越低，匹配滤波的信噪比增益越高。如果采取升余弦波形，那么它的增益和滚降系数有关，即： <span class="math display">\[\frac{2W}{R_s}=1+\alpha\]</span></p><h3 id="根号奈奎斯特准则">根号奈奎斯特准则</h3><p>在上述讨论中，我们仅仅传输了一个符号，而数字通信需要源源不断的传输间隔为<span class="math inline">\(T_s\)</span>的符号序列。此时，系统设计需要同时满足以下两个条件:</p><ol type="1"><li>采样点无失真</li><li>采样点信噪比最大</li></ol><p>回顾一下数字信号传输的框图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306061606404.png" alt="数字信号传输方框图" /><figcaption aria-hidden="true">数字信号传输方框图</figcaption></figure><p>实际上，我们需要让<span class="math inline">\(\hat G(f)=G(f)H(f)\)</span>满足奈奎斯特第一准则。</p><p>因为匹配滤波器的频响是<span class="math inline">\(H(f)=G^*(f)\)</span>，所以有： <span class="math display">\[\hat G(f) = |G(f)|^2\]</span> 那么只需要这个等效的频响函数满足奈奎斯特第一准则，就能同时满足采样点无失真和采样点信噪比最大了。有： <span class="math display">\[\sum_{n=-\infty}^{\infty}\left|G\left(f+\frac{n}{T_s}\right)\right|^2=T_s\]</span> 这叫<strong>根号奈奎斯特准则</strong>。</p><p>特别的，对于升余弦滤波器来说，如果<span class="math inline">\(G^2(f)\)</span>是升余弦滤波器，那么<span class="math inline">\(G(f)\)</span>叫做“根升余弦滤波器”。</p><h3 id="等效基带模型">等效基带模型</h3><p>为了对前两节（即应用根号奈奎斯特准则）的基带调制解调系统进行一个总体抽象，我们来看一下经过匹配滤波后<span class="math inline">\(kT_s\)</span>时刻的采样值： <span class="math display">\[Y(kT_s)=a_k \int_{-\infty}^{\infty} g^2(t) d t+\int_{-\infty}^{\infty} g(t) N\left(t+k T_s\right) d t\]</span> 等号两边同时除以<span class="math inline">\(E_g=\int g^2(t)dt\)</span>，并令： <span class="math display">\[n_k=\frac{\int_{-\infty}^{\infty} g(t) N\left(t+k T_s\right) d t}{\int_{-\infty}^{\infty} g^2(t) d t}\]</span> 则有： <span class="math display">\[y_k=\frac {Y(kT_S)}{E_g}=a_k+n_k\]</span> 其中<span class="math inline">\(n_k\)</span>符合高斯分布，均值为<span class="math inline">\(0\)</span>，方差为 <span class="math display">\[\frac{n_0}{2E_g}\]</span> 我们希望符号<span class="math inline">\(a_k\)</span>越大越好，但是发射机的平均功率有限制。其功率为： <span class="math display">\[P_s=E_sR_s\]</span> 即每个符号的能量乘以单位时间内传输符号的数目。有： <span class="math display">\[E_S=E[a_k^2]E_g\]</span> 令<span class="math inline">\(E_g=1\)</span>，则<span class="math inline">\(a_k\)</span>的取值满足： <span class="math display">\[E[a_k^2]=P_sT_s\]</span> 在等效基带模型中，<span class="math inline">\(y_k=a_k+n_k\)</span>，<span class="math inline">\(E[a_k^2]=E_s\)</span>，噪声能量<span class="math inline">\(E[n_k^2]=n_0/2\)</span>，平均信噪比<span class="math inline">\(2E_s/n_0\)</span>。</p><h2 id="最佳判决与差错概率">最佳判决与差错概率</h2><p>回忆一下等效基带模型： <span class="math display">\[y_k=a_k+n_k\]</span> 观察到的是有噪声/干扰信号<span class="math inline">\(𝑦_𝑘\)</span>，需要根据观测值推断发送的符号<span class="math inline">\(𝑎_𝑘\)</span>，该过程称为判决。其中噪声满足<span class="math inline">\(n\sim N(\mu=0,\sigma^2=n_0/2)\)</span>，符号满足<span class="math inline">\(E[a^2]=E_s\)</span>。</p><p>注意到<span class="math inline">\(y\)</span>的分布是整个实数域，而符号集合是一个离散的有限集合，所以符号判决的规范表达式为： <span class="math display">\[\varphi: \mathbb R \mapsto \mathbb{A}\]</span> 显然这是一个多对一的映射，其实和量化挺像的。</p><h3 id="各种判决准则">各种判决准则</h3><p>判决的根本目标是最小化错判概率，即： <span class="math display">\[p_e=\sum_{m=1}^M p_m\mathbf {Pr}\{\varphi(y)\neq a_m|a=a_m\}\]</span></p><ol type="1"><li><p>极大似然准则</p><p>极大似然准则的基本思想是在众多的<span class="math inline">\(a\)</span>中寻找一个<span class="math inline">\(a_m\)</span>，使得当发射的符号是<span class="math inline">\(a_m\)</span>时接收端观察到<span class="math inline">\(y\)</span>的可能性最大。即： <span class="math display">\[\varphi(y)=\underset{a_m \in \mathcal{A}}{\arg \max } \operatorname{Pr}\left\{y \mid a=a_m\right\}\]</span></p></li><li><p>最小距离准则</p><p>基于通信信号的收发关系模型<span class="math inline">\(𝑦 = 𝑎 + 𝑛\)</span>，我们可以对ML准则做进一步的简化，得到最小距离准则 <span class="math display">\[\varphi(y)=\arg \min_{a_m\in A}|y-a_m|\]</span> 也就是选择和<span class="math inline">\(y\)</span>距离最近的<span class="math inline">\(a_m\)</span>。</p><p>把相邻两个许用符号的中点称作“判决门限”，把各个判决门限中间的区域称为“判决域”。</p></li></ol><h3 id="m元ask星座">M元ASK星座</h3><p>符号集合<span class="math inline">\(𝔸\)</span>直观地被称为星座图，对其的设计在数字通信中又被称为星座设计。在一维空间上，最佳的<span class="math inline">\(M\)</span>元星座是零均值、等概分布的，这样可以使得平均差错概率最小化。</p><p>双极性ASK星座可以表示为： <span class="math display">\[\mathbb A =\{-(M-1)A,\cdots,-3A,-A,A,3A,\cdots,(M-1)A\}\]</span> 其中符号半间隔为 <span class="math display">\[A=\sqrt{\frac{3E_s}{M^2-1}}\]</span></p><h3 id="数字基带传输的差错分析方法">数字基带传输的差错分析方法</h3><p>首先来点基础知识：标准正态截尾分布函数 <span class="math display">\[Q(u)=\int ^{\infty}_u \frac 1{\sqrt{2\pi}}\exp\left(\frac{-x^2}{2}\right) \mathbf dx\]</span> 这是把标准整体分布函数从一个点<span class="math inline">\(u\)</span>开始往后作积分，也就是一个符合标准正态分布的变量大于<span class="math inline">\(u\)</span>的概率。</p><p>以前面的“双极性ASK星座”为例，进行分析。</p><p>第一步，对于在两边的星座点<span class="math inline">\(-(M-1)A\)</span>和<span class="math inline">\((M-1)A\)</span>来说，以<span class="math inline">\(-(M-1)A\)</span>为例，当噪声<span class="math inline">\(n&gt;A\)</span>时，<span class="math inline">\(y&gt;-(M-2)A\)</span>，此时就会产生误判。于是条件差错概率为： <span class="math display">\[\int^\infty_A\frac{1}{\sqrt{\pi n_0}}\exp \left(-\frac {x^2}{n_0}\right) \mathbf dx\]</span> 针对任何概率形式，我们都需要将其标准正态变量(也就是<span class="math inline">\(A/\sqrt{n_0/2}\)</span>)的统计函数，在上式中，令<span class="math inline">\(z=x/\sqrt{n_0/2}\)</span>，则有： <span class="math display">\[p_1=\int^{\infty}_{\frac {A}{\sqrt{n_0/2}}} \frac 1{\sqrt {2\pi}}\exp\left(-\frac{z^2}{2}\right)\mathbf dz=Q\left(\frac{A}{\sqrt {n_0/2}}\right)\]</span> 对于在中间的星座点，如果噪声<span class="math inline">\(n\)</span>取值过大（<span class="math inline">\(n&gt;A\)</span>）或者过小（<span class="math inline">\(n&lt;-A\)</span>），都会出错，所以出错的概率为： <span class="math display">\[p_2=2Q\left(\frac{A}{\sqrt {n_0/2}}\right)\]</span> 第二步，综合一下，就得到平均误符号率： <span class="math display">\[p_s=\frac 1M (2p_1+(M-2)p_2)=\frac {2(M-1)}{M}Q\left(\frac A{\sqrt{n_0/2}}\right)\]</span> 第三步，计算<span class="math inline">\(A\)</span>和<span class="math inline">\(E_s\)</span>之间的关系，有： <span class="math display">\[E_s=\frac 2M\sum_{i=0}^{2i+1\leq M-1} [(2i+1)A]^2=\frac{M^2-1}{3}A^2\]</span> 于是 <span class="math display">\[A=\sqrt{\frac{3E_s}{M^2-1}}\]</span> 代入，有： <span class="math display">\[p_s=\frac {2(M-1)}{M}Q\left(\sqrt{\frac{6E_s}{(M^2-1)n_0}}\right)\]</span> 然后计算误比特率BER，一般来说，比特和符号之间的映射采用格雷码，信噪比较高时有： <span class="math display">\[p_b=\frac {p_s}{\log _2M}\]</span></p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>本文中，所有省略了积分上下界的积分，都表示积分是从负无穷到正无穷。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理（轨迹分析）</title>
    <link href="/2023/05/21/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2023/05/21/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>轨迹分析主要包含两部分内容，即根轨迹分析和频域分析（即奈奎斯特图和波特图）。</p><h2 id="根轨迹分析法">根轨迹分析法</h2><p>闭环系统的根轨迹指的是闭环系统特征方程的根随着系统开环增益<span class="math inline">\(K\)</span>从零变化到正无穷时变化的轨迹。得到根轨迹图后，就有一一对应的一组系统闭环极点分布，再考虑到系统的闭环零点分布和输入函数等，就可以完成系统的性能分析。</p><p>我们知道，稳定的充要条件就是闭环系统的极点，也就是闭环系统特征方程的根都在<span class="math inline">\(s\)</span>坐标系的左半平面（也就是实部小于零），可以根据不同<span class="math inline">\(K\)</span>取值对应的根轨迹位置，来观察<span class="math inline">\(K\)</span>对系统稳定性的影响。</p><h3 id="根轨迹方程和幅值相角条件">根轨迹方程和幅值相角条件</h3><p>闭环系统的特征方程为： <span class="math display">\[G(s)H(s)=-1\]</span> 那么我们可以写出根轨迹方程： <span class="math display">\[K \cdot \frac{\prod_{i=1}^m\left(s-z_i\right)}{\prod_{j=1}^n\left(s-p_j\right)}=-1\]</span> 凡是满足根轨迹方程的<span class="math inline">\(s\)</span>点都在系统的根轨迹上，其中<span class="math inline">\(K\)</span>是根轨迹增益。对于每个<span class="math inline">\(K\)</span>，都有一组对应的闭环极点，当<span class="math inline">\(K:0\to \infty\)</span>时，不同的<span class="math inline">\(s\)</span>点就形成<span class="math inline">\(n\)</span>条系统根轨迹（其中<span class="math inline">\(n\)</span>是分母的次数）</p><p>把根轨迹方程写出幅值和相角形式，即： <span class="math display">\[K \cdot \frac{\prod_{i=1}^m\left(s-z_i\right)}{\prod_{j=1}^n\left(s-p_j\right)}=1\angle (2k+1)\pi\]</span> 进一步，可以写出幅值条件： <span class="math display">\[\frac{\prod_{j=1}^n\left|s-p_j\right|}{\prod_{i=1}^m\left|s-z_i\right|}=K\]</span> 相角条件： <span class="math display">\[\sum_{i=1}^m \angle (s-z_i)-\sum_{j=1}^n \angle (s-p_j)=(2 k+1) \pi \quad(k=0, \pm 1, \pm 2, \cdots)\]</span></p><h3 id="绘制根轨迹图的基本规则">绘制根轨迹图的基本规则</h3><h4 id="根轨迹的对称性">根轨迹的对称性</h4><p>因为特征方程的根不是实数就是共轭复数，所以根轨迹是关于实轴对称的，所以画的时候只用画上半平面（或者下半平面）的就行了。</p><h4 id="根轨迹的起始点和终止点">根轨迹的起始点和终止点</h4><p>根轨迹起始于开环极点，终止于开环零点。</p><h4 id="根轨迹的条数">根轨迹的条数</h4><p>对于<span class="math inline">\(n\)</span>阶系统，根轨迹有<span class="math inline">\(n\)</span>个起始点，因此有<span class="math inline">\(n\)</span>条。在这<span class="math inline">\(n\)</span>条中，有<span class="math inline">\(m\)</span>（零点数）条终止于有限零点，其余的终止于无穷远点（无限零点）。</p><h4 id="根轨迹在实轴上的分布规律">根轨迹在实轴上的分布规律</h4><p>对于实轴上的一段，如果其右边的开环零极点数目之和是奇数，那么这段实轴是根轨迹的一部分。</p><h4 id="根轨迹的渐近线">根轨迹的渐近线</h4><p>有<span class="math inline">\((n-m)\)</span>条根轨迹终止于无穷远点，描述它们的方法就是用渐近线。确定渐近线的方法很简单，即首先确定其斜率，然后确定其在实轴（横轴）上的截距。</p><p>其斜率（与正实轴的夹角）满足： <span class="math display">\[\varphi_{\mathrm{A}}=\frac{ \pm(2 k+1) \pi}{n-m} \quad(k=0,1,2, \cdots)\]</span> 截距（和实轴的交点）满足： <span class="math display">\[\sigma_{\mathrm{A}}=\frac{\sum_{j=1}^n p_j-\sum_{i=1}^m z_i}{(n-m)}\]</span></p><h4 id="实轴上根轨迹的分离点和汇合点">实轴上根轨迹的分离点和汇合点</h4><p>根轨迹在实轴上的某个点分叉或者相会，这个点就称为分离点或者汇合点，而且这个点一定是重极点。算分离点和汇合点的方法有两种。</p><p>其一是解方程： <span class="math display">\[\sum_{i=1}^m \frac{1}{\sigma_{\mathrm{B}}-z_i}=\sum_{j=1}^n \frac{1}{\sigma_{\mathrm{B}}-p_j}\]</span> 得到的<span class="math inline">\(\sigma_b\)</span>们即为分离点或汇合点。</p><p>其二是解联立方程： <span class="math display">\[\begin{cases}&amp; 1+G(s) H(s)=0 \\&amp; \frac{\mathrm{d}}{\mathrm{d} s}[G(s) H(s)]=0\end{cases}\]</span> 得到的<span class="math inline">\(s\)</span>即为分离点或汇合点。当然解这个方程不是硬解，因为里面有个常数<span class="math inline">\(K\)</span>。一般是先解下面的那个，然后检验解是不是在根轨迹上就行了。</p><h4 id="根轨迹的起始角和终止角">根轨迹的起始角和终止角</h4><p>起始角就是开环极点处根轨迹的切线和正实轴的夹角；终止角就是开环零点处根轨迹和正实轴的夹角。</p><p><span class="math inline">\(p_1\)</span>极点处起始角为： <span class="math display">\[\theta_{p1}=\pm (2k+1)\pi+\sum_{i=1}^m\angle (p_1-z_i)-\sum_{j=2}^n \angle(p_1-p_j)\]</span> <span class="math inline">\(z_1\)</span>零点处终止角为： <span class="math display">\[\theta_{z1}=\pm (2k+1)\pi+\sum_{i=1}^n\angle (z_1-p_i)-\sum_{j=2}^m \angle(z_1-z_j)\]</span></p><h4 id="根轨迹的分离角和会合角">根轨迹的分离角和会合角</h4><p>根轨迹在<span class="math inline">\(s\)</span>平面上相遇后分开，分离角指的是根轨迹离开重极点处的切线和正实轴的夹角；会合角指的是根轨迹进入重极点处的切线和正实轴的夹角。有： <span class="math display">\[\theta = \frac{360^\circ}{q}\]</span></p><h4 id="根轨迹和虚轴的交点">根轨迹和虚轴的交点</h4><p>根轨迹最重要的部分就是在靠近虚轴和原点的那一部分，因为判定系统稳定的依据就是根是否都在<span class="math inline">\(s\)</span>坐标系的左半平面。</p><p>利用系统闭环特征方程，令<span class="math inline">\(s=j\omega\)</span>代入后满足特征方程实部虚部均为零，则<span class="math inline">\(\omega\)</span>就是根轨迹和虚轴的交点 <span class="math display">\[1+G(s)H(s)=0\]</span></p><blockquote><p>【例】已知单位反馈系统开环传递函数是 <span class="math display">\[\frac{k}{s (0.05 s+1) (0.05 s^2+0.2 s+1)}\]</span> 画出根轨迹图。</p><p>【解】第一步：将其化成零极点形式 <span class="math display">\[G(s)=\frac{K}{s(s+20)(s+2+4j)(s+2-4j)}\]</span> 其中<span class="math inline">\(K=400k\)</span>。系统没有开环零点，<span class="math inline">\(m=0\)</span>；有四个开环极点，<span class="math inline">\(n=4\)</span>，四个极点分别为<span class="math inline">\(p_0=0,p_2=20,p_3=-2+4j,p_4=-2-4j\)</span>。</p><p>第二步：根轨迹总共有四条，起始点分别为<span class="math inline">\(p_{1,2,3,4}\)</span>，终止点都是无穷远点。</p><p>第三步：根轨迹渐近线的实轴截距为： <span class="math display">\[\sigma_{\mathrm{A}}=\frac{\sum_{j=1}^n p_j-\sum_{i=1}^m z_i}{(n-m)}=-6\]</span> 斜率为 <span class="math display">\[\varphi_{\mathrm{A}}=\frac{ \pm(2 k+1) \pi}{4}\]</span> 取<span class="math inline">\(k=0,1\)</span>，得夹角为<span class="math inline">\(\pm 45^\circ,\pm135^\circ\)</span></p><p>第四步：求复数极点处的起始角 <span class="math display">\[\begin{aligned}\theta_{p_3}&amp;=\pm (2k+1)\pi-\sum_{j=1,j\neq 3}^4 \angle(p_3-p_j)\\&amp;=\pm(2k+1)\times 180^\circ -116.6^\circ -12.5^\circ - 90^\circ\\&amp;=-39.1^\circ\end{aligned}\]</span> （取<span class="math inline">\(k=0\)</span>）。则<span class="math inline">\(\theta_{p_4}=39.1^\circ\)</span></p><p>第五步：求实轴上分离点坐标和分离角 <span class="math display">\[\frac 1{\sigma_b}+\frac 1{\sigma_b+20}+\frac 1{\sigma_b+2+4j}+\frac 1{\sigma_b+2-4j}=0\]</span> 解得<span class="math inline">\(\sigma_b=-15.1\)</span>，分离角为<span class="math inline">\(\pm 90^\circ\)</span></p><p>第六步：求根轨迹和虚轴的交点。闭环特征方程为： <span class="math display">\[s(s+20)(s^2+4s+20)+k=0\]</span> 令<span class="math inline">\(s=j\omega\)</span>，代入： <span class="math display">\[j\omega(j\omega+20)(-\omega^2+4j\omega+20)+k=0\]</span> 令实部虚部都是零，有： <span class="math display">\[\begin{cases}\omega^4-100\omega^2+k=0\\-24\omega^2+400\omega=0\end{cases}\]</span> 得<span class="math inline">\(\omega=\pm 4.1,k=1391\)</span>。</p><p>于是，可以画出根轨迹图了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306072231198.png" alt="根轨迹图" /><figcaption aria-hidden="true">根轨迹图</figcaption></figure><p>上面这张图是用<code>Mathematica</code>画的，代码为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">RootLocusPlot</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">s</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">0.05</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">0.05</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.2</span><span class="hljs-operator">*</span><span class="hljs-variable">s</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">k</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">80</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <br> <span class="hljs-built_in">PlotStyle</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-built_in">AbsoluteThickness</span><span class="hljs-punctuation">[</span><span class="hljs-number">5.`</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="频域分析法">频域分析法</h2><p>系统的频率响应函数就是把<span class="math inline">\(G(s)\)</span>里面的<span class="math inline">\(s\)</span>换成<span class="math inline">\(j\omega\)</span>，即<span class="math inline">\(G(j\omega)\)</span>。</p><p>在进行频域分析法时，有两件事是无论如何都要注意的：</p><ol type="1"><li><p>对开环系统函数进行分析</p></li><li><p>要把系统函数各个因子的系数化为1，即： <span class="math display">\[G(s)=\frac{K_0(\tau_1s+1)\cdots(\tau_2s^2+2\xi_2\tau_2s+1)\cdots}{s^v(T_1s+1)\cdots(T_2s^2+2\xi_2T_2s+1)\cdots}\]</span></p></li></ol><h3 id="奈奎斯特图">奈奎斯特图</h3><p>奈奎斯特图就是在复平面上<span class="math inline">\(G(j\omega)\)</span>的值随<span class="math inline">\(\omega\)</span>从<span class="math inline">\(0\)</span>变化到<span class="math inline">\(+\infty\)</span>时的参数图像。在介绍奈奎斯特图的画法时，我将介绍两种方法。首先介绍一种公式法，然后来说明公式法的本质。</p><h4 id="公式法">公式法</h4><p>按照下面几个步骤，可以画出奈奎斯特图。</p><ol type="1"><li><p>确定起点</p><p>起点按照以下公式确定： <span class="math display">\[G(0+)=\begin{cases}0_+\angle(-v\frac \pi2+\angle K_0) &amp; v&lt;0\\[2ex]|K_0|\angle K_0 &amp; v=0\\[2ex]\infty\angle(-v\frac \pi2+\angle K_0) &amp; v&gt;0\end{cases}\]</span> 其中<span class="math inline">\(v\)</span>是传递函数分母里面单个<span class="math inline">\(s\)</span>的指数，<span class="math inline">\(K_0\)</span>是分子上提出来的系数。</p><p>然后，看（分母中<span class="math inline">\(s\)</span>一次项的系数之和-分子中<span class="math inline">\(s\)</span>一次项的系数之和），如果这个值大于零，那么就在前进方向的坐标轴的左侧，否则在右侧。</p><p>以 <span class="math display">\[G(s)=\frac 1{s(s+1)(2s+1)}\]</span> 为例，有<span class="math inline">\(v=1&gt;0\)</span>，所以<span class="math inline">\(G(0+)=\infty\angle (-\frac \pi2+0)=\infty\angle -90^\circ\)</span></p><p>分母中<span class="math inline">\(s\)</span>的系数之和为<span class="math inline">\(1+1+2=3\)</span>，分子中<span class="math inline">\(s\)</span>的系数之和为零，所以在前进方向坐标轴的左侧，即正向纵轴的左侧，即从第四象限起笔</p></li><li><p>确定终点</p><p>终点按以下公式确定： <span class="math display">\[G(j\infty)=\begin{cases}|K^*|\angle\left[-(n&#39;+m&#39;)\frac \pi2+\angle K_0\right] &amp; n=m\\[2ex]0_+\angle\left[-(n&#39;+m&#39;)\frac \pi2+\angle K_0\right] &amp;n&gt;m\end{cases}\]</span> 其中<span class="math inline">\(m\)</span>是分子的总次数，<span class="math inline">\(n\)</span>是分母的总次数，<span class="math inline">\(m&#39;=m_a-m_b\)</span>，<span class="math inline">\(n&#39;=n_a-n_b\)</span></p><p><span class="math inline">\(*_a\)</span>代表分子/分母中最小相位环节（就是<span class="math inline">\(s\)</span>前面系数是正的）的总阶数，<span class="math inline">\(*_b\)</span>代表分子/分母中非最小相位环节的总阶数。</p><p>继续以上面的系统为例，分子中次数为零，最小相位环节阶数为零；分母中次数为3，最小相位环节总阶数也是3，所以 <span class="math display">\[G(j\infty)=0_+\angle\left[-(3-0)\frac \pi2+0\right]=0_+\angle -270^\circ\]</span> 于是，知道了起点和终点，我们就可以初步画出<span class="math inline">\(0_+\to\infty\)</span>的图像了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306142222129.png" alt="初步图像" /><figcaption aria-hidden="true">初步图像</figcaption></figure><p>绘图代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">ParametricPlot</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Re</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <br>  <span class="hljs-built_in">Im</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">I</span><span class="hljs-operator">*</span><span class="hljs-variable">w</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">w</span><span class="hljs-operator">,</span> <span class="hljs-number">0.01</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure></li><li><p>补充虚圆</p><p>为什么说上面的是初步呢？因为还有<span class="math inline">\(0\to0_+\)</span>这部分的没有画，而且这部分还很重要。</p><p>如果<span class="math inline">\(v=0\)</span>，那么不用画。</p><p>如果<span class="math inline">\(G(s)\)</span>在原点上有重根，即<span class="math inline">\(v&gt;0\)</span>，那么以<span class="math inline">\(\angle K_0\)</span>为开始，半径无穷大，顺时针转<span class="math inline">\(+v\frac \pi2\)</span>，接到上面那个图像的起点处。</p><p>*如果<span class="math inline">\(G(s)\)</span>在虚轴上有<span class="math inline">\(n\)</span>重共轭极点<span class="math inline">\(\pm j\omega_n\)</span>，则： <span class="math display">\[G(s)=\frac 1{(s^2+\omega_n^2)^u}G_2(s)\]</span> 其中<span class="math inline">\(G_2(s)\)</span>是没有<span class="math inline">\(n\)</span>重共轭极点的。那么从<span class="math inline">\(G_2(j\omega_n)\)</span>开始，以半径为无穷大，顺时针转<span class="math inline">\(+u\pi\)</span>，接到起点处。</p><p>还是对于上面这个例子，属于第二种情况，于是可以画出：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202306142232168.png" alt="img" style="zoom:25%;" /></p></li></ol><h4 id="定义法">定义法</h4><ol type="1"><li><p>确定起点</p><p>说起起点，就是计算 <span class="math display">\[\lim_{\omega\to 0+}G(j\omega)\]</span> 不就行了吗？先来看模长部分，那当然是<span class="math inline">\(v&gt;0\)</span>就是无穷大，因为分母是零；<span class="math inline">\(v&lt;0\)</span>是零，因为分子是零，这是显然的。然后看相位，众所周知复数相乘就是相位相加，复数相除就是相位相减，所以相位就是分子的相位减去分母的相位之和了。考虑一个<span class="math inline">\((\tau j\omega+1)\)</span>，当<span class="math inline">\(\omega\to 0_+\)</span>时，这玩意就趋向于<span class="math inline">\(1\)</span>，对应的相位就是<span class="math inline">\(0\)</span>，所以不用管，只看<span class="math inline">\(j\omega\)</span>单独的那一项，一个它的相位是<span class="math inline">\(90^\circ\)</span>，总共有<span class="math inline">\(v\)</span>个它，这就是公式法里面的 <span class="math display">\[-v\frac \pi2+\angle K_0\]</span> 的来历。</p></li><li><p>确定终点</p><p>终点就是 <span class="math display">\[\lim_{\omega\to \infty}G(j\omega)\]</span> 幅值分析略，看相位。最小相位系统就是<span class="math inline">\((j\omega+1)\)</span>，非最小相位系统就是<span class="math inline">\((-j\omega+1)\)</span>，当<span class="math inline">\(\omega\to \infty\)</span>的时候他俩分别就是<span class="math inline">\(j,-j\)</span>，对应的相位就是<span class="math inline">\(90^\circ,-90^\circ\)</span>。这就是公式法里面的 <span class="math display">\[-(n&#39;+m&#39;)\frac \pi2+\angle K_0\]</span></p></li><li><p>画出虚圆</p><p>这里只说第二种情况。如果<span class="math inline">\(\omega=0\)</span>了，那么值显然是<span class="math inline">\(sgn[K_0]\infty\)</span>，实数，所以要从<span class="math inline">\(\angle K_0\)</span>开始。但是从<span class="math inline">\(0+\)</span>开始那它就不是实数，就有一个“确定起点”的那个角度，这时候虚圆就是把这俩连起来就行。</p></li></ol><p>画图完成以后，还要计算一个点，那就是图像和横轴的交点，名叫穿越点，对应的频率叫穿越频率。</p><h4 id="奈奎斯特稳定判据">奈奎斯特稳定判据</h4><p>利用奈奎斯特图判断闭环系统的稳定性，需要计算 <span class="math display">\[Z=P-2N\]</span> 如果<span class="math inline">\(Z=0\)</span>，那么稳定。</p><p>其中，<span class="math inline">\(P\)</span>是开环中实部大于零的极点的个数，也可以对分母用劳斯表，看第一列的符号改变次数。</p><p><span class="math inline">\(N\)</span>是曲线穿越<span class="math inline">\((-\infty,-1)\)</span>这段横轴的总次数，但是有正有负：</p><ul><li>虚圆穿越，总是负的</li><li>实线穿越，以<span class="math inline">\((-1,0)\)</span>作为视点，看它是顺时针（负）还是逆时针（正）</li><li>如果起始点、终止点在轴上，算<span class="math inline">\(0.5\)</span>次</li></ul><h3 id="波特图">波特图</h3><p>波特图由两张半对数坐标图组成，其中一张表征幅频特征，一张表征相频特征。其横坐标是频率，为对数坐标；幅频纵坐标是dB，相频纵坐标是线性。绘制波特图首先要记住两个原则</p><ol type="1"><li>如果两个传递函数互为倒数，那么波特图关于横轴镜像对称</li><li>如果两个传递函数互为共轭（即<span class="math inline">\(s\)</span>换成<span class="math inline">\(-s\)</span>），那么幅频曲线相同，相频关于横轴镜像对称</li></ol><p>然后记住两个典型环节：</p><ol type="1"><li><p>惯性环节 <span class="math display">\[\frac 1{\frac{s}{\omega_n}+1}\]</span> 对应的幅频斜率为<span class="math inline">\(-20\)</span>dB/十倍频，对应的相频变化量为<span class="math inline">\(-90^\circ\)</span></p></li><li><p>震荡环节 <span class="math display">\[\frac 1{\left(\frac s {\omega_n}\right)^2+2\xi\frac s{\omega_n}+1}\]</span> 对应的幅频斜率为<span class="math inline">\(-40\)</span>dB/十倍频，对应的相频变化量为<span class="math inline">\(-180^\circ\)</span></p></li></ol><p>然后可以开始画了。画的步骤如下。在下面的例子中，传递函数为： <span class="math display">\[G(s)=\frac{100(1+\sqrt{10}s)}{(-100s^2+20s+1)(-0.001s^2+\frac{\sqrt{10}}{3000}s+1)}\]</span></p><ol type="1"><li><p>把系统函数按转折频率从低到高排列，并把因子写成上面的那种形式，然后在横轴上标出转折频率 <span class="math display">\[G(s)=100\cdot \frac{1}{\left(\frac{s}{0.1}\right)^2+2\frac{s}{0.1}+1}\cdot \left(\frac{s}{\frac{1}{\sqrt{10}}}+1\right)\cdot \frac{1}{\frac{s}{10\sqrt {10}}^2+\frac 1{30}\frac{s}{10\sqrt {10}}+1}\]</span> 所以转折频率为<span class="math inline">\(0.1,1/\sqrt {10},10\sqrt{10}\)</span></p></li><li><p>低频段（即比最低的转折频率还低的一段）：幅频斜率为<span class="math inline">\(-20v\)</span>dB/十倍频，相位起点为<span class="math inline">\(-v\cdot 90^\circ+\angle K_0\)</span>，然后根据幅频曲线一定经过<span class="math inline">\((|K_0|^{1/v},0)\)</span>或者<span class="math inline">\((1,20\lg|K_0|)\)</span>来确定幅频曲线的位置</p><p>在本例中，<span class="math inline">\(v=0,\angle K_0=0\)</span>，<span class="math inline">\(-20v=0\)</span>，<span class="math inline">\(20\lg K_0=40\)</span></p></li><li><p>幅频图中，每段以转折频率为界限，调整斜率，在原有斜率的基础上增加目前环节对应的斜率。</p></li><li><p>相频图中，每个转折频率代表相频图在<span class="math inline">\(0.1\omega_c,10\omega_c\)</span>上变化了<span class="math inline">\(\Delta \varphi\)</span>，不同的转折频率之间相互叠加</p></li><li><p>（可选）在二阶环节对应的转折频率处补充一个高度为<span class="math inline">\(20\lg |1/2\xi|\)</span>的尖峰</p></li><li><p>计算幅频曲线和<span class="math inline">\(\omega\)</span>轴的交点</p></li></ol><h4 id="对数判据">对数判据</h4><p>要用波特图判断闭环系统的稳定性，同样要计算 <span class="math display">\[P-2N\]</span> 其中<span class="math inline">\(P\)</span>是开环中实部大于零的极点的个数，<span class="math inline">\(N\)</span>是在<span class="math inline">\(L(\omega)&gt;0\)</span>即幅频图为正值的部分中，相频曲线穿过<span class="math inline">\((2k+1)\pi\)</span>的次数之和，向上穿越算正数，向下穿越算负数</p><h4 id="稳定裕度">稳定裕度</h4><p>稳定裕度是衡量系统相对稳定性质的量，分为相位裕度和增益裕度。</p><p>相位裕度的定义是在幅频波特图和横轴的交点<span class="math inline">\(\omega_c\)</span>处，使系统达到临界稳定状态的附加相移，有： <span class="math display">\[\gamma=180^\circ+\angle G(j\omega_c)H(\omega_c)\]</span> 在奈奎斯特图中，相位裕度<span class="math inline">\(\gamma\)</span>指的是曲线和单位圆的交点和原点的连线与负实轴之间的夹角。</p><p>增益裕度<span class="math inline">\(K_g\)</span>的定义是在相频波特图和<span class="math inline">\(-180^\circ\)</span>的交点<span class="math inline">\(\omega_g\)</span>处，使得系统达到临界稳定状态所需增大的增益倍数，一般用dB表示，有： <span class="math display">\[K_g=-20\lg|G(j\omega_g)H(j\omega_g)|\]</span> 在奈奎斯特图中，增益裕度是曲线和负实轴的交点离原点的距离的倒数。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理笔记（时域分析）</title>
    <link href="/2023/05/20/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2023/05/20/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="控制系统基础知识">控制系统基础知识</h2><p>在本节，将对自动控制原理中的一些基础概念给出定义，以方便后续的讨论。</p><h3 id="控制系统的性能要求">控制系统的性能要求</h3><p>自动控制系统的目标是使得被控量按照指定规律变化。系统受到外加信号作用之后，被控量随着时间变化并趋于一定规律的全过程被称为系统的动态特性。</p><p>系统的<strong>稳定性</strong>指的是系统进入稳态或者恢复工作状态的能力，即瞬态响应是否会随着时间的延续而趋向于0。系统的<strong>平稳性</strong>指的是当系统稳定时，要求<span class="math inline">\(c(t)\)</span>即输出信号的振荡小，在时域分析中通常用超调量<span class="math inline">\(M_p\)</span>表示。系统的“<strong>快速</strong>”指的是动态过程（即瞬态响应）持续的时间长短。系统的<strong>准确度</strong>指的是过渡到新的平衡状态后最终保持的精度。</p><h3 id="控制系统的数学模型">控制系统的数学模型</h3><p>控制系统通常用微分（差分）方程、方框图等形式表示。一个一般的闭环系统的方框图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112045896.png" alt="闭环系统方框图" /><figcaption aria-hidden="true">闭环系统方框图</figcaption></figure><p>其中<span class="math inline">\(G(s)\)</span>称为前向传递函数，<span class="math inline">\(G(s)H(s)\)</span>称为开环传递函数，当<span class="math inline">\(H(s)=1\)</span>时，开环传递函数和前向传递函数相等。而 <span class="math display">\[T(s)=\frac {C(s)}{R(s)}=\frac{G(s)}{1+G(s)H(s)}\]</span> 称为闭环传递函数，它也是整个闭环系统的传递函数。</p><p>对于一般的控制系统，其控制元件的数学模型都是由几种简单的因子或者典型单元结构组成的，常称为“典型环节”。常见的典型环节有：</p><ol type="1"><li><p>放大环节</p><p>微分方程为 <span class="math display">\[y(t)=Kx(t)\]</span> 传递函数为 <span class="math display">\[G(s)=K\]</span></p></li><li><p>惯性环节</p><p>微分方程为 <span class="math display">\[T\frac{dy(t)}{dt}+y(t)=x(t)\]</span> 传递函数为 <span class="math display">\[G(s)=\frac{1}{Ts+1}\]</span> 其中<span class="math inline">\(T\)</span>叫做时间常数，典型的惯性环节是RC网络。</p></li><li><p>一阶微分环节</p><p>微分方程为 <span class="math display">\[y(t)=\tau \frac {dx(t)}{dt}+x(t)\]</span> 传递函数为 <span class="math display">\[G(s)=\tau s +1\]</span></p></li><li><p>积分环节</p><p>微分方程为 <span class="math display">\[\frac{dy(t)}{dt}=x(t)\]</span> 传递函数为 <span class="math display">\[G(s)=\frac 1s\]</span></p></li><li><p>理想微分环节</p><p>微分方程为 <span class="math display">\[y(t)=\frac{dx(t)}{dt}\]</span> 传递函数为 <span class="math display">\[G(s)=s\]</span></p></li></ol><p>此外，还有震荡环节、二阶微分环节等。</p><h2 id="时域分析法">时域分析法</h2><p>在时域分析法中，往往选择典型的初始状态（零状态，即<span class="math inline">\(t=0-\)</span>时，<span class="math inline">\(c(t)\)</span>的任意阶导数为零），典型的输入信号（如阶跃、斜坡、加速度、冲击、正弦信号），求出典型的时间响应，然后考察系统的性能。</p><h3 id="一阶系统时域分析">一阶系统时域分析</h3><p>一个典型的闭环一阶系统的框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112112739.png" alt="一阶系统" /><figcaption aria-hidden="true">一阶系统</figcaption></figure><p>其闭环传递函数为 <span class="math display">\[T(s)=\frac{1}{\frac 1Ks+1}=\frac{1}{Ts+1}\]</span> 在<span class="math inline">\(-K=-1/T\)</span>处有一个极点。</p><p>其单位阶跃响应为： <span class="math display">\[c(t)=\left(1-e^{-\frac 1T t}\right)u(t)\]</span> 其时域性能只由一个参数决定，即<span class="math inline">\(-1/T\)</span>，其中<span class="math inline">\(T\)</span>也叫时间常数，它表示系统响应达到稳态值的<span class="math inline">\(63.2\%\)</span>所需的时间。时间常数越小，系统的速度越快。其调整时间一般取<span class="math inline">\(t_s=3T(5\%\Delta)\)</span>或<span class="math inline">\(t_s=4T(2\%\Delta)\)</span>，稳态误差为零。</p><p>其单位斜坡响应为 <span class="math display">\[c(t)=(t-T)+Te^{-t/T}\]</span> 所以具有稳态误差，为<span class="math inline">\(T\)</span>。</p><h3 id="二阶系统时域分析">二阶系统时域分析</h3><p>一个典型的二阶系统如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112126058.png" alt="二阶系统" /><figcaption aria-hidden="true">二阶系统</figcaption></figure><p>其闭环传递函数为 <span class="math display">\[T(s)=\frac{K}{Ts^2+s+K}\]</span> “标准形式”为： <span class="math display">\[T(s)=\frac{\omega_n^2}{s^2+2 \xi \omega_n s+\omega_n^2}=\frac{\omega_n^2}{\left(s-s_1\right)\left(s-s_2\right)}\]</span> 之所以要写成看起来这么复杂的样子，是因为其中的参数<span class="math inline">\(\xi,\omega_n\)</span>等有其物理意义。其中<span class="math inline">\(\omega_n=\sqrt{K/T}\)</span>叫做“无阻尼振荡频率”，<span class="math inline">\(\xi =1/(2\sqrt{KT})\)</span>叫做“阻尼比”。阻尼比决定了系统阶跃响应的模式。</p><ol type="1"><li><p>欠阻尼系统（<span class="math inline">\(\xi \in (0,1)\)</span>）</p><p>两个极点<span class="math inline">\(s_1,s_2\)</span>互为共轭复根。阻尼自然频率<span class="math inline">\(\omega_d=\omega_n\sqrt{1-\xi^2}\)</span>。欠阻尼系统的阶跃响应时域波形大概是这个样子：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305112143198.png" alt="欠阻尼阶跃响应" /><figcaption aria-hidden="true">欠阻尼阶跃响应</figcaption></figure></li></ol><p>可以看到里面有很多参数。下面介绍几个比较重要的</p><ul><li><p>上升时间<span class="math inline">\(t_r\)</span></p><p>指的是从稳态值的<span class="math inline">\(10\%\)</span>上升到<span class="math inline">\(90\%\)</span>所需的时间。有： <span class="math display">\[t_r=\frac{\pi-\beta}{\omega_d}\]</span></p></li><li><p>峰值时间<span class="math inline">\(t_p\)</span></p><p>指的是系统达到最大值所需的时间。有： <span class="math display">\[t_p=\frac \pi {\omega_d}\]</span></p></li><li><p>最大超调量<span class="math inline">\(M_p\)</span></p><p>指的是响应峰值和稳态值之间的归一化差值。有： <span class="math display">\[M_p=\frac{c(t_p)-c(\infty)}{c(\infty)}=e^{-\frac{\pi \xi}{\sqrt{1-\xi^2}}}\]</span></p></li><li><p>调节时间<span class="math inline">\(t_s\)</span></p><p>调节时间指的是满足： <span class="math display">\[\forall t&gt;t_s,|c(t)-c(\infty)|\leq \Delta c(\infty)\]</span> 的最小<span class="math inline">\(t_s\)</span>。有： <span class="math display">\[t_s= \begin{cases}\frac{4}{\xi \omega_n} &amp; 2 \% \Delta \\ \frac{3}{\xi \omega_n} &amp; 5 \% \Delta\end{cases}\]</span></p></li></ul><ol start="2" type="1"><li><p>过阻尼系统（<span class="math inline">\(\xi &gt;1\)</span>）和临界阻尼系统（<span class="math inline">\(\xi=1\)</span>）</p><p>这两种情况下，<span class="math inline">\(c(t)\)</span>是单调上升过程，系统近似为一阶系统，单位阶跃响应近似表示为： <span class="math display">\[c(t)=1-\exp [-(\xi -\sqrt{\xi ^2-1})\omega_n t]\]</span></p></li></ol><h3 id="稳定性分析">稳定性分析</h3><p><span class="math inline">\(H(s)\)</span>的极点如果全部位于左半平面，则系统稳定。当虚轴存在一阶零点时，称为边界稳定或者震荡稳定；当右半平面有极点，或者虚轴上有高阶极点时，称系统不稳定。</p><ol type="1"><li><p>首先基于<span class="math inline">\(H(s)=N/D\)</span>的阶次进行分析。其中<span class="math inline">\(N\)</span>是<span class="math inline">\(m\)</span>阶多项式，<span class="math inline">\(D\)</span>是<span class="math inline">\(n\)</span>阶多项式。</p><p>如果<span class="math inline">\(m&gt;n\)</span>，系统一定存在一个无穷远点处的极点。基于这个事实，有以下系统稳定的必要条件：</p><ol type="1"><li><span class="math inline">\(m\leq n\)</span>是系统稳定的必要条件</li><li><span class="math inline">\(m&gt;n+1\)</span>时，系统一定不稳定</li></ol></li><li><p>基于分母多项式（也叫特征多项式）的根的分布判别</p><ol type="1"><li><p>必要条件</p><ol type="1"><li><span class="math inline">\(D(s)\)</span>的所有系数都同号</li><li><span class="math inline">\(D(s)\)</span>不缺项，或者缺全部的奇次或偶次项</li></ol><p>上面两个条件是必要条件，只要任一条件不被满足，系统就不是稳定的。但是即使全部满足，系统也不一定稳定。例如： <span class="math display">\[D(s)=2s^3+s^2+3s+9\]</span></p></li><li><p>劳斯判据</p><p>劳斯判据就是列劳斯表，然后看第一列是不是全同号。劳斯表是这样列的：</p><p>前两行，第一行从前往后是<span class="math inline">\(a_n,a_{n-2},a_{n-4},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>；第二行，是<span class="math inline">\(a_{n-1},a_{n-3},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>。设劳斯表第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素是<span class="math inline">\(m_{ij}\)</span>，在第三行之后，有： <span class="math display">\[m_{ij}=-\frac{1} {m_{i-1,1} }\begin{vmatrix}m_{i-2,1} &amp; m_{i-2,j+1}\\m_{i-1,1} &amp; m_{i-1,j+1}\\\end{vmatrix}\]</span> 单看这些下标可能还比较抽象。实际上就是说，第三行以后的劳斯表的元素都是一个二阶行列式的相反数除以它上一行的第一个数。这个二阶行列式的左侧一列是它上一行和上上一行的第一个数，右侧一列从上一行和上上一行的第二个数开始，随着当前要算的这个元素在自己的行中向右移动而向右移动。</p><p>在计算过程中，可能会出现两种特殊情况。</p><p>其一是某一行的第一个数是零，但其余各项不全为零。这时候只需要把它用一个很小的正数<span class="math inline">\(\epsilon\)</span>代替然后继续算就行。</p><p>其二是某一行的所有数都是零，这代表着系统可能存在互为相反数的实根，或者共轭虚根，或者关于原点对称的共轭复根。这时可以把全零行的上一行的系数构造一个辅助多项式（最高次是行号，然后每个系数降2次），对其求导，并把求导结果带入全零行，然后继续算。需要注意：辅助多项式的根也是原方程的根。</p></li></ol></li></ol><h3 id="稳态误差分析">稳态误差分析</h3><p>如果输入信号<span class="math inline">\(r(t)\)</span>和输出信号<span class="math inline">\(c(t)\)</span>是同量纲、同数量级的，那么系统误差定义为： <span class="math display">\[e(t)=r(t)-c(t)\]</span> 但是实际上这并不可能，因为很多系统都是用电压输入，而输出的被控量很可能是温度，速度等物理量。这就需要用一个传感器把被控量转换为和输入量同量纲同数量级的量，并放在反馈支路。此时系统误差定义为： <span class="math display">\[e(t)=r(t)-b(t)\]</span> 为计算稳态误差，考虑终值定理（使用条件：<span class="math inline">\(E(s)\)</span>极点都在<span class="math inline">\(s\)</span>左半平面），有： <span class="math display">\[\lim _{t\to \infty}e(t)=e_s=\lim_{s\to 0}sE(s)=\lim _{s \rightarrow 0} s \cdot \frac{R(s)}{1+G(s) H(s)}\]</span> 注意到，系统稳态误差和输入信号以及开环传递函数<span class="math inline">\(G(s)H(s)\)</span>有关。稳态误差仅对稳定系统才有意义。</p><p>系统开环传递函数一般为： <span class="math display">\[G(s) H(s)=\frac{K\left(\tau_1 s+1\right) \cdots\left(\tau_2^2 s^2+2 \xi \tau_2 s+1\right) \cdots}{s^N\left(T_1 s+1\right) \cdots\left(T_2^2 s^2+2 \xi T_2 s+1\right) \cdots}\]</span> 注意：这里的系数<span class="math inline">\(K\)</span>的提出是为了把后面的每一项的常数项都设置为<span class="math inline">\(1\)</span>，称为系统的开环放大倍数。分母里的<span class="math inline">\(s^N\)</span>的指数<span class="math inline">\(N\)</span>表示系统开环串联的积分环节的个数，决定了系统的型别，即“<span class="math inline">\(N\)</span>型系统”</p><p>接下来就输入信号和系统型别来讨论稳态误差：</p><ol type="1"><li><p>输入<span class="math inline">\(R(s)=1/s\)</span></p><p>此时有： <span class="math display">\[e_{ss}=\lim _{\mathrm{s} \rightarrow 0} \frac{1}{1+G(s) H(s)}=\frac{1}{1+\lim _{\mathrm{s} \rightarrow 0} G(s) H(s)}=\frac{1}{1+K_p}\]</span> 其中<span class="math inline">\(K_p=\lim _{s\to 0}G(s)H(s)\)</span>称为阶跃误差系数，也叫静态位置误差系数。</p><ul><li>0型系统：<span class="math inline">\(K_p=K,e_{ss}=1/(1+K)\)</span></li><li><span class="math inline">\(0\)</span>型以上系统：<span class="math inline">\(K_p=\infty,e_{ss}=0\)</span></li></ul></li><li><p>输入<span class="math inline">\(R(s)=1/s^2\)</span></p><p>此时有： <span class="math display">\[e_{s r}=\lim _{s \rightarrow 0} \frac{1}{s+s G(s) H(s)}=\frac{1}{\lim _{s \rightarrow 0} s G(s) H(s)}=\frac{1}{K_v}\]</span> <span class="math inline">\(K_v\)</span>叫做斜坡误差系数，也叫静态速度误差系数。</p></li></ol><table><thead><tr class="header"><th>系统型别</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(K_v\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td><span class="math inline">\(e_{sr}\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(1/K\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td></tr></tbody></table><ol start="3" type="1"><li><p>输入<span class="math inline">\(R(s)=1/s^3\)</span></p><p>此时有： <span class="math display">\[e_{s p}=\lim _{s \rightarrow 0} \frac{1}{s^2+s^2 G(s) H(s)}=\frac{1}{\lim _{s \rightarrow 0} s^2 G(s) H(s)}=\frac{1}{K_a}\]</span> <span class="math inline">\(K_a\)</span>叫做抛物线误差系数，也叫静态加速度误差系数。</p></li></ol><table><thead><tr class="header"><th>系统型别</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(K_a\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(K\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td><span class="math inline">\(e_{sp}\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(1/K\)</span></td><td><span class="math inline">\(0\)</span></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息论笔记</title>
    <link href="/2023/05/18/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/18/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="信息的统计度量">信息的统计度量</h2><h3 id="信息量">信息量</h3><h4 id="自信息量">自信息量</h4><p>从信源中获取信息的过程就是其不确定性缩减的过程，在统计分析中，使用概率作为衡量不确定性的一种度量。因此，信息量和概率是紧密相关的。任意事件的自信息量的定义为该事件发生的概率的对数的负值，即：</p><p>在总体<span class="math inline">\(X\)</span>中，事件<span class="math inline">\(x_i\)</span>发生的信息量为： <span class="math display">\[I(x_i)=-\log p(x_i)\]</span> 可见：小概率事件包含的不确定性大，所以它带来的信息量也大。</p><p>信息量所用的单位随着对数的底变化而变化，常用的有：</p><table><thead><tr class="header"><th>底数</th><th>单位</th></tr></thead><tbody><tr class="odd"><td>2</td><td>比特(bit)</td></tr><tr class="even"><td>e</td><td>奈特(nat)</td></tr><tr class="odd"><td>10</td><td>哈特(hat)</td></tr></tbody></table><p>需要说明的是，信息量本身是纯数，没有量纲。这里的“单位”只是为了表示不同底的对数值。</p><p>二维联合总体<span class="math inline">\(XY\)</span>上的元素的信息量为： <span class="math display">\[I(x_iy_i)=-\log p(x_iy_i)\]</span> 在二维联合总体中，事件<span class="math inline">\(x_i\)</span>在事件<span class="math inline">\(y_i\)</span>给定的条件下的条件自信息量为： <span class="math display">\[I(x_i\mid y_j)=-\log p(x_i\mid y_j)=-\log \frac {p(x_iy_j)}{p(y_j)}\]</span></p><h4 id="互信息量">互信息量</h4><p>对于一个信息传输系统来说，如果信道中没有干扰，那么信源发出信号<span class="math inline">\(x_i\)</span>以后，信宿一定可以准确地收到消息，此时获得的信息量就是<span class="math inline">\(x_i\)</span>的不确定度<span class="math inline">\(I(x_i)\)</span>，即信源发出的<span class="math inline">\(x_i\)</span>所含有的全部信息。但是实际上信道不可能没有干扰，这时候<span class="math inline">\(x_i\)</span>通过信道会产生污染，信宿收到的消息<span class="math inline">\(y_i\)</span>将不同于<span class="math inline">\(x_i\)</span>，只能通过条件概率<span class="math inline">\(p(x_i\mid y_i)\)</span>推测信源发出<span class="math inline">\(x_i\)</span>的概率。</p><p>对于两个离散随机总体<span class="math inline">\(XY\)</span>，事件<span class="math inline">\(y_j\)</span>的出现给出关于事件<span class="math inline">\(x_i\)</span>的信息量定义为互信息量，为： <span class="math display">\[I(x_i;y_j)=\log\frac{P(x_i\mid y_j)}{p(x_i)}=I(x_i)-I(x_i\mid y_j)\]</span> 意思是，互信息量是一种不确定性的度量，等于先验的不确定性减去尚存在的不确定性。</p><p>互信息量有以下性质：</p><ol type="1"><li><p>互易性： <span class="math display">\[I(x_i;y_j)=I(y_j;x_i)\]</span></p></li><li><p>可以为0：当<span class="math inline">\(x_i,y_j\)</span>相互独立时，互信息量为零</p></li><li><p>可正可负：正值意味着事件<span class="math inline">\(y_j\)</span>的出现有助于肯定事件<span class="math inline">\(x_i\)</span>的出现，反之则是不利。</p></li><li><p>任何两个事件之间的互信息量不大于其中任意一个事件的自信息量</p></li></ol><p>在联合总体<span class="math inline">\(XYZ\)</span>中，给定<span class="math inline">\(z_k\)</span>的条件下，<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_j\)</span>的互信息量叫做条件互信息量，即： <span class="math display">\[I(x_i;y_j\mid z_k)=\log \frac{p(x_i\mid y_jz_k)}{p(x_i\mid z_k)}\]</span> 在上述联合总体上，还有<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_jz_k\)</span>之间的互信息量，有： <span class="math display">\[I(x_i;y_jz_k)=I(x_i;y_j)+I(x_i;z_k\mid y_j)\]</span> 意思是：<span class="math inline">\(y_jz_k\)</span>同时出现提供的有关<span class="math inline">\(x_i\)</span>的信息量等于<span class="math inline">\(y_j\)</span>提供的信息量和给定<span class="math inline">\(y_j\)</span>的条件下，<span class="math inline">\(z_k\)</span>提供的信息量之和。</p><h4 id="离散集总体的平均自信息量">离散集（总体）的平均自信息量</h4><p>之前讨论的自信息量都是对于一个事件<span class="math inline">\(x_i\)</span>来说的。为了讨论整个<span class="math inline">\(X\)</span>总体，需要定义平均自信息量： <span class="math display">\[H(X)=E[I(x_i)]=-\sum_{i=1}^n p(x_i)\log p(x_i)\]</span> 平均自信息量也叫做总体<span class="math inline">\(X\)</span>的<strong>信息熵</strong>。因为信息熵仅仅是总体的概率分布的函数，所以又可以记作： <span class="math display">\[H(X)=H(\mathbf P)=H(p_1,p_2,\cdots,p_n)=-\sum_{i=1}^n p_i\log p_i\]</span> 其中<span class="math inline">\(\sum_{i=1}^np_i=1\)</span>，所以它实际上是一个<span class="math inline">\(n-1\)</span>元函数。</p><p>在联合集<span class="math inline">\(XY\)</span>上，条件自信息量<span class="math inline">\(I(y\mid x)\)</span>的概率的加权平均值定义为条件熵，即： <span class="math display">\[H(Y\mid X)=\sum_{xy}p(x_i,y_j)I(y_j\mid x_i)\]</span> 对于条件熵，有： <span class="math display">\[\begin{aligned}&amp; H(Y \mid X) \leq H(Y) \\&amp; H(X \mid Y) \leq H(X)\end{aligned}\]</span> 在联合集<span class="math inline">\(XY\)</span>上，每对元素的自信息量的概率加权平均值定义为联合熵，即： <span class="math display">\[H(X,Y)=\sum_{xy}p(x_iy_j)I(x_i,y_j)\]</span> 对于联合熵，有： <span class="math display">\[H(X,Y)\leq H(X)+H(Y)\]</span> 当X和Y统计独立时，取得等号。</p><p>熵函数有以下特征：</p><ol type="1"><li><p>对称性：指无论如何改变概率矢量<span class="math inline">\(\mathbf P\)</span>中的元素排列顺序，<span class="math inline">\(H(\mathbf P)\)</span>保持不变</p></li><li><p>非负性：<span class="math inline">\(H(X)\geq 0\)</span>，当且仅当<span class="math inline">\(\mathbf P\)</span>中有且只有一个<span class="math inline">\(1\)</span>，其它全是<span class="math inline">\(0\)</span></p></li><li><p>扩展性： <span class="math display">\[\lim _{\epsilon \to 0}H_{n+1}(p_1,\cdots,p_n,\epsilon)=H_{n}(p_1,\cdots,p_n)\]</span> 意思是：一个事件的概率同总体中其它事件相比极小时，它对于总体熵的贡献可以忽略不计。</p></li><li><p>可加性： <span class="math display">\[H(X,Y)=H(X)+H(Y\mid X)=H(Y)+H(X\mid Y)\]</span></p></li><li><p>极值性 <span class="math display">\[H(\mathbf P)\leq H(\frac 1n,\cdots,\frac 1n)=\log n\]</span></p></li><li><p>上凸性：<span class="math inline">\(H(\mathbf P)\)</span>是<span class="math inline">\(\mathbf P\)</span>的严格上凸函数，即：</p><p>对于两个概率矢量<span class="math inline">\(\mathbf{P,P&#39;}\)</span>，有： <span class="math display">\[\forall \alpha \in (0,1),H[\alpha \mathbf P+(1-\alpha)\mathbf P&#39;]&gt;\alpha H(\mathbf P)+(1-\alpha)H(\mathbf P&#39;)\]</span></p></li></ol><h4 id="离散集的平均互信息量">离散集的平均互信息量</h4><p>在联合集<span class="math inline">\(XY\)</span>上，由<span class="math inline">\(y_j\)</span>提供的关于集<span class="math inline">\(X\)</span>的<strong>平均条件互信息量</strong>是由<span class="math inline">\(y_j\)</span>提供的关于元素<span class="math inline">\(x_i\)</span>的互信息量<span class="math inline">\(I(x_i;y_j)\)</span>的加权平均，即： <span class="math display">\[I(X;y_j)=\sum_{x_i\in X}p(x_i\mid y_j)I(x_i;y_j)\]</span> 平均条件互信息量在<span class="math inline">\(Y\)</span>上的加权平均是两个总体的<strong>平均互信息量</strong>，即： <span class="math display">\[I(X;Y)=\sum_{y_j\in Y}p(y_j)I(X;y_j)\]</span> 平均互信息量非负、互易，而且和通信熵具有如下的关系：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304152136046.png" alt="image-20230415213620301" /><figcaption aria-hidden="true">image-20230415213620301</figcaption></figure><h2 id="离散信源">离散信源</h2><h3 id="离散无记忆信源">离散无记忆信源</h3><p>离散无记忆信源可以用下面的概率分布描述： <span class="math display">\[\left[\begin{array}{l}X \\P\end{array}\right]=\left[\begin{array}{cccc}\alpha_1 &amp; \alpha_2 &amp; \cdots &amp; \alpha_q \\p\left(x_1\right) &amp; p\left(x_2\right) &amp; \cdots &amp; p\left(x_q\right)\end{array}\right]\]</span> 其<span class="math inline">\(N\)</span>次扩展信源<span class="math inline">\(X^N\)</span>是具有<span class="math inline">\(q^N\)</span>个符号的离散无记忆信源，为： <span class="math display">\[\left[\begin{array}{c}X^N \\p\end{array}\right]=\left[\begin{array}{cccc}\alpha_1 &amp; \alpha_2 &amp; \cdots &amp; \alpha_{q^N} \\p\left(\alpha_1\right) &amp; p\left(\alpha_2\right) &amp; \cdots &amp; p\left(\alpha_{q^N}\right)\end{array}\right]\]</span> <span class="math inline">\(N\)</span>次扩展信源的熵为原信源的<span class="math inline">\(N\)</span>倍，即： <span class="math display">\[H(X^N)=NH(X)\]</span></p><h3 id="离散平稳信源">离散平稳信源</h3><p>如果一个信源产生的随机序列<span class="math inline">\(X_i,i=1,2,\cdots\)</span>满足：</p><ol type="1"><li><p>所有<span class="math inline">\(x_i\)</span>都取值于有限的信源符号集合<span class="math inline">\(A=\{a_1,a_2\cdots,a_q\}\)</span></p></li><li><p>对所有的非负整数<span class="math inline">\(N,i_1,i_2,\cdots,i_N,h\)</span>，对所有的<span class="math inline">\(x_1,x_2,\cdots\in A\)</span>，有： <span class="math display">\[P(X_{i_1}=x_1,\dots,X_{i_N}=x_n)=P(X_{i_1+h}=x_1,\cdots,X_{i_N+h}=x_n)\]</span></p></li></ol><p>也就是说，这个信源发出的符号序列的概率分布和时间起点无关，那么这个信源称为离散平稳信源。</p><p>如果有 <span class="math display">\[P(X_i=x)=P(X_j=x)\]</span> 即任意时刻信源发出单个符号的概率相同，那么叫做“一维平稳信源”；如果随机序列的二维联合分布也和时间起点无关，称为二维平稳信源。如果对任意正整数<span class="math inline">\(N\)</span>，其联合分布都和时间起点无关，称为完全平稳信源，简称为平稳信源。</p>对二维平稳信源来说，有联合熵： <span class="math display">\[H(\mathbf{X})=H\left(X_1 X_2\right)=-\sum_{i=1}^q \sum_{j=1}^q p\left(a_i a_j\right) \log p\left(a_i a_j\right)\]</span> 条件熵： <span class="math display">\[H\left(X_2 \mid X_1\right)=-\sum_{i=1}^q \sum_{j=1}^q p\left(a_i a_j\right) \log p\left(a_j \mid a_i\right)\]</span> 因为 <span class="math display">\[p(a_ia_j)=p(a_j|a_i)p(a_i)\]</span> 所以 $$<span class="math display">\[\begin{aligned}H(X_1,X_2)&amp; =-\sum_{i=1}^q\left[\sum_{j=1}^q p\left(a_i a_j\right) \right] \log p\left(a_i\right)-\sum_{i=1}^q\sum_{j=1}^q p\left(a_i, a_j\right) \log p\left(a_j \mid a_j\right) \\&amp; =-\sum_{i=1}^q p\left(a_i\right) \log p\left(a_i\right)-H(X_1|X_2)\\&amp; =H(X_1)-H(X_1|X_2)\\\end{aligned}\]</span><p>$$ 即：联合熵＝前一个符号的信息熵＋前一个符号已知时信源发出下一个符号的条件熵。</p><p>对于平稳有记忆N次扩展信源，有平均符号熵： <span class="math display">\[H_N(X) \stackrel{\text { def }}{=} \frac{1}{N} H\left(X^N\right)=\frac{1}{N} H\left(X_1, X_2, \cdots X_N\right)\]</span> 当信源符号序列长度趋于无穷时，有极限熵： <span class="math display">\[H_{\infty}(X) \stackrel{\text { def }}{=} \lim _{N \rightarrow \infty} H_N(X)=\lim _{N \rightarrow \infty} \frac{1}{N} H\left(X^N\right)\]</span> N次扩展信源熵的性质有：</p><ol type="1"><li>条件熵<span class="math inline">\(H\left(X_N \mid X_1 X_2 \cdots X_{N-1}\right)\)</span>随<span class="math inline">\(N\)</span>增加非递增</li><li>平均符号熵<span class="math inline">\(H_N(X)\)</span>随<span class="math inline">\(N\)</span>增加非递增</li><li>极限熵存在，且<span class="math inline">\(H_\infty(X)=\lim _{N \rightarrow \infty} H\left(X_N \mid X_1 X_2 \cdots X_{N-1}\right)\)</span></li><li><span class="math inline">\(H_N(X) \geq H\left(X_N \mid X_1 X_2 \cdots X_{N-1}\right)\)</span></li></ol><h3 id="马尔可夫信源">马尔可夫信源</h3><p>如果系统在时刻<span class="math inline">\(n-1\)</span>处于状态<span class="math inline">\(S_{i_{n-1}}\)</span>，那么将来时刻<span class="math inline">\(n\)</span>的状态<span class="math inline">\(S_n\)</span>和过去的<span class="math inline">\(1,2,3,\cdots,n-2\)</span>都无关，只和现在时刻<span class="math inline">\(n-1\)</span>的状态有关，这样的特性叫做马尔可夫特性，这样的系统叫做马尔可夫链（有限状态一阶马尔可夫链），用数学语言描述，就是： <span class="math display">\[\begin{aligned}&amp; P\left(X_n=S_{i_n} \mid X_{n-1}=S_{i_{n-1}}, X_{n-2}=S_{i_{n-2}}, \cdots, X_1=S_{i_1}\right) \\= &amp; P\left(X_n=S_{i_n} \mid X_{n-1}=S_{i_{n-1}}\right)\end{aligned}\]</span> 引入转移概率： <span class="math display">\[P_{ij}(m,n)\]</span> 意思是已知时刻<span class="math inline">\(m\)</span>系统处于状态<span class="math inline">\(S_i\)</span>，经过<span class="math inline">\(n-m\)</span>步后系统转移到状态<span class="math inline">\(S_j\)</span>的概率。在有限状态一阶马尔可夫链中，我们主要关注<span class="math inline">\(P_{ij}(m,m+1)\)</span>，简记为<span class="math inline">\(P_{ij}(m)\)</span>，即： <span class="math display">\[p_{i j}(m)=P\left(X_{m+1}=S_j \mid X_m=S_i\right)\]</span> 类似地，定义<span class="math inline">\(k\)</span>步转移概率为<span class="math inline">\(P_{ij}^{(k)}(m)=P_{ij}(m,m+k)\)</span>。</p><p>因为系统在任意时刻都可能处于任意状态，所以一般用状态转移矩阵来描述，<span class="math inline">\(m\)</span>时刻的<span class="math inline">\(k\)</span>步转移矩阵定义为： <span class="math display">\[\mathbf P^{(k)}(m)=\{p_{ij}^{(k)}(m),i,j\in S\}\]</span> 如果在马尔科夫链中，<span class="math inline">\(p_{ij}(m)=p_{ij}\)</span>，即转移概率和<span class="math inline">\(m\)</span>无关，那么称之为<strong>齐次马尔可夫链</strong>,也叫遍历的马尔可夫链。齐次马尔科夫链的转移矩阵可以表示为： <span class="math display">\[\mathbf{P}=\left[\begin{array}{cccc}p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1 j} \\p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2 j} \\\vdots &amp; \vdots &amp; &amp; \vdots \\p_{j 1} &amp; p_{j 2} &amp; \cdots &amp; p_{jj}\end{array}\right]\]</span> 且有C-K方程： <span class="math display">\[\mathbf{P}^{(n+m)}=\mathbf{P}^{(n)} \cdot \mathbf{P}^{(m)}\]</span> 若齐次马尔可夫链对一切<span class="math inline">\(i,j\)</span>存在不依赖于<span class="math inline">\(i\)</span>的极限： <span class="math display">\[\lim _{n \rightarrow \infty} p_{i j}^{(n)}=p_j\]</span> 且满足：</p><ol type="1"><li><p><span class="math display">\[p_j\geq 0\]</span></p></li><li><p><span class="math display">\[p_j=\sum_{i=1}^\infty p_ip_{ij}\]</span></p></li><li><p><span class="math display">\[\sum_j p_j=1\]</span></p></li></ol><p>那么称其有平稳性，<span class="math inline">\(p_j\)</span>称为平稳分布，其中<span class="math inline">\(p_i\)</span>是马尔科夫链的初始分布。意思是，无论系统从哪个状态出发，当转移的步数足够多时，转移到特定状态的概率都近似等于一个常数。稳态分布存在的充要条件是：存在一个正整数<span class="math inline">\(N\)</span>，使得<span class="math inline">\(P^N\)</span>中的所有元素都大于零。</p><p>如果稳态分布存在，那么可以设稳态分布矢量<span class="math inline">\(\mathbf W=[w_1,w_2,\cdots,w_n]\)</span>，其中<span class="math inline">\(w_j\)</span>表示稳态分布中的<span class="math inline">\(p_j\)</span>，通过解方程 <span class="math display">\[\mathbf{W=WP}\]</span> 可以求解稳态分布，且稳态分布具有唯一性。</p><p>具有<span class="math inline">\(m\)</span>阶马尔可夫特性（即下一个时刻输出的符号仅和前<span class="math inline">\(m\)</span>个符号有关，和更前的符号无关）的信源称为<span class="math inline">\(m\)</span>阶马尔可夫信源。遍历的<span class="math inline">\(m\)</span>阶马尔可夫信源的极限熵为其<span class="math inline">\(m\)</span>阶条件熵，即： <span class="math display">\[H_\infty=H_{m+1}=H\left(X_{m+1} \mid X_1 X_2 \cdots X_m\right)\]</span></p><h3 id="相关性和冗余度">相关性和冗余度</h3><p>信源输出符号间的依赖关系越强，信源熵就会减小。这就是信源的相关性。当信源输出符号间的相关程度越长，信源的实际熵越小，趋于极限熵；当信源输出符号之间不存在相互依存关系且为等概分布，信源实际熵趋于最大熵<span class="math inline">\(H_0=\log q\)</span>，其中<span class="math inline">\(q\)</span>是信源输出符号集的符号数目。定义信源剩余度： <span class="math display">\[R=1-\frac{H_{\infty}}{H_0}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理· 调制之章</title>
    <link href="/2023/05/16/%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/"/>
    <url>/2023/05/16/%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="模拟调制">模拟调制</h2><p>调制是对信源（编码）产生的信号进行符号映射、频谱搬移、滤波等处理，以适配信道传输的过程。其意义在于便于设计小型发射机和提高无线资源的利用率。调制的基本框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304242218773.png" alt="调制" /><figcaption aria-hidden="true">调制</figcaption></figure><p>其中<span class="math inline">\(m(t)\)</span>是要传输的信号，叫做调制信号或基带信号，<span class="math inline">\(c(t)\)</span>是载波信号，<span class="math inline">\(s(t)\)</span>是已调信号。其基本方程为： <span class="math display">\[c(t)=A\cos(\omega_c t+\theta_c)\]</span> 如果基带信号<span class="math inline">\(m(t)\)</span>加在幅度<span class="math inline">\(A\)</span>上，叫做调幅；如果基带信号<span class="math inline">\(m(t)\)</span>加在频率<span class="math inline">\(\omega_c\)</span>上，叫做调频；如果基带信号<span class="math inline">\(m(t)\)</span>加在相位<span class="math inline">\(\theta_c\)</span>，叫做调相。</p><p>当<span class="math inline">\(s(t)\)</span>和<span class="math inline">\(m(t)\)</span>有线性关系时，叫做线性调制，例如调幅；当是非线性关系时，叫做非线性调制，例如调频或者调相。</p><h3 id="带通信号">带通信号</h3><p>在分析模拟调制之前，我们首先来分析一下带通信号。带通信号也叫窄带信号，是指频谱集中在某个载频<span class="math inline">\(f_c\)</span>附近的信号。本章提到的带通信号如无特别说明，一般指实信号，其频谱满足共轭对称性：<span class="math inline">\(X(f)=X^*(-f)\)</span>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305072217995.png" alt="带通信号" /><figcaption aria-hidden="true">带通信号</figcaption></figure><p>定义带通信号<span class="math inline">\(s(t)\)</span>的“解析信号”<span class="math inline">\(z(t)\)</span>为： <span class="math display">\[z(t)=s(t)+j\hat s(t)\]</span> 其中<span class="math inline">\(\hat s(t)\)</span>是<span class="math inline">\(s(t)\)</span>的希尔伯特变换，具体来说： <span class="math display">\[\hat s(t)=s(t)\bigotimes \frac {1}{\pi t}=\frac 1\pi \int_{-\infty}^\infty x(\tau)\frac {1}{t-\tau}\mathbf d t\]</span> 希尔伯特变换是一个<span class="math inline">\(90\degree\)</span>移相器，它把输入的实信号中的每一个频率分量按照各自的周期延迟<span class="math inline">\(1/4\)</span>周期。信号经过希尔伯特变换后功率谱密度不变，功率不变，自相关函数不变。其传递函数如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305072223694.png" alt="希尔伯特变换传递函数" /><figcaption aria-hidden="true">希尔伯特变换传递函数</figcaption></figure><p>那么考察<span class="math inline">\(z(t)\)</span>和<span class="math inline">\(s(t)\)</span>的频域，我们可以发现： <span class="math display">\[Z(f)= \begin{cases}2 S(f), &amp; f&gt;0 \\ 0, &amp; f&lt;0\end{cases}\]</span> 即其频谱为<span class="math inline">\(s(t)\)</span>的正频率的部分乘以二：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305072225260.png" alt="解析信号的频谱" /><figcaption aria-hidden="true">解析信号的频谱</figcaption></figure><p>设 <span class="math inline">\(f_{\mathrm{c}}&gt;0\)</span> 是任意一个落在实带通信号 <span class="math inline">\(s(t)\)</span> 频带内或者附近的频率值 ， 假设 <span class="math inline">\(s(t)\)</span> 的最高频率不超过 <span class="math inline">\(2 f_{\mathrm{c}}\)</span>, 也就是说, <span class="math inline">\(s(t)\)</span> 的傅里叶变换 <span class="math inline">\(S(f)\)</span> 在 <span class="math inline">\(f&lt;-2 f_{\mathrm{c}}\)</span> 以及 <span class="math inline">\(f&gt;2 f_c\)</span> 处为零。令 <span class="math inline">\(\phi\)</span> 是任意固定的相位, 则 <span class="math inline">\(s(t)\)</span> 的<strong>复包络</strong>定义为： <span class="math display">\[s_{\mathrm{L}}(t)=[s(t)+\mathrm{j} \hat{s}(t)] \mathrm{e}^{-\mathrm{j}\left(2 \pi f_{\mathrm{c}} t+\phi\right)}\]</span> 称上面式子的指数项为“参考复载波”。复包络和解析信号都是复信号。其功率谱和原信号的关系为： <span class="math display">\[P_{s_{\mathrm{L}}}(f)=P_z\left(f+f_{\mathrm{c}}\right)= \begin{cases}4 P_s\left(f+f_{\mathrm{c}}\right), &amp; |f| \leqslant f_{\mathrm{c}} \\ 0, &amp; |f|&gt;f_{\mathrm{c}}\end{cases}\]</span> 定义<span class="math inline">\(s_{I}(t)=Re\{s_L(t)\},s_Q(t)=Im\{s_L(t)\}\)</span>，则<span class="math inline">\(s(t)\)</span>可以表示为： <span class="math display">\[s(t)=s_I(t) \cos \left(2 \pi f_{\mathrm{c}} t+\phi\right)-s_Q(t) \sin \left(2 \pi f_{\mathrm{c}} t+\phi\right)\]</span> 如果把复数<span class="math inline">\(s_L\)</span>以极坐标方式表示： <span class="math display">\[\begin{gathered}A(t)=\left|s_{\mathrm{L}}(t)\right|=\sqrt{s_1^2(t)+s_Q^2(t)} \\\varphi(t)=\angle s_{\mathrm{L}}(t)=\arctan \frac{s_{\mathrm{Q}}(t)}{s_1(t)}\end{gathered}\]</span> 可以得到带通信号的三种表示方法： <span class="math display">\[\begin{aligned}s(t) &amp; =\operatorname{Re}\left\{s_{\mathrm{L}}(t) \mathrm{e}^{j\left(2 \pi j_e t+\phi\right)}\right\} \\&amp; =A(t) \cos \left[2 \pi f_{\mathrm{c}} t+\phi+\varphi(t)\right] \\&amp; =s_1(t) \cos \left(2 \pi f_{\mathrm{c}} t+\phi\right)-s_0(t) \sin \left(2 \pi f_{\mathrm{c}} t+\phi\right)\end{aligned}\]</span> 给定参考载波 <span class="math inline">\(\cos \left(2 \pi f_c t+\phi\right)\)</span> 时, 从带通信号 <span class="math inline">\(s(t)\)</span> 能唯一确定复包络 <span class="math inline">\(s_{\mathrm{L}}(t)\)</span>, 从复包络 <span class="math inline">\(s_{\mathrm{L}}(t)\)</span> 也 能唯一确定带通信号 <span class="math inline">\(s(t)\)</span> 。带通信号由复包络和参考载波共同决定, 参考载波决定带通信号的 频谱位置, 带通信号的其余信息都包含在复包络中。复包络是一个基带信号, 便于进行数学分析以及计算机仿真。</p><h3 id="模拟线性调制">模拟线性调制</h3><h4 id="常规双边带调幅am">常规双边带调幅AM</h4><p>AM的基本公式为： <span class="math display">\[c(t)=[A_0+m(t)]\cos \omega_c t\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021549898.png" alt="AM调制示意图" style="zoom:50%;" /></p><p>其中<span class="math inline">\(m(t)\)</span>的范围是<span class="math inline">\([-A_m,A_m]\)</span>，那么调幅系数定义为： <span class="math display">\[\beta=\frac {A_m} {A_0}\]</span> 其频谱为： <span class="math display">\[S_{AM}(f)=\frac 12\left(M(f+f_c)+M(f-f_c)\right)\]</span> AM信号的频谱和基带信号<span class="math inline">\(A_0+m(t)\)</span>的频谱的关系如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021549264.png" alt="image-20230502154705675" /><figcaption aria-hidden="true">image-20230502154705675</figcaption></figure><p><strong>可见：AM信号的频谱由载频分量和上下两个边带组成。上边带的频谱结构和原调制信号相同，下边带是上边带的镜像。</strong>如果说基带信号的带宽为<span class="math inline">\(B_b=f_H\)</span>，那么AM信号的带宽为<span class="math inline">\(2f_H=2B_b\)</span>.</p><p>AM信号的解调方法有两种，即包络检波法和相干解调法。相干解调法的框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021608521.png" alt="相干解调" /><figcaption aria-hidden="true">相干解调</figcaption></figure><p>其频谱变化过程示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021608073.png" alt="相干解调频谱" /><figcaption aria-hidden="true">相干解调频谱</figcaption></figure><p>AM调制的功率利用率比较低，而且占用频带较宽。为了解决这个问题，可以采用抑制载波双边带调制（DSB）</p><h4 id="双边带调制dsb">双边带调制DSB</h4><p>抑制载波双边带调制（DSB-SC）简称双边带调制（DSB）。其基本公式为： <span class="math display">\[s_{DSB}(t)=m(t)\cos \omega_c t\]</span> DSB信号的包络不再与调制信号的变化规律一致，因此包络检波法不再可用，只能使用相干解调法。相干解调法和AM基本相同，只是不需要隔直。有： <span class="math display">\[m(t)\cos \omega_c t\cdot\cos \omega_c t=\frac 12m(t)(1+\cos 2\omega_c t)\]</span> 因此通过低通滤波器后，有： <span class="math display">\[m_o(t)=\frac 12 m(t)\]</span> 虽然DSB节省了载波频率，提高了功率利用率，但是频带宽度仍然是调制信号带宽的2倍，与AM的相同。</p><h4 id="单边带调制ssb">单边带调制SSB</h4><p>单边带调制就是将DSB信号的频谱上只保留一个边带：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305021644115.png" alt="单边带调制" /><figcaption aria-hidden="true">单边带调制</figcaption></figure><p>保留红色的叫上边带（USB），保留蓝色的叫下边带（LSB）。</p><p>单边带调制信号可以用DSB信号通过一个低通（高通）滤波器来生成，也可以通过移相法实现： <span class="math display">\[s_{LSB}(t)=\frac 12\left(m(t)\cos \omega_c t+\hat m(t)\sin \omega_c(t)\right)\]</span> 其中<span class="math inline">\(\hat m(t)\)</span>是<span class="math inline">\(m(t)\)</span>的希尔伯特变换。证明可以直接对比左右两式的频域表达式。</p><p>SSB信号的解调，可以采用相干解调，如果一定要采取包络检波，则要插入强载波。</p><h4 id="残留边带调制vsb">残留边带调制VSB</h4><p>SSB调制对滤波器的要求有点过高了。在残留边带调制中，除了传送一个边带外，还保留了另外一个边带的一部分。对于具有低频及直流分量的调制信号，用滤波法实现单边带调制时所需要的过渡带无限陡的理想滤波器，在残留边带调制中已不再需要。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305022044405.png" alt="VSB频谱" /><figcaption aria-hidden="true">VSB频谱</figcaption></figure><p>其对滤波器传递函数的要求为： <span class="math display">\[H(f+f_c)+H(f-f_c)=C\]</span> 即<span class="math inline">\(H(f)\)</span>在<span class="math inline">\(f_c\)</span>两侧互补对称。</p><h3 id="非线性调制角度调制">非线性调制（角度调制）</h3><h4 id="相位调制pm">相位调制PM</h4><p>使相位随调制信号线性变化，即： <span class="math display">\[s_{PM}(t)=A\cos \left[\omega_ct+\varphi_0+K_{PM}m(t)\right]\]</span> 其中的<span class="math inline">\(K_{PM}\)</span>叫做调相灵敏度，瞬时相位为： <span class="math display">\[\varphi_0+K_{PM}m(t)\]</span> 瞬时相位偏移为 <span class="math display">\[K_{PM}m(t)\]</span> 其最大值定义为调相指数： <span class="math display">\[M_p=K_{PM}A_m\]</span></p><h4 id="频率调制fm">频率调制FM</h4><p>使瞬时频率随着调制信号线性变化，叫做频率调制。即： <span class="math display">\[\omega(t)=\omega_c +K_{FM}m(t)\]</span> 更进一步，调频的实质其实是让角度的导数和调制信号成正比，即瞬时频率偏移是调制信号的线性函数： <span class="math display">\[\frac d{dt}\varphi(t)=2\pi K_{FM}m(t)\]</span> 因此，调频的表达式为： <span class="math display">\[s_{FM}(t)=A\cos \left[\omega_ct+\varphi_0+K_{FM}\int _{-\infty}^tm(\tau)d\tau\right]\]</span> 其中<span class="math inline">\(m(t)\)</span>的范围是<span class="math inline">\([-A_m,A_m]\)</span>.</p><p>瞬时频率偏离<span class="math inline">\(f_c\)</span>的最大值叫做最大频偏，即： <span class="math display">\[\Delta f=\frac 1{2\pi}\left| \frac d{dt}\varphi(t)\right|_{max}=K_{FM}A_m\]</span> 最大频偏按消息信号的带宽<span class="math inline">\(W\)</span>归一化的值代表调频波的最大相对偏移，叫做调频指数： <span class="math display">\[M_f=\beta_{FM}=\frac{K_{FM}A_m}{W}\]</span> <span class="math inline">\(M_f\)</span>和<span class="math inline">\(\beta_{FM}\)</span>都是调频指数，是同一个事物的两个名字，我也不知道为什么会这样。</p><p>对于单频调制而言，假设调制信号为余弦波 <span class="math display">\[m(t)=A_m\cos \omega_m t\]</span> 调相，有： <span class="math display">\[s_{PM}(t)=A\cos(\omega_ct+K_{PM}A_m\cos \omega_mt)\]</span> 其中调相指数<span class="math inline">\(M_p=K_{PM}A_m\)</span>，就是相位部分的振幅值，代表最大相位偏移。</p><p>调频，有： <span class="math display">\[\begin{aligned}s_{F M}(t) &amp; =A \cos \left(\omega_c t+K_{F M} \int_{-\infty}^t A_m \cos \omega_m \tau d \tau\right) \\&amp; =A \cos \left(\omega_c t+\frac{K_{F M} A_m}{\omega_m} \sin \omega_m t\right) \\&amp; =A \cos \left(\omega_c t+M_f \sin \omega_m t\right)\end{aligned}\]</span> 其中 <span class="math display">\[M_f=\frac{K_{FM}A_m}{\omega_m}\]</span> 为调频知数，代表调频波的最大相对偏移。调频波的最大频率偏移为： <span class="math display">\[\Delta \omega_m=K_{FM}A_m=M_f\omega_m\]</span> 可以看出，最大频偏就是把表达式相位部分的幅值和角频率乘起来。</p><p>所以也可以说： <span class="math display">\[M_f=\frac{\Delta \omega_{m}}{\omega_m}\]</span> 即调频最大频偏/调制信号频率。请注意，上面这部分的频率都是角频率，也即<span class="math inline">\(\omega\)</span>，如果要算<span class="math inline">\(f\)</span>，需要除以<span class="math inline">\(2\pi\)</span></p><p>当<span class="math inline">\(A_m\)</span>不变，调制信号频率<span class="math inline">\(\omega_m\)</span>增大时：</p><ul><li>FM中的<span class="math inline">\(\Delta f\)</span>不变，<span class="math inline">\(M_f\)</span>成反比例地减小</li><li>PM中的<span class="math inline">\(\Delta f\)</span>成正比例增大，<span class="math inline">\(M_p\)</span>不变</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305022146037.png" alt="示意图" /><figcaption aria-hidden="true">示意图</figcaption></figure><blockquote><p>【例】用基带信号对载波进行调频得到 <span class="math display">\[s(t)=10\cos(2\pi f_ct+5\cos 200\pi t)\]</span></p><ol type="1"><li>求最大频偏、调频指数、带宽</li><li>固定<span class="math inline">\(K_{FM},f_m\)</span>，把<span class="math inline">\(A_m\)</span>提高一倍，求（1）</li><li>固定<span class="math inline">\(K_{FM},A_m\)</span>，把<span class="math inline">\(f_m\)</span>提高一倍，求（1）</li></ol><p>【解】</p><ol type="1"><li><p>最大频偏(相位部分表达式幅度乘以频率) <span class="math display">\[\Delta f_m=5\times 200\pi/2\pi=500\]</span> 调频指数(相位部分表达式的幅度) <span class="math display">\[M_f=\frac{\Delta f_m}{f_m}=5\]</span> 带宽 <span class="math display">\[B=2(\Delta f_m+f_m)=1200\]</span></p></li><li><p>调频指数 <span class="math display">\[M_f=\frac{K_{FM}A_m}{\omega_m}=10\]</span> 最大频偏 <span class="math display">\[\Delta f_m=1000\]</span> 带宽 <span class="math display">\[B=2(\Delta f_m+f_m)=2200\]</span></p></li><li><p>仍旧从调频指数定义式出发，有：<span class="math inline">\(\Delta f_m=500,M_f=2.5,B=1400\)</span></p></li></ol></blockquote><p>如果将调制信号先积分，而后进行调相，则得到的是调频波，这种方式叫间接调频。也就是说，PM和FM的区别其实就是更换了调制信号。下面，主要对FM进行讨论。</p><p>经过分析，可以知道已调信号的带宽实际上是无穷，但是其能量主要集中在<span class="math inline">\(f_c\)</span>附近的一个范围内。其频带宽度可以大致用卡森公式估计： <span class="math display">\[B_{FM}=2(1+M_f)f_m=2(\Delta f+f_m)\]</span></p><blockquote><p>【例】2MHz载波受10KHz单频正弦调频，峰值频偏为10KHz，求：</p><ol type="1"><li>调频信号带宽</li><li>调制信号幅度加倍时，调频信号的带宽</li><li>调制信号频率加倍时，调频信号的带宽</li><li>如果峰值频偏减为1KHz，分别计算123</li></ol><p>【解】由卡森公式：<span class="math inline">\(B_{FM}=2(1+M_f)f_m=2(\Delta f+f_m)\)</span>，调频指数：<span class="math inline">\(M_f=AK_{fm}/\omega_m=\Delta f_{\max}/f_m\)</span></p><ol type="1"><li><span class="math inline">\(M_f=\Delta f_{\max}/f_m=10k/10k=1\)</span>，则<span class="math inline">\(B_{fm}=2\times (1+1)\times 10=40\text {kHz}\)</span></li><li>幅度加倍，则最大频偏加倍，则<span class="math inline">\(M_f\)</span>加倍，<span class="math inline">\(B_{fm}=2\times (2+1)\times 10=60\text{kHz}\)</span></li><li>频率加倍，则<span class="math inline">\(B_{fm}=2(20+10)=60\text{kHz}\)</span></li><li>则<span class="math inline">\(\Delta f_m=1kHz\)</span>，对（1）有：<span class="math inline">\(B_{fm}=2\times (0.1+1)\times 10=22\text{kHz}\)</span>，其余略</li></ol></blockquote><p>要进行调频，有直接法和倍频法。直接法又叫VCO调频，就是用调制信号直接控制压控振荡器的频率，使其按调制信号的规律线性变化。其缺点是载频<span class="math inline">\(f_c\)</span>可能会产生漂移。</p><p>倍频法是先对调制信号积分后再进行相位调制，从而产生窄带调频信号，然后利用倍频器把它变成宽带调频信号。</p><h3 id="模拟调制的噪声分析">模拟调制的噪声分析</h3><p>在分析噪声时，认为噪声是加性<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="叠加在信号上的噪声。与此相对，乘性噪声是乘在信号上的。">[1]</span></a></sup>各态历经<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="各态历经的意思是统计平均等于时间平均，$E[x(t)]=\bar x(t)$​。直观理解就是“一次性投100枚硬币”和“把一枚硬币投100次”是等效的。">[2]</span></a></sup>平稳<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="平稳的意思是概率密度函数和时间无关">[3]</span></a></sup>高斯<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="高斯的意思是概率密度分布是高斯分布">[4]</span></a></sup>白<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="白噪声的意思是功率谱是常数">[5]</span></a></sup>噪声。</p><table><thead><tr class="header"><th>调制方式</th><th>通带</th><th><span class="math inline">\(S_i/N_i\)</span></th><th><span class="math inline">\(S_o/N_o\)</span></th><th><span class="math inline">\(G_m\)</span></th><th>复杂度</th></tr></thead><tbody><tr class="odd"><td>DSB</td><td><span class="math inline">\(2f_m\)</span></td><td><span class="math inline">\(\frac{P_m/2}{2f_mn_0}\)</span></td><td><span class="math inline">\(\frac{P_m}{2f_mn_0}\)</span></td><td>2</td><td>中</td></tr><tr class="even"><td>SSB</td><td><span class="math inline">\(f_m\)</span></td><td><span class="math inline">\(\frac{P_m/4}{f_mn_0}\)</span></td><td><span class="math inline">\(\frac{P_m}{4f_mn_0}\)</span></td><td>1</td><td>难</td></tr><tr class="odd"><td>VSB</td><td>略大于<span class="math inline">\(f_m\)</span></td><td>同上</td><td>同上</td><td>同上</td><td>难</td></tr><tr class="even"><td>AM</td><td><span class="math inline">\(2f_m\)</span></td><td><span class="math inline">\(\frac{(A^2+P_m)/2}{2f_mn_0}\)</span></td><td><span class="math inline">\(P_m/2f_mn_0\)</span></td><td><span class="math inline">\(2\eta_{AM}\)</span></td><td>易</td></tr><tr class="odd"><td>FM</td><td><span class="math inline">\(2(M_f+1)f_m\)</span></td><td><span class="math inline">\(\frac{A^2}{2B_{FM}n_0}\)</span></td><td><span class="math inline">\(3M_f^2\frac{P_mA^2/2}{A_m^2n_0f_m}\)</span></td><td><span class="math inline">\(6\beta^2(1+\beta)\frac{P_m}{A_m^2}\)</span></td><td>中</td></tr></tbody></table><blockquote><p>【例（2022期末）】已知信号<span class="math inline">\(m(t)\)</span>是带宽为20kHz的低频信号，分别经过以下两种方式调制以后得到调制信号，调制信号经过信道传输，解调后输出。如果要求输出信号的信噪比为40dB，设信道传输损耗为50dB，信道引入的加性高斯白噪声双边功率谱密度<span class="math inline">\(n_0/2=10^-12 W/Hz\)</span>，求以下两种情况的最小发射功率。</p><ol type="1"><li>DSB-SC</li><li>AM，<span class="math inline">\(\eta=0.2\)</span></li></ol><p>【解】</p><ol type="1"><li><p>由题知，<span class="math inline">\(SNR_o=10^4,SNR_i=SNR_o/ G=2\times 10^3\)</span></p><p>先假设信道没有衰减，那么有 <span class="math display">\[P_s=SNR_i\cdot 2n_0f_m=2\cdot10^3\times 2\cdot 10^{-12}\times20k=4\times10^{-4}W\]</span> 加上信道衰减，发射功率为<span class="math inline">\(P_s\times 10^5=40W\)</span></p></li><li><p>由题知，<span class="math inline">\(SNR_o=10^4,SNR_i=SNR_o/G=SNR_o/(2\eta)=2.5\cdot 10^{4}\)</span></p><p>假设没有衰减，那么有 <span class="math display">\[P_s=SNR_i\cdot2n_0f_m=2\cdot 10^{-3}W\]</span> 加上信道衰减，发射功率为<span class="math inline">\(P_s\times 10^5=200W\)</span></p></li></ol></blockquote><p>在上面这个例子中，有些同学可能会有一个疑问，那就是dB不是<span class="math inline">\(20\lg(\cdot)\)</span>吗？为什么40dB是<span class="math inline">\(10^4\)</span>呢？实际上，因为这里是基于功率定义的dB。由于功率跟幅度的平方成正比，所以在基于幅度定义的dB的对数运算后前面又乘以2，变成了“20lg”。</p><blockquote><p>【例（2022期末）】对某一信号进行FM调制传输，设加到接收机的调制信号功率谱密度是 <span class="math display">\[P_m(f)=\left\{\begin{array}{cc}\frac{n_m}{2} \times \frac{|f|}{f_m} &amp; |f| \leq f_m \\0 &amp; |f|&gt;f_m\end{array}\right.\]</span> 其中<span class="math inline">\(f_m=5kHz,n_m=2V^2/Hz\)</span>。载波振幅100V，频率100MHz，<span class="math inline">\(k_f=500\pi\ rad/(s\cdot V)\)</span>，最大频偏<span class="math inline">\(\Delta f_{max}=75kHz\)</span>，噪声功率谱均匀，单边功率谱是<span class="math inline">\(p_n(f)=10^-3 W/Hz\)</span>，求</p><ol type="1"><li>调制信号带宽</li><li>解调器输入信噪功率比</li><li>系统的解调增益和输出信噪功率比</li></ol><p>【解】</p><ol type="1"><li><p>有卡森公式： <span class="math display">\[B=2(f_m+\Delta f)=2(5k+75k)=160 kHz\]</span></p></li><li><p>有：<span class="math inline">\(S_i=(A/\sqrt 2)^2=(100/\sqrt 2)^2=5000\)</span></p><p><span class="math inline">\(N_i=p_n\cdot W=10^{-3}\times 160k=160\)</span></p><p>所以<span class="math inline">\(SNR_i=31.25\)</span></p></li><li><p>由于 <span class="math display">\[G=6\beta_{fm}^2(\beta_{fm}+1)\frac{P_m}{A_m^2}\]</span> 其中<span class="math inline">\(\beta_{fm}=\Delta f/f_m=15\)</span> <span class="math display">\[P_m=2\int_{0}^{f_m}p_m(f)\mathbf df=\frac 12 f_mn_m=5000\]</span></p><p><span class="math display">\[A_m=\frac{\Delta f}{k_f}=\frac{75k}{250}=300\]</span></p><p>代入，有：<span class="math inline">\(G=1.2\cdot 10^{3}\)</span></p><p>所以 <span class="math display">\[SNR_o=SNR_i\times G=3.75\times 10^4\]</span></p></li></ol></blockquote><blockquote></blockquote><h2 id="模拟信号数字化">模拟信号数字化</h2><h3 id="采样">采样</h3><p>采样就是把时间上连续的模拟信号变成一系列时间上离散的采样值的过程。如果对一个频带有限的连续时间信号进行采样，当采样速率满足某些条件时，它的原信号就能由采样信号唯一地恢复出来，这是模拟信号数字化的理论依据。</p><h4 id="低通采样定理">低通采样定理</h4><p>一个频带限制在<span class="math inline">\((0,f_H)\)</span>范围内的连续时间信号<span class="math inline">\(m(t)\)</span>，如果以<span class="math inline">\(T_s\leq 1/(2f_H)\)</span>的时间间隔进行等间隔采样，则<span class="math inline">\(m(t)\)</span>被所得到的采样序列完全确定。换句话说，在信号最高频分量的一个周期内应该至少采样两次。</p><p>以下是对这个结论的简单证明：</p><p>假设采样脉冲为： <span class="math display">\[\delta_{T_s}(t)=\sum_{-\infty}^\infty\delta(t-nT_s)\]</span> 即一个周期为<span class="math inline">\(T_s\)</span>的冲激串。那么有： <span class="math display">\[\mathscr F[\delta_{T_s}(t)]=\frac {2\pi}{T_s}\sum_{n=-\infty}^\infty\delta(\omega-n\omega_s)=\frac{2\pi}{T_s}\delta_{\omega_s}(\omega)\]</span> 那么采样的过程是： <span class="math display">\[m_s(t)=m(t)\cdot \delta_{T_s}(t)\]</span> 因为时域相乘就是频域卷积，所以： <span class="math display">\[M(\omega)=\frac 1{2\pi}M(\omega)\bigotimes \delta_{T_S}(\omega)=\frac 1 {T_s}\sum_{n=-\infty}^\infty M(\omega-n\omega_s)\]</span> 那么就相当于把无数个间隔为<span class="math inline">\(\omega_s\)</span> 的 <span class="math inline">\(M(\omega)\)</span> 叠加而成：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122109921.png" alt="低通采样" /><figcaption aria-hidden="true">低通采样</figcaption></figure><p>那么对<span class="math inline">\(T_s\)</span>的限制条件就是显而易见的了。</p><h4 id="带通采样">带通采样</h4><p>一个带通信号<span class="math inline">\(m(t)\)</span>,其频率限制在<span class="math inline">\(f_L\)</span>与<span class="math inline">\(f_H\)</span>之间，带宽为<span class="math inline">\(B=f_L-f_H,\)</span>如果最小采样速率<span class="math inline">\(f=2f_H/m\)</span>,<span class="math inline">\(m\)</span>是一个不超过<span class="math inline">\(f_H/B\)</span>的最大整数，那么<span class="math inline">\(m(t)\)</span>可完全由其采样值确定。</p><h4 id="实际采样">实际采样</h4><p>前面两个理想采样用的采样函数都是冲激串，实际上当然不可能用冲激串，而是采用矩形串。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122147282.png" alt="矩形串" /><figcaption aria-hidden="true">矩形串</figcaption></figure><p>实际采样主要有两种。</p><p>其一是自然采样，意思是采样所得的每个“矩形”的顶都不是平顶，而是按照<span class="math inline">\(m(t)\)</span>的形状变化的。自然采样的波形和频谱如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122148557.png" alt="自然采样的波形和频谱" /><figcaption aria-hidden="true">自然采样的波形和频谱</figcaption></figure><p>自然采样和理想（低通）采样的不同之处是：理想采样的频谱被常数<span class="math inline">\(1/T_s\)</span>加权，因而信号带宽为无穷大；而自然采样频谱的包络按<span class="math inline">\(sinc\)</span>函数随频率增高而下降，带宽与脉宽<span class="math inline">\(\tau\)</span>有关。</p><p>其二是平顶采样，顾名思义和自然采样不同，这里的采样得到的每个“矩形”的顶都是平顶，如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122151229.png" alt="平顶采样示意图" /><figcaption aria-hidden="true">平顶采样示意图</figcaption></figure><p>其频谱不再是原信号频谱直接搬移，而是在搬移的同时，出现了失真，此种失真称为孔径失真。</p><h3 id="量化">量化</h3><p>在采样以后，虽然时间域上信号变成了离散的，但是从幅度上来说依然是连续的，也就是说幅度是多少都有可能，所以没办法之间数字化。为了数字化，需要对采样后的信号进行进一步的量化处理，也就是利用预先规定的有限个电平来表示模拟信号的采样值的过程。量化是从无穷多连续电平到有限个离散电平的不可逆映射过程，所以一定会产生失真。</p><p>一般来说，量化就是把<span class="math inline">\((x_k,x_{k+1}]\)</span>范围内的电平映射为<span class="math inline">\(y_k\)</span>的过程。其中<span class="math inline">\(x_k\)</span>叫做分层电平，<span class="math inline">\(y_k\)</span>叫做量化电平，<span class="math inline">\((x_k,x_{k+1}]\)</span>叫做量化区间，一个量化区间对应一个量化电平。用<span class="math inline">\(y=Q(x)\)</span>来表示采样电平<span class="math inline">\(x\)</span>经量化的结果为<span class="math inline">\(y\)</span>。</p><p>那么量化误差定义为： <span class="math display">\[q=x-Q(x)\]</span> 因为<span class="math inline">\(x\)</span>是随机变量，所以<span class="math inline">\(q\)</span>也是随机变量。一般用均方误差（平均功率）来衡量量化误差的大小： <span class="math display">\[\sigma_q^2=E[x-Q(x)]^2=\int_{-\infty}^\infty [x-Q(x)]^2p_x(x)dx\]</span> 即： <span class="math display">\[\sigma_q^2=\sum_{k=1}^L \int_{x_k}^{x_{k+1}}\left(x-y_k\right)^2 p_x(x) d x\]</span> 一般用量化信噪比来衡量量化器的性能，信噪比越大，性能越好： <span class="math display">\[SNR=S/\sigma_q^2\]</span></p><h4 id="均匀量化">均匀量化</h4><p>把输入信号的取值域按等间隔分割的量化称为均匀量化。在均匀量化中，每个量化区间的量化电平的取值在各区间的中点。如果量化范围为<span class="math inline">\([-V,V]\)</span>，量化层数为<span class="math inline">\(L\)</span>，那么：</p><ul><li><p>量化间隔为<span class="math inline">\(\Delta V=2V/L\)</span></p></li><li><p>分层电平为<span class="math inline">\(x_k=-V+(k-1)\Delta V\)</span></p></li><li><p>量化电平为<span class="math inline">\(y_k=-V+(k-1/2)\Delta V\)</span></p></li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122225164.png" alt="均匀量化示意图" /><figcaption aria-hidden="true">均匀量化示意图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305122234010.png" alt="均匀量化误差示意图" /><figcaption aria-hidden="true">均匀量化误差示意图</figcaption></figure><p>如果忽略过载区，即假设输入信号是<span class="math inline">\([-V,V]\)</span>中的均匀分布，那么量化噪声功率为： <span class="math display">\[\sigma_q^2=\frac{\Delta V^2}{12}=\frac{V^2}{3 L^2}\]</span> 假设输入信号为正弦信号，幅度为<span class="math inline">\(A_m\leq V\)</span>，那么有：</p><ul><li><p>信号功率<span class="math inline">\(S=A_m^2/2\)</span></p></li><li><p>噪声功率<span class="math inline">\(\sigma_q^2=V^2/(3L^2)\)</span></p></li><li><p>信噪比 <span class="math display">\[S N R=\frac{S}{\sigma_q^2}=\frac{A_m^2 / 2}{V^2 /\left(3 L^2\right)}=\frac{3 A_m^2 L^2}{2 V^2}\]</span></p></li></ul><p>进一步，如果定义归一化有效值为<span class="math inline">\(D=A_m/(\sqrt 2 V)\)</span>，设量化间隔数<span class="math inline">\(L=2^n\)</span>称为<span class="math inline">\(n\)</span>比特量化，有：</p><ul><li><p>信噪比 <span class="math display">\[S N R=\frac{S}{\sigma_q^2}=\frac{3 A_m^2 L^2}{2 V^2}=3 D^2 L^2=3 D^2 2^{2 n}\]</span></p></li><li><p>用分贝表示的信噪比 <span class="math display">\[SNR=10\lg 3+20\lg D+20\lg 2^n\]</span></p></li></ul><h4 id="非均匀量化">非均匀量化</h4><p>非均匀量化是一种在输入信号的动态范围内量化间隔不相等的量化方式。在信号取值小的区间，量化间隔小；在信号取值大的区间，量化间隔大。在改善小信号量化信噪比的同时，不影响大信号量化信噪比。相当于压缩信号的动态范围（容忍更大动态范围）</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162144263.png" alt="非均匀量化流程图" /><figcaption aria-hidden="true">非均匀量化流程图</figcaption></figure><p>实现非均匀量化一般采取压缩法，即使用一个上凸函数对输入信号进行压缩，以期放大小信号，缩小大信号，然后再对变换后的信号进行均匀量化。</p><p>𝐿 ≫ 1（分层很密）时，每一量化级中的压缩特性曲线可以近似看做直线，有： <span class="math display">\[\sigma_q^2=\frac{1}{12} \int_{-V}^V\left[\Delta_k(x)\right]^2 p_x(x) d x\]</span> 设压缩特性为<span class="math inline">\(y=f(x)\)</span>，且压缩后的量化间隔为等间隔，即<span class="math inline">\(\Delta_z=2V/L\)</span>，那么有： <span class="math display">\[\sigma_q^2=\frac{\Delta^2}{6} \int_0^V\left[f^{\prime}(x)\right]^{-2} p_x(x) d x\]</span> 对于理想的对数量化器，即： <span class="math display">\[y=f(x)=\frac 1B \ln x\]</span> 有量化信噪比为： <span class="math display">\[\frac{S}{\sigma_q^2}=\frac{12}{B^2 \Delta^2}=\frac{3 L^2}{B^2 V^2}\]</span> 可见其量化信噪比是常数，和信号的分布、D（归一化有效值）等变量无关，是一种最平稳的状态。</p><p>但是实际上对数压缩无法实现，因为<span class="math inline">\(y\)</span>随着<span class="math inline">\(x\)</span>的减小而趋向于无穷大。在应用中，常用的量化有A律和<span class="math inline">\(\mu\)</span>律量化两种，它们的区别是压扩函数不同。</p><p>A律的压扩函数为： <span class="math display">\[y= \begin{cases}\frac{A x}{1+\ln A} &amp; 0 \leqslant x \leqslant \frac{1}{A} \\ \frac{1+\ln A x}{1+\ln A} &amp; \frac{1}{A} \leqslant x \leqslant 1\end{cases}\]</span> 其中<span class="math inline">\(x,y\)</span>都是归一化<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="归一化的意思是当前值和最大值之比">[6]</span></a></sup>电平值，在<span class="math inline">\([0,1]\)</span>之间，国际标准中<span class="math inline">\(A=87.6\)</span>。</p><p><span class="math inline">\(\mu\)</span>律的压扩函数为： <span class="math display">\[y=\frac{\ln (1+\mu x)}{\ln (1+\mu)} \quad 0 \leqslant x \leqslant 1\]</span> 其中<span class="math inline">\(\mu\)</span>越大，压缩效果越明显，国际标准中<span class="math inline">\(\mu=255\)</span>。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162159933.png" alt="两种常用非均匀量化器压缩函数图像" /><figcaption aria-hidden="true">两种常用非均匀量化器压缩函数图像</figcaption></figure><p>由公式： <span class="math display">\[\sigma_q^2=\frac{\Delta^2}{6} \int_0^V\left[f^{\prime}(x)\right]^{-2} p_x(x) d x\]</span> 知，量化信噪比比均匀量化改造<span class="math inline">\([f&#39;(x)]^2\)</span>倍，具体地，对于A律，有： <span class="math display">\[\left.f^{\prime}(x)\right|_{x \rightarrow 0}=\frac{87.6}{1+\ln 87.6}=16\]</span> 改善<span class="math inline">\(20\lg 16=24\mathbf {dB}\)</span>。对<span class="math inline">\(\mu\)</span>律，有： <span class="math display">\[\left.f^{\prime}(x)\right|_{x \rightarrow 0}=\left.\frac{\mu}{\ln (1+\mu)}\right|_{\mu=255}=46\]</span> 改善<span class="math inline">\(20\lg 46=33.3\mathbf {dB}\)</span>。</p><h3 id="编码脉冲编码调制">编码（脉冲编码调制）</h3><p>PCM（脉冲编码调制）简称脉码调制，是一种用一组二进制数字代码（码字）来代替连续信号的采样值，从而实现数字通信的方式。首先，我们来明确几个基本概念，即码组、码字、码型。</p><p>对于<span class="math inline">\(L\)</span>个量化电平的采样值，可以用<span class="math inline">\(N=\log _2 L\)</span>​位二进制的<strong>码组</strong>进行唯一表示。一个𝑁位二进制码组称为一个<strong>码字</strong>，一个码字对应一个量化电平。而码型指的是编码的规律，也就是把十进制数变成01序列的过程，常用的码型有自然码，折叠码，格雷码等。</p><p>自然码就是量化级序号十进制正整数的二进制表示，例如用四位码表示从低往高第六个量化级，就是<code>0110</code></p><p>折叠码的第一位是符号位（也叫极性码），后面的位表示幅度<strong>绝对值的大小</strong>。从编码效果来看，对于正样值，自然码和折叠码相同；对于负样值，除了符号位以外，折叠码是自然码按位取反的结果。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162246446.png" alt="常用码型" /><figcaption aria-hidden="true">常用码型</figcaption></figure><p>对于非均匀量化，为了在编码时比较方便，需要对压缩函数进行折线近似。折线近似的基本思想就是在<span class="math inline">\(y\)</span>坐标上，把纵轴等分成<span class="math inline">\(N\)</span>份，然后把曲线分成（不超过）<span class="math inline">\(N\)</span>个曲线段，把每个曲线段近似为折线，然后再进行。例如对于<span class="math inline">\(A\)</span>律，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305162253217.png" alt="A律折线近似" /><figcaption aria-hidden="true">A律折线近似</figcaption></figure><p>其中最靠近原点的第1、2段的斜率是一样的，所以他俩其实是一条线，这也是我前面说“不超过<span class="math inline">\(N\)</span>个”的原因。这样一来，A律正负双向共有13段折线（本来16段，1、2、-1、-2合为1段），所以叫做“A律13折线近似”。</p><p>在对A律13折线进行编码时，采用八位二进制码，即<span class="math inline">\(256\)</span>个量化级，正负样值各<span class="math inline">\(128\)</span>个。于是需要把8个折线段中的每个再分为16份，按折叠码型，这八位安排如下：</p><table><thead><tr class="header"><th>极性码</th><th>段落码</th><th>段内码</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(C_1\)</span></td><td><span class="math inline">\(C_2C_3C_4\)</span></td><td><span class="math inline">\(C_5C_6C_7C_8\)</span></td></tr></tbody></table><p>具体编码规则如下：</p><table><thead><tr class="header"><th>量化段序号</th><th>电平范围/<span class="math inline">\(\Delta\)</span></th><th>段落码</th><th>段落起始电平</th><th>量化间隔<span class="math inline">\(\Delta_i/\Delta\)</span></th></tr></thead><tbody><tr class="odd"><td>8</td><td>1024~2048</td><td>111</td><td>1024</td><td>64</td></tr><tr class="even"><td>7</td><td>512~1024</td><td>110</td><td>512</td><td>32</td></tr><tr class="odd"><td>6</td><td>256~512</td><td>101</td><td>256</td><td>16</td></tr><tr class="even"><td>5</td><td>128~256</td><td>100</td><td>128</td><td>8</td></tr><tr class="odd"><td>4</td><td>64~128</td><td>011</td><td>64</td><td>4</td></tr><tr class="even"><td>3</td><td>32~64</td><td>010</td><td>32</td><td>2</td></tr><tr class="odd"><td>2</td><td>16~32</td><td>001</td><td>16</td><td>1</td></tr><tr class="even"><td>1</td><td>0~16</td><td>000</td><td>0</td><td>1</td></tr></tbody></table><p>注意：每个段落都不含其起始电平，例如电平64应该属于段落3而不是段落4。接下来举例说明：</p><blockquote><p>【例】若13折线A律编码器的不过载量化范围为（−5𝑉, +5𝑉 ），输入抽样脉冲幅度为−1.6875𝑉。设量化器的最小量化间隔为1个单位，最大分层电平为2048个单位。求编码器的输出码组，并计算量化误差。</p><p>【解】</p><p>先把输入信号归一化 <span class="math display">\[[\frac {-1.6875}{5}\cdot 2048]=-691\]</span> 符号位：因为是负样值，所以是<code>0</code></p><p>段落码：因为<span class="math inline">\(691\in (2^9,2^{10}]\)</span>，所以是第七段，段落码为<code>110</code></p><p>段内码： <span class="math display">\[[\frac {691-2^9}{32}]=5\]</span> 所以段内码为<code>0101</code></p><p>所以编码结果是<code>01100101</code></p><p>恢复出的电平为<span class="math inline">\(-[512+32(5+0.5)]=-688\)</span>，量化误差为： <span class="math display">\[(|-691.2+688|)\cdot \frac{5}{2048}=0.0078V\]</span></p></blockquote><h3 id="pcm的抗噪声性能">PCM的抗噪声性能</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305171507673.png" alt="PCM系统示意图" /><figcaption aria-hidden="true">PCM系统示意图</figcaption></figure><p>在PCM系统中，噪声主要有两个来源，其一是量化过程引入的量化噪声，其二是二进制信道传输过程中产生的误码引入的误码失真噪声。</p><p>假设输入信号为 [−𝑉, +𝑉] 均匀分布的随机变量，<span class="math inline">\(𝐿 = 2^𝑁&gt;&gt;1\)</span> 级均匀量化，二进制信道传输误码率为<span class="math inline">\(P_e&lt;&lt;1\)</span>。那么信号平均功率为： <span class="math display">\[S=\frac {V^2} 3=\frac{(\Delta VL/2)^2}{3}\]</span> 量化噪声功率： <span class="math display">\[\sigma_q^2=\frac{\Delta V^2}{12}\]</span> 误码失真噪声功率和码型有关，以自然码为例，有： <span class="math display">\[\sigma_e^2=E\left\{n_e^2(t)\right\}=\sum_{i=1}^N P_e\left(2^{i-1} \Delta V\right)^2=P_e \Delta V^2 \frac{2^{2 N}-1}{3} \approx P_e \Delta V^2 \frac{2^{2 N}}{3}\]</span> 所以总输出信噪比为： <span class="math display">\[S N R_o=\frac{S}{\sigma_q^2+\sigma_e^2}=\frac{S}{S / 2^{2 N}+4 P_e S}=\frac{2^{2 N}}{1+4 P_e 2^{2 N}}\]</span></p><blockquote><p>【例（2022期末）】已知信号<span class="math inline">\(m(t)\)</span>最高频率4kHz，幅度范围为<span class="math inline">\((-5.12,5.12)V\)</span>，采取13折线A律编码进行数字化，求：</p><ol type="1"><li>采样值为-1.7V时的输出码组、输出量化电平、量化误差</li><li>输出码组为<code>11011001</code>时代表的量化电平值，写出与之对应的均匀量化11位码</li><li>输出速率<span class="math inline">\(R_b\)</span></li><li>使用64QAM传输的最小带宽</li></ol><p>【解】</p><ol type="1"><li><p>先把输入信号归一化： <span class="math display">\[\left[\frac{-1.7}{5.12}\times 2048\right]=-680\]</span> 符号位：<code>0</code></p><p>段落码：因为<span class="math inline">\(680\in (512,1024]\)</span>，所以是第七段，即<code>110</code></p><p>段内码： <span class="math display">\[\left[\frac{680-512}{32}\right]=5\]</span> 所以段内码为<code>0101</code></p><p>所以整个码组为<code>01100101</code></p><p>恢复出的电平为<span class="math inline">\(-[512+32(5+0.5)]=-688\)</span>，恢复成原始电平就是<span class="math inline">\(1.72V\)</span>，量化误差为<span class="math inline">\(0.02V\)</span></p></li><li><p>正数，段落码是第第六段（256~512），段内码为<span class="math inline">\(16\times 9.5=152\)</span>，所以对应成归一化量化电平为408，对应原始电平1.02V，对应的11位均匀量化为 <span class="math display">\[(408)_{10}=(00110011000)_2\]</span></p></li><li><p><span class="math inline">\(R_b=8f_s=64kbps\)</span></p></li><li><p>有： <span class="math display">\[R_s=\frac{R_b}{\log_{2}64}=10666.67baud\]</span> 所以带宽为<span class="math inline">\(10.67kHz\)</span></p></li></ol></blockquote><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>叠加在信号上的噪声。与此相对，乘性噪声是乘在信号上的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>各态历经的意思是统计平均等于时间平均，<span class="math inline">(E[x(t)]=x(t))</span>​。直观理解就是“一次性投100枚硬币”和“把一枚硬币投100次”是等效的。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>平稳的意思是概率密度函数和时间无关 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>高斯的意思是概率密度分布是高斯分布 <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>白噪声的意思是功率谱是常数 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>归一化的意思是当前值和最大值之比 <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230416-20230514）</title>
    <link href="/2023/05/14/%E5%91%A8%E8%AE%B0%EF%BC%8820230416-20230514%EF%BC%89/"/>
    <url>/2023/05/14/%E5%91%A8%E8%AE%B0%EF%BC%8820230416-20230514%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>周记（×）月记（√）懒狗是这样的（笑）</p><p>这段时间里，我去了模型展：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142222885.jpg" alt="模型" /><figcaption aria-hidden="true">模型</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142226128.jpg" alt="笨笨" /><figcaption aria-hidden="true">笨笨</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142226621.jpg" alt="赠品" /><figcaption aria-hidden="true">赠品</figcaption></figure><p>还去了航空博物馆，只不过洞库没开，遗憾</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142227673.jpg" alt="航空博物馆" /><figcaption aria-hidden="true">航空博物馆</figcaption></figure><p>看了四场北京国际电影节的电影，然后五一胡吃海喝了很多吃的。</p><p>看的电影有《MONDAYS/如果不让上司发现这个时间循环就无法结束》、《2001：太空漫游》、《大红灯笼高高挂》、《秋丰满月时》和《白色塑料天空》。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142232558.jpg" alt="白色塑料天空" /><figcaption aria-hidden="true">白色塑料天空</figcaption></figure><p>一个有点神秘的斯洛伐克动画片，不是很好看。打分66/100</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142233851.jpg" alt="MONDAYS" /><figcaption aria-hidden="true">MONDAYS</figcaption></figure><p>一个关于时间循环（废话）的日本讽刺喜剧电影，特别乐，很好看。里面有一些关于职场的讽刺，比如为了让上司知道时间循环了还要做个PPT汇报之类的。打分85/100。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142234407.jpg" alt="2001太空漫游" /><figcaption aria-hidden="true">2001太空漫游</figcaption></figure><p>神中神，不用多说了吧。在IMAX大屏幕上看那段光影跟磕了药一样。打分99/100。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142235769.jpg" alt="秋丰满月时" /><figcaption aria-hidden="true">秋丰满月时</figcaption></figure><p>一部蒙古国的电影，看到了一个沙尘暴以外的水草丰美的蒙古。小孩在假扮大人，大人在找回童真，有一种朦胧而平静的美，值得推荐。打分80/100。</p><p>我看完了《龙蛋》，现在在看《死在火星上》。</p><p>我写了自控、通信、信息论的笔记，过两天传到博客上。</p><p>科幻协会的申请通过了。</p><p>我给妈妈买了束花，挺好看的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202305142238136.jpg" alt="花" /><figcaption aria-hidden="true">花</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230403-20230416）</title>
    <link href="/2023/04/16/%E5%91%A8%E8%AE%B0%EF%BC%8820230403-20230416%EF%BC%89/"/>
    <url>/2023/04/16/%E5%91%A8%E8%AE%B0%EF%BC%8820230403-20230416%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>校历第七周和第八周，本学期已经过半，应当开始着手复习了。我这周末复习了信息论，之后应当开始通信原理和自控。</p><p>上周六，吃了叙利亚餐厅，比较不错，作为尝试异域风情来说是一个很不错的选择。这周末去了一个书展，图书市集，很有市集的感觉，买了三本书：一本哲学书、一本索何夫的科幻，一本不是科幻的短篇小说，希望能看完。</p><p>这周开始看《龙蛋》，且已经过半，下周能看完，然后把三本书一起还给图书馆，宿舍空间也就没那么紧张了。</p><p>这周买了新的iPad，很喜欢。</p><p>因为去书展所以错过了空之航路，非常遗憾。</p><p>这周进行了社团成立答辩，感觉某个评委的智能没有显著地高于查理·高登。</p><p>周日感冒了，晕，感觉是舍友传染的。</p><p>随感一：关于互联网主权。近期很多人在吹嘘chatGPT能带来第X次工业革命（这个工业革命先放在一边哈，一会儿是区块链，一会儿是元宇宙，一会儿是chatGPT，合着一年革命一次呗，先假设它有），因为chatGPT是美国做的，所以美国又赢麻了。这个逻辑是正确的吗？我想不是的。举个最简单的例子吧，互联网技术所带来的“第四次工业革命”（我仍然不认为这是工业革命，但是大家都这样说，那就这样说吧），谁发明的互联网呢？美国。但是从互联网崭露头角的1990s至今，美国的国际地位是提高了，还是降低了呢？<strong>我觉得凡是智力正常的人都不会觉得现在美国的国际地位比1990s还要高</strong>。巧合的是，互联网技术最终在2010s给中国的国际地位带来了巨大的提升，我想这个也是无可争议的。那么为什么美国引导了技术革命，国际地位反而出现了大幅度的下降呢？甚至再往前算，引领了无可争议的第一次工业革命的英国，难道是第一次工业革命的最大获益者，吗？</p><p>第一：因为美国没有对互联网技术进行强而有力的管控，于是导致了2020s美国社会的大撕裂，大分化，导致互联网变成彻彻底底的战场，导致不同意见的人民的分歧被无限拉伸，导致民粹横行，西方选票式民主制度的缺点被进一步放大，终于导致2023年美国已经处于了事实上的无人驾驶状态。反观中国，在1990s就对互联网进行了认真的管控和引导。最近美国也开始建“墙”了，我在群里说：“中国又领先了一个版本”，其实这话70%是开玩笑的而30%是认真的，在过去30年的互联网时代里，其实只有两个国家有互联网主权，那就是美国和中国。美国凭借的是一力降十会，而中国凭借的是组织术。现在的美国一力降不了十会了，怎么办呢？</p><p>第二：互联网技术的技术壁垒不高。其实从发电机和内燃机引领的第二次工业革命开始，所谓“工业革命”的技术壁垒是越来越低了。电力技术和内燃机技术，难道那个国家能独自甩掉其它国家突飞猛进吗？核裂变技术，一穷二白的中国，乃至被围追堵截的朝鲜伊朗，甚至当时的台湾伪政权，不都（至少是差点）搞出来了吗？互联网技术更是如此了。</p><p>那么我们回到chatGPT，以上两点对于chatGPT来说是更显著了，还是更微弱了呢？要知道，现在的美国已经处于事实上的无人驾驶状态了，马斯克等人甚至要联署暂停GPT的研发来给立法机构一个缓冲的时间。而与此同时，中国已经出台了人工智能管理办法（草案），而且中国的大模型也在雨后春笋般的冒出来，虽然质量上确实比不过人家，管理办法也有些争议，但是至少有个架子。有个架子就能发展，这是好的。</p><p>随感二：我发现部分人在观看《三体》的改编时，抱着一种叶哲泰和叶文雪是整个宇宙的邪恶势力的幕后总黑手的视角。什么意思呢？就是不看别的，先看这两位怎么死，死的越惨呢，对作品的评价就越高。越不死呢，对作品的评价就越低，很可笑不是吗？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304162342344.jpg" alt="叙利亚烤肉拼盘" /><figcaption aria-hidden="true">叙利亚烤肉拼盘</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304162342623.jpg" alt="是年的颜色，亦是生活的喜色" /><figcaption aria-hidden="true">是年的颜色，亦是生活的喜色</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304162343781.jpg" alt="叙利亚某某盘餐" /><figcaption aria-hidden="true">叙利亚某某盘餐</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304162343419.jpg" alt="正经事" /><figcaption aria-hidden="true">正经事</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304162343784.jpg" alt="图书集市" /><figcaption aria-hidden="true">图书集市</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304162343276.jpg" alt="图书集市" /><figcaption aria-hidden="true">图书集市</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记(20230320-20230402)</title>
    <link href="/2023/04/05/%E5%91%A8%E8%AE%B0%EF%BC%8820230320-20230402%EF%BC%89/"/>
    <url>/2023/04/05/%E5%91%A8%E8%AE%B0%EF%BC%8820230320-20230402%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这是本学期的第五周和第六周。通信原理还是一如既往的难，信息论和自控就那样，微机原理算是比较轻松的。在这两周里，我组织了一场《宇宙探索编辑部》的包场观影活动。</p><p>这场电影是4月1日星期六上映的，既然要包场，应该就是当天看了。我在前一周的周五（也就是3月24日）在科幻协会发了一个问卷来征集想要来一起看的人，大概是这样的：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051029604.png" alt="时间调研问卷" /><figcaption aria-hidden="true">时间调研问卷</figcaption></figure><p>截止到3月26日收集到了20份问卷，而且增长的速度已经开始放缓了。26日晚上，我联系了光影星空电影协会，希望和他们一起来看，然后把问卷发到了他们的群里，结果响应的人很多，问卷的数量迅速达到了90份，于是我准备联系包场工作。考虑到《调研问卷》中沙河和学院路的一样多，所以我选了离沙河和学院路一样近的回龙观影院（后来发现，这个影院离地铁站有点远）。我通过猫眼找到了影院的电话，然后打电话加上了他们经理的微信。3月27日上午，我询问了经理包场的情况，给出的报价是50元一人（赠送爆米花可乐）。我个人认为这个价格是合理的，于是简单地征集了一下同学们的意见以后就和经理确认了。通过沟通，我发现影院那边包场的人数以70为一个分界点，来决定放映厅的大小，于是我需要一份参与人员的准确名单，为了得到这份名单，我又发了份问卷：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051034998.png" alt="名单统计问卷" /><figcaption aria-hidden="true">名单统计问卷</figcaption></figure><p>在周一，我感觉要给大家制作一点纪念品，于是自己设计了一版纪念影票，然后拿去印刷，最终选择了300g铜版纸工艺，效果还算可以，花了190块钱，因为找的是北京的商家。如果影票能提前制作，那么花的钱会远少于190元。</p><p>最终在周三下午（影院排片的DDL）前，收集了66份问卷。在这期间，我基本每天往群（观影群、科幻协会群和光影星空群）里发两次链接。然后把名单报给影院，微信转账付款，然后我再开始收款工作。收款就是在群里发个公告，里面是我的收款码，到了当天了还没交钱的我会去通过手机号码私聊他们确认是不来了还是忘了交钱。</p><p>因为选座是先到先得的方式，我当天提前1小时到达影院的时候，发现已经有人在等了。然后就是签到进场，这没有什么好说的了。因为我在纪念影票上放了二维码，所以也从光影星空给科幻协会拉了一拨人，</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051043970.jpg" alt="合影" /><figcaption aria-hidden="true">合影</figcaption></figure><p>观影结束之后，我还发起了一个影评征集活动。不过活动还在进行，所以也没法多写什么。</p><p>在3月25、26日，我和朋友去秦皇岛玩了，还是挺好玩的，参观了一个叫做“猫的天空之城”的书店，吃了烤肉和大馅饺子，相当的好吃。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051106231.jpg" alt="北戴河" /><figcaption aria-hidden="true">北戴河</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051107632.jpg" alt="大风机关" /><figcaption aria-hidden="true">大风机关</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051107159.jpg" alt="长城" /><figcaption aria-hidden="true">长城</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202304051107285.jpg" alt="落日" /><figcaption aria-hidden="true">落日</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230313-20230319）</title>
    <link href="/2023/03/20/%E5%91%A8%E8%AE%B0%EF%BC%8820230313-20230319%EF%BC%89/"/>
    <url>/2023/03/20/%E5%91%A8%E8%AE%B0%EF%BC%8820230313-20230319%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第四周，没有发生什么特别值得记录的事情。本周我在新媒体学院进行了社团的成立答辩，顺利通过，然后拿到了学院的盖章，并且把材料提交给了团委。然后周末的时候我爸来北京出差了，我带他转了转校园，又在颐和园玩了玩，还住了就在我学校旁边的四星级宾馆。另外，这周末有百团大战，我买了两个新飞梦姬钥匙扣。</p><p>我这周看了科幻世界2023的增刊（历史科幻特辑），这个题材还是相当有意思的，假设历史的另一条走向。有诗云：“折戟沉沙铁未销，自将磨洗认前朝。东风不与周郎便，铜雀春深锁二乔”。也不知道如果11年前的昨天“东风不与周郎便”了，历史会如何发展呢（笑）</p><p>我想了几个科幻协会能在百团玩的摊位游戏，感觉还挺有趣的，但我现在不能把它们写下来。</p><p>这周我还参加了七圣召唤比赛，两胜两负。</p><p>对了，还有一件值得高兴的事情：奖学金的证书到了。奖学金真是个好东西：申请的时候高兴一遍、发钱的时候高兴一遍、发奖状的时候又高兴一遍，一奖三吃，太赚了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303202254108.jpg" alt="奖学金证书" /><figcaption aria-hidden="true">奖学金证书</figcaption></figure><p>我得过学习优秀、社会工作、社会实践、志愿公益、创新创业、学科竞赛的奖学金。文艺优胜这学期可以冲击一下，优秀运动员真的得不来。</p><p>这周塞凡的数字生命卡出了点瓜，我想从两方面评论一下这件事。</p><p>首先，就事论事。从小圈子破圈就是这样的。以前定制几十几百个的时候，临时换换材料啊，英文单词打错了这种事情，可能大家都是圈内人，打个哈哈也就过去了。但是现在不一样了，现在这是一个亿的大生意，你的客户大部分都不是“圈内人”，不能再用小圈子小作坊心态考虑问题了。这是从小圈子发展壮大的必经之路。</p><p>当然，还有一条路，那就是直接从圈外开始。比如流浪地球2拍摄的时候，直接用徐工、中建管理工厂工地的方法来管理片场，那属于降维打击。</p><p>但是你要从“圈”里“破”出去，那这样的失误就是很容易发生的。要破圈就得经历波折，希望我国的影视行业能吸取经验教训，走好将来在全世界“破圈”之路。</p><p>然后，发散一下。这件事进一步完善了《流浪地球2》的艺术价值，使这部电影升格为了真正的meta movie。赛凡的偷工减料，正暗示了影片中“数字生命计划”最大的缺陷：“没有实体你数字个屁”。互联网上有很多人支持数字生命计划，但是这件事让大家看到这个计划根本站不住脚。试想一下，图恒宇已经14年没有用过丫丫的卡了，如果这个卡是赛凡做的，等图恒宇摸进550W的机房，然后企图把丫丫导入进去时，首先数字生命卡的底座一按就碎了，然后他好不容易把卡插进去，发现用的是USB2.0，传输数据需要24天，那就尴尬了，哈哈。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230306-20230312）</title>
    <link href="/2023/03/12/%E5%91%A8%E8%AE%B0%EF%BC%8820230306-20230312%EF%BC%89/"/>
    <url>/2023/03/12/%E5%91%A8%E8%AE%B0%EF%BC%8820230306-20230312%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第三周，基本上各种生活已经步入正轨了。在学业方面，可以看出上学期的成绩还是比较显著的，保研应该是不太有悬念的，但是清华还是有点够不上，有点遗憾。这学期的课程里，《通信原理》尤其地难，难得头疼。</p><p>读书方面，在读《火星编年史》，是一本雷·布拉德伯里的科幻小说。说是科幻，其实科幻要素并不是很多，只有一个火星。但是故事写得很有意思，有点点恐怖诡异的感觉，而且很明显能看出来是讽刺，我的评价是也是一部电波作。另外这本书的体裁也比较有趣，它的本质是一本短篇小说集，也就是故事与故事之间还是比较独立的，但是又有一个时间线和共同的世界观，所以才叫《火星编年史》。接下来准备读一读克拉克的其它短篇小说，我在北航的图书馆借了一本。而且我看了两篇最前面的，那是克拉克在21岁的时候写的，发的杂志也不是什么特别知名的杂志，内容就是人们发射火箭前往火星。对于1938年的克拉克来说，发射火箭还是一件遥不可及的幻梦，但是仅仅31年以后，人们就真的乘坐火箭登上了月球，那时的克拉克也只有五十来岁，正值壮年。说到这里我是真的羡慕他啊，亲眼看见自己的幻想变成现实的感觉。作为一个科幻作家，亲身体验了“技术爆炸”，真是...太羡慕了。</p><p>这周我体验了一下AI画图，并且给我的科幻社团画了几张画。不得不说这玩意还是挺好用的。现在互联网上有很多关于AI画图的争论，我也来表达一下我的见解。在我看来，AI画图之于图画创作领域，正如智能拼音输入法之于文学创作领域。什么意思呢？在智能语音输入法出现以前，文学创作只能拿笔去写，于是门槛很高，起码你得有耐心和恒心把自己脑子里的作品用笔一笔一划地写下来。如果拿给别人看，别人可能注重的也是你的字写得好不好，而不是文章的内容写得好不好。这种门槛是必要的吗？是否一定要有手写大篇幅文字的功力才能创作文章呢？我看不一定吧，最简单的例子就是刘慈欣，他的字写得并不是非常好，但是他写的文章就是非常好。AI画图也一样，我给电脑输入一些我脑子里面想象出的文字，电脑就能给我转换成图像，而如果约一个稿子的话可能得几千块钱。那么这个图像是我画的吗？当然不是我画的了。就像你指着一篇打印出来的文件问：“这些字是你写的吗？“我也只能回答：“这些字不是我写的，而是机器打印出来的。”那么这篇文章里我做了什么？答案是：我提供了想法和创意。智能拼音输入法能让我在写文章时不再纠结于一撇一捺的位置和大小，AI画图也让我在创作图画时不再纠结于笔触和线条。我在这里放几幅我觉得质量中上的AI作品，质量上上的我要留给科幻协会用。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303122256339.png" alt="宇宙飞船在星海中遨游，画面较暗" /><figcaption aria-hidden="true">宇宙飞船在星海中遨游，画面较暗</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303122256476.png" alt="宇宙飞船、星空、宇宙、画面较暗" /><figcaption aria-hidden="true">宇宙飞船、星空、宇宙、画面较暗</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303122258616.png" alt="巨大的运载火箭在傍晚发射，天边有气态巨行星" /><figcaption aria-hidden="true">巨大的运载火箭在傍晚发射，天边有气态巨行星</figcaption></figure><p>这周我还去清华玩了。感受是：清华的校园比你航的漂亮，但也比你航的大；清华的教学楼比你航的好看，但也比你航的麻烦；清华的食堂比你航的多，但是不如你航的好吃；清华的图书馆比你航的多，也比你航的漂亮，还比你航的质量高。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303122259186.jpg" alt="人文学院图书馆" /><figcaption aria-hidden="true">人文学院图书馆</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303122300201.jpg" alt="路牌" /><figcaption aria-hidden="true">路牌</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202303122300929.jpg" alt="烧鸟丼" /><figcaption aria-hidden="true">烧鸟丼</figcaption></figure><p>这个烧鸟丼我要着重提一下。烧鸟本身还不错的，烤的焦焦脆脆。酱汁一般般，是很普通的酱汁。配菜难吃得要死，坚硬得让我以为我在吃塑料。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230220-20230226）</title>
    <link href="/2023/02/26/%E5%91%A8%E8%AE%B0%EF%BC%8820230220-20230226%EF%BC%89/"/>
    <url>/2023/02/26/%E5%91%A8%E8%AE%B0%EF%BC%8820230220-20230226%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第一周，万象更新，生机勃勃，万类竞发。我且看几个周以后会不会再次变成我的“葬身之地”（笑）</p><p>本学期的主要课程有通信原理、嵌入式、图像信号处理、信息论、自动控制原理。</p><p>本来我的体育课掉了，于是只能在社会性死亡（芭蕾形体）和肉体性死亡（人体工程）中二选一，我选了人体工程。但是当我去上人体工程课时，慧眼识人的老师发现了我并不可能顺利完成课程，于是找到体育部的老师帮我换了课，换成了篮球，哈哈。</p><p>奥体中心，本来是我在北航学院路呆了两年都没去过的地方，在这短短的一（两）周里，却去了三次。吃了萨莉亚、看了数字北京中心（流浪地球2中的北京根服务器地址）和党史馆影城里的门框机器人。</p><p>这周五去国贸吃了个云南菜，排了158分钟队，结果菜品并不对得起这158分钟。虽然菜不是依托答辩吧，为此排158分钟属于是有点过分了。菜比较普通，属于那种价格打个七折，开在大运村楼底下，我每学期说不定会想起来去吃一次的程度。我决定在一学期以内不再吃需要排队超过30分钟的餐厅。</p><p>这周科幻协会的注册正在有序进行，我也不多在这里多说什么了。在我心中，新科幻协会和老科幻协会的关系有点类似于唐朝和汉朝的关系：它们都是“中华帝国”、“华夏文明”，但是并不是复辟与被复辟的关系，倒是有点“折戟沉沙铁未销，自将磨洗认前朝”的感觉。为什么呢？因为老科幻协会断代时间太长了，已经不存在什么连续性了。我尝试和郭帆导演要了一份寄语，而且信息发出去才发现打错字了，也不知道他会不会给我。</p><p>说到底，我参与社团活动是为了得到什么呢？是综测加分吗？我想不是的，而且在交接的时候我一定要把这个事情非常明确地给下一届学弟学妹讲清楚：“你参加社团活动，参加社团管理，不能给你带来综测加分、不能丰厚你的简历、不能给你增加太多志愿时长、不能给你凭空增加博雅、不能让你赚到金钱、不能给你增加奖学金。如果你需要综测加分，性价比最高的是去当小班委；如果你需要丰厚简历，最好去搞科研；如果你需要志愿时长，最好去做线上志愿；如果你需要博雅——这是最容易的——你在群里见码就扫就行了；如果你需要奖学金，最好的方法是全身心去学习。社团活动、社团管理的性质，完完全全的，百分之一百的，不打折扣的，是‘玩’，是和你打游戏、看电影同样性质的行为，不要给自己任何的催眠，说我做这件事是有巨大意义的，就是玩。”</p><p>早在两年前我就说过，在我看来，不只是社团活动，在北航，所有的学生工作，你能得到的实际回报都是可以忽略的。所有的学生工作，总结起来四个字：为爱发电。你喜欢拍照片就可以做摄影，喜欢和人聊天就可以做记者，喜欢做平面设计就去做海报，只有因为喜欢所以去做，你才能得到所谓的满足感。</p><p>那我去做社长是因为我喜欢什么？答案是我喜欢科幻，与此同时尝叹息痛恨于北航没有自己的科幻组织，流浪地球路演竟然漏掉了某所航空航天大学。好吧，既然两年了都没有人来搞，那我就自己来吧。至于做社长所必须要做的社交、签字盖章等等工作，我坦诚的说，我很不喜欢。但是为了最根本的目的，我必须得把它做好。你不能因为这个而说我喜欢社交，这是不合逻辑的。就像我因为我喜欢数学所以学了数学二学位，每周末去沙河上课，你就此说我喜欢每周末跑沙河吗？我喜欢玩游戏所以我花钱买了游戏，所以说我喜欢花钱？没这个道理的嘛，“社交”、“每周跑沙河”、“花钱”都是我为了好玩的事情：“科幻”、“数学”、“玩游戏”所必须要经历的苦难罢了。</p><p>这周npy感觉进度有点急了，我有点不是很舒服，总之先试着提一提吧，慢慢调整。</p><p>我看了《与罗摩相会》、《日暮》、和阿西莫夫机器人短篇小说集的一部分，都挺有意思的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302262352652.jpg" alt="北京根服务器" /><figcaption aria-hidden="true">北京根服务器</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302262352403.jpg" alt="排队吃云南菜的人" /><figcaption aria-hidden="true">排队吃云南菜的人</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302262352420.jpg" alt="我到游乐园要先吃甜筒" /><figcaption aria-hidden="true">我到游乐园要先吃甜筒</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302262352376.jpg" alt="刘培强，图恒宇：我什么时候说过这话" /><figcaption aria-hidden="true">刘培强，图恒宇：我什么时候说过这话</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230119-20230212）</title>
    <link href="/2023/02/13/%E5%91%A8%E8%AE%B0%EF%BC%8820230119-20230212%EF%BC%89/"/>
    <url>/2023/02/13/%E5%91%A8%E8%AE%B0%EF%BC%8820230119-20230212%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>说是周记，快成月记了，这是因为假期懒了。我现在已经回到北京了，但是寒假还有一个周，所以现在作寒假总结还为时过早。但是现在既然已经把编辑器打开了，还是得写点东西的。</p><p>小说写完了，题目是《最美好的前途》，这是一首苏联歌的名字。这篇小说和我写的第一篇《凉宫春日的抉择》一样，也是同人科幻文。写作灵感是和群友聊天时无意间想到的：如果魔法少女们拥有了相对靠谱一点的组织力会怎么样。但是其实我并没有办法回答这个问题，因为这个问题太难回答了，首先得对目前的社会有深刻认知，而且还得考虑清楚实力对比。例如：人类会不会成规模地迫害魔法少女？魔法少女能不能顶住迫害？会不会产生母系氏族军阀？那殖民外太空也不用考虑什么维生系统了，飞船运灵魂宝石和机器人到地方再克隆个肉体呗？这是不是某种机械飞升？......所以我只写了一个小切面，而且还是这个组织将形成而未形成时，正如函数 <span class="math inline">\(y=e^x\)</span>在<span class="math inline">\(x=1\)</span> 时一样，看似平静实则马上就会指数爆炸。其实全文的重点是第六章，但是前五章和第六章的衔接不够流畅，这是一个问题。</p><p>关于科幻，这个寒假和很多波人看了很多遍流浪地球2。毫无疑问地，《流浪地球2》取得了很大的成功，《三体》电视剧同样取得了不小的成功，这也让我对我前一篇周记中提出了“利用刘慈欣科幻宇宙抢夺先进文化的前进方向”有了进一步的信心。当下世界电影市场、尤其是好莱坞，我说一句疲软应该不过分，是时候了，加油啊！我很开心地发现《球状闪电》和《全频带阻塞干扰》的计划已经提上日程了，这很好，因为这两部的科幻大场面并不多，现实主义的描写占了绝大多数，对特效技术的要求不是非常高，这说明上面是有高人的，我很开心。2035年，随着《三体》电影的上映和巨大成功，中国将正式成为世界先进文化的引领者。</p><p>关于科幻，我寒假阅读了一本刘慈欣的科幻评论集、一本《阿尔吉侬的花束》，都是非常值得阅读的书目。刘慈欣的那本书展现了它的科幻观念，并对“我们为什么要读科幻”，“科幻的重点是科还是幻”，“科幻和科普是什么关系”，“如何看待科幻的硬伤”这种群里的日经问题作出了一些系统的解答，还是比较能说服人的。《献给阿尔吉侬的花束》讲的是一个痴呆患者接受了某种手术，智商开始飙升，直到远远超过常人。但是变成天才的他进行科研时又发现自己的这个手术有一种副作用，就是他的智商很快就会跌落到以前的水平，于是他更加勤奋地工作试图阻止这个过程但是终究没有成功。这可能是一篇“软科幻”，但是也是很好的作品。</p><p>关于科幻，我这里有一些待办事项，不一定要不要做，但是怕忘了，还是写在这里</p><ul><li><p>毕业前成功投一篇《科幻世界》</p></li><li><p>筹备组建一下北航科幻同好会</p><p>我觉得这太他妈的离谱了，我操，咱就是说啊，2016年的银河奖颁奖典礼是在北航举行的，说明那时候北航至少应该有个管科幻的组织，然后我2019年入学的时候就完全没见到，直到2022年了也没有出现，这是为什么？？这就像是，我观察到一个文明，前一天还在太阳上盖戴森球呢，一觉醒来，身销道陨了，啥都没了，这什么情况？撞大过滤器上了？那飞梦怎么没撞大过滤器上？过滤器只给科幻社团设的？</p><p>不管了，即使有大过滤器，到时候我也毕业了，相信后人的智慧。</p><p>总之它首先应当以飞梦的一个分群或分部的形式存在，先慢慢发展着，在我还能说得上话的时候原则上我个人是反对它独立的，原因很简单那就是我对飞梦有感情。但是我不准备在什么《科幻分部管理办法》啊，《科幻分群总纲》啊之类的文件上设什么限制，还是那句话：相信后人的智慧。</p><p>关于一个社团，我想核心是一点：我为什么要来参加你的活动？我的答案是：凝聚力。具体怎么做呢？有两点。</p><p>第一点：要在社团中形成一个互为好朋友的团体。这里的好朋友不只是因为相同的兴趣，而是要在生活中的方方面面成为真正的好朋友。这样就给“参与社团活动”赋予了“和朋友一起参与活动”的社交属性。</p><p>第二点：要维持社团主题。这个意思就是对于小规模的社团，尤其是初创社团，一定要坚定地维持社团讨论的核心主题，避免其成为互为好朋友的团体的腐败组织。我曾经参与过一个叫做《北航发射同盟》的航天同好会，它成功进行了第一点但是没有完成这一点，于是现在里面全是xc话题或者生活话题，真正和航天有关的内容并不多。</p></li><li><p>多读书吧，不仅要读科幻的书也要读创作的书，因为是带了目的（创作）的读书，所以要做笔记。</p></li></ul><p>这个寒假我去重庆玩了，重庆是一个挺好的地方，吃的也好吃，景色也好看。</p><ul><li><p>第一个印象：硕大无朋，不是说“重庆市”这个政区占地面积大，而是当你站在嘉陵江和长江的交汇口，看三片陆地上鳞次栉比的巨大建筑物环绕着你时，有一种排山倒海的压迫感。而且重庆的老破居民楼也非常大，可以说是“老破大”了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302132357825.jpg" alt="洗衣机管子" /><figcaption aria-hidden="true">洗衣机管子</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302132358977.jpg" alt="来福士" /><figcaption aria-hidden="true">来福士</figcaption></figure></li><li><p>第二个印象：人行道窄。我有点不明白，这是不是规划中的失误。重庆大剧院和洪崖洞这种顶流景点附近的人行道只能并排走四个人，这合理吗？</p></li><li><p>第三个印象：热情奔放。第一点：无论是什么人，酒店前台，小摊贩，出租车司机，都是默认讲方言的，很有乡土气息。第二点：出租车开得和飞一样，在那种盘山的公路像过山车。</p></li><li><p>第四个印象：地势崎岖，有玩开放世界游戏的快感。举个例子，有一天我们从洪崖洞打了个车到解放碑，但是第二天我就发现从洪崖洞步行到解放碑只有十分钟，那时我就有一种游戏里地图被打开了的快乐。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302132358274.jpg" alt="轻轨穿楼" /><figcaption aria-hidden="true">轻轨穿楼</figcaption></figure></li></ul><p>看了个剧，开心麻花的《恋爱吧！人类》，非常一般，有点差劲了。这告诉我们一个创作者的“代表作”和“平庸作”之间的差距有多大。</p><p>在大年三十和元宵节，家附近的公园举办了花火大会，非常好看，人也很多。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302132357105.jpg" alt="花火大会" /><figcaption aria-hidden="true">花火大会</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202302132358952.jpg" alt="花火大会2" /><figcaption aria-hidden="true">花火大会2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最美好的前途</title>
    <link href="/2023/02/02/%E5%B9%A1%E7%84%B6%E6%82%94%E6%82%9F%EF%BC%88%E6%9A%82%E5%AE%9A%EF%BC%89/"/>
    <url>/2023/02/02/%E5%B9%A1%E7%84%B6%E6%82%94%E6%82%9F%EF%BC%88%E6%9A%82%E5%AE%9A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>自己写的软科幻小说，献丑献丑，这两天持续连载。</p><span id="more"></span><h2 id="第一节-失踪">第一节 失踪</h2><p>刺耳的警报声从耳机里传出，宪贞才从神游中惊醒。不用说，他又在想那些十几年前的怪事了。</p><p>十几年前，庆田宪贞还是一个意气风发的少年，一切都是那么地幸福，少年和少女一起逛灯会，一起共进晚餐，每晚在电话里互诉衷肠，还有青涩的第一次拥抱和初吻.....她发色鲜红，热烈奔放，是火一样的少女。一切都那么地美好，直到宪贞的一场车祸夺走了这一切。一开始，宪贞几乎就要死掉了。可是经过抢救，宪贞竟然基本痊愈了，连主刀的老教授也只能感叹一声医学奇迹。但是，自此之后，她就消失了，就只留下了一张纸条，上面写着“对不起”，而另一面则写着“别来找我”。</p><p>一开始宪贞被愤怒冲昏了头脑，但过了两个月就被疑惑取代。如果只是因为担心车祸后的我拖累自己于是离开也就算了，直接人间蒸发是闹哪样呢？在这两个月里，宪贞问遍了朋友、家人、同学、老师，甚至警察，但是都没有得到任何回答。</p><p>时间在滚滚向前，像一把利刃一样切开了一切。十几年前迷梦也在慢慢地成为过眼云烟。其信然耶？其梦耶？宪贞有时也有些恍惚。不过宪贞毕业以后就进入了警局，做到了分管失踪人口的小队长，这是千真万确的。</p><p>宪贞看了一眼电脑，是紧急警务通告。</p><p>科技发达的现在，一般的事件并不会被推上宪贞的案头。先不说还在试运行的AI追查系统，单单是遍布全城的天眼，找回几个偷偷从后门溜进黑网吧的高中生也不是什么难事。于是宪贞这个小队长的工作，渐渐也从全城到处开着车巡逻，变成了坐在办公室里敲敲键盘鼠标。上周宪贞他们所接了一个幼儿坠楼的警，不过等人到了以后黄花菜都凉了。而像这样发紧急通告的，一年满打满算在这座城市也就两三起。</p><p>这是一个人鱼纪念中学女生的失踪案，孩子名叫星奈花，成绩平平，但也算得上乖巧，只是最近一个月放学回家越来越晚，直到有一天放学后再也没回来，父母吓得直接报了警。</p><p>宪贞心里一紧，他也知道现在科技的强大，而如果连科技也找不到的人，用人力找无异于大海捞针，更别说最新的AI追查系统只有在面对失踪几年乃至十几年的对象，才会表现出明显优势。</p><p>宪贞操作天眼查询这个女孩子的行踪，发现在失踪那天，她放学后直接去了一家咖啡店，自己一人进了包间，然后不知所踪，记录就此消失。宪贞到了咖啡店，一边问老板有没有注意到有人只进来了却没出去。老板被问得一头雾水，回应说店里人来人往，实在难以注意。那么，有人没付账走了么？宪贞又问。“没有啊，现在都是扫码点单了，哪还有没付账一说。”老板回答。宪贞道了谢，转身离开了咖啡厅。</p><p>说来也奇怪，宪贞自从当上了小队长以后，只遇到过三起能被摆上案头的失踪案件，其中一件顺利解决了，而另一件的线索，恰恰也是在这间咖啡厅断掉的。有一瞬间，宪贞怀疑这个咖啡厅可能大有问题，但转念一想，这里是离中学区最近的咖啡厅之一，学生想谈谈事情，大多也会选择这里，人流量相当大，几乎成了学校的第二食堂：从概率论的角度来说，似乎并不足以判定咖啡厅就是有问题。</p><p>宪贞坐上车，输入了失踪少女的家的位置。少女的家坐落在一片老旧小区里，宪贞把警车停到巷口，一个人挤进昏暗而狭窄的小巷，找到了少女的家。</p><p>按响门铃，开门的是一对夫妻，年纪不轻，估摸着有四五十岁了。男主人头上有了些许银点，而女主人则一直是担忧而后悔的表情。他们的衣服虽说整洁，但也略有发白，看样子经历过的年岁不少。打眼一看，就知道他们是最典型的工薪家庭，有些收入，但也绝供不起挥霍浪费。客厅没有墙纸，一面墙上贴着几张奖状。勤勤恳恳的普通父母，拖拽着家庭走在还算有希望的道路上——本来应该是这样的。</p><p>“啊，是庆田警官吧，请进请进”。父亲先开了口，把宪贞迎进了客厅，还给他倒了一杯茶水。</p><p>“三天以前，她就和往常一样出去上学，再也没回来过。”女主人垂着头说道。宪贞拿出笔记本假装做起了笔记，但实际上，这句话已经在案卷中被他看了不下十遍了。</p><p>“当天她有什么异样呢？有闹情绪之类的吗？”宪贞追问道。</p><p>“没有啊，就是和往常一样出门，然后就没有回来了。”女主人低声答道，男主人接起了话茬：“说到异样，最近一个月里她确实有时候很晚回来，有时候夜不归宿。问她去干什么了，基本都是说和同学一起玩游戏去了。我给她同学打电话，也确实得到了相同的回答，说是在玩最近很火的那个什么《圆神》。我们寻思着玩游戏不算什么大事，只要把学习搞好，平时放松一下也不是不行，就没有细问。”</p><p>“但是上周开始女儿身上有时候开始出现了伤痕，也不大，问就说是磕了碰了，不要紧。而且第二天起来就好了，我们也就没细问。谁知道……哎！”</p><p>“不都是怪你不操心吗！女儿只有这一个月成天不回来，你就光打打电话就算完事了？你怎么就不知道拦一下……现在可好！都是你的错！”女主人突然站起来，边哭边捶打着男主人。宪贞拉开他俩，坐定以后，又确认了她的学校，班级之后，留下联系方式便离去了。</p><p>宪贞坐进车里，整理了一下思绪。好吧，至少出现了一点点有意思的线索，也就是那些伤痕。女孩身上出现不大的伤痕，那么女孩是不是有一个崇尚暴力的男朋友呢？然后女孩害怕父母反对，总之就是和男友私奔了。多半是被高年级的海王骗了吧！这个傻女子。“小度，去人鱼中学！”宪贞下了决定。</p><p>正在为您规划路线，预计时间十分钟。</p><p>挺近的，估计为这房子也花了不少钱，宪贞心想。人鱼纪念中学是当地相当有名的升学高中，坊间向来有踏进人鱼就等于半只脚踏进名牌大学的说法，学费不高，而且从来只看考试成绩录取，交钱不顶用，市长批条子也不顶用。至于这个诡异的名字，据说是赞助商的癖好吧。宪贞查了查赞助商，叫佐仓基金会，而其主要投资人也姓佐仓，是当地一家科技企业：美冬科技的总裁。</p><p>人鱼中学最近安装了“学生大数据系统”，是全国十所试点的中学之一。学生大数据系统已经在大学全面铺开了，在中学还只在试点阶段。它除了能记录学生的姓名、班级、成绩、奖惩等基本信息以外，还可以针对成绩下滑严重、沉迷网络游戏、迟到早退、上课打瞌睡的同学作出预警，甚至可以通过学生们在食堂、浴室、图书馆等地的刷卡签到进行大数据聚类分析，形成学生们的关系图谱。虽然这系统在刚刚推行时引起了很大的关于隐私方面的争议，但它也做到了校内各种资源的整合，带来了很大的生活便利，再加上试点的学校也不多，大家久而久之也就默认它的存在了。</p><p>宪贞调取了星奈花的大数据，所有警告项目前面都是一个绿色的对勾，也不知道是幸运还是不幸。只有沉迷网络游戏和上课打瞌睡这两项数值最近有增长趋势，印证了父母的证词，但增长缓慢，数值也不高，还没到触发警报的程度。接下来就是分析关系图谱了。如果最近有很强的关系形成，甚至是恋爱关系，那么就可以沿着“暴力海王”的思路继续追查了。</p><p>宪贞把关系图谱的数据下载下来，导入警方专用的绘图软件中，输入密码后，便生成了可视化的动态关系图谱。计算显示，她最近在和人恋爱的概率不超过2%——不管是男的还是女的。星奈花在一个月前的社交圈子很稳定，在一个月之内的社交圈子也很稳定。更蹊跷的是，这两个圈子似乎很不一样。</p><p>宪贞把图谱保存下来，又问了星奈花的朋友，也没有得到什么异样的回答，她最近既没有闹情绪，也没有和之前的圈子决裂，总之一切看起来都很正常，除了上课有些打不起精神以外。至于第二个圈子，显得也很正常，只是里面的同学都在玩《圆神》，这看起来就像是星奈花游戏刚入坑，找“大佬”带一样。宪贞问完以后，就离开了人鱼中学。</p><h2 id="第二节-圆神">第二节 圆神</h2><p>“哎哟我真是草了，怎么又摊上这档子事。”回到办公室的宪贞刚坐到椅子上就开始头大。他整理了一下目前能确定的疑点，首先就是莫名其妙又能迅速痊愈的伤痕，第二个疑点就是一个月前社交圈子的变动。宪贞抱怨道：“真是邪乎到家了！打个游戏能打出伤来，还能把人打没了？我倒要看看这个‘圆神’是个什么东西！”</p><p>同事听到了宪贞的话，便随口接道：“圆神你都不知道？恁游戏最近红得发紫了都，那个开发商，美冬（Mifuyu）科技，以前还名不见经传的，好像是做快递的，去年发布了圆神，一跃成为了咱们市的重点企业嘞”，同事打了两下键盘，“诺，美冬科技，光它的增长就占了咱市去年经济增长总量的25%！纳税大户，好得很呐。你要想入坑可以加下我好友，我回头带你哈~”</p><p>宪贞下班后，并没有像往常一样去居酒屋，而是直接向自己的公寓奔去。“550W啊，帮我搜一下这个圆神”，宪贞对他的智能音箱说道。</p><p>好的，正在为您搜索相关信息：</p><blockquote><p>《圆神》是由美冬科技（Mifuyu）自主开发的一款全新开放世界VR冒险游戏。游戏发生在一个被称作“银之庭”的幻想世界，在这里，被神选中的人将被授予“灵魂宝石”，导引魔法之力。玩家将扮演一位名为“魔法少女”的神秘角色，在自由的旅行中邂逅性格各异、能力独特的少女同伴们，和她们一起击败魔女，找回失散的亲人——同时，逐步发掘“灵魂”的真相。</p><p>——维基百科</p></blockquote><p>“那你能给我下一个么？”，宪贞心想，我倒要看看这游戏有什么魔力。</p><p>“下载完成，请戴上眼镜，进入VR游戏室体验游戏”智能音箱提示道。宪贞带上眼镜，走上跑步机，系上安全带后，进入了《圆神》的世界。</p><p>首先映入宪贞眼帘的是游戏的登录界面，一座在云上的城市，道路上铺满了略显突兀的鲜花，一位没有面目的白衣女神从天上驾着马车降下，粉色的长发延伸到屏幕之外，似乎有无限长。待游戏加载完成后，这位女神来到他的面前，他点击进入了游戏。</p><p>游戏一开始，黄色卷发的loli麻美（宪贞控制的主角）和父母一起乘车郊游，忽然不知道从哪儿窜出来一辆大货车，向主角一行人的车径直撞过去。主角的父母当场去世，主角的视角也在慢慢变成深红色。正当视野即将变成全黑色时，不知道从哪儿窜出来一只明亮的白色生物。从某种意义上来说，这个生物体态和猫有点类似。但是它的嘴是“<span class="math inline">\(\omega\)</span>”形，有两大片从白色到粉红色的，像头巾一样的结构从耳朵中冒出来，而它的尾巴也比猫大得多。</p><p>这个生物说话了，却没有开口：“和我签订契约，成为魔法少女吧！麻美，你的愿望是什么？”</p><p>“请，请让我活下去。”屏幕上只有这一个选项。</p><p>“好了，接受它吧，这就是你的命运。”白色生物的“头巾”伸长并且插入了麻美的胸口。麻美的视野恢复了正常，并发现眼前有一个闪着金黄色光芒的宝石。</p><p>伸手摘下了这颗宝石，游戏正式开始了。</p><p>麻美活了下来，她的父母却没有这么幸运。</p><p>她在白色生物的引导下慢慢往家所在的小城走去。小城的风格是三十年前的画风，看起来有些古朴的质感。一路上，麻美和白色生物边走边聊。白色生物说自己叫做“丘比”，和著名的沙拉酱同名，自己的使命就是来拯救处于危难或彷徨中的少女们，实现她们的愿望并带领她们适应新的生活。</p><p>快到城市时，宪贞看到了一个奇怪的生物。在写实画风的游戏中，这个生物却像是从纸上剪下来直接贴在视野里的一样。而且画风相当潦草，边缘还在不停地抖动。这时，丘比说话了：“轻轻地念‘变身’，然后跟着那个生物。”</p><p>宪贞用只有自己和麦克风能听到的声音轻轻地念了一声“变身”，手中的黄色宝石飞了出去，闪烁着金色的光芒。麻美身上的便服也变成了一身华丽的衣装，手中拿着一柄短剑，身边还漂浮着明黄色的缎带。麻美放轻脚步，慢慢地跟着那个神秘的生物。尽管城市中道路错综复杂，但是当她的方向正确，或者靠近“猎物”时，宝石的闪光频率便会加大，所以找到“猎物”的位置倒也不难。终于，麻美把猎物逼到了一条断头路上，她挥动身边的缎带，把猎物绑缚起来，又用手上的短剑结束了猎物的生命。这时，系统界面弹出一个提示，说这种猎物叫做“使魔”，属于“魔女”的仆役。</p><p>“是魔女的仆役？那么魔女是什么？”，宪贞问。丘比答道：“其实魔女才是你们要打的主要目标哦~如果见到使魔就打的话，不仅会浪费自己的魔力，还很难通过它找到魔女的踪影。”</p><p>“在你使用魔法时，你的魔力就会损耗。魔力越损耗，灵魂宝石就越污浊。当灵魂宝石完全浑浊时，会有相当不好的事情发生也说不定...而击杀魔女以后，掉落的物品除了升级素材以外，最重要的就是这个东西，悲叹之种”，丘比向宪贞眼前投送了一张图片，悲叹之种就像一根被银针穿过的葡萄。丘比继续说道：“悲叹之种可以清洁你的灵魂宝石，只要把它们放在一起就行了。”</p><p>“那么，如果我一直不战斗，只是在大世界里面逛街，是不是就没事了？”宪贞抛出了自己的疑问。</p><p>丘比似乎早有准备，立刻答道：“减少战斗确实能延缓灵魂宝石的浑浊，但是并不能完全避免。你的负面情绪，负面的身体状态，灵魂宝石都会自动用魔法帮你修复，而且这个功能你并不能自主选择开启或关闭，所以久而久之你的灵魂宝石还是会浑浊。接下来教你几招常用的技能吧......那么，如果没有其他问题的话，我就走咯。如果有问题就叫我，我会马上出现的。”丘比说完，从麻美肩膀上跳下去，消失不见了。</p><p>“哦...”宪贞有些迷茫。他并不是没有问题，倒不如说满脑子都是问题。“算啦，走一步看一步吧！”他下定决心。</p><p>麻美变回了普通少女的形态，一边把玩着自己的灵魂宝石，一边在城市里逛街。在一个小巷子的转角处，她发现了一个用银针穿过的紫色球体，钉在墙面上。“这不是那个什么悲叹之种吗，在这里是可以直接拿的意思吗？”</p><p>麻美伸手把悲叹之种拔了下来。紧接着，她周围的世界扭曲并折叠，变成了一个旋涡，被吸进了那个悲叹之种留下的小小窟窿里。取代世界的，是另一幅光怪陆离的光景。这个奇异的世界和版画有些类似，色彩相当鲜艳，而且画风相当潦草，边缘还在不停地抖动，就像是那个小孩子的涂鸦。之前遇到的“使魔”，放在大世界里确实很突兀，放在这个奇幻的空间倒是毫无违和感。现在麻美似乎身处一个走廊里，走廊的墙壁上布满了会动的画，描述着不知道是哪个少女的短暂的一生，走廊的地上铺着鲜艳的鲜花，尽管踩起来丝毫没有鲜花的柔软。</p><p>麻美继续沿着走廊往前走，途中遇到了很多使魔，大多数并没有纠缠她太久，她也没有一直和使魔战斗。又走了几十步，空间一下子变大了起来，直到变成了一个大厅。处于大厅之中的，除了许多使魔之外，还有一个巨大的怪物。只见这怪物有三四个人那么高，通体黑红色，好像将熄未熄的木炭；她的周围，有无数鲜红色的蝴蝶飞舞，好似木炭往四周抛洒的火星。一条提示出现在了麻美面前：</p><blockquote><p>Lv.30 烈焰之魔女，性质是挥霍。泪水和歌喉被耗尽后，她决定挥霍一切生命之火，烧尽世界的救赎。</p></blockquote><p>魔女！宪贞眼中只看到了这个词，原来这就是自己的主要敌人：魔女。麻美立刻变身，提起缎带和短剑冲了上去，丝毫没有意识到自己只有5级。</p><p>刚靠近烈焰之魔女，麻美首先感到的是刺骨的严寒，进而是难以言说的酷热。黑红的炭山对她吐出火舌，她只得左右腾挪躲闪。在火舌和冰柱之间，麻美渐渐地体力不支。魔女似乎也不耐烦了，从身体中掏出一根冒着火舌的长鞭举到空中，对着麻美迎面劈下来。麻美见躲闪不及，硬着头皮受了这一击。区区5级的麻美，又哪里是30级的魔女的敌手？</p><p>麻美只见自己的视野又变黑了，她知道这是“濒死”的现象。她吓得暂停了游戏，从背包中找到能回血的食品胡吃海塞。就这样，麻美一边可怜地往魔女身边凑近，用她的缎带和短剑抛光；一边转身腾挪躲避火舌和冰柱，一边不停地按暂停键，吃应急食品来回血。但是食品终究有吃完的时候，而此时魔女的血量还有五分之四。就当麻美准备放弃，闷着头挨下一击时，她的眼前突然弹出一个提示：</p><p>“玩家：福蒂娅 正申请加入你的世界”</p><p>就像在洪水中摸到救命稻草一般，宪贞立刻同意了她的申请。90级的福蒂娅来到了麻美身边，只一击，就杀死了烈焰的魔女。</p><p>“诺，悲叹之种，你拿走吧，反正我还有好多。”福蒂娅开口了。麻美好像是还没缓过劲来，只是走上前去，拿起了悲叹之种。</p><p>“喂喂，我问你啊，你是刚刚才入坑的吧？怎么找到这里来了？”福蒂娅又问道，“这里可不是新人该来的地方。”</p><p>“啊，我，我就是在城里瞎转了转，不知道怎么就来了……”宪贞也不知道怎么回答。</p><p>“哦...这样啊。”福蒂娅不知道怎么，好像有点失望。但她又迅速恢复了刚刚的热情，继续说道“我给你说啊，打怪之前先看一眼等级，Ok？这种Boss不能打就不要乱打。还有就是，你这个角色的技能是可以升级的吧，升到五级以后就能用枪哦，比你现在用的短剑好用多了吧……”她又讲了讲游戏最基本的机制和技巧，就离开了宪贞的世界。</p><p>“是这样啊……”宪贞缓了缓，照着福蒂娅说的找了几个等级低的怪物打了打，又给自己的角色升了几级，也就下线了。</p><p>摘下眼镜，离开VR游戏室，宪贞躺在床上回味着自己的《圆神》时光。不得不承认，这游戏能火确实有它的原因的，在其他这种二次元游戏都是氪金抽卡片的换皮游戏的时候，圆神居然有如此奇妙的画风以及宽广的地图,以及精细的细节。剧情设定到现在倒是没看出什么端倪，看着像上世纪末流行的经典子供向魔法少女。但这一切和失踪案有什么关系呢？罢了，先睡觉吧……宪贞关掉了灯。</p><h2 id="第三节-福蒂娅">第三节 福蒂娅</h2><p>尽管灯关了，头放到枕头上了，被子也放到身体上了，却怎么也睡不着觉，就感觉心脏上压着一块大石头一样。往日柔和的月光，今天却显得有些刺眼了。宪贞不断地在脑子中整理着昨天一整天的所见所闻。先是咖啡店，然后是身上莫名其妙的伤痕，再是社交圈子的微妙变化，最后是——《圆神》。圆神中又有两个人物，丘比应该是机器人先不说了，这个福蒂娅倒是让人印象颇为深刻，毕竟算是救人于水火之中嘛。火一样的性格，可能也是自己喜欢的类型。</p><p>……等等！</p><p>宪贞彻底睡不着了。无论是福蒂娅说话的声音，还是说话的方式，都让宪贞越想越不对劲。宪贞从床上挣扎起来，又进入游戏室，调取了游戏过程的录音，截取了最后福蒂娅出现的那一段以后，拷贝到了自己的U盘里。</p><p>宪贞躺回了床上，一遍又一遍地咂摸着这短短的两句话。不是内容，而是语调和声音。最终他还是和着这段声音进入了梦乡。在梦里，他屡次感觉马上就要捅破那层窗户纸了，但是最终还是没有结果。</p><p>第二天早上，宪贞按时上班时，没有忘记带着他的U盘。宪贞知道，虽然手上这个星奈花的案子暂时还没有头绪，但是论起找人，在市里他说自己的第二，也没人敢说自己是第一。他刚到局里，就溜进了超算机房。而这台超算上，正运行着还在调试的AI追查系统。这套AI追查系统脱胎于宪贞自己大学的科创项目，在大学时期为他带来了倚叠如山的荣誉，基本上来说也是宪贞能如此顺利的当上警察并如坐火箭一般升职的敲门砖。它不仅仅能根据面部、声纹、虹膜等等生物特征在高效地查找人物信息，更厉害的是，一旦知道了一个人的DNA信息，以及任意一个时刻的生物特征，它便能使用人工智能推演出未来某个时刻的特征，包括说话的声音，以及面容等等。它在刚刚投入使用的那一年，便一举帮助几十个被拐卖的儿童找到了父母，而所需要的信息只是出生时的一张照片和一滴血。</p><p>宪贞颤抖着输入了系统的登录密码，然后试着把U盘插到电脑上。当然第一下肯定是插反了的，他又把U盘倒过来，还是插不进去，直到第三次，U盘才精准地滑进了USB口。宪贞深吸一口气，擦了擦手上的汗，把那一段音频拖进了AI追查系统的输入框里，再深吸一口气，按下“确定”：</p><blockquote><p>找到0个目标：第0个/共0个。</p></blockquote><p>这套AI追查系统还没见到过这样的惨败，甚至于宪贞都没有想起来做一个没找到的时候的UI界面。毕竟...一个人怎么可能是不存在的呢？宪贞之前一直是这样想的。</p><p>宪贞现在才想起来把自己扔进椅子里，又给自己倒了杯冷水，喝了一大口。一个人怎么可能是不存在的呢？宪贞在问自己。已经死了？不可能，死人也有记录。失踪了？同理。不对不对，这都是一个人消失的情况，而不是一个不存在的人冒出来的情况。反过来想，如果这个人一开始就没有登记过呢？这样的话不就找不到了吗？但是如果连他的父母、兄弟姐妹都匹配不出来，是不是有点太过分了？总不可能一整个家族都没登记吧？</p><p>宪贞把那杯水一口喝完，锁上电脑，又离开了超算房。他决定先冷静冷静。</p><p>上午，专案组里召开了关于星奈花失踪事件的会议，宪贞讲解了一下昨天调查时的记录，讲了讲自己遇到的几个疑点以后就结束了，他的同事们也没有提出什么太有价值的见解。局长似乎有点生气，说要是两天以内再找不到就只能全城搜查了。</p><p>散会以后，宪贞又溜进了超算房。就在屁股刚挨到椅子上时，一个念头突然划过——怎么就没考虑到“福蒂娅”用了伪声器的可能呢？毕竟以前所有使用AI追查系统的目标都相当的“配合”——至少不会蓄意捣乱。现在的伪声器已经非常高级了，只需要给波形上加上一个很微弱但是经过精心设计的噪音，就能达成扰乱基于神经网络的识别系统的效果，而人耳则完全察觉不了。宪贞将那段录音先用降噪器还原，又轻车熟路地拖到了追查系统的输入框里，按下了enter键。此时，屏幕上出现了结果。</p><p>一张宪贞熟悉得不能再熟悉的面孔出现在了屏幕上。从某种意义上来说，“显示这张照片”就是这套AI追查系统在宪贞大学时被写出来时的终极意义——没错，那就是宪贞日思夜想了十几年的那个她。</p><p>宪贞的心脏漏跳了一拍，瞬间感觉四肢冰冷，呼吸加速，有无数鲜血涌上大脑。尽管他在梦中见到过无数次这个画面，但是要说在现实中突然冷不丁地出现，他并没有做好心理准备。正当他准备开心地大喊时，他注意到了图片右下角的匹配度：只有12%。</p><p>12%的匹配度，系统认为“福蒂娅”有88%的可能性并不是宪贞曾经的女友。但是，系统并没有给出匹配度更高的人选。这代表着，在全国以及世界上共享了数据库的国家的范围内，AI追查系统还是没有找出“福蒂娅”的真身。同时，系统提示：“福蒂娅”，这名据推断为19岁零五个月正负两个月的少女，有46%的可能性是她的妹妹，另有41%的可能性是她的女儿，剩下的1%则是其他从实际上可以忽略的可能，比如克隆人。自从大陆那边搞人类转基因的贺教授锒铛入狱，全世界都加强了关于人类生物技术的监管。</p><p>她有妹妹吗？宪贞可以肯定地回答，没有。不仅仅是在恋爱中的交谈得知，系统中也没有关于她的妹妹的任何信息。那也可能是她失踪后才出生的妹妹，而且基于各种各样的原因没有登记呢？宪贞也迅速排除了这个可能。首先不去登记在这个时代已经是相当困难的事情了，基本等同于黑户，没有身份信息也很难登录游戏；其次，即使这位妹妹是宪贞车祸当天出生的，到现在也不过十八岁三个月零五天，和AI推断的年龄并不相符。那么是女儿吗？呃……宪贞打心眼里不愿意去想象这个可能性。但是依旧是年龄对不上。</p><p>排除了AI给出的两个最有可能的情况，似乎又陷入了死胡同。但一个巨大的进展已经出现了，那就是“福蒂娅”肯定和她有说不清道不明的关系。</p><p>宪贞仔细咂摸着“19岁零五个月”这个年龄，他的脑中莫名有一道光出现。这道光接管了宪贞身体的控制权，操纵着宪贞的手，在AI追查系统的“生理信息预测”功能上点了一下“×”。这个功能本来是宪贞的得意之作，是他付出了无数精力和心血的最终结晶。而如果关闭了这个功能，也就意味着系统将暂时失去按时间流逝推演的能力。接着，这道光继续操纵着宪贞的手按下了“查询”。</p><p>两分钟后，结果出现了。</p><p>屏幕上还是那个女孩，不过这时，右下角的匹配度变成了99.99%。当然，还有一个黄色的警告符号，指示着生理信息预测功能未在运行。</p><p>看到这个结果，宪贞反而像是释然了一般，长出一口气，坐回了椅子里。这个结果意味着什么呢？显然，它意味着十八年前的，宪贞的初恋女友，不知道是经过时空旅行还是怎样，突然出现在了现在这个世界，她现在也在玩《圆神》，用户名是“福蒂娅”。</p><p>十八年的追寻终于有了结果，但是却又带来了一系列问题，其中最大的问题就是：时间旅行并不可能实现，这是常识中的常识。</p><p>宪贞觉得自己的脑子快要被这两个女人的失踪案搅和成一团乱麻了。首先是星奈花的失踪案，然后是自己十八年前的女友的失而复得案，两个事件都疑点重重。星奈花的神秘伤痕，社交圈子的变动，“圆神”，以及“圆神”中“福蒂娅”——也就是宪贞十八年前人间蒸发的女友。有一句话说得好，你手里攥着千头万绪，工作是千头万绪，攥着一千个线头，但是一次针眼只能穿过一条线。宪贞决定还是从自己的女友入手比较好，说没有私心的成分是不可能的，而且他感觉，自己和（前？）女友打交道，应该也比较熟练。那就下班回到家以后继续玩玩《圆神》吧，应该还能在游戏里见到她。在让同事调取一下福蒂娅的实名认证信息后，宪贞就下班回家了。</p><p>宪贞刚回到家，屁股还没坐到沙发上，电话突然响了。一边祈祷着不是新的警情通报，宪贞一边拿起了电话。是一个外国号码，不知道是哪个国家的，看着像是什么南太平洋岛国，和电话一起来的还有反诈骗中心的警告短信。作为一名警察，逗逗骗子扮猪吃老虎也算是乐趣之一，于是宪贞接起了电话。</p><p>“喂，你是宪贞吧，我是福蒂娅。按我对你的了解，你现在大概知道我是谁了吧，要是知道了就来咖啡厅见一面，偶哇！”</p><p>怎么说呢，还是熟悉的热情似火。当然，宪贞也是很乐意见上一见的，不如说是非常想见一面的。于是宪贞直接让AI管家预订了出租车，一边快步往小区大门跑去。</p><h2 id="第四节-意料之外的相遇">第四节 意料之外的相遇</h2><p>宪贞乘车来到了咖啡厅，服务员告知他已经有一个叫福蒂娅的女孩在等他。宪贞三步并做二步走到了服务员指引的包间，打开门，见到了他朝思暮想的那张脸。</p><p>“呀，你来了，坐吧。”福蒂娅微微一笑，作出了一个“请”的姿势。</p><p>宪贞动了动嘴，他当然有很多的问题想问，但是看着福蒂娅，又一时间说不出话来，只得拉开椅子先坐下。福蒂娅已经给他放好了一杯咖啡，他拿起来抿了一小口，既为了平复自己的心情，也为了组织一下自己的语言。</p><p>“星奈花很安全，你不要再追查了。”没想到，福蒂娅先开口了，而且这一句话就能惊掉宪贞的下巴。</p><p>宪贞的下巴当然没有掉，因为他正在喝咖啡。听到福蒂娅的话，他似乎被呛到了一般咳嗽了几声，但又迅速平静了下来。“什么？”宪贞一头雾水。</p><p>“我说啊，你现在是不是在追查一个叫星奈花的孩子的失踪案？星奈花还活着，非常安全，而且被我们保护得很好，过两天等事情结束了我们就把她还给父母，你就不要再管了。”福蒂娅补充道。</p><p>可惜，福蒂娅的补充并没有减少宪贞脑袋里的问号数量。她怎么知道星奈花的？她和星奈花有什么关系？为什么时隔十几年的重逢是在说这些？什么叫“保护得很好”？是劫匪吗？“事情结束了”是什么事情？福蒂娅这两句话，直接把宪贞打蒙了。愣了半天，出于职业习惯，宪贞还是决定问问什么叫保护得很好。</p><p>“呃，保护得很好的意思就是她在我们手里...呃，不是，我不是那个意思。总之就是她可能生了些...病，然后我们怕她受到更多伤害，就在保护她。”福蒂娅显然有点紧张，说话断断续续的。</p><p>“好吧，我们先不说这个。查不查她真不是我说了能算的。亲爱的，你这几年都去哪儿了？为什么突然消失了？‘我们’是什么？”宪贞显然回过了神来。</p><p>“嗯，那个...哎呀，总之你就不要查星奈花了！我,,,很好，希望我们还能再见。”福蒂娅把头低下去，脸色一红，支支吾吾地说。说完，福蒂娅竟然凭空消失了。</p><p>“今天真是见了鬼...”宪贞瞪大了眼睛，然后，他发现福蒂娅的座位上有一个奇怪的装置。</p><p>宪贞乘车回到所里，找到值班的警察，拿出这个装置，问道：“你知道这是个什么东西么？”值班警察对着它端详了半天，也没说出个所以然来，只能明天找专家看看了。</p><p>宪贞带着满脑子的问题跑出了家门，带着更多的问题和一个奇怪的装置回到了家中。</p><p>宪贞把这装置在手中细细揣摩，只见它呈一个从小到大的圆台形，约莫有五六厘米高，顶部是一系列玻璃镜子，就像相机镜头，底部有个USB接口和两张存储卡。看到这里，宪贞小松了一口气：至少它是我们能理解的科技，顶多是哪个高科技公司的试验机，不是什么天外来物，毕竟这两天发生的怪事要说是外星人在搞鬼也不是没有可能。宪贞把这两张存储卡拔出来，发现是VR设备专用的。这么说，这个设备应该是某种VR成像投影仪，而今天在咖啡店的，应该是福蒂娅的VR投影，宪贞作出了推测。</p><p>他把存储卡带进自己的VR室，塞进终端。其中一张卡里的文件格式系统并不认识，可是对于另一张卡，系统提示这是“圆神”的游戏录屏存档。宪贞急忙带上VR眼镜，把这个文件用“圆神”打开，看看里面到底有什么。</p><p>刚进游戏，宪贞变成了一个十六七岁的普通JK少女，而不是他进游戏时所扮演的金发小学萝莉，视野右上角的闪烁着“记录模式”，在这个模式下宪贞并不能操纵角色，只能用这个角色的眼睛观察着世界。</p><p>似乎与平常不同，少女的生活并没有像宪贞扮演的麻美一样突然出现什么重大的变故。她只是在日复一日地上学，上课，聊天，放学，写作业，打游戏，就像这个国家里的无数少女一样。聊的天也无外乎谁和谁谈恋爱了，哪个男明星长得帅了，以及现在最火的游戏——《圆神》。其中她尤其和一个高三年级的学姐关系非常密切，连吃饭都要一起。</p><p>通过聊天的内容得知，学姐来自大陆那边，因为对岛上的文化什么的更感兴趣才在上个月转来的。五年前，大陆那边对他们的宝岛发动了统一国家的战争，日本也被胁迫派兵去帮助宝岛。结果自卫队的队员发现，东京比北京好打得多。日本水兵抹了美国大兵的脖子，战舰在海上兜了一圈又回到了东京湾，一声炮响，自民党下台。这起事件在当时并没有让多少民众的生活受到直接影响，似乎和历史上的那些兵变没什么区别，都是老爷们的游戏。但是这五年里大陆那边和岛上的往来是越来越密切了，岛上很多学校的外语课程从英语换成了普通话，人鱼纪念中学就是其中最积极的一个；大陆那边用日语参加高考的人也越来越多了，而学姐原本就是其中之一。谈吐间，也能看出学姐是个挺优秀的人，学识还算渊博，气质还算温柔优雅，总之给人的感觉不是什么坏人。</p><p>随着关系日益亲密，少女终于决定去学姐家做客了。因为是留学来的，所以学姐是一个人住。为了不那么孤单，学姐养了个宠物。这宠物不是别的，正是那丘比。丘比就像一只小猫一样，时不时低头觅食，时不时在家里跳来蹦去。学姐拿好零食坐下，小丘比灵活地跳进学姐的怀里，学姐则轻柔地抚摸着丘比的毛发。</p><p>“小花，快坐吧！这是从我家带回来的，西湖龙井，今年的新茶，你快尝尝！”学姐拿起桌面上的紫砂壶，招呼少女坐下。宪贞这时才得知，少女似乎叫做小花。</p><p>小花端起茶杯，轻轻吹了几口气，又抿了一口。可惜VR设备还没强大到模拟味觉的地步，宪贞没能尝到“今年的新龙井”的味道。随后，她们又聊了一会儿女孩子们的话题。学姐忽然猛地咽了一口水，似乎下了很大的决心，正色道：“小花，你想不想看看我的世界呢？”</p><p>“诶……学姐的世界...是什么意思呢？”小花呆呆地回应道。</p><p>“来吧，来了你就知道了！”学姐看起来很热情，一旁的丘比开心地甩着尾巴。</p><p>“诶……好吧。”小花依旧呆呆地同意了。</p><p>学姐抱起丘比，拿起小花的手，脚步轻盈地拉着小花走到了大街上。紧接着，学姐从裙子的口袋里掏出了一个水滴状的小饰品，大概有食指那么长，浑身透亮而带点幽幽的蓝色，以不快不慢的频率闪着光，上面有纷繁复杂的镶嵌和装饰。宪贞看出来了，这东西是个灵魂宝石。</p><p>学姐一手拿着灵魂宝石，根据宝石闪烁的频率来判定方向，一手牵着一头雾水的小花，丘比静静地趴在学姐的肩上。“小花，你看，这就是我的世界哦。我在学校里没有多少朋友，也就只有你可以倾诉了...”学姐自顾自地说起话来。</p><p>宝石的闪烁频率仍然在不断地加大，这说明她们离目标越来越近了。这是一个郊外的立交桥，专用于自动驾驶的，虽然不太繁忙，但是看起来依然非常雄壮。唯一不和谐的因素是，有一个绝不应该存在在这里的东西，出现在了视野中，那是一个人！他径直往立交桥上走去，手上还带着一把钳子，应该是用来剪开路旁的铁丝围栏用的。他步履蹒跚，似乎已经非常疲惫了，但是依然昂着头，向着立交桥走去。自动驾驶的速度很快，基本来说都有时速二百多码，虽然现在车并不多，但是他一旦进入了立交桥，也基本意味着死亡。</p><p>“小花，我们快去把他拦下来！”学姐急切地叫道。“诶，可是我们都是女孩子....”小花似乎依然有点犹豫。</p><p>“来不及了，变身！”学姐手中的灵魂宝石飞了出去，发出了蓝色的光芒。学姐身上的校服也变成了华丽的甲胄，看起来好像是中世纪的骑士。她一下跳到那人面前，三两下打晕了他，并夺走了他手中的钳子。这下他应该没有那个本事闯入立交桥了。小花赶上前去，看到他的脖子上有一颗奇怪的印记。“这是魔兽的咬痕”，学姐解释说，“这世界上存在一种叫做‘魔兽’的恶魔，他们会通过这种方式引诱人们自杀，精神不稳定的人、小孩子或者老年人最容易受它们的侵蚀。我的世界，说白了就是和它们作战。”</p><p>“魔兽一般都成群结队出现，今天这只竟然落了单，这是猎杀的好时机！”学姐补充道。</p><p>“来吧，跟上我！”学姐站了起来。这时，小花周围的正常世界忽然开始融化，天空幻化成融化的蜡烛滴落下来，取而代之的是一个光怪陆离，像拼贴画一样的世界。宪贞知道，这就是结界。结界中，小花、学姐和丘比在一条小径中快步前行，学姐不时用钳子幻化而成剑劈砍着冲上来的使魔，一边安慰小花说，“不要害怕，有我在呢。”</p><p>渐行数十步，豁然开朗，一行人来到了一个大厅，大厅半空中有一个面容扭曲的布偶，时不时发出凄厉的嘶吼，它大概就是魔兽的真身。学姐挥动手中的绸缎，只见它变成了一根细线，向大厅的上方飞去。啪嗒一声，绸缎好似有抓钩一般固定在了天花板上。另有一条绸缎飞出把小花和学姐绑在了一起。“抓稳了哟！”学姐提示道，紧接着，小花、学姐和丘比一起顺着绸缎向它的末端飞去。在途经魔女时，学姐拔出剑，对着它砍将过去。一剑下去，那玩偶便爆出雪白色的棉花来。</p><p>一行人顺着绸缎飞到了天花板上，学姐叫一声“小心了！”松开抓钩，向那玩偶落去，而宝剑直对着它的天灵盖。一剑下去，那玩偶像泄了气的气球一样四处乱飞，紧接着拼贴画的世界渐渐淡出，天空又恢复了本来的面貌。</p><p>学姐变回了原来穿着校服的样子，宝剑和绸缎也消失了。小花跑到那个被打晕了的男人面前，摇醒了他，确认他没事之后，轻声安慰了他两句。男人倒也不是坏人，搞清楚状况后道了谢就离开了。这时小花还特意观察了男人的脖子，“魔兽的咬痕”已经消失了。</p><p>学姐走了过来，对小花说：“这就是我的世界。嗯...不知道你喜不喜欢呢...”学姐低下头，似乎有点紧张。</p><p>“哇！学姐也太帅了吧！”小花跳起来，抱住了学姐。“没想到在学校里安安静静的学姐，竟然还有这么帅气的一面吗！而且还可以帮助别人，要是我也能像学姐一样就好了！”学姐愣了愣神，旋即脸上恢复了笑意，拉起小花的手说，“那真是太好了，我们快回去吧。”</p><p>回到家里，学姐重新坐下，叹了一口气，说：“其实我今天特别的害怕，总是怕你觉得我是什么怪物，或者是什么暴力狂……所以我也一直不敢对别人说，但是一直这样下去，我心中就像有一团淤积的火一样，又想说，又不敢说，直到我遇见了你...总之非常感谢你能认可我！”学姐红着脸说道。</p><p>小花笑了：“哪里...像学姐这样又帅气又有爱心的人，不要这么自卑啦！我觉得大家都能认可你哦，即使没有大家，我也是你的忠实粉丝啦！”她们聊了一会儿天后，小花就回到自己家里去了。</p><p>看到游戏告一段落，宪贞把VR眼镜取下来，想要休息一下，接口水喝，顺便捋捋思路。宪贞知道福蒂娅在游戏中的造型和人设，和录像存档里的学姐根本不一样。也就是说，这个录像带并不是福蒂娅本人的，至少不是她昨天使用的账号。而小花则很有意思，本来宪贞很想看看小花长什么样子，可是游戏里是第一人称，而且并没有照镜子的机会。真的没有么？宪贞打开了游戏的帮助菜单，找到“录像与存档”。里面说，这里的游戏录像并不是直接截取画面，而是获取了游戏内部的存档数据，在播放时再实时演算出来，因此大大降低了所占用的存储空间。“既然是实时演算，那么应该就能切换视角！”宪贞心想。果不其然，开发者早考虑到了有能之士的破解，游戏内就提供了视角切换工具，倒带回看工具，速率缩放工具等等一系列扩展插件，就是每个要...呃...1000日元一个月。“钱不是问题，装！”宪贞对AI助手说道。等“录像存档专用插件包”安装好后，宪贞迫不及待地进入了游戏。</p><h2 id="第五节-还是人吗">第五节 还是人吗</h2><p>刚进入录像，宪贞就打开了视角切换工具，结果提示：“目前视线内无可供切换的角色，请找到好友玩家后再试。”想想也对，毕竟这时的小花正在睡大觉呢，视线内什么也没有呀，话说游戏里也要睡觉么，宪贞嘀咕道。</p><p>不一会儿天就亮了，小花也起床去上学了。在上学途中，小花遇上了她的另一个同学。宪贞又打开了视角切换工具，但是仍然提示“目前视线内无可供切换的角色，请找到好友玩家后再试。”，原来如果是NPC的话，也不能切换视角。好吧，宪贞心想，今天你（我）总还要见学姐的吧，我就不信学姐也是NPC。一转眼儿，小花就到了课堂。正在她盯着窗外发呆时，却看见了学姐的那只宠物：丘比。一下课，小花就出去，对着丘比又摸又抱。丘比灵活地从她的怀里挣脱，跳到了地上，尾巴一晃，说话了，却没有开口：“和我签订契约，成为魔法少女吧！”</p><p>“诶，那，那个....像我这样的人，真的可以吗？”小花说道。“没问题的哦，我在你的身上看到了羁绊。”丘比摇着尾巴。“能让我考虑考虑吗？”小花怯生生地问道。“当然没问题，你也可以问问学姐啦，我随时都在，你只要默念我的名字‘丘比’就可以啦 ”丘比又摇了摇尾巴，“此外，如果你愿意当魔法少女，我还可以实现你的一个愿望哟！”说完，丘比就一溜烟跑了。</p><p>中午吃午饭时，小花果不其然去找到了学姐。她们刚刚坐定，宪贞就启动了视角切换工具，这次工具成功启用了，宪贞用视线选择了学姐，按下确定 。</p><p>眼前出现的，是自己日夜追查的星奈花的脸。</p><p>宪贞知道，现在先进一些的VR设备是可以扫描用户的面部特征并导入支持定制角色样貌的游戏里的。</p><p>也就是说，这个录像存档，大概是星奈花的。看日期，也就是星奈花失踪前几天的记录。“这么说来，我更得看看了”，宪贞心想，“这不仅和福蒂娅有关，也和星奈花有关。”</p><p>宪贞把视角调回星奈花，也就是小花，然后继续播放。在吃午饭时，小花告诉学姐，自己被丘比邀请成为魔法少女的事。学姐很开心，因为这样就可以和自己最信任的后辈并肩作战了。沉默了一会儿，学姐又补充道：“嗯...我建议你还是再仔细考虑考虑吧。毕竟这是在战斗，可能是会受伤的！你好好考虑吧，就我而言肯定是希望你能来啦，多个朋友多个帮手嘛。”</p><p>小花显然陷入了思考，没有说太多话。时间到了放学时，小花又跑去找到了学姐，这时她似乎下定了决心：“学姐，我还是想当魔法少女！我这个人平时很懦弱...对什么都很害怕，也总是担心给别人添麻烦...如果能成为魔法少女的话，至少可以帮助到别人，而且还能实现一个梦想呢。”听完这话，学姐一把把小花抱住，边哭边说：“呜呜...小花你真是太好了...”小花难为情地嘿嘿笑了笑，说：“我还没想好愿望是什么呢……”</p><p>愿望这东西，平时说起来有很多，比如说我想中彩票，我想有很多很多的钱，我想不学习就能考到100分，我想让我喜欢的人也喜欢我，我想让我的全家人身体健康，我想让世界和平，我想让全人类飞向星空。但是当真的有你言出法随的机会摆在眼前时，你反而会纠结。不是因为有了这样的机会，而是因为这样的机会只有一次。</p><p>“学姐你的愿望是什么呢？”小花问道。但是学姐并没有正面回答，只是说：“你的愿望一定要直面自己的内心，千万不要搞弯弯绕，不然这会害了你的。比如你说你要次次考试都考一百分，但是你考试的目的是上大学，上好大学的目的是找好工作，找好工作的目的是赚钱，那你与其许愿考一百分，不如直接许愿好工作，或者赚好多钱哦~毕竟高考的满分是150分，嘿嘿。”星奈花认真听着，时不时地点点头表示赞许。</p><p>“那么我的愿望是什么呢...我感觉现在的生活就挺好的了，不如说我想当魔法少女就是为了帮助别人，这可怎么办呢...贸然许愿会不会打破现在平静但美好的生活？”星奈花小声嘀咕着。</p><p>这时，丘比从一旁窜了出来，跳到了学姐怀里，说：“想不到愿望的话，也没有关系的，我一直都在，想好了的话，我就会自动出现哦<sub>Q</sub>”</p><p>“诶，别走，我想好了！既然要成为魔法少女，那我就要成为超级——超级强大的魔法少女！这样既不会对我的日常生活产生影响，也能帮助我的战斗，学姐你觉得怎么样呢？”星奈花说。</p><p>“如果这真的是你的愿望的话，那当然最好啦！”学姐仍旧笑吟吟地看着星奈花。</p><p>“这当然没问题。你确定这是你的愿望吗？”丘比跳到了星奈花的对面。“嗯”，星奈花点了点头。</p><p>“好了，接受它吧，这就是你的命运。”丘比的“头巾”伸长并且插入了星奈花的胸口。并发现眼前有一个闪着鲜红色光芒的宝石。</p><p>接着，录像的时间加快了。内容大概都是一些星奈花和学姐去喝咖啡、并肩战斗、学姐帮助星奈花训练的场景，还是很温馨的。星奈花的魔力很强，但是使用得还是不够熟练，只能在训练中慢慢进步。当然，为了不过度使用魔力，《圆神》就成了她们训练的强力辅助。</p><p>直到那一天。</p><p>紫萱是五年前来岛上的大陆人之一。她在大陆的生活并不顺利，于是便想来岛上碰碰运气，她变卖了在大陆的房产，住进了一座普通的公寓，带着她的老公。在这五年里，她的人生稍有起色，其中最可喜的是在第二年获得了一个可爱的小女孩，名叫小寒。她在推特上开了个账号，记录她和孩子的温馨日常，收获的关注也颇丰。</p><p>这天孩子闹腾着要吃蛋挞，紫萱便下楼去给她买，顺便在蛋糕店旁边的驿站取个快递，那是给孩子买的换装娃娃。刚回单元楼，紫萱便看见邻居火急火燎地找上门，说：“你娃好像刚刚在窗台玩，摔下去了！你赶紧去看看！”。紫萱似乎一下子并没有理解邻居的意思，仍旧提着东西往电梯里走。她一边想着：“这孩子是该多教育教育”，一边按下电梯的13楼按钮。</p><p>一进家门，紫萱高声叫道：“小寒~来吃蛋挞啦！”但是并没有收到想象中的回应。她扔下东西，在家里四处寻找起来。终于，她在窗台上找到了一辆小汽车玩具，这是上周一家人一起去商场时，小寒闹着让买的。往下看去，她看到了最熟悉的花纹，那花纹是紫萱的妈妈最擅长的。新年时，妈妈从大陆给紫萱寄了满满一包东西，其中就有一件饱含着温柔和爱意的小小新衣，上面还有亲手缝制的不那么规整的针脚。</p><p>现在这件新衣静静地躺在十三楼下的水泥地上，上面好像还有一些暗红色的东西。</p><p>紫萱尖叫一声，从楼梯冲了下去。</p><p>13楼的楼梯说长不长，可是对这天的紫萱来说，它长得像二万五千里长征。</p><p>她终于跑到了一楼，看见了暗红色的斑块在她最熟悉的新衣和灰白的水泥地上慢慢扩散。</p><p>与紫萱同时跑来的，还有星奈花和学姐。学姐看到了紫萱，也看到了趴在地上的小孩的脖子上有一块奇怪的印记，这是魔兽的咬痕。</p><p>学姐惊叫一声，直接变身，拉着星奈花进入了魔兽的结界。在结界中歇斯底里地左劈右砍，丝毫不在意砍的是魔兽、使魔还是别的什么东西。学姐的招式里只有永无止境的进攻，丝毫没有格挡与防守。渐渐地，她的身上多出许多伤口，鲜红的血液随着学姐突刺劈砍的身形一起挥洒。星奈花眼见大事不好，催动魔力，释放无数缎带缚住了学姐，硬是把她拉离了结界。</p><p>学姐即使被束缚住，仍然在不停地挣扎，大声喊叫：“小花你在做什么？！你难道不去打魔兽吗？你难道还要让它害死更多的人吗！”直到星奈花把学姐放在公园的长椅上，学姐的动静才渐渐小了起来，渐渐地转化为哭泣：“都怪我不好……都怪我不好！我单知道年轻人会被魔兽盯上，我不知道小孩子也会...我明明昨晚还在推上看过她的....”</p><p>这是一座小公园的深处，半坏的路灯闪着昏暗的白光，树枝在微风中轻轻摇曳。</p><p>星奈花一把把学姐拉近自己的怀里，不知道要说些什么，只好紧紧搂着学姐，一边检查着学姐的伤势。在结界里看起来很严重的伤，现在看来却没有那么严重了。正当星奈花抱着学姐时，她却突然停止了哭泣，晕了过去。</p><p>“学姐！学姐！你醒一醒！”星奈花轻轻推动着学姐，然而并没有得到任何回应。她摸了摸学姐的脉搏，也没有感受到应有的跳动。“喂，喂，醒一醒啊……”星奈花越来越害怕，越来越心急。</p><p>她背起学姐，一脚深一脚浅地往马路边走去，应该是准备叫救护车。这时，丘比出现了：</p><p>“你不要你的学姐了吗？”</p><p>星奈花愣住了：“什么意思？学姐不是在我背上吗？”</p><p>丘比灵巧地跃出，几秒之后又轻轻跳了回来，嘴里叼着暗蓝色的灵魂宝石：</p><p>“学姐她刚刚从身体里掉出来了，所以身体自然就不会动啦。下次可不要这么粗心了哟<sub>Q</sub>”</p><p>与此同时，学姐也醒了过来。她从星奈花背上下来，一把抓起丘比的脖子，诘问道：“喂，刚才是怎么回事？你给我解释清楚！”</p><p>丘比虽然被捏着脖子，声音却丝毫没有变化：“你们魔法少女控制身体的范围只有100米，超过了这个范围，身体自然就成一具空壳了，平时一定要看好自己，不要再让它从身体里掉出来了哟。”</p><p>“一具空壳？什么意思？！”</p><p>“我可不会让你们用原来的身体去战斗，那样也太危险了。对你们魔法少女而言，原先的身体就是身外之物了。作为你们本体的灵魂，已经被精简成了能更安全高效地使用魔力的安全形态。”</p><p>丘比的语调依然没有任何变化，像英语听力一样标准而平缓。</p><p>“和你们签订契约的我，就是抽取你们的灵魂，把它变成灵魂宝石哦<sub>Q</sub>”</p><p>星奈花站在一旁惊慌失措地看着，不知道该想些什么，也不知道该做些什么，好像大脑突然断网进入了“loading”状态一样，她只能在一旁静静地看着。</p><p>学姐掏出剑来，一剑把丘比劈成两半：“你他妈瞎说什么呢？”</p><p>两片丘比的遗体像落叶一般飘落在地上，似乎没有什么重量。</p><p>“那我们不全是僵尸了吗？”</p><p>从树林的阴影处，又一只丘比慢慢地走了出来：</p><p>“你要硬是这么说也不能说就是错的啦。不过这样做可全是为了你们好哦。”</p><p>“够了！够了！不要再说了！！”</p><p>学姐又向新的丘比投掷了几枚匕首，然而并没有击中目标。新的丘比走到原先丘比的尸体旁边，开始啃食起来。</p><p>“这不是更方便了吗？即使心脏被打穿了，只要灵魂宝石还在，就能立刻修复身体继续战斗，比起满是弱点，还会随着时间推移老化的人体，这不是对战斗更有利吗？”</p><p>“你们还真是一个样呢。告诉你们真相后都是这种反应，真不知道你们人类是怎么想的。”</p><p>学姐双腿一软，跪倒在了地上。对着丘比冷冷地说：</p><p><strong>“你他妈的，还算是个人吗？”</strong></p><p><strong>“我不是，你也不是。”</strong>丘比一转身，消失在了阴影之中。</p><p>学姐手中拿着的，是失去了光泽的灵魂宝石，或者说，是她自己。</p><p>比起一开始像天空一样澄澈的灵魂宝石，现在的它已经污浊不堪，里面飘着紫黑色的絮状物，好像是暴雨前的天空，表面更有杂乱无章的裂隙，仿佛一碰就要崩解。</p><p>星奈花见到了，大惊失色，急忙从身上找悲叹之种。但是宪贞知道她不可能找得见，因为屏幕左上角提示星奈花的悲叹之种余量是0。</p><p>学姐轻轻按落星奈花翻找的手，淡淡地说：“没必要了。”</p><p>星奈花在这个仲秋的夜里，急得满头大汗。</p><p>“像我这样的人，既没法拯救别人，甚至连自己都变成怪物了……你说我们，怎么如此滑稽啊？”学姐的声音在颤抖。</p><p>“学姐你不要这样说，你还是救过很多人的！振作起来！”星奈花摇着学姐的肩膀，眼中充满了真挚和急切。</p><p>学姐把手指头轻轻放到星奈花的嘴边，做了一个“嘘”的手势，叹了口气，说：</p><p>“祈求多大的希望，最终就会换回同等的绝望。我们魔法少女，可能就是这样的结构吧。我真傻，真的……”</p><p>天边，一道桃红色的闪光撕破如胶一般粘腻的深夜。那道光好似从大洋彼岸发射的一支利箭，带着使命和神圣，终于来到了学姐的面前。</p><p>学姐轻轻笑了笑，闭上了眼睛。</p><p>蓝黑色的灵魂宝石其中的污浊被桃红色的神圣光箭完全吸收，宝石又恢复成了一开始的澄澈透明。紧接着，宝石破碎了，桃红色的光芒也消失了，随之一同消失的还有学姐的身体。</p><p>学姐好像从来没有在这个世界上存在过。</p><p>星奈花仍然保持着扶着学姐肩膀的姿势，可是她扶着的肩膀已经不存在了。</p><p>她顺势趴在地上，开始呜呜地哭了起来。</p><p>她只看到了学姐的离去，还没有来得及仔细体会丘比说的话到底是什么意思。但是宪贞注意到，系统显示，星奈花灵魂宝石的污染程度已经超过了70%，处于即将崩溃的边缘。</p><p>路灯闪烁，发出滋滋的电流声。树叶摇曳，发出沙沙的撞击声。如果没有少女的哭声，那么这将是普普通通的秋夜。忽然，急切的跑动声和魔法瞬移自带的咻咻声闯了进来。</p><p>星奈花抬头看去，眼前也是一位魔法少女，一头鲜红色的短发，面色通红，喘着粗气，显然是急忙赶来的。她的穿着并不像学姐和星奈花一样复古，而是以普通校服打底，外面穿了一套充满了现代化风格的战术装具，头上戴着鸭舌帽和耳麦，以及一副看起来很复杂的眼镜，手上戴着半指手套，还端着一把自动步枪，手肘膝盖上都戴着护具，身上还穿着一件战术背心，脚下蹬着一双皮靴，至少看起来是这样。</p><p>“巡逻小队285-7报告！找到人了，大的没来得及，小的还在……位置073，021，魔兽1，魔兽幼体4，使魔27，魔法少女1，OVER！”来人对着耳麦说道。</p><p>星奈花的系统显示，这位现代化的魔法少女名字叫做：福蒂娅。</p><p>福蒂娅一把抓起星奈花的手，往其中塞了三颗悲叹之种，说：“快跟我走，你现在情况很危急，周围还有魔兽在活动，先赶紧净化灵魂宝石，别说话，别问，我们边走边解释！”</p><p>星奈花慢慢地把灵魂宝石拿出来，用悲叹之种靠了上去。瞬间，灵魂宝石清澈了不少。</p><p>“对了，就是这样，好孩子！现在我们快走吧！”福蒂娅拉着星奈花的手，一边跑步一边催动魔力瞬移，没命一般地猛跑，跑出了三个街道，福蒂娅才停下喘了口气。福蒂娅抚摸着跑脱力了的星奈花的后背，安慰道：</p><p>“好孩子，不要害怕，我是来保护你的。对你朋友的遭遇，我也非常的悲伤。但是刚才你的灵魂宝石污染已经非常高了，我们需要对你进行全面的检查，希望你能配合我们！”</p><p>星奈花也跟着喘着粗气，她显然没有搞清楚这是怎么回事，不过她知道面前的福蒂娅并不是什么坏人，于是就答应了下来。</p><p>“你还能跑得动吗？现在离魔兽也远了，我们可以慢点走”福蒂娅说。</p><p>“没关系的，走吧。但是那个魔兽怎么办？”星奈花回应道。</p><p>“我已经让我的队友们前去处理了，你不要担心。”尽管如此，福蒂娅还是多少放慢了速度。终于，她们来到了一个诊所门口，诊所并没有通电，看起来就像是下班停业了一样。“冬的诊所”，牌匾上这样写道。福蒂娅和星奈花一个瞬移，就进入了诊所里面的一间病房。</p><p>“叮”一声提示音响起，录屏记录就此中断。</p><p>宪贞取下VR眼睛，也大口地喘着气，顺手擦了擦头上的汗，拿起桌边的瓶装水猛灌了一口。不得不说，宪贞之前真的小看了这款游戏，无论从细节，建模还是渲染上来说，这游戏都有点真实得过分了，简直就像用摄像机拍摄出来的一样，甚至比普通摄像机还要真实，不如说就像是自己真的用眼睛在看。</p><p>游戏录像看完了，那么星奈花和福蒂娅到底在哪呢？宪贞决定先从最后的“冬之诊所”查起。因为这里是记录消失的地方。</p><p>宪贞进入了自己的游戏，来到了地图上的“冬之诊所”。不出意料，系统并没有让他进去。于是，他便在周围散起了步。冬之诊所并不是什么大医院，因此也只在一幢摩天楼的一二楼门面房里。这座摩天楼所在的区域非常的繁华，好像是市中心一样，楼旁的马路中间有个小小的广场公园，好像是哪个古迹的遗址。</p><p>这场景让宪贞有点眼熟。</p><p>非常眼熟。</p><p>宪贞一把抓下了VR眼镜，从裤兜里掏出手机，打开地图APP，在搜索框中输入了“冬之诊所”，按下了确认。</p><p>果不其然，地图给出了结果。冬之诊所就在宪贞所居住的市，而那幢摩天楼正是美冬科技的总部。宪贞调出游戏的大地图，发现这地图竟然和现实完美重合。宪贞一拍脑壳，痛骂自己刚才怎么没有看出来。</p><p>宪贞没有任何一天像今天一样着急去上班，他看向窗外，果不其然，地平线上出现了意料之中的鱼肚白。</p><p>跳上智能车，他火急火燎地到了派出所。刚钻出车舱，就遇见了刚下班的，昨晚值夜班的警察。他拦住宪贞，给了他一封文件。</p><p>“这是美冬科技昨晚给咱们所发的传真，说是丢了一件VR终端实验品让帮忙找找，你看看是不是你昨天拿过来的那个？要是的话，你今天拿给人家，咱也就不用立案了，麻烦。”</p><p>宪贞定睛一看，正是昨天福蒂娅留下的那个装置。宪贞应了下来，就进了警局，换上衣服准备出发了。</p><h2 id="第六节-最美好的前途">第六节 最美好的前途</h2><p>宪贞走进了冬之诊所。乍一看，它和全国几千个大大小小的诊所完全相同，来就诊的患者不多不少，一切都在有序运行，总而言之一句话：正常得都有点异常了。</p><p>宪贞向分诊台的护士出示了警官证和搜查令，叫来了诊所的负责人。负责人是一个中老年的男性，头发花白，面色慈祥，穿着白大褂，挂着听诊器。除了脸上有一道刀疤以外完全就是“老专家”的形象。</p><p>宪贞给他看了星奈花和福蒂娅的照片，问问他有没有看到过这两个人。</p><p>“第一个人没有一点印象，第二个人应该是在头顶这座大厦上班的。”老专家回答道。</p><p>“我能在这里四处走走吗？”</p><p>“当然可以，不过有些房间是无菌的，您要进去恐怕得先做个消杀才行。”</p><p>宪贞道了谢，便在这诊所的一二两层四处转了起来。同之前一样，他也没有发现任何异常，这个诊所和平常的小医院没有任何不同，要硬说有异状，那就是冬之诊所的设备很先进，完全有三甲医院的水平，从专业的医疗器械，到医生桌面上摆的电脑，没有一个是差劲的。这也难怪，说不定人家是美冬科技资助的呢，离得那么近还有个冬字，宪贞心想。</p><p>在二层的走廊尽头，宪贞看到了一个紧锁的房间。老专家说，那个房间从他接手以来就从来没有用过，他都不知道是不是属于这个诊所的。虽然租赁合同上是有，但是房东没给这间房的钥匙，也嘱咐过不要动这房间。</p><p>说着说着，老专家一拍大腿：“哎呀，我才想起来我要出诊了，警官您慢慢查着，有问题了随时叫我哈！”说完，他就跑下了楼。</p><p>宪贞从口袋里摸出万能钥匙，在锁眼里捅了两三下，门就开了。</p><p>映入眼帘的，是和外面没什么不同的病房装潢。两张病床，一堆仪器，一个病人和一个陪护。不同的是，这里面的仪器和外面的有很大区别，不是心电仪，血压血氧仪等常规仪器，病人身上也没有插着各种管子。</p><p>躺着的人看不清，但是坐着的人看得很清楚，那人就是福蒂娅。</p><p>没等宪贞有所反应，福蒂娅就来到了宪贞眼前。</p><p>“宪贞！你是怎么找到这里的？”她开口问道。</p><p>宪贞从口袋中拿出了那枚“VR试验品”，“你总不会是不小心留给我的吧。”，宪贞说道。</p><p>“既然你都看完了，那我也没什么隐瞒的必要了。”少女拉起宪贞的手，另一只手指着病床，“诺，那就是你正在找的星奈花，现在正在睡觉呢，我们小声一点。”，又指了指仪器。</p><p>宪贞凑近去看，仪器的中心，是一块明红色的宝石，那宝石不是别的，正是灵魂宝石。而灵魂宝石上则插着各种各样的导线和接口，整个仪器都是围绕着这宝石工作的。</p><p>“啊？这，这……”宪贞惊讶得说不出话来。</p><p>女孩打开了一扇暗门，招呼着宪贞，有啥事咱出去说。</p><p>宪贞走进了暗门，来到了一个电梯里。等两人站定，电梯便开始缓缓上升。</p><p>“该说你聪明呢？还是笨呢？”福蒂娅责怪着说，“你难道就没有发现那片录像存档芯片里，记录的不是游戏里的内容吗？”</p><p>“什么？那记录的是什么？”宪贞还没有反应过来。</p><p>“事实”，福蒂娅说，“提示很简单。第一，游戏中你们战斗的目标叫‘魔女’，而不叫‘魔兽’。第二，那起幼儿坠楼案，接处警的就是你们所，我还以为你会有点印象。”</p><p>经这么一说，宪贞似乎确实想起来了点东西。不过他还是不太明白，事实是怎么被写在录像存储芯片上的，难道是拍电影吗？</p><p>“从灵魂宝石里提取的。你也应该知道，灵魂宝石才是我们的本体，所以自然能从那里面提取记忆。脑机接口我们做不出来，但是对灵魂宝石的研究突破还是一件接一件。”</p><p>“这...算不算是某种人体实验？”宪贞想幽一默，化解一下尴尬的气氛。</p><p>“……”福蒂娅没有回答。</p><p>电梯停下了。她把宪贞带到外面，那是一片纯白色的大厅，点着几盏白色的灯。“来吧，既然来都来了，那就带你看看我们的实验室。”</p><p>少女指着玻璃墙里面的一号实验室，与其说是实验室，更像是一个制衣工厂，而成品就是福蒂娅在游戏中穿着的现代化战术装具。少女介绍到：“这是魔法少女战术装具。在普通装具的基础上，加入了对灵魂宝石的凯夫拉纤维特种保护，就是被迫击炮弹正面击中，也能保障石头的完好无损。”福蒂娅撕开胸前的一个口袋的尼龙搭扣，透亮的宝石在里面发出温柔而坚定的红光。灵魂宝石周围，接着几根导线，她解释说，这是监测污染程度用的。如果污染程度超过了50%，战术装具就会自动弹出这里悲叹之种来进行净化，福蒂娅指了指灵魂宝石上面的口袋。</p><p>二号实验室看起来也不像是通常意义的实验室，倒像是网吧。福蒂娅说，这是指挥调度中心。大屏幕上监测的是全市范围内的魔兽活动情况。绿色的是巡逻小队，她们主要由能空间移动的魔法少女组成，主要是在市里查找魔兽。“我就是巡逻小队的一员”，福蒂娅补充道。</p><p>找到魔兽后，巡逻小队要上报指挥中心，也就是这里的二号实验室。中心会派出一支四人小队，标准的编制是移动师、战斗师、增幅师和治疗师。“调度中心给魔兽分了五大类，会针对类型分别派遣战斗小队，当然这主要是为了适配小队里的增幅师。每次战斗基本都有固定的流程和套路，再辅以小队长的自行决断，我们这里已经很久没有出现战斗减员了”，福蒂娅听起来有点得意地介绍着，“现在也有监测新签约的魔法少女的装置，但是还不成熟，反应有点慢，定位也不是非常的准。星奈花就是被这个试制系统找到的。”</p><p>三号实验室看起来有点像实验室了，里面有一台大型计算机，比宪贞所里的只大不小。“这是OGAS，总裁起的名字，我也不知道是什么含义。它的作用是对悲叹之种进行分配。”福蒂娅说。宪贞知道，悲叹之种可谓是魔法少女的命门了，而如何对其进行分配，也是至关重要的。福蒂娅继续介绍道：“以前魔法少女各自为战，战斗力强的赚得盆满钵满，而战斗力弱的只能独自消失。OGAS出现以后，所有悲叹之种的生成、获取、分配、消耗，都是由它计算的。基本上来说，它实现了按需分配。”</p><p>“按需分配？那怎么可能呢？如果我现在需要100个怎么办？”</p><p>“这是你对按需分配的狭隘理解。”福蒂娅轻轻笑了一下，“你根本不需要100个悲叹之种，对吧？事实上你连1个都不需要。所以它自然不会给你发，你说的这叫‘按欲分配’而不是‘按需分配’。你说你想要100个，只是因为你认为悲叹之种是一种需要囤积的稀缺资源。几十年前大陆那边的人不也囤积了很多盐，到现在不也没吃完吗？看了前两个实验室，你就应该知道：每一个我们这里的魔法少女的污浊度，都有实时联网记录，这样的话谁什么时候需要多少悲叹之种就一目了然了。”</p><p>宪贞震撼得说不出话来。</p><p>四号实验室看起来更像一个实验室了，宪贞是这么认为的，因为从玻璃墙壁看进去，里面有很多试管，反应皿，还有很多示波器和工业机。福蒂娅说，这是用来研究灵魂宝石的性质的实验室，它最大的成就之一就是灵魂宝石的记忆提取技术和污浊度监测技术。实验室里现在没什么人，只有电器运行的嗡嗡声，因为目前愿意把自己贡献出来以供研究的魔法少女在出外勤。</p><p>五号实验室没有玻璃外墙了，门也换成了严实的铁门。福蒂娅说，她只知道这座实验室名叫“新生命实验室”，里面研究的似乎是关于人体细胞和脑科学的东西。“我们都不是人了，研究体细胞有什么用？有啥病变大不了切掉重新长一个。”福蒂娅表现得有些不屑。</p><p>走廊走到了尽头，福蒂娅刚带着宪贞回头，没想到在他们的面前出现了另一个人。来人一头紫黑色的长发，紫黑色的眼珠下面有一张冷峻的脸，她上身穿着领口和袖口有黑色装饰的白衬衫，下身穿着黑底紫花的裤袜，约莫十四五岁的样子。当然宪贞知道，现在看人脸识别出的年龄已经不靠谱了。</p><p>来人伸出了手：“庆田警官，福蒂娅，你们好，我是晓美焰，美冬科技的副总裁。幸会幸会。”</p><p>宪贞和晓美焰握了手，福蒂娅则显得有点惊慌：“焰！那，那个...我不是故意带外人进来的...他就是我给您提到过的庆田宪贞，所以我才...真的对不起！”</p><p>“没关系，我都知道了，小福你不要老是这么害怕我的。庆田警官，您是为星奈花的事来的吧？”</p><p>“啊，是的。”</p><p>“那麻烦您跟我上楼吧，总裁会给您一个详细的解释。另外，还请麻烦您把你上衣口袋、以及公文包里的录音机拿出来吧，我们用不到这个。”</p><p>晓美焰张开了握住的手，里面果真躺着两个微型录音机。宪贞再去上衣口袋里摸时，已经摸不到了。</p><p>“没事，我都已经帮你拿出来了。没有别的问题我们就走吧”晓美焰淡淡地说。</p><p>总裁的办公室比实验室还要高一楼，但是并没有通电梯，晓美焰和宪贞通过楼梯到了楼上。晓美焰给宪贞递过一张名片，上面印着“晓美焰，美冬科技集团副总裁，东京大学公共管理学院硕士研究生毕业”的字样。</p><p>“门后面就是佐仓总裁的办公室了，我就送到这里吧，回见。”晓美焰指了指面前的门，转身走了。</p><p>宪贞敲了敲门，门自动打开了，眼前的就是美冬科技集团总裁的办公室。装潢并不十分华丽，也不像下面的实验室那样有科技感，就是普普通通的感觉。右边的墙上是一个书架，堆满了书，其中还有翻开的，应该不是假书。办公桌的背后是一块顶天立地的巨大屏幕，屏幕上显示着《圆神》的登录画面，圣洁的粉白色女神正低头俯视着这一切。音响里播放着一首小提琴曲，是《最美好的前途》，上世纪的一首苏联歌。</p><p>总裁端坐在椅子上，面对着屏幕时不时敲两下键盘。她穿着西装，暗红色的头发在脑后束起高马尾，显得很简洁干练，也是十四五岁的面容。看到门开了，总裁站起来，对走到办公桌前的宪贞微微点了下头，也递上一张名片。</p><p>“佐仓杏子，美冬科技集团总裁，东京大学公共管理学院硕士研究生毕业”，上面写道。</p><p>“请坐吧，需要喝水吗？还是喝饮料？茶，咖啡，还是可乐？”佐仓杏子招呼道。</p><p>“啊，喝茶吧。”宪贞随便选了一个。</p><p>佐仓杏子走到书架前，从抽屉里取出一套茶具，紫砂的，花样繁多，有盖碗，茶海，闻香杯，茶杯，茶滤，茶夹，茶托，茶盘，茶巾等等一整套，看得宪贞眼花缭乱。她又取出了一个小小的银罐，从里面倒出些许茶叶。</p><p>经过了一系列工序，杏子亲手为宪贞泡了一杯茶。“今年的新龙井，应该挺好喝的。”杏子说。</p><p>宪贞拿起杯子，回应道：“您也喝，您也喝。”</p><p>杏子从桌子底下的冰箱里拿出一罐红黑色的东西，撬开，倒进了茶杯，里面还咕嘟咕嘟冒着气。</p><p>“哈哈，我就这样。大陆有句话说‘山猪吃不了细糠’，我就喝可乐就行了。”杏子笑了笑，说：“星奈花的事情，你应该了解得差不多了吧，记忆芯片都看了。”</p><p>“是的”</p><p>“里面的东西都是真的”</p><p>“福蒂娅也是这么和我说的”，宪贞似乎有点不置可否。</p><p>“别怀疑啦，都是真的，毕竟魔法什么的，一下子接受不了也是正常的。小福这孩子不会说话。现在她已经恢复得挺好了，咱们聊完你就能把她领走，给她父母一个交代，这事你放一万个心！”杏子察觉到了宪贞的纠结。</p><p>“啊，好的，那多谢您了。只是如果只有这件事，似乎不用劳您大驾吧？”宪贞答道。</p><p>“聪明”，杏子又笑了一下，“福蒂娅以前是你的女朋友吧？她经常和我说起你”。</p><p>“是的，您能告诉我她这些年都经历了什么吗？”宪贞这才意识到已经进入了正题。</p><p>“你之前出过车祸，对吧？当时你都快死了，福蒂娅天天为你祈祷，于是丘比就找上了她”，杏子喝了一口可乐，“她当时就许了愿，许的就是你的健康。后来就是以前每个魔法少女都会经历的事，什么发现自己不是人了什么的。她怕你以为她是怪物，就悄悄离开了你。当时是小焰在路旁捡到的她，就把她带回来了，然后她就一直跟着我们做事，大概就是这么回事。”</p><p>“我真的搞不懂这些小女孩，不是就不是了呗，崩溃啥呀？咋滴，是舌头尝不出味儿了，还是耳朵听不见声音了，还是眼睛看不见东西了，还是胃不能消化了，还是〇没法〇了？一切正常，该咋就咋嘛，真是的。”杏子吐槽道，“哈哈，你别看我现在这样说，当时刚发现这事的时候也挺崩溃的，我现在是老阿姨喽~”</p><p>“您还年轻着呢。”宪贞接下话茬。</p><p>“哈哈，年轻？我们魔法少女最不缺的就是年轻！你把悲叹之种管够，我到一百年之后还是这张脸，这具身体，这个脑子！别说一百年，就是二百年，三百年，高山重新变成海洋，沙漠重新变成绿洲，天空重新变成蓝色，鲜花重新挂上枝头，我们的身体也不会变了。”</p><p>“那么历史上为什么没有关于长寿少女的记载呢？”宪贞提出了疑问。</p><p>“为什么没有？傻呗！就我刚当上魔法少女那时候吧，每个城里的魔法少女都单打独斗，一派一派的。魔兽魔兽打不过，打起魔法少女来倒是一打一个准的，内斗呗，抢来的悲叹之种和打来的悲叹之种不都是悲叹之种。还有大把大把死在第一场战斗上的。过去的人真笨，过去的人真难呐。”</p><p>背景音乐轻声唱道：</p><blockquote><p>有个声音来自最美好的远处，它在黎明时分含着晨露。</p><p>灿烂的前景令人心驰向往，如同当初美好理想的模样。</p><p>……</p></blockquote><p>“我是幸运的，不如说我们是幸运的。我，小焰和麻美，都活到了大学毕业。当时我们就觉得，魔法少女不能再这样下去了。然后麻美就去大陆留学了，我们在这边攒钱。虽然我现在是总裁，不过最厉害的还是人家麻美”，杏子停下，又倒了一杯可乐：“人家在大陆那边留了几年学，回来满嘴什么‘组织’，‘分配’，‘唯物’，还有什么‘标准化’的，给我们讲了一整晚，把我们说得一愣一愣的。虽然愣，但我们知道它行，就这样搞！”</p><p>“花开两朵各表一枝吧，我们这边呢，先是继续读了研，然后开始创业。当时我们做得可多了，什么快递（当然是用魔法瞬移）呀，什么私人侦探呀，搬运工呀，啥活都干，几年下来也算是攒下一笔钱。”</p><p>“后来就干呗，我们就是最初的‘四人小队’，不过只有三个人。你看这本书”，杏子抽出一本薄书，白色封面，上面印着《猎杀魔兽完全指南》，“这就是我们一开始搞的初稿”。杏子轻轻地抚摸着这本书，沉浸在了回忆之中。</p><p>“后来又打了几场仗，和别的魔法少女。我刚在批判内斗，但是有时候真没办法。我们不杀人，也不抢悲叹之种，只是诚挚地要求她们加入我们。一遍行了那就加入，一遍不行就多打几遍，总会同意的。一开始人多的帮派打不过，我们就一个一个拉拢人少的，或者落单的。”</p><p>“再后来啊，我们也慢慢壮大。注册了个公司，叫美冬。主业当时还是送快递，对吧警官”</p><p>“啊，对的”，宪贞赶紧回忆了一下。</p><p>“当时我们的快递干得可好啦，全国次日达，而且既不用买车也不用租飞机，找几个空间系魔法少女接力就行。”</p><p>“再后来啊，麻美她一直在捣鼓电路板，说是能读取灵魂宝石上的信息，还手把手教我们操作。灵魂宝石可是我们的命，一开始谁也不敢轻举妄动，她竟然把自己的灵魂宝石装上去做实验。我到现在都记得污浊度读取成功的那一刻，我们四个人在麻美的小作坊里相拥而泣，我的胳膊上还被没冷下来的烙铁烫了个泡，诺，这就是她当时用的烙铁”杏子指了指书柜。“小焰把这个系统命名为圆环之理 0.1”</p><blockquote><p>……</p><p>有个声音来自最美好的远处，她在召唤我去奇妙的国度。</p><p>我听见那声音向我严正发问，我为明天尽些什么义务？</p><p>……</p></blockquote><p>“科学实验总不是一帆风顺的。有一天晚上大家都下班回家了，麻美还在实验室泡着，我们也没管她。第二天醒来却找不见她人了，查了监控才知道是实验做得不太成功，把自己的灵魂宝石弄浑了。这不是啥大事，放悲叹之种的仓库就在旁边。但是她不愿停下实验，为了获取半浑浊的灵魂宝石的数据，竟然把宝石留在实验台上，自己去拿悲叹之种了。实验室和仓库说远不远，只有120米，可就是这多出来的20米要了她的命。哎，怎么那么不小心啊，明明是这么聪明的人。”杏子长长地叹了口气，语气里充满了惋惜。她又从书架上取下两本书。这次的书不是打印的，而是手写的。封面上用娟秀的字体写着“巴 マミ”，不用说，这是麻美的笔记了。一本是科学研究的记录，一本是组织的经验。</p><p>“幸好她留下来了这两本东西。她以前经常说，要从实践中总结出理论，才不致于人亡事息。没想到‘人亡’得这么快啊……唉。”杏子把这两本笔记放回了书架，接着说：“不过我们两个都不是学理的。小焰上中学的时候学过一点，后来也用得不太熟练，科学实验的笔记是真的看不懂。组织经验的笔记还能照猫画虎继续搞搞，但我们都知道不发展技术，徒有组织是走不远的。那天小福来找我办事，一眼就看到了麻美的实验笔记，她的眼睛里立刻就放着光，问我能不能借回家去看。我当然很开心了，就同意了。我知道小福以前是学工学的，虽然中途辍学了，总比我们这些文科生好得多。”</p><p>“第二天，小福给我们拿来一份文件，题目叫‘实验室操作流程规范’，从怎么不被电烙铁烫到手，到怎么不因为灵魂宝石的崩溃而死，一条一条列得清清楚楚。我请了个施工队，按着她的要求把实验室翻修了一遍。然后她就住进了实验室。我还是有点不放心她的安全，就在实验室寸步不离得陪着她。”</p><p>“大概过了半个月吧，小福终于有了进展。她把自己的灵魂宝石放进系统的卡槽里，大屏幕上竟然显示出来她自己的视野，能随着她的头转动而转动。她说这叫‘感官的流式传输’，现在还只做了视觉。但我们都知道，这是了不起的突破。后来小福给系统加上了存储器，制成了首个记忆芯片，看，就是这个”杏子指着书柜上层的一个水晶展示盒说。盒子里面有一张平平无奇的TF卡。“我们把这个命名为圆环之理 0.5”</p><blockquote><p>……</p><p>我发誓要变得格外善良纯朴，誓和同志分挑患难幸福。</p><p>我要飞快朝那声音奔驰而去，踏上人们没有走过的路。</p><p>……</p></blockquote><p>“再后来，小福做了嗅觉，触觉的流式传输，她又找了个VR设备的公司，把这些数据和VR设备做了适配。过了半年多吧，我们的训练就全进VR了，毕竟在现实世界打魔兽，流程再规范，还是有可能受伤的。这就是圆环之理1.0了。麻美和小焰看出了这里面的商机，就改了改作为游戏发行了，这就是市面上的《圆神》。小焰说这名字和她的一位故交有关。”杏子盯着座椅背后的LED屏幕。</p><p>“这本书也是我们的成果之一”，杏子指着书架上的一本厚厚的书。宪贞走进书架把它抽了出来，封面写着《魔法少女学》。他粗略地翻了翻目录，里面有关于“希望相变焓”、“新人魔法少女心理疏导”、“收割魔兽战斗流程解析”、“灵魂宝石的机械性能”、“灵魂宝石的数据读取方法和数据输入研究”、“利用丘比转发进行的思维共享尝试”、“魔兽诞生机理的几种猜想”等等内容。</p><p>“慢慢的魔法少女活得也越来越久了，也有进社会的，进自卫队的，都有。好在她们都没暴露，都是好孩子啊。”杏子结束了这段讲述，长出了一口气。</p><p>宪贞和杏子都沉默着，只有音乐仍在轻轻唱道：</p><blockquote><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p></blockquote><p>“为什么不能暴露呢？”长长的沉默后，宪贞又提了一个问题。</p><p>“愚问。”杏子眼睛都不眨地回答道，“为什么不能暴露？你说说我们为什么不能暴露？五百年前欧洲人是怎么对待印第安人的？他们还都是人呢，我们连人都不是，他们，或者说，你们能对我们做出什么事来，嗯？”杏子转过身，直直地盯着宪贞。“我们年轻，聪明，漂亮，身体素质强，不会受伤，甚至还会魔法，甚至不用天天吃饭喝水，甚至永远不会老。你猜我们能给社会带来多么巨大的变革？你猜猜你们社会要是发现了我们会做什么？嗯？人类的历史，你我都读过，不用的多说了吧？”</p><p>“不过我相信，我的孩子相信，孩子的孩子相信，终有一天，我们和人类能和谐共处，把酒言欢，同处一片阳光之下。当然，前提是我们能活到那时候。所以我才找到了你，庆田宪贞警官。”杏子坐回了办公椅。</p><p>“你能问出刚才这个问题，也挺好的。至少比那些一看到我们就叫着‘怪物’跑开的人好。其实小福这些年一直都记着你，但是她老害怕你说她是怪物。有你这句话，我就放心了。”杏子又恢复了笑意。</p><p>“小福进来吧！”杏子对着麦克风说。门开了，进来的是那位红色头发，热烈奔放，火一样的少女。现在的福蒂娅没有穿战术装具，只穿了一身水手服，看起来青春烂漫。</p><p>“宪贞...对不起”福蒂娅低下头轻声说。</p><p>宪贞一把把福蒂娅搂在怀里，用手轻轻摸着她那柔顺的头发，一句话也说不出来。</p><p>“你真的老了，胡子扎得我好疼。”福蒂娅在宪贞耳边轻声说，然后从宪贞怀里像小猫一样钻出来，只是手还握在一起。</p><p>“你真傻，为什么不和我说？”宪贞看着福蒂娅的眼睛。</p><p>“我怕……”福蒂娅的脸红了。</p><p>“别怕，我在，我一直都在。”宪贞温柔地回答道。这是暂停了十八年三个月的情愫。</p><p>“咳咳，你俩调情差不多就得了”，杏子在一旁尴尬地说。“庆田警官，我们想拜托你的是，以后帮忙注意一下像这种失踪啊之类的情况，然后给我们也行行方便，有事儿了知会一声。毕竟我们找新魔法少女的手段还不够成熟，将来还要拜托小福呢。”</p><p>宪贞满口答应了下来：“哈哈，那是自然。不过我还是有最后一个问题，您的名字是真名吗？”</p><p>杏子做了个鬼脸：“你猜？”然后她又转向了福蒂娅，说：“虽然我们这还有任务，但是休息也是必须的，你休一个月的假吧，和你的男朋友一起。工资照发，悲叹之种也照发。”杏子笑吟吟地把二人推出了办公室。</p><p>回到座椅上，杏子轻轻地抚摸着办公桌上的一张照片。那是一个穿着白斗篷，蓝衣服的蓝发少女，脸上露出傻傻的憨笑，手上拿着一把西洋剑，海蓝色的灵魂宝石裸露着放在肚脐眼上。</p><p>“你怎么这么傻啊？真是个笨蛋呐……”杏子自言自语道。</p><h2 id="尾声">尾声</h2><p>流浪地球号正在无垠的星空间默默地航行。这个名字是为了致敬五百年前的一位中国科幻作家，在它的笔下，小小的人儿们把地球装上发动机，开到了比邻星的身边。而在这位作家的暮年起航流浪地球号核聚变辐射推进恒星际飞船，也将抵达他笔下的目标：半人马座三星。</p><p>虽然流浪地球号是最早起航的恒星际飞船，但是它一度可能不是最早抵达的。在它启航的一百五十年后，哈珀-摇光光速曲率引擎取得了突破性进展，并在五十年后大规模投入了使用。七十二岁的理查德·哈珀教授，和他的博士生导师，看起来是十七岁少女的李摇光院士出席了首航仪式。哈珀教授在讲话中说，李摇光院士用着十七岁的大脑进行着天马行空般灵动的想象，同时拥有着长达二百年的知识储备和经验沉淀，这让她在科研事业上无往不利。有一句话说“隔行如隔山”，在曲率引擎的研制工作中，李摇光院士从隔着两个喜马拉雅山的完全不同的数学和物理门类中发现了匪夷所思的联系，最终成为了曲率引擎的关键理论基础。在实验遇到瓶颈时，李摇光院士谕示机一般恐怖的直觉也能准确地找出问题出在哪里。面对这样的赞誉，李院士只是笑着摆摆手，说：“熟能生巧而已”。</p><p>一时间，安装着哈珀-摇光引擎的恒星际飞船们像放射线一样，以太阳为中心飞向各种各样的恒星系。最终，人类用二百年的时间，证明了至少在一百光年的半径内，自己在宇宙中是孤独的存在。而其中只有一个星系还没有人染指，那就是离太阳系最近的半人马座三星。“我们要给予我们的先驱者最大限度的尊重”，星际殖民部部长说道，“这尊重就是让她们成为首个完成启航时的目标的人”。</p><p>流浪地球号与以往人们想象中的飞船是不同的，它里面并没有通常意义上的“人”，取而代之的是几个由严密机械保护的鸡蛋大小的宝石。这就是乘员们的灵魂宝石，休眠状态。在日常的航行时，由舰载人工智能自行组织、自行决策，而在飞船遭遇重大事故、或者即将抵达目的地时，才会将这些灵魂宝石唤醒。机械臂从飞船的超低温贮存舱中取出五枚细心保管的空白卵细胞，开始将量子存储器中的DNA序列翻译为脱氧核糖核酸长链，再和同样是打印出来的蛋白质结合后形成染色体，注入细胞核中。</p><p>十七年后，流浪地球号成功泊入了半人马座三星的轨道，五具十七岁少女的身体也在培养皿中日趋成型。机械臂取出灵魂宝石，将其分别靠近对应的身体，少女脸上的眼睛慢慢地出现了光芒。前人追求几百年的人体冬眠技术，以这种看起来离经叛道的原因成为了现实。</p><p>指令长佐仓杏子穿好了舱内航天服，趴在窗前，静静地看着梦了五百年的半人马座三星。这个星系并不像小说家所写的一样处于永恒的混沌之中：中间的两颗和太阳差不多大小的恒星相隔不远地互相绕转，在宇宙中上演着一曲永恒的华尔兹，而比邻星的质量只有太阳的八分之一，在离前两颗恒星1.2万天文单位的圆轨道上缓缓地绕转。这是一个美丽的星系。</p><p>舰载AI发出了提示，在星系中发现了五颗行星，两颗离中心太近，一颗离中心太远，还有一颗落在宜居带中。佐仓杏子指示，首先探索宜居带的那一颗。</p><p>聚变引擎开启，不过输出功率被限制在了很小的范围内，在如此小的输出功率下，人体甚至不会被加速度压坏。飞船静静地向宜居行星飞去，初步分析显示，那是一颗和地球质量类似的岩石行星，拥有大气层，而且在大气层中检测出来了氧气和水蒸气。</p><p>毫无疑问，这说明这颗行星简直就是一个翻版的地球，而它上面，非常有可能存在着生命。</p><p>在随船科学家福蒂娅仔细研读初步分析报告时，舰载AI发现了从那颗行星上面发出的导航电磁波。这么一来，连初步分析报告也没必要看了，星球上存在技术文明是板上钉钉的事。福蒂娅扔下分析报告，开始译解起导航信号来。信号的开头是几组短促的高音，即“2，3，5，7，11，13，17，19”，这是素数序列，昭示着这条电波的主人是技术文明。紧接着，是欧氏平面几何的基本公理和牛顿三定律。就这样，这组信号用最最基本的数学和物理形式构建了一种语言，用来写诗是差了点，但是用作飞船的导航是绰绰有余了。</p><p>飞船已经近到能用肉眼观察行星了。这颗星球有着深蓝色的海洋，浅蓝色的森林和草原，雪白的冰原，悠长的河流，但是唯独少了一样东西：灯光。一个能指导外星飞船降落的文明，为什么夜晚没有灯光呢？</p><p>跟随着引导，飞船的着陆器，以及福蒂娅、晓美焰两位成员缓缓地着陆在了星球表面。这是在一片浅蓝色的草原上，几头不知道是像马还是像河马的动物在水边吃草。在飞船着陆的地表上，有一块黑曜石做成的方碑，上面刻着一些看不懂的文字。</p><p>福蒂娅拿出了从导航信号中提取出来的翻译系统，轻轻念道：“为了忘却的纪念”。</p><p>方碑似乎发现了来人，像一扇门一样打开了。它的下方，是一个隧道。晓美焰和福蒂娅走上了隧道的阶梯。隧道两侧，似乎镌刻着这个文明的历史。他们也有原始时期，有封建领主，有工业革命，当然，也有魔法少女。</p><p>不同于人类在和平时期发现了魔法少女，比邻星文明的魔法少女则亮相于战争年代。这次战争的技术水平略高于人类的第二次世界大战，交战双方都已经掌握了核子武器的使用，但是谁也不敢大面积地轰炸。这时，其中一方的情报组织报告了魔法少女的存在。这条消息转眼间就被间谍送到了对方的案头。它如同炸雷一样引爆了交战双方，他们都意识到了，魔法少女们所蕴含的军事价值，于是紧接着就是大搜捕，年轻的少女们被一个个保家卫国的誓言引诱，对着自己（原本的）同类举起了魔法凝结成的屠刀。</p><p>因为魔法少女的共享心灵特质，旷日持久的战争的天平逐渐翻倒。</p><p>是的，不是倾斜，而是翻倒。战争逐渐从人（我们就把这个文明的主体民族叫做人吧）与人的战争，演变成了人-魔法少女和人-魔法少女的战争，最终则演变成了人类和魔法少女的战争。越来越多的魔法少女们被他们的人类战友视作怪物，越来越多的魔法少女也意识到了战争的目的或许并不像人类所许诺的那样单纯，于是他们慢慢地把枪口对准了彼此。这是一场真正意义上的科技与魔法的较量，一边是超音速战斗机和核子武器，一边是瞬移魔法和时停魔法。</p><p>战争进行了十年，仍然没有结果，只导致天空和大海都变成了黑色，也导致了再也没有人往天空上看一眼。当人们从天文望远镜上发现那颗还有五十年就要正对比邻星的，正从两极发射着死亡的伽马射线的中子星之时，一切已经太晚了。</p><p>五十年很长，正如签订辛丑条约时的中国人不会意识到五十年的时间足以让中国发展出一支把十六国联军抵挡于国门之外的英雄军队。五十年也很短，正如比邻星上可怜的文明发现自己文明的丧钟即将敲响时，它们的英雄飞行员正在忙着朝长得像自己女儿的“异类”少女们投下重磅炸弹，而不是致力于踏上自己行星的月亮。</p><p>战争结束了，没有胜负，只留下了满地的断壁残垣，和一个静静流逝的倒计时。</p><p>核能没有用来驱动辐射引擎，而是用来杀灭了万千生灵。</p><p>当倒计时只剩下十五年的时候，人们才发射了第一颗人造卫星。</p><p>十四年，第一艘载人飞船（不带维生装置的，魔法少女专用）。</p><p>十年，第一支核裂变火箭。</p><p>来不及了！来不及了！！来不及了！！！</p><p>终于，人们停止了所有的努力。是啊，确实来不及了。于是，这座墓穴便被修建了起来，这是整个文明的墓碑。</p><p>5、4、3、2、1......</p><p>伽马射线暴如期，精准地扫过了比邻星和这颗小小行星，行星的整个天空上出现了狂乱鲜红的北极光。但是这并不是这场灾难的终点，而只是这场灾难的序章。在被伽马射线直射后，比邻星加速老化，急速膨胀，在几个小时里走完了几亿年的路，终于，氦闪被点燃了，天空又重新变回了白色，但是红色没有消失，只是转移到了大地上横流的岩浆中。</p><p>人，确实是死完了。但是魔法少女的灵魂宝石，似乎从氦闪中幸存了下来。</p><p>晓美焰和福蒂娅看到这里，不忍继续想下去，因为她们知道将会发生什么。</p><p>纵然灵魂宝石有修复身体的功能，但是面对完全损毁的身体依然无能为力。灵魂宝石们只会消耗魔力，不断化合空气中的碳氢氧，试图组建蛋白质，再组建细胞和菌群，再组建组织，组建器官，最后试图重组人体。但是这一过程实在太复杂，不可能成功。走得最远的，也仅仅到器官这一步。融化的大地上，散落的灵魂宝石周边不断地涌现出几缕肌肉或半个心脏，只是跳动两下就又被熔岩焚毁，而灵魂宝石凭借着强大的机械性能没有被摧毁，依然在忠实地履行着职责，直到全部污浊的那一刻，才能从这永恒的痛苦中解脱。</p><p>百年之后，地面重新凝固，天空重新变成蓝色。这时，最后一颗灵魂宝石也终于耗尽了魔力，或许是因为她生前把守着悲叹之种的仓库，或许是因为着别的原因。它在重组人体的第几千次尝试中失败了，最终只留下了一个心脏、半个骨架和半个肺。</p><p>而现在星球上多姿多彩的生态系统，或许就是这最后一位魔法少女留给行星的最后一件礼物。</p><p>这时，丘比不知道从哪里跳了出来。</p><p>“嘛，孵化总不可能是一帆风顺的。有成功自然有失败，你们地球人还算成功，可是其它文明可能就没这么好运了。这才是孵化者嘛，孵化星际文明的使者。”</p><p>“技术给到手里，怎么用就是自己的事情咯~总之，欢迎你们地球人加入银河系碳基文明联邦啦，我们的总部设在第二悬臂，离你们还挺远的，不过我相信，你们总有一天能到那里去的！”</p><p>“那么，就让我们在某年某月某某有的没的时候再度相见吧！”</p><p>丘比摆了摆尾巴，又消失不见了。</p><p>在轨道上看着直播的佐仓杏子，脑中响起了几百年前她最喜欢的那首有点忧伤的歌曲：</p><blockquote><p>有个声音来自最美好的远处，它在黎明时分含着晨露。</p><p>灿烂的前景令人心驰向往，如同当初美好理想的模样。</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p><p>...</p><p>有个声音来自最美好的远处，她在召唤我去奇妙的国度。</p><p>我听见那声音向我严正发问，我为明天尽些什么义务？</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p><p>...</p><p>我发誓要变得格外善良纯朴，誓和同志分挑患难幸福。</p><p>我要飞快朝那声音奔驰而去，踏上人们没有走过的路。</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p><p>...</p><p>啊最美好的前途，请不要对我冷酷！</p><p>请不要对我冷酷，不要冷酷！</p><p>我就从零点起步，迈向美好的前途。</p><p>向最美好的前途，哪怕是漫漫长路。</p></blockquote><p>【完】</p>]]></content>
    
    
    <categories>
      
      <category>小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科幻</tag>
      
      <tag>同人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20230101-20230119）</title>
    <link href="/2023/01/19/%E5%91%A8%E8%AE%B0%EF%BC%8820230101-20230119%EF%BC%89/"/>
    <url>/2023/01/19/%E5%91%A8%E8%AE%B0%EF%BC%8820230101-20230119%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>说起来已经很久没有写周记了，那么我就简单的记录一下2023年至今，然后稍微规划一下寒假。</p><p>首先就是在2023年的1月1日我阳了，说实话如果告诉几个月前的我我会在新年的第一天感染新冠病毒，我是怎么也不会相信的，但是事实就是这样。阳了的当天发烧到39.5度，但是发烧一晚上以后主要症状就没有了，后面就是时不时咳嗽一下，然后体力有点不如以前。</p><p>在“二十条”刚发布的时候，我认为是想要将动态清零转入一个新常态，但是事实上这样的尝试失败了。这也充分体现了超复杂系统的性质，即使是组织力如此强的政府仍然不能控制方方面面。持续三年的轰轰烈烈的抗疫战争终于告一段落了，但是抗疫虽然结束了，疫情却刚开始，这场战争的结局似乎并不十分尽如人意。未来会怎么样？只能走一步看一步了。至少校门能出了，活动能办了，也算是为数不多的慰藉了。但是不可否认的是：如果在2020年初，全世界能够齐心协力，本来这场灾难完全可以扼杀于摇篮之中。中国人口多，GDP低，科学水平较差，都能在长达两年的时间里把病毒持续抑制在较低的水平，美国人口少、GDP高、科学水平高，却在战争的一开始就被击溃。只要你承认人不生病比生病好，你就得承认在这场战争中，中国的表现远远好于美国。为什么呢？只能是因为中国的社会制度更先进。谁是新时代的朝阳，谁是旧时代的余孽，已经不言而喻了。中国社会制度的先进还体现在，从动态清零到80%的国民都感染新冠，这中间的政策转型只有短短30天的时间。30天里完成了这么巨大的社会转向，甚至有很多人被迫付出健康乃至生命的惨重代价，但是社会上没有出现大的动乱，社会秩序基本照常，法制仍在继续运行，各级机关没有遭到冲击：这是很恐怖的。2020年美国只是更换了一位总统，就有好多人冲进国会山放火了。究其原因，是因为中国是政府和体制合法性双高的社会，而美国则牺牲了政府的执政合法性来被迫换取体制的高合法性。这也导致了美国政府为了自己的存续，必须无止境地讨好属于自己的选民，只看眼前利益而无视长远利益，这也是美国在2020年初就出现大溃败的原因。</p><p>苏联解体后，美国靠着暂时的霸权在全世界横行，逐渐已经不能代表先进文化的前进方向，不能代表先进生产力的发展方向，不能代表全世界最广大人民的根本利益。一个国家的无产阶级，可以存在于这个国家的国境线之外。而中国提出的人类命运共同体和人类文明新形态，是不是要在全世界、国与国之间发动一场国家的无产阶级革命呢？我有这样的预感，但是不能证实。</p><p>说起先进文化的前进方向，近期我作为一个科幻迷有点狂喜，因为有三部科幻影视作品上线：《异化开天三体》、《腾讯三体》、《流浪地球2》.异化开天三体已经被证明是一坨大便了，腾讯三体和流浪地球2的势头目前还是可以的。异化开天三体的失败，真可谓我国目前部分文化行业的缩影。说到底就是人民群众日益提高的艺术文化审美同带专甚至中专学历的相关从业者之间的矛盾。如果把文艺事业，宣传事业都交给降分录取的、文化水平不高的“艺术生”手中，那能有什么前途呢？最终就是在这么一部新中国最伟大的文化作品之一上拉屎撒尿，极尽丑态，令人感慨。我的建议是因为演员可能需要童子功，在录取时仍旧采取降分录取的政策不变，但是在发给毕业证书、执业证书时，必须通过题型类似高考的文化水平通过性考核。</p><p>相比之下，腾讯版三体和流浪地球2就是正面教材。2019年有人说流浪地球开启中国科幻元年，但是中国科幻在这三年内说实话并没有什么太大进展，今年，我希望这个元年能够再被开启一次，由腾讯三体和流浪地球2一起。如果流浪地球2能够成功，我希望三体的电影化，以及刘慈欣先生其它短篇小说的电影化能够尽快提上日程，“刘慈欣宇宙”是在中国日益在国际社会上地位提升的同时，抢占先进文化话语权的绝佳机会，这一工作最好在2035年前后进行。刘慈欣先生是一位国际主义者，它的作品中流露出的国际主义、浪漫主义情节，是非常难能可贵的。</p><p>这段时间里，我进行了为期一周的线上支教。说句实话线上支教和线下支教的体验差得不是一点半点，当然还有两支实践队的实力差距的因素。选择小实践队也有它的好处，那就是能自由选择自己所要讲的内容。我讲了一些数学课和航天史，其中我最得意的部分是航天史。线上讲课的难受，我也算是体会到了，既不能让同学们都来上课，也不能及时和同学们互动，总之就是和线下比不了。这个实践队的经验也不是很足，没有一个很好的传承机制，说人话就是草台班子。突然让我用什么钉钉，我也不知道怎么用。好在我来的目的就是讲课，所以也不用管那些什么加分之类的事，毕竟我已经得过一个全国第一的奖了，一个全国第一和两个全国第一对我来说，也没什么大区别。我曾经想过把我的讲课视频发到B站上，但是最终作罢。因为我在准备时参考了很多资料，而又没有一一标记引用，这个的工作量还是蛮大的。当然我参与实践的另一个原因是npy也参加了，只可惜她的体验似乎不是很好。</p><p>说起文艺作品和现实之间的关系，我的想法是这样的。首先，在高考结束以后，我欣赏文艺作品的出发点是完全娱乐角度的。也就是说，我观看文艺作品只有两种目的：第一种是娱乐身心，第二种是为我即将创作的文艺作品提供参考。尤其是：我欣赏文艺作品不会直接指导我的社会实践，不论它是现实主义、魔幻现实主义、科幻、玄幻、历史还是意识流。我不去为我的放松娱乐寻找所谓的教育意义，我放松娱乐的目的是放松娱乐本身。我看文艺作品是为了我自己高兴而不是为了学到什么。也就是说，文艺作品也许会对我的三观有所塑造，但我不会因为文艺作品中的人物做了什么事，就要在现实世界做什么事，这个道理是很显然的，在我生活的过去21年里，也一直是严格贯彻落实的。我不会因为小时候看喜羊羊和灰太狼里狼把羊放在火锅里，就在嬉戏的时候把同伴放在火锅里；我不会因为我看的动画片里的人会穿越时空，就要在现实世界中也去尝试穿越时空；我不会因为我看的小说里面的人开枪杀人，我就也会在现实世界里开枪杀人，与此完全相同的道理，我不会因为我看的所谓现实主义电视剧里的人物做了什么事，就会在现实世界里做同样的事。</p><p>但是既然要娱乐身心，我想我希望文艺作品里的角色去贯彻公平正义是天经地义的：因为人人都希望正义获胜，我们都希望真理战胜邪恶，我们都希望事实战胜虚伪，我们都希望别人和自己都是爱国敬业诚信友善的，我们都以诚实守信为荣，以见利忘义为耻，以遵纪守法为荣，以违法乱纪为耻。至于所谓现实世界会怎样发展，我当然知道。现实世界里应该怎样做，我当然也知道。但是现实世界自有现实生活来体验，我不希望在我放松娱乐的时候仍然去受现实世界的那些罪，这是很容易理解的。</p><p>这段时间，我在读《南明史》（需要指出的是，南明史可比所谓的现实主义电视剧现实多了，它完全是事实，没有半点变造虚伪）和《红雨》，读完以后准备读《卖桔者言》和《再见绘梨》。此外还会穿插一些科幻世界杂志的阅读。2023年，世界科幻大会将在成都举行，我要抽时间了解一下这个是干什么的，然后考虑一下要不要去。</p><p>游戏方面依然在继续玩原神，Ever17还没有继续打，这个假期肯定是要把它打完的。</p><p>这个假期说什么也要把我那个小说写完。今明两天先写一个新的大纲。其实现在大纲已经写完了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202301192343394.jpg" alt="昆明池落日" /><figcaption aria-hidden="true">昆明池落日</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我为什么要学习数学</title>
    <link href="/2022/12/30/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6/"/>
    <url>/2022/12/30/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>在这学期，我终于完成了数学二学位的学习，<del>也算是拿到理学学士学位了</del>。借此机会，我想来谈一谈，我，以及我们，为什么要学习数学。我为什么要每周花费8个课时的时间，来搞这个又不加综测又不保研又没有奖的东西呢？</p><p>设想一下，我们初中的课本是这样介绍三角函数的：</p><blockquote><p>【三角函数】亲爱的小朋友们，我们今天来介绍三角函数。首先，我们来给出三角函数的定义： <span class="math display">\[\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdots\]</span></p><p><span class="math display">\[\cos x = 1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots\]</span></p><p>我们管这样的函数叫做三角函数，小朋友们学会了吗？接下来，我们做几个练习题巩固一下吧！</p><p>【练习1】计算以下三角函数的数值</p><ol type="1"><li><span class="math inline">\(\sin 1\)</span></li><li><span class="math inline">\(\sin 10\)</span></li><li><span class="math inline">\(\sin \frac \pi 2\)</span></li><li><span class="math inline">\(\cos 17.25\)</span></li><li><span class="math inline">\(\cos 3.14159\)</span></li></ol></blockquote><p>于是，我学了一学期的“三角函数”，知道了各种求多项式加法的技巧，我还会根据周期性调整自变量的值，经过海量的练习，已经能在一分钟以内算出五位小数的三角函数数值了，我已经神功大成，是三角函数大师了！直到我接触到了一门名叫“物理”的科目，里面赫然出现了这么一张图：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212301736742.png" alt="力的正交分解" style="zoom:50%;" /></p><p>我一看到我最熟悉的<span class="math inline">\(\sin ,\cos\)</span>，整个就是一个大惊喜，这不是我最会算的三角函数吗？可是，我又马上蒙蔽了：为什么<span class="math inline">\(F_x=F\cos \theta\)</span>呢？难道说 <span class="math display">\[F_x=F-\frac{F\theta^2}{2!}+\frac{F\theta^4}{4!}-\frac{F\theta^6}{6!}+\cdots\]</span> 是成立的吗？为什么这两个力线的夹角的数值能被塞进一个长得这么奇怪的多项式里面呢？啊，大自然多么的神奇啊！总之我只管记住就行了。可是，我在日后的学习中，在各个地方总是摆脱不了这两个神秘多项式的魅影，渐渐的，我开始感觉到奇怪：为什么大自然就这么不约而同地把这些值设置成 <span class="math display">\[x-\frac{x^3}{6}+\frac{x^5}{120}-\frac{x^7}{5040}+\cdots\]</span> 这些系数真的这么刚好吗？为什么不是 <span class="math display">\[x-\frac{x^{3.1}}{5.7}+\frac{x^{4.8}}{119.98}-\frac{x^{7.2}}{5040.01}+\cdots\]</span> 呢？</p><hr /><p>网上有句话说：“不学数理化，生活处处是魔法”。上面这个例子看起来似乎非常地奇幻，但是它是真实发生的，不过它的主角不是“三角函数”，而是“行列式”。在进入大学的第一个月，我就接触了这个叫做“行列式”的魅影，以及它的逆序数、求和......看起来似乎非常的简单，完全只用到了加减乘除（正如前面的“三角函数”一样），然后我又学会了各种花式计算行列式的办法。但是，我渐渐地发现了，“行列式”这个玩意似乎无处不在，它的魅影笼罩在了许多地方，比如说，为什么我把一个方程的系数像这样加加乘乘，它就能说明这个方程的解的情况呢？</p><p>这个问题一直困惑着我，直到有一天我发现平行四边形的面积的计算方法和<span class="math inline">\(ad-bc\)</span>好像，有那么点关系。那么三维度的平行六面体，以至于多维的超立方体是不是也有这样的关系？为什么那些数字加加乘乘就能判断矩阵的秩序？因为向量们张成的空间的体积如果是零，它们自然线性相关了。在发现这一点以后，我有一种像“任督二脉被打通”一般的强烈的快感，正所谓：</p><blockquote><p>洞天石扉，訇然中开</p></blockquote><p>在发现了方程、向量、超矩体之间的关系以后，我第一次感到了“数学”这门学科的魅力，这是那种“看似毫不相干的事物却通过某种关系紧紧绑缚在一起”的感觉。同时，我也预见到了自己未来的无知：现在我可以灵光一现想到这些东西，但是我这人并不聪明，没有那么多灵光，将来如果继续遇到无数地这些“三角函数”或者“行列式”，怎么办呢？我是不是要继续再这些“换一个方向就很简单”的问题上再花那么多时间和精力呢？</p><p>后来，我在刷B站的时候，又看到了一些讲数学的UP主（其中以“3Blue1Brown”为代表），这更加提升了我对于数学这门学科的热情。</p><p>通过三年多的学习，我也确实从一门又一门的课程中学习到了很多东西。从在各专业课中被频繁使用的常微分方程，到以“抽象”为名且名副其实的抽象代数；从联系了分析、代数、拓扑三大领域的“实变函数与泛函分析”，到和生活紧密相关的数学建模、数理统计和运筹学：数学二学位的学习开阔了我的眼界，满足了我对数学学科的兴趣，反哺了主专业课程的学习，更使我在生活中多了一份应用数学的头脑。</p><p>我再举一个例子吧，比如说傅里叶变换 <span class="math display">\[F(\omega)=\int_{-\infty}^{\infty}f(t)e^{-i\omega t}dt\]</span> 为什么帕塞瓦尔定理是成立的呢？说一句“能量守恒”，似乎有点干巴巴。可是如果把函数看作是一个空间中的向量，傅里叶变换不过是把这个函数换了一个标准正交基来描述，帕塞瓦尔定理的成立就非常显然了——因为它似乎有一个我们更亲切的别名：勾股定理。</p><p>数学在我们的生活中，看似是不在任何地方（毕竟，“买菜不用微积分”），但是同时又无处不在。贝叶斯推断能使我们对事物进行更加准确的判断和预测，数理统计的知识能让我不再对浩如烟海的统计数据感到畏惧，从而从数据中发掘更深层次的真相，运筹学也能从理论层面指导我在两难时作出抉择。</p><p>以上就是我参加数学辅修学位的根本原因，以及学习了三年以来的收获。虽然课程结束了，学习却永无止境，我们且学且珍惜吧。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·滤波器之章</title>
    <link href="/2022/12/24/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%C2%B7%E6%BB%A4%E6%B3%A2%E5%99%A8%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/24/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%C2%B7%E6%BB%A4%E6%B3%A2%E5%99%A8%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="数字滤波器设计">数字滤波器设计</h2><p>数字滤波器设计是通过幅频响应<span class="math inline">\(|H(e^{j\omega})|\)</span>设计系统函数<span class="math inline">\(H(z)\)</span>，在数字系统中编程实现。利用模拟滤波器设计数字滤波器，就是要寻求某种映射，把<span class="math inline">\(s\)</span>平面映射到<span class="math inline">\(z\)</span>平面，为了因果稳定性，这个映射应该满足以下两个条件：</p><ol type="1"><li><span class="math inline">\(s\)</span>平面的虚轴<span class="math inline">\(j\Omega\)</span>映射为<span class="math inline">\(z\)</span>平面的单位圆</li><li><span class="math inline">\(s\)</span>平面的左半平面映射为<span class="math inline">\(z\)</span>平面的单位圆内</li></ol><h3 id="冲激响应不变法设计iir滤波器">冲激响应不变法设计IIR滤波器</h3><p>冲激响应不变法的根本思想是从系统的冲激响应出发，保证数字系统的冲激响应是模拟系统的冲激响应的采样，即： <span class="math display">\[h[n]=h_c(t)|_{t=nT_s}=h_c(nT_s)\]</span> 其中<span class="math inline">\(T_s\)</span>是采样周期。</p><p>对模拟系统冲激响应进行理想采样，有： <span class="math display">\[h_s(t)=\sum_{n=-\infty}^{\infty} h_c\left(n T_s\right) \delta\left(t-n T_{\mathrm{s}}\right)\]</span> 其拉普拉斯变换为： <span class="math display">\[H_s(s)=\sum_{n=-\infty}^\infty h[n]e^{-snT_s}\]</span> 数字系统冲激响应的<span class="math inline">\(z\)</span>变换为： <span class="math display">\[H(z)=\sum_{n=-\infty}^\infty h[n]z^{-n}\]</span> 所以，有： <span class="math display">\[H_s(s)=H(z)|_{z=e^{sT_s}}\]</span> 把模拟信号的拉普拉斯变换在<span class="math inline">\(s\)</span>平面上沿着虚轴以<span class="math inline">\(\Omega_s=2\pi/T_s\)</span>为周期进行周期延拓后，按照<span class="math inline">\(z=e^{sT_s}\)</span>，即<span class="math inline">\(s=\ln z/T_s\)</span>的规则替换变元，即可得到<span class="math inline">\(H(z)\)</span>。需要注意，和<span class="math inline">\(H(z)\)</span>有关的并不是一开始的系统函数<span class="math inline">\(H(s)\)</span>，而是它周期延拓后的结果<span class="math inline">\(H_s(s)\)</span>，如果只知道系统函数，那么要么从冲激响应的路径解决问题，要么先进行周期延拓。</p><p>这个映射可以保证把<span class="math inline">\(s\)</span>左半平面映射到<span class="math inline">\(z\)</span>平面单位圆的内部，保证稳定的模拟滤波器能变换出稳定的数字滤波器。</p><p>因为上述过程中存在周期延拓，因此需要保证模拟滤波器是带限的，但是实际上这并不可能做到，因此用冲激响应不变法必定产生频域混叠。</p><blockquote><p>【例】现有系统： <span class="math display">\[H_c(s)=\sum_{k=1}^N \frac{A_k}{s-s_k}\]</span> 用冲激响应不变法设计数字滤波器，求其<span class="math inline">\(H(z)\)</span></p><p>【解】对系统函数作反变换，得冲激响应： <span class="math display">\[h_c(t)=\sum_{k=1}^N A_ke^{s_kt}u(t)\]</span> 采样，得： <span class="math display">\[h_s[n]=\sum_{k=1}^N T_n A_k\left(\mathrm{e}^{s_k T}\right)^n \mathrm{u}[n]\]</span> 作<span class="math inline">\(z\)</span>变换，得： <span class="math display">\[H(z)=\sum_{k=1}^N \frac{T_s A_k}{1-\mathrm{e}^{s_k T_s} z^{-1}}\]</span></p></blockquote><p>观察上例，<span class="math inline">\(s=s_k\)</span>处的极点变换成Z平面中<span class="math inline">\(e^{s_kT_s}\)</span>处的极点，所以左半S平面的极点可以映射到Z平面的单位圆内；但离散时间系统函数中的零点是部分分式展开式中的极点和系数的函数，通常并不按照与极点相同的方式进行映射，因此冲激响应不变法<strong>不能保证最小相位系统映射后的仍然是最小相位系统。</strong></p><h3 id="双线性变换法设计iir滤波器">双线性变换法设计IIR滤波器</h3><p>为了解决冲激响应不变法的频域混叠现象，需要研究双线性变换法。双线性变换法有两步：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241124288.png" alt="双线性变换法过程示意图" /><figcaption aria-hidden="true">双线性变换法过程示意图</figcaption></figure><p>第一步，把<span class="math inline">\(s\)</span>平面的<span class="math inline">\(j\Omega\)</span>轴压缩到<span class="math inline">\(s_1\)</span>平面的<span class="math inline">\(j\Omega_1\)</span>轴<span class="math inline">\([-\pi/T_s,\pi/T_s]\)</span>的一段。可以通过正切变换，即： <span class="math display">\[\Omega=c\tan \frac{\Omega_1T_s}{2}\]</span> 把这个关系拓展到整个<span class="math inline">\(s,s_1\)</span>平面，有： <span class="math display">\[s=\frac{2}{T_s}\frac{1-\mathrm{e}^{-s_1 T_s}}{1+\mathrm{e}^{-s_1 T_s}}=\frac{2}{T_{\mathrm{s}}} \tanh \frac{s_1 T_{s}}{2}\]</span> 再通过<span class="math inline">\(z=e^{s_1T_s}\)</span>变换到<span class="math inline">\(z\)</span>平面，有： <span class="math display">\[s=\frac 2{T_s}\frac{1-z^{-1}}{1+z^{-1}}\]</span> 或者说， <span class="math display">\[z=\frac{1+(T_s/2)s}{1-(T_s/2)s}\]</span> 如果<span class="math inline">\(z=re^{j\omega},s=\sigma+j\Omega\)</span>，有： <span class="math display">\[\begin{gathered}r=\left[\frac{\left(2 / T_{\mathrm{s}}+\sigma\right)^2+\Omega^2}{\left(2 / T_{\mathrm{s}}-\sigma\right)^2+\Omega^2}\right] \\\omega=\arctan \frac{\Omega}{2 / T_{\mathrm{s}}+\sigma}+\arctan \frac{\Omega}{2 / T_{s}-\sigma}\end{gathered}\]</span> 因为变换的过程中频率产生了畸变，所以设计时可以进行“预畸变”，根据 <span class="math display">\[\Omega=\frac{2}{T_s}\tan\frac{\omega}{2}\]</span> 双线性变换的零极点是按照同种方式映射的，因此可以保证最小相位、全通性质在映射前后不变。而且它完全规避了频域混叠，生成的离散滤波器和连续滤波器有一一对应的关系，这一点也是和冲激响应不变法不同的。</p><h3 id="窗函数法设计fir滤波器">窗函数法设计FIR滤波器</h3><h4 id="基本原理">基本原理</h4><p>FIR滤波器的设计任务是，选择有限长度的单位脉冲响应<span class="math inline">\(h[n]\)</span>，使得系统的频响<span class="math inline">\(H(e^{j\omega})\)</span>满足技术要求。</p><p>窗函数法的基本思想是，首先对理想零相位低通滤波器，画出其单位脉冲响应<span class="math inline">\(h[n]\)</span>（应该是一个偶序列），如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241411935.png" /></p><p>现在把这个<span class="math inline">\(h[n]\)</span>向右移动<span class="math inline">\(M/2\)</span>位，变成<span class="math inline">\(h[n-M/2]\)</span>，然后加一个窗函数<span class="math inline">\(w[n]=R_M[n]\)</span>，形成如下图所示的序列<span class="math inline">\(h_d[n]\)</span>：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241413206.png" /></p><p>由此可见，因果可实现的FIR系统的幅度函数<span class="math inline">\(|H(e^{j\omega})|\)</span>是理想滤波器的幅度函数和窗函数<span class="math inline">\(w[n]\)</span>的幅度函数<span class="math inline">\(W_g(e^{j\omega})\)</span>的卷积，而其相频响应来自于位移所产生的<span class="math inline">\(e^{-j\frac{\omega M}{2}}\)</span>.有以下结论：</p><ol type="1"><li>窗函数旁瓣影响通带内波纹</li><li>窗函数旁瓣影响阻带内波纹</li><li>主瓣宽度影响过渡带宽度</li><li>增加窗的长度可以减小主瓣宽度，从而减小过渡带，但是不能改变肩峰的相对值</li></ol><h4 id="常用窗函数">常用窗函数</h4><ol type="1"><li><p>矩形窗 <span class="math display">\[w[n]=R_M[n]\]</span></p><table><thead><tr class="header"><th style="text-align: center;">主瓣宽度</th><th style="text-align: center;">旁瓣峰值</th><th style="text-align: center;">过渡带宽度</th><th style="text-align: center;">通带阻带波纹最大起伏</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\frac{4\pi}{M+1}\)</span></td><td style="text-align: center;">-13dB</td><td style="text-align: center;"><span class="math inline">\(\frac{1.8\pi}{M+1}\)</span></td><td style="text-align: center;">-21dB</td></tr></tbody></table><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241445619.png" alt="矩形窗" style="zoom:50%;" /></p></li><li><p>Barlett窗 <span class="math display">\[w[n]= \begin{cases}2 n / M, &amp; 0 \leqslant n \leqslant M / 2 \\ 2-2 n / M, &amp; M / 2&lt;n \leqslant M \\ 0, &amp; \text {others}\end{cases}\]</span></p><table><thead><tr class="header"><th style="text-align: center;">主瓣宽度</th><th style="text-align: center;">旁瓣峰值</th><th style="text-align: center;">过渡带宽度</th><th style="text-align: center;">通带阻带波纹最大起伏</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\frac{8\pi}{M+1}\)</span></td><td style="text-align: center;">-25dB</td><td style="text-align: center;"><span class="math inline">\(\frac{4.1\pi}{M+1}\)</span></td><td style="text-align: center;">-25dB</td></tr></tbody></table><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241449010.png" alt="Barlett窗" style="zoom:50%;" /></p></li><li><p>Hanning窗 <span class="math display">\[w[n]= \begin{cases}0.5-0.5 \cos (2 \pi n / M), &amp; 0 \leqslant n \leqslant M \\ 0, &amp; \text {others}\end{cases}\]</span> | 主瓣宽度 | 旁瓣峰值 | 过渡带宽度 | 通带阻带波纹最大起伏 | | :----------------: | :------: | :------------------: | :------------------: | | <span class="math inline">\(\frac{8\pi}{M+1}\)</span> | -41dB | <span class="math inline">\(\frac{6.2\pi}{M+1}\)</span> | -44dB |</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212241452792.png" alt="Hanning窗" style="zoom:50%;" /></p><p>它能使能量更有效地集中在主瓣，但主瓣更长</p></li><li><p>Kaiser窗 <span class="math display">\[w[n]= \begin{cases}\frac{I_0\left[\beta\left(1-[(n-\alpha) / \alpha]^2\right)^{\frac{1}{2}}\right]}{I_0(\beta)}, &amp; 0 \leqslant n \leqslant M \\ 0, &amp; \text {others}\end{cases}\]</span> 其中 <span class="math display">\[\beta= \begin{cases}0.1102(A-8.7), &amp; A&gt;50 \\ 0.5842(A-21)^{0.4}+0.07886(A-21), &amp; 21 \leqslant A \leqslant 50 \\ 0, &amp; A&lt;21\end{cases}\]</span></p><p><span class="math display">\[\begin{align}\alpha&amp;=\frac M2\\M&amp;=\frac{A-8}{2.285(\omega_s-\omega_p)}\\A&amp;=-20\lg \min\{\delta_1,\delta_2\}\end{align}\]</span></p><p><span class="math inline">\(I_0\)</span>是第一类零阶修正贝塞尔函数。于是，得到的因果滤波器为： <span class="math display">\[h_{\text {lpd }}[n]=\frac{\sin \left[\omega_c(n-M / 2)\right]}{\pi(n-M / 2)} w[n]\]</span> 其中 <span class="math display">\[\omega_c=\frac{\omega_s+\omega_p}{2}\]</span></p></li></ol><h3 id="频率采样法设计fir滤波器">频率采样法设计FIR滤波器</h3><p>这个方法的思想是，根据给定的性能确定系统的频响，然后频响进行采样得到采样值<span class="math inline">\(H[k]\)</span>，对其进行IDFT得到<span class="math inline">\(h[n]\)</span>。具体来说，步骤如下：</p><ol type="1"><li><p>根据阻带最小衰减选择过渡带采样点数<span class="math inline">\(m\)</span></p><p>有<span class="math inline">\(A=-20\lg\delta \mathrm{ dB}\)</span>，根据表：</p><table><thead><tr class="header"><th>过渡带采样点数</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td>阻带衰减/dB</td><td>44-54</td><td>54-75</td><td>85-95</td></tr></tbody></table><p>选择<span class="math inline">\(m\)</span></p></li><li><p>确定过渡带宽度<span class="math inline">\(\Delta \omega=\omega_s-\omega_p\)</span>，根据 <span class="math display">\[\Delta \omega \geq \frac{2\pi(m+1)}{M+1}\]</span> 确定滤波器长度<span class="math inline">\(M+1\)</span></p></li><li><p>根据待设计滤波器的性能指标，确定是第几类广义线性相位系统，有以下规则：</p><ul><li><span class="math inline">\(M\)</span>是偶数那么在I、III中选，否则在II、IV中选</li><li>第I类可做各种滤波器，第II类可做低通带通、第III类可做带通、第IV类可做高通带阻</li></ul></li><li><p>确定理想滤波器的幅频<span class="math inline">\(A(e^{j\omega})\)</span>，相频<span class="math inline">\(e^{j(\beta-\alpha \omega)}\)</span></p></li><li><p>对频响进行采样，对于不同的广义线性相位系统，有以下公式成立：</p><ol type="1"><li><p>第I类，<span class="math inline">\(M\)</span>是偶数，<span class="math inline">\(\beta=0\ or\ \pi\)</span> <span class="math display">\[H[k]= \begin{cases}A[k] \mathrm{e}^{-j \frac{M\pi k}{M+1}}, &amp; k \in\left[0, \frac{M}{2}\right] \\ H^*[M+1-k], &amp; k \in\left[\frac{M}{2}+1, M\right]\end{cases}\]</span></p></li><li><p>第II类，M是奇数，<span class="math inline">\(\beta = 0\ or\ \pi\)</span> <span class="math display">\[H[k]= \begin{cases}A[k] \mathrm{e}^{-j \frac{M\pi k}{M+1}}, &amp; k \in\left[0, \frac{M-1}{2}\right] \\ 0, &amp; k=\frac{M+1}{2} \\ H^*[M+1-k], &amp; k \in\left[\frac{M+3}{2}, M\right]\end{cases}\]</span></p></li><li><p>第III类，M是偶数。<span class="math inline">\(\beta = \pi/2 \ or \ 3\pi/2\)</span> <span class="math display">\[H[k]= \begin{cases}0, &amp; k=0 \\{jA}[k] \mathrm{e}^{-j\frac{M\pi k}{M+1}},&amp; k \in\left[1, \frac{M}{2}\right] \\ H^*[M+1-k], &amp; k \in\left[\frac{M}{2}+1, M\right]\end{cases}\]</span></p></li><li><p>第IV类，M是奇数，<span class="math inline">\(\beta = \pi/2 \ or \ 3\pi/2\)</span> <span class="math display">\[H[k]= \begin{cases}0, &amp; k=0 \\ {jA}[k] \mathrm{e}^{-j\frac{M\pi k}{M+1}}, &amp; k \in\left[1, \frac{M+1}{2}\right] \\ H^*[M+1-k], &amp; k \in\left[\frac{M+3}{2}, M\right]\end{cases}\]</span></p></li></ol></li><li><p>求<span class="math inline">\(H[k]\)</span>的<span class="math inline">\(M+1\)</span>点IDFT，得到<span class="math inline">\(h[n]\)</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路·组合与时序之章</title>
    <link href="/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E7%BB%84%E5%90%88%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E7%BB%84%E5%90%88%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="组合逻辑电路">组合逻辑电路</h2><h3 id="设计分析">设计分析</h3><p>略，无非是列功能表、真值表、画卡诺图、化简、转换形式、连电路。</p><h3 id="经典组合逻辑电路模块">经典组合逻辑电路模块</h3><h4 id="编码器">编码器</h4><ul><li><p>8（位）-3（线）编码器</p><p>其基本功能是输入8位中的一位表示被编码的十进制数，3条输出线表示这个十进制数的二进制形式。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162058622.png" alt="83编码器功能表" /><figcaption aria-hidden="true">83编码器功能表</figcaption></figure></li><li><p>优先编码器</p><p>相比于83编码器，优先编码器的输出取决于最高为1的那一位。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162100464.png" alt="优先编码器功能表" /><figcaption aria-hidden="true">优先编码器功能表</figcaption></figure></li><li><p>74HC148优先编码器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162102678.png" alt="电路图" /><figcaption aria-hidden="true">电路图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162102372.png" alt="逻辑符号" /><figcaption aria-hidden="true">逻辑符号</figcaption></figure><p>其中的<span class="math inline">\(A_i,Y_i\)</span>是完成基本功能的输入输出端，此外，它还有一些其它的端口，能进行扩展功能：</p><ul><li><span class="math inline">\(\overline S\)</span>选通输入端，当且仅当<span class="math inline">\(\overline S=0\)</span>，电路正常工作，否则，所有输出都被封锁在高电平。</li><li><span class="math inline">\(\overline {Y_S}\)</span>选通输出端，当它为0时表示：电路工作但无编码输入</li><li><span class="math inline">\(\overline {Y_{EX}}\)</span>扩展输出端，它为0时表示：电路工作且有编码输入</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162110457.png" alt="74HC148功能表" /><figcaption aria-hidden="true">74HC148功能表</figcaption></figure></li></ul><h4 id="译码器">译码器</h4><p>译码器就是编码器的逆，输入三个信号表示一个二进制数，输出八个信号中的一个表示那个二进制数的十进制表示。</p><p>常用的译码器是74138译码器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162113986.png" alt="74138逻辑图" /><figcaption aria-hidden="true">74138逻辑图</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162114347.png" alt="功能表" /><figcaption aria-hidden="true">功能表</figcaption></figure><p>它有三个附加控制器：<span class="math inline">\(S_1,\overline S_{2},\overline S_3\)</span>。当<span class="math inline">\(S_1=1,\overline S_{2}=\overline S_3=0\)</span>时，电路正常工作，否则，所有输出端为高电平。</p><p>使用多个译码器进行串接时，往往可以在第二个译码器上对高位取反，以此来达到串联效果。</p><h4 id="数据选择器">数据选择器</h4><p>数据选择器有若干个输入信号，一个选择信号（可能有多位）和一个输出。由选择信号决定输出接哪个输入信号。</p><p>常用的数据选择器是74HC153双四选一数据选择器。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162121574.png" alt="74HC153逻辑图" /><figcaption aria-hidden="true">74HC153逻辑图</figcaption></figure><p>其中<span class="math inline">\(D\)</span>表示输入信号，<span class="math inline">\(A_1A_0\)</span>共同表示一个二进制数，是选择信号，<span class="math inline">\(Y\)</span>是输出信号，<span class="math inline">\(S\)</span>是选通输入端。有时候我们只用单四选一，这时候把其它管脚留空即可，但是不能把这个片劈成两半。</p><h4 id="数值比较器">数值比较器</h4><p>略，没啥说的，都差不多。</p><p>常用的数值比较器是7485数值比较器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162137127.png" alt="7485逻辑图" /><figcaption aria-hidden="true">7485逻辑图</figcaption></figure><p>其中<span class="math inline">\(A,B\)</span>是待比较的数值，<span class="math inline">\(F\)</span>是输出。而<span class="math inline">\(I\)</span>则是当数值比较器扩展时，来自低位的比较结果。比如说，要实现八位数值的比较，我们可以这样级联：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162139534.png" alt="数值比较器扩展" /><figcaption aria-hidden="true">数值比较器扩展</figcaption></figure><p>首先比较高四位。如果高四位出现了不同，那么自然可以直接输出。如果高四位相同，那么就需要另接入一个数值比较器来比较下四位，然后把下四位的比较结果通过<span class="math inline">\(I\)</span>端反馈到高位的比较器，再由负责高位的比较器来输出最终的结果。</p><p>也就是说，当<span class="math inline">\(AB\)</span>不相等时，输出和<span class="math inline">\(I\)</span>无关，直接输出<span class="math inline">\(AB\)</span>的关系，否则，直接输出<span class="math inline">\(I\)</span>。</p><h4 id="加法器">加法器</h4><p>全加器有三个输入<span class="math inline">\(A,B,CI\)</span>，其中<span class="math inline">\(AB\)</span>表示两个加数，<span class="math inline">\(CI\)</span>表示上个全加器产生的进位信号。有两个输出：<span class="math inline">\(S,CO\)</span>，<span class="math inline">\(S\)</span>表示和，<span class="math inline">\(CO\)</span>表示有无进位。</p><p>这个功能很简单就能描述：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> &#123;CO,S&#125;=A+B+CI<br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162127862.png" alt="全加器功能表" /><figcaption aria-hidden="true">全加器功能表</figcaption></figure><h2 id="半导体存储电路">半导体存储电路</h2><p>基本的半导体存储电路有锁存器、触发器、寄存器、存储器等。其中触发器可按结构分为基本、同步、主从、边沿触发器，按触发方式分为电平、脉冲、脉冲边沿触发器，按逻辑功能分为RS、JK、D和T触发器等。</p><h3 id="sr锁存器">SR锁存器</h3><p>SR锁存器是最基本的半导体存储电路。一般来说，我们所谓的锁存器，都指的是SR锁存器。其电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271054295.png" alt="或非门SR锁存器" /><figcaption aria-hidden="true">或非门SR锁存器</figcaption></figure><p>由于或非门可以被“锁定”的特性，这个电路具有了锁存的功能。其状态转移图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271052715.png" alt="image-20221127105256632" /><figcaption aria-hidden="true">image-20221127105256632</figcaption></figure><p>状态方程如下： <span class="math display">\[\left\{\begin{array}{c}Q^{n+1}=S_{\mathrm{D}}+\overline{R_{\mathrm{D}}} \cdot Q^n \\R_{\mathrm{D}} S_{\mathrm{D}} \equiv 0\end{array}\right.\]</span> 状态表如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271107647.png" alt="或非门SR锁存器状态表" /><figcaption aria-hidden="true">或非门SR锁存器状态表</figcaption></figure><p>状态转移图、状态方程、状态表，说的都是一件事，那就是这个元件的状态如何变化。在SR触发器中，记住状态表是最高效的分析方法。</p><p>在状态表中，我们观察最后两行，这是状态转移图和状态方程中没有考虑到的。这里的“不定”有两种含义。第一种，当电路正常工作时，如果施加<span class="math inline">\(S_D=1,R_D=1\)</span>的输入，会有<span class="math inline">\(Q=\overline{Q}=0\)</span>的状态，这既<strong>不</strong>是<strong>定</strong>义的“1”状态，也<strong>不</strong>是<strong>定</strong>义的“0”状态，所以叫“<strong>不定</strong>”。第二种是，当电路本来就是上一个状态时，如果同时把<span class="math inline">\(S,R\)</span>置<span class="math inline">\(0\)</span>，那么电路的输出状态<strong>不</strong>能确<strong>定</strong>（这个照着电路图推一推就明白了），于是叫做“<strong>不定</strong>”。</p><p>观察状态转换方法，我们有时将<span class="math inline">\(S_D\)</span>叫做“直接置位端”，意思是直接把状态置为1；将<span class="math inline">\(R_D\)</span>叫做“直接复位端”，意思是把状态复位为0，于是这个电路叫做“Ser-Reser Latch”，即“SR锁存器”。</p><p>SR锁存器也可以用与非门构造，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271115837.png" alt="与非门SR锁存器" /><figcaption aria-hidden="true">与非门SR锁存器</figcaption></figure><p>不同的是，这里的<span class="math inline">\(S_D,R_D\)</span>都变成了低电平有效。</p><h3 id="触发器">触发器</h3><h4 id="电平触发">电平触发</h4><p>电平触发的意思，就是当且仅当<code>clk</code>信号是有效信号时，触发器的输出状态随着输入信号变化。如果不是有效信号，则保持之前的输出状态。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271609270.png" alt="电平触发SR触发器" /><figcaption aria-hidden="true">电平触发SR触发器</figcaption></figure><p>电平触发有时会因为一些短暂的噪声而影响整个输出，因此我们要考虑其它触发方式</p><h4 id="脉冲触发">脉冲触发</h4><p>首先来考虑主从SR触发器（也叫“脉冲触发的SR触发器”）。主从SR触发器的结构和符号如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211271644991.png" alt="主从SR触发器" /><figcaption aria-hidden="true">主从SR触发器</figcaption></figure><p>可以看出，一个脉冲触发的SR触发器，是由两个电平触发的SR触发器接成的。<span class="math inline">\(FF_1\)</span>叫主触发器，<span class="math inline">\(FF_2\)</span>叫从触发器，主触发器的输出直接接入从触发器的输入。在分析时，应该在高电平先对<span class="math inline">\(Q_1\)</span>进行分析，之后，再在低电平（注意，从触发器接的时钟信号是翻转的）对<span class="math inline">\(Q\)</span>进行分析。显然，主触发器在一个高电平时间段内，可以随着输入信号的变化而翻转多次。</p><p>接下来我们考虑JK触发器。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272038848.png" alt="JK触发器" /><figcaption aria-hidden="true">JK触发器</figcaption></figure><p>这里在输出端和输入端之间接了一个反馈。即： <span class="math display">\[S=\overline{Q}J,R=QK\]</span> 带入，有： <span class="math display">\[Q^{n+1}=J \cdot \overline{Q^n}+\overline{K} \cdot Q^n\]</span> 这就是JK触发器的状态转移方程，可以写出状态转移图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272045222.png" alt="JK触发器的状态转移图" /><figcaption aria-hidden="true">JK触发器的状态转移图</figcaption></figure><p>状态表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272106517.png" alt="JK触发器状态表" /><figcaption aria-hidden="true">JK触发器状态表</figcaption></figure><p>接下来，我们讨论一下JK触发器是怎么进行状态转移的。JK的主触发器仍然是一个电平触发的SR触发器，但是由于JK触发器的反馈机制，当<span class="math inline">\(Q=0\)</span>时，因为<span class="math inline">\(R=QK=0\)</span>，主触发器只能接受“置1输入信号”；当<span class="math inline">\(Q=1\)</span>时，因为<span class="math inline">\(S=\overline QJ=0\)</span>，主触发器只能接受“置0（复位）输入信号”，所以这个主触发器在<span class="math inline">\(CLK=1\)</span>期间至多翻转一次，这就是所谓的“JK触发器的一次性变化现象”。</p><p>于是，我们可以知道所谓“脉冲触发”到底是什么意思。</p><ol type="1"><li>触发器的翻转分两步动作，首先，在<span class="math inline">\(CLK=1\)</span>时，主触发器接收输入信号，进行动作，而从触发器不动。第二步，<span class="math inline">\(CLK=1\)</span>的信号消失时（有的人把这个动作表述为“下降沿来临时”），从触发器根据主触发器的状态进行动作。由于输出信号是从触发器的输出信号，我们看起来，脉冲触发的触发器进行动作总是发生在<span class="math inline">\(CLK\)</span>信号的下降沿。</li><li>主触发器本来是一个电平触发的SR触发器，所以在<span class="math inline">\(CLK=1\)</span>的全部时间，输入信号都会对主触发器起作用。</li></ol><h4 id="边沿触发">边沿触发</h4><p>边沿触发是最简单的，它的次态仅仅取决与<span class="math inline">\(CLK\)</span>信号的上升沿或下降沿来临的瞬间，输入信号的状态。在分析时，只用对触发的边沿那几个有限的点进行分析就行了。</p><h4 id="按逻辑功能的分类">按逻辑功能的分类</h4><p>SR触发器和JK触发器的逻辑功能前面已经讲了。接下来介绍两种其它的触发器：</p><ol type="1"><li><p>T触发器</p><p>T触发器的功能简单来说是：“0保持，1取反”，即： <span class="math display">\[Q^{n+1}=T\overline{Q}+\overline{T}Q\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(T\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(Q^{n+1}\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>0</td></tr></tbody></table></li><li><p>D触发器</p><p>D触发器的功能简单来说是：“延迟一位”，即： <span class="math display">\[Q^{n+1}=D\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(D\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(Q^{n+1}\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>0</td></tr><tr class="odd"><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td></tr></tbody></table></li></ol><h3 id="存储器">存储器</h3><p>首先明确一个概念：怎么表达一个存储器的大小呢？书上说：“通常写成（字数）x（每个字的位数）”的形式。什么是字？字就是这个存储器输出的东西。存储器每读入一个地址，就会输出一个01串，这个01串就是一个“字”，这个01串的长度就是“每个字的位数”。那么有人说，假设每个字的位数是<span class="math inline">\(n\)</span>，那么字数难道不会自动是<span class="math inline">\(2^n\)</span>吗？不是这样的。因为我们可以在不同的地址里存相同的字，也可以不在存储器中存储所有字，这是显而易见的。存储器的每个地址中存法一个字，所以所谓的“字数”其实是有效的地址数。</p><h4 id="随机存取存储器ram">随机存取存储器RAM</h4><p>可以随时从任何一个指定的地址读出数据，也可以随时将数据写入任何一个指定的存储单元中去，但是掉电后数据会丢失。其基本结构如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272202657.png" alt="RAM结构" /><figcaption aria-hidden="true">RAM结构</figcaption></figure><h4 id="只读存储器rom">只读存储器ROM</h4><p>ROM的基本结构如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272204218.png" alt="ROM" /><figcaption aria-hidden="true">ROM</figcaption></figure><p>我们可以考察一下二极管ROM的详细结构。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272205218.png" alt="二极管ROM" /><figcaption aria-hidden="true">二极管ROM</figcaption></figure><p>在地址译码器中，看纵列，每个纵列构成了一个二极管与门。于是： <span class="math display">\[\begin{aligned}W_0=\overline{A_0}\ \overline{A_1}\\W_1=A_0 \overline{A_1}\\W_2=\overline{A_0}A_1\\W_3=A_0A_1\end{aligned}\]</span> 这样一来，就实现了一个译码器，这就是地址译码器。它将输入的二位二进制地址码翻译成<span class="math inline">\(W_i\)</span>的其中一个信号。</p><p>现在看存储矩阵，看横行，每个横行构成了一个二极管或门，比如<span class="math inline">\(D_3=W_1+W_3,D_2=W_0+W_2+W_3,\cdots\)</span>，这样一来，输出端<span class="math inline">\(D\)</span>就能根据<span class="math inline">\(W\)</span>的选通而输出对应的信号<span class="math inline">\(\{D_3D_2D_1D_0\}\)</span>了。这就是二极管ROM的工作原理。根据这个原理，我们也可以使用ROM来实现多输出端逻辑函数，不再赘述了。</p><h4 id="存储器容量的扩展">存储器容量的扩展</h4><ol type="1"><li><p>位扩展</p><p>当字数够用而每个字的位数不够时，可以使用位扩展。位扩展很简单，只需要把所有地址线、读写控制线、<span class="math inline">\(CS&#39;\)</span>线（CS‘线就是片选输入端，当<span class="math inline">\(\overline{CS}=0\)</span>时，这个片才工作）统统拧在一起就行了，如下是把8个1024x1位存储器位扩展为一个1024x8位存储器的过程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272225535.png" alt="位扩展" /><figcaption aria-hidden="true">位扩展</figcaption></figure></li><li><p>字扩展</p><p>当位数够用而字数不够时，可以使用字扩展。字扩展的接法是：首先把每个片的每个输出端，每个低位地址端，读写控制线并联起来，然后在新的地址位上加入一个译码器，通过译码器和CS端来控制不同的片工作与否，以达到扩展字数的目的。如下图是把4个256x8存储器接成一个1024x8存储器的过程：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211272232639.png" alt="字扩展" /><figcaption aria-hidden="true">字扩展</figcaption></figure></li></ol><h2 id="时序逻辑电路">时序逻辑电路</h2><p>时序逻辑电路的特点是：任意时刻的输出状态不仅仅和当前的输入有关，还和电路之前的状态有关。其基本结构是由存储器电路和组合逻辑电路组成的。如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062052681.png" alt="时序逻辑电路结构" /><figcaption aria-hidden="true">时序逻辑电路结构</figcaption></figure><p>描述时序逻辑，一般用三个方程。下面所说的“Q状态”指的是存储电路中各触发器的输出端状态：</p><ul><li><p>状态方程 <span class="math display">\[Q^{n+1}=H(Z,Q^n)\]</span> 状态方程描述的是前一次的<span class="math inline">\(Q\)</span>状态和后一次的<span class="math inline">\(Q\)</span>状态的关系。</p></li><li><p>驱动方程 <span class="math display">\[Z=Q(X,Q^n)\]</span> 驱动方程描述的是触发器各输入端口和电路的<span class="math inline">\(Q\)</span>状态以及输入信号的关系。</p></li><li><p>输出方程 <span class="math display">\[Y=F(X,Q^n)\]</span> 输出方程描述的是电路的输出信号和输入信号以及<span class="math inline">\(Q\)</span>状态的关系。</p></li></ul><p>时序逻辑电路按照电路状态转换情况不同，分为同步时序逻辑电路（所有触发器共用一个时钟信号）、异步时序逻辑电路（有些触发器的时钟信号可能是其它触发器的输出或者其它信号，总之不是共用一个时钟信号）。</p><p>按照输出变量是否和输入变量直接相关，分为Mealy型（外部输出和触发器的状态以及输入信号有关）和Moore型（外部输出仅与触发器的状态有关）。</p><h3 id="时序逻辑电路的分析">时序逻辑电路的分析</h3><p>分析时序逻辑电路的基本纲领是：</p><ol type="1"><li>根据电路逻辑图写出各个触发器的<strong>驱动方程</strong>（基本形式为：<span class="math inline">\(\text{触发器输入端信号}=f(Q^n,\text{输入信号})\)</span>）和输出方程</li><li>把各驱动方程带入触发器的特性方程，得到电路的状态方程（基本形式为：<span class="math inline">\(Q^{n+1}=f(Q^n,\text{输入信号})\)</span>）</li><li>列出逻辑转换表、逻辑转换图</li><li>分析电路功能</li></ol><p>以下以一些例子说明这个过程。</p><h4 id="同步时序逻辑电路分析">同步时序逻辑电路分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062120494.png" alt="同步时序逻辑电路" /><figcaption aria-hidden="true">同步时序逻辑电路</figcaption></figure><ol type="1"><li><p>列电路驱动方程： <span class="math display">\[\begin{cases}J_1=\overline{Q_2} \cdot Q_3 &amp; K_1=1 \\ J_2=Q_1 &amp; K_2=\overline{\overline{Q_1} \cdot \overline{Q_3}} \\ J_3=Q_1 \cdot Q_2 &amp; K_3=Q_2\end{cases}\]</span> 输出方程： <span class="math display">\[Y=Q_2Q_3\]</span></p></li><li><p>电路所用触发器是<span class="math inline">\(JK\)</span>触发器，其特性方程为：<span class="math inline">\(Q^{n+1}=J\bar Q+\bar KQ\)</span>，把驱动方程带入特性方程，有： <span class="math display">\[\begin{aligned}&amp; Q_1^{n+1}=\overline{Q_2} \cdot Q_3 \cdot \overline{Q_1} \\&amp; Q_2{ }^{n+1}=Q_1 \cdot \overline{Q_2}+\overline{Q_1} \cdot \overline{Q_3} \cdot Q_2 \\&amp; Q_3{ }^{n+1}=Q_1 \cdot Q_2 \cdot \bar{Q}_3+\overline{Q_2} \cdot Q_3\end{aligned}\]</span></p></li><li><p>列出状态转移表：</p><p>这个表有三部分：<span class="math inline">\(Q,Q^{n+1},Y\)</span>。其中<span class="math inline">\(Q\)</span>栏要预先穷举所有组合，<span class="math inline">\(Q^{n+1}\)</span>栏和<span class="math inline">\(Y\)</span>栏根据状态方程和输出方程书写。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062135331.png" alt="状态转移表" /><figcaption aria-hidden="true">状态转移表</figcaption></figure></li><li><p>分析，得这个电路是一个七进制加法计数器，<span class="math inline">\(Y\)</span>是进位信号。</p></li></ol><h4 id="同步mealy时序逻辑电路分析">同步Mealy时序逻辑电路分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062147191.png" alt="有输入的同步时序逻辑电路" /><figcaption aria-hidden="true">有输入的同步时序逻辑电路</figcaption></figure><ol type="1"><li><p>写驱动方程 <span class="math display">\[\begin{aligned}&amp; D_1=\overline{Q_1} \\&amp; D_2=A \oplus Q_1 \oplus Q_2\end{aligned}\]</span></p></li><li><p>由<span class="math inline">\(D\)</span>触发器的特性方程<span class="math inline">\(Q^{n+1}=D\)</span>，写状态方程： <span class="math display">\[\begin{aligned}&amp; Q_1^{n+1}=D_1=\bar{Q}_1 \\&amp; Q_2^{n+1}=D_2=A \oplus Q_1 \oplus Q_2\end{aligned}\]</span></p></li><li><p>写输出方程： <span class="math display">\[Y=\overline{\overline{\bar{A} Q_1 Q_2} \cdot \overline{A \overline{Q_1} \overline{Q_2}}}=\bar{A} Q_1 Q_2+A \overline{Q_1} \overline{Q_2}\]</span></p></li><li><p>写状态转移表：</p><table><thead><tr class="header"><th>A</th><th>Q2</th><th>Q1</th><th>Q2*</th><th>Q1*</th><th>Y</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr class="odd"><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></li><li><p>经分析，其是四进制加减计数器，输入控制加减。状态转换图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062155771.png" alt="状态转换图" /><figcaption aria-hidden="true">状态转换图</figcaption></figure></li></ol><h4 id="异步时序逻辑电路分析">异步时序逻辑电路分析</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062158972.png" alt="异步时序逻辑电路" /><figcaption aria-hidden="true">异步时序逻辑电路</figcaption></figure><ol type="1"><li><p>写出驱动方程： <span class="math display">\[\begin{cases}J_0=1 &amp; K_0=1 &amp; cp_0=CP\downarrow\\J_1=\overline{\overline{Q_2} \cdot \overline{Q_3}} &amp; K_1=1 &amp; cp_1=\bar Q_0\downarrow\\J_2=1 &amp; K_2=1 &amp; cp_2=\bar Q_1\downarrow\\J_3=\bar Q_1\bar Q_2 &amp; K_3=1 &amp; cp_3=\bar Q_0\downarrow\end{cases}\]</span></p></li><li><p>根据<span class="math inline">\(JK\)</span>触发器的特性方程<span class="math inline">\(Q^{n+1}=J\bar Q+\bar KQ\)</span>，写出状态方程： <span class="math display">\[\begin{cases}Q_0^{n+1}=\left.\overline{Q_0}\right|_{CP \downarrow}\\Q_1^{n+1}=Q_2 \overline{Q_1}+Q_3 \left.\overline{Q_1}\right| _{\bar Q_0 \downarrow}\\Q_2^{n+1}=\left.\overline{Q_2}\right|_{\overline{Q_1} \downarrow}\\Q_3^{n+1}=\overline{Q_1} \cdot \overline{Q_2} \cdot \left. \overline{Q_3} \right| _{\overline{Q_0} \downarrow}\end{cases}\]</span></p></li><li><p>写状态转换表。</p><p>首先画一张空表</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062216825.png" alt="空表" /><figcaption aria-hidden="true">空表</figcaption></figure><p>然后填写Q和已确定的<span class="math inline">\(cp_0\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062218665.png" alt="填写Q和cp0" /><figcaption aria-hidden="true">填写Q和cp0</figcaption></figure><p>写出可以写出的<span class="math inline">\(Q^{n+1}\)</span>，比如<span class="math inline">\(Q_0^{n+1}\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062220582.png" alt="填写Q0*" /><figcaption aria-hidden="true">填写Q0*</figcaption></figure><p>根据Q0*，写出由Q0*确定的时钟信号<span class="math inline">\(cp_1\)</span>,<span class="math inline">\(cp_3\)</span>.因为这两个信号都是<span class="math inline">\(\bar Q_0\downarrow\)</span>，所以在<span class="math inline">\(Q_0^{n+1}=1\)</span>的地方画下箭头</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062224507.png" alt="画cp1cp3" /><figcaption aria-hidden="true">画cp1cp3</figcaption></figure><p>根据已经确定的<span class="math inline">\(Q,cp_1,cp_3\)</span>,填写<span class="math inline">\(Q_1^{n+1},Q_3^{n+1}\)</span>.在<span class="math inline">\(cp\)</span>有下降沿时，根据状态方程计算状态；当<span class="math inline">\(cp\)</span>不是下降沿时，直接保持<span class="math inline">\(Q_1^n,Q_3^n\)</span>（原状态）的值</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062229881.png" /></p><p>根据<span class="math inline">\(Q_1^{n+1}\)</span>，写出<span class="math inline">\(cp_2\)</span>（连续1串的末尾处填写↓），仿照上面的过程填写<span class="math inline">\(Q_2^{n+1}\)</span>，最后填写<span class="math inline">\(Y\)</span>.</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212062232556.png" /></p></li><li><p>根据表格画出状态转移图，发现其为模十减法计数器</p></li></ol><h3 id="时序逻辑电路设计">时序逻辑电路设计</h3><p>设计时序逻辑电路的纲领就是把分析的过程反过来</p><ol type="1"><li>根据设计要求设定状态，绘制状态转换图和表</li><li>根据触发器类型对状态方程进行逻辑化简</li><li>写出输出方程和驱动方程</li><li>根据输出方程和驱动方程画电路图</li><li>验证自启动性</li></ol><p>下面以一些例子说明这个过程：</p><h4 id="同步时序逻辑电路设计">同步时序逻辑电路设计</h4><p>【例】设计一个同步13进制加法计数器。</p><ol type="1"><li><p>绘制状态转换图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071028422.png" alt="状态转换图" /><figcaption aria-hidden="true">状态转换图</figcaption></figure><p>根据图列出状态转换表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071029063.png" alt="状态转换表" /><figcaption aria-hidden="true">状态转换表</figcaption></figure></li><li><p>进行逻辑化简，画卡诺图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071033299.png" alt="卡诺图" /><figcaption aria-hidden="true">卡诺图</figcaption></figure><p>在使用JK触发器时，因为JK触发器的特性方程是（以<span class="math inline">\(Q_3\)</span>为例子）： <span class="math display">\[Q_3^{n+1}=J\cdot \overline{Q_3^n}+\overline{K}\cdot Q_3^n\]</span> 所以我们终究是要化简成像这样的形式，才能进行下一步驱动方程的书写的。所以，在化简时，我们可以在卡诺图中画一条“鸿沟”，把<span class="math inline">\(Q_3\)</span>和<span class="math inline">\(\overline{Q_3}\)</span>的部分分割开，合并“1”格画卡诺圈时不跨越“鸿沟”，这样的话，化简出来就直接是上面式子的形式了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071055814.png" alt="“鸿沟法”" /><figcaption aria-hidden="true">“鸿沟法”</figcaption></figure><p>如图，可以写出各状态方程： <span class="math display">\[\begin{cases}Q_3^{n+1}=Q_2Q_1Q_0\cdot \overline{Q_3}+\overline{Q_2}\cdot Q_3\\Q_2^{n+1}=Q_1Q_0\cdot \overline{Q_2}+(\overline{Q_3}\ \overline{Q_1}\cdot Q_2+\overline{Q_3}\ \overline{Q_0}\cdot Q_2)\\Q_1^{n+1}=Q_0 \cdot \overline{Q_1}+\overline{Q_0} \cdot Q_1\\Q_0^{n+1}=(\overline{Q_3} \cdot \overline{Q_0}+\overline{Q_2} \cdot \overline{Q_0})\end{cases}\]</span></p></li><li><p>根据JK触发器的特性方程，可以直接写出驱动方程： <span class="math display">\[\begin{cases}J_3=Q_2Q_1Q_0 &amp; K_3=\overline{\overline{Q_2}}=Q_2\\J_2=Q_1Q_0 &amp; K_2=\overline{\overline{Q_3}(\overline{Q_1}+\overline{Q_0})}=Q_3+(Q_1Q_0)\\J_1=Q_0 &amp; K_1=Q_0\\J_0=\overline{Q_2}+\overline{Q_3} &amp; K_0=1\end{cases}\]</span></p></li><li><p>画出电路图</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212071111134.png" alt="电路图" /><figcaption aria-hidden="true">电路图</figcaption></figure></li></ol><h4 id="异步时序逻辑电路设计">异步时序逻辑电路设计</h4><p>【例】用JK触发器设计一个异步五进制计数器</p><ol type="1"><li><p>绘制状态转换图（略），时序波形图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132041777.png" alt="波形图" /><figcaption aria-hidden="true">波形图</figcaption></figure></li><li><p>在保证状态变化的时候必有触发脉冲的前提条件下, 选择在状态不变的时候触发脉冲最少的, 使得 <span class="math inline">\(\mathrm{JK}\)</span> 的输入条件简化。根据以上准则，选定各触发器的触发信号源；列写状态转移表：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132044245.png" alt="状态转移表" /><figcaption aria-hidden="true">状态转移表</figcaption></figure></li><li><p>把状态转换表变成卡诺图形式，逻辑化简，写出逻辑表达式 <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132046917.png" alt="卡诺图" /></p><p>状态方程： <span class="math display">\[\begin{cases}Q_2^{n+1}=Q_1Q_0\cdot\overline{Q_2}\\Q_1^{n+1}=\overline{Q_1}\\Q_0^{n+1}=\overline{Q_2}\cdot\overline{Q_0}\end{cases}\]</span> 驱动方程： <span class="math display">\[\begin{cases}J_2=Q_1Q_0 &amp; K_2=1\\J_1=1 &amp; K_1=1\\J_0=\overline{Q_2} &amp; K_0=1\end{cases}\]</span></p></li></ol><h3 id="计数器">计数器</h3><p>计数器是用以统计输入脉冲CP个数的电路。常用的计数器有以下这么几种：</p><ol type="1"><li><p>74161：4位二进制同步加法计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132138461.png" alt="74161的逻辑图和功能表" /><figcaption aria-hidden="true">74161的逻辑图和功能表</figcaption></figure></li><li><p>74191：四位二进制同步可逆计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132142262.png" alt="功能表" /><figcaption aria-hidden="true">功能表</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132143570.png" alt="符号" /><figcaption aria-hidden="true">符号</figcaption></figure></li><li><p>74160：十进制同步加法计数器</p><p>其逻辑符号和功能表和74161相同，仅靠上面的数字区分。</p></li></ol><h4 id="任意进制计数器的构成">任意进制计数器的构成</h4><p>假设已经有了<span class="math inline">\(N\)</span>进制计数器，要求通过链接、外加电路的方法得到<span class="math inline">\(M\)</span>进制计数器。</p><ol type="1"><li><p><span class="math inline">\(M&lt;N\)</span>时</p><p>主要方法有置零法和置数法两种。置零法是在电路从<span class="math inline">\(S_0\)</span>计数到<span class="math inline">\(S_M\)</span>时，外接一个<span class="math inline">\(M\)</span>的译码器，产生一个置零信号，接入置零端。因为电路一经过<span class="math inline">\(S_M\)</span>状态就会产生置零信号，进而被置入<span class="math inline">\(S_0\)</span>状态，因此<span class="math inline">\(S_M\)</span>并不会出现在稳定循环中。以上是异步置零的情况，如果是同步置零的话，需要在<span class="math inline">\(S_{M-1}\)</span>处进行译码，传回置零信号，然后在下一个时钟触发置零。其逻辑转换图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132232915.png" alt="置零法" /><figcaption aria-hidden="true">置零法</figcaption></figure><p>下图是用置零法把同步十进制计数器74160接成同步六进制计数器的电路图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132237765.png" alt="10-6" /><figcaption aria-hidden="true">10-6</figcaption></figure><p>这里的清零端是异步清零。此时标志“进位”这个动作发生的信号是进位输出信号的下降沿。这种接法的清零信号持续时间非常的短，有可能导致电路出错。可以在进位输出前加一个锁存器，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132241978.png" alt="改进的10-6" /><figcaption aria-hidden="true">改进的10-6</figcaption></figure><p>此时如果电路进入<span class="math inline">\(S_6(0110)\)</span>状态，在<span class="math inline">\(G_1\)</span>门后输出低电平，把与非门SR锁存器置1，<span class="math inline">\(\bar Q\)</span>端输出低电平，接入低电平有效置零端<span class="math inline">\(R_D\)</span>，把电路置零。而因为锁存器的存在，置零信号会维持一段时间，直到计数脉冲回到低电平，SR锁存器才被置零。</p><p>置位法是通过给计数器重复置入某个数值的方法跳过<span class="math inline">\(N-M\)</span>个状态，从而获得<span class="math inline">\(M\)</span>进制计数器的。其逻辑转换图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132234036.png" alt="置位法" /><figcaption aria-hidden="true">置位法</figcaption></figure><p>下图是一种用置数法构成的电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132257611.png" alt="在S5(0101)时置入0000" /><figcaption aria-hidden="true">在S5(0101)时置入0000</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212132258697.png" alt="在S4(0100)时置入SN-1(1001)" /><figcaption aria-hidden="true">在S4(0100)时置入SN-1(1001)</figcaption></figure></li><li><p><span class="math inline">\(M&gt;N\)</span>时</p><p>应用多片N进制计数器进行组合。如果M可以因式分解成多个小于N的数之和，即：<span class="math inline">\(M=N_1N_2\cdots N_n\)</span>，那么可以把第<span class="math inline">\(i\)</span>片计数器接成<span class="math inline">\(N_i\)</span>进制，然后采用串行进位或者并行进位把他们链接起来。</p><p>串行进位指的是以低位片的进位输出信号作为高位片的时钟信号，如下图是把两个十进制计数器用串行接法接成一个一百进制计数器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261931290.png" alt="串行100进制计数器" /><figcaption aria-hidden="true">串行100进制计数器</figcaption></figure><p>在第9个<span class="math inline">\(CLK\)</span>信号来临时，第一个计数器的状态为<span class="math inline">\(1001\)</span>，进位输出<span class="math inline">\(C\)</span>出现高电平，第二片的时钟信号在低电平；当第10个<span class="math inline">\(CLK\)</span>信号到来时，第一个计数器的状态变为<span class="math inline">\(0000\)</span>，进位输出<span class="math inline">\(C\)</span>输出低电平，第二片的时钟信号出现一个上升沿，第二片的状态变成<span class="math inline">\(0001\)</span>，以此实现进位功能。</p><p>并行进位指的是以低位片的进位输出信号作为高位片的使能信号，两片的时钟同时接<span class="math inline">\(CLK\)</span>输入信号，如下图是把两个十进制计数器用并行接法接成一个一百进制计数器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261935682.png" alt="并行100进制计数器" /><figcaption aria-hidden="true">并行100进制计数器</figcaption></figure><p>在第9个<span class="math inline">\(CLK\)</span>信号来临时，第一个计数器的状态为<span class="math inline">\(1001\)</span>，进位输出<span class="math inline">\(C\)</span>出现高电平，第二片使能开启，开始工作；下个<span class="math inline">\(CLK\)</span>信号来临，第二片正在工作，状态变为<span class="math inline">\(0001\)</span>，第一片的状态变为<span class="math inline">\(0000\)</span>，进位输出低电平，第二片使能关闭。</p><p>如果M是素数，或者不能像这样因式分解，则必须采用整体置零/置数法。</p></li></ol><h4 id="移位寄存器型计数器">移位寄存器型计数器</h4><ol type="1"><li><p>环形计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261939073.png" alt="环形计数器" /><figcaption aria-hidden="true">环形计数器</figcaption></figure><p>有效循环为<span class="math inline">\(1000\to 0100\to0010\to0001\to 1000\)</span>，不能自启动</p></li><li><p>扭环形计数器</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261940589.png" alt="扭环形计数器" /><figcaption aria-hidden="true">扭环形计数器</figcaption></figure><p>其状态转移图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261941367.png" alt="扭环形计数器状态转移图" /><figcaption aria-hidden="true">扭环形计数器状态转移图</figcaption></figure></li></ol><p>用<span class="math inline">\(n\)</span>位移位寄存器构成 环形计数器 可以得到<span class="math inline">\(n\)</span>个状态的有效循环；</p><p>用<span class="math inline">\(n\)</span>位移位寄存器构成 扭环形计数器 可以得到<span class="math inline">\(2n\)</span>个状态的有效循环。</p><h3 id="序列信号发生器">序列信号发生器</h3><h4 id="计数译码型">计数译码型</h4><p>其原理是由一个计数器和一个数据选择器连接，计数器的计数输出连在数据选择器的地址输入上。在数据选择器的信号输入端，预置已知的序列，然后用<span class="math inline">\(CLK\)</span>驱动计数器，数据选择器根据计数器的状态选择要输出的信号。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212261954151.png" alt="计数译码型序列信号发生器" /><figcaption aria-hidden="true">计数译码型序列信号发生器</figcaption></figure><p>如上图，发生的序列是<span class="math inline">\(00010111\)</span>。</p><p>当然，上面的数据选择器也可以换成自己搭建的组合逻辑译码电路（输入计数信号，输出该信号对应的序列的值）</p><h4 id="反馈移位型">反馈移位型</h4><p>其一般电路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262002159.png" alt="反馈移位型序列发生器" /><figcaption aria-hidden="true">反馈移位型序列发生器</figcaption></figure><p>驱动方程为： <span class="math display">\[\begin{aligned}D_0&amp;=F(Q_0,Q_1,\cdots,Q_n)\\D_1&amp;=Q_0\\\cdots\\D_n&amp;=Q_{n-1}\end{aligned}\]</span> 在分析时，完全可以当成一般的同步时序逻辑电路分析，当然也可以用序列发生器的特点简化分析。在分析时，这两者的复杂度区别并不大。</p><p>在设计时，首先需要注意，在一个周期内状态编码不能重复；然后根据序列长度<span class="math inline">\(n\)</span>使用<span class="math inline">\(\log _2 n\)</span>个<span class="math inline">\(D\)</span>触发器。接下来以一个例子说明设计过程：</p><p>【例】设计反馈移位型序列发生器，序列为<span class="math inline">\(\{1111\ 0101\ 1001\ 000\}\)</span>（右侧的先出现）。</p><ol type="1"><li><p>检查是否有重复和确定触发器数目：</p><p>应用四个触发器</p></li><li><p>确定输出信号的位置</p><p>一般来说，选取最后一个触发器的输出端，即<span class="math inline">\(Q_3\)</span></p></li><li><p>设计组合逻辑反馈电路</p><p>这里，实际上就是要求写出<span class="math inline">\(D_0\)</span>和<span class="math inline">\(Q_3,Q_2,Q_1,Q_0\)</span>的函数关系式。</p><p>首先列出表，在<span class="math inline">\(Q_3\)</span>里填入要输出的序列：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262022013.png" /></p><p>然后因为“移位”的特点，把<span class="math inline">\(Q_3\)</span>整体向上提一格，填入<span class="math inline">\(Q_2\)</span>；把<span class="math inline">\(Q_2\)</span>整体往上提一格，填入<span class="math inline">\(Q_1\)</span>；......把<span class="math inline">\(Q_0\)</span>整体往上提一格填入<span class="math inline">\(D_0\)</span>（这里的“往上提”是含有循环意味的）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262025544.png" /></p><p>于是，我们就得到了逻辑关系表，然后画卡诺图化简，连电路就行了。</p></li><li><p>最终结果 <span class="math display">\[D_0=Q_0 \overline{Q_3}+\overline{Q_0} Q_3=Q_0\bigoplus Q_3\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212262028019.png" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路·模拟之章</title>
    <link href="/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E6%A8%A1%E6%8B%9F%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/22/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%C2%B7%E6%A8%A1%E6%8B%9F%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>为什么叫模拟之章呢？是因为这篇主要是涉及模拟电路的部分。</p><span id="more"></span><h2 id="门电路">门电路</h2><h3 id="cmos门电路">CMOS门电路</h3><p>要研究CMOS门电路，首先要认识MOS器件以及它们的特性。</p><h4 id="mos管的基本概念">MOS管的基本概念</h4><p>MOS管全名叫“结型场效应晶体管”，我们平常见到的有以下四种</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161943768.png" alt="常见MOS管符号" /><figcaption aria-hidden="true">常见MOS管符号</figcaption></figure><p>注意看：箭头方向决定是N还是P，线的虚实决定是增强还是耗尽。</p><p>MOS管的符号也有简化画法，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161944750.png" alt="MOS管符号的简化画法" /><figcaption aria-hidden="true">MOS管符号的简化画法</figcaption></figure><p>它们的特性按P、N和增强、耗尽，有所不同：</p><ul><li><strong>N沟道</strong>的，当<span class="math inline">\(V_{GS}\)</span>接足够大的正向电压时，<span class="math inline">\(DS\)</span>之间相当于联通。<strong>P沟道</strong>的，当<span class="math inline">\(V_{GS}\)</span>之间接足够大的反向电压，<span class="math inline">\(DS\)</span>之间相当于导通。</li><li><strong>增强型</strong>，开启电压为正。以<span class="math inline">\(N\)</span>沟道为例，当<span class="math inline">\(V_{GS}&gt;V_{GS(th)}&gt;0\)</span>时，<span class="math inline">\(DS\)</span>之间才能相当于联通。<strong>耗尽型</strong>，截止电压为负。以<span class="math inline">\(N\)</span>沟道为例，只要<span class="math inline">\(V&gt;V_{GS(off)}\)</span>，其中<span class="math inline">\(V_{GS(off)}&lt;0\)</span>，<span class="math inline">\(DS\)</span>之间就能导通，也就是说为了让N沟道耗尽型的DS之间不再导通，<span class="math inline">\(V_{GS}\)</span>需要一个足够大的负值电压才行。</li></ul><p>为了加深对这个特性的理解，我们来分析一下下面这个电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161954418.png" alt="未知的CMOS门电路" /><figcaption aria-hidden="true">未知的CMOS门电路</figcaption></figure><p>约定：<span class="math inline">\(V_{DD}\)</span>大于两管开启电源绝对值之和。</p><ul><li>当<span class="math inline">\(V_i=0\)</span>（接低电平）时，<span class="math inline">\(T_1\)</span>P沟道增强型MOS管的<span class="math inline">\(V_{GS}=-V_{DD}&lt;V_{GS(th)P}\)</span>，于是<span class="math inline">\(T_1\)</span>两端相当于连通，<span class="math inline">\(V_o=V_{DD}\)</span>，输出高电平。此时<span class="math inline">\(T_2\)</span>截止，两端相当于断路。</li><li>当<span class="math inline">\(V_i=V_{DD}\)</span>（接低电平）时，<span class="math inline">\(T_2\)</span>N沟道增强型MOS管的<span class="math inline">\(V_{GS}=V_{DD}&gt;V_{GS(th)N}\)</span>，于是<span class="math inline">\(T_2\)</span>导通，<span class="math inline">\(V_o\)</span>输出地（0V），此时<span class="math inline">\(T_1\)</span>截止，两端相当于断路。</li><li>综上所述，这是个非门。</li></ul><h4 id="经典门电路的mos管实现">经典门电路的MOS管实现</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162009771.png" alt="MOS门电路" /><figcaption aria-hidden="true">MOS门电路</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162009164.png" alt="MOS门电路" /><figcaption aria-hidden="true">MOS门电路</figcaption></figure><p>对于CMOS器件构成的门电路，不允许输入端悬空，输入端经电阻接地时和低电平等效，输入端经电阻接电源时和高电平等效。</p><h4 id="od门">OD门</h4><p>OD门全称为漏极开关输出门电路，它的电路长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162017294.png" alt="OD与非门电路详图" /><figcaption aria-hidden="true">OD与非门电路详图</figcaption></figure><p>其逻辑符号为门电路符号里面加一个带下划线的菱形，如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162018140.png" alt="OD与非门逻辑符号" /><figcaption aria-hidden="true">OD与非门逻辑符号</figcaption></figure><p>OD门要正常工作，必须把输出端经过一个上拉电阻和电源相连。也就是电路详图中的<span class="math inline">\(R_L\)</span>，这样一来，输出的高电平具体是几伏，就取决于<span class="math inline">\(V_{DD2}\)</span>而不是<span class="math inline">\(V_{DD1}\)</span>了。</p><p>把多个OD门的输出端直接接在一起，可以构成“线与”逻辑，如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162022900.png" alt="线与接法" /><figcaption aria-hidden="true">线与接法</figcaption></figure><p>这时，有<span class="math inline">\(Y=Y_1Y_2\)</span>。有时，线与的与门符号省略，直接用圆点表示。</p><p>在选取<span class="math inline">\(R_L\)</span>时，应该注意以下原则：</p><ol type="1"><li><p><span class="math inline">\(R_L\)</span>不能太大，以保证<span class="math inline">\(V_{DD}-V_{R_L}\geq V_{OH}\)</span>。在这个条件下，有： <span class="math display">\[R_{\mathrm{L}}\leq\frac{V_{\mathrm{DD}}-V_{\mathrm{OH}}}{n \cdot I_{\mathrm{OH}}+m \cdot I_{\mathrm{IH}}}\]</span> 这里的<span class="math inline">\(V_{DD}\)</span>当然是<span class="math inline">\(R_L\)</span>连接的那个电源，其中<span class="math inline">\(n\)</span>是OD门的数目，<span class="math inline">\(m\)</span>是下一级输入端的数目（比如说，一个与非门一般有两个输入端），<span class="math inline">\(I_{OH}\)</span>是OD门截止时的漏电流，<span class="math inline">\(I_{IH}\)</span>是负载门每个输入端的高电平输入电流</p></li><li><p><span class="math inline">\(R_L\)</span>不能过小，以保证“灌入”的负载电流不大于单只OD门可承受的输入电流。有： <span class="math display">\[R_{\mathrm{L}} \geq \frac{V_{\mathrm{DD}}-V_{\mathrm{OL}}}{I_{\mathrm{OL}(\mathrm{OD})}-m \cdot I_{\mathrm{IL}}}\]</span> <span class="math inline">\(m\)</span>是下一级输入端的数目。</p></li></ol><h4 id="传输门">传输门</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162030714.png" alt="CMOS传输门电路和逻辑符号" /><figcaption aria-hidden="true">CMOS传输门电路和逻辑符号</figcaption></figure><p>其特性为：</p><ul><li><span class="math inline">\(C\)</span>接高电平而<span class="math inline">\(\overline{C}\)</span>接低电平，<span class="math inline">\(V_o=V_i\)</span>，相当于信号直接通过</li><li><span class="math inline">\(C\)</span>接低电平而<span class="math inline">\(\overline{C}\)</span>接高电平，相当于中间的电路断开，输出是高阻态。</li></ul><h4 id="三态门">三态门</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162032490.png" alt="三态门符号" /><figcaption aria-hidden="true">三态门符号</figcaption></figure><p>三态门是一个正常的门电路外加一个<span class="math inline">\(EN\)</span>信号，里面画一个倒三角。当<span class="math inline">\(EN\)</span>为有效信号（上图是低电平有效，也就是<span class="math inline">\(EN=0\)</span>）时，门电路正常工作，否则，输出高阻态。</p><h3 id="ttl门电路">TTL门电路</h3><p>我也不会分析，所以分析略。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162040271.png" /></p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211162040028.png" /></p><p>这里这个OC门（集电极开路输出的门电路）就和前面那个OD门意思差不多，也有线与，也得算<span class="math inline">\(R_L\)</span>的范围。不同的是，当输出端含有与非门时，要按与非门的门数计算，而不是端数。</p><p>对于TTL门电路，输入端悬空等效于逻辑高电平；输入端经过几十千欧以内的电阻接电源，等效于逻辑高电平；输入端经过几十欧的小电阻接地等效于低电平，当电阻升高到一定程度（一般是几千欧）以后，等效为高电平。</p><h2 id="脉冲波形的产生和整形电路">脉冲波形的产生和整形电路</h2><h3 id="施密特触发器">施密特触发器</h3><p>施密特触发器是脉冲波形变换中的常用电路。它具有以下两个特点：</p><ol type="1"><li>输入信号本来是低电平，上升的过程中电路状态发生转换时对应的输入电平，和输入信号本来是高电平，下降的过程中电路状态发生转换时对应的输入电平不相等</li><li>在电路状态变化的过程中，电路内存在正反馈过程，从而使得电压波形非常陡峭</li></ol><p>施密特触发器的电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221543571.png" alt="施密特触发器" /><figcaption aria-hidden="true">施密特触发器</figcaption></figure><p>当<span class="math inline">\(v_1\)</span>从0开始逐渐上升，使得<span class="math inline">\(v_A=V_{TH}\)</span>时，<span class="math inline">\(G_1\)</span>门的输出端<span class="math inline">\(v_{O1}\)</span>下降，变成低电平，于是<span class="math inline">\(G_2\)</span>门的输出端<span class="math inline">\(v_O\)</span>抬升，变成高电平。因为对<span class="math inline">\(v_1-R_1-R_2-v_O\)</span>回路，有 <span class="math display">\[v_A=v_1-(v_1-v_O)\frac{R_1}{R_1+R_2}\]</span> 抬升的<span class="math inline">\(v_O\)</span>通过电阻<span class="math inline">\(R_2\)</span>反作用于<span class="math inline">\(v_A\)</span>，使得<span class="math inline">\(v_A\)</span>继续上升。于是，<span class="math inline">\(v_O\)</span>迅速地达到高电平<span class="math inline">\(V_{DD}\)</span>。</p><p>在上述过程中，状态转换发生的瞬间，此时<span class="math inline">\(v_o\)</span>还是低电平<span class="math inline">\(0\)</span>，有： <span class="math display">\[v_A=\frac{R_2}{R_1+R_2}V_{T+}=V_{TH}\]</span> 解得 <span class="math display">\[V_{T+}=\left(1+\frac {R_1}{R_2}\right)V_{TH}\]</span> 其中<span class="math inline">\(V_{T+}\)</span>是施密特触发器上升过程中电路状态转换瞬间对应的输入电平，<span class="math inline">\(V_{TH}\)</span>是逻辑门高低电平的分界线。</p><p>同理，当<span class="math inline">\(v_1\)</span>从高电平<span class="math inline">\(V_{DD}\)</span>开始下降，直到<span class="math inline">\(v_A=V_{TH}\)</span>时，<span class="math inline">\(G_1\)</span>门的输出端<span class="math inline">\(v_{O1}\)</span>抬升，变成高电平，于是<span class="math inline">\(G_2\)</span>门的输出端<span class="math inline">\(v_{O}\)</span>下降，根据上面的式子，下降的<span class="math inline">\(v_O\)</span>作用于<span class="math inline">\(v_A\)</span>形成正反馈，使得<span class="math inline">\(v_A\)</span>继续下降，于是<span class="math inline">\(v_O\)</span>迅速地达到0.</p><p>同样，有： <span class="math display">\[v_A=V_{T-}-(V_{T-}-V_{DD})\frac{R_1}{R_1+R_2}\]</span> 解得： <span class="math display">\[V_{T-}=\left(1-\frac{R_1}{R_2}\right)V_{TH}\]</span> 其中<span class="math inline">\(V_{T-}\)</span>是施密特触发器下降过程中电路状态转换瞬间对应的输入电平。</p><p>于是，可以得到施密特触发器的电压传输特性：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221613215.png" alt="电压传输特性" /><figcaption aria-hidden="true">电压传输特性</figcaption></figure><p>中间的部分叫做回差电压： <span class="math display">\[\Delta V_T=V_{T+}-V_{T-}=2\frac{R_1}{R_2}V_{TH}\]</span> 如果施密特触发器要正常工作，那么<span class="math inline">\(R_1&lt;R_2\)</span>，否则会发生互锁。</p><p>施密特触发器的电路符号如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221620747.png" alt="施密特触发器的符号" /><figcaption aria-hidden="true">施密特触发器的符号</figcaption></figure><p>上面的同相输出，下面的是反相输出。</p><h3 id="单稳态电路">单稳态电路</h3><p>单稳态电路具有以下特点：</p><ol type="1"><li>具有稳态、暂稳态两个不同的工作状态</li><li>在外界脉冲的触发下，从稳态进入暂稳态，并在暂稳态停留一段时间后恢复稳态。这段时间的长度只和电路本身的参数有关，和触发脉冲的持续时间，强度无关。</li></ol><p>这个工作特性可以类比声控灯，触发脉冲就是声音，无论你拍个手，还是长时间地播放声音，无论声音多大，只要能触发，它一次就亮那么长时间。</p><h4 id="微分型单稳态电路">微分型单稳态电路</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221652036.png" alt="微分型单稳态电路图" /><figcaption aria-hidden="true">微分型单稳态电路图</figcaption></figure><p>如图，微分型单稳态电路由一些电阻、电容、或非门和非门构成。其前级由<span class="math inline">\(C_d-R_d\)</span>构成一个微分电路，环路内由<span class="math inline">\(C-R\)</span>构成一个微分电路。</p><p>输入端本来是低电平，当向输入端<span class="math inline">\(v_I\)</span>加入一个脉冲时，因为<span class="math inline">\(C_d\)</span>两端电压不可以突变，所以<span class="math inline">\(v_d\)</span>会被拉高，于是<span class="math inline">\(R_d\)</span>上产生一个向下的电流，负电荷流向<span class="math inline">\(C_d\)</span>，<span class="math inline">\(C_d\)</span>开始充电，<span class="math inline">\(v_d\)</span>开始下降。总的来说，微分电路<span class="math inline">\(C_d-R_d\)</span>会产生一个尖刺，就像下图一样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221710310.png" alt="vd随vi的变化" /><figcaption aria-hidden="true">vd随vi的变化</figcaption></figure><p>当<span class="math inline">\(v_d\)</span>上升达到<span class="math inline">\(V_{TH}\)</span>时，<span class="math inline">\(v_{O1}\)</span>会下降的低电平，因为<span class="math inline">\(C\)</span>两端的电压差不能突变，于是<span class="math inline">\(v_{I2}\)</span>也跟着下降到低电平，于是<span class="math inline">\(v_O\)</span>跳变到高电平，电路进入了暂稳态。</p><p>这时，<span class="math inline">\(R\)</span>上产生了向下的电流，正电荷流入<span class="math inline">\(C\)</span>，电容<span class="math inline">\(C\)</span>开始充电。随着充电的进行，<span class="math inline">\(v_{I2}\)</span>逐渐抬升，直到其抬升到<span class="math inline">\(V_{TH}\)</span>，此时<span class="math inline">\(v_O\)</span>下降为低电平，低电平反馈回<span class="math inline">\(G_1\)</span>（因为此时<span class="math inline">\(v_d\)</span>已经回到低电平），使得<span class="math inline">\(v_{O1}\)</span>抬升为高电平，进而使得<span class="math inline">\(v_{I2}\)</span>抬升。此时，电容<span class="math inline">\(C\)</span>通过电阻<span class="math inline">\(R\)</span>和门<span class="math inline">\(G_2\)</span>的输入保护电路向<span class="math inline">\(V_{DD}\)</span>放电，直至电容上的电压为<span class="math inline">\(0\)</span>，电路恢复稳态。</p><p>全过程的电压波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221728138.png" alt="全过程电压波形" /><figcaption aria-hidden="true">全过程电压波形</figcaption></figure><p>我们考察<span class="math inline">\(R-C\)</span>回路充电的过程。从充电开始到变化到<span class="math inline">\(V_{TH}\)</span>的耗时为： <span class="math display">\[t=RC\ln \frac{v_c(\infty)-v_c(0)}{v_c(\infty)-V_{TH}}\]</span> 把<span class="math inline">\(v_c(\infty)=V_{DD}\)</span>带入，有： <span class="math display">\[t_w=RC\ln 2=0.69RC\]</span> 这就是暂稳态持续的时间。</p><p>当<span class="math inline">\(v_o\)</span>恢复稳态后，<span class="math inline">\(C\)</span>还要经历一个放电的过程。放电的时间为： <span class="math display">\[t_{re}=(3\sim 5)R_{ON}C\]</span> 其中<span class="math inline">\(R_{ON}\)</span>是<span class="math inline">\(G_1\)</span>的输出电阻。整个电路两个相邻触发脉冲的最小时间间隔为 <span class="math display">\[t_d=t_w+t_{re}\]</span></p><h4 id="积分型">积分型</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221749651.png" alt="积分型单稳态电路图" /><figcaption aria-hidden="true">积分型单稳态电路图</figcaption></figure><p>如图是用与非门、非门、积分电路构成的积分型单稳态电路。</p><p>当输入正脉冲时，<span class="math inline">\(v_{O1}\)</span>变成低电平，但是因为<span class="math inline">\(C\)</span>两端的电压不能突变，所以<span class="math inline">\(v_A\)</span>仍然维持在高电平。<span class="math inline">\(G_2\)</span>的输入端是两个高电平，<span class="math inline">\(v_O\)</span>输出低电平，电路进入暂稳态。</p><p>此时，电容开始放电。随着电容的放电，<span class="math inline">\(v_A\)</span>不断降低，直到低过<span class="math inline">\(v_{TH}\)</span>。此时，与非门的其中一个输入变成低电平，<span class="math inline">\(v_O\)</span>回到高电平。等到输入端的脉冲结束以后，<span class="math inline">\(v_{O1}\)</span>又变成高电平，给电容充电，经过一段时间以后，电容充满电，电路恢复稳态。</p><p>全过程电压波形图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212221949659.png" alt="全过程电压波形" /><figcaption aria-hidden="true">全过程电压波形</figcaption></figure><p>在计算电容放电过程时，有放电等效电路：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222001589.png" alt="放电等效电路" /><figcaption aria-hidden="true">放电等效电路</figcaption></figure><p>放电时，相当于<span class="math inline">\(R\)</span>和<span class="math inline">\(R_O\)</span>串联，有： <span class="math display">\[t_=\left(R+R_{\mathrm{O}}\right) C \ln \frac{V_{\mathrm{OL}}-V_{\mathrm{OH}}}{V_{\mathrm{OL}}-V_{\mathrm{TH}}}\]</span> 充电时，有： <span class="math display">\[t_{re}=(3\sim 5)(R+R_O&#39;)C\]</span> 整个电路两个相邻触发脉冲的最小时间间隔为： <span class="math display">\[t_d=t_w+t_{re}\]</span></p><h3 id="多谐振荡器">多谐振荡器</h3><h4 id="对称式多谐振荡器">对称式多谐振荡器</h4><p>对称式多谐振荡器的电路图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222144835.png" alt="对称式多谐振荡器" /><figcaption aria-hidden="true">对称式多谐振荡器</figcaption></figure><p>那么有人就说了：这也不对称啊？其实，它可以画成这样的形式：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222145042.png" alt="“对称”式多谐振荡器" /><figcaption aria-hidden="true">“对称”式多谐振荡器</figcaption></figure><p>对称式多谐振荡器是没有“稳态”的，<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>被反馈电阻偏置到放大状态。在一开始的“不平衡稳定态”，门工作在转折区，有：<span class="math inline">\(v_{I1}=v_{O1}=v_{I2}=v_{O2}\)</span>。</p><p>现在，因为某些原因，给<span class="math inline">\(v_{I1}\)</span>上加一个微小的扰动，使其有一个正跳变。那么，<span class="math inline">\(v_{O1}\)</span>会下降，因为电容<span class="math inline">\(C_1\)</span>的存在，<span class="math inline">\(v_{I2}\)</span>跟着一起下降，于是<span class="math inline">\(v_{O2}\)</span>上升，经过电容<span class="math inline">\(C_2\)</span>而继续带动<span class="math inline">\(v_{I1}\)</span>的上升，进入一个正反馈过程，此时电路进入了暂稳态。</p><p>需要注意的一点是，在接下来的分析里，我们要明确哪些电压是有外界电源保持的，哪些电压是纯数字（只有两个状态的），哪些电压是没有外界电源保持的，哪些电压是模拟（可以连续变化的）。因为这样才能知道是谁在对谁充电、画波形图时也比较方便。</p><p>有外界电源保持的电压，是纯数字的，作为门的输出端口电压出现；没有外界电源保持的电压，是模拟的，作为门的输入端口的形式出现。</p><p>对于<span class="math inline">\(C_1\)</span>，因为<span class="math inline">\(v_{O2}\)</span>上升而<span class="math inline">\(v_{I2}\)</span>下降，电流从<span class="math inline">\(R_{F2}\)</span>流入<span class="math inline">\(C_1\)</span>，对其进行充电。这时，实际上是<span class="math inline">\(G_2\)</span>的外接电源通过<span class="math inline">\(v_{O2}\)</span>，来对<span class="math inline">\(C_1\)</span>进行充电。此外，流入<span class="math inline">\(C_1\)</span>的还有门<span class="math inline">\(G_2\)</span>输入级的电流。因为<span class="math inline">\(v_{O1}\)</span>是有外界电源保持的，所以充电的效果是：<span class="math inline">\(v_{I2}\)</span>缓慢抬升。</p><p>对于<span class="math inline">\(C_2\)</span>，因为<span class="math inline">\(v_{I1}\)</span>上升而<span class="math inline">\(v_{O1}\)</span>下降，<span class="math inline">\(C_2\)</span>向电阻<span class="math inline">\(R_{F1}\)</span>放电。因为一开始给了<span class="math inline">\(v_{I1}\)</span>的一个向上的微扰，当<span class="math inline">\(v_{O2}\)</span>反馈回来时，<span class="math inline">\(v_{I1}&gt;v_{O2}\)</span>，但是<span class="math inline">\(v_{I1}\)</span>是没有外界电源保持的，因此<span class="math inline">\(C_2\)</span>会放电，把<span class="math inline">\(v_{I1}\)</span>放下去。于是，放电的效果就是<span class="math inline">\(v_{I1}\)</span>缓慢下降。那么有人就问了，既然一开始的所谓“不稳定的平衡态”，这四个电压都一样，<span class="math inline">\(C_2\)</span>上本来就没有电。那么<span class="math inline">\(C_2\)</span>放电的“电”来自于何处呢？是来自于<span class="math inline">\(v_{I1}\)</span>一开始的正跳变后引发的正反馈过程。</p><p>电路的充放电回路示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222158087.png" alt="充放电回路示意图" /><figcaption aria-hidden="true">充放电回路示意图</figcaption></figure><p>接下来，我们详细分析一下充放电过程。</p><p>对于<span class="math inline">\(C_1\)</span>:</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222218443.png" alt="C1充电等效回路" /><figcaption aria-hidden="true">C1充电等效回路</figcaption></figure><p>由戴维南定理，首先把所有电源接地，看进去等效于两个电阻并联，于是有： <span class="math display">\[R_{\mathrm{E} 1}=\frac{R_1 R_{\mathrm{F} 2}}{R_1+R_{\mathrm{F} 2}}\]</span> 接着运用叠加定理，或者说以<span class="math inline">\(V_{OH2}\)</span>为基准进行分析，得到等效电源： <span class="math display">\[V_{\mathrm{E} 1}=V_{\mathrm{OH}}+\frac{R_{\mathrm{F} 2}}{R_1+R_{\mathrm{F} 2}}\left(V_{\mathrm{CC}}-V_{\mathrm{OH}}-V_{\mathrm{BE}}\right)\]</span> 对于<span class="math inline">\(C_2\)</span>:</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222221917.png" alt="C2放电等效回路" /><figcaption aria-hidden="true">C2放电等效回路</figcaption></figure><p>因为同时有两个电源伺候<span class="math inline">\(C_1\)</span>，所以它冲的比较快，<span class="math inline">\(v_{I2}\)</span>抢先一步达到<span class="math inline">\(V_{TH}\)</span>，此时<span class="math inline">\(v_{O2}\)</span>下降为低电平，连带着<span class="math inline">\(v_{I1}\)</span>一起下降，然后通过<span class="math inline">\(G_1\)</span>使得<span class="math inline">\(v_{O_1}\)</span>上升。<span class="math inline">\(v_{O1}\)</span>的上升又通过电容<span class="math inline">\(C_1\)</span>传递给<span class="math inline">\(v_{I2}\)</span>，此时，电路进入第二个暂稳态，<span class="math inline">\(C_2\)</span>开始充电使得<span class="math inline">\(v_{I2}\)</span>下降，<span class="math inline">\(C_1\)</span>开始放电使得<span class="math inline">\(v_{I_1}\)</span>上升。从开始到<span class="math inline">\(v_{I2}\)</span>达到<span class="math inline">\(V_{TH}\)</span>的时间为： <span class="math display">\[T_1=R_{\mathrm{E} 1} C_1 \ln \frac{V_{\mathrm{E} 1}-V_{\mathrm{IK}}}{V_{\mathrm{E} 1}-V_{\mathrm{TH}}}\]</span> 因为还是有两个电源伺候<span class="math inline">\(C_2\)</span>，所以这次轮到<span class="math inline">\(v_{I1}\)</span>先上升到<span class="math inline">\(V_{TH}\)</span>，使得<span class="math inline">\(v_{O1}\)</span>下降到低电平，因为电容<span class="math inline">\(C_1\)</span>的存在，<span class="math inline">\(v_{I2}\)</span>跟着一起下降，于是<span class="math inline">\(v_{O2}\)</span>上升，经过电容<span class="math inline">\(C_2\)</span>而继续带动<span class="math inline">\(v_{I1}\)</span>的上升，又回到了第一个暂稳态。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212222234255.png" alt="电压波形图" /><figcaption aria-hidden="true">电压波形图</figcaption></figure><h4 id="非对称式多谐振荡器">非对称式多谐振荡器</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231056601.png" alt="非对称式多谐振荡器" /><figcaption aria-hidden="true">非对称式多谐振荡器</figcaption></figure><p>非对称式多谐振荡器如上图所示，相比于对称式，非对称式少了一个电容、一个反馈电阻，多了一个<span class="math inline">\(R_p\)</span>的<span class="math inline">\(G_1\)</span>输入端保护电阻。静态时，<span class="math inline">\(G_1,G_2\)</span>工作在电压传输特性图的中点（转折区），即<span class="math inline">\(v_{I1}=v_{O1}=v_{I2}=v_{O2}=V_{DD}/2\)</span>。其中<span class="math inline">\(v_{O1}\equiv v_{I2}\)</span>和<span class="math inline">\(v_{O}\)</span>是有外界电源保持的数字信号，而<span class="math inline">\(v_{I1}\)</span>是没有外界电源保持的模拟信号。</p><p>由于某种扰动，使得<span class="math inline">\(v_{I1}\)</span>上升，那么<span class="math inline">\(v_{O1}\)</span>下降，<span class="math inline">\(v_{O2}\)</span>上升，通过电容<span class="math inline">\(C\)</span>反过来作用到<span class="math inline">\(v_{I1}\)</span>使其继续上升，进入了正反馈过程。当<span class="math inline">\(v_{O2}\)</span>提升到高电平<span class="math inline">\(V_{DD}\)</span>，<span class="math inline">\(v_{I1}\)</span>提升到<span class="math inline">\(V_{TH}+V_{DD}\)</span>时，电路进入第一个暂稳态。</p><p>在第一个暂稳态，电容<span class="math inline">\(C\)</span>经过<span class="math inline">\(R_F\)</span>把电放到<span class="math inline">\(G_1\)</span>门的地中，放电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231114936.png" alt="放电回路" /><figcaption aria-hidden="true">放电回路</figcaption></figure><p>因为<span class="math inline">\(R_F\)</span>远大于<span class="math inline">\(R_{ON}\)</span>，有： <span class="math display">\[t=R C \ln \frac{v_R(\infty)-v_R(0)}{v_R(\infty)-v_R(t)}\]</span> 由终了态电容等效于断路，得<span class="math inline">\(v_R(\infty)=0\)</span>，第一暂稳态将在<span class="math inline">\(v_R=V_{TH}\)</span>时发生改变，得： <span class="math display">\[\begin{aligned}T_1 &amp; \approx R_{\mathrm{F}} C \ln \frac{0-\left(V_{\mathrm{TH}}+V_{\mathrm{DD}}\right)}{0-V_{\mathrm{TH}}} \\&amp; =R_{\mathrm{F}} C \ln 3\end{aligned}\]</span> 当<span class="math inline">\(v_{I1}=v_R(t)\)</span>下降到<span class="math inline">\(V_{TH}\)</span>时，<span class="math inline">\(v_{O1}\)</span>拉高，<span class="math inline">\(v_{O2}\)</span>降低，反过来作用于<span class="math inline">\(v_{I1}\)</span>使得它继续下降，<span class="math inline">\(v_{I1}\)</span>下降到<span class="math inline">\(V_{TH}-V_{DD}\)</span>时，电路进入第二暂稳态。为什么之前对称的多谐振荡器只能下降到<span class="math inline">\(V_{IK}\)</span>，而这里却能下降到<span class="math inline">\(V_{TH}-V_{DD}\)</span>呢？是因为有<span class="math inline">\(R_p\)</span>的存在.</p><p>这时，电容<span class="math inline">\(C\)</span>进行充电，<span class="math inline">\(v_{I1}\)</span>开始上升，充电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231132758.png" alt="充电回路" /><figcaption aria-hidden="true">充电回路</figcaption></figure><p>计算充电时间，有： <span class="math display">\[\begin{aligned}T_2 &amp; \approx R_{\mathrm{F}} C \ln \frac{V_{\mathrm{DD}}-\left(V_{\mathrm{TH}}-V_{\mathrm{DD}}\right)}{V_{\mathrm{DD}}-V_{\mathrm{TH}}} \\&amp; =R_{\mathrm{F}} C \ln 3\end{aligned}\]</span> 当电容冲电，<span class="math inline">\(v_{I1}\)</span>上升到<span class="math inline">\(V_{TH}\)</span>后，电路又会回到第一暂稳态，如此循环，于是，一个循环的周期是： <span class="math display">\[T=T_1+T_2=R_FC\cdot 2\ln 3\]</span></p><h4 id="环形振荡电路">环形振荡电路</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231448009.png" alt="基本环形振荡电路" /><figcaption aria-hidden="true">基本环形振荡电路</figcaption></figure><p>上图是基本环形振荡电路，由3个非门首尾相连构成，利用非门之间的传输延时<span class="math inline">\(t_{pd}\)</span>来进行振荡，它的周期是 <span class="math display">\[T=2nt_{pd}\]</span> 但是这个周期太短了，而且不可控，于是可以通过加阻容的方式增大这个延时：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231450308.png" alt="实用环形振荡器" /><figcaption aria-hidden="true">实用环形振荡器</figcaption></figure><p>当<span class="math inline">\(v_{I2}\)</span>发生负跳变时，这个负跳变由电容<span class="math inline">\(C\)</span>传递到<span class="math inline">\(v_{I3}\)</span>，使得<span class="math inline">\(v_{I3}\)</span>也被下拉。但是<span class="math inline">\(G_2\)</span>的输出口上呈现出高电平，于是电容开始充电直到达到<span class="math inline">\(V_{TH}\)</span>。电容的充电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231454667.png" alt="充电回路" /><figcaption aria-hidden="true">充电回路</figcaption></figure><p>主要是由<span class="math inline">\(V_{OH2}\)</span>和<span class="math inline">\(G_3\)</span>的外接电源<span class="math inline">\(V_{CC}\)</span>来对<span class="math inline">\(C\)</span>进行充电的。有： <span class="math display">\[R_E=\frac{R(R_1+R_s)}{R+R_1+R_s}\]</span></p><p><span class="math display">\[V_E=V_{OH}+(V_{CC}-V_{BE}-V_{OH})\frac{R}{R+R_1+R_s}\]</span></p><p>因此，从<span class="math inline">\(v_{I3}=V_{TH}-V_{OH}+V_{OL}\)</span>充电到<span class="math inline">\(V_{TH}\)</span>的时间为： <span class="math display">\[T_1=R_{\mathrm{E}} C \ln \frac{V_{\mathrm{E}}-\left[V_{\mathrm{TH}}-\left(V_{\mathrm{OH}}-V_{\mathrm{OL}}\right)\right]}{V_{\mathrm{E}}-V_{\mathrm{TH}}}\]</span> <span class="math inline">\(v_{I3}\)</span>达到<span class="math inline">\(V_{TH}\)</span>以后，引发<span class="math inline">\(G_3\)</span>输出端<span class="math inline">\(v_{O},v_{I1}\)</span>跳变到低电平，<span class="math inline">\(v_{I2}\)</span>跳变到高电平，进一步拉高<span class="math inline">\(v_{I3}\)</span>到<span class="math inline">\(V_{TH}+V_{OH}-V_{OL}\)</span>，然后<span class="math inline">\(C\)</span>开始放电，放电回路如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231506341.png" alt="放电回路" /><figcaption aria-hidden="true">放电回路</figcaption></figure><p>放电时间为： <span class="math display">\[T_2=R C \ln \frac{V_{\mathrm{OL}}-\left[V_{\mathrm{TH}}+\left(V_{\mathrm{OH}}-V_{\mathrm{OL}}\right)\right]}{V_{\mathrm{OL}}-V_{\mathrm{TH}}}\]</span> 充放电时间之和即为振荡周期，有： <span class="math display">\[T=T_1+T_2 \approx R C \ln \left(\frac{2 V_{\mathrm{OH}}-V_{\mathrm{TH}}}{V_{\mathrm{OH}}-V_{\mathrm{TH}}} \cdot \frac{V_{\mathrm{OH}}+V_{\mathrm{TH}}}{V_{\mathrm{TH}}}\right)\]</span> 这里约等于的条件是<span class="math inline">\(R_1+R_s&gt;&gt;R,V_{OL}=0\)</span>，进而<span class="math inline">\(V_E=V_{OH},R_E=R\)</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231520051.png" alt="波形图" /><figcaption aria-hidden="true">波形图</figcaption></figure><h4 id="施密特触发器多谐振荡器">施密特触发器多谐振荡器</h4><p>其原理是让电压在施密特触发器的滞回线<span class="math inline">\(V_{T+},V_{T-}\)</span>之间来回摆动，在输出端得到矩形波，</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231515840.png" alt="基本电路" style="zoom:33%;" /></p><p>一开始，<span class="math inline">\(v_I=0\)</span>，输出<span class="math inline">\(v_O\)</span>是高电平，通过<span class="math inline">\(R\)</span>向<span class="math inline">\(C\)</span>充电。设<span class="math inline">\(V_{OH}=V_{DD},V_{OL}=0\)</span>，充电时间为： <span class="math display">\[T_0=RC\ln \frac{V_{DD}}{V_{DD-V_{T+}}}\]</span> 达到<span class="math inline">\(V_{T+}\)</span>后，<span class="math inline">\(v_{O}\)</span>转化为低电平，<span class="math inline">\(C\)</span>开始放电，放电时间为： <span class="math display">\[T_2=RC\ln \frac{V_{T+}}{V_{T-}}\]</span> 放到<span class="math inline">\(V_{T-}\)</span>后，<span class="math inline">\(v_O\)</span>再次变成高电平，<span class="math inline">\(C\)</span>又开始充电，有： <span class="math display">\[T_1=R C \ln \left(\frac{V_{\mathrm{DD}}-V_{\mathrm{T}-}}{V_{\mathrm{DD}}-V_{\mathrm{T}+}}\right)\]</span> 系统周期振荡的周期为 <span class="math display">\[T=T_1+T_2\]</span> 占空比为 <span class="math display">\[p=\frac {T_1}{T}\]</span> 于是，只要我们通过两个二极管，使得电容充放电时的时间常数不同，就能控制占空比了，改进电路如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231521147.png" alt="image-20221223152142047" style="zoom:33%;" /></p><p>波形图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212231522032.png" alt="施密特振荡器波形图" /><figcaption aria-hidden="true">施密特振荡器波形图</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波技术·路之章</title>
    <link href="/2022/12/17/%E5%BE%AE%E6%B3%A2%C2%B7%E8%B7%AF%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/17/%E5%BE%AE%E6%B3%A2%C2%B7%E8%B7%AF%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="微波网络">微波网络</h2><p>微波网络研究的对象是微波系统中的“不均匀区”（也叫微波结），如下图所示，可以由左图等效为右图分析问题</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212051713899.png" alt="微波网络" /><figcaption aria-hidden="true">微波网络</figcaption></figure><p>其基本思想是：把单模波导等效为双导线，把各种微波元件等效为微波网络。</p><h3 id="单模波导等效为双导线">单模波导等效为双导线</h3><ol type="1"><li><p>等效复功率、电压、电流</p><p>如果用电磁场表示的复功率，和用电压电流表示的复功率相等，有： <span class="math display">\[\dot{P}=\frac{1}{2} \int_S\left(\dot{\vec{E}}_{\mathrm{T}} \times \dot{\vec{H}}_{\mathrm{T}}^*\right) \cdot \hat{i}_z \mathrm{~d} S=\frac{1}{2} \dot{U} \dot{I}^*\]</span> 将电磁场纵横分离，有： <span class="math display">\[\dot{\vec{E}}_{\mathrm{T}}(u, v, z)=\vec{e}_{\mathrm{T}}(u, v) \cdot \dot{U}(z)\]</span></p><p><span class="math display">\[\dot{\vec{H}}_{\mathrm{T}}(u, v, z)=\vec{h}_{\mathrm{T}}(u, v) \cdot \dot{I}(z)\]</span></p><p>其中<span class="math inline">\(e,h\)</span>叫矢量模式函数。满足： <span class="math display">\[\int_S\left(\vec{e}_{\mathrm{T}} \times \vec{h}_{\mathrm{T}}\right) \cdot \hat{i}_z \mathrm{~d} S=1\]</span></p></li><li><p>等效特性阻抗<span class="math inline">\(Z_0\)</span></p><p>设波导等效特性阻抗<span class="math inline">\(Z_0\)</span>，被等效的波导模式的波阻抗<span class="math inline">\(\eta_w\)</span>，有： <span class="math display">\[\frac{|\vec e_T|}{|\vec h_T|}=\frac{\eta_w}{Z_0}\]</span></p></li><li><p>相位常数</p><p>取被等效的波导模式的轴向相位常数。</p></li></ol><h3 id="不均匀区等效为网络">不均匀区等效为网络</h3><p>电路参量，也就是反映参考平面上电压和电流的关系的网络参量。</p><ol type="1"><li><p>阻抗参量</p><p>由方程 <span class="math display">\[\dot{U}_i=\sum_{j=1}^n Z_{i j} \dot{I}_j,(i=1,2, \cdots, n)\]</span> 得： <span class="math display">\[[\dot{\boldsymbol{U}}]=[\boldsymbol{Z}][\dot{\boldsymbol{I}}]\]</span> 其中<span class="math inline">\(Z_{ij}\)</span>是比例系数，称为阻抗。<span class="math inline">\(i=j\)</span>时叫自阻抗，否则叫互阻抗。 详细地来说：</p><ul><li><span class="math inline">\(Z_{ii}\)</span>表示其余端口开路时，端口<span class="math inline">\(i\)</span>的输入阻抗。</li><li><span class="math inline">\(Z_{ij}\)</span>表示端口<span class="math inline">\(i\)</span>开路时，端口<span class="math inline">\(j\)</span>到端口<span class="math inline">\(i\)</span>的转移阻抗。</li></ul></li><li><p>导纳参量 <span class="math display">\[\dot{I}_i=\sum_{j=1}^n Y_{i j} \dot{U}_j,(i=1,2, \cdots, n)\]</span> 即： <span class="math display">\[[\dot{\mathbf{I}}]=[\boldsymbol{Y}][\dot{\boldsymbol{U}}]\]</span> 其中的<span class="math inline">\([Y]\)</span>就是导纳参量矩阵。其物理意义为：</p><ul><li><span class="math inline">\(Y_{ii}\)</span>表示其它端口短路时，端口<span class="math inline">\(i\)</span>的输入导纳。</li><li><span class="math inline">\(Y_{ij}\)</span>表示端口<span class="math inline">\(i\)</span>短路时，端口<span class="math inline">\(j\)</span>到端口<span class="math inline">\(i\)</span>的转移导纳。</li></ul></li></ol><h3 id="归一化参量">归一化参量</h3><p>因为反射系数是一个很直观而且容易测量的量，仿照“传输线理论”，定义归一化阻抗： <span class="math display">\[\bar{Z}=\frac{Z}{Z_0}=\frac{1+\Gamma}{1-\Gamma}\]</span> 于是，可以直接导出归一化电压、电流，有： <span class="math display">\[\bar{Z}=\frac{Z}{Z_0}=\frac{\dot{U} / \dot{I}}{Z_0}=\frac{\dot{U} / \sqrt{Z_0}}{\dot{I} \sqrt{Z_0}}=\frac{\bar{U}}{\bar{I}}\]</span> 即： <span class="math display">\[\begin{cases}\bar U=\dot U/\sqrt{Z_0}\\\bar I=\dot I\sqrt{Z_0}\end{cases}\]</span> 传输线理论中所有关系式都成立，可以应用史密斯圆图.用归一化电压和电流，可以导出归一化阻抗、导纳参量。</p><h3 id="散射参量">散射参量</h3><p>在传输线理论中，我们学习了入射波和反射波的概念，这是研究散射参量的出发点 。散射参量描述的是进入网络的电压波和离开网络电压波的关系。 定义<span class="math inline">\(a\)</span>为进入网络的归一化电压波，定义<span class="math inline">\(b\)</span>为离开网络的归一化电压波。</p><p>有： <span class="math display">\[\left\{\begin{array}{l}a_i=\frac{1}{2}\left(\bar{U}_i+\bar{I}_i\right) \\b_i=\frac{1}{2}\left(\bar{U}_i-\bar{I}_i\right)\end{array}\right.\]</span></p><p>对<span class="math inline">\(n\)</span>端口的微波网络，我们可以把出波表示为入波的响应，也就是线性组合的形式。 <span class="math display">\[b_i=\sum_{j=1}^n S_{i j} a_j(i=1,2 \ldots n)\]</span> 即： <span class="math display">\[[b]=[S][a]\]</span> 其中的<span class="math inline">\([S]\)</span>就是散射参量矩阵。</p><p>在讨论散射参量矩阵的物理意义之前，首先要明确端口匹配负载和端口匹配的概念。</p><p>端口接匹配负载的意思是指端口接负载，并且所接的负载和端口传输线匹配，负载的反射波为零，即对该端口的进波为零。如果说第<span class="math inline">\(i\)</span>个端口接匹配负载，则<span class="math inline">\(a_i=0\)</span>.</p><p>端口匹配的意思是，在其它端口接负载的情况下，从该端口看进去的网络本身作为终端等效负载时和端口传输线匹配，网络反射波为零，即端口出波为零，即<span class="math inline">\(b_i=0\)</span>.</p><p>那么<span class="math inline">\([S]\)</span>矩阵的物理意义是：在除了波源所在的第<span class="math inline">\(j\)</span>端口以外的其余各端口均接匹配负载，散射矩阵的非对角线元素<span class="math inline">\(S_{ij}\)</span>是<strong>第<span class="math inline">\(j\)</span>端口到第<span class="math inline">\(i\)</span>端口</strong>（注意是反的）的电压传输系数，其对角线元素<span class="math inline">\(S_{jj}\)</span>是波源所在的第<span class="math inline">\(j\)</span>端口的电压反射系数。</p><h4 id="用散射参量描述网络性质">用散射参量描述网络性质</h4><ol type="1"><li><p>互易性</p><p>当微波元件内部为各向同性均匀媒质,即媒质极化、磁化、传导性质与外加场方向无关，进而与电磁波的传播方向无关时,其等效网络的任意两个端口都是可逆的，该网络称为可逆网络或互易网络。</p><p>可以证明，互易网络的<span class="math inline">\(S\)</span>矩阵是转置不变的，即： <span class="math display">\[S^T=S\]</span></p></li><li><p>无耗性</p><p>无耗网络的<span class="math inline">\(S\)</span>矩阵是酉矩阵<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，即： <span class="math display">\[S^+S=1\]</span></p></li><li><p>对称性</p><p>如果微波网络具有对称性，例如第<span class="math inline">\(i\)</span>端口和第<span class="math inline">\(j\)</span>端口是对称的，那么 <span class="math display">\[S_{ii}=S_{jj}\]</span></p></li></ol><h4 id="散射参量和阻抗导纳参量的转换">散射参量和阻抗导纳参量的转换</h4><p><span class="math display">\[[\bar{Z}]=([1]+[S])([1]-[S])^{-1}\]</span></p><p><span class="math display">\[[S]=([\bar{Z}]-[1])([\bar{Z}]+[1])^{-1}\]</span></p><p><span class="math display">\[[\bar{Y}]=([1]-[S])([1]+[S])^{-1}\]</span></p><p><span class="math display">\[[S]=([1]-[\bar{Y}])([1]+[\bar{Y}])^{-1}\]</span></p><h4 id="参考平面移动对s矩阵的影响">参考平面移动对S矩阵的影响</h4><p>对于<span class="math inline">\(n\)</span>端口网络，各端口参考面外移长度为<span class="math inline">\(l_1,l_2\cdots l_n\)</span>时，移动后的<span class="math inline">\(S&#39;\)</span>矩阵和原来的<span class="math inline">\(S\)</span>矩阵的关系为： <span class="math display">\[S&#39;=PSP\]</span> 其中<span class="math inline">\(P\)</span>是一个<span class="math inline">\(n\)</span>阶对角阵，满足： <span class="math display">\[P_{kk}=e^{-j\beta l_k}\]</span></p><h3 id="二端网络">二端网络</h3><p>二端网络的阻抗、导纳参量、散射参量、传输参量没有什么特别值得说的。矩阵各元素的物理意义已经在前面给出了。</p><h4 id="二端网络的性质">二端网络的性质</h4><ul><li><p>互易性 <span class="math display">\[\begin{aligned}&amp; \bar{Z}_{12}=\bar{Z}_{21} \\&amp; \bar{Y}_{12}=\bar{Y}_{21} \\&amp; S_{12}=S_{21}\end{aligned}\]</span></p></li><li><p>对称性 <span class="math display">\[\begin{aligned}&amp; \bar{Z}_{11}=\bar{Z}_{22} \\&amp; \bar{Y}_{11}=\bar{Y}_{22} \\&amp; S_{11}=S_{22}\end{aligned}\]</span></p></li><li><p>无耗性 <span class="math display">\[\begin{aligned}\overline{\boldsymbol{Z}}^{+}&amp;=-\overline{\boldsymbol{Z}} \\\bar{Y}^{+}&amp;=-\bar{Y} \\S^{+}S &amp;=I\end{aligned}\]</span></p><blockquote><p>这个无耗性是从能量守恒定理出发的。如果我们把这个共轭转置展开，有以下四个式子： <span class="math display">\[\begin{gathered}S_{11}^{*} S_{11}+S_{21}^{*} S_{21}=\left|S_{11}\right|^2+\left|S_{21}\right|^2=1 \\S_{12}^* S_{12}+S_{22}^{\cdot} S_{22}=\left|S_{12}\right|^2+\left|S_{22}\right|^2=1 \\S_{11}^* S_{12}+S_{21}^* S_{22}=0 \\S_{22}^* S_{14}+S_{22}^* S_{21}=0\end{gathered}\]</span></p></blockquote><blockquote><p>根据 <span class="math inline">\(S\)</span> 参量物理意义有 <span class="math display">\[\begin{array}{ll}\left|S_{11}\right|^2=\left.\frac{\left|b_1\right|^2}{\left|a_1\right|^2}\right|_{a_2=0}=\left.\frac{\left(P^{-}\right)_1}{\left(P^{+}\right)_1}\right|_{a_2=0}  \\\left|S_{21}\right|^2=\left.\frac{\left|b_2\right|^2}{\left|a_1\right|^2}\right|_{a_2=0}=\left.\frac{\left(P^{-}\right)_2}{\left(P^{+}\right)_1}\right|_{a_2=0} \end{array}\]</span> 式中, <span class="math inline">\(\left(P^{-}\right)_1\)</span> 表示端口 1 输出功率大小, <span class="math inline">\(\left(P^{-}\right)_2\)</span> 表示端口 2 输出功率大小, <span class="math inline">\(\left(P^{+}\right)\)</span>，表示端口 1 输人功率大小。 <span class="math inline">\(\left|S_{11}\right|^2\)</span> 表示端口 1 接波源, 端口 2 接匹配负载时, 端口 1 的功率反射系数, <span class="math inline">\(\left|S_{21}\right|^2\)</span> 表示此时从端口 1 到端口 2 的功率传输系数。 式 <span class="math inline">\(\left|S_{11}\right|^2+\left|S_{21}\right|^2=1\)</span> 表示当端口 2 接匹配负载时, 从端口 1 输人的功率分为 两部分：一部分被系统反射 <span class="math inline">\(\left(\left|S_{11}\right|^2\right)\)</span>, 另一部分被系统传输到端口 <span class="math inline">\(2\left(\left|S_{21}\right|^2\right)\)</span> 并被负载吸收。</p><p>式 <span class="math inline">\(\left|S_{12}\right|^2+\left|S_{22}\right|^2=1\)</span> 表示当端口 1 接匹配负载时, 从端口 2 输人的能量分为 两部分： 一部分被系统反射 <span class="math inline">\(\left(\left|S_{22}\right|^2\right)\)</span>, 另一部分被系统传输到端口 <span class="math inline">\(1\left(\left|S_{12}\right|^2\right)\)</span> 并被负载吸收。</p></blockquote></li></ul><p>二端口网络中，有：</p><ul><li>如果一个端口匹配，那么另一个端口匹配</li><li>如果网络完全匹配，那么完全传输</li></ul><h4 id="用散射参量表示网络外特性">用散射参量表示网络外特性</h4><ul><li><p>电压传输系数：输出端口出波和输入端口入波之比 <span class="math display">\[T=\left.\frac{b_2}{a_1}\right|_{a_2=0}=S_{21}\]</span></p></li><li><p>插入衰减：输出端接匹配负载，输入端进波功率和输出端出波功率之比 <span class="math display">\[L=\left.\frac{\left(P^*\right)_1}{\left(P^{-}\right)_2}\right|_{a_2=0}=\left.\frac{\left|a_1\right|^2}{\left|b_2\right|^2}\right|_{a_2=0}=\frac{1}{\left|S_{21}\right|^2}=\frac{1}{T^2}\]</span> 它可以分解为两项： <span class="math display">\[L=\frac{1-\left|S_{11}\right|^2}{\left|S_{21}\right|^2} \cdot \frac{1}{1-\left|S_{11}\right|^2}\]</span> 前一项叫吸收衰减，记作<span class="math inline">\(L_a\)</span>，由网络本身引起；后项叫反射衰减，记作<span class="math inline">\(L_r\)</span>，由输入端和外接输入线不匹配引起。</p></li><li><p>插入相移：出端接匹配负载，输入端进波和输出端出波相位差 <span class="math display">\[\phi=\theta_{21}=\arg T=\arg S_{21}\]</span></p></li><li><p>输入驻波比：出端接匹配负载，输入端测得驻波比 <span class="math display">\[L=\frac{1}{\left|S_{21}\right|^2}=\frac{1}{1-\left|S_{11}\right|^2}=\frac{(\rho+1)^2}{4 \rho}\]</span></p></li><li><p>回波损耗：出端接匹配负载，输入端入射波功率和反射波功率之比 <span class="math display">\[R L=\left.10 \lg \frac{\left(P^{+}\right)_1}{\left(P^{-}\right)_1}\right|_{a_2=0}=\left.10 \lg \frac{\left|a_1\right|^2}{\left|b_1\right|^2}\right|_{a_2=0}=-20 \lg \left|S_{11}\right|\]</span></p></li></ul><h4 id="二端口网络的互联">二端口网络的互联</h4><ol type="1"><li><p>串联</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182232843.png" alt="二端网络串联" /><figcaption aria-hidden="true">二端网络串联</figcaption></figure><p>有： <span class="math display">\[Z=Z_1+Z_2\]</span> 可以类比为电阻（阻抗）串联，阻值相加。</p></li><li><p>并联</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182235435.png" alt="二端网络并联" /><figcaption aria-hidden="true">二端网络并联</figcaption></figure><p>有： <span class="math display">\[Y=Y_1+Y_2\]</span> 可以类比导纳并联的电导等于各电导之和</p></li><li><p>级联</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182237317.png" alt="二端网络级联" /><figcaption aria-hidden="true">二端网络级联</figcaption></figure><p>有 ： <span class="math display">\[T=T_1\cdot T_2\]</span></p></li></ol><h4 id="转移参量">转移参量</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212182248801.png" alt="二端口网络示意图" /> <span class="math display">\[\left\{\begin{array}{l}\dot{U}_1=a \dot{U}_2+b\left(-\dot{I}_2\right) \\\dot{I}_1=c \dot{U}_2+d\left(-\dot{I}_2\right)\end{array}\right.\]</span> 即： <span class="math display">\[\left[\begin{array}{l}\dot{U}_1 \\\dot{I}_1\end{array}\right]=\left[\begin{array}{ll}a &amp; b \\c &amp; d\end{array}\right]\left[\begin{array}{c}\dot{U}_2 \\-\dot{I}_2\end{array}\right]=[A]\left[\begin{array}{c}\dot{U}_2 \\-\dot{I}_2\end{array}\right]\]</span> 其中<span class="math inline">\(A\)</span>称为转移矩阵，其中的各个元素称为转移参量。</p><p>归一化转移参量：把上面式子中的电压电流都换成归一化的，有： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\bar{a} &amp; \bar{b} \\\bar{c} &amp; \bar{d}\end{array}\right]=\left[\begin{array}{cc}a \sqrt{\frac{Z_{02}}{Z_{01}}} &amp; \frac{b}{\sqrt{Z_{01} Z_{02}}} \\c \sqrt{Z_{01} Z_{02}} &amp; d \sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p><p>转移参量和其它参量的关系：</p><ol type="1"><li><p>散射参量 <span class="math display">\[[S]=\frac{1}{\bar{a}+\bar{b}+\bar{c}+\bar{d}}\left[\begin{array}{cc}\bar{a}+\bar{b}-\bar{c}-\bar{d} &amp; 2|\bar{A}| \\2 &amp; -\bar{a}+\bar{b}-\bar{c}+\bar{d}\end{array}\right]\]</span> 反过来，有： <span class="math display">\[[\bar{A}]=\frac{1}{2 S_{21}}\left[\begin{array}{ll}1-|S|+S_{11}-S_{22} &amp; 1+|S|+S_{11}+S_{22} \\1+|S|-S_{11}-S_{22} &amp; 1-|S|-S_{11}+S_{22}\end{array}\right]\]</span></p></li><li><p>阻抗参量 <span class="math display">\[[\bar{Z}]=\frac{1}{c}\left[\begin{array}{cc}\bar{a} &amp; |\bar{A}| \\1 &amp; \bar{d}\end{array}\right]\]</span> 反过来，有： <span class="math display">\[[\bar{A}]=\frac{1}{Z_{21}}\left[\begin{array}{cc}\bar{Z}_{11} &amp; |\bar{Z}| \\1 &amp; \bar{Z}_{22}\end{array}\right]\]</span></p></li><li><p>导纳参量 <span class="math display">\[[\bar{Y}]=\frac{1}{b}\left[\begin{array}{cc}\bar{d} &amp; -|\bar{A}| \\-1 &amp; \bar{a}\end{array}\right]\]</span> 反过来，有： <span class="math display">\[[\bar{A}]=-\frac{1}{\bar Y_{21}}\left[\begin{array}{cc}\bar{Y}_{22} &amp; 1 \\\mid \bar{Y}\mid &amp; \bar{Y}_{11}\end{array}\right]\]</span></p></li></ol><p>至于二端口网络的各种性质，也可以用转移参量描述：</p><ol type="1"><li><p>互易性： <span class="math display">\[|\bar A|=|A|=1\]</span></p></li><li><p>对称性： <span class="math display">\[\begin{array}{ll}\bar{a}=\bar{d}, &amp; |\bar{A}|=\bar{a} \bar{d}-\bar{b} \bar{c}=1 \\a=d, &amp; |A|=a d-b c=1\end{array}\]</span></p></li><li><p>无耗互易： <span class="math display">\[\bar a,\bar d\in \mathbb R\]</span></p><p><span class="math display">\[\bar b,\bar c\in \mathbb I\]</span></p></li></ol><h4 id="基本电路单元">基本电路单元</h4><ol type="1"><li><p>串联阻抗</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192031951.png" alt="串联阻抗" /><figcaption aria-hidden="true">串联阻抗</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{ll}1 &amp; 0 \\Y &amp; 1\end{array}\right]\]</span> 归一化： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\sqrt{\frac{Z_{02}}{Z_{01}}} &amp; 0 \\Y \sqrt{Z_{01} Z_{02}} &amp; \sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p></li><li><p>不同阻抗的传输线相连</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192040220.png" alt="不同阻抗的传输线相连" /><figcaption aria-hidden="true">不同阻抗的传输线相连</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{ll}1 &amp; 0 \\0 &amp; 1\end{array}\right]\]</span> 归一化转移矩阵： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\sqrt{\frac{Z_{02}}{Z_{01}}} &amp; 0 \\0 &amp; \sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p></li><li><p>理想变压器：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192041717.png" alt="理想变压器" /><figcaption aria-hidden="true">理想变压器</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{ll}n^{-1} &amp; 0 \\0 &amp; n\end{array}\right]\]</span> 归一化： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\frac{1}{n} \sqrt{\frac{Z_{02}}{Z_{01}}} &amp; 0 \\0 &amp; n\sqrt{\frac{Z_{01}}{Z_{02}}}\end{array}\right]\]</span></p></li><li><p>一段均匀传输线：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192045931.png" alt="均匀传输线" /><figcaption aria-hidden="true">均匀传输线</figcaption></figure><p>转移矩阵： <span class="math display">\[[A]=\left[\begin{array}{cc}\cos \beta l &amp; \mathrm{j} Z_0 \sin \beta l \\\frac{\mathrm{j} \sin \beta l}{Z_0} &amp; \cos \beta l\end{array}\right]\]</span> 归一化： <span class="math display">\[[\bar{A}]=\left[\begin{array}{cc}\cos \beta l &amp; j \sin \beta l \\j \sin \beta l &amp; \cos \beta l\end{array}\right]\]</span></p></li></ol><h3 id="无耗三端口网络">无耗三端口网络</h3><p>具有以下性质：</p><ol type="1"><li>无耗互易三端口网络不可能完全匹配。如果端口1、2匹配，那么端口3和网络完全隔离，即<span class="math inline">\(S_{13}=S_{23}=0\)</span></li><li>任何完全匹配的无耗三端口网络一定是非互易的。</li><li>对称互易无耗的三端口网络，输入驻波比不低于2</li><li>无耗互易三端口网络中任意端口接短路活塞，总可以找到活塞的一个位置，使其它两个端口互相隔离。</li><li>如果无耗互易三端口网络对于接有短路活塞的端口是对称的，则总可以找到活塞的一个位置，使其它两个端口之间可以无耗的传输。</li></ol><h3 id="无耗四端口网络">无耗四端口网络</h3><p>具有以下性质：</p><ol type="1"><li>如果一个无耗互易四端口网络的任意三个端口匹配，则第四个端口自动匹配，且该网络构成一个定向耦合器。所谓的定向耦合器是指对四端口元件，当某个端口接波源、其余端口接匹配负载时，必然和其中一个端口理想隔离。理想定向性要求接波源的端口无反射，即输入端口匹配。</li><li>有理想定向性的无耗互易四端口网络不一定四个端口都匹配。</li><li>有两个端口匹配且互相隔离的无耗互易四端口网络一定是完全匹配的定向耦合器。</li></ol><h2 id="微波元件">微波元件</h2><h3 id="一端口元件">一端口元件</h3><ol type="1"><li><p>短路负载</p><p>扼流式短路负载的基本原理是：利用传输线的<span class="math inline">\(\lambda/4\)</span>波长阻抗变换特性，把有高频电流流过，需要良好电接触的地方，恰好安排在电压波节点（电流波腹点）处，从而得到等效短路。</p></li><li><p>匹配负载</p><p>它可以几乎无反射地吸收入射波的全部功率，在传输系统中建立行波状态。</p></li><li><p>失配负载</p><p>它具有某一个固定的驻波比，在微波测量中作为标准终端负载。</p></li></ol><h3 id="二端口元件">二端口元件</h3><ol type="1"><li><p>波导接头</p><p>是用来把传输线接在一起的。有平接头、扼流接头等。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212192224219.png" alt="波导接头" /><figcaption aria-hidden="true">波导接头</figcaption></figure><p>扼流接头在连接波导的法兰盘上有一个深为<span class="math inline">\(\lambda_g/4\)</span>的槽，这样可以保证接头处恰好是电流波腹点。</p></li><li><p>拐角、弯曲、扭转元件</p></li><li><p>调配元件</p><p>是一些电抗元件，放在传输线上，产生附加反射，使得传输线匹配。</p><ol type="1"><li>电抗膜片：分为感性膜片、容性膜片、谐振窗</li><li>销钉</li><li>螺钉匹配器</li></ol></li><li><p>衰减器</p><p>吸收式衰减器散射矩阵： <span class="math display">\[S=\begin{pmatrix}0 &amp; e^{-\alpha t}\\e^{-\alpha t} &amp; 0\end{pmatrix}\]</span> 截止式衰减器：插入一个比较小的传输线，使得电磁场在这一小段里面截止。其特点有：</p><ol type="1"><li>衰减量dB和距离呈线性关系</li><li>当<span class="math inline">\(\lambda_c&lt;&lt;\lambda\)</span>，衰减系数<span class="math inline">\(\alpha\)</span>很大，移动较小的距离就可以得到很大的衰减量</li><li>衰减是由于反射产生，输入端和输出端严重失配</li></ol><p>还有极化衰减器</p></li><li><p>相移器</p><p>其S矩阵为： <span class="math display">\[S=\begin{pmatrix}0 &amp; e^{-j\beta l}\\e^{-j\beta l} &amp; 0\end{pmatrix}\]</span></p></li></ol><hr /><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>酉矩阵也叫幺正矩阵，即它的共轭转置和它的乘积是单位矩阵。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变泛函笔记·泛函分析之章</title>
    <link href="/2022/12/15/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD%E7%AC%94%E8%AE%B0%C2%B7%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%AB%A0/"/>
    <url>/2022/12/15/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD%E7%AC%94%E8%AE%B0%C2%B7%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="度量空间和赋范线性空间">度量空间和赋范线性空间</h2><h3 id="度量距离空间">度量（距离）空间</h3><p>如果<span class="math inline">\(X\)</span>是一个非空集合，对于<span class="math inline">\(X\)</span>中的任何两个元素<span class="math inline">\((x,y)\)</span>，都有一个实数<span class="math inline">\(d(x,y)\)</span>与之对应，且满足：</p><ol type="1"><li><span class="math inline">\(d(x,y)\geq 0\)</span>，等号仅在<span class="math inline">\(x=y\)</span>时取得</li><li><span class="math inline">\(d(x,y)=d(y,x)\)</span></li><li><span class="math inline">\(d(x,z)\leq d(x,y)+d(y,z)\)</span>，也就是“三角形两边之和大于第三边”</li></ol><p>那么称函数<span class="math inline">\(d\)</span>是<span class="math inline">\(X\)</span>上的一个距离（度量），<span class="math inline">\((X,d)\)</span>是距离空间。</p><p>事实上，对于任何非空集合，我们都可以让他变成距离空间，大不了定义<code>d(x,y)=(x==y)?0:1</code>嘛。</p><h4 id="常用的距离空间">常用的距离空间</h4><ol type="1"><li><p><span class="math inline">\(R\)</span>，<span class="math inline">\(d(x,y)=|y-x|\)</span></p></li><li><p><span class="math inline">\(R^n\)</span>，有很多种<span class="math inline">\(d\)</span>的定义，列举三种： <span class="math display">\[\begin{aligned}&amp; d_1(x, y)=\sum_{i=1}^n\left|x_i-y_i\right| \\&amp; d_2(x, y)=\left(\sum_{i=1}^n\left|x_i-y_i\right|^2\right)^{1 / 2} \\&amp; d_3(x, y)=\max _{\forall i}\left|x_i-y_i\right|^2\end{aligned}\]</span></p></li><li><p><span class="math inline">\(C[a,b]\)</span>，指<span class="math inline">\([a,b]\)</span>上的连续函数构成的集合 <span class="math display">\[d(x, y)=\max _{a \leq t \leq b}|x(t)-y(t)|, \forall x, y \in C[a, b]\]</span> 距离定义为定义域内两个函数垂直距离的最大值</p></li><li><p>所有序列构成的集合<span class="math inline">\(S\)</span></p><p>如果<span class="math inline">\(x=\{\xi_i\},y=\{\eta_i\}\)</span>，则 <span class="math display">\[d(x, y)=\sum_{i=1}^{\infty} \frac{1}{2^i} \frac{\left|\xi_i-\eta_i\right|}{1+\left|\xi_i-\eta_i\right|}\]</span> 提示：验证第三条公理只需考察函数<span class="math inline">\(f(x)=\frac{x}{1+x}\)</span>的单调性</p></li><li><p>有界序列空间<span class="math inline">\(l^\infty\)</span> <span class="math display">\[d(x, y)=\sup _{\forall i}\left|\xi_i-\eta_i\right|\]</span></p></li><li><p>收敛序列空间<span class="math inline">\(c\)</span></p><p>距离的定义同有界数列空间一样</p></li><li><p><span class="math inline">\(p\)</span>次可和序列空间<span class="math inline">\(l^p\)</span> <span class="math display">\[l^p=\left\{x=\left\{\xi_i\right\}\left|\sum_{i=1}^{\infty}\left| \xi_i\right|^p&lt;\infty\right.\right\}, 1 \leq p&lt;\infty\]</span> 距离： <span class="math display">\[d(x, y)=\left(\sum_{i=1}^{\infty}\left|\xi_i-\eta_i\right|^p\right)^{\frac{1}{p}}\]</span></p></li><li><p>本质有界可测函数空间<span class="math inline">\(L^\infty[a,b]\)</span></p><p>本质有界：指除了一个零测集<span class="math inline">\(E\)</span>以外都有界</p><p>距离： <span class="math display">\[d(x,y)=\inf _{m(E)=0}\left\{\sup _{t \in[a, b] \backslash E}|x(t)-y(t)|\right\}\]</span> 意思是：先遍历零测集<span class="math inline">\(E\)</span>，再对每个<span class="math inline">\(E\)</span>沿着<span class="math inline">\(x\)</span>轴找到两个函数垂直距离最大的点，再找这个最小的“最大的垂直距离”。</p></li><li><p><span class="math inline">\(p\)</span>次可积函数空间<span class="math inline">\(L^p\)</span> <span class="math display">\[d(x, y)=\left(\int_a^b|x(t)-y(t)|^p \mathrm{~d} t\right)^{1 / p}\]</span></p></li></ol><h4 id="距离空间中的拓扑">距离空间中的拓扑</h4><p>既然我们定义了距离，那么什么都好办了，距离空间中的拓扑可以对照<span class="math inline">\(R^n\)</span>中的拓扑的相关定义，包括开球、邻域、内点外点边界点、聚点、开集导集闭包等等。这些定义都是相同的。</p><p><strong>【连续映射】</strong>设<span class="math inline">\((X,d),(Y,p)\)</span>都是距离空间，<span class="math inline">\(T:X\to Y\)</span>，如果对于给定的<span class="math inline">\(x_0\in X,\forall \epsilon &gt;0,\exists\delta&gt;0,s.t. x\in X,d(x,x_0)&lt;\delta,p(T_x,T_{x_0})&lt;\epsilon\)</span>，也就是说，如果<span class="math inline">\(X\)</span>中的两点足够近，那么其映射的像在<span class="math inline">\(Y\)</span>中也足够近，那么称映射<span class="math inline">\(T\)</span>在点<span class="math inline">\(x_0\)</span>处连续。如果<span class="math inline">\(T\)</span>在<span class="math inline">\(X\)</span>的每一点都连续，称<span class="math inline">\(T\)</span>是<span class="math inline">\(X\)</span>上的连续映射。</p><p>连续有两个充要条件，可以辅助判别：</p><ol type="1"><li><span class="math inline">\(\forall x_0\in X\)</span>当<span class="math inline">\(X\)</span>中的点列<span class="math inline">\(x_n\to x_0\)</span>（距离意义上），相应<span class="math inline">\(Y\)</span>中的像点列<span class="math inline">\(Tx_n\to Tx_0\)</span>（海涅定理）</li><li>对<span class="math inline">\(Y\)</span>中的任何开集<span class="math inline">\(O\)</span>，<span class="math inline">\(T^{-1}O\)</span>是<span class="math inline">\(X\)</span>中的开集</li></ol><p><strong>【稠密性】</strong>设<span class="math inline">\((X,d)\)</span>是距离空间，<span class="math inline">\(A\subset X\)</span>，对<span class="math inline">\(\forall x\in X,x\)</span>的任何球中后含有<span class="math inline">\(A\)</span>中的点，称<span class="math inline">\(A\)</span>在<span class="math inline">\(X\)</span>中稠密</p><p><strong>【可分性】</strong>设<span class="math inline">\((X,d)\)</span>是距离空间，如果<span class="math inline">\(X\)</span>中存在可数的稠密子集，那么称<span class="math inline">\(X\)</span>是可分的。</p><blockquote><p>例如：<span class="math inline">\(R^n,l^p,s,C[a,b],P[a,b],L^p[a,b]\)</span>都是可分的。</p><p>但是<span class="math inline">\(l^\infty\)</span>是不可分的。</p></blockquote><h4 id="完备距离空间">完备距离空间</h4><p>满足“所有基本列（柯西列）都收敛”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="所有收敛列都是基本列是永远成立的。">[1]</span></a></sup>的距离空间叫做完备距离空间。</p><blockquote><p>反例1：对距离空间<span class="math inline">\((Q,d(x,y)=|x-y|)\)</span>，有基本列<span class="math inline">\(x_n=(1+1/n)^n\)</span>，在<span class="math inline">\(Q\)</span>上不收敛。</p><p>反例2：对距离空间<span class="math inline">\((X=(0,1),d(x,y)=|x-y|)\)</span>，有基本列<span class="math inline">\(x_n=1/(n+1)\)</span>，在<span class="math inline">\((0,1)\)</span>上不收敛</p></blockquote><p>典型的完备距离空间有：<span class="math inline">\(R^n,L^P,l^p,C[a,b]\)</span></p><p><strong>【等距映射】</strong>设<span class="math inline">\((X,d),(\hat X,\rho)\)</span>都是距离空间，如果存在一个映射<span class="math inline">\(T:X\to \hat X\)</span>，使得 <span class="math display">\[d(x,y)=\rho (Tx,Ty)\]</span> 称<span class="math inline">\(T\)</span>是等距映射。<span class="math inline">\(X,\hat X\)</span>称为等距同构空间。</p><p><strong>【完备化】</strong> 对距离空间<span class="math inline">\((X,d)\)</span>，如果有完备距离空间<span class="math inline">\((\hat X,\rho)\)</span>，使得这两个空间等距同构，那么称<span class="math inline">\(\hat X\)</span>是<span class="math inline">\(X\)</span>的完备化空间。每个距离空间都有自己的完备化空间。</p><h3 id="线性空间">线性空间</h3><p>在数域<span class="math inline">\(K\)</span>，集合<span class="math inline">\(X\)</span>上定义加法、数乘，满足前文提到的“线性运算加法和数乘8条性质”的集合<span class="math inline">\(X\)</span>称作向量空间或线性空间。</p><p>线性空间的性质，我们在线性代数中已经学了很多，这里仅仅列举</p><ul><li>零向量唯一</li><li>一个向量的负向量唯一</li><li>线性子空间的定义（X的子集对加法和数乘封闭）</li><li>线性组合</li><li>生成子空间</li><li>线性无关</li><li>维数</li><li>线性子空间的直和<span class="math inline">\(X=M\bigoplus N=\{m+n|\forall m\in M,\forall n\in N,M\cap N=\emptyset\}\)</span>，有<span class="math inline">\(\dim X=\dim M+\dim N\)</span></li><li>补子空间：<span class="math inline">\(X=M\bigoplus N\)</span>，称<span class="math inline">\(N\)</span>是<span class="math inline">\(X\)</span>的补。对于一个线性空间<span class="math inline">\(X\)</span>和它的一个子空间<span class="math inline">\(M\)</span>，<span class="math inline">\(M\)</span>的补一定存在。</li></ul><h4 id="赋范线性空间">赋范线性空间</h4><p>设<span class="math inline">\(X\)</span>是线性空间，且<span class="math inline">\(\forall x\in X\)</span>，存在一个非负实数<span class="math inline">\(||x||\)</span>，且</p><ol type="1"><li><span class="math inline">\(\|x\| \geq \mathbf{0},\|x\|=0 \Leftrightarrow x=\theta\)</span></li><li><span class="math inline">\(\|\alpha x\|=|\alpha| \cdot\|x\|, \forall \alpha \in C\)</span> (或 <span class="math inline">\(R)\)</span></li><li><span class="math inline">\(\|x+y\| \leq\|x\|+\|y\|, \forall x, y \in X \quad\)</span> (三角不等式）</li></ol><p>那么称<span class="math inline">\(||x||\)</span>是<span class="math inline">\(x\)</span>的范数，<span class="math inline">\((X,||\cdot||)\)</span>为赋范线性空间。</p><p>例如：在<span class="math inline">\(R^n\)</span>空间中的常用范数：</p><ol type="1"><li><p>p-范数： <span class="math display">\[\|x\|_p=\left(\sum_{i=1}^n\left|x_i\right|^p\right)^{1 / p}\]</span></p></li><li><p>无穷范数： <span class="math display">\[||x||_\infty=\max |x_i|\]</span></p></li><li><p>1-范数： <span class="math display">\[||x||_1=\sum_{i=1}^n |x_i|\]</span></p></li></ol><p>任何赋范线性空间都能诱导出一种距离： <span class="math display">\[d(x,y)=||x-y||\]</span> 但距离空间不一定能诱导出一种范数。</p><p><strong>【依范数收敛】</strong> <span class="math display">\[\lim_{n\to \infty}||x_n-x_0||=0\]</span> <strong>【范数的等价】</strong>对于不同的范数，如果存在<span class="math inline">\(C_1,C_2&gt;0\)</span>，使得 <span class="math display">\[C_1||x||_2&lt;||x||_1&lt;C_2||x||_2\]</span> 那么称这两个范数等价</p><p><strong>【巴拿赫空间】</strong>如果一个赋范线性空间按照它的范数诱导出来的距离构成的距离空间是完备距离空间，那么称这个赋范线性空间为巴拿赫空间。</p><p><strong>【有限维赋范线性空间】</strong>有如下性质：</p><ol type="1"><li>维数相等的赋范线性空间都同构</li><li>有限维线性赋范线性空间必完备且可分</li><li>赋范线性空间<span class="math inline">\(X\)</span>是列紧的，和它是有限维等价</li><li>在其上定义的各种范数都等价</li><li>从有限维到有限维的线性算子都有界</li></ol><h2 id="有界线性算子和连续线性泛函">有界线性算子和连续线性泛函</h2><p>在泛函分析中，把具有一定性质的元素的集合称为空间，把空间到空间的映射称为算子。算子的概念可以类比于平常所说的映射，也有值域、单、满、双、逆的概念。</p><p><strong>【线性算子】</strong>如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，有： <span class="math display">\[T(\alpha_1x_1+\alpha_2x_2)=\alpha_1Tx_1+\alpha_2Tx_2\]</span> 则称这个算子<span class="math inline">\(T\)</span>是线性算子。</p><p><strong>【连续算子】</strong> 如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，有： <span class="math display">\[\text{当}||x-x_0||_1\to 0\text{有}||Tx-Tx_0||_2\to 0\]</span> 称<span class="math inline">\(T\)</span>在<span class="math inline">\(x_0\)</span>处连续。如果<span class="math inline">\(T\)</span>在<span class="math inline">\(X\)</span>的每个点都连续，称其为连续算子。</p><p><strong>【同构同胚】</strong> 如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，线性</p><ol type="1"><li>如果<span class="math inline">\(T\)</span>是双射，那么称<span class="math inline">\(T\)</span>是线性同构的</li><li>进一步，如果<span class="math inline">\(T\)</span>和它的逆都是连续的，那么称<span class="math inline">\(T\)</span>是线性同胚的</li></ol><p><strong>【有界】</strong>如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>，存在常数<span class="math inline">\(C\)</span>，使得对任意<span class="math inline">\(x\)</span> <span class="math display">\[||T_x||_2\leq C||x||_1\]</span> 则称 <span class="math inline">\(T\)</span>是有界的。有界当且仅当其把任意有界集映射为有界集。</p><p><strong>【算子的范数】</strong>如果<span class="math inline">\(T:(X,||\cdot||_1)\to (Y,||\cdot||_2)\)</span>的线性有界算子，称 <span class="math display">\[||T||=\sup_{\forall x\neq \theta}\frac{||Tx||_2}{||x||_1}\]</span> 为算子<span class="math inline">\(T\)</span>的范数。</p><p>如果在上述“算子”的描述中，<span class="math inline">\(Y\)</span>是数集，那么这个算子也可以叫做“泛函”。</p><h3 id="有界线性算子空间和共轭空间">有界线性算子空间和共轭空间</h3><h4 id="有界线性算子空间">有界线性算子空间</h4><p>设全体<span class="math inline">\(T:X\to Y\)</span>构成一个集合，记作<span class="math inline">\(\mathcal L(X,Y)\)</span>。则它按范数是赋范线性空间。其中 <span class="math display">\[(A+B)x=Ax+Bx,(\alpha A)x=\alpha(Ax)\]</span> 如果<span class="math inline">\(X\)</span>是赋范线性空间，<span class="math inline">\(Y\)</span>是巴拿赫空间（按照它的范数诱导出来的距离构成的距离空间是完备距离空间的赋范线性空间），那么<span class="math inline">\(\mathcal L(X,Y)\)</span>也是巴拿赫空间。</p><p>如果<span class="math inline">\(A,B\in \mathcal L(X,Y)\)</span>，则<span class="math inline">\(AB\in L(X,Y)\)</span>，且<span class="math inline">\(||AB||\leq ||A||\cdot||B||\)</span>。进一步，有：<span class="math inline">\(||A^n||\leq ||A||^n\)</span></p><p><strong>【范数的强弱】</strong> 对于同一个集合上的两个范数，如果： <span class="math display">\[(||x_n||_1\to 0)\to (||x_n||_2\to 0)\]</span> 称范数1比范数2更强。</p><h4 id="算子的逆">算子的逆</h4><p>设 <span class="math inline">\(X, Y\)</span> 都是线性赋范空间, <span class="math inline">\(A: X \rightarrow Y\)</span> 是线性映射. 那么 <span class="math inline">\(A\)</span> 是单射, 且定义在 <span class="math inline">\(R(A)\)</span> 上的算子 <span class="math inline">\(A^{-1}\)</span> 是连续的 <span class="math inline">\(\Leftrightarrow\)</span> 存在常数 <span class="math inline">\(m&gt;0\)</span>, 使 <span class="math inline">\(\|A x\| \geq m\|x\|, \forall x \in X\)</span>.</p><p>设 <span class="math inline">\(X\)</span> 为 Banach空间, <span class="math inline">\(A \in \mathcal{L}(X)\)</span>, 且 <span class="math inline">\(\|A\|&lt;1\)</span>, 则 <span class="math inline">\(I-A\)</span> 是有界可逆的, 且 <span class="math display">\[(I-A)^{-1}=\sum_{n=0}^{\infty} A^n, \quad\left\|(I-A)^{-1}\right\| \leq \frac{1}{1-\|A\|},\]</span> 其中 <span class="math inline">\(A^0=I, I\)</span> 是恒等算子.</p><h4 id="对偶空间">对偶空间</h4><p>如果<span class="math inline">\(X\)</span>是数域<span class="math inline">\(C\)</span>上的赋范线性空间，集合 <span class="math display">\[X^{\prime}=\mathcal{L}(X, C)=\left\{x^{\prime} \mid x^{\prime}: X \rightarrow C \text { 是连续线性泛函 }\right\}\]</span> 规定：</p><ol type="1"><li><span class="math inline">\(\left(x_1^{\prime}+x_2^{\prime}\right)(x)=x_1^{\prime}(x)+x_2^{\prime}(x)\)</span>，<span class="math inline">\((\lambda x&#39;)(x)=\lambda(x&#39;(x))\)</span></li><li><span class="math inline">\(\left\|x^{\prime}\right\|=\sup _{\|x\| \leq 1}\left|x^{\prime}(x)\right|\)</span></li></ol><p>称<span class="math inline">\(X&#39;\)</span>是<span class="math inline">\(X\)</span>的对偶空间/共轭空间。</p><p>如果<span class="math inline">\(X\)</span>可分，那么<span class="math inline">\(X&#39;\)</span>可分。</p><h4 id="常见空间上的连续线性泛函">常见空间上的连续线性泛函</h4><ol type="1"><li><p><span class="math inline">\(l^1\)</span>空间</p><p>其上的连续线性泛函可以表现为： <span class="math display">\[f(x)=\sum_{k=1}^{\infty} \xi_k \eta_k, \forall x=\left\{\xi_k\right\} \in l^1\]</span> 就是序列中的各项按由<span class="math inline">\(f(x)\)</span>唯一确定的权重<span class="math inline">\(y=\{\eta_i\}\)</span>线性组合。且： <span class="math display">\[||f(x)||=\sup|\eta_k|=||y||_{l^1}\]</span></p></li><li><p><span class="math inline">\(l^p\)</span>空间 <span class="math display">\[f(x)=\sum_{k=1}^{\infty} \xi_k \eta_k, \forall x=\left\{\xi_k\right\} \in l^1\]</span> 其中<span class="math inline">\(y\in l^q\)</span>，满足<span class="math inline">\(p^{-1}+q^{-1}=1\)</span>。也就是说：<span class="math inline">\((l^p)&#39;=l^q\)</span></p></li><li><p><span class="math inline">\(L^p[a,b]\)</span>空间： <span class="math display">\[f(x)=\int_a^b x(t) y(t) \mathrm{d} t, \forall x=x(t) \in L^p[a, b]\]</span> 其中<span class="math inline">\(y=y(t)\in L^q[a,b]\)</span>，<span class="math inline">\(q=\frac{p}{p-1}\)</span>。</p></li></ol><h2 id="内积空间和希尔伯特hilbert空间">内积空间和希尔伯特（Hilbert）空间</h2><p>设 <span class="math inline">\(X\)</span> 是数域 <span class="math inline">\(K\)</span> (实或复数域)上的线性空间, 若 <span class="math inline">\(\forall x, y \in X\)</span> 存在唯一的数 <span class="math inline">\((x, y) \in K\)</span>, 满足下列三条内积公理:</p><ul><li>正定性: <span class="math inline">\((x, x) \geq 0,(x, x)=0 \Leftrightarrow x=\theta\)</span>;</li><li>对第一变元的线性性:<span class="math inline">\((\alpha x+\beta y, z)=\alpha(x, z)+\beta(y, z), \forall z \in X, \forall \alpha, \beta \in K\)</span></li><li>共轭对称性: <span class="math inline">\((x, y)=\overline{(y, x)}\)</span>,</li></ul><p>则称 <span class="math inline">\((x, y)\)</span> 为 <span class="math inline">\(x, y\)</span> 的内积, <span class="math inline">\(X\)</span> 为内积空间。如果是复内积空间，对第二变元有共轭线性，即： <span class="math display">\[(x, \alpha y+\beta z)=\bar{\alpha}(x, y)+\bar{\beta}(x, z)\]</span> 两个向量内积为零，称为正交。如果一个集合<span class="math inline">\(\{x_i\}\)</span>满足<span class="math inline">\((x_i,x_j)=\delta_{ij}\)</span>，称为正规正交集。</p><p><strong>【勾股定理】</strong> <span class="math inline">\(X\)</span>是内积空间，<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>正交，则有： <span class="math display">\[\|x+y\|^2=\|x\|^2+\|y\|^2\]</span> 其中<span class="math inline">\(||x||=\sqrt{(x,x)}\)</span>称为向量<span class="math inline">\(x\)</span>的范数。</p><p>如果<span class="math inline">\(\{x_i\}\)</span>是正规正交集，则<span class="math inline">\(\forall x\in X\)</span> <span class="math display">\[\|x\|^2=\sum_{j=1}^n\left|\left(x, x_j\right)\right|^2+\left\|x-\sum_{j=1}^n\left(x, x_j\right) x_j\right\|^2\]</span> <strong>【贝塞尔不等式】</strong>如果<span class="math inline">\(\{x_i\}\)</span>是正规正交集，则<span class="math inline">\(\forall x\in X\)</span> <span class="math display">\[\sum_{j=1}^n\left|\left(x, x_j\right)\right|^2 \leq\|x\|^2\]</span> <strong>【柯西-施瓦茨不等式】</strong> <span class="math display">\[|(x, y)| \leq\|x\| \cdot\|y\|\]</span></p><h3 id="内积的性质">内积的性质</h3><p><strong>【连续性】</strong>内积对两个变元都是连续泛函。即<span class="math inline">\(x_n\to x,y_n\to y\)</span>时，<span class="math inline">\((x_n,y_n)\to (x,y)\)</span></p><blockquote><p>证明时先用三角不等式，再用柯西-施瓦茨不等式。 <span class="math display">\[\begin{aligned}\left|\left(x_n, y_n\right)-(x, y)\right| &amp; \leq\left|\left(x_n, y_n\right)-\left(x_n, y\right)\right|+\left|\left(x_n, y\right)-(x, y)\right| \\&amp; =\left|\left(x_n, y_n-y\right)\right|+\left|\left(x_n-x, y\right)\right| \\&amp; \leq\left\|x_n\right\| \cdot\left\|y_n-y\right\|+\left\|x_n-x\right\| \cdot\|y\|\end{aligned}\]</span></p></blockquote><p><strong>【平行四边形公式】</strong> <span class="math display">\[\|x+y\|^2+\|x-y\|^2=2\left(\|x\|^2+\|y\|^2\right)\]</span> 如果赋范线性空间的范数满足这个式子，那么它可以成为内积空间，反之亦然。</p><p><strong>【极化恒等式】</strong> <span class="math display">\[(x, y)=\frac{1}{4}\left(\|x+y\|^2-\|x-y\|^2\right)+\frac{i}{4}\left(\|x+i y\|^2-\|x-i y\|^2\right)\]</span></p><h3 id="希尔伯特空间">希尔伯特空间</h3><p>完备（所有基本列都是收敛的）的内积空间被称为希尔伯特空间。</p><ol type="1"><li><p><span class="math inline">\(n\)</span>维实/复向量空间 <span class="math display">\[(x, y)=\bar{y}^{\mathrm{T}} x=\sum_{i=1}^n x_i \bar{y}_i\]</span></p></li><li><p><span class="math inline">\(l^2\)</span>平方可和序列空间 <span class="math display">\[(x, y)=\sum_{j=1}^{\infty} \xi_j \bar{\eta}_j\]</span></p></li><li><p><span class="math inline">\(L^2[a,b]\)</span>平方可积函数空间 <span class="math display">\[(x, y)=\int_a^b x(t) \cdot \bar{y}(t) \mathrm{d} t\]</span></p></li></ol><h3 id="正规正交基">正规正交基</h3><p><strong>【施密特正交化】</strong>对于任意线性无关组<span class="math inline">\(\{x\}\)</span>，有以下过程可以构造一个正规正交集： <span class="math display">\[\begin{aligned}&amp; y_1=x_1 \Rightarrow e_1=\frac{y_1}{\left\|y_1\right\|} \\&amp; y_2=x_2-\left(x_2, e_1\right) e_1 \Rightarrow e_2=\frac{y_2}{\left\|y_2\right\|} \\&amp; y_3=x_3-\left(x_3, e_1\right) e_1-\left(x_3, e_2\right) e_2 \Rightarrow e_3=\frac{y_3}{\left\|y_3\right\|}, \cdots \\&amp; y_n=x_n-\sum_{i=1}^{n-1}\left(x_n, e_i\right) e_i \Rightarrow e_n=\frac{y_n}{\left\|y_n\right\|}, \cdots\end{aligned}\]</span> 得到的正规正交集为<span class="math inline">\(\{e\}\)</span>,</p><p><strong>【正规正交基】</strong>在希尔伯特空间中，不是任何其它正规正交集的子集的正规正交集，叫做正规正交基。</p><p>也即：在空间中，如果一个向量和正规正交基的每个元素都正交，那么这个向量是零向量。这说明了正规正交基的完全性。</p><p>设 <span class="math inline">\(H\)</span> 为无穷维Hilbert空间, 则</p><ol type="1"><li>若 <span class="math inline">\(H\)</span> 可分, 则 <span class="math inline">\(H\)</span> 有一个可数的正规正交基</li><li>每个非零的 <span class="math inline">\(H\)</span> 都有正规正交基</li></ol><p>设 <span class="math inline">\(S=\left\{e_\alpha\right\}_{\alpha \in \mathrm{A}}\)</span> 是 <span class="math inline">\(H\)</span> 的一个正规正交基, 则对 <span class="math inline">\(\forall x \in H\)</span>, 有</p><ol type="1"><li>【傅里叶系数】<span class="math inline">\(x=\sum_{\alpha \in \mathrm{A}}\left(x, e_\alpha\right) e_\alpha\)</span></li><li>【帕塞瓦尔定理（勾股定理），完备性】<span class="math inline">\(\|x\|^2=\sum_{\alpha \in \mathbb{A}}\left|\left(x, e_\alpha\right)\right|^2\)</span></li></ol><h3 id="射影定理">射影定理</h3><p><strong>【射影定理】</strong> 设 <span class="math inline">\(M\)</span> 是Hilbert空间 <span class="math inline">\(H\)</span> 中闭的线性子空间 则 <span class="math inline">\(\forall x \in H\)</span>, 必存在唯一的 <span class="math inline">\(y \in M, z \in M^{\perp}\)</span>, 使得 <span class="math display">\[x=y+z\]</span> 其中<span class="math inline">\(y\)</span>就是<span class="math inline">\(x\)</span>在<span class="math inline">\(M\)</span>上的射影。</p><p><strong>【Frechet-Riesz表示定理】</strong> 设 <span class="math inline">\(H\)</span> 是Hilbert空间, 对 <span class="math inline">\(\forall f \in H^*, \exists ! z_f \in H\)</span>, 使得 <span class="math inline">\(f(x)\)</span> 可表示为 <span class="math display">\[f(x)=\left(x, z_f\right), \quad \forall x \in H,\]</span> 并且 <span class="math inline">\(\|\boldsymbol{f}\|=\left\|z_f\right\|\)</span>.</p><blockquote><p>例如，对<span class="math inline">\(R^3\)</span>而言， <span class="math display">\[f(x)=a x_1+b x_2+c x_3=\vec{x} \cdot \vec{n}\]</span> 其中 <span class="math inline">\(\vec{x}=\left\{x_1, x_2, x_3\right\}, \vec{n}=\{a, b, c\}\)</span>.要找的 <span class="math inline">\(z_f\)</span> 就是 <span class="math inline">\(\vec{n}\)</span>, 它是平面 <span class="math inline">\(f(x)=0\)</span> 的法向量.</p></blockquote><h2 id="巴拿赫banach空间的基本定理">巴拿赫（Banach）空间的基本定理</h2><h3 id="hahn-banach定理">Hahn-Banach定理</h3><p>【Hahn-Banach定理】 对于线性赋范空间 <span class="math inline">\(X\)</span> 中线性子空间 <span class="math inline">\(G\)</span> 上的连续线性泛函 <span class="math inline">\(f(x)\)</span>, 恒有 <span class="math inline">\(X\)</span> 上的连续线性泛函 <span class="math inline">\(F(x)\)</span>, 使得 1. <span class="math inline">\(F(x)=f(x), x \in G\)</span>, 2. <span class="math inline">\(\|\boldsymbol{F}\|=\|f\|_G\)</span>.</p><p>【推论1】设 <span class="math inline">\(X\)</span> 是线性赋范空间, 任给非零的 <span class="math inline">\(x_0 \in X\)</span>, 总存在 <span class="math inline">\(X\)</span> 上的 连续线性泛函 <span class="math inline">\(f\)</span>, 满足 1. <span class="math inline">\(\|f\|=1\)</span>, 2. <span class="math inline">\(f\left(x_0\right)=\left\|x_0\right\|\)</span>.</p><p>【推论1的几何形式】 任意球面<span class="math inline">\(S\)</span>上的任意一点<span class="math inline">\(x_0\)</span>，必定存在一个支撑超平面。</p><p>【推论2】设 <span class="math inline">\(X\)</span> 是线性赋范空间, <span class="math inline">\(E\)</span> 是 <span class="math inline">\(X\)</span> 的闭子空间, <span class="math inline">\(x_0 \notin E\)</span>, 则存在 <span class="math inline">\(X\)</span> 上的有界线性泛函 <span class="math inline">\(f\)</span>, 满足 1. <span class="math inline">\(f(x)=0, \forall x \in E\)</span> 2. <span class="math inline">\(f\left(x_0\right)=d\)</span>, 3. <span class="math inline">\(\|f\|=1, d \triangleq \operatorname{dist}\left(x_0, E\right)&gt;0\)</span>.</p><p>【Hahn-Banach定理的几何形式】若<span class="math inline">\(X\)</span>中的线性流形<span class="math inline">\(g\)</span>与开球<span class="math inline">\(B\)</span>不相交，则有超平面<span class="math inline">\(H\)</span>包含<span class="math inline">\(g\)</span>且与<span class="math inline">\(B\)</span>不相交</p><h3 id="banach逆算子定理">Banach逆算子定理</h3><p>【纲集】可数个稀疏并叫第一纲集，不是第一纲的叫第二纲集。</p><p>完备距离空间是第二纲集。</p><p>【开映射定理】 设 <span class="math inline">\(X, Y\)</span> 都是Banach空间, <span class="math inline">\(T \in \mathcal{L}(X, Y)\)</span>. 如果 <span class="math inline">\(\mathcal{R}(T)\)</span> 是第二纲集, 则 <span class="math inline">\(T\)</span> 为开映射.</p><p>【Banach逆算子定理】 设 <span class="math inline">\(X, Y\)</span> 都是Banach空间, <span class="math inline">\(T \in \mathcal{L}(X, Y)\)</span>. 如果 <span class="math inline">\(T\)</span> 既单又满, 则 <span class="math inline">\(T\)</span> 是有界可逆的, 即 <span class="math inline">\(T^{-1} \in \mathcal{L}(Y, X)\)</span>.</p><p>【等价范数定理】设线性空间 <span class="math inline">\(X\)</span> 上赋予了两个范数 <span class="math inline">\(\|\|_1,\|\|_2\)</span>, 它们都使 <span class="math inline">\(X\)</span> 成为Banach空间, 如果 <span class="math inline">\(\|\cdot\|_1\)</span> 强于 <span class="math inline">\(\|\cdot\|_2\)</span>, 则两个范数等价.</p><h3 id="闭图像定理">闭图像定理</h3><p>【闭算子】 设 <span class="math inline">\(X, Y\)</span> 是赋范线性空间, <span class="math inline">\(M\)</span> 是 <span class="math inline">\(X\)</span> 中的线性子空间， <span class="math inline">\(T: M \rightarrow Y\)</span> 线性算子, <span class="math inline">\(M\)</span> 称为 <span class="math inline">\(T\)</span> 的定义域, 记为 <span class="math inline">\(\mathcal{D}(T)\)</span>. 如果由 <span class="math display">\[x_n \in \mathcal{D}(T), x_n \rightarrow x_0 \text {, 与 } T x_n \rightarrow y_0,\]</span> 可推知 <span class="math inline">\(x_0 \in \mathcal{D}(T), T x_0=y_0\)</span>, 则称 <span class="math inline">\(T\)</span> 为闭算子.</p><p>【图像】设 <span class="math inline">\(X, Y\)</span> 是赋范线性空间, <span class="math inline">\(T: \mathcal{D}(T) \subset X \rightarrow Y\)</span> 线性算子, 定义其图像为： <span class="math display">\[\mathcal{G}(T)=\{(x, y) \in X \times Y: x \in \mathcal{D}(T), y=T x\},\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212171143426.png" alt="image-20221217114236831" /><figcaption aria-hidden="true">image-20221217114236831</figcaption></figure><p>若对 <span class="math inline">\((x, y) \in X \times Y\)</span>, 引进范数 <span class="math display">\[\|(x, y)\|=\|x\|+\|y\| \text {. }\]</span> 则 <span class="math inline">\(T\)</span> 是闭算子 <span class="math inline">\(\Leftrightarrow \mathcal{G}(T)\)</span> 是 <span class="math inline">\(X \times Y\)</span> 中的闭集.</p><p>【闭图像定理】 设 <span class="math inline">\(X, Y\)</span> 是Banach空间, <span class="math inline">\(T: X \rightarrow Y\)</span> 闭算子, 则 <span class="math inline">\(T\)</span> 为有界的.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>所有收敛列都是基本列是永远成立的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实变泛函</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·傅里叶之章</title>
    <link href="/2022/12/08/DSP3/"/>
    <url>/2022/12/08/DSP3/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="离散傅里叶变换dft">离散傅里叶变换DFT</h2><p>我们之前已学过很多“变换”了，例如连续时间信号傅里叶变换FT、连续时间信号傅里叶级数FS、离散时间序列傅里叶变换DTFT、离散时间序列傅里叶级数FS。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212081540465.png" alt="各个变换" /><figcaption aria-hidden="true">各个变换</figcaption></figure><p>因为数字系统只能处理离散序列，而这其中只有DFS同时在时域和频域是离散的。但是DFS又是周期无限长序列，而现有的数字系统仍然不能实现。因此我们必须考虑用有限长序列建立时域离散和频域离散的关系。</p><p>设<span class="math inline">\(\widetilde{x}[n]\)</span>是周期为<span class="math inline">\(N\)</span>的周期序列，那么称 <span class="math display">\[x[n]=\widetilde x[n]R_N[n]\]</span> 为“主值序列”，也就是原序列的第<span class="math inline">\(0\sim N-1\)</span>个值。</p><p>设<span class="math inline">\(x[n]\)</span>是长度为<span class="math inline">\(N\)</span>的有限长序列，那么为了将其周期性延拓，有： <span class="math display">\[\widetilde  {x}[n]=\sum_{r=-\infty}^{\infty} x[n+r N]\]</span></p><p>记作： <span class="math display">\[\widetilde{x}[n]=x[((n))_N]\]</span> 其中<span class="math inline">\(((n))_N\)</span>称作取模运算，设<span class="math inline">\(n=mN+n_1\)</span>，则<span class="math inline">\(((n))_N=n_1\)</span>。</p><p>周期序列<span class="math inline">\(\widetilde x[n],\widetilde X[k]\)</span>可以看作有限长序列<span class="math inline">\(x[n],X[k]\)</span>的周期延拓，因此只需计算主值区间中的DFS，即可对周期序列进行恢复。有DFT的定义： <span class="math display">\[\begin{gathered}x[n]=\frac{1}{N} \sum_{k=0}^{N-1} X[k] \mathrm{e}^{\frac{2\pi k n}{N}} \\X[k]=\sum_{n=0}^{N-1} x[n] \mathrm{e}^{j \frac{-2 \pi k n}{N}}\end{gathered}\]</span> 我们可以看出：DFT并不是一个新的变换形式，而是DFS在实频域的主值序列，因此其很多性质和DFS有类似性。</p><h3 id="几大变换之间的关系">几大变换之间的关系</h3><p>以下：将Z变换记作<span class="math inline">\(X(z)\)</span>，将DTFT（离散时间序列傅里叶变换）记作<span class="math inline">\(X(e^{j\omega})\)</span>，将DFS（离散时间序列傅里叶级数）记作<span class="math inline">\(\widetilde X[k]\)</span>，将DFT（离散傅里叶变换）记作<span class="math inline">\(X[k]\)</span>。</p><h4 id="z变换和dtft">Z变换和DTFT</h4><p><span class="math inline">\(x[n]\)</span>的DTFT是其Z变换在单位圆上的采样。即： <span class="math display">\[X\left(\mathrm{e}^{j w}\right)=\left.X(z)\right|_{z=e^{j\omega}}\]</span></p><h4 id="dtft和dfs">DTFT和DFS</h4><p>对<span class="math inline">\(X(e^{j\omega})\)</span>在<span class="math inline">\(\omega \in [0,2\pi)\)</span>的等间隔频率点进行<span class="math inline">\(N\)</span>点采样得到周期序列<span class="math inline">\(\widetilde X[k]\)</span>。对<span class="math inline">\(\widetilde X[k]\)</span>作IDFS（离散时间序列傅里叶级数逆变换），得到序列<span class="math inline">\(\widetilde x_N[n]\)</span>。</p><p>由： <span class="math display">\[\tilde{X}[k]=\left.X\left(\mathrm{e}^{j \omega}\right)\right|_{\omega=\frac{2 \pi i}{N}}=\sum_{n=-\infty}^{\infty} x[n] \mathrm{e}^{-j \frac{2 \pi}{N} k n}\]</span> 和 <span class="math display">\[\tilde{x}_N[n]=\operatorname{IDFS}[\tilde{X}[k]]=\frac{1}{N} \sum_{k=0}^{N-1} \widetilde {X}[k] \mathrm{e}^{j\frac{2 \pi}{N} k n}\]</span> 把上式带入下式，有： <span class="math display">\[\widetilde x_N[n]=\sum_{m=-\infty}^{\infty} x[m]\left[\frac{1}{N} \sum_{k=0}^{N-1} \mathrm{e}^{-j \frac{2 \pi}{N} k(m-n)}\right]\]</span> 有复指数函数的正交性和周期性，有： <span class="math display">\[\begin{aligned}\tilde{x}_N[n]&amp;=\sum_{m=-\infty}^{\infty} x[m]\left[\sum_{r=-\infty}^{\infty} \delta[m-n-r N]\right]\\&amp;=\cdots+x[n+N]+x[n]+x[n-N]+\cdots\end{aligned}\]</span> 可以看到，<span class="math inline">\(\widetilde x_N[n]\)</span>是<span class="math inline">\(x[n]\)</span>的周期移位。也就是说，正如<strong>时域采样会导致频域周期延拓，频域采样也会导致时域周期延拓</strong>。下面按<span class="math inline">\(x[n]\)</span>的长度<span class="math inline">\(L\)</span>和频域采样数<span class="math inline">\(N\)</span>分情况讨论：</p><ol type="1"><li>非周期序列<span class="math inline">\(x[n]\)</span>不是有限长序列，则频域采样一定会造成混叠</li><li><span class="math inline">\(N&lt;L\)</span>时，仍会产生时域混叠失真。混叠的长度就是<span class="math inline">\(L-N\)</span>，参考上面的式子</li><li><span class="math inline">\(N\geq L\)</span>时，才能由频域采样<span class="math inline">\(\tilde X[k]\)</span>恢复出<span class="math inline">\(x[n]\)</span></li></ol><h4 id="dfs和dft">DFS和DFT</h4><p>如前文所说，DFT和DFS本质上来说是一种变换，不过DFS的离散时间序列是周期的，变换得到的频域也是周期的，DFT是DFS的主值序列。</p><h3 id="dft的性质和定理">DFT的性质和定理</h3><p>在研究DFT的性质时，需要时刻注意DFT的有限定长度性以及循环周期性。当涉及到两个长度不同的序列时，要通过补0的方式使其长度均为<span class="math inline">\(N\geq max(N_1,N_2)\)</span>。</p><ol type="1"><li><p>线性</p></li><li><p>时域循环位移性质</p><p>这里的循环移位是圆周移位，在序列中，从左（右）边移出多少位，就会从右（左）边移入相同位的序列值。 <span class="math display">\[x\left[\left(\left(n+n_d\right)\right)_N\right] R_N[n] \underset{N-\mathrm{IDFT}}{\stackrel{N-\mathrm{DFT}}{\longrightarrow}} \mathrm{e}^{j\left(2 \pi kn_d / N\right)} X[k]\]</span></p></li><li><p>频域循环位移性质 <span class="math display">\[\mathrm{e}^{\mathrm{j}(2 \pi k / N) l n} x[n] \underset{N-\mathrm{IDFT}}{\stackrel{N-\mathrm{DFT}}{\rightleftarrows}} X\left[((k-l))_N\right] R_N[n]\]</span></p></li><li><p>时间倒置性质 <span class="math display">\[x[-n] \underset{N-\mathrm{IDFT}}{\stackrel{N-\mathrm{DFT}}{\rightleftarrows}} X[-k]\]</span></p></li><li><p>此外，还有实频域循环卷积、对偶、帕塞瓦尔等性质。</p></li></ol><h3 id="dft的对称性">DFT的对称性</h3><p>和DFS的基本相同。重点是：DFT的对称都是“圆周对称”。对于圆周共轭对称序列，有： <span class="math display">\[x[n]=x^*[N-n]\]</span> 对于圆周共轭反对称序列，有： <span class="math display">\[x[n]=-x^*[N-n]\]</span> 如果<span class="math inline">\(x[n]\)</span>是实信号，那么它的DFT<span class="math inline">\(X[k]\)</span>是圆周共轭对称的。也就是说它的实部<span class="math inline">\(X_{Re}[k]\)</span>是圆周偶对称，虚部是圆周奇对称。</p><h3 id="用dft实现线性卷积">用DFT实现线性卷积</h3><p>这是我们之前几章经常用的线性卷积： <span class="math display">\[y_l[n]=x[n] * h[n]=\sum_{m=-\infty}^{+\infty} h[m] x[n-m]\]</span> 这是我们DFT里经常用的N点循环卷积： <span class="math display">\[y_c[n]=x[n] N h[n]=\left(\sum_{m=0}^{N-1} h[m] x\left[((n-m))_N\right]\right) R_N[n]\]</span> 把<span class="math inline">\(x\left[((n-m))_N\right]=\sum_{i=-\infty}^{+\infty} x[n-m+i N]\)</span> 带入，有： <span class="math display">\[\begin{aligned}y_c[n] &amp; =\left(\sum_{m=0}^{N-1} x[m] h\left[((n-m))_N\right]\right) R_N[n] \\&amp; =\left(\sum_{m=0}^{N-1} h[m] \sum_{i=-\infty}^{+\infty} x[n-m+i N]\right) R_N[n] \\&amp; =\left(\sum_{i=-\infty}^{+\infty} \sum_{m=0}^{N-1} h[m] x[n-m+i N]\right) R_N[n] \\&amp; =\left(\sum_{i=-\infty}^{+\infty} y_l[n+i N]\right) R_N[n]\end{aligned}\]</span> 于是，我们可以证明：循环卷积的结果是线性卷积以<span class="math inline">\(N\)</span>为周期的周期延拓的序列的主值序列。因为线性卷积序列的长度是<span class="math inline">\(L+P-1\)</span>，于是循环卷积的点数必须满足<span class="math inline">\(N\geq L+P-1\)</span>时，才不会发生混叠，取主值序列时才满足<span class="math inline">\(y_c[n]=y_l[n]\)</span></p><p>根据上述推理，我们可以利用DFT来实现卷积，计算框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212081757914.png" alt="DFT实现线性卷积" /><figcaption aria-hidden="true">DFT实现线性卷积</figcaption></figure><h4 id="dft实现线性系统块卷积方法">DFT实现线性系统（块卷积方法）</h4><p>在实际的操作中，输入序列<span class="math inline">\(x[n]\)</span>的长度远远大于冲激响应<span class="math inline">\(h[n]\)</span>的长度<span class="math inline">\(P\)</span>，所以计算效率比较低，所以需要分段处理，把输入序列分成长度为<span class="math inline">\(L\)</span>的块，再进行计算。有两种方法，分别是重叠相加法和重叠保留法。</p><p><strong>重叠相加法：</strong></p><p>把输入序列按顺序直接切割成若干个长度为<span class="math inline">\(L\)</span>的段序列<span class="math inline">\(x_r[n]\)</span>，即： <span class="math display">\[x_r[n]= \begin{cases}x[n+r L], &amp; 0 \leqslant n \leqslant L-1 \\ 0, &amp; \text { 其他 }\end{cases}\]</span> 对每个分段信号，和<span class="math inline">\(h[n]\)</span>进行线性卷积： <span class="math display">\[y_r[n]=x_r[n] * h[n]\]</span> 其中<span class="math inline">\(y_r[n]\)</span>是长度为<span class="math inline">\(L+P-1\)</span>的序列。由卷积的性质，有： <span class="math display">\[y[n]=\sum_{r=0}^{\infty} x_r[n-r L] * h[n]\]</span> 则： <span class="math display">\[y[n]=\sum_{r=0}^{\infty} y_r[n-r L]\]</span> 也就是说，尽管相邻两段<span class="math inline">\(y_r\)</span>会有重叠部分，但是加的时候不要管，直接叠加就行了。所以，这种方法叫做重叠相加法。</p><p><strong>重叠保留法：</strong></p><p>重叠保留法在对<span class="math inline">\(x[n]\)</span>分割成<span class="math inline">\(x_r[n]\)</span>时，两个相邻的<span class="math inline">\(x_r[n]\)</span>之间存在<span class="math inline">\(P-1\)</span>长度的重叠，即： <span class="math display">\[x_r[n]=x[n+r(L-P+1)-P+1], 0 \leqslant n \leqslant L-1\]</span> 有： <span class="math display">\[y[n]=\sum_{r=0}^{\infty} y_r[n-r(L-P+1)+P-1]\]</span> 把每个序列段和<span class="math inline">\(h[n]\)</span>的线性卷积记作<span class="math inline">\(y_{rp}[n]\)</span>则： <span class="math display">\[y_r= \begin{cases}y_{rp}[n], &amp; P-1 \leqslant n \leqslant L-1 \\ 0, &amp; \text { 其他 }\end{cases}\]</span> 意思是，在拼接时，每个<span class="math inline">\(y_r\)</span>序列都应该去掉<span class="math inline">\(0\leq n\leq P-2\)</span>和<span class="math inline">\(L\leq n\leq L+P-1\)</span>的部分。但是，明明拼接时去掉了一部分，为什么要叫“重叠保留”呢？哈哈。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212081959819.png" alt="块卷积方法" /><figcaption aria-hidden="true">块卷积方法</figcaption></figure><h2 id="快速傅里叶变换fft">快速傅里叶变换FFT</h2><p>一般的DFT，其时间复杂度是<span class="math inline">\(O(N^2)\)</span>，难以处理很长的数据。FFT把计算复杂度降低到了<span class="math inline">\(\frac N2 \log_2 N\)</span>次，大大提高了计算效率。FFT的实质是分治算法，把一个长度为<span class="math inline">\(N\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="在本节中，进行FFT的序列长度默认为2的整数次幂，不足则用0补齐。">[1]</span></a></sup>的序列不断地分拆成长度为<span class="math inline">\(N/2\)</span>，再利用旋转因子<span class="math inline">\(W_N^{nk}\)</span>（即<span class="math inline">\(\exp(-j\frac{2\pi kn}{N})\)</span>）的性质由子序列的DFT来合成整个序列的DFT。</p><h3 id="时间抽取ditfft">时间抽取（DIT）FFT</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082052669.png" alt="时间抽取FFT" /><figcaption aria-hidden="true">时间抽取FFT</figcaption></figure><p>这是DIT-FFT的基本框图。把长度为<span class="math inline">\(N\)</span>的序列<span class="math inline">\(x[n]\)</span>按奇偶分为两个长度为<span class="math inline">\(N/2\)</span>的序列<span class="math inline">\(g[n],h[n]\)</span>。接下来我们来<strong>推导“组合成长序列”这一步</strong>究竟是如何进行的。</p><p>由傅里叶变换定义式： <span class="math display">\[{X}[{k}]=\sum_{n=0}^{N-1} {x}[{n}] \cdot e^{-j \frac{2 \pi k}{N} n}\]</span> 把<span class="math inline">\(x[n]\)</span>分解为奇数偶数两部分： <span class="math display">\[ {X}[ {k}]=\sum_{ {r}=0}^{\frac{N}{2}-1}  {x}[2  {r}] e^{-j \frac{2 \pi k}{N} 2  {r}}+\sum_{r=0}^{\frac{N}{2}-1}  {x}[2  {r}+1] e^{-j \frac{2 \pi k}{N}(2  {r}+1)}\]</span> 把等式右侧的<span class="math inline">\(\exp [-j\frac{2\pi k}{N}(2r+1)]\)</span>分解开，有： <span class="math display">\[X[k]=\sum_{r=0}^{\frac{N}{2}-1}  {g}[ {r}] e^{-j \frac{2 \pi k}{N} 2 r}+\sum_{r=0}^{\frac{N}{2}-1}  {h}[ {r}] e^{-j \frac{2 \pi k}{N} 2 r} e^{-j \frac{2 \pi k}{N}}\]</span> 再回忆一下傅里叶变换的定义： <span class="math display">\[G[k]=\sum_{r=0}^{\frac N2-1}g[r]e^{-j\frac{2\pi k}{N/2}r}\]</span></p><p><span class="math display">\[H[k]=\sum_{r=0}^{\frac N2-1}h[r]e^{-j\frac{2\pi k}{N/2}r}\]</span></p><p>我们惊喜地发现：可以代换了。有： <span class="math display">\[X[k]=G[k]+e^{-j\frac{2\pi k}{N}}H[k]\]</span> 只要再注意到<span class="math inline">\(G,H\)</span>都是以<span class="math inline">\(N/2\)</span>为周期的，那么“组合成长序列”的方法已经昭然若揭了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082117370.png" alt="组合成长序列" /><figcaption aria-hidden="true">组合成长序列</figcaption></figure><p>当然，这个图还可以继续优化，只需要注意到： <span class="math display">\[e^{j\frac{2\pi N/2}{N}}=-1,e^{j\frac{2\pi}{N}(k+\frac N2)}=-e^{j\frac{2\pi}{N}k}\]</span> 有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082119083.png" alt="优化" /><figcaption aria-hidden="true">优化</figcaption></figure><p>接下来如法炮制，对<span class="math inline">\(g,h\)</span>进行分析，把它们分解为<span class="math inline">\(N/4\)</span>的序列，进行计算，直到序列的长度只有2为止。此时，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082125722.png" alt="序列长度只有2" /><figcaption aria-hidden="true">序列长度只有2</figcaption></figure><p>我们得到了计算这个长度为8的序列的FFT的全过程流图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082126128.png" alt="全过程流图" /><figcaption aria-hidden="true">全过程流图</figcaption></figure><h3 id="按频率抽取diffft">按频率抽取（DIF）FFT</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082132719.png" alt="按频率抽取" /><figcaption aria-hidden="true">按频率抽取</figcaption></figure>仿照上面的过程，我们来<strong>推导“组合成短序列”的过程</strong>。由DFT的定义： <span class="math display">\[X[k]=\sum_{n=0}^{N-1} x[n] \cdot e^{-j \frac{2 \pi k}{N} n}\]</span> 把它拆开： $$<span class="math display">\[\begin{aligned}{X}[{k}]&amp;=\sum_{n=0}^{N / 2-1} x[{n}] e^{-j \frac{2 \pi k}{N} n}+\sum_{n=N / 2}^{N-1} x[n] e^{-j \frac{2 \pi k}{N} n}\\&amp;=\sum_{n=0}^{\frac{N}{2}-1} {x}[{n}] e^{-j \frac{2 \pi k}{N} n}+\sum_{r=0}^{\frac{N}{2}-1} x\left[r+\frac{N}{2}\right] e^{-j \frac{2 \pi k}{N}\left(r+\frac{N}{2}\right)}\\&amp;=\sum_{n=0}^{\frac{N}{2}-1}  {x}[ {n}]  {e}^{-j \frac{2 \pi k}{N} n}+\sum_{n=0}^{\frac{N}{2}-1}  {e}^{-j \pi k}  {x}\left[ {n}+\frac{N}{2}\right] e^{-j \frac{2 \pi k}{N} n}\\&amp;=\sum_{n=0}^{\frac{N}{2}-1}\left(x[n]+e^{-j \pi k} x\left[n+\frac{N}{2}\right]\right) e^{-j \frac{2 \pi k}{N} n}\end{aligned}\]</span><span class="math display">\[然后，我们分别让$k=2r,2r+1$，有：\]</span><span class="math display">\[\begin{cases}X[2 r+1]=\sum_{n=0}^{\frac{N}{2}-1}\left(\left(x[n]-x\left[n+\frac{N}{2}\right]\right) e^{-j \frac{2 \pi}{N} n}\right) e^{-j \frac{2 \pi r}{N / 2} n}\\X[2 r]=\sum_{n=0}^{\frac{N}{2}-1}\left(x[n]+x\left[n+\frac{N}{2}\right]\right) e^{-j \frac{2 \pi r}{N / 2} n}\end{cases}\]</span><span class="math display">\[即：\]</span><span class="math display">\[\begin{cases}X[2r+1]=DFT\left\{x[n]-x[n+\frac N2]e^{-j\frac{2\pi}Nn}\right\}\\X[2r]=DFT\left\{x[n]+x[n+\frac N2]\right\}\end{cases}\]</span><p>$$ 于是，我们可以画出流图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082153498.png" alt="DIF流图" /><figcaption aria-hidden="true">DIF流图</figcaption></figure><p>如此重复，直到序列长度为2，有：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082154503.png" alt="长度为2的流图" /><figcaption aria-hidden="true">长度为2的流图</figcaption></figure><p>于是，全过程流图为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212082154066.png" alt="DIFFFT全过程流图" /><figcaption aria-hidden="true">DIFFFT全过程流图</figcaption></figure><h3 id="ifft">IFFT</h3><p>在不修改电路（程序）的情况下，直接借用FFT的模块实现IFFT，有两种操作方法。</p><ol type="1"><li>把蝶形运算中的旋转因子<span class="math inline">\(W_N^k\)</span>换成<span class="math inline">\(W_N^{-k}\)</span>，把<span class="math inline">\(X[k]\)</span>送进输入端，对输出的结果除以<span class="math inline">\(N\)</span></li><li>把<span class="math inline">\(X^*[k]\)</span>送入输入端，计算输出的共轭，然后除以<span class="math inline">\(N\)</span></li></ol><h3 id="实数序列的fft">实数序列的FFT</h3><p>前面所提到的序列都是复序列。如果要计算实数，当然可以把它当成虚部为零的复数，但是也有更简便的计算方法。</p><h4 id="n点fft计算两个n点实序列">N点FFT计算两个N点实序列</h4><p>构造复序列<span class="math inline">\(x[n]=x_1[n]+jx_2[n]\)</span>，则有： <span class="math display">\[X_1[k]=X_{e p}[k]= \begin{cases}X_{\mathrm{Re}}[0], &amp; k=0 \\ \frac{1}{2}\left(X[k]+X^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><p><span class="math display">\[X_2[k]=X_{\text {op }}[k]= \begin{cases}X_{1 \mathrm{~s}}[0], &amp; k=0 \\ -\frac{\mathrm{j}}{2}\left(X[k]-X^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><h4 id="n点fft计算2n点实序列">N点FFT计算2N点实序列</h4><p>构造复序列<span class="math inline">\(x[n]=g[n]+jh[n]\)</span>，其中<span class="math inline">\(g\)</span>是原实序列的偶数项，<span class="math inline">\(h\)</span>是原实序列的奇数项。则有： <span class="math display">\[G[k]=Y_{e p}[k]= \begin{cases}Y_{\mathrm{k}_*}[0], &amp; k=0 \\ \frac{1}{2}\left(Y[k]+Y^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><p><span class="math display">\[H[k]=Y_{\text {ap }}[k]= \begin{cases}Y_{1 \mathrm{~m}}[0], &amp; k=0 \\ -\frac{\mathrm{j}}{2}\left(Y[k]-Y^*[N-k]\right), &amp; 0&lt;k&lt;N\end{cases}\]</span></p><p><span class="math display">\[X[k]= \begin{cases}G[k]+W_{2 v}^k H[k], &amp; k=0,1, \cdots, N-1 \\ G[k-N]-W_{2 N}^{k-N} H[k-N], &amp; k=N, N+1, \cdots, 2 N-1\end{cases}\]</span></p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>在本节中，进行FFT的序列长度默认为2的整数次幂，不足则用0补齐。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·系统之章</title>
    <link href="/2022/12/08/DSP2/"/>
    <url>/2022/12/08/DSP2/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="离散系统变换域分析">离散系统变换域分析</h2><p>表示LTI系统有很多方法，我们常用三种：</p><ul><li>单位脉冲响应 <span class="math inline">\(h[n]\)</span></li><li>单位脉冲响应的频谱密度函数（DTFT） <span class="math inline">\(H(e^{j\omega})\)</span></li><li>系统函数（单位脉冲响应的Z变换） <span class="math inline">\(H(z)\)</span></li></ul><h3 id="lti系统的频域表示">LTI系统的频域表示</h3><h4 id="特征函数和频率响应">特征函数和频率响应</h4><p>对于LTI系统，对于某些输入序列，输出序列是输入序列和某个复常数的乘积。这样的输入序列叫做特征函数，复常数叫做系统的特征值。</p><p>由于输入序列为<span class="math inline">\(x[n]=e^{j\omega n}\)</span>时，有 <span class="math display">\[y[n]=x[n]*h[n]=\sum_{k=-\infty}^\infty e^{j\omega(n-k)}h[k]=e^{j\omega n}H(e^{j\omega})\]</span> 所以LTI系统的其中一个特征函数就是<span class="math inline">\(x[n]=e^{j\omega n}\)</span>（事实上，所有的指数型函数，例如<span class="math inline">\(5^n\)</span>等，都是特征函数，而且，指数型函数和指数型函数的有限项乘积也是特征函数，但是形容<span class="math inline">\(e^{j\omega n}u[n]\)</span>这种就不行），其对应的特征值为<span class="math inline">\(H(e^{j\omega})\)</span>。</p><p>而且，由傅里叶变换，我们知道：序列<span class="math inline">\(x[n]\)</span>往往可以表示为<span class="math inline">\(e^{j\omega n}\)</span>的线性组合，即<span class="math inline">\(x[n]=\frac{1}{2\pi}\int_{-\pi}^\pi X(e^{j\omega})e^{j\omega n}d\omega\)</span>。于是，我们将其中的每一项乘以对应的特征值，就得到了输出<span class="math inline">\(y[n]=\frac{1}{2\pi}\int_{-\pi}^\pi X(e^{j\omega})H(e^{j\omega})e^{j\omega n}d\omega\)</span>。于是我们得到了： <span class="math display">\[Y(e^{j\omega})=X(e^{j\omega})H(e^{j\omega})\]</span> 如果LTI系统的相频响应满足<span class="math inline">\(\angle H(e^{j\omega})=-\omega n_d\)</span>，那么称这样的系统为线性相位系统。线性相位系统对所有频率分量<span class="math inline">\(e^{j\omega n}\)</span>造成的延迟均为<span class="math inline">\(n_d\)</span>。一般来说，我们用群延时衡量相位变化对信号的影响，有： <span class="math display">\[\tau(\omega)=-\frac{d}{d\omega}\angle H(e^{j\omega})\]</span> 如果群延时不是常数，那么会造成输出信号的失真，这称为色散。</p><h4 id="lti系统的z变换分析">LTI系统的Z变换分析</h4><p>对于以下差分方程表示的系统： <span class="math display">\[y[n]=\sum_{k=1}^N a_ky[n-k]+\sum_{k=0}^Mb[k]x[n-k]\]</span> 在有初始松弛条件（零状态）时，是因果LTI系统。其系统函数为： <span class="math display">\[H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^M b_kz^{-k}}{1-\sum_{k=1}^N a_kz^{-k}}\]</span> 也可以把它表示为因式的形式： <span class="math display">\[H(z)=\frac{b_0}{a_0}\frac{\prod_{m=1}^M(1-c_mz^{-1})}{\prod_{n=1}^N (1-d_nz^{-1})}\]</span> 关于系统的因果和稳定性，有如下结论：</p><ul><li>LTI系统是因果的 等价于 <span class="math inline">\(H(z)\)</span>的收敛域包含无穷远点</li><li>LTI系统是稳定的 等价于<span class="math inline">\(H(z)\)</span>在单位圆上是收敛的</li></ul><p>关于系统的零极点和幅频响应的关系，有如下结论：</p><ul><li>对于单零点系统，零点为<span class="math inline">\(c\)</span>，当<span class="math inline">\(\omega=\theta_c\)</span>时，幅频响应是极小值，零点越靠近单位圆，幅频响应的极小值越小，当零点在单位圆上时，这个极小值为<span class="math inline">\(0\)</span>(如果采用对数坐标则为负无穷)</li><li>对于单极点系统，极点为<span class="math inline">\(d\)</span>，当<span class="math inline">\(\omega=\theta_d\)</span>时，幅频响应是极大值，极点越靠近单位圆，幅频响应的极大值越大，当极点在单位圆上时，这个极大值为正无穷。极点在单位圆上或单位圆外，则系统不稳定。</li></ul><h4 id="有理系统的全通分解">有理系统的全通分解</h4><ul><li><p>幅频特性相同的系统</p><p>若有一个有理实系统，把其中的若干个零点或极点用它的共轭倒数代替，新系统的幅频响应和原来的系统相同。于是，如果设计好一个系统的幅频特性，一定存在符合要求的因果稳定LTI系统，其极点都在单位圆内。</p></li><li><p>全通系统</p><p>全通指的是<span class="math inline">\(|H(e^{j\omega})|\equiv1\)</span>的系统，仅有相频特性随频率变化而变化。全通系统的零极点相对单位圆是镜像共轭成对的。也就是说：如果<span class="math inline">\(a_i\)</span>是系统的零点，那么<span class="math inline">\((a_i^*)^{-1}\)</span>，即<span class="math inline">\(a_i\)</span>的共轭的倒数，定是全通系统的极点。而且，对于有理实系数系统来说，零点和极点本身也是共轭成对的，即如果<span class="math inline">\(b_i\)</span>是零点或极点，那么它的共轭一定也是零点或极点。</p><p>全通系统具有以下性质：</p><ul><li><p>相位特性随频率单调下降，即 <span class="math display">\[\frac{\rm d\theta(\omega)}{\rm d\omega}&lt;0\]</span></p></li><li><p>输入信号<span class="math inline">\(x[n]\)</span>和输出信号<span class="math inline">\(y[n]\)</span>的能量相同，即 <span class="math display">\[\sum_{n=-\infty}^\infty\lvert x[n]\rvert^2=\sum_{n=-\infty}^\infty\lvert y[n]\rvert^2\]</span></p></li><li><p>当频率<span class="math inline">\(\omega\)</span>从<span class="math inline">\(0\)</span>变化到<span class="math inline">\(\pi\)</span>时，<span class="math inline">\(N\)</span>阶全通系统的相位改变为<span class="math inline">\(N\pi\)</span></p></li></ul><p>全通系统的应用主要在作相位均衡器，或者通过级联全通系统的方法提高系统的稳定性。</p></li><li><p>最小相位系统</p><p>对于一个离散时间因果稳定系统，它的极点都在单位圆内。如果在此基础上，零点也都在单位圆内，那么这样的系统叫做最小相位系统<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="也就是说最小相位系统的意思就是零极点都在单位圆内。">[3]</span></a></sup>；如果零点全在单位圆外，叫最大相位系统；如果零点在单位圆内外都有，叫混合相位系统。</p><p>最小相位系统有以下性质：</p><ul><li>在所有幅频响应相同的因果稳定系统中，最小相位系统的相位延迟最小</li><li>在所有幅频响应相同的实系数因果稳定系统中，最小相位系统的群延时最小</li><li>最小相位系统的逆系统也是最小相位系统</li></ul><blockquote><p>【例】因果序列<span class="math inline">\(x[n]\)</span>的<span class="math inline">\(z\)</span>变换为 <span class="math display">\[X(z)=\frac{\left(1-\frac 12 z^{-1}\right)\left(1-\frac 14 z^{-1}\right)\left(1-\frac 15 z\right)}{\left(1-\frac 16 z\right)}\]</span> 又已知<span class="math inline">\(\alpha^nx[n]\)</span>是一个最小相位系统，求<span class="math inline">\(\alpha\)</span>的范围。</p><p>【解】只有不在单位圆内的有一个零点<span class="math inline">\(5\)</span>和一个极点<span class="math inline">\(6\)</span>。记<span class="math inline">\(y[n]=\alpha^nx[n]\)</span>，则有 <span class="math display">\[Y(z)=\sum_{n=-\infty}^\infty\alpha^nx[n]z^{-n}=X\left(\frac z\alpha\right)\]</span> 如果<span class="math inline">\(a_i\)</span>是<span class="math inline">\(X(z)\)</span>的零点或极点，那么<span class="math inline">\(a_i\cdot\alpha\)</span>就是<span class="math inline">\(Y(z)\)</span>的零点或极点。为了让<span class="math inline">\(Y(z)\)</span>的所有零极点都在单位圆内，只需调整<span class="math inline">\(\alpha\)</span>，让<span class="math inline">\(6\alpha\)</span>在单位圆内即可。于是有： <span class="math display">\[\alpha&lt;\frac 16\]</span></p></blockquote></li><li><p>有理系统的全通分解</p><p>任何有理系统函数都可以分解为最小相位系统<span class="math inline">\(H_{min}(z)\)</span>和全通系统<span class="math inline">\(H_{ap}(z)\)</span>级联的形式。假设系统仅有一个单位圆外的零点<span class="math inline">\((c^*)^{-1}\)</span>，即： <span class="math display">\[H(z)=H_1(z)(z^{-1}-c^*)\]</span> 则<span class="math inline">\(H_1\)</span>的零极点都在单位圆内，是最小相位系统。上式可以进一步表示为： <span class="math display">\[H(z)=H_1(z)(z^{-1}-c^*)\frac{1-cz^{-1}}{1-cz^{-1}}=H_1(z)(1-cz^{-1})\frac{z^{-1}-c^*}{1-cz^{-1}}\]</span> 其中<span class="math inline">\(\frac{z^{-1}-c^*}{1-cz^{-1}}\)</span>的零点是<span class="math inline">\((c^*)^{-1}\)</span>，极点是<span class="math inline">\(c\)</span>，互为共轭倒数，是全通系统，记作<span class="math inline">\(H_{ap}(z)\)</span>。因为<span class="math inline">\(|z|&lt;1\)</span>，其余部分是最小相位系统，记作<span class="math inline">\(H_{min}(z)\)</span>，于是分解完成。</p><p>上述过程的实质是在单位圆外零点<span class="math inline">\((c^*)^{-1}\)</span>的共轭倒数<span class="math inline">\(c\)</span>的位置放置了一个零点和一个极点。<span class="math inline">\(c\)</span>上的极点和<span class="math inline">\((c^*)^{-1}\)</span>这个零点一起构成了全通系统；<span class="math inline">\(c\)</span>上的极点和原来系统的其它零极点构成了最小相位系统。</p><blockquote><p>【例】把以下系统分解成全通系统和最小相位系统的级联 <span class="math display">\[H(z)=\frac{1-3z^{-1}}{1+\frac 12 z^{-1}}\]</span> 【解】该系统有<span class="math inline">\(z=-1/2\)</span>的极点和<span class="math inline">\(z=3\)</span>的零点。即<span class="math inline">\((c^*)^{-1}=3\)</span>，得<span class="math inline">\(c=1/3\)</span>。则有： <span class="math display">\[\begin{align}H(z)&amp;=\frac{-3}{1+\frac 12 z^{-1}}\left(z^{-1}-\frac 13\right)\\&amp;=-3\left(\frac{1-\frac 13z^{-1}}{1+\frac 12 z^{-1}}\right)\left(\frac{z^{-1}-\frac 13}{1-\frac 13z^{-1}}\right)\end{align}\]</span> 于是： <span class="math display">\[H_{min}(z)=-3\left(\frac{1-\frac 13z^{-1}}{1+\frac 12 z^{-1}}\right)\]</span></p><p><span class="math display">\[H_{ap}(z)=\left(\frac{z^{-1}-\frac 13}{1-\frac 13z^{-1}}\right)\]</span></p></blockquote></li></ul><h4 id="广义线性相位系统">广义线性相位系统</h4><p>我们之前所说的经典频响是这样的： <span class="math display">\[H(e^{j\omega})=|H(e^{j\omega})|e^{j\angle H(e^{j\omega})}\]</span> 这时<span class="math inline">\(|H|\)</span>叫经典幅频响应，<span class="math inline">\(\angle H\)</span>叫经典相频响应.但是现在我们引入广义响应： <span class="math display">\[H(e^{j\omega})=A(e^{j\omega})e^{j\varphi(\omega)}\]</span> 这时候，<span class="math inline">\(A\)</span>叫做“广义幅频响应”，而<span class="math inline">\(\varphi\)</span>叫做“广义相频响应”。请注意“经典”和“广义”的不同：经典幅频响应永远是正的，而广义相频响应可以是负的。因此，广义相频响应和经典相频响应，在<span class="math inline">\(A\)</span>变成负数的时候，会有一个<span class="math inline">\(\pi\)</span>的差距。</p><p>所谓的线性相位的意思是，系统对不同频率的正弦信号所产生的相移和正弦信号的频率呈线性关系。即： <span class="math display">\[\angle H(e^{j\omega})=-\alpha \omega\]</span> 那么广义线性相位的意思就是，给这个加上一个常数，变成 <span class="math display">\[\angle H(e^{j\omega})=\beta-\alpha \omega\]</span> 经过一番数学推导，相频响应满足上面式子的系统的单位脉冲响应满足以下等式： <span class="math display">\[\sum_{n=-\infty}^\infty h[n]\sin(\omega(n-\alpha)+\beta)=0\]</span> 满足上面式子的情况的两组解如下：</p><ul><li><span class="math inline">\(\beta=0\)</span>或<span class="math inline">\(\pi\)</span>，<span class="math inline">\(2\alpha=M\in \mathbb N\)</span>，<span class="math inline">\(h[2\alpha-n]=h[n]\)</span></li><li><span class="math inline">\(\beta=\pi/2\)</span>或<span class="math inline">\(3\pi/2\)</span>，<span class="math inline">\(2\alpha=M\in \mathbb N\)</span>，<span class="math inline">\(h[2\alpha-n]=-h[n]\)</span></li></ul><p>于是，我们可以分出四种广义线性相位系统。</p><ul><li><p>第I类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>偶对称，而且<span class="math inline">\(M\)</span>是偶数。第I类的<span class="math inline">\(\beta=0,\pi\)</span>。所以相频响应是过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=m\pi,m\in \mathbb Z\)</span>偶对称，可用作各种滤波器。</p></li><li><p>第II类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>偶对称，而且<span class="math inline">\(M\)</span>是奇数。第II类的<span class="math inline">\(\beta=0,\pi\)</span>。所以相频响应是过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=2m\pi,m\in \mathbb Z\)</span>偶对称，关于<span class="math inline">\(\omega=(2m+1)\pi,m\in \mathbb Z\)</span>奇对称，幅度函数在<span class="math inline">\(\pi\)</span>时为零，不适合作高通、带阻滤波器。</p></li><li><p>第III类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=-h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>奇对称，而且<span class="math inline">\(M\)</span>是偶数。第III类的<span class="math inline">\(\beta=\pi/2,3\pi/2\)</span>。所以相频响应是不过原点的直线（过<span class="math inline">\((0,\pi/2)\)</span>或<span class="math inline">\((0,3\pi/2)\)</span>），斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=m\pi,m\in \mathbb Z\)</span>奇对称，只适合作带通滤波器。</p></li><li><p>第IV类广义线性相位系统</p><p>该类系统满足<span class="math inline">\(h[M-n]=-h[n]\)</span>，即<span class="math inline">\(h[n]\)</span>关于<span class="math inline">\(M/2\)</span>奇对称，而且<span class="math inline">\(M\)</span>是奇数。第IV类的<span class="math inline">\(\beta=\pi/2,3\pi/2\)</span>。所以相频响应是不过原点的直线，斜率是<span class="math inline">\(-M/2\)</span>，群延时是<span class="math inline">\(M/2\)</span>。</p><p>这类系统的广义幅频响应<span class="math inline">\(A(e^{j\omega})\)</span>关于<span class="math inline">\(\omega=2m\pi,m\in \mathbb Z\)</span>奇对称，关于<span class="math inline">\(\omega=(2m+1)\pi,m\in \mathbb Z\)</span>偶对称，幅度函数在<span class="math inline">\(\pi\)</span>时为零，不适合作低通、带通滤波器。</p></li></ul><p>由于第3、4类广义线性系统的相移特性，可以作希尔伯特变换器使用。</p><p>对于广义线性系统而言，如果<span class="math inline">\(z_0\)</span>是系统的零点，那么<span class="math inline">\(z_0^{-1},z_0^*,(z_0^*)^{-1}\)</span>也是系统的零点。第2、3类的零点一定包含-1，第3、4类的零点一定包含1.</p><h2 id="信号的采样和重建">信号的采样和重建</h2><h3 id="连续信号的理想采样">连续信号的理想采样</h3><p>设原连续信号为<span class="math inline">\(x_c(t)\)</span>，用来采样的理想冲击串为<span class="math inline">\(s(t)\)</span>，采样得的连续采样信号为<span class="math inline">\(x_s(t)\)</span>，采样得的离散时间序列为<span class="math inline">\(x[n]\)</span>。其中采样用的理想冲击串的周期为<span class="math inline">\(T_s\)</span>。</p><h4 id="x_s和x_c的关系"><span class="math inline">\(X_s\)</span>和<span class="math inline">\(X_c\)</span>的关系</h4><p>这一部分是《信号与系统》的内容，这里只简单提一下。</p><p>首先我们知道，冲击串的傅里叶变换还是冲击串，即： <span class="math display">\[S(j\Omega)=\frac{2\pi}{T_s}\sum_{k=-\infty}^{\infty}\delta(\Omega-k\Omega_s)\]</span> 由傅里叶变换的乘积性质，有： <span class="math display">\[X_s(j\Omega)=\frac 1 {T_s}\sum_{k=-\infty}^\infty X_c(j\Omega-jk\Omega_s)\]</span> 即：<span class="math inline">\(x_s(t)\)</span>的频谱<span class="math inline">\(X_s(j\Omega)\)</span>是连续时间信号<span class="math inline">\(x_c(t)\)</span>的频谱<span class="math inline">\(X_c(j\Omega)\)</span>以采样周期<span class="math inline">\(\Omega_s=2\pi/T_s\)</span>的周期延拓，并以<span class="math inline">\(\frac 1{T_s}\)</span>加权的结果。所以，为了不使得频域混叠，需满足<span class="math inline">\(\Omega_s&gt;2\Omega_N\)</span>，其中<span class="math inline">\(\Omega_N\)</span>是原信号所含有的最高频分量的频率。</p><h4 id="xejomega和x_cjomega的关系"><span class="math inline">\(X(e^{j\omega})\)</span>和<span class="math inline">\(X_c(j\Omega)\)</span>的关系</h4><p>有： <span class="math display">\[X_s(j\Omega)=\sum_{n=-\infty}^{\infty}x[n]e^{-j\Omega nT_s}\]</span> 令<span class="math inline">\(\omega=\Omega T_s\)</span>，有： <span class="math display">\[X_s\left(j\frac{\omega}{T_s}\right)=\sum_{n=-\infty}^\infty x[n]e^{-j\omega n}\]</span></p><p>可以发现：使用<span class="math inline">\(1/T_s\)</span>对<span class="math inline">\(X_c(j\Omega)\)</span>加权且频率按<span class="math inline">\(\Omega=\omega/T_s\)</span>尺度变换，得到函数<span class="math inline">\(X_c(j\omega/T_s)/T_s\)</span>，将其以<span class="math inline">\(2\pi\)</span>为周期进行延拓，得离散序列<span class="math inline">\(x[n]\)</span>频谱<span class="math inline">\(X(e^{j\omega})\)</span>.</p><h3 id="连续信号的理想重建">连续信号的理想重建</h3><p>重建系统的示意图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301039578.png" alt="连续信号重建系统" /><figcaption aria-hidden="true">连续信号重建系统</figcaption></figure><p>先把离散时间信号序列<span class="math inline">\(y[n]\)</span>转化为连续时间信号<span class="math inline">\(y_s(t)\)</span>，然后让<span class="math inline">\(y_s(t)\)</span>经过截止频率为<span class="math inline">\(\pi/T_s\)</span>，幅度<span class="math inline">\(T_s\)</span>的低通滤波器，得到重建信号<span class="math inline">\(y_r(t)\)</span>。</p><p>即： <span class="math display">\[H_r(j\Omega)=\begin{cases}T_s, &amp;|\Omega|&lt;\frac{\Omega_s}{2}\\0 , &amp;\text{others}\end{cases}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211301112181.png" alt="重建过程" /><figcaption aria-hidden="true">重建过程</figcaption></figure><h3 id="余弦信号的采样">余弦信号的采样</h3><p>这一段没有什么新东西，主要内容是以对余弦信号采样举例来让人直观感受“频域混叠”的存在，尤其是在采样频率<span class="math inline">\(\Omega_s=2\Omega_0\)</span>时，可能会出现各种情况：当<span class="math inline">\(\varphi=0\)</span>时，才能恢复原信号；当其它情况时，都不能恢复原信号，极端时刻，甚至采样值全部为0，不包含任何信息。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:3" class="footnote-text"><span>也就是说最小相位系统的意思就是零极点都在单位圆内。 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变泛函·实变函数之章</title>
    <link href="/2022/12/04/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD/"/>
    <url>/2022/12/04/%E5%AE%9E%E5%8F%98%E6%B3%9B%E5%87%BD/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>实变函数和泛函分析是一门广度极强的学科，融合了分析、代数、抽代、拓扑等数学各个方面的知识。在学习时要能建立起各个概念之间的联系。</p><span id="more"></span><h2 id="点集">点集</h2><h3 id="rn中的线性运算内积和范数"><span class="math inline">\(R^n\)</span>中的线性运算、内积和范数</h3><h4 id="n维欧氏空间rn"><span class="math inline">\(n\)</span>维欧氏空间<span class="math inline">\(R^n\)</span></h4><p><span class="math inline">\(R^n\)</span>指的是<span class="math inline">\(n\)</span>维向量组成的集合： <span class="math display">\[R^n=\{(x_1,x_2,\cdots,x_n):x_i\in R,i=1,2,\cdots n\}\]</span> 在这个集合上定义加法和数乘： <span class="math display">\[\begin{aligned}&amp;\forall x,y\in R^n,\lambda\in R\\&amp;x+y=(x_1+y_1,x_2+y_2,\cdots,x_n+y_n)\\&amp;\lambda x=(\lambda x_1,\lambda x_2,\cdots,\lambda x_n)\end{aligned}\]</span> 其满足所谓的“线性运算八条性质”：对任意的<span class="math inline">\(x,y\in R^n;\lambda,\mu\in R\)</span></p><ol type="1"><li><span class="math inline">\(x+y=y+x\)</span></li><li><span class="math inline">\(x+y+z=(x+y)+z=x+(y+z)\)</span></li><li><span class="math inline">\(x+0=x\)</span>;</li><li><span class="math inline">\(x+(-x)=0\)</span></li><li><span class="math inline">\(1x=x\)</span></li><li><span class="math inline">\(\lambda(x+y)=\lambda x+\lambda y\)</span></li><li><span class="math inline">\((\lambda+\mu) x=\lambda x+\mu x\)</span></li><li><span class="math inline">\((\lambda \mu) x=\lambda(\mu x)\)</span></li></ol><p>对于<span class="math inline">\(\forall x,y\in R^n\)</span>，定义<strong>内积</strong>： <span class="math display">\[(x,y)=\sum_{i=1}^n x_iy_i\]</span> 内积满足以下三条性质：对于任意的<span class="math inline">\(x,y,z\in R^n\)</span>，任意的<span class="math inline">\(\lambda,\mu\in R\)</span>，有：</p><ol type="1"><li>正定性：<span class="math inline">\((x,x)\geq 0\)</span></li><li>对称性：<span class="math inline">\((x,y)=(y,x)\)</span></li><li>对第一变元的线性：<ol type="1"><li><span class="math inline">\((x+y,z)=(x,z)+(y,z)\)</span></li><li><span class="math inline">\((\lambda x,y)=\lambda(x,y)\)</span></li></ol></li></ol><p>定义了内积的<span class="math inline">\(n\)</span>维向量空间被称为“<strong>内积空间</strong>”，也叫“<strong>欧几里得空间</strong>”.</p><p>对于一般的内积空间<span class="math inline">\(X\)</span>，总成立柯西-施瓦茨不等式： <span class="math display">\[|(x,y)|\leq ||x||\cdot||y||\]</span> 其中<span class="math inline">\(||x||=\sqrt{(x,x)}\)</span>，称之为向量的<strong>范数</strong>。范数满足以下三条性质：</p><ol type="1"><li>正定性：<span class="math inline">\(||x||\geq 0\)</span>，取到<span class="math inline">\(0\)</span>当且仅当<span class="math inline">\(x=0\)</span></li><li>齐次性：<span class="math inline">\(||\lambda x||=|\lambda|\cdot ||x||\)</span></li><li>三角不等式：<span class="math inline">\(||x+y||\leq||x||+||y||\)</span></li></ol><p>其实，只要<span class="math inline">\(f(x)\)</span>满足以上三个条件，那么它就可以被称作范数，范数不只有上面所提到的那一种定义。</p><p>对三角不等式的证明可以先对式子两边取平方，再运用柯西-施瓦茨不等式。</p><p>如果<span class="math inline">\(x,y\in R^n\)</span>且<span class="math inline">\(x,y\neq 0\)</span> ,则存在实数<span class="math inline">\(\theta\in[0,\pi]\)</span>，满足： <span class="math display">\[\cos \theta=\frac{(x,y)}{||x||\cdot ||y||}\]</span> 这个实数称为两个向量之间的<strong>夹角</strong>。</p><p>最后，我们定义<strong>两点间的距离</strong>：<span class="math inline">\(d(x,y)=||x-y||\)</span>。距离的本质是范数，满足范数的性质。</p><h4 id="rn中点列的极限"><span class="math inline">\(R^n\)</span>中点列的极限</h4><p>设<span class="math inline">\(\{x_k\}\)</span>是<span class="math inline">\(R^n\)</span>中的点列，如果<span class="math inline">\(\forall \epsilon&gt;0,\exists N,\forall k&gt;N,||x_k-a||&lt;\epsilon\)</span>，称<span class="math inline">\(\{x_k\}\)</span>收敛于<span class="math inline">\(a\)</span>，记作： <span class="math display">\[\lim_{n\to \infty}x_k=a\]</span> 点列的极限满足以下四条性质：</p><ol type="1"><li>点列的极限如果存在，那么唯一</li><li>收敛点列必定有界</li><li><span class="math inline">\(\lim_{k\to \infty}(x_k+y_k)=a+b\)</span></li><li><span class="math inline">\(\forall \lambda \in R,\lim_{k\to \infty} (\lambda x_k)=\lambda a\)</span></li></ol><p>点列收敛等价于点列的每个分量都收敛（即按分量收敛）。</p><h3 id="rn中点集的基本概念和性质"><span class="math inline">\(R^n\)</span>中点集的基本概念和性质</h3><p><span class="math inline">\(a\in R^n,r&gt;0\)</span>，则称集合<span class="math inline">\(\{x\in R^n:||x-a||&lt;r\}\)</span>称为以<span class="math inline">\(a\)</span>为心，<span class="math inline">\(r\)</span>为半径的“<strong>开球</strong>”或者“<strong>球形邻域</strong>”，记作<span class="math inline">\(B_r(a)\)</span>.</p><p>令<span class="math inline">\(\bar B_r(a)=\{x\in R^n:||x-a||\leq r\}\)</span>，称作“<strong>闭球</strong>”</p><p>令<span class="math inline">\(B_r^o(a)=\{x\in R^n:0&lt;||x-a||&lt;r\}\)</span>，称作“<strong>去心开球</strong>”</p><p>若<span class="math inline">\(E\subset R^n,\exists r&gt;0,s.t. E\subset B_r(0)\)</span>，称<span class="math inline">\(E\)</span>是<strong>有界</strong>的。否则，称<span class="math inline">\(E\)</span>是<strong>无界</strong>的。</p><h4 id="点">点</h4><p>如果<span class="math inline">\(a\in E,\exists r&gt;0,s.t. B_r(a)\subset E\)</span>，则<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>内点</strong>，如果<span class="math inline">\(a\)</span>是<span class="math inline">\(E^c\)</span>(<span class="math inline">\(E\)</span>的补集)的内点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>外点</strong>。如果<span class="math inline">\(a\)</span>对<span class="math inline">\(E\)</span>来说既不是内点，也不是外点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>边界点</strong>。</p><p>换句话说：以<span class="math inline">\(a\)</span>为心的任意邻域内都存在属于<span class="math inline">\(E\)</span>的点，同时也存在不属于<span class="math inline">\(E\)</span>的点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的边界点。</p><p>如果以<span class="math inline">\(a\)</span>为心的任意球形邻域中都含有<span class="math inline">\(E\)</span>的无限多个点，那么<span class="math inline">\(a\)</span>叫做<span class="math inline">\(E\)</span>的<strong>聚点</strong>，也叫<strong>极限点</strong>。聚点的定义可以简化，也就是说，只要以<span class="math inline">\(a\)</span>为心的任意球形邻域中都含有<span class="math inline">\(E\)</span>中不同于<span class="math inline">\(a\)</span>的一个点，那么<span class="math inline">\(a\)</span>就是<span class="math inline">\(E\)</span>的聚点。很显然，这两种说法实际上是等价的。还有一种等价的说法：从<span class="math inline">\(E\)</span>中选出互不相同的点组成点列<span class="math inline">\(\{x_k\}\)</span>，如果<span class="math inline">\(\lim_{k\to \infty}x_k=a\)</span>，那么<span class="math inline">\(a\)</span>是<span class="math inline">\(E\)</span>的聚点。<span class="math inline">\(E\)</span>中不是聚点的点叫做<strong>孤立点</strong>。</p><p>关于各种点之间的关系，有如下的结论：</p><ol type="1"><li>内点一定是聚点，外点一定不是聚点</li><li>聚点可以是内点，也可以是边界点，但不可能是外点</li><li>孤立点一定是边界点</li><li>边界点是聚点或孤立点</li><li>如果一个点既不是聚点，也不是边界点，那么一定是外点</li><li>内点必属于集合，外点必不属于集合，边界点不一定属于集合</li></ol><p>我们会发现：聚点不一定在集合内，例子很简单：对于<span class="math inline">\(R^1,E=Q,e=\lim_{k\to \infty}(1+1/n)^n,e\notin E\)</span></p><p>设<span class="math inline">\(A\subset R^n,\forall x\in R^n,\exist r,s.t. \exist a\in A,a\in B_r(x)\)</span>，那么称<span class="math inline">\(A\)</span>在<span class="math inline">\(R^n\)</span>中<strong>稠密</strong>。稠密等价于以下两个结论：</p><ol type="1"><li>对<span class="math inline">\(\forall x\in R^n\)</span>，总存在<span class="math inline">\(A\)</span>中的点列收敛于<span class="math inline">\(x\)</span>。</li><li><span class="math inline">\(R^n\)</span>中的点要么是<span class="math inline">\(A\)</span>中的点，要么是<span class="math inline">\(A\)</span>的聚点。</li></ol><h4 id="开集">开集</h4><p>点集<span class="math inline">\(E\)</span>的全体内点的集合叫做<span class="math inline">\(E\)</span> 的内部，记作<span class="math inline">\(E^o\)</span>。如果<span class="math inline">\(E=E^o\)</span>，那么称<span class="math inline">\(E\)</span>为<strong>开集</strong>。</p><p>几个经典的开集：空集、<span class="math inline">\(R^n\)</span>、数轴上的开区间、<span class="math inline">\(\{(x,y)|y&gt;0\}\)</span>、开球</p><p>任意多个开集的并还是开集，有限个开集的交还是开集</p><h4 id="闭集">闭集</h4><p>如果<span class="math inline">\(E\subset R^n\)</span>是开集，那么<span class="math inline">\(E^c\)</span>叫做<strong>闭集</strong>。</p><p>几个经典的闭集：数轴上的闭区间、<span class="math inline">\(R^2\)</span>的横轴和下半平面、有限个点的集合、开球的补</p><p>集合可以既不是开集也不是闭集。</p><p>任意个闭集的交还是闭集，有限个闭集的并还是闭集。</p><p>点集<span class="math inline">\(E\subset R^n\)</span>的全体聚点的集合叫做<span class="math inline">\(E\)</span>的<strong>导集</strong>，记作<span class="math inline">\(E&#39;\)</span>。如果<span class="math inline">\(\bar E=E\cup E&#39;\)</span>，那么<span class="math inline">\(\bar E\)</span>叫做<span class="math inline">\(E\)</span>的<strong>闭包</strong>。</p><p>如果<span class="math inline">\(E\)</span>是闭集，那么它的闭包是它自己。</p><p>内部是含于一个集合的最大开集，闭包是包含一个集合的最小闭集。</p><h3 id="rn中的基本定理"><span class="math inline">\(R^n\)</span>中的基本定理</h3><p>我们在学实数的时候经常提“六大定理”，即：</p><ol type="1"><li>确界存在定理</li><li>单调数列收敛定理</li><li>有界数列必有收敛子列</li><li>柯西收敛准则</li><li>闭区间套定理</li><li>有限覆盖定理</li></ol><p>在<span class="math inline">\(R^n\)</span>中，前两个定理不再成立，后面的继续成立。</p><ul><li><p><span class="math inline">\(R^n\)</span>中的有界点列必有收敛子列，也就是：任何无穷点集都含有聚点</p></li><li><p>如果<span class="math inline">\(\{x_k\}\)</span>是<span class="math inline">\(R^n\)</span>中的点列，如果<span class="math inline">\(\forall \varepsilon&gt;0,\exists N=N(\varepsilon)&gt;0,s.t. \forall k,l&gt;N,||x_k-x_l||&lt;\varepsilon\)</span>，称<span class="math inline">\(\{x_k\}\)</span>是基本列。“是基本列”和“收敛”等价。</p></li><li><p>设<span class="math inline">\(\{E_k\}\)</span>是一个闭集列，都不是空集，而且：</p><ul><li>后一项是前一项的子列</li><li><span class="math inline">\(\lim _{k\to \infty} diam(E_k)=0\)</span></li></ul><p>那么存在唯一的<span class="math inline">\(\xi \in \bigcap_{k=1}^{\infty} E_k\)</span>，其中<span class="math inline">\(diam(A)=\sup_{\forall x,y\in A}||x-y||\)</span>。</p></li><li><p>设<span class="math inline">\(E\in R^n,\{G_\alpha\}_{\alpha \in \Gamma}\)</span>是<span class="math inline">\(R^n\)</span>中的一个开集族，如果<span class="math inline">\(E\subset \bigcup G_\alpha\)</span>，称<span class="math inline">\(\{G\}\)</span>是<span class="math inline">\(E\)</span>的一个开覆盖。<span class="math inline">\(R^n\)</span>中的有界闭集的任意一个开覆盖都有有限子覆盖</p></li></ul><h3 id="距离">距离</h3><p>点<span class="math inline">\(x\)</span>和集合<span class="math inline">\(B\)</span>的距离为： <span class="math display">\[d(x,B)=\inf\{d(x,y):y\in B\}\]</span> 意思就是点到集合中每个点的距离的下确界</p><p>两个集合之间的距离为： <span class="math display">\[d(A,B)=\inf\{d(x,y):x\in A,y\in B\}\]</span> 意思就是从集合里面任选两个点，它们之间的距离的下确界</p><p>有以下结论：</p><ol type="1"><li>如果A是非空闭集，则<span class="math inline">\(\exists y\in A,s.t.d(x,y)=d(x,A)\)</span></li><li>如果AB是非空闭集，则<span class="math inline">\(\exists x\in A,y\in B,s.t. d(x,y)=d(A,B)\)</span></li><li><span class="math inline">\(F_1,F_2\)</span>是不相交的非空闭集，则存在<span class="math inline">\(R^n\)</span>上的连续函数，使得<ol type="1"><li><span class="math inline">\(0\leq f(x)\leq 1\)</span></li><li><span class="math inline">\(f(x)=0,x\in F_1\)</span>；<span class="math inline">\(f(x)=1,x\in F_2\)</span></li></ol></li></ol><h3 id="康托尔cantor三分集">康托尔（Cantor）三分集</h3><p>把<span class="math inline">\([0,1]\)</span>三等分，去掉中间的一部分，再把左右两个剩下的三等分，再各自去掉中间的一部分，重复无限次，剩下来的集合就是Cantor三分集（P）。</p><p>它：</p><ol type="1"><li>是闭集，完备集</li><li>没有内点</li><li>是疏朗集，即<span class="math inline">\(\bar P\)</span>(闭包)没有内点</li><li>基数是连续势</li><li>测度为零，外测度也为零</li></ol><p>康托尔函数<span class="math inline">\(\theta(x)\)</span>：把在构造康托尔集的过程中第<span class="math inline">\(n\)</span>次去掉的<span class="math inline">\(2^{n-1}\)</span>个开区间上依次取值为 <span class="math display">\[\frac {1}{2^n},\frac{3}{2^n},\cdots,\frac{2^n-1}{2^n}\]</span> 规定<span class="math inline">\(\theta(0)=0,\theta(1)=1\)</span></p><p>康托尔函数是<span class="math inline">\([0,1]\)</span>上的单调不减连续函数。</p><h2 id="测度论">测度论</h2><p>测度是“长度”、“面积”概念的扩展。</p><p>集合的测度<span class="math inline">\(m:E\to[0,+\infty]\)</span>应当满足：</p><ol type="1"><li><p>非负性</p></li><li><p>正则性：若<span class="math inline">\(I=(a,b)\)</span>，则<span class="math inline">\(m(I)=b-a\)</span></p></li><li><p>可数可加性：如果集合<span class="math inline">\(E_1,E_2\cdots\)</span>都有测度且两两不交，那么： <span class="math display">\[m\left(\bigcup_{k=1}^\infty E_k \right)=\sum_{k=1}^\infty m(E_k)\]</span></p></li></ol><p>这里主要讨论勒贝格测度。在定义测度时，先定义勒贝格外测度，然后在其基础上诱导出一个可测集合类，在其上的外测度就是一种期望的测度。</p><h3 id="外测度">外测度</h3><p>对于<span class="math inline">\(R^n\)</span>的子集<span class="math inline">\(E\)</span>，定义非负广义函数： <span class="math display">\[m^*(E)=\inf \left\{  \sum_{k=1}^\infty |I_k|:I_1,I_2\cdots\text{是开矩体,且}E\subset \bigcup_{k=1}^\infty I_k\right\}\]</span> 开矩体是<span class="math inline">\(n\)</span>个开区间的直积，其体积为每个开区间的长度之积。</p><p>外测度有以下性质：</p><ol type="1"><li><p>非负性</p></li><li><p>单调性：如果<span class="math inline">\(E_1\subset E_2\)</span>，则<span class="math inline">\(m^*(E_1)\leq m^*(E_2)\)</span></p></li><li><p>次可数可加性：如果集合<span class="math inline">\(E_1,E_2\cdots\)</span>都有测度且两两不交，那么： <span class="math display">\[m^*\left(\bigcup_{k=1}^\infty E_k \right)\leq \sum_{k=1}^\infty m^*(E_k)\]</span></p></li><li><p>平移不变性： <span class="math display">\[m^*(E+\{a\})=m^*(E)\]</span> 其中<span class="math inline">\(E+\{a\}=\{x+a,x\in E\}\)</span></p></li></ol><h3 id="可测集">可测集</h3><p>定义，如果<span class="math inline">\(E,T\in R^n\)</span>： <span class="math display">\[m^*(T)=m^*(T\cap E)+m^*(T\cap E^c)\]</span> 则称<span class="math inline">\(E\)</span>是勒贝格<strong>可测集</strong>，简称为可测集。此时<span class="math inline">\(m^*(E)\)</span>称为<span class="math inline">\(E\)</span>的测度，记作<span class="math inline">\(m(E)\)</span>。这个等式叫做卡特西奥多里条件。</p><p>这个条件可以等价于： <span class="math display">\[m^*(T)\geq m^*(T\cap E)+m^*(T\cap E^c)\]</span> 设<span class="math inline">\(R^n\)</span>上的可测集所构成的集族称为M，则：</p><ol type="1"><li>空集属于M</li><li>如果<span class="math inline">\(E\)</span>可测，那么<span class="math inline">\(E^c\)</span>可测</li><li>如果<span class="math inline">\(E_1,E_2\in M\)</span>，则它们的并、交、差都是可测</li><li>可测集的有限并也可测，而且满足可列可加</li></ol><p>区间可测，凡是开集或闭集都可测，外测度为零的集合可测且测度为零</p><p>零测集的子集、至多可数个零测集的并也是零测集。</p><h3 id="不可测集">不可测集</h3><p>存在不可测集。</p><h2 id="可测函数">可测函数</h2><h3 id="可测函数的定义和性质">可测函数的定义和性质</h3><p>设<span class="math inline">\(f(x)\)</span>是定义在可测集<span class="math inline">\(E\subset R^n\)</span>上的广义实值函数，若<span class="math inline">\(\forall a\in R\)</span>，<span class="math inline">\(E(f&gt;a)\)</span>（即<span class="math inline">\(\{x\in E:f(x)&gt;a\}\)</span>）都是可测集，则称<span class="math inline">\(f(x)\)</span>为<strong>可测函数</strong>。</p><p>以下条件相互等价：</p><ul><li><span class="math inline">\(f(x)\)</span>是可测函数，即<span class="math inline">\(\forall a\in R,E(f&gt; a)\)</span>可测</li><li><span class="math inline">\(\forall a\in R,E(f\geq a)\)</span>可测</li><li><span class="math inline">\(\forall a\in R,E(f&lt; a)\)</span>可测</li><li><span class="math inline">\(\forall a\in R,E(f\leq a)\)</span>可测</li></ul><p>如果<span class="math inline">\(f(x)\)</span>在可测集<span class="math inline">\(E\)</span>上是可测函数，那么在<span class="math inline">\(E\)</span>的每个可测子集上也是可测函数。</p><p>如果<span class="math inline">\(E=\bigcup_{k=1}^\infty E_k\)</span>，其中每一个<span class="math inline">\(E_k\)</span>都是可测集而且<span class="math inline">\(f(x)\)</span>在其上可测，那么<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上可测。</p><p>可测函数类关于确界、上下极限封闭。即：如果<span class="math inline">\(\{f_k\}\)</span>都是可测集<span class="math inline">\(E\)</span>上的函数，那么<span class="math inline">\(\sup_k f_k(x),\inf_k f_k(x),\overline{\lim}_{k\to \infty}f_k(x),\underline{\lim}_{k\to \infty}f_k(x)\)</span>都可测。</p><p>可测函数类关于加、减、乘、除、数乘、绝对值封闭。</p><p>如果<span class="math inline">\(P(x)\)</span>是一个和集合<span class="math inline">\(E\)</span>中元素<span class="math inline">\(x\)</span>有关的命题，如果存在一个<span class="math inline">\(E\)</span>的零测子集<span class="math inline">\(M\)</span>，使得<span class="math inline">\(P(x)\)</span>在<span class="math inline">\(E/M\)</span>上恒成立，称<span class="math inline">\(P(x)\)</span>在<span class="math inline">\(E\)</span>上<strong>几乎处处成立</strong>，记作<span class="math inline">\(a.e.\)</span></p><p>如果<span class="math inline">\(f(x),g(x)\)</span>都是<span class="math inline">\(E\)</span>上的广义实值函数，且<span class="math inline">\(f(x)=g(x)\ a.e. x\in E\)</span>，那么<span class="math inline">\(f(x)\)</span>可测是<span class="math inline">\(g(x)\)</span>可测的充要条件。</p><p>下面定义三种函数：</p><ol type="1"><li><p>设<span class="math inline">\(X=R\)</span>的一个子集<span class="math inline">\(E\)</span>，称： <span class="math display">\[\chi_E(x)=\begin{cases}1 &amp; x\in E\\0 &amp; x\in E^c\end{cases}\]</span> 为<span class="math inline">\(E\)</span>上的<strong>特征函数</strong>。如果<span class="math inline">\(E\)</span>可测，那么它的特征函数可测。</p></li><li><p>如果<span class="math inline">\(f(x)\)</span>的定义域<span class="math inline">\(E\)</span>可以分为有限个不相交的集合<span class="math inline">\(E_k\)</span>，且<span class="math inline">\(f(x)\)</span>在每个<span class="math inline">\(E_k\)</span>上取常值<span class="math inline">\(c_k\)</span>，那么称<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的<strong>简单函数</strong>。（简单理解：取有限个实数）</p></li><li><p>如果在简单函数的定义的基础上，每个<span class="math inline">\(E_k\)</span>都是矩体，称<span class="math inline">\(f(x)\)</span>为<strong>阶梯函数</strong>。</p></li></ol><h3 id="可测函数和简单函数的关系简单函数逼近定理">可测函数和简单函数的关系(简单函数逼近定理)</h3><p>如果<span class="math inline">\(f(x)\)</span>是可测集<span class="math inline">\(E\subset R\)</span>上的非负可测函数，当且仅当存在非负可测渐升简单函数列<span class="math inline">\(\{\phi_k(x)\}\)</span>，使得： <span class="math display">\[\lim_{k\to \infty}\phi_k(x)=f(x)\]</span> 如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上有界，那么上述收敛是一致的。</p><blockquote><p>事实上，作简单函数列<span class="math inline">\(\phi_k(x)\)</span>，使得： <span class="math display">\[\phi_k(x)=k\chi_{F_k}(x)+\sum_{i=1}^{k2^k}\frac{i-1}{2^k}\chi_{E_{ki}}(x)\]</span> 其中 <span class="math display">\[E_{ki}=E\left(\frac{i-1}{2^k}\leq f&lt;\frac i{2^k}\right),F_k=E(f\geq k)\]</span> 即满足上述定理的要求。</p></blockquote><p>如果<span class="math inline">\(f(x)\)</span>是可测集<span class="math inline">\(E\)</span>上的可测函数，当且仅当存在可测的简单函数列<span class="math inline">\(\{f_k(x)\}\)</span>，满足：</p><ol type="1"><li><span class="math inline">\(|f_k(x)|\leq|f(x)|\)</span></li><li><span class="math inline">\(\lim_{k\to \infty}f_k(x)=f(x)\)</span></li></ol><p>如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上有界，那么上述收敛是一致的。</p><blockquote><p>在证明时，可以把<span class="math inline">\(f(x)\)</span>分解成正负部之差，利用前面关于非负函数的定理，令 <span class="math display">\[f_k(x)=\phi^+_k(x)-\phi^-_k(x)\]</span></p></blockquote><h3 id="可测函数的收敛">可测函数的收敛</h3><p>设<span class="math inline">\(f(x),f_k(x)\)</span>都是定义在<span class="math inline">\(E\)</span>上的可测函数，有：</p><ol type="1"><li><p>处处收敛：<span class="math inline">\(\forall \epsilon&gt;0,\forall x\in E,\exists K=K(x,\epsilon)\)</span>当<span class="math inline">\(k&gt;K\)</span>时，有：<span class="math inline">\(|f_k(x)-f(x)|&lt;\epsilon\)</span>，记作 <span class="math display">\[\lim_{k\to \infty}f_k(x)=f(x)\]</span></p></li><li><p>几乎处处收敛：存在一个零测集，使得<span class="math inline">\(f_k(x)\)</span>在<span class="math inline">\(E\)</span>中除了这个零测集以外的点上收敛于<span class="math inline">\(f(x)\)</span></p></li><li><p>一致收敛：<span class="math inline">\(\forall \epsilon&gt;0,\forall x\in E,\exists K=K(\epsilon)\)</span>当<span class="math inline">\(k&gt;K\)</span>时，有：<span class="math inline">\(|f_k(x)-f(x)|&lt;\epsilon\)</span>。一致收敛等价于： <span class="math display">\[\lim_{k\to \infty}\sup_{x\in E}|f_k(x)-f(x)|=0\]</span></p></li></ol><p>有Egoroff（叶洛果夫）定理：设<span class="math inline">\(m(E)&lt; \infty\)</span>，如果<span class="math inline">\(\{f_k\}\)</span>在<span class="math inline">\(E\)</span>上几乎处处收敛，那么对于任意的<span class="math inline">\(\delta &gt; 0\)</span>，有<span class="math inline">\(E\)</span>的可测子集<span class="math inline">\(E_\delta,m(E_\delta)&lt;\delta\)</span>，使得<span class="math inline">\(\{f_k\}\)</span>在<span class="math inline">\(E/E_\delta\)</span>上一致收敛。也就是说，几乎处处收敛的函数列是“近一致收敛”的。</p><blockquote><p>例如，对于函数列<span class="math inline">\(\{f_k=x^k\}\)</span>，<span class="math inline">\(E=[0,1]\)</span>，其处处收敛于 <span class="math display">\[f(x)=\begin{cases}0,&amp;x\in[0,1)\\1,&amp;x=1\end{cases}\]</span> 因 <span class="math display">\[\beta_k=\sup_{x\in E}|f_k-f|=1\]</span> 不趋向于<span class="math inline">\(0\)</span>，所以它不是一致收敛的。然而只要去掉任意小的区域，把<span class="math inline">\(E\)</span>变成<span class="math inline">\([0,1-\delta]\)</span>，那么就一致收敛了。</p></blockquote><p>其实还有比几乎处处收敛更弱的收敛，叫做<strong>依测度收敛</strong>。如果<span class="math inline">\(\{f_k\},f\)</span>是可测集<span class="math inline">\(E\)</span>上的几乎处处有限的函数，如果对任意<span class="math inline">\(\varepsilon&gt;0\)</span>，有： <span class="math display">\[\lim _{k \rightarrow \infty} m\left(\left\{x \in E:\left|f_k(x)-f(x)\right|&gt;\varepsilon\right\}\right)=0\]</span> 即：<span class="math inline">\(f_k\)</span>与<span class="math inline">\(f\)</span>的差值比<span class="math inline">\(\varepsilon\)</span>大的集合的测度趋向于0，那么说<span class="math inline">\(\{f_k\}\)</span>依测度收敛于<span class="math inline">\(f\)</span>。</p><p>几乎处处收敛比依测度收敛更强，是因为<strong>几乎处处有限可以推出依测度收敛，反之不然</strong>。</p><p>如果函数列依测度收敛，那么存在函数列的子列<span class="math inline">\(\{f_{k_i}\}\)</span>几乎处处收敛，这叫做<strong>Riesz定理</strong>。</p><p>如果<span class="math inline">\(f\)</span>是可测集<span class="math inline">\(E\)</span>上的几乎处处有限的函数，<span class="math inline">\(\forall \delta&gt;0,\exists F,m(E/F)&lt;\delta\)</span>，使得<span class="math inline">\(f(x)\)</span>在闭集<span class="math inline">\(F\)</span>上连续，这叫做<strong>鲁津定理</strong>。</p><p>有关可测函数的常见结论和各种收敛的关系总结如下：</p><ul><li>可测函数与零测集无关.</li><li>可测函数是简单函数列处处收敛的极限.(当可测函数有界时, 可做到一致收敛)</li><li>可测函数关于一些运算的封闭性.</li><li>可测集 <span class="math inline">\(E\)</span> 上的连续函数是可测的.</li><li>可测集 <span class="math inline">\(E\)</span> 上的简单函数是可测的.</li><li><span class="math inline">\(R\)</span> 中可测集 <span class="math inline">\(E\)</span> 上的单调函数是可测的.</li></ul><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212121534719.png" alt="各种收敛" /><figcaption aria-hidden="true">各种收敛</figcaption></figure><h2 id="勒贝格积分">勒贝格积分</h2><p>首先我们从简单函数出发：假设<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(E\subset R\)</span>上的非负简单函数，在<span class="math inline">\(E_i\)</span>上取值<span class="math inline">\(c_i\)</span>，且<span class="math inline">\(E=\bigcup E_i,E_i\cap E_j=\emptyset\)</span>。也就是说： <span class="math display">\[\varphi(x)=\sum_{i=1}^p c_i\chi_{E_i}(x)\]</span> 那么定义<span class="math inline">\(\varphi(x)\)</span>在<span class="math inline">\(E\)</span>上的勒贝格积分（下简称为L积分）为： <span class="math display">\[\int _E\varphi(x)dx=\sum_{i=1}^p c_im(E_i)\]</span> 根据简单函数逼近定理，我们可以把这个定义扩展到非负可测函数上：如果<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的非负可测函数，那么定义<span class="math inline">\(f(x)\)</span>的L积分： <span class="math display">\[\int_E f(x)dx=\sup_{\varphi(x)\leq f(x),x\in E}\left\{ \int_E \varphi(x)dx\right\}\]</span> 其中<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(E\)</span>上的非负可测简单函数。如果有： <span class="math display">\[\int_E f(x)dx&lt;\infty\]</span> 就称<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上可积的。</p><p>进一步，因为每个可测函数都可以分解成两个非负可测函数的差（即正部和负部），有： <span class="math display">\[f(x)=f^+(x)-f^-(x)\]</span> 定义可测函数上的L积分： <span class="math display">\[\int _Ef(x)dx=\int_Ef^+(x)dx-\int_E f^-(x)dx\]</span></p><h3 id="l积分的性质">L积分的性质</h3><h4 id="l积分的条件">L积分的条件</h4><p>以下，记<span class="math inline">\(L(E)\)</span>为在<span class="math inline">\(E\)</span>上L可积的函数构成的集合。</p><ol type="1"><li>【必要条件】：<span class="math inline">\(f(x)\in L(E)\to f(x)\)</span>在<span class="math inline">\(E\)</span>上几乎处处有界</li><li>【充分条件】：<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的有界可测函数，<span class="math inline">\(m(E)&lt;+\infty\)</span>，则<span class="math inline">\(f(x)\in L(E)\)</span></li><li>【充分条件】：<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\)</span>上的可测函数，<span class="math inline">\(g(x)\in L(E),|f(x)|&lt;g(x)\)</span>，则<span class="math inline">\(f(x)\in L(E)\)</span></li></ol><h4 id="l积分的基本性质">L积分的基本性质</h4><ol type="1"><li><p>线性，保序性</p><p>略，和黎曼积分（以下简称R积分）相同</p></li><li><p>有限可加性</p><p>如果<span class="math inline">\(f(x)\in L(E)\)</span>，那么<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>的子集上也L可积。</p><p>如果<span class="math inline">\(E=A\cup B,A\cap B=\emptyset,AB\)</span>可测，那么 <span class="math display">\[ \int_E f(x)dx=\int_Af(x)dx+\int_Bf(x)dx \]</span></p></li><li><p>集合意义</p><p>如果<span class="math inline">\(f(x)\)</span>是<span class="math inline">\(E\subset R^n\)</span>上的非负实值函数，称： <span class="math display">\[ \underline{G}(f)=\underline{G}_E(f)=\left\{(x, y) \in R^{n+1}: x \in E, 0 \leq y \leq f(x)\right\} \]</span> 为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上的下方图形，如果<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(E\)</span>上可测，那么他的下方图形在<span class="math inline">\(R^{n+1}\)</span>上也可测，有： <span class="math display">\[ m(\underline{G}(f))=\int_E f(x) d x \]</span> 如果<span class="math inline">\(E\)</span>可测，则<span class="math inline">\(G(f)\)</span>在<span class="math inline">\(R^{n+1}\)</span>上可测，<span class="math inline">\(f(x)\)</span>也 可测，且也有上面的结论</p></li></ol><h4 id="l积分的特殊性质">L积分的特殊性质</h4><ol type="1"><li><p>零测集上任何函数L积分为零，更进一步，如果两个函数只在一个零测集上有区别，那么这两个函数的L积分相等</p></li><li><p>函数<span class="math inline">\(f(x)\)</span>L可积和其绝对值<span class="math inline">\(|f(x)|\)</span>L可积等价，且积分的绝对值不大于绝对值的积分</p></li><li><p>绝对连续性：如果<span class="math inline">\(f(x)\in L(E)\)</span>，则<span class="math inline">\(\forall \varepsilon &gt;0,\exists \delta&gt;0,s.t. \forall e\in E,m(e)&lt;\delta\)</span>，有： <span class="math display">\[\left|\int_e f(x) \mathrm{d} x\right| \leq \int_e|f(x)| \mathrm{d} x&lt;\varepsilon\]</span></p></li><li><p>如果一个函数R可积，那么它L可积，且两个积分的值相等。</p><p>这说明，R积分的有关问题，可以转换为L积分，再利用马上就要说明的L积分的优良性质完成 。</p></li></ol><h4 id="l积分的优良性质">L积分的优良性质</h4><p>【勒贝格收敛控制定理】如果<span class="math inline">\(\{f_k(x)\}\)</span>是<span class="math inline">\(E\in R^n\)</span>上的可测函数列，且：</p><ol type="1"><li><span class="math inline">\(\lim _{k\to \infty}f_k(x)=f(x)\)</span></li><li><span class="math inline">\(\exists F(x)\in L(E),\forall k,|f_k(x)|\leq F(x)\ a.e.x\in E\)</span></li></ol><p>那么，<span class="math inline">\(f_k(x),f(x)\in L(E)\)</span>，且积分和极限可以交换次序，有： <span class="math display">\[\lim _{k \rightarrow \infty} \int_E f_k(x) \mathrm{d} x=\int_E f(x) \mathrm{d} x=\int_E \lim _{k \rightarrow \infty} f_k(x) \mathrm{d} x .\]</span></p><blockquote><p>相比之下，黎曼积分需要函数列一致收敛，才能交换顺序。一致收敛是一个非常强的条件。</p></blockquote><p>推论：如果<span class="math inline">\(\{f_k(x)\}\)</span>是<span class="math inline">\(E\in R^n\)</span>上的可测函数列，且：</p><ol type="1"><li><span class="math inline">\(\lim _{k\to \infty}f_k(x)=f(x)\)</span></li><li><span class="math inline">\(\exists M&gt;0,|f_k(x)|\leq M,a.e. x\in E\)</span></li><li><span class="math inline">\(m(E)&lt;\infty\)</span></li></ol><p>那么，<span class="math inline">\(f_k(x),f(x)\in L(E)\)</span>，且积分和极限可以交换次序，有： <span class="math display">\[\lim _{k \rightarrow \infty} \int_E f_k(x) \mathrm{d} x=\int_E f(x) \mathrm{d} x=\int_E \lim _{k \rightarrow \infty} f_k(x) \mathrm{d} x .\]</span> 推论：设<span class="math inline">\(u_i(x)\in L(E)\)</span>，且有： <span class="math display">\[\sum_{i=1}^{\infty} \int_E\left|u_i(x)\right| d x&lt;+\infty\]</span> 则：</p><ol type="1"><li><p><span class="math inline">\(\sum_{i=1}^n u_i(x)\)</span>几乎处处收敛</p></li><li><p>其和函数<span class="math inline">\(f(x)\in L(E)\)</span>，且 <span class="math display">\[\int_E f(x) \mathrm{d} x=\int_E\left[\sum_{i=1}^{\infty} u_i(x)\right] \mathrm{d} x = \sum_{i=1}^{\infty} \int_E u_i(x) d x\]</span></p></li></ol><blockquote><p>【例】求 <span class="math display">\[\lim _{n \rightarrow \infty}(R) \int_0^1 \frac{n x}{1+n^2 x^2} \sin n x d x\]</span></p><p>【解】因为原函数列不一致收敛，因此需要用L积分。</p><p>验证勒贝格收敛控制定理： <span class="math display">\[\left|f_n(x)\right| \leq\left|\frac{n x}{1+n^2 x^2}\right| \leq \frac{n x}{2 n x}=\frac{1}{2} \stackrel{\Delta}{=} F(x), x \in[0,1]\]</span></p><p>则有： <span class="math display">\[\begin{aligned}&amp; \lim _{n \rightarrow \infty}(R) \int_0^1 \frac{n x}{1+n^2 x^2} \sin n x d x \\&amp; =\lim _{n \rightarrow \infty}(L) \int_{[0,1]} \frac{n x}{1+n^2 x^2} \sin n x d x \\&amp; =(L) \int_{[0,1]}\left(\lim _{n \rightarrow \infty} \frac{n x}{1+n^2 x^2} \sin n x\right) d x \\&amp; =(L) \int_{[0,1]} 0 \mathrm{~d} x=0 .\end{aligned}\]</span></p></blockquote><p>有时候，问题中并不显式地出现极限、求和符号，但是可以通过把被积分展开成级数的和，再求解：</p><blockquote><p>【例】 <span class="math display">\[\int_{0}^1 \frac{\ln(1-x)}{x}dx\]</span> 【解】</p><p>首先展开成级数： <span class="math display">\[\frac{\ln (1-x)}{x}=-\sum_{n=1}^{\infty} \frac{x^{n-1}}{n}, x \in[0,1)\]</span></p><p>我们发现这不是一致收敛的，但是没关系，我们有勒贝格积分： <span class="math display">\[\begin{aligned}&amp;\ (R) \int_0^1 \frac{\ln (1-x)}{x} \mathrm{~d} x \\&amp; =(L) \int_{[0,1]} \frac{\ln (1-x)}{x} \mathrm{~d} x \\&amp; =(L) \int_{[0,1]}\left(-\sum_{n=1}^{\infty} \frac{x^{n-1}}{n}\right) \mathrm{d} x\\&amp; =-\sum_{n=1}^{\infty}(L) \int_{[0,1]} \frac{x^{n-1}}{n} d x \\&amp; =-\sum_{n=1}^{\infty} \frac{1}{n^2} \\&amp; =-\frac{\pi^2}{6} \end{aligned}\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实变泛函</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221107-20221130）</title>
    <link href="/2022/11/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221107-20221130%EF%BC%89/"/>
    <url>/2022/11/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221107-20221130%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>哈哈，我已经很多周没有写周记了，大概有三四周了。现在是校历第十四周的周三，期末的氛围已经很浓厚了。在这一段时间里面，北航竟然出现了阳性病例，这是我没有想到的。第一次出现是在11月25日，那次一早上醒来就发现新北有阳性，然后学校就迅速的把所有宿舍都封控了，还迅速给每个宿舍发了饭，这一系列动作不得不给北航点个赞，你航的后勤这方面真的没法喷。</p><p>至于我自己呢，首先心理状态肯定是会受到疫情影响的，按群友的话来说就是“一阳性就没心情学习了”，这也是我接下来要着力克服的方面。这段时间的信息真的太多了，纷繁复杂，如果真的要一一处理，无疑会浪费我的大量经历。而我的精力很宝贵，我的精力要用在学习上的。所以我想，我还是要把精力放在学习上，至于外部的纷繁复杂的消息，我想，只能作为消遣吧。我的计划是：早上八点半起床，下午两点起床，学习的时候少玩手机，少刷知乎，增强效率，做好计划，就酱。</p><p>我看完了《论中国》，《Ever17》暂时搁置。原神打通了深渊12-3，这是值得自豪的事。这说明像我这样的XP党也可以打通深渊的。深渊打通了以后，Ever17也可以继续了。我看了《孤独摇滚》，真他妈的好看，我要向全世界推荐。</p><p>今天江主席去世了，我买了一本《他改变了中国》，其实我早就读过电子版了，不知道重读一遍会不会有新的收获。</p><p>现在这个互联网，真是春春的奇葩了。认知战真是无处不在，我试举一例吧：有些人喜欢发一些看似意味深长而莫名其妙的东西，当问他们“发的是什么”时，他们往往会回答“不能说”、“懂得都懂”之类的话，或者某些粗略的引导。那么这时候，有些人，尤其是自诩为高级知识分子的人，为了不使自己看起来很“笨”，以至于连人家发的神秘信息也看不懂，为了显示自己是“懂得”，为了不“脱离圈子”，便会自己往上面附会一些意义，于是，自己便从“不懂得”演化成了“懂得”，这就叫做用自己的智慧击败自己。</p><p>那么这些信息到底有什么含义？正如三体中汪淼眼前的倒计时，它本身可以没有任何含义，倒计时的尽头什么也没有。可是三体人越故弄玄虚，越说什么也没有，作为高级知识分子的汪淼就越抓狂——他不允许自己理解不了这倒计时是什么含义。</p><p>这些可怜的不想被别人认为自己很笨的高级知识分子正在仔细研究这些信息，以从中推理出含义。可是这些信息本身真的什么也不是，于是他们自然推理不出来含义。这时，发信息的人又出现了，他给予这些可怜人以一点点微弱的引导，譬如：“想想最近发生了什么”，沉迷做题十数年、数十年的可怜人们便像是看到了出题人给出的“提示”，把那提示潜移默化中在脑中咂摸十遍百遍，于是，思想引导便完成了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211302336855.jpg" alt="高风险" /><figcaption aria-hidden="true">高风险</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211302336127.jpg" alt="核酸排队" /><figcaption aria-hidden="true">核酸排队</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211302336833.jpg" alt="学院路之秋" /><figcaption aria-hidden="true">学院路之秋</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211302337658.jpg" alt="深渊12-3" /><figcaption aria-hidden="true">深渊12-3</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路·逻辑之章</title>
    <link href="/2022/11/16/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/16/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>你说得对，但是《数字电子技术基础》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作五（203）的幻想世界，在这里，被神选中的信号将被授予“门电路”，导引高低电平之力。玩家将扮演一位名为“学生”的神秘角色，在自由的课程中邂逅性格各异、能力独特的元件们，和他们一起分析逻辑，找回失散的导线——同时，逐步发掘“Verilog”的真相。</p><span id="more"></span><h2 id="数制和码制">数制和码制</h2><h3 id="数制">数制</h3><p>数制指的是数字每一位的构成方法，以及从低位到高位的进位规则。常用的数制有十进制、二进制、八进制、十六进制。</p><p>k进制数字的基本表示方式为： <span class="math display">\[(\cdots x_2x_1x_0.x_{-1}x_{-2}\cdots)_k=\sum_{i=-\infty}^{\infty}x_i\times k^i\]</span></p><h4 id="不同数制的转换方式">不同数制的转换方式</h4><ul><li><p>任意进制到十进制的转换</p><p>直接按上面的式子展开即可。</p><blockquote><p>【例】<span class="math inline">\((8FA.C)_{16}=8\times 16^2+F\times16^1+A\times16^0+C\times16^{-1}=(2298.75)_{10}\)</span></p></blockquote></li><li><p>十-二转换</p><p>整数部分用除二取余法，小数部分用乘二取整法。这成天写，我不展开了，忘了就随便拿个什么11啊这种数字推一下。</p></li><li><p>二-十六（八）转换</p><p>分组对应法最快。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161438587.png" alt="进制转换对应表" /><figcaption aria-hidden="true">进制转换对应表</figcaption></figure></li></ul><p>不同进制下四则运算的规则和方法和十进制一致。</p><h4 id="原码反码和补码">原码、反码和补码</h4><ul><li><p>原码</p><p>最高位（最左边的一位）表示正负号，0为+，1为-，其余各位表示数的绝对值。</p><p>表示范围为<span class="math inline">\(-(2^{n-1}-1)\sim (2^{n-1}-1)\)</span>，0的表示不唯一</p></li><li><p>反码</p><p>正数和原码的规则一样，有符号位和绝对值；负数是它的相反数整体（含符号位）取反，当然也可以理解成，负数的符号位是1，绝对值按位取反。</p><p>表示范围为<span class="math inline">\(-(2^{n-1}-1)\sim (2^{n-1}-1)\)</span>，0的表示不唯一</p></li><li><p>补码</p><p>正数和原码的规则一样；负数为“反码加一”，即符号位为1，绝对值按位取反，再加一。</p><p>表示范围为<span class="math inline">\(-(2^{n-1})\sim (2^{n-1}-1)\)</span>，0的表示唯一。</p><p>补码加减法运算，符号位参与运算，而且应该在相应位数表示的数值范围内进行，进位直接丢弃。</p><blockquote><p>【例】利用补码加法计算39-22</p><p>【解】<span class="math inline">\((39)_{10}=(0|010\ 0111)_{2},(-22)_{10}=(1|110\ 1010)_2\)</span>，两个二进制数相加后为<span class="math inline">\((1\ 0001\ 0001)_2\)</span>，舍弃溢出位，得结果为<span class="math inline">\((0|001\ 0001)_2=(17)_{10}\)</span></p></blockquote><p>补码的运算有模的特性。</p></li></ul><h3 id="码制">码制</h3><ul><li><p>BCD码</p><p>BCD码，即二-十进制代码，它是用二进制代码表示十进制数码的编码方法，也就是0~9这十个符号的二进制编码。分为恒权码和变权码等。</p><p>例如：8421码，就是从高位到低位的权依次是8421（和普通二进制一样），它的有效编码是0000<sub>1001，分别代表0</sub>9，其它的是非法码。</p><p>还有其他的编码，比如2421码、余3码、余3循环码等。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161527716.png" alt="常用BCD码" /><figcaption aria-hidden="true">常用BCD码</figcaption></figure></li><li><p>格雷码</p><p>格雷码的特性如下：</p><ul><li>单位距离：相邻码字仅有一个位元不同，其它位都相同。</li><li>循环相邻：对于n位循环码，如果从第0个码字开始，最大范围是第<span class="math inline">\((2^n-1)\)</span>个码字，而对<span class="math inline">\((2^n-1)\)</span>的编码一定是<span class="math inline">\(( 2^ {n-1})\)</span>的自然二进制码。</li><li>镜像反射</li></ul></li></ul><h2 id="逻辑代数">逻辑代数</h2><p>逻辑运算的大部分知识已经在“离散数学”课程中讲过了，这里仅进行补充。这里“<span class="math inline">\(\cdot\)</span>”表示与，"<span class="math inline">\(+\)</span>"表示或，<span class="math inline">\(\overline{X}\)</span>表示非，<span class="math inline">\(\oplus\)</span>表示异或，<span class="math inline">\(\odot\)</span>表示异或。</p><h3 id="逻辑函数的两种标准形式">逻辑函数的两种标准形式</h3><p>两种标准形式就是指标准与或表达式（也叫最小项之和，主析取范式），和标准或与表达式（也叫最大项之积，主合取范式）。</p><ul><li><p>标准与或表达式</p><p>形如下列式子的形式： <span class="math display">\[\begin{align}Y&amp;=AB\overline{C}+ABC+\overline{A}BC\\&amp;=m_{3}+m_{6}+m_{7}\\&amp;=\sum m(3,6,7)\end{align}\]</span> 这三个形式都是标准与或表达式。<span class="math inline">\(m\)</span>下面的下标由对应的最小项确定（没有取反的项记为1，有取反的项记为1，构成一个二进制串，转换为十进制即可）。</p></li><li><p>标准或与表达式</p><p>形如下面的式子： <span class="math display">\[\begin{align}Y&amp;=(A+B+C)(A+B+\overline{C})(\overline{A}+B+C)\\&amp;=M_0M_1M_4\\&amp;=\prod M(0,1,4)\end{align}\]</span> 和上面的一样，不赘述了。</p></li></ul><h3 id="逻辑化简">逻辑化简</h3><p>公式法略。</p><h4 id="卡诺图法">卡诺图法</h4><p>卡诺图法是一种从真值表出发得到最简与或表达式的方法。使用卡诺图的步骤如下：</p><ol type="1"><li><p>先记住这几个标准格式</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211161607455.png" alt="卡诺图" /><figcaption aria-hidden="true">卡诺图</figcaption></figure><p>其实很好记的，横纵坐标就是格雷码的顺序，这也是为了利用单位距离性。</p></li><li><p>在逻辑函数为真的格子上填1，逻辑函数为假的格子填0</p></li><li><p>画卡诺圈（乘积项），合并最小项（1），反复利用互补律化简。卡诺圈的形状可以是日字形，田字形，而且有循环边界条件。</p><p>互补律：<span class="math inline">\(A\overline{A}=0,A+\overline{A}=1\)</span></p><p>画卡诺圈时应该遵循以下原则：</p><ol type="1"><li>“1”格不能漏圈</li><li>“1”格可以属于一个以上的圈</li><li>圈越大越好</li><li>圈越少越好</li><li>每个圈应该包含至少一个新的“1”格</li></ol></li></ol><h4 id="无关项">无关项</h4><p>有时候，输入逻辑变量的某些取值组合禁止出现，这种叫做“约束项”。有时候，一些取值组合出现时，输出逻辑值可以是任意的，这种叫做“任意项”。以上两个统称为无关项。在化简时，把无关项用X表示，在画卡诺圈时，X既可以被当作1，也可以被当作0，具体看你需要。</p><h4 id="逻辑函数形式的转换">逻辑函数形式的转换</h4><p>除了我们前面说的最简与或式以外，还有一些常用的形式。</p><ul><li><p>最简或与式</p><p>在画出<span class="math inline">\(Y\)</span>的卡诺图后，合并<span class="math inline">\(0\)</span>方格，求反函数的最简与或表达式，然后使用德摩根公式进行反演变换，得到原函数的最简或与表达式</p><p>德摩根公式： <span class="math display">\[\overline{AB}=\overline{A}+\overline{B},\overline{A+B}=\overline{A}\cdot\overline{B}\]</span></p><blockquote><p>【例】已知Y的反函数，求Y的最简或与式。 <span class="math display">\[\overline{Y}=AB+CD+B\overline{D}\]</span> 【解】 <span class="math display">\[\begin{align}Y&amp;=\overline{AB}\cdot\overline{CD}\cdot\overline{B\overline{D}}\\&amp;=(\overline{A}+\overline{B})(\overline{C}+\overline{D})(\overline{B}+{D})\end{align}\]</span></p></blockquote></li><li><p>或非-或非式</p><p>先求出最简或与式，对最简或与式求两次反，再对内侧（下面）的反用一次德摩根公式展开。</p><blockquote><p>【例】 <span class="math display">\[\overline{\overline{(A+B)(\overline{A}+C)}}\to \overline{\overline{A+B}+\overline{\overline{A}+C}}\]</span></p></blockquote><p>也可以在求出反函数的最简与或表达式的时候，直接对反函数两端求反，再对各个乘积项用德摩根公式</p><blockquote><p>【例】 <span class="math display">\[\begin{align}&amp;\overline Y=\overline A\cdot \overline B+A\overline C\\&amp;\to Y=\overline{\overline A\cdot \overline B+A\overline C}\\&amp;\to Y=\overline{\overline{A+B}+\overline{\overline A+C}}\end{align}\]</span></p></blockquote></li><li><p>与非-与非式</p><p>把与或表达式两次取反，再用德摩根公式即可。</p><blockquote><p>【例】 <span class="math display">\[\begin{aligned}Y &amp;={A C+\overline{A} B} \\&amp;=\overline{\overline{A C+\overline{A} B}} \\&amp;=\overline{\overline{A \cdot C} \cdot \overline{\overline{A} \cdot B}}\end{aligned}\]</span></p></blockquote></li><li><p>与或非式</p><p>先求反函数的最简与或表达式，再求反。</p><blockquote><p>【例】 <span class="math display">\[\begin{align}Y&amp;=A C+\overline{A} B \\\overline{Y}&amp;=\overline{A} \cdot \overline{B}+A \cdot \overline{C} \\Y&amp;=\overline{\overline{A} \cdot \overline{B}+A \cdot \overline{C}}\end{align}\]</span></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微波技术·波之章</title>
    <link href="/2022/11/07/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/07/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>你说得对，但是《微波技术》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作五（303）的幻想世界，在这里，被神选中的信号将被授予“波导”，导引电磁波。玩家将扮演一位名为“传输线”的神秘角色，在自由的课程中邂逅性格各异、能力独特的圆图们，和他们一起分析阻抗，找回失散的能量——同时，逐步发掘“Black Magic”的真相。</p><span id="more"></span><p>[toc]</p><h2 id="传输线理论">传输线理论</h2><p>微波的工作频率为<span class="math inline">\(300MHz\sim 3000GHz\)</span>，对应的自由空间中的波长为<span class="math inline">\(1m\sim 0.1mm\)</span>，在这种条件下，日常尺度的导线以及具备很多异于理想导线的性质，被称作“长线”或者“传输线”，理想导线则被称作“短线”。具体来说，当系统的电长度<span class="math inline">\(l/\lambda \geq0.05\)</span>时，就要用传输线理论来分析问题，这种导线就被称作长线。</p><h3 id="传输线方程">传输线方程</h3><p>对于传输线上的一个微元<span class="math inline">\(dz\)</span>，有其等效集总参数模型：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211181534581.png" alt="image-20221118153336875" /><figcaption aria-hidden="true">image-20221118153336875</figcaption></figure><p>其中<span class="math inline">\(R_0\)</span>叫分布电阻，<span class="math inline">\(L_0\)</span>叫分布电感，<span class="math inline">\(G_0\)</span>叫分布电导，<span class="math inline">\(C_0\)</span>叫分布电容。理想导体的<span class="math inline">\(R_0=0\)</span>，理想介质的<span class="math inline">\(G_0=0\)</span>。</p><p>根据基尔霍夫定律列出方程，转换为复频域形式，则有我们所说的传输线方程，也叫频域电报方程 <span class="math display">\[\begin{aligned}&amp;\frac{\mathrm{d} \dot{U}(z)}{\mathrm{d} z}=-\left(R_0+j \omega L_0\right) \dot{I}(z)=-Z \dot{I}(z) \\&amp;\frac{\mathrm{d} \dot{I}(z)}{\mathrm{d} z}=-\left(G_0+\mathrm{j} \omega C_0\right) \dot{U}(z)=-Y \dot{U}(z)\end{aligned}\]</span> 其中<span class="math inline">\(Z=(R_0+j\omega L_0)\)</span>叫单位长度串联阻抗、<span class="math inline">\(Y=(G_0+j\omega C_0)\)</span>叫单位长度并联导纳。把上面两个式子对<span class="math inline">\(z\)</span>求导，再代换，有： <span class="math display">\[\begin{aligned}&amp;\frac{\mathrm{d}^2 \dot{U}(z)}{\mathrm{dz} z^2}-\gamma^2 \dot{U}(z)=0 \\&amp;\frac{\mathrm{d}^2 \dot{I}(z)}{\mathrm{d} z^2}-\gamma^2 \dot{l}(z)=0\end{aligned}\]</span> 其中 <span class="math display">\[\gamma=\sqrt{Z Y}=\sqrt{\left(R_0+\mathrm{j} \omega L_0\right)\left(G_0+\mathrm{j} \omega C_0\right)}=\alpha+\mathrm{j} \beta\]</span> 叫做传播常数，是一个取决于传输线物理性质的常数。于是，可以解出传输线方程的通解： <span class="math display">\[\dot{U}(z)=A_1 \mathrm{e}^{-\gamma z}+A_2 \mathrm{e}^{\gamma z}\]</span></p><p><span class="math display">\[I(z)=-\frac 1Z\frac{ \mathrm{~d} \dot{U}(z)}{ \mathrm{~d} z}=\frac{\gamma}{Z}\left(A_1 \mathrm{e}^{-\gamma z}-A_2 \mathrm{e}^{\gamma z}\right)=\frac{1}{Z_0}\left(A_1 \mathrm{e}^{-\gamma z}-A_2 \mathrm{e}^{\gamma z}\right)\]</span></p><p>其中<span class="math inline">\(Z_0\)</span>叫做传输线特性阻抗，有： <span class="math display">\[Z_0=\frac{Z}{\gamma}=\sqrt{\frac{Z}{Y}}=\sqrt{\frac{R_0+\mathrm{j} \omega L_0}{G_0+\mathrm{j} \omega C_0}}\]</span> <span class="math inline">\(A_1,A_2\)</span>是待定常数，要根据端口条件来确定。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211181630064.png" alt="完整电路" /><figcaption aria-hidden="true">完整电路</figcaption></figure><ol type="1"><li><p>终端条件</p><p>即已知终端<span class="math inline">\(\dot{U}_2,\dot{I}_2\)</span>。则有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{1}{2}\left(\dot{U}_2+Z_0 \dot{I}_2\right) \\A_2=\frac{1}{2}\left(\dot{U}_2-Z_0 \dot{I}_2\right)\end{array}\right.\]</span></p></li><li><p>始端条件</p><p>即已知<span class="math inline">\(\dot{U}_1,\dot{I}_1\)</span>。则有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{1}{2}\left(\dot{U}_1+Z_0 \dot{I}_1\right) \\A_2=\frac{1}{2}\left(\dot{U}_1-Z_0 \dot{I}_1\right)\end{array}\right.\]</span></p></li><li><p>波源阻抗条件</p><p>即已知<span class="math inline">\(\dot{E}_g,Z_g,Z_L\)</span>，有： <span class="math display">\[\left\{\begin{array}{l}A_1=\frac{Z_0 \dot{E}_{\mathrm{g}} \mathrm{e}^{-\gamma l}}{Z_{\mathrm{g}}+Z_0} \\A_2=\frac{Z_0 \dot{E}_{\mathrm{g}} \mathrm{e}^{-\gamma l}}{Z_{\mathrm{g}}+Z_0} \Gamma_{\mathrm{L}}\end{array}\right.\]</span></p></li></ol><h3 id="传输线上的参量">传输线上的参量</h3><h4 id="一次特征参量">一次特征参量</h4><p><span class="math inline">\(R_0\)</span>分布电阻，<span class="math inline">\(L_0\)</span>分布电感，<span class="math inline">\(G_0\)</span>分布电导，<span class="math inline">\(C_0\)</span>分布电容</p><h4 id="二次特征参量">二次特征参量</h4><p>二次特征参量也叫传播特性参量，其中最主要的就是传播常数<span class="math inline">\(\gamma\)</span>和特征阻抗<span class="math inline">\(Z_0\)</span>，具体的计算式已经在上面给出了。还有一些其它的特征参量，可以由上面的导出。</p><ol type="1"><li><p>衰减常数和相位常数</p><p>若<span class="math inline">\(\gamma=\alpha+j\beta\)</span>，那么<span class="math inline">\(\alpha\)</span>叫做衰减常数，表示经过单位长度行波幅度衰减<span class="math inline">\(e^{-\alpha}\)</span>，<span class="math inline">\(\beta\)</span>叫做相位常数，表示单位长度行波滞后的幅度。对于无耗传输线，有： <span class="math display">\[\left\{\begin{array}{l}\gamma=\mathrm{j} \omega \sqrt{L_0 C_0} \\\alpha=0 \\\beta=\omega \sqrt{L_0 C_0}\end{array}\right.\]</span></p></li><li><p>相速度和相波长</p><p>相速度就是等相位面移动的速度，相波长就是等相位面在一个周期内移动的距离。有： <span class="math display">\[v_p=\frac \omega \beta\]</span></p><p><span class="math display">\[\lambda_p=\frac{2\pi}\beta\]</span></p><p>对于均匀无耗传输线，有： <span class="math display">\[v_p=\frac{c}{\sqrt{\varepsilon_r\mu_r}}\]</span></p><p><span class="math display">\[\lambda_p=\frac{\lambda_0}{\sqrt{\varepsilon_r\mu_r}}\]</span></p></li><li><p>特性阻抗</p><p>特性阻抗具有如下特点：</p><ul><li>同一时刻，传输线上行波电压不同，但是传输线上各点的入射波电压和入射波之比是一个定值，这个值就是特性阻抗</li><li>传输线特性阻抗仅取决于传输线的结构，和其长度无关</li><li>特性阻抗描述入射（或反射）波电压和电流的幅度相位关系。</li></ul></li></ol><h4 id="工作状态参量">工作状态参量</h4><ol type="1"><li><p>反射系数</p><p>定义电压反射系数： <span class="math display">\[\Gamma_U(z)=\frac{\dot U_r(z)}{\dot U_i(z)}\]</span> 电流反射系数可类似定义，但我们一般都用电压反射系数。</p><p>对于无耗传输线，有： <span class="math display">\[\Gamma_{U}(z)=\frac{A_2}{A_1} \mathrm{e}^{-\mathrm{j} 2 \beta z}\]</span> 若终端负载处反射系数为<span class="math inline">\(\Gamma_2\)</span>，则有： <span class="math display">\[\Gamma(z)=\Gamma_2 \mathrm{e}^{-j 2 \beta z}=\left|\Gamma_2\right| \mathrm{e}^{\mathrm{j}\left(\phi_2-2 \beta_2\right)}=\left|\Gamma_2\right| \mathrm{e}^{\mathrm{j} \phi}\]</span> 其中<span class="math inline">\(\phi_2\)</span>是<span class="math inline">\(\Gamma_2\)</span>的相角。</p></li><li><p>输入阻抗</p><p>输入阻抗是传输线上任何一点的总电压和总电流的比，即： <span class="math display">\[Z_{\mathrm{in}}(z)=\frac{\dot{U}(z)}{\dot{I}(z)}\]</span> 输入阻抗和线上反射系数可以互相转化： <span class="math display">\[Z_{in}(z)=Z_0 \frac{1+\Gamma(z)}{1-\Gamma(z)}\]</span></p><p><span class="math display">\[\Gamma(z)=\frac{Z_{\mathrm{in}}(z)-Z_0}{Z_{\mathrm{in}}(z)+Z_0}\]</span></p><p>需要提醒：上面两个式子对终端也适用，也就是说如果终端直接接入阻抗<span class="math inline">\(Z_L\)</span>，是可以直接计算终端反射系数<span class="math inline">\(\Gamma_2\)</span>的。进一步，有： <span class="math display">\[Z_{\mathrm{in}}(z)=Z_0 \frac{1+\Gamma_2 \mathrm{e}^{-\mathrm{j} 2 \beta z}}{1-\Gamma_2 \mathrm{e}^{-j 2 \beta z}}=Z_0 \frac{Z_{\mathrm{L}}+\mathrm{j} Z_0 \tan \beta z}{Z_0+\mathrm{j} Z_{\mathrm{L}} \tan \beta z}\]</span> 当然，我感觉这个用史密斯圆图更好算。</p></li></ol><h4 id="驻波参量">驻波参量</h4><p>当<span class="math inline">\(Z_L=Z_0\)</span>时，称传输线阻抗匹配，否则称传输线失配。我们用驻波参量来衡量失配程度。</p><ol type="1"><li><p>驻波比SWR（<span class="math inline">\(\rho\)</span>）</p><p>驻波比的定义是沿线电压最大值和最小值之比，它和反射系数是一一对应的。对于无耗传输线，有： <span class="math display">\[\begin{gathered}\rho=\frac{1+|\Gamma|}{1-|\Gamma|}=\frac{1+\left|\Gamma_2\right|}{1-\left|\Gamma_2\right|} \\|\Gamma|=\left|\Gamma_2\right|=\frac{\rho-1}{\rho+1}\end{gathered}\]</span> 当完全匹配时，驻波比为1，沿线电压最大值和最小值相等，<span class="math inline">\(\Gamma_2=0\)</span>。</p></li><li><p>行波系数<span class="math inline">\(K\)</span></p><p>就是驻波比的倒数。</p></li><li><p>驻波相位<span class="math inline">\(l_{min}\)</span></p><p>离终端最近的电压波节点到终端的距离</p></li></ol><p>无耗传输线上的波有三种传输模式：</p><ol type="1"><li><span class="math inline">\(Z_L=Z_0\)</span>，此时阻抗匹配，波形是行波</li><li><span class="math inline">\(Z_L\)</span> 开路、短路或是纯虚数，此时传输线处于全反射状态，波形是纯驻波。</li><li>其它情况，传输线处于部分反射状态，波形是行驻波。</li></ol><h3 id="史密斯圆图">史密斯圆图</h3><h4 id="归一化阻抗和导纳">归一化阻抗和导纳</h4><p>定义归一化阻抗： <span class="math display">\[\bar{Z}_L=\frac{Z_L}{Z_0}\]</span> 则有： <span class="math display">\[\bar{Z}_{\mathrm{in}}(z)=\frac{\bar{Z}_{\mathrm{L}}+\mathrm{j} \tan \beta z}{1+\mathrm{j} \bar{Z}_L \tan \beta z}\]</span> 再定义归一化电标度（电尺寸）： <span class="math display">\[\bar{z}=\frac z\lambda\]</span> 则有： <span class="math display">\[\bar{Z}_{\mathrm{in}}(\bar{z})=\frac{\bar{Z}_{\mathrm{L}}+\mathrm{j} \tan 2 \pi \bar{z}}{1+\mathrm{j} \bar{Z}_{\mathrm{L}} \tan 2 \pi \bar{z}}\]</span> 表达式中不再包含和传输线结构有关的参量，于是此表达式可以适用于任意传输线的分析。</p><p>由阻抗和反射系数的一对一转换关系： <span class="math display">\[\Gamma(\bar{z})=\frac{\bar{Z}_{\mathrm{in}}(\bar{z})-1}{\bar{Z}_{\mathrm{in}}(\bar{z})+1}\]</span> #### 阻抗圆图</p><p>把<span class="math inline">\(Z\)</span>平面转换到<span class="math inline">\(\Gamma\)</span>平面，可得阻抗圆图：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211231047660.png" alt="image-20221123104650102" /><figcaption aria-hidden="true">image-20221123104650102</figcaption></figure><p>图中有<strong>三个关键点</strong>：</p><ol type="1"><li>匹配点：<span class="math inline">\(\Gamma (0,0)\)</span>点，对应<span class="math inline">\(Z(1,0)\)</span>点，此时有<span class="math inline">\(Z_L=Z_0\)</span>，传输线匹配，驻波比为1</li><li>开路点：<span class="math inline">\(\Gamma(1,0)\)</span>点，对应<span class="math inline">\(Z(\infty,\infty)\)</span>点，此时<span class="math inline">\(Z_L=\infty\)</span>，传输线处于开路状态，驻波比无穷大</li><li>短路点：<span class="math inline">\(\Gamma(-1,0)\)</span>点，对应<span class="math inline">\(Z(0,0)\)</span>点，此时<span class="math inline">\(Z_L=0\)</span>，传输线短路，驻波比无穷大</li></ol><p><strong>三个圆：</strong></p><ol type="1"><li><p>等电抗圆：指的是圆心在直线<span class="math inline">\(x=1\)</span>上的那些圆，在一个等点抗圆上的点有相等的电抗。在上半平面的电抗大于零，叫做感性；在下半平面的电抗小于零，叫做容性。其圆心在<span class="math inline">\((1,1/\bar X)\)</span>，半径为<span class="math inline">\(|1/\bar X|\)</span>。<span class="math inline">\(X\)</span>越小，等电抗圆越大。当<span class="math inline">\(X=0\)</span>时变成横轴，当<span class="math inline">\(X\to \infty\)</span>时变成开路点。</p></li><li><p>等电阻圆：指的是圆心在实轴（横轴）上的那些圆，在一个等电阻圆上的点有相等的电阻。其圆心为<span class="math inline">\((\bar R/(\bar R+1),0)\)</span>，半径为<span class="math inline">\(1/(\bar R+1)\)</span>。<span class="math inline">\(R\)</span>越小，等电阻圆越大。</p></li><li><p>等反射系数圆（也叫等驻波比圆）：指的是圆心在<span class="math inline">\(\Gamma (0,0)\)</span>的圆。圆的半径和反射系数以及驻波比有一一对应关系。当反射系数为正实数（即在实轴正半轴）时，对应电压波腹点，于是实轴正半轴叫做电压波腹线；同理，实轴负半轴叫做电压波节线。</p><p>当在传输线上移动<span class="math inline">\(\Delta z=\lambda/2\)</span>时，对应沿等反射系数圆旋转一圈，方向为“源顺负逆”。</p></li></ol><p>于是，在圆图中任意确定一个点，总能找到一个等电抗圆和一个等电阻圆与之对应，这样一来，我们就能读出这个点的阻抗。要确定传输线上其它点的阻抗，只需要按照源顺负逆的规则，在等反射系数圆上进行移动即可。</p><h4 id="导纳圆图">导纳圆图</h4><p>把阻抗圆图以圆心为中心旋转180度就是导纳圆图。在阻抗圆图中确定一点，绕等反射系数圆旋转180度，反射系数变为<span class="math inline">\(-\Gamma\)</span>。则<span class="math inline">\(-\Gamma\)</span>处在阻抗圆图中读出的归一化阻抗值就是原位置<span class="math inline">\(\Gamma\)</span>处的导纳值。</p><p>旋转时，波节线、波腹线、短路点、开路点随之旋转。但是“源顺负逆”的准则不变。</p><p>在导纳圆图上确定归一化导纳时，有关系： <span class="math display">\[\bar Y=Y\cdot Z_0\]</span></p><h3 id="阻抗匹配技术">阻抗匹配技术</h3><p>阻抗匹配包含两种含义，其一是信号源的匹配，即想办法从信号源中获得最大的功率并消除信号源的反射；其二是负载的匹配，即想办法消除反射。阻抗匹配有三种：信号源阻抗匹配，负载阻抗匹配，共轭阻抗匹配。其重要性有：</p><ol type="1"><li><p>负载匹配时功率最大，功率损耗最小</p></li><li><p>阻抗匹配可以改善系统信噪比</p></li><li><p>功率分配网络中的阻抗匹配可以吉昂蒂幅度和相位的误差</p></li><li><p>保持信号源工作稳定性</p></li><li><p>提高传输线 的功率容量 <span class="math display">\[P_{br}=\frac 12\frac{U^2_{br}}{Z_0}K\]</span></p></li></ol><h4 id="lambda4匹配"><span class="math inline">\(\lambda/4\)</span>匹配</h4><p>是一段特征阻抗为<span class="math inline">\(Z_{01}\)</span>，长度为<span class="math inline">\(\lambda/4\)</span>的传输线。如果这段传输线末端接<span class="math inline">\(R_L\)</span>阻抗，那么可以计算出，这部分的输入阻抗为： <span class="math display">\[Z_{in}=\frac{Z_{01}^2}{R_L}=Z_0\]</span></p><blockquote><p>推导过程：由公式 <span class="math display">\[Z_{\mathrm{in}}(z)=Z_0 \frac{1+\Gamma_2 \mathrm{e}^{-\mathrm{j} 2 \beta z}}{1-\Gamma_2 \mathrm{e}^{-j 2 \beta z}}=Z_0 \frac{Z_{\mathrm{L}}+\mathrm{j} Z_0 \tan \beta z}{Z_0+\mathrm{j} Z_{\mathrm{L}} \tan \beta z}\]</span> 把<span class="math inline">\(\beta z=2\pi/4=\pi/2\)</span>代入，得<span class="math inline">\(\tan \beta z=\infty\)</span>，此时可以把<span class="math inline">\(Z_L,Z_0\)</span>项略去，并把<span class="math inline">\(j\tan \beta z\)</span>项约分掉，就得： <span class="math display">\[Z_{in}=\frac{Z_0^2}{Z_L}\]</span></p></blockquote><p>这个结论也叫“<span class="math inline">\(\lambda/4\)</span>传输线阻抗变换特性”，需要记住。</p><p>得 <span class="math display">\[Z_{01}=\sqrt{Z_0R_L}\]</span> 如果负载不是纯电阻，那么可以把匹配器接在电压波腹点<span class="math inline">\(l_{max}\)</span>或电压波节点<span class="math inline">\(l_{min}\)</span>。此时，匹配的目的是要把输入阻抗变成纯电阻。匹配时，首先确定负载所在的等反射系数（等驻波比）圆，然后在这个圆上确定波节点/波腹点，读出对应的电阻值。负载的点和波节/波腹点的电标度的差决定了<span class="math inline">\(\lambda/4\)</span>传输线的位置（这个位置指的是从负载到<span class="math inline">\(\lambda/4\)</span>传输线最近的边缘的距离），在这里放置<span class="math inline">\(\lambda/4\)</span>传输线，其到负载之间的部分（负载+原传输线）等效为纯阻。然后，再把这个纯阻（刚刚读出来的）带入前面的方程中，计算<span class="math inline">\(\lambda/4\)</span>传输线所需的阻抗。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212202328429.png" alt="四分之一波长匹配器匹配过程" /><figcaption aria-hidden="true">四分之一波长匹配器匹配过程</figcaption></figure><h4 id="单支节匹配">单支节匹配</h4><p>单支节匹配是在传输线上并联一根传输线枝节，通过调节枝节的位置<span class="math inline">\(d\)</span>和长度<span class="math inline">\(l\)</span>，抵消阻抗的虚部，从而实现匹配。其步骤为：</p><ol type="1"><li><p>在史密斯圆图上画出归一化负载阻抗<span class="math inline">\(\bar Z_L\)</span>的位置，把它旋转180度，画出归一化负载导纳<span class="math inline">\(\bar Y_L\)</span>的位置，把导纳的位置记作<span class="math inline">\(A\)</span>，电标度为<span class="math inline">\(\bar l_A\)</span></p></li><li><p>首先来求<span class="math inline">\(d\)</span>：从<span class="math inline">\(A\)</span>点开始，沿着等反射系数圆顺时针旋转，直到和可匹配圆（<span class="math inline">\(\bar G=1\)</span>）相交，交点记作<span class="math inline">\(C\)</span>，对应导纳<span class="math inline">\(\bar Y_1=1+j\bar B\)</span>，则在此位置并联<span class="math inline">\(\bar Y_2=-jB\)</span>的电纳即可实现匹配。设<span class="math inline">\(C\)</span>点的电标度为<span class="math inline">\(\bar l_C\)</span>，则有： <span class="math display">\[d=(\bar l_C-\bar l_A)\lambda\]</span></p></li><li><p>接下来求<span class="math inline">\(l\)</span>：找到短路点（圆图右侧端点）位置，其电标度为0.25.从短路点开始，顺时针沿着全反射圆移动到电纳值为<span class="math inline">\(-\bar B\)</span>的地方，记作<span class="math inline">\(E\)</span>点。<span class="math inline">\(E\)</span>点的电标度为<span class="math inline">\(\bar l_E\)</span>，则有： <span class="math display">\[l=(\bar l_E-0.25)\lambda\]</span></p></li></ol><p>以上过程可由如下图示描述，不同颜色表示不同的步骤：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212201140012.png" alt="单枝节匹配过程" /><figcaption aria-hidden="true">单枝节匹配过程</figcaption></figure><h4 id="双支节匹配">双支节匹配</h4><p>在单支节匹配中，我们移动枝节的位置，来寻找归一化电导值为1的参考面。那么有没有别的办法得到这个面呢？有：我们在枝节和负载中间附加一个纯电纳即可。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212210021630.png" alt="双支节匹配示意图" /><figcaption aria-hidden="true">双支节匹配示意图</figcaption></figure><p>如图所示，这两个枝节的位置是固定的，我们首先要调节<span class="math inline">\(l_1\)</span>的长度，让<span class="math inline">\(2\)</span>号支节所在的参考面的归一化电导值为1，然后再调节<span class="math inline">\(l_2\)</span>的长度，以达到匹配效果。</p><p>以下，记：</p><table><thead><tr class="header"><th>名称</th><th>含义</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\bar Y_1\)</span></td><td><span class="math inline">\(d_1\)</span>段传输线（含负载）归一化输入导纳</td><td></td></tr><tr class="even"><td><span class="math inline">\(\bar Y_2\)</span></td><td><span class="math inline">\(1\)</span>号支节始端归一化输入导纳</td><td>纯纳</td></tr><tr class="odd"><td><span class="math inline">\(\bar Y_3\)</span></td><td><span class="math inline">\(d_2\)</span>段传输线始端归一化输入导纳</td><td>在可匹配圆上</td></tr><tr class="even"><td><span class="math inline">\(\bar Y_4\)</span></td><td><span class="math inline">\(2\)</span>号支节始端归一化输入导纳</td><td>纯纳</td></tr><tr class="odd"><td><span class="math inline">\(\bar Y_B\)</span></td><td>整个系统最前端等效负载归一化导纳</td><td><span class="math inline">\(Y_B=Y_3+Y_4\)</span></td></tr><tr class="even"><td><span class="math inline">\(\bar Y_A\)</span></td><td><span class="math inline">\(d_2\)</span>段传输线终端等效负载归一化导纳</td><td><span class="math inline">\(Y_A=Y_1+Y_2\)</span></td></tr></tbody></table><p>于是，我们知道：<span class="math inline">\(Y_3\)</span>在可匹配圆上，由于<span class="math inline">\(d_2\)</span>传输线会对于每个<span class="math inline">\(Y_3\)</span>对应的点有一个绕着圆心旋转的作用，所以我们把可匹配圆也绕着圆心旋转<span class="math inline">\(\bar d_2=d_2/\lambda\)</span>，称作“辅助圆”。双支节匹配的过程是：</p><ol type="1"><li><p>把可匹配圆绕着单位圆的圆心旋转<span class="math inline">\(\bar d_2=d_2/\lambda\)</span>，画出辅助圆（深绿色）</p></li><li><p>确定<span class="math inline">\(\bar Z_L,\bar Y_L\)</span>位置（鲜红色）</p></li><li><p>从<span class="math inline">\(\bar Y_L\)</span>开始，沿其所在的等反射系数圆顺时针旋转<span class="math inline">\(\bar d_1\)</span>，得到<span class="math inline">\(\bar Y_1\)</span>（橙色）</p></li><li><p>因为<span class="math inline">\(\bar Y_2\)</span>是纯纳，所以<span class="math inline">\(\bar Y_A\)</span>和<span class="math inline">\(\bar Y_1\)</span>在一个等电导圆上。画出<span class="math inline">\(Y_1\)</span>所在的等电导圆<span class="math inline">\(G=G_1\)</span>，这个等电导圆和辅助圆的交点就是<span class="math inline">\(\bar Y_A\)</span>。由<span class="math inline">\(\bar Y_2=\bar Y_A-\bar Y_1\)</span>计算出<span class="math inline">\(\bar Y_2\)</span>，绘制<span class="math inline">\(\bar Y_2\)</span>，读出<span class="math inline">\(\bar l_2\)</span>的电标度，有（鲜绿色）： <span class="math display">\[\bar l_1=(\bar l_{Y_2}-0.25)\]</span></p></li><li><p>画出<span class="math inline">\(\bar Y_A\)</span>所在的等反射系数圆，交可匹配圆<span class="math inline">\(G=1\)</span>于<span class="math inline">\(\bar Y_3\)</span>点。读出<span class="math inline">\(\bar Y_3=1+j\bar B_3\)</span>.（蓝色）</p></li><li><p>画出<span class="math inline">\(\bar Y_4=-jB_3\)</span>，有（紫色）： <span class="math display">\[\bar l_2=(\bar l_{Y_4}-0.25)\]</span></p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202212210047719.png" alt="双支节匹配过程" /><figcaption aria-hidden="true">双支节匹配过程</figcaption></figure><h2 id="波导理论">波导理论</h2><h3 id="导行波的传播特性">导行波的传播特性</h3><p>导行波的场量都有因子<span class="math inline">\(e^{-\gamma z}\)</span>，其中<span class="math inline">\(\gamma=\alpha+j\beta\)</span>。由麦克斯韦方程和边界条件推导（意思就是我也不想推导）可知： <span class="math display">\[\gamma=k^2_c-k^2\]</span> 其中<span class="math inline">\(k=\omega\sqrt{\mu\varepsilon}\)</span>为电磁波在无限媒质中的波数，它由波的频率和传播介质决定。<span class="math inline">\(k_c\)</span>叫波导的截止波数，它由波导系统横截面的边界条件决定，这两个“波数”都是实数。于是，随着频率的不同，<span class="math inline">\(\gamma\)</span>有以下三种情况：</p><ul><li><span class="math inline">\(\gamma^2&lt;0\)</span>，此时有<span class="math inline">\(\gamma=j\beta\)</span>，因为场量不随着距离增长而衰减，称为传输状态。</li><li><span class="math inline">\(\gamma^2&gt;0\)</span>，此时有<span class="math inline">\(\gamma=\alpha\)</span>，此时场量随着距离增长而指数衰减，称为截止状态。</li><li><span class="math inline">\(\gamma^2=0\)</span>，这个叫临界状态，分析时认为不属于传输状态，波不能传输。</li></ul><p>既然有了“截止波数”<span class="math inline">\(k_c\)</span>的定义，我们也可以顺势定义出截止频率、截止波长：</p><ul><li><p>截止频率<span class="math inline">\(f_c\)</span> <span class="math display">\[f_c=\frac{k_c}{2\pi\sqrt{\mu\varepsilon}}\]</span></p></li><li><p>截止波长<span class="math inline">\(\lambda_c\)</span> <span class="math display">\[\lambda_c=\frac{v}{f_c}=\frac{2\pi}{k_c}\]</span> 其中<span class="math inline">\(v\)</span>是理想介质<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="就是不导电的介质，不是自由空间。">[1]</span></a></sup>中的光速。</p></li></ul><p>于是，导波系统传输TE波或TM波的条件是： <span class="math display">\[f&gt;f_c\ \text{or}\ \lambda&lt;\lambda_c\]</span> 我们进一步分析传输状态时的导行波。理想导波系统中的相波长<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="等相面在一个周期内移动的距离">[2]</span></a></sup>称为波导波长，记作<span class="math inline">\(\lambda_g\)</span>。根据相波长和相位常数的定义，有： <span class="math display">\[\beta=\frac{2\pi}{\lambda_g}\]</span> 我们可以计算出，对于相位常数<span class="math inline">\(\beta\)</span>，有： <span class="math display">\[\beta=\sqrt{k^2-k_c^2}=\frac{2\pi}\lambda\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}\]</span> 于是，相波长为 <span class="math display">\[\lambda_g=\frac{\lambda}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}=\frac{\lambda_0/\sqrt{\mu_r\varepsilon_r}}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}\]</span> 根据相速度的一般公式<span class="math inline">\(v_p=\omega/\beta\)</span>，相速度为： <span class="math display">\[v_p=\frac{c/\sqrt{\mu_r\varepsilon_r}}{\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}}\]</span> 根据群速度的一般公式<span class="math inline">\(v_g=d\omega/d\beta\)</span>，将<span class="math inline">\(\beta=\sqrt{k^2-k_c^2}\)</span>中的<span class="math inline">\(k\)</span>用<span class="math inline">\(\omega\sqrt{\mu\varepsilon}\)</span>表示，有： <span class="math display">\[v_g=v\sqrt{1-\left(\frac{\lambda}{\lambda_c}\right)^2}\]</span> 以上就是会经常用到的一些传播特性参量。</p><h3 id="导波模式">导波模式</h3><h4 id="矩形波导">矩形波导</h4><p>导通模式下矩形波导中TM波的通解为：</p><p>【一大坨式子，里面有两个参量<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>】</p><p>这里的<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>就是波导边界条件决定的正整数，称作波指数。<span class="math inline">\(m\)</span>表示沿着波导长边分布的半驻波个数，<span class="math inline">\(n\)</span>表示沿着波导短边分布的半驻波个数。<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都不能是零。每一个<span class="math inline">\((m,n)\)</span>都对应着一种电磁场分布，即一种波形，或者说，模式，记作<span class="math inline">\(TM_{mn}\)</span></p><p>导通模式下矩形波导中TE波的通解为：</p><p>【一大坨式子，里面有两个参量<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>】</p><p>这里的<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都是自然数，但是不能同时为零。每一个<span class="math inline">\((m,n)\)</span>都对应着一种模式，记作<span class="math inline">\(TE_{mn}\)</span></p><p>将各种<span class="math inline">\(TM_{mn}\)</span>和<span class="math inline">\(TE_{mn}\)</span>相互叠加，就能表示出矩形波导中所有可能存在的波形。那么怎么知道某种模式是否存在呢？我们有： <span class="math display">\[k_c^2=\left(\frac{m\pi}{a}\right)^2+\left(\frac{n\pi}{b}\right)^2\]</span> 也就是 <span class="math display">\[\lambda_c=\frac{2\pi}{k_c}=\frac{2}{\sqrt{\left(\frac{m\pi}{a}\right)^2+\left(\frac{n\pi}{b}\right)^2}}\]</span> 考察波的<span class="math inline">\(k\)</span>(由频率和介质决定)，当满足传输条件<span class="math inline">\(k&gt;k_c\)</span>或<span class="math inline">\(\lambda&lt;\lambda_c\)</span>时，就存在对应的模式。观察这个式子，我们发现当<span class="math inline">\(m,n\)</span>对应相等时，TM波和TE波有着相同的截止波数，我们把这样的现象叫做模式简并<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="严格的定义是：模式简并：截止波数相同但是场分布不同的现象">[3]</span></a></sup>。</p><p>通常，我们称截止波数最小（截止波长最大）的模式为主模，也叫基本模式或者最低模式。矩形波导的主模是<span class="math inline">\(TE_{10}\)</span>模。</p><p>矩形波导的功率容量（最大传输功率）如下： <span class="math display">\[P_{max}=\frac{ab}{480\pi}E^2_{br}\sqrt{1-\left(\frac{\lambda}{2a}\right)^2}\]</span> 其中<span class="math inline">\(E_{br}\)</span>是波导内媒质的击穿电压。</p><h4 id="圆波导">圆波导</h4><p>圆波导的分析的大概形状和矩形波导是类似的，也有TE、TM波。</p><p>TM通解为：</p><p>【一大坨式子，里面有个参量<span class="math inline">\(u_{ni}\)</span>】</p><p>其中<span class="math inline">\(u_{ni}\)</span>表示第一类<span class="math inline">\(n\)</span>阶贝塞尔函数的第<span class="math inline">\(i\)</span>个零点。<span class="math inline">\((n,i)\)</span>代表了一个TM波的模式，记作<span class="math inline">\(TM_{ni}^\circ\)</span></p><p>TE通解为：</p><p>【一大坨式子，里面有个参量<span class="math inline">\(v_{ni}\)</span>】</p><p>其中<span class="math inline">\(v_{ni}\)</span>表示第一类<span class="math inline">\(n\)</span>阶贝塞尔函数的导数的第<span class="math inline">\(i\)</span>个零点。<span class="math inline">\((n,i)\)</span>代表了一个TE波的模式，记作<span class="math inline">\(TE_{ni}^\circ\)</span></p><p>圆波导的截止波长一般查表给出。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211072249964.png" alt="截止波数表" /><figcaption aria-hidden="true">截止波数表</figcaption></figure><p>在圆波导中，存在两种模式简并。第一种是E-H简并，因为对于第一类贝塞尔函数有<span class="math inline">\(J&#39;_0(x)=-J_1(x)\)</span>，所以<span class="math inline">\(J&#39;_0\)</span>和<span class="math inline">\(J_1\)</span>的零点相等，因此<span class="math inline">\(H_{0i}\)</span>和<span class="math inline">\(E_{1i}\)</span>简并。第二种叫极化简并，是因为坐标<span class="math inline">\(\varphi\)</span>的完全对称性引起的。在圆波导中，电磁场的横向分布存在着<span class="math inline">\(\cos n\varphi\)</span>和<span class="math inline">\(\sin n\varphi\)</span>两种形式，它们具有相同的截止波长，只是极化方向旋转90度。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>就是不导电的介质，不是自由空间。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>等相面在一个周期内移动的距离 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>严格的定义是：模式简并：截止波数相同但是场分布不同的现象 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221031-20221106）</title>
    <link href="/2022/11/06/%E5%91%A8%E8%AE%B0%EF%BC%8820221031-20221106%EF%BC%89/"/>
    <url>/2022/11/06/%E5%91%A8%E8%AE%B0%EF%BC%8820221031-20221106%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第十周，一个学期又快要结束了（指还剩下7周），稍微有点焦虑。本周精神状态、身体状态良好，学习状态佳，还是挺不错的。周三的时候和友人一起去故宫了，故宫确实好看，但是只转了一个下午，属于是有点潦草了。另外，这周还买了D9音乐会的票，这玩意之前我也是每年看一次的，还以为不办了呢，结果又回来了，有点开心。</p><p>这周打了原神3.2和赛博朋克2077，以及Ever17。Ever17打通了第一条线，赛博朋克就剩最后一个结局了。所以说，精神状态和心理状态好了，干啥都好。</p><p>这周电赛的成绩出来了，二等奖，算是“还行”吧，挺不错的。集成电路马上就来了，要抓紧学习了。</p><p>这周做了俩实验，微波实验的一个表看着比我还老，春春的逆天，哈哈</p><p>这周继续阅读了论中国这本书，下周说不定能看完了。</p><p>这周，我们来议论一下提瓦特大陆各国的政治体制，分析一下“教令院之变”的过程。</p><p>分析提瓦特的政治，不能照搬照抄我们这个世界的理论。毕竟，人家是异世界嘛。提瓦特目前的四个国家，尽管风土人情、政治体制、权力部门设置区别很大，但是有一个不变的共同点，那就是“君权神授”。而且，这里的神不同于在我们这个世界流毒甚广的亚伯拉罕一神教的神，这里的神是个活生生的，权能极大的真“人”。在提瓦特，谁掌握了神权，谁能称为神的代言人，谁就能拥有一切。</p><p>蒙德国，尽管风神巴巴托斯在大部分人看来是个酒鬼流浪汉，但是国家的立国理念“自由”被攥在神权手中。当风神弹琴时，统治机构西风骑士团的代理团长也得安安静静站在一旁听着，她还得在国家的各种重要场合邀请这个酒鬼流浪汉出席。</p><p>璃月国，岩王帝君摩拉克斯自导自演了一出退休戏码，神权似乎隐退了。但是事实果然如此吗？非也。在璃月，仙人作为神的代言人，行使着神权。例如月海亭秘书长甘雨就一直权柄在握，不如说，璃月七星必须让她掌握大权。到了过节了，璃月七星还得亲自去给仙人送礼慰问。</p><p>稻妻国，三奉行深知，稻妻之所以存在至今，完全是因为雷神巴尔泽布的存在，更准确地说，是因为“无想的一刀”的存在，以至于到了对其“迷信”的地步。三奉行知道，自己能吃拿卡要，能作威作福，完全是巴尔泽布（及其创造的机器人）赐予的。在巴尔泽布逮捕当朝三分之二的高官时，没有遇到任何形式的抵抗：将军说什么就是什么——不然，你来挥出“无想的一刀”？</p><p>须弥国，是目前最接近“人治”的国家。但是教令院君主立宪制的合法性来源于何处？来源于大慈树王的神权，包括最重要的统治工具——虚空——也是如此。大慈树王山陵崩后，教令院以她的神权为后盾，都督须弥诸军事。但是，教令院也知道，自己的合法性的最大来源已经死了，于是他们软禁新神，并试图创造属于自己的<a href="https://www.zhihu.com/search?q=伪神&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2747711192%7D">伪神</a>，以便在彻底瞒不过去后寻找新的合法性。</p><p>但是，教令院没有想到，他们低估了真正的神之权能，他们软禁的纳西妲是一位优秀的政治家。这位政治家有着优秀的品质：谦逊和忍耐，也就是“<strong>战略定力</strong>”。她能耐得住五百年的寂寞，观察须弥和提瓦特的社会各阶层，等待教令院自我毁灭。终于，她等到了教令院的致命失误，在一场政变中把教令院卖国集团一波带走。</p><p>在进入须弥前不久，须弥国的主要矛盾是什么？很简单，是<strong>世界树的污染</strong>。那么谁能根治世界树的污染？很简单，有且仅有一个人，那就是纳西妲，那就是摩诃善法大吉祥智慧主布耶尔。大道理管着小道理，这就是纳西妲能成功大政奉还的最大的道理。</p><p>此外，须弥国还面临着其它严重的危机，换句话说，教令院正在犯下严重的错误。</p><p>第一，<strong>城乡发展不平衡</strong>，沙漠人民和雨林人民矛盾日益加深，国家处在分裂的边缘；</p><p>第二，<strong>教令院高层出现分裂</strong>，六贤者中呈现了四对二的局面；</p><p>第三，<strong>政治中心须弥城的防卫部队竟然大部分都是外包的</strong>，而且几乎全是地位低下的沙漠人民；（是不是二次元都喜欢让战斗角色的政治地位较低？其它例子如86、EVA、末日时在做什么等等）</p><p>第四，<strong>死域、魔鳞病等灾害愈演愈烈</strong>，当然这是主要矛盾的副作用；</p><p>最后，<strong>教令院卖国集团勾结愚人众境外势力</strong>，借用民众大脑制造伪神，妄图给自己塑造新的合法性。</p><p>此时，<strong>西风骑士团荣誉骑士、绝云间归来之人、璃月港的大英雄、雷电将军御侧侍卫、稻妻几乎全部国土的再生父母——大名鼎鼎的旅行者来了，纳西妲觉得是时候了。</strong></p><blockquote><p>咔咔，请您下决心吧！</p></blockquote><p>在旅行者还没到达须弥，还在海岛度假时，纳西妲抢先一步和旅行者建立了联系。后来，在梦境事件中，纳西妲和旅行者建立了深厚的革命友谊（她说我是她的唯一！）。</p><p>为什么选定了旅行者？因为她可以提供极强的羁绊（或者说，关系）。旅行者说话，有人信。试想如果是普通须弥人告诉艾书记、赛诺等人梦境事件，他大概只有一个结果，那就是被当成林居诳语期然后扔到阿如村。但是旅行者不一样，旅行者上通神灵下通百姓，权势滔天功勋卓著，平易近人无私奉献，简直就是天降圣人（唯一的缺点可能就是成天发情，盒盒）。旅行者让艾书记、提纳里和赛诺相信了小吉祥草王“居然还活跃在须弥”，于是才能有后面的教令院之变。与此同时，旅行者还办了一件事，那就是消弭了赤王信徒和草王信徒的宗教矛盾，为日后的计划奠定了基础。</p><p>终于，爷一行人抵达了教令院，开始了政变。</p><p>第一步，拥有了至高无上的<strong>合法性宣称</strong>：智慧之神纳西妲。</p><p>第二步，通过伪装被捕的方式在全国政治中心埋下一支<strong>精锐武装部队</strong>。</p><blockquote><p>拉赫曼将军，就由你来打头阵吧！</p></blockquote><p>第三步，调离或策反首都警卫力量。在沙漠人民和雨林居民矛盾不断恶化的时代，只要纳西妲提出乡村（沙漠）振兴计划，拿出<strong>解决城乡发展不平衡的诚意</strong>（解决了问题一），消弭赤王和草王的信仰分歧，拿钱办事的沙漠雇佣兵很难不倒戈（解决了问题三）。</p><blockquote><p>我们军人是很单纯的，生来就是为国家服务的！</p></blockquote><p>第四步，待对方首脑防卫空虚，立刻派出赛诺<strong>直接将其逮捕</strong>。</p><blockquote><p>大贤者从愚人众处收受不少的金钱吧！因此我们有必要听取大贤者的陈述，请贤者合作。</p></blockquote><p>第五步，纳西妲以迅雷不及掩耳之势<strong>控制了全国的广播站、电视台</strong>（也就是虚空）<strong>，</strong>发表题为《散兵怎么打，在线等，急》的<strong>全国虚空讲话</strong>，正式荣登大宝。此时，爷和纳西妲以坚决的斗争姿态清除了教令院的残余抵抗势力散兵。</p><blockquote><p>须弥人民们！在我们祖国和我国各族人民命运面临严峻危急的时刻，我们向你们发出呼吁！我们伟大的祖国面临致命的危险！由阿扎尔发起并开始的改革政策，原想作为保障教令院迅速发展的手段，却因种种原因已走入死胡同。失去信仰、冷漠和绝望取代了最初的热情和希望。教令院失去了人民的信任。在社会生活中，玩弄权术取代了对国家和人民命运的关心。整个须弥实际上已失去控制。</p></blockquote><p>这时候，政变看似已经基本结束了，可以开香槟了。是这样的吗？</p><p>看似是的，但是纳西妲非常清醒，她记得自己的政变能成功的<strong>大道理</strong>，也记得须弥的<strong>主要矛盾</strong>。于是她没有着急控制局势，收拾残局，而是直接用神的权能根治了世界树，治好了魔鳞病，遏制了死域发展（解决了问题四），自此，<strong>小吉祥草王和大慈树王二位一体</strong>，获得了完美无缺的政权宣称。紧接着，她和博士展开战略博弈，一口气完成了几件小小的战略目标：</p><p>首先有一个，就是<strong>加入了至冬国的反抗天理阵营</strong>。二一个就是获得了<strong>至冬国和国际社会对新生政权的承认</strong>，要说还有一个就是<strong>博士一律不许切片</strong>，这对须弥的安全来说也是很重要的一个。</p><p>至此，纳西妲执掌了政权，站稳了脚跟，获得了国际社会的认可，还狠狠地削了博士一把。之后，艾书记等人将教令院拨乱反正，粉碎了四贤者卖国集团，但没有开展大清洗，而是保留了绝大多数原有的精英。紧接着，艾书记急流勇退，纳西妲正式执政。接下来 她面临的问题就是：须弥新的主要矛盾是什么？须弥社会怎么和平稳定地发展？我们只能拭目以待了。</p><p>周日晚上我看了摇曳露营，我的评价是一部温馨而慢节奏的励志片，非常好看，推荐大家看。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202211070028289.jpg" alt="摇曳露营" /><figcaption aria-hidden="true">摇曳露营</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221024-20221030）</title>
    <link href="/2022/10/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221024-20221030%EF%BC%89/"/>
    <url>/2022/10/30/%E5%91%A8%E8%AE%B0%EF%BC%8820221024-20221030%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第九周，也就是这学期已经过去一半了。这周我的心情总体来说有点不好，因为我发现我的学习状态不是特别好。但是在周末已经努力改回来了，现在就看下周能不能继续保持住了。我估计下周会很忙，因为周二和周四各有两个实验，也不知道怎么做。</p><p>这周有一件大事，那就是校庆。我和友人一起去了，虽然因为去得比较晚，几乎啥奖品都没了。但是我得到了宋友便利贴，以及和友人一起逛校庆的经历，我以及赢麻了。虽然但是，校庆晚会上的“北京航天航空大学”属实是给我整绷不住了，就你航管宣传的这伙人，我不好说了，只能说是烂泥扶不上墙吧。</p><p>这周继续看论中国、以及一些科幻小说，游戏继续玩Ever17，以及赛博朋克。动画的话，想看孤独摇滚，明天就看。</p><p>在这周，我进行了一些思考。我认为中国的“谈话-酝酿-确认”模式，确实比西方的“辩论-投票”模式更加高级。首先：“辩论”这个行为，对人的临场反应能力，以及调动听众的情绪的能力的要求很高；而“谈话”（或者，写长文等），这种形式更考察人的深入思考、全面思考、冷静思考，以及想法和书面语之间的相互转化能力，以辨明真理为最高目标，而不以在言语上驳倒他人为最高目标。就我观察的几场辩论而言，双方为了驳倒对方，往往会深究某些不是主要矛盾的“定义”（例如，在“原神是不是国产游戏的黎明”议题中，双方对“黎明”进行了很长时间的辨析，但是这是主要矛盾吗？），攻击对方言语上的漏洞，或者试图调动观众的情绪。那么这两种要求哪个是作为一个国家的执政者更需要掌握的呢？我认为是第二个。当希特勒说出“你们是八百万德意志人，还是八百万奴隶”时，当然所有听众的情绪都被调动了，然后就把他选成德国总理，给全世界带来了深重的灾难。辩论、集会、演讲，选出来的是语言家、表演家，而不一定是政治家。</p><p>其次，我们来考量一下“投票”。我写了一些，但是我感觉写得不好，然后删了。总之我的观点是：民主不等同于人民直接决定政治领导人的过程，我国的全过程民主更接近民主的本质。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310008897.jpg" alt="绿园的秋" /><figcaption aria-hidden="true">绿园的秋</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310008371.jpg" alt="七公寓门前" /><figcaption aria-hidden="true">七公寓门前</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310008496.jpg" alt="图书馆门前" /><figcaption aria-hidden="true">图书馆门前</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310009850.jpg" alt="站点披萨，真他妈好吃！" /><figcaption aria-hidden="true">站点披萨，真他妈好吃！</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210310009878.jpg" alt="为庆祝北航生日吃蛋糕，当然实际上就是想吃蛋糕了" /><figcaption aria-hidden="true">为庆祝北航生日吃蛋糕，当然实际上就是想吃蛋糕了</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理·变换之章</title>
    <link href="/2022/10/26/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/26/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%89%8D%E5%9B%9B%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>你说得对，但是《数字信号处理》是电子信息工程学院独立开设的一门核心专业课，课程发生在一个被称作D221的幻想世界，在这里，被神选中的序列将被授予“傅里叶变换”，导引频域分解之力。玩家将扮演一位名为“DSP”的神秘角色，在自由的系统中邂逅性格各异、能力独特的信号们，和他们一起分析频谱，找回失散的频段——同时，逐步发掘“线性系统”的真相。</p><span id="more"></span><h2 id="第二章离散时间信号与系统">第二章：离散时间信号与系统</h2><h3 id="离数时间序列">离数时间序列</h3><p>序列的表示方式略。</p><h4 id="序列的分类">序列的分类</h4><p>有限长度/无限长度序列、左/右/双边序列、因果/非因果序列、实/复数序列的定义很显然，就是字面意思，略。</p><ul><li><p>周期序列和非周期序列</p><p>周期序列的定义： <span class="math display">\[\exists N\neq 0\ \forall n\ x[n]=x[n+N]\]</span> 满足上面式子的序列称为周期序列，否则称为非周期序列。需要提醒的是：如果一个序列满足上面的式子，它一定是无限长的双边序列，也就是<span class="math inline">\(n\)</span>从负无穷取遍正无穷。例如：<span class="math inline">\(x[n]=\sin (\pi n/5)\)</span>是周期序列，但<span class="math inline">\(x[n]=u[n]\sin(\pi n/5)\)</span>不是周期序列。</p></li><li><p>能量序列和功率序列</p><p>如果对序列<span class="math inline">\(x[n]\)</span>有： <span class="math display">\[E=\sum_{n=-\infty}^{\infty}\lvert x[n]\rvert^2&lt;\infty\]</span> 称该序列为能量有限序列，简称能量序列。对于能量无限序列，如果另有： <span class="math display">\[P=\lim_{N\to \infty}\frac{1}{2N+1}\sum_{n=-N}^N \lvert x[n] \rvert ^2&lt;\infty\]</span> 则称该序列为功率有限序列，简称功率序列。需要注意的是：周期序列一般来说都是功率序列。周期序列的功率为： <span class="math display">\[P=\lim_{N\to \infty} \frac{1}{N} \sum_{n=n}^{N-1}\lvert x[n]\rvert^2\]</span></p></li></ul><h4 id="常见序列">常见序列</h4><p>矩形序列、脉冲序列、阶跃序列、实指数序列略。</p><ul><li><p>复指数序列</p><p>对于指数序列 <span class="math display">\[x[n]=A\alpha^n\]</span> 如果<span class="math inline">\(A,\alpha\)</span>是复数，那么这个序列是复指数序列。若有<span class="math inline">\(A=|A|\angle \varphi,\alpha=|\alpha|\angle \omega_0\)</span>，则复指数序列也可以表示成： <span class="math display">\[x[n]=|A||\alpha|^n\exp [j(\omega_0n+\varphi)]\]</span> 复指数序列表现为一列不断收缩或者扩张的螺旋。特别地，当<span class="math inline">\(|\alpha|=1\)</span>时，复指数序列的幅值保持不变。此时，如果满足 <span class="math display">\[\frac {\omega_0}{2N}\in \mathbb Q\]</span> 则复指数序列是周期序列。其周期为： <span class="math display">\[N=\frac{2\pi m}{\omega_0}\in \mathbb Z^+\]</span> 其中<span class="math inline">\(m\)</span>是能让<span class="math inline">\(N\)</span>成为正整数的整数。</p><blockquote><p>【例】计算以下序列的最小正周期： <span class="math display">\[x[n]=e^{j\frac {6\pi}{31}n}\]</span> 【解】由于 <span class="math display">\[N=\frac{2\pi m}{\omega}=\frac{31}{3}m\]</span> 取<span class="math inline">\(m=3\)</span>，得最小正周期为<span class="math inline">\(N=31\)</span></p></blockquote><p>无论复指数序列是不是周期序列，<span class="math inline">\(\omega_0\)</span>都称作这个序列的数字频率。对于连续时间信号来说，频率越大，信号震荡得越快。但是对于复指数序列来说，<span class="math inline">\(\omega_0\)</span>从<span class="math inline">\(0\)</span>增加到<span class="math inline">\(\pi\)</span>时，振荡得越来越快；从<span class="math inline">\(\pi\)</span>增加到<span class="math inline">\(2\pi\)</span>时，振荡得越来越慢，并且以<span class="math inline">\(2\pi\)</span>为周期。</p><p>这初看有些不好理解，但是实际上是因为复指数序列是离散时间序列，时间最细的粒度是<span class="math inline">\(1\)</span>（不同于连续时间序列的时间定义在连续统上，时间最细的粒度是无穷小）。复指数序列振荡最快的情形，可以想象这样的序列： <span class="math display">\[x[n]=Ae^{j\pi n}\]</span> 也就是<span class="math inline">\(x[n]=A(-1)^n\)</span>，它振荡得再快，也就是每过1个时间变一下符号而已嘛。</p><p>当<span class="math inline">\(\omega_0&gt;0\)</span>时，表示在复平面内逆时针旋转，否则为顺时针旋转。</p></li></ul><h3 id="离散时间系统">离散时间系统</h3><p>和连续时间系统的理论差不多，有线性、时不变、因果、记忆、稳定等等。</p><p>对于线性时不变<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="需要注意的是，我们平常做题见到的很多系统都不是线性时不变系统。例如：如果进行了压扩变换，那么系统往往是时变的。我们平常所进行的“调幅”(即频率搬移)乘以一个$\cos$，由于产生了新的频率分量，也不是线性时不变的。">[1]</span></a></sup>系统，同样可以用卷积表示。即：如果<strong>线性时不变系统</strong>的单位脉冲响应是<span class="math inline">\(h[n]\)</span>，对于任意输入序列<span class="math inline">\(x[n]\)</span>，有响应： <span class="math display">\[y[n]=\sum_{k=-\infty}^\infty x[k]h[n-k]=x[n]*h[n]\]</span></p><p>卷积有交换律、结合律，对加法有左分配律。</p><p>LTI系统是因果系统等价于其单位脉冲响应是因果序列。</p><p>LTI系统稳定等价于其单位脉冲响应绝对可和，即： <span class="math display">\[S=\sum_{k=-\infty}^\infty \lvert h[k] \rvert &lt; \infty\]</span></p><ul><li><p>线性常系数差分方程</p><p>差分方程的概念、表示方法和解法略，在之前的“Z变换”一文中有说明。</p><p>线性系统的输入序列<span class="math inline">\(x[n]\equiv 0\)</span>时，有输出序列<span class="math inline">\(y[n]\equiv 0\)</span>。这个结论是显然成立的：如果对于<span class="math inline">\(x[n]\equiv 0\)</span>的输出不全为零的话，设<span class="math inline">\(a[n]\)</span>单独输入时的输出为<span class="math inline">\(b[n]\)</span>，那么对于<span class="math inline">\(a[n]+x[n]\)</span>的输入，输出将为<span class="math inline">\(b[n]+y[n]\)</span>，可是<span class="math inline">\(a[n]+x[n]=a[n]\)</span>呀，<span class="math inline">\(y[n]\)</span>不全为零，那么系统对于同样的输入不就有两个不同输出了吗？这显然是荒诞的。</p><blockquote><p>【例】对于下列方程描述的系统： <span class="math display">\[y[n]-ay[n-1]=x[n]\]</span> 初始条件为<span class="math inline">\(y[-1]=1\)</span>，那么这是线性系统吗？</p><p>【解】对于全零输入，其输出序列为<span class="math inline">\(y[n]=a^{n+1}\)</span>，不全为零，因此不是线性系统。</p></blockquote><p>这道例题说明：不是一切用常系数线性差分方程表示的系统都是线性系统，更不用说线性时不变了。事实上，如果要系统是因果的LTI系统，必须要满足“初始松弛”的条件，也就是初始状态为零。</p></li></ul><h2 id="dtftdfs和z变换">DTFT、DFS和Z变换</h2><h3 id="离散时间傅里叶变换dtft">离散时间傅里叶变换(DTFT)</h3><p>首先，我们可以回忆一下连续时间信号的傅里叶变换： <span class="math display">\[\begin{align}X(j\Omega)=\int_{-\infty}^\infty x(t)e^{-j\Omega t}\mathbf dt\\x(t)=\frac{1}{2\pi}\int_{-\infty}^\infty X(j\Omega)e^{j\Omega t}\mathbf d\Omega\end{align}\]</span></p><h4 id="dtft的定义">DTFT的定义</h4><p>和连续时间傅里叶变换类似，DTFT是要把序列<span class="math inline">\(x[n]\)</span>表示序列<span class="math inline">\(e^{j\omega n }\mathbf d\omega\)</span>的线性组合： <span class="math display">\[x[n]=\frac{1}{2\pi}\int_{-\infty}^\infty X(e^{j\omega})e^{j\omega n}d\omega\]</span> 则权函数可以表示为： <span class="math display">\[X(e^{j\omega})=\sum_{n=-\infty}^\infty x[n]e^{-j\omega n}\]</span> 这就是离散时间傅里叶变换的性质。需要强调的是：<span class="math inline">\(X(e^{j\omega})\)</span>是<span class="math inline">\(\omega\)</span>的连续函数，称为频谱密度函数。它是周期为<span class="math inline">\(2\pi\)</span>的周期函数。</p><h4 id="dtft的性质和相关定理">DTFT的性质和相关定理</h4><p>假如<span class="math inline">\(x[n]\)</span>的DTFT是<span class="math inline">\(X(e^{j\omega})\)</span>，那么</p><ol type="1"><li><p>线性</p></li><li><p>时域移位性质： <span class="math display">\[x[n-n_d]\to e^{j\omega n_d}X(e^{j\omega})\]</span> 时域移位不会影响幅度频谱，但会引起相位频谱的线性变化，其斜率为<span class="math inline">\(-n_d\)</span></p></li><li><p>频域移位性质： <span class="math display">\[e^{j\omega_0n}\to X(e^{j(\omega-\omega_0)})\]</span></p></li><li><p>时间倒置性质： <span class="math display">\[x[-n]=X(e^{-j\omega})\]</span></p></li><li><p>频域微分性质： <span class="math display">\[nx[n]\to j\frac{d X}{d\omega}\]</span></p></li><li><p>共轭性质： <span class="math display">\[x^*[n]\to X^*(e^{-j\omega})\]</span></p></li><li><p>时、频域卷积，帕塞瓦尔定理。</p></li></ol><h4 id="dtft的对称性">DTFT的对称性</h4><p>对于一个序列<span class="math inline">\(x[n]\)</span>，有其共轭逆序序列<span class="math inline">\(x^*[-n]\)</span>，利用这个序列，我们可以把原序列分解<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="为什么说“分解”呢？因为$x[n]=x_e[n]+x_o[n]$显然成立。">[2]</span></a></sup>成共轭对称序列和共轭反对称序列，即： <span class="math display">\[\begin{align}x_e[n]=\frac 12(x[n]+x^*[-n])\\x_o[n]=\frac 12(x[n]-x^*[-n])\end{align}\]</span> 同样，对于连续函数（当然这里说的连续函数就是<span class="math inline">\(X(e^{j\omega})\)</span>，也可以按照类似的方法进行分解。</p><p>共轭对称序列<span class="math inline">\(x_e[n]\)</span>的实部偶对称，虚部奇对称；共轭反对称序列<span class="math inline">\(x_o[n]\)</span>的实部奇对称，虚部偶对称。</p><p>利用“共轭性质”，“线性性质”，有： <span class="math display">\[\begin{align}x_{Re}[n]\to X_e(e^{j\omega})\\jx_{Im}[n]\to X_o(e^{j\omega})\\x_e[n]\to X_{Re}(e^{j\omega})\\x_o[n]\to jX_{Im}(e^{j\omega})\end{align}\]</span> 由第一个式子，可以看出：实序列的DTFT幅度谱是偶函数，相位谱是奇函数。</p><h3 id="离散傅里叶级数dfs">离散傅里叶级数（DFS）</h3><p>DFS就是把DTFT里面的<span class="math inline">\(\omega\)</span>换成<span class="math inline">\(2\pi k/N\)</span>，其中<span class="math inline">\(N\)</span>是原序列的周期，<span class="math inline">\(k\)</span>是变换后得到的权序列的自变量。</p><h3 id="z变换">Z变换</h3><p>没啥好说的这个，上学期都学过了。</p><p>首先要注意的就是，<span class="math inline">\(X(z)\)</span>本质上来说还是个幂级数，以原序列为系数，即： <span class="math display">\[X(z)=\sum_{n=-\infty}^{\infty}x[n]z^{-n}\]</span> 在分析某些问题时，这种思维会很有用。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>需要注意的是，我们平常做题见到的很多系统都不是线性时不变系统。例如：如果进行了压扩变换，那么系统往往是时变的。我们平常所进行的“调幅”(即频率搬移)乘以一个<span class="math inline">()</span>，由于产生了新的频率分量，也不是线性时不变的。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>为什么说“分解”呢？因为<span class="math inline">(x[n]=x_e[n]+x_o[n])</span>显然成立。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221017-20221023）</title>
    <link href="/2022/10/23/%E5%91%A8%E8%AE%B0%EF%BC%8820221017-20221023%EF%BC%89/"/>
    <url>/2022/10/23/%E5%91%A8%E8%AE%B0%EF%BC%8820221017-20221023%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第八周，也就是这学期即将过去一半了。本周我有些感冒（应该是从周二夜间开始的），不如说还挺严重的，对我的生活各方面造成了相当大的影响。一方面是身体确实不太舒服，另一方面是容易借感冒了这个理由而多多摆烂，不过我觉得还好，摆就摆一会儿吧， 休息一下也好。不过等康复了以后要恢复起来。</p><p>在学习方面，本周没有做什么太多有意义的事情，无非是上课、写作业等。本来，我预计在周三更新一篇DSP总结，但是由于身体原因一直没有开始，争取这周写一写。另外就是本周进行了电赛测评，不知道结果如何。</p><p>在游戏方面，我开始打《Ever 17》了。游戏里的时间2017年，我们早已经超过了（笑），但是现在还没有实现那里面的技术。曾经有一部电影叫做《2001太空漫游》，里面充满了对2001年的太空世界浪漫主义的瑰丽想象。可是事实上我们人类却总是执着于在这个小小地球里面内卷，无暇顾及无垠的太空了。1991年美国取得冷战的胜利以来，已经失去了其初心使命，它的政权（或者说，体制，下文不作区分，当然实际上区别很大的）的目的已经是维持统治本身了。世界由这样的政权统治，还能有什么好结果呢？本周，党的二十大胜利召开了，里面有一条提法我很喜欢，那就是：建立人类文明新形态。我相信，经历了“不可能之革命”胜利的中国、中国共产党和中国体制是“领先于版本”的，一定能成为人类文明的出路。</p><p>西方国家总是对中国有着错误的理解，这导致它们从1949年以来对中国的预测“屡战屡败”，这很搞笑，它们难道没有发现自己的错误吗？譬如说吧，西方人总以为，在议会大打出手就是所谓的“民主”，而领导层们铁板一块则必然是“专制”，这太可笑了。</p><p>书，继续读论中国。这周读的少。我有点想看《孤独摇滚》。</p><p>下周就是校庆了，有点期待，但是还是有点懒。我和友人约定一起去校庆玩了。和去年相比，我更享受和友人在一起的时光了，而不是把它当成“任务”了。我也更乐于和友人分享生活中琐碎的事物了，这是一大进步。</p><p>我申请了一个优秀志愿者，接下来还要申请三好和优干。算了，都申吧，反正写申请书不要钱，哈哈。</p><p>对了，还有一件事，我确认了电子信息工程专业。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210240011528.jpg" alt="秋意渐浓如瀑" /><figcaption aria-hidden="true">秋意渐浓如瀑</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210240014356.jpg" alt="一星级志愿者" /><figcaption aria-hidden="true">一星级志愿者</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210240014395.png" alt="足迹" /><figcaption aria-hidden="true">足迹</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(21-30)</title>
    <link href="/2022/10/19/Verilog21-30/"/>
    <url>/2022/10/19/Verilog21-30/</url>
    
    <content type="html"><![CDATA[<h2 id="基于端口位置的实例化">基于端口位置的实例化</h2><h3 id="题目描述">题目描述</h3><p>创建一verilog电路，实现对模块mod_a基于端口位置的实例化，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191637163.png" /></p><p>其中mod_a模块的代码提供为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a(<br>    <span class="hljs-keyword">output</span> out1, out2,<br>    <span class="hljs-keyword">input</span> in1,in2,in3,in4);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;<br>    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;   <br>    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><strong>Hint:</strong></p><ul><li>实例化名称可以与模块名称相同</li><li>实例化模块时，需要注意端口信号的位宽相匹配，本例中都是1bit，所以不存在问题</li></ul><h3 id="输入格式">输入格式</h3><p>4个1bit信号a, b, c, d</p><h3 id="输出格式">输出格式</h3><p>经由模块mod_a输出的信号out1, out2</p><h3 id="代码和解析">代码和解析</h3><p>如题目所说，像调用函数一样依次传“参数”即可，注意位置要一一对应。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a(<br><span class="hljs-keyword">output</span> out1, out2,<br><span class="hljs-keyword">input</span> in1,in2,in3,in4);<br><span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4; <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;<span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b, <br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out1,<br>    <span class="hljs-keyword">output</span> out2<br>);<br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    mod_a mod_a_inst(out1,out2,a,b,c,d);<br><br><span class="hljs-comment">// 用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="基于端口名称的实例化">基于端口名称的实例化</h2><h3 id="题目描述-1">题目描述</h3><p>创建一 verilog 电路，实现对模块 mod_a 基于端口名称的实例化，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191640660.png" /></p><p>其中mod_a模块的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a (<br>    <span class="hljs-keyword">output</span>   out1,<br>    <span class="hljs-keyword">output</span>   out2,<br>    <span class="hljs-keyword">input</span>    in1,<br>    <span class="hljs-keyword">input</span>    in2,<br>    <span class="hljs-keyword">input</span>    in3,<br>    <span class="hljs-keyword">input</span>    in4<br>);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="输入格式-1">输入格式</h3><p>输入信号 a, b, c, d，位宽 1bit。</p><h3 id="输出格式-1">输出格式</h3><p>输出信号 out1, out2，位宽 1bit。</p><h3 id="代码和解析-1">代码和解析</h3><p>除了像C语言一样按顺序传参数以外，Verilog还可以进行基于端口名称的实例化，如这道题所示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a (<br>    <span class="hljs-keyword">output</span>   out1   ,<br>    <span class="hljs-keyword">output</span>   out2   ,<br>    <span class="hljs-keyword">input</span>    in1    ,<br>    <span class="hljs-keyword">input</span>    in2    ,<br>    <span class="hljs-keyword">input</span>    in3    ,<br>    <span class="hljs-keyword">input</span>    in4<br>);<br>    <span class="hljs-keyword">assign</span> out1 = in1 &amp; in2 &amp; in3 &amp; in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br>    <span class="hljs-keyword">assign</span> out2 = in1 | in2 | in3 | in4;    <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module ( <br>    <span class="hljs-keyword">input</span>   a   ,<br>    <span class="hljs-keyword">input</span>   b   ,<br>    <span class="hljs-keyword">input</span>   c   ,<br>    <span class="hljs-keyword">input</span>   d   ,<br>    <span class="hljs-keyword">output</span>  out1,<br>    <span class="hljs-keyword">output</span>  out2<br>);<br><br>mod_a ul(<br>    <span class="hljs-variable">.out1</span>       (out1),<br>    <span class="hljs-variable">.out2</span>       (out2),<br>    <span class="hljs-variable">.in1</span>        (a),<br>    <span class="hljs-variable">.in2</span>        (b),<br>    <span class="hljs-variable">.in3</span>        (c),<br>    <span class="hljs-variable">.in4</span>        (d));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多个模块的例化">多个模块的例化</h2><h3 id="题目描述-2">题目描述</h3><p>对于给定模块my_dff，包含两个输入信号和一个输出信号（D触发器模块），其代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> d,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> q);<br>   <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>      q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请创建一verilog模块，在该模块中将my_dff模块例化3次，并串行连接，使其构成一个长度为3的移位寄存器，其中3个模块公用一个clk信号，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191642288.png" /></p><p>为实现电路功能，用户需要在顶层模块定义一些内部信号，从而能够将3个例化的模块进行连接。</p><h3 id="输入格式-2">输入格式</h3><p>2个 1bit 位宽信号 clk、d</p><h3 id="输出格式-2">输出格式</h3><p>1个 1bit 位宽信号 q</p><h3 id="代码和解析-2">代码和解析</h3><p>只需要对于图里面的两个粗箭头定义两个<code>wire</code>型中间信号即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff(<span class="hljs-keyword">input</span> clk,<span class="hljs-keyword">input</span> d,<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> q);<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>        q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module ( <span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> d, <span class="hljs-keyword">output</span> q );<br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    my_dff u1(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.q</span>(w1));<br>    my_dff u2(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w1),<span class="hljs-variable">.q</span>(w2));<br>    my_dff u3(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w2),<span class="hljs-variable">.q</span>(q));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="模块与向量信号">模块与向量信号</h2><h3 id="题目描述-3">题目描述</h3><p>对于给定模块 my_dff8，其代码如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff8(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>        q &lt;= d;      <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>试创建一 Verilog 模块，对 my_dff8 模块例化 3 次，并串行连接，构成一个 8bit 位宽长度为 3 的移位寄存器，同时可以通过选择信号选择输出结果，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191647063.png" /></p><h3 id="输入格式-3">输入格式</h3><p>8bit 的任意有效输入</p><h3 id="输出格式-3">输出格式</h3><p>根据 sel 信号，选择一个模块或者原输入作为输出信号</p><h3 id="代码和解析-3">代码和解析</h3><p>比特矢量是可以作为一个信号直接参与模块例化的，这也是我之前说要把比特矢量看成一个“数”的原因之一。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_dff8(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<br>    q &lt;= d;<br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br>  <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w1,w2,w3;<br>    my_dff8 u1(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.q</span>(w1));<br>    my_dff8 u2(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w1),<span class="hljs-variable">.q</span>(w2));<br>    my_dff8 u3(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.d</span>(w2),<span class="hljs-variable">.q</span>(w3));<br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span> (sel)<br>            <span class="hljs-number">0</span>:q=d;<br>            <span class="hljs-number">1</span>:q=w1;<br>            <span class="hljs-number">2</span>:q=w2;<br>            <span class="hljs-number">3</span>:q=w3;<br>            <span class="hljs-keyword">default</span> : q=<span class="hljs-number">8&#x27;b00000000</span>;<br>        <span class="hljs-keyword">endcase</span><br>      <span class="hljs-keyword">end</span><br>  <span class="hljs-comment">// Write your code here</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这里用到了<code>always</code>块，是以前没有用到过的，但是我后面几个题的时候再来讲解。</p><h2 id="加法器">加法器</h2><p>对于给定的16bit加法器电路，其代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br> <span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>试创建一verilog模块，在该模块中实例化两个16bit的加法器，并进行适当的连接，最终构成一个32bit的加法器，该加法器输入进位位为0，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191652602.png" /></p><h3 id="输入格式-4">输入格式</h3><p>32'b0 32'b0</p><h3 id="输出格式-4">输出格式</h3><p>32'b0</p><h3 id="代码和解析-4">代码和解析</h3><p>这个题只需要读懂逻辑，然后照着图实现就可以了。这是一个典型的链接两个加法器的题，对于一个加法器（全加器），一般有三个输入：<code>a,b</code>是两个加数，<code>cin</code>是用来记录上一步有没有进位的值。输出一般有两个：<code>sum</code>是结果，<code>cout</code>是用来记录这个加法器有没有产生进位的值。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    add16 u1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<span class="hljs-variable">.sum</span>(sum1),<span class="hljs-variable">.cout</span>(w1));<br>    add16 u2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.cin</span>(w1),<span class="hljs-variable">.sum</span>(sum2),<span class="hljs-variable">.cout</span>(w2));<br>    <span class="hljs-keyword">assign</span> sum=&#123;sum2,sum1&#125;;<br>  <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多层次例化加法器">多层次例化加法器</h2><h3 id="题目描述-4">题目描述</h3><p>在此练习中，用户需要创建一个包含两层调用的电路，在顶层模块中，实例化两个16bit位宽的加法器add16,而add16模块又是通过例化16个1bit全加器实现的，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191656711.png" /></p><p>在本设计中，一共涉及到3个模块，分别是：顶层模块、add16模块、add1模块，其中add16模块源代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout);<br><span class="hljs-keyword">wire</span> c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15;<br><br>add1 inst_0(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">0</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(cin),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cout</span>(c1));<br>add1 inst_1(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">1</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cin</span>(c1),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cout</span>(c2));<br>add1 inst_2(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">2</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cin</span>(c2),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cout</span>(c3));<br>add1 inst_3(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">3</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cin</span>(c3),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cout</span>(c4));<br>add1 inst_4(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">4</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cin</span>(c4),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cout</span>(c5));<br>add1 inst_5(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">5</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cin</span>(c5),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cout</span>(c6));<br>add1 inst_6(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">6</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cin</span>(c6),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cout</span>(c7));<br>add1 inst_7(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">7</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cin</span>(c7),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cout</span>(c8));<br>add1 inst_8(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">8</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cin</span>(c8),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cout</span>(c9));<br>add1 inst_9(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">9</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cin</span>(c9),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cout</span>(c10));<br>add1 inst_10(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">10</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">10</span>]),<span class="hljs-variable">.cin</span>(c10),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">10</span>]),<span class="hljs-variable">.cout</span>(c11));<br>add1 inst_11(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">11</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">11</span>]),<span class="hljs-variable">.cin</span>(c11),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">11</span>]),<span class="hljs-variable">.cout</span>(c12));<br>add1 inst_12(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">12</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">12</span>]),<span class="hljs-variable">.cin</span>(c12),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">12</span>]),<span class="hljs-variable">.cout</span>(c13));<br>add1 inst_13(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">13</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">13</span>]),<span class="hljs-variable">.cin</span>(c13),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">13</span>]),<span class="hljs-variable">.cout</span>(c14));<br>add1 inst_14(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">14</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">14</span>]),<span class="hljs-variable">.cin</span>(c14),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">14</span>]),<span class="hljs-variable">.cout</span>(c15));<br>add1 inst_15(<span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>]),<span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>]),<span class="hljs-variable">.cin</span>(c15),<span class="hljs-variable">.sum</span>(sum[<span class="hljs-number">15</span>]),<span class="hljs-variable">.cout</span>(cout));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>现在，你需要完成顶层模块和add1模块的verilog代码。</p><h3 id="输入格式-5">输入格式</h3><p>两个32位宽的加数a,b</p><h3 id="输出格式-5">输出格式</h3><p>32位宽的和sum</p><h3 id="代码和解析-5">代码和解析</h3><p>首先，第一部分是实现一位全加器<code>add1</code>，有两种实现方式。第一种是写出真值表，画出卡诺图并化简成逻辑表达式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">wire</span> w1,a1,a2,a3;<br>    <span class="hljs-keyword">assign</span> w1 = a ^ b;<br>    <span class="hljs-keyword">assign</span> sum = w1 ^ cin;<br>    <span class="hljs-keyword">assign</span> a1 = a &amp; b;<br>    <span class="hljs-keyword">assign</span> a2 = a &amp; cin;<br>    <span class="hljs-keyword">assign</span> a3 = b &amp; cin;<br>    <span class="hljs-keyword">assign</span> cout = a1 | a2 | a3;<br><span class="hljs-comment">// Full adder module here</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>第二种是基于行为建模，直接写出结果即可：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add1 ( <span class="hljs-keyword">input</span> a, <span class="hljs-keyword">input</span> b, <span class="hljs-keyword">input</span> cin,   <span class="hljs-keyword">output</span> sum, <span class="hljs-keyword">output</span> cout );<br>    <span class="hljs-keyword">assign</span> &#123;cout,sum&#125;=a+b+cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>然后，第二部分就是<code>top_module</code>，这个没有什么新意，照着图写就行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum);<br>    <br>    <span class="hljs-keyword">wire</span> w1,w2;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br><br>    add16 u1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sum1),<br>        <span class="hljs-variable">.cout</span>(w1)<br>    );<br><br>    add16 u2(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(w1),<br>        <span class="hljs-variable">.sum</span>(sum2),<br>        <span class="hljs-variable">.cout</span>(w2)<br>    );<br><br>    <span class="hljs-keyword">assign</span> sum = &#123;sum2,sum1&#125;;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="进位选择加法器">进位选择加法器</h2><h3 id="题目描述-5">题目描述</h3><p>前例中的加法器成为串行进位加法器，只有等前一级的加法器运算结束产生进位位之后，下一级加法器才能利用进位位进行计算，因此电路延时会随加法器串联级数的增加而线性增加，这使得电路计算速度大大降低。设每一级全加器的延时为t，则32bit加法器的延时则为：32t。 为降低电路整体延时，我们可以按下图进行设计：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191702113.png" /></p><p>我们将电路分为两段，每段实现16bit的加法，为了使高16位与低16位同时进行运算，我们采用两个add16对高位进行计算，区别在于进位位分别为0和1，最终通过低16位加法器的输出进位作为选择控制信号，选择高16位的运算结果。这样，32bit加法器的延时就变为：16t+tmux2 ≈16t,延时降低了接近一倍，这种以空间（增加电路）换时间（提高速度）的做法，在数字电路设计中经常使用。 请创建Verilog模块，实现上图中的电路结构，其中add16不需要用户编写，其声明如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br>   <span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="输入格式-6">输入格式</h3><p>32bit a, 32bit b</p><h3 id="输出格式-6">输出格式</h3><p>32bit sum 为 a 与 b 的和</p><h3 id="代码和解析-6">代码和解析</h3><p>这题和前面几题差不多，没有什么难度，但是这个题介绍的方法很有趣。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <br><span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <br>    <span class="hljs-keyword">input</span> cin, <br>    <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <br>    <span class="hljs-keyword">output</span> cout <br>);<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sumH0,sumH1,sumL;<br>    <span class="hljs-keyword">wire</span> coutL;<br>    add16 H0(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sumH0)<br>    );<br>    add16 H1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">32</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-variable">.sum</span>(sumH1)<br>    );<br>    add16 L(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(b[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-variable">.sum</span>(sumL),<br>        <span class="hljs-variable">.cout</span>(coutL)<br>    );<br>    <span class="hljs-keyword">assign</span> sum=(coutL?&#123;sumH1,sumL&#125;:&#123;sumH0,sumL&#125;);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="加法减法器">加法减法器</h2><h3 id="题目描述-6">题目描述</h3><p>通过对加法器进行改造，可以支持加、减两种运算。我们知道，电路中有符号数通常使用补码表示，如<span class="math inline">\(-b\)</span>其补码为：<span class="math inline">\(\sim b + 1\)</span>（按位取反然后加1）。因此，对于减法算式<span class="math inline">\(a-b\)</span>,可以理解为<span class="math inline">\(a+(-b) = a+(\sim b+1)= a + (\sim b) +1\)</span>,因此对于减法运算，可以将加法器进行如下改造实现</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191705188.png" /></p><p>实现减法运算时，首先通过32bit的异或门，将信号b按位取反，同时将输入进位位置1，实现加法运算时，b保持不变，输入进位位置0。 其中add16模块代码如下，用户可直接调用：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请创建Verilog模块，实现上述电路功能。</p><h3 id="输入格式-7">输入格式</h3><p>32位的a,b，以及一个1位信号sub，sub为1时为减法，sub为0时为加法</p><h3 id="输出格式-7">输出格式</h3><p>32位信号sum 注：我想你读到这里的时候，一定跟我一样想着直接用sum=(sub==0?a+b:a-b)逃课了，但是请老老实实地按题目要求分高位低位取补码相加哦~~~</p><h3 id="代码与解析">代码与解析</h3><p>我们先对<span class="math inline">\(b\)</span>进行一个处理。如果题目要求加，即<code>sub==0</code>，那么不需要做任何处理，直接加即可。但是如果题目要求减，即<code>sub==1</code>，那么需要求取<code>b</code>的反码，即<code>~b</code>。我们很容易想到，异或可以完成这个工作：遇到0不变，遇到1取反。所以我们可以直接把<code>b</code>和<code>sub</code>异或。</p><p>由于减法是<span class="math inline">\(a+(-b) = a+(\sim b+1)= a + (\sim b) +1\)</span>，为了实现这个加一，我们直接把<code>sub</code>信号接到第一个全加器的<code>cin</code>上即可。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add16 ( <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] a, <span class="hljs-keyword">input</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] b, <span class="hljs-keyword">input</span> cin, <span class="hljs-keyword">output</span>[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum, <span class="hljs-keyword">output</span> cout );<br><span class="hljs-keyword">assign</span> &#123;cout,sum&#125; = a + b + cin;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">input</span> sub,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum<br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bXorSub;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sum1,sum2;<br>    <span class="hljs-keyword">wire</span> w1;<br>    <span class="hljs-keyword">assign</span> bXorSub = b ^ &#123;<span class="hljs-number">32</span>&#123;sub&#125;&#125;;<br>    add16 u1(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.b</span>(bXorSub[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]),<br>        <span class="hljs-variable">.cin</span>(sub),<br>        <span class="hljs-variable">.sum</span>(sum1),<br>        <span class="hljs-variable">.cout</span>(w1)<br>    );<br>    add16 u2(<br>        <span class="hljs-variable">.a</span>(a[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.b</span>(bXorSub[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]),<br>        <span class="hljs-variable">.cin</span>(w1),<br>        <span class="hljs-variable">.sum</span>(sum2)<br>    );<br>    <span class="hljs-keyword">assign</span> sum=&#123;sum2,sum1&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="always过程块_组合逻辑">always过程块_组合逻辑</h2><h3 id="题目描述-7">题目描述</h3><p>所有的数字电路都是由逻辑门和连线构成的，因此理论上来说都可以通过模块的连接和<code>assign</code>语句进行描述，然而在很多情况下这并不是最方便的一种方式，过程块提供了一种更加方便的描述方式，<code>always</code>过程块便是其中最常用的一种。 对于可综合电路（即能转化成实际电路的verilog描述方式，与之相对的是不可综合电路，多用于电路仿真，不能转换成实际电路），有两种<code>always</code>块的语法形式：</p><ul><li>组合逻辑电路：<code>always@(*)</code></li><li>时序逻辑电路：<code>always@(posedge clk)</code></li></ul><p>组合逻辑电路的<code>always</code>块与<code>assign</code>语句等效，用户描述组合逻辑电路时，可根据便利性选择其中一种方式使用。两者生成的硬件电路一般是等效的，但在语法规则上稍有不同：</p><ul><li><code>assign</code>语句只能对一个信号进行赋值，<code>always</code>块内可对多个信号进行赋值</li><li><code>assign</code>语句中被赋值信号为<code>wire</code>类型，<code>always</code>块内被赋值信号需定义为<code>reg</code>类型</li><li><code>always</code>块内支持更加丰富的语法，如使用<code>if…else..</code>、<code>case</code>等适合实现交复杂的组合逻辑 例如下述两条语句是等效的（out1需定义为<code>wire</code>类型，out2需定义为<code>reg</code>类型，但这仅仅是语法上的要求，生成的电路并没有区别）： <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out1 = a &amp; b | c ^ d;<br><span class="hljs-keyword">always</span> @(*) out2 = a &amp; b | c ^ d;<br></code></pre></td></tr></table></figure> 其对应的电路图如下所示：</li></ul><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192023388.png" /></p><p><code>always</code>语句后的括号内放的是敏感变量列表，对于上例来说，可以写成<code>always @(a,b,c,d) out2 = a &amp; b | c ^ d</code>，但为了简单起见，我们一般都用符号<code>*</code>代替。 试创建一verilog模块，实现一与门，分别用<code>assign</code>语句和<code>always</code>块实现。</p><h3 id="输入格式-8">输入格式</h3><p>1位的a，1位的b</p><h3 id="输出格式-8">输出格式</h3><p>1位的out_assign，1位的out_alwaysblock</p><h3 id="代码和解析-7">代码和解析</h3><p>这道题向我们介绍了一个叫做“过程块”的事物，它就是<code>always</code>。在过程块中被赋值的变量必须是<code>reg</code>类型，尽管综合时可能和平常所使用的<code>assign</code>得到的电路没有区别。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a, <br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_alwaysblock<br>);<br>    <span class="hljs-keyword">assign</span> out_assign = a &amp; b;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        out_alwaysblock = a &amp; b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="always过程块_时序逻辑">always过程块_时序逻辑</h2><h3 id="题目描述-8">题目描述</h3><p>通过前例已经了解到，对于可综合电路，有两种always块的语法形式：</p><ul><li>组合逻辑电路：<code>always@(*)</code></li><li>时序逻辑电路：<code>always@(posedge clk)</code></li></ul><p>用always描述的时序逻辑电路，除了像组合逻辑always块那样生成组合逻辑电路外，还会生成一组触发器（或称寄存器），用于寄存组合逻辑的输出。寄存器的输出只有在时钟的上升沿时（<code>posedge clk</code>）才会更新，其余时刻均保持不变。 阻塞赋值和非阻塞赋值： 在Verilog中，有三种赋值方式，分别为：</p><ul><li>连续赋值（如<code>assign x = y;</code>），该赋值方式只能用于过程块(如always块)之外</li><li>阻塞赋值（如<code>x = y;</code>），该赋值方式只能用在过程块（如<code>always@（*）</code>）内</li><li>非阻塞赋值（如<code>x &lt;= y;</code>），该赋值方式只能用在过程块内（如<code>always@（posedge clk）</code>）</li></ul><p>在设计Verilog模块时，请遵循以下原则：</p><ul><li>在组合逻辑的always块内采用阻塞赋值</li><li>时序逻辑的always块内采用非阻塞赋值</li></ul><p>违背这一原则将可能导致难以发现的电路错误，且可能导致仿真与综合的不一致，请用户切记。至于为何这样，初学者可以不必理会，简单理解为verilog语法规范性要求即可。 创建一verilog电路，分别采用上述三种赋值方式实现异或门电路，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192119474.png" /></p><p><strong>Hint</strong></p><ul><li>always块内被赋值的信号都应定义成reg类型</li><li>always块内，组合逻辑采用阻塞赋值（<code>a = b</code>），时序逻辑采用非阻塞赋值（<code>a &lt;= b</code>）</li><li>always语句括号内是敏感变量列表，时序逻辑是边沿敏感的，<code>posedge clk</code>表示的是clk信号的上升沿，此外，还可以是<code>negedge clk</code>，表示clk信号的下降沿。</li></ul><h3 id="输入格式-9">输入格式</h3><p>一位线网型变量clk，a, b。clk为时钟，a，b为输入</p><h3 id="输出格式-9">输出格式</h3><p>一位线网型变量out_assign，out_always_comb，out_always_ff。out_assign为a，b连续赋值得到的结果。out_always_comb为a，b阻塞赋值得到的结果。out_always_ff为a，b非阻塞赋值得到的结果</p><h3 id="代码和解析-8">代码和解析</h3><p>连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果；过程赋值只有在语句执行的时候，才会起作用。这是连续性赋值与过程性赋值的区别。</p><p>阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> sel, a, b ;<br><span class="hljs-keyword">reg</span> y , c ;<br><span class="hljs-keyword">always</span> @( sel <span class="hljs-keyword">or</span> a <span class="hljs-keyword">or</span> b ) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> ( sel == <span class="hljs-number">1&#x27;b1</span> ) <span class="hljs-keyword">begin</span><br>        c = a ;<br>        y = c ；<span class="hljs-comment">//实际就是y=a，这为了展示依次描述过程</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> y = b ;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这就是阻塞赋值，先执行<code>c=a</code>，再执行<code>y=c</code>，这段代码等价于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> sel, a, b, y ;<br><span class="hljs-keyword">assign</span> y = ( sel == <span class="hljs-number">1</span>’b1 ) ? a : b ;<br></code></pre></td></tr></table></figure><p>非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Cyclic_shifter ( clk, rst_n, Q );<br>    <span class="hljs-keyword">input</span> clk, rst_n ;<br>    <span class="hljs-keyword">output</span> [ <span class="hljs-number">2</span> : <span class="hljs-number">0</span> ] Q ;<br>    <span class="hljs-keyword">reg</span> [ <span class="hljs-number">2</span> : <span class="hljs-number">0</span> ] Q ;<br>    <span class="hljs-keyword">always</span> @ ( <span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n ) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> ( ~rst_n ) Q &lt;= <span class="hljs-number">3&#x27;b001</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>            Q[<span class="hljs-number">0</span>] &lt;= Q[<span class="hljs-number">2</span>] ; <span class="hljs-comment">//相当于 Q &lt;= &#123; Q[1:0], Q[2]&#125; ;</span><br>            Q[<span class="hljs-number">1</span>] &lt;= Q[<span class="hljs-number">0</span>] ; <span class="hljs-comment">//这里只是为了展示非阻塞赋值，</span><br>            Q[<span class="hljs-number">2</span>] &lt;= Q[<span class="hljs-number">1</span>] ; <span class="hljs-comment">//实际上，可打乱这3句的次序，无影响</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>非阻塞赋值是先计算出要“赋”的“值”，然后到块结束再统一“赋予”。例如上面的代码，就是利用非阻塞赋值来交换了三个变量的值。</p><p>本题的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always_comb,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always_ff   <br>);<br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    <span class="hljs-keyword">assign</span> out_assign = a ^ b;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        out_always_comb = a ^ b;    <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        out_always_ff &lt;= a ^ b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="ifelse语句">if…else…语句</h2><p>题目描述</p><p>if语句用于过程块内部，其对应的电路是二选一的选择器，</p><p>以下述代码为例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(*)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(condition) out = x;<br>  <span class="hljs-keyword">else</span> out = y;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>上述代码与下面的assign语句完全等效：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out = (condition) ? x : y;<br></code></pre></td></tr></table></figure><p>试创建一Verilog模块，分别采用assing语句和过程块内的if语句实现下述选择器电路：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210192154335.png" /></p><p><strong>Hint：</strong> 1. if…else…可以嵌套使用</p><ol start="2" type="1"><li>使用if语句描述组合逻辑时，务必加上else语句，以免产生锁存器（数字电路设计中应尽力避免产生锁存器）</li><li>本题两个输出信号波形其实是完全一致的，原则上是为了训练大家采用assign和过程块内的if语句使用，所以希望大家能够两种方式都各自尝试一下</li></ol><h3 id="输入格式-10">输入格式</h3><p>信号a, b, 选择信号sel_b1, sel_b2</p><h3 id="输出格式-10">输出格式</h3><p>通过assign语句选择的信号out_assign 通过if语句选择的信号out_always</p><h3 id="代码和解析-9">代码和解析</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">input</span> sel_b1,<br>    <span class="hljs-keyword">input</span> sel_b2,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_assign,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_always); <br><span class="hljs-comment">// 请用户在下方编辑代码</span><br>    <span class="hljs-keyword">assign</span> out_assign = (sel_b1 &amp; sel_b2) ? b : a;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(sel_b1 &amp; sel_b2)<br>            out_always = b;<br>        <span class="hljs-keyword">else</span> <br>            out_always = a;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221010-20221016）</title>
    <link href="/2022/10/19/%E5%91%A8%E8%AE%B0%EF%BC%8820221010-20221016%EF%BC%89/"/>
    <url>/2022/10/19/%E5%91%A8%E8%AE%B0%EF%BC%8820221010-20221016%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是校历第七周，总体来说算是比较满意的一周。本周主要是打了一个北京电赛，我们选的是滤波器题。怎么说呢？就是完全是临时乱抓，之前的培训完全没派上用场。培训了一堆什么画PCB，STM32，结果最后选了个模拟的题目，哈哈。好在最后算是把东西都完成了，也增进了和两位同学的友谊，就等下周末评测了，还行吧。</p><p>本周发生了一件乐事，就是微波把自己的实验排到了自己的理论课的时间，由此说明助教肯定不知道我们什么时候上理论课，多少有点离谱了。</p><p>书、二次元和游戏这周搞的比较少，毕竟要打电赛。</p><p>宿舍的浴室修好了，还挺好的，不错。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191630676.jpg" alt="电赛成品" /><figcaption aria-hidden="true">电赛成品</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210191631922.jpg" alt="学校博物馆上新" /><figcaption aria-hidden="true">学校博物馆上新</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(10-20)</title>
    <link href="/2022/10/10/verilog10-20/"/>
    <url>/2022/10/10/verilog10-20/</url>
    
    <content type="html"><![CDATA[<p>这一部分主要是比特矢量。</p><span id="more"></span><h2 id="向量">向量</h2><h3 id="题目描述">题目描述</h3><p><strong>Hint:</strong> 向量是为了编写、阅读代码方便，将一组相关的信号用一个向量名称统一命名的方式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w;<br></code></pre></td></tr></table></figure><p>声明了一个8bit位宽的向量信号w，实际上代表的是8个1bit的wire型信号。 注意向量信号的声明是将位宽信息放在信号名之前，这与C语言不太一样。我们可以将向量信号中的一位或多位单独拿来使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] out_4;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] my_vector;<br><span class="hljs-comment">// 声明一个100bit的向量my_vector</span><br><span class="hljs-keyword">assign</span> out = my_vector[<span class="hljs-number">11</span>] &amp; my_vector[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 选择其中两位信号进行运算</span><br><span class="hljs-keyword">assign</span> out_4 = my_vector[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>];<br><span class="hljs-comment">// 选择其中4bit信号</span><br></code></pre></td></tr></table></figure><p><strong>任务目标：</strong> 创建一verilog模块，具有一个3bit位宽的输入向量信号，然后将其输出到3bit位宽的输出向量信号，同时再分别输出到3个1bit位宽的输出信号，如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102158555.png" /></p><h3 id="输入格式">输入格式</h3><p>1个3bit位宽的向量信号vec</p><h3 id="输出格式">输出格式</h3><p>1个与输入vec保持一致的3bit位宽向量信号<code>outv</code>； 3个1bit位宽信号<code>o0</code>, <code>o1</code>, <code>o2</code>，分别对应输入信号<code>vec</code>的三位</p><h3 id="代码和解析">代码和解析</h3><p>当位宽大于 1 时，<code>wire</code>或 <code>reg</code> 即可声明为向量的形式。这种“向量”也叫“比特矢量”，为的是强调它的每一位都是一个二进制位。一个比特矢量一般来说是这么定义的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] name;<br></code></pre></td></tr></table></figure><p>对于一个比特矢量来说，我们更应该把它看成一个“变量”或“数”，而尽可能不把它看成“数列”，这样可能会为思考带来些许方便。比如说，一个比特矢量是可以直接赋值的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">var</span>;<br><span class="hljs-keyword">var</span>=<span class="hljs-number">8&#x27;hFF</span>;<br></code></pre></td></tr></table></figure><p>这样的话，变量<code>var</code>就被赋予了8位二进制数<code>8'b1111_1111</code>的值，也就是十进制下的511。在比特矢量中，更靠“左”的位对应的“下标”的数字会更大。初看很奇怪，但是只要把左边的理解成二进制的“高位”，那么位越高数字越大，就很显然了。</p><p>在访问单个元素时，可以使用类似于“数组”的形式来访问。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(vec,outv,o2,o1,o0);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] vec;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]outv;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> o0,o1,o2;<br><br>    <span class="hljs-keyword">assign</span> outv = vec[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> o0=vec[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> o1=vec[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">assign</span> o2=vec[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量_续-1">向量_续 1</h2><h3 id="题目描述-1">题目描述</h3><p>创建一 Verilog 模块，将 16bit 输入信号 <code>in</code>分成两个 8bit 的信号 <code>out_hi</code>、<code>out_lo</code>，然后输出，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102225212.png" /></p><h3 id="输入格式-1">输入格式</h3><p>输入信号 <code>in</code>, 位宽 16bit，类型为 <code>wire</code>。</p><h3 id="输出格式-1">输出格式</h3><p>输出信号<code>out_hi</code>，位宽 8bit，为输入信号的高 8 位。 输出信号<code>out_lo</code>，位宽 8bit，为输入信号的低 8 位。</p><h3 id="代码和解析-1">代码和解析</h3><p>Verilog里面的比特矢量是可以以和Python里面的列表切片有点类似的方法使用的，就像这里面一样，<code>[15:8]</code>就表示取第15位到第8位。这个学名叫“part-select操作”。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]out_hi,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]out_lo<br>);<br><br><span class="hljs-keyword">assign</span> out_lo = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> out_hi = in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量_续2">向量_续2</h2><h3 id="题目描述-2">题目描述</h3><p>一个32bit的向量信号包含有4个字节（bit[31:24]、bit[23:16]等），创建一个电路，用以调整4个字节的顺序，该电路经常用于在不同大小端系统之间进行数据交互： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">AaaaaaaaBbbbbbbbCcccccccDddddddd</span> <span class="hljs-operator">=</span>&gt; DdddddddCcccccccBbbbbbbbAaaaaaaa<br></code></pre></td></tr></table></figure> 提示：part-select操作即可以用于赋值语句的左侧也可用于右侧。</p><h3 id="输入格式-2">输入格式</h3><p>1个 32bit 位宽的向量信号 in</p><h3 id="输出格式-2">输出格式</h3><p>1个 32bit 位宽的向量信号 out</p><h3 id="代码和解析-2">代码和解析</h3><p>正如题目所说的，part-select操作即可以用于赋值语句的左侧也可用于右侧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>);<br><br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>] = in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>] = in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>] = in[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">assign</span> out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] = in[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="位操作">位操作</h2><h3 id="题目描述-3">题目描述</h3><p>创建一个电路，包含两个 3bit 的输入信号 a 和 b，分别对 ab 进行按位或、逻辑或操作，以及将 ab 拼接成 6bit 信号后进行按位取反，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102234810.png" /></p><h3 id="输入格式-3">输入格式</h3><p>a = 3'b101 b = 3'b000</p><h3 id="输出格式-3">输出格式</h3><p>按位或：3'b101 逻辑或：1 拼接ab后再按位取反：6'b111010</p><h3 id="代码和解析-3">代码和解析</h3><p>这里主要区分一下按位操作和逻辑操作。在逻辑操作中，一个数如果不等于0（即所有位都是0），那么它代表“真”值，反之，如果所有位都是0，那么它代表“假”值。</p><p>Verilog中，比特矢量是可以拼接的。只需要用个大括号把两部分括起来就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] out_or_bitwise,<br>    <span class="hljs-keyword">output</span> out_or_logical,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] out_not<br>);<br>    <span class="hljs-keyword">assign</span> out_or_bitwise = a|b;<br>    <span class="hljs-keyword">assign</span> out_or_logical = a || b;<br>    <span class="hljs-keyword">assign</span> out_not = &#123;~b,~a&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="位操作2">位操作2</h2><h3 id="题目描述-4">题目描述</h3><p>创建一个组合逻辑电路，包含4bit输入（in[3:0]），和3个输出，分别为：</p><ul><li><code>out_and</code>：四输入与门的输出信号</li><li><code>out_or</code>：四输入或门的输出信号</li><li><code>out_xor</code>：四输出异或门的输出信号</li></ul><p>电路结构如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102241454.png" /></p><h3 id="输入格式-4">输入格式</h3><p>0 0 0 0</p><h3 id="输出格式-4">输出格式</h3><p>0 0 0</p><h3 id="代码和解析-4">代码和解析</h3><p>在Verilog中，可以把一个本来是二目运算符的按位算符放在一个比特矢量的前面，这表示从高位到低位一个一个依次用这个二目运算符计算，最后得到一个一位的结果。这种操作叫“归约操作符”。归约操作符包括：归约与<code>&amp;</code>，归约与非<code>~&amp;</code>，归约或<code>|</code>，归约或非<code>~|</code>，归约异或<code>^</code>，归约同或<code>~^</code>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_and,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_or,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out_xor<br>);<br>    <span class="hljs-keyword">assign</span> out_and = &amp;in;<br>    <span class="hljs-keyword">assign</span> out_or = |in;<br>    <span class="hljs-keyword">assign</span> out_xor = ^in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量拼接">向量拼接</h2><h3 id="题目描述-5">题目描述</h3><p>part_selection用于选择向量信号中的一部分，而向量拼接算子{a,b,c}用于将多个信号组合成一个位宽更大的向量信号，如： <code>&#123;3'b111, 3'b000&#125;</code> 等同于 <code>6'b111000</code> <code>&#123;1'b1, 1'b0, 3'b101&#125;</code>等同于<code>5'b10101</code> <code>&#123;4'ha, 4'd10&#125;</code> 等同于 <code>8'b10101010</code> // 4'ha and 4'd10 are both 4'b1010 in binary 向量拼接时，每个信号都需要有明确的位宽，这样拼接后的信号才会有明确的位宽。例如，{1,2,3}就是非法的，因为无法确定各信号的位宽，语法检查时会报错。 向量拼接算子既可以用于赋值语句的左侧，也可用于右侧，如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] in;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">23</span>:<span class="hljs-number">0</span>] out;<br><span class="hljs-keyword">assign</span> &#123;out[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], out[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125; = in;<br><span class="hljs-keyword">assign</span> out[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;<br><span class="hljs-keyword">assign</span> out = &#123;in[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>], in[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>]&#125;;  <br></code></pre></td></tr></table></figure><p>创建Verilog电路，将6个5bit位宽的输入信号，以及2bit的常量信号2’b11拼接成32bit的向量信号，并将其拆成4个8bit的信号，分别赋值给4个输出信号，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102248499.png" /></p><h3 id="输入格式-5">输入格式</h3><p>6个5位宽的输入信号a,b,c,d,e,f</p><h3 id="输出格式-5">输出格式</h3><p>4个8位宽的信号w,x,y,z</p><h3 id="代码和解析-5">代码和解析</h3><p>正如题目中所说：向量拼接算子既可以用于赋值语句的左侧，也可用于右侧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] a, b, c, d, e, f,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w, x, y, z );<br>    <span class="hljs-keyword">assign</span> &#123;w,x,y,z&#125; = &#123;a,b,c,d,e,f,<span class="hljs-number">2&#x27;b11</span>&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="向量翻转">向量翻转</h2><h3 id="题目描述-6">题目描述</h3><p>创建verilog电路，将8bit的输入信号按bit翻转，并输出到输出端口，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102255765.png" /></p><h3 id="输入格式-6">输入格式</h3><p>8 bit in</p><h3 id="输出格式-6">输出格式</h3><p>8 bit out, 为in的向量翻转</p><h3 id="代码和解析-6">代码和解析</h3><p>想到翻转，我第一时间想到的是直接写成这样：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out=in[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>];<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>然而实践证明并不行，是因为 Verilog 不允许翻转向量的位顺序，所以还是只能一个一个赋值。</p><p>正确的代码是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">assign</span> out=&#123;in[<span class="hljs-number">0</span>],in[<span class="hljs-number">1</span>],in[<span class="hljs-number">2</span>],in[<span class="hljs-number">3</span>],in[<span class="hljs-number">4</span>],in[<span class="hljs-number">5</span>],in[<span class="hljs-number">6</span>],in[<span class="hljs-number">7</span>]&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="复制算子">复制算子</h2><h3 id="题目描述-7">题目描述</h3><p>复制算子是拼接算子的一种特殊情况，如<code>a=&#123;b,b,b,b,b,b&#125;</code>便可以写成<code>a=&#123;6&#123;b&#125;&#125;</code>的形式。复制算子的格式为：<code>&#123;num&#123;vector&#125;&#125;</code>，其中<code>num</code>必须为常量。如下所示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Verilog">&#123;<span class="hljs-number">5</span>&#123;<span class="hljs-number">1&#x27;b1</span>&#125;&#125; <span class="hljs-comment">// 5&#x27;b11111 (or 5&#x27;d31 or 5&#x27;h1f)</span><br>&#123;<span class="hljs-number">2</span>&#123;a,b,c&#125;&#125; <span class="hljs-comment">// The same as &#123;a,b,c,a,b,c&#125;</span><br>&#123;<span class="hljs-number">3&#x27;d5</span>, &#123;<span class="hljs-number">2</span>&#123;<span class="hljs-number">3&#x27;d6</span>&#125;&#125;&#125; <span class="hljs-comment">// 9&#x27;b101_110_110</span><br></code></pre></td></tr></table></figure><p>创建一verilog电路，将一个8bit位宽的输入信号进行符号位扩展，并通过32bit的输出端口输出，如下图所示</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102258111.png" /></p><h3 id="输入格式-7">输入格式</h3><p>8位in信号</p><h3 id="输出格式-7">输出格式</h3><p>32位out信号</p><h3 id="代码和解析-7">代码和解析</h3><p>关于复制算子，题目里已经说得很清楚了，照着写就行了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out <br>);<br>    <span class="hljs-keyword">assign</span> out = &#123;&#123;<span class="hljs-number">24</span>&#123;in[<span class="hljs-number">7</span>]&#125;&#125;,in&#125;;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="复制算子_2">复制算子_2</h2><h3 id="题目描述-8">题目描述</h3><p>创建一verilog电路，包含5个1bit输入，使所有输入两两进行同或（两bit相同时输出1，不同时输出0），并将结果通过25bit的向量信号输出，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102259350.png" /></p><h3 id="输入格式-8">输入格式</h3><p>1位的a,b,c,d,e</p><h3 id="输出格式-8">输出格式</h3><p>25位的out</p><h3 id="代码和解析-8">代码和解析</h3><p>使用复制算子实现该电路，可以大大减少代码量，提高编码效率。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a, b, c, d, e,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] out <br>);<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] mid_1;<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">24</span>:<span class="hljs-number">0</span>] mid_2;<br>    <span class="hljs-keyword">assign</span> mid_1=&#123;&#123;<span class="hljs-number">5</span>&#123;a&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;b&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;c&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;d&#125;&#125;,&#123;<span class="hljs-number">5</span>&#123;e&#125;&#125;&#125;;<br>    <span class="hljs-keyword">assign</span> mid_2=&#123;&#123;<span class="hljs-number">5</span>&#123;a,b,c,d,e&#125;&#125;&#125;;<br>    <span class="hljs-keyword">assign</span> out=~(mid_1 ^ mid_2);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="模块例化">模块例化</h2><h3 id="题目描述-9">题目描述</h3><p>通过前面一系列的练习，用户应当已经熟悉单个模块电路的设计了。对于功能上更复杂的电路模块，一般都是由若干子模块以及附加的功能电路构成的。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210102301840.png" /></p><p>在模块实例化过程中，被例化模块的端口信号是最重要的，用户甚至可以不知道模块的内部结构。上图展示了一个非常简单的包含有子模块电路的电路结构，在此电路中，创建模块mod_a的一个实例化，并将该实例化模块的三个端口（<code>in1</code>,<code>in2</code>,<code>out</code>）与顶层电路的三个端口(<code>a</code>,<code>b</code>,<code>out</code>)直接连接，其中<code>mod_a</code>模块的代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mod_a ( <span class="hljs-keyword">input</span> in1, <span class="hljs-keyword">input</span> in2, <span class="hljs-keyword">output</span> out );<br><span class="hljs-comment">// Module body</span><br><span class="hljs-keyword">assign</span> out = in1 &amp; in2; <span class="hljs-comment">//这只是一个简单的示例</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>模块实例化一般有两种语法格式，分别称为基于端口名称的实例化和基于端口位置的实例化。 基于位置的实例化和C语言中的函数调用类似（只是语法上类似，实际上该例化会产生实际的硬件电路），以上述<code>mod_a</code>模块的实例化为例，可以在上层模块中使用以下语句：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<span class="hljs-keyword">input</span> wa,<span class="hljs-keyword">input</span> wb,<span class="hljs-keyword">output</span> wc);<br>mod_a inst_name1(wa,wb,wc);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>其中<code>inst_name1</code>是<code>mod_a</code>模块的实例化名称，可以由用户自定义，通过这种例化方式，便实现了端口对应：<code>wa↔︎in1</code>, <code>wb↔︎in2</code>, <code>wc↔︎out</code>。 基于端口名称的实例化如下所示</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<span class="hljs-keyword">input</span> wa,<span class="hljs-keyword">input</span> wb,<span class="hljs-keyword">output</span> wc);<br>mod_a inst_name2(<br><span class="hljs-variable">.out</span>(wc),<br><span class="hljs-variable">.in1</span>(wa),<br><span class="hljs-variable">.in2</span>(wb));<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>本教程推荐用户使用基于端口名称的例化方式，因为这种方式编写的代码可读性更强。 试创建一verilog电路，并按照上图中所示实例化<code>mod_a</code>模块（建议使用基于端口名称的方式实例化）。</p><p>Hint:</p><ul><li>推荐使用基于端口名称的实例化方式</li><li>模块调用就像是一个树形的层次结构，不允许循环调用，如a调用b，b又调用a，也不允许模块调用自身，即模块c中又实例化模块c。</li><li>不允许在进程块（如always、initial等）或赋值语句（如assign语句）内进行模块实例化</li><li>模块的实例化名称可以自定义，如在同一模块中要对一个模块多次实例化，需要有不同的实例化名称。</li></ul><h3 id="输入格式-9">输入格式</h3><p>一位线网型变量a、b</p><h3 id="输出格式-9">输出格式</h3><p>一位线网型变量out</p><h3 id="代码和解析-9">代码和解析</h3><p>正如上一篇文章中所说，模块实例化可以类比为C语言里面的函数调用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">input</span> a,<br>  <span class="hljs-keyword">input</span> b,<br>  <span class="hljs-keyword">output</span> out<br>);<br>  <br><span class="hljs-comment">// 请用户在下方编辑代码</span><br><br>mod_a mod_a_inst(<span class="hljs-variable">.in1</span>(a),<span class="hljs-variable">.in2</span>(b),<span class="hljs-variable">.out</span>(out));<br><br><span class="hljs-comment">//用户编辑到此为止</span><br><span class="hljs-keyword">endmodule</span><br><br><br><span class="hljs-keyword">module</span> mod_a ( <br>  <span class="hljs-keyword">input</span> in1, <br>  <span class="hljs-keyword">input</span> in2, <br>  <span class="hljs-keyword">output</span> out <br>);<br><span class="hljs-keyword">assign</span> out = in1 &amp; in2;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20221003-20221009）</title>
    <link href="/2022/10/09/%E5%91%A8%E8%AE%B0-20221003-20221009/"/>
    <url>/2022/10/09/%E5%91%A8%E8%AE%B0-20221003-20221009/</url>
    
    <content type="html"><![CDATA[<p>这周是校历第六周。在本周，我的生活有些许改变。首先是学习了FPGA的Verilog开发的基本知识，基本上能独立刷题了，其次是开始以一个较高的频率在图书馆自习，最后是，能规律地安排每天的空闲时间。 周一，我和朋友一起去吃吉野家小火锅，然后她忘了做核酸了，我就陪她在海淀区找能24h核酸的医院。因为天气也降温了，我就想起之前的几个十一。19年的十一，我有很大一部分时间在图书馆学习，但是3号我从北京南站坐高铁去天津滨海新区站，听了幻奏；20年的十一，我也和车万群的群友们以及舍友们一起去听了幻奏华章。那时候我还和天津舍友说，下次去的时候，希望能多在天津待几天，而不是上午去下午回；21年的十一，本来幻奏是打算在北京办，也就不用去天津了，我去了IDO，看社团的朋友们在漫展的大舞台上演出，感觉很幸福，从IDO赶回宿舍以后，我迅速组装了刚到的电脑屏幕，然后和舍友一起看了上海幻奏的直播。总之前三年的十一，我基本都是在车万，具体来说是幻奏的陪伴下度过的。但是今年呢？我只想念两句古文：</p><blockquote><p>胜地不常，盛筵难再，兰亭已矣，梓泽丘墟。</p></blockquote><p>和</p><blockquote><p>向之所欣，俯仰之间，已为陈迹，犹不能不以之兴怀，况修短随化，终期于尽！</p></blockquote><p>那时的世界，万类竞发，生机勃勃，犹在眼前，短短三年过去，竟然一变而成为我的葬身之地了么？？另：吉野家小火锅挺好吃。</p><p>在学习方面，下一步，我要在每天醒来都对今天要做什么事情有一个比较明确的规划，这样的话效率会比较高。同时，应该认真规划一下两个科研项目的时间。电赛，说实话有点想摆了。</p><p>游戏方面继续玩赛博朋克，不过玩的少了一点。</p><p>继续读论中国，这个书很长，要读很久。</p><p>周日早上去海洋馆了，晚上又看了一遍凉宫春日的消失，依然很震撼。我看了不知道多少遍了，但是每看一遍就震撼一遍。</p><p>最近那个AI作图还挺火的。我朋友圈里面有支持的，也有反对的。有人说这是产业革命，这有可能是正确的。但就艺术来看，十九世纪末，照相技术的出现迫使艺术界走向了表现主义等现代主义风格，而不再以追求“像”为最高标准。在AI绘画的冲击下，下一个美学标准该如何定义？今后的艺术如何发展？百年未有之大变局，我非常的期待。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092337692.jpg" alt="可倒(导)不一定连续？" /><figcaption aria-hidden="true">可倒(导)不一定连续？</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092338021.jpg" alt="凉宫春日的消失" /><figcaption aria-hidden="true">凉宫春日的消失</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092338380.jpg" alt="图书馆" /><figcaption aria-hidden="true">图书馆</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210092338157.jpg" alt="花园鳗" /><figcaption aria-hidden="true">花园鳗</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vlab Verilog OJ 做题记录(1-10)</title>
    <link href="/2022/10/08/verilog1-10/"/>
    <url>/2022/10/08/verilog1-10/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="准备工作">准备工作</h2><ol type="1"><li><p>安装Vivado软件，VSCode软件，VSCode的Verilog插件</p></li><li><p>在环境变量中加入Vivado的XVlog，以便VSCode检查</p></li><li><p>在Vivado中新建一个project，除取名和选择路径以外一路Next即可。</p></li><li><p>来到了以下界面</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082304579.png" alt="image-20221008230354388" /><figcaption aria-hidden="true">image-20221008230354388</figcaption></figure><p>鼠标选择Constraints，点加号，在弹出的窗口中选择第二个选项，点Next，点Creat File新建一个文件，文件名最好是模块名。</p></li><li><p>点小齿轮（设置），点Text Editor，选择Custom Editor，输入<code>.../Microsoft VS Code/Code.exe -g [file name]</code>，点OK</p></li><li><p>先打开VSCode软件，再双击Vivado Sources/Design Sources里你刚刚新建的.v文件，弹出新VSCode窗口，于是可以开始写代码了。</p></li></ol><h2 id="输出1">输出1</h2><h3 id="题目描述">题目描述</h3><p>编写 Verilog 代码，使电路输出信号1</p><h3 id="输入格式">输入格式</h3><p>无输入</p><h3 id="输出格式">输出格式</h3><p>输出1，位宽为1</p><h3 id="代码和解析">代码和解析</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(out);<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>  <span class="hljs-keyword">assign</span> out = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这个题没什么好解析的，直接用<code>assign</code>赋值即可，主要熟悉基本的操作。Verilog的基本结构是模块，也就是这里面的<code>module</code>，一个模块代表一个功能单元。模块最基本的结构是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名称(端口列表);<br>    <span class="hljs-keyword">input</span> 数据类型(<span class="hljs-keyword">reg</span> 或 <span class="hljs-keyword">wire</span>) 输入端口表;<br>    <span class="hljs-keyword">output</span> 数据类型(<span class="hljs-keyword">reg</span> 或 <span class="hljs-keyword">wire</span>) 输出端口表;<br>    <span class="hljs-comment">//逻辑代码...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>上述的声明方法是Verilog-1995标准 风格，还有一种声明方法是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> 模块名 <span class="hljs-variable">#(参数声明1，参数声明2,...)</span><br>    (端口声明 端口<span class="hljs-number">1</span>，端口<span class="hljs-number">2</span>，...,<br>     端口声明 端口<span class="hljs-number">3</span>，端口<span class="hljs-number">4</span>,....);<br>    <span class="hljs-comment">//逻辑代码...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>以这种风格书写的本题代码是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>  <span class="hljs-keyword">output</span> out<br>);<br>  <span class="hljs-keyword">assign</span> out = <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="输出0">输出0</h2><p>把上题中的<code>1</code>变成<code>0</code>即可，略。</p><h2 id="wire">wire</h2><h3 id="题目描述-1">题目描述</h3><p>wire 是 Verilog 的关键字，用于表征信号类型的，其含义是线网。wire 可理解为物理连线，但又有所不同，因为 Verilog 中的 wire 是有方向的。例如设计一模块，模块名命名为 top_module，输入信号名为 in，输出信号名为 out，使 in 与 out 直连，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082321013.png" /></p><p>请使用 assign 语句将代码补充完整，使其实现上述电路图的功能。</p><h3 id="输入格式-1">输入格式</h3><p>任意</p><h3 id="输出格式-1">输出格式</h3><p>与输入完全相同</p><h3 id="代码和解析-1">代码和解析</h3><p>Verilog的变量有两种最基本的类型，即<code>wire</code>和<code>reg</code>，默认1位宽。</p><p><code>wire</code>如其名字所示，表示连线。驱动端信号的改变会立刻传递到输出的连线上。输入输出端口，如果不另行声明类型，都默认为`<code>wire</code>，如果使用<code>assign</code>的连续赋值语句，被赋值的变量都得是<code>wire</code>。</p><p><code>reg</code>的意思是寄存器，它能保持其值，直到它被赋于新的值。在行为建模中，在过程块(<code>always</code>块)中被赋值的变量必须是<code>reg</code>类型</p><p>还有其它类型，如整数、实数、比特矢量、数组，等用到了再说。</p><p>这个题的代码实现是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(in,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> in;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out = in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="多个端口的模块">多个端口的模块</h2><h3 id="题目描述-2">题目描述</h3><p>wire是Verilog的关键字，用于表征信号类型的，其含义是线网，wire可理解为物理连线，但又有所不同，因为verilog中的wire是有方向的，例如设计一模块，模块名命名为top_module，输入信号名为in，输出信号名为out，使in与out直连，如下图所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082332727.png" /></p><p>请使用assign语句将代码补充完整，使其实现上述电路图的功能</p><h3 id="输入格式-2">输入格式</h3><p>1 1 1</p><h3 id="输出格式-2">输出格式</h3><p>1 1 1 1</p><h3 id="代码和解析-2">代码和解析</h3><p>这题没啥解析的，和上一题差不多。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,c,w,x,y,z);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b,c;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> w,x,y,z;<br>    <span class="hljs-keyword">assign</span> w=a;<br>    <span class="hljs-keyword">assign</span> x=b;<br>    <span class="hljs-keyword">assign</span> y=b;<br>    <span class="hljs-keyword">assign</span> z=c;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h2 id="非门">非门</h2><h3 id="题目描述-3">题目描述</h3><p>创建一个名为top_module的Verilog模块，实现非门的功能</p><h3 id="输入格式-3">输入格式</h3><p>无</p><h3 id="输出格式-3">输出格式</h3><p>无</p><h3 id="代码和解析-3">代码和解析</h3><p>在这个题里，我们要介绍一下连续赋值。总的来说，Verilog里有两种赋值，叫做过程赋值和连续赋值。其中过程赋值主要在<code>initial</code>或<code>always</code>块中使用，我们也是到时候再说，先来说连续赋值。</p><p>连续赋值的格式是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> 被赋值量 = 值;<br></code></pre></td></tr></table></figure><p>其中被赋值量只能是<code>wire</code>型的，值的类型没有限制。</p><p>本题的代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> b;<br>    <span class="hljs-keyword">assign</span>  b = ~a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="与门">与门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082342033.png" /></p><p>和上一题差别不大</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=a&amp;b;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="或非门">或非门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082343150.png" /></p><p>和上一题的差别不大，或非的意思就是先或再非。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=~(a|b);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="同或门">同或门</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082344430.png" /></p><p>和上一题差别不大，同或的意思就是俩信号一样就是0，不一样就是1，也就是异或取反。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,out);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out;<br>    <span class="hljs-keyword">assign</span> out=~(a^b);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="线网型中间信号">线网型中间信号</h2><h3 id="题目描述-4">题目描述</h3><p>之前的verilog模块结构都比较简单，输出信号可直接用输入信号的逻辑表达式表示出来，模块功能稍微复杂时，一般都会用到中间信号，以下图为例，输入信号in经过两个非门后输出到out端口，为了在verilog模块中表示两个非门中间的这跟信号，需要将其定义为线网型（wire）信号，此处我们命名为not_in。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082345009.png" /></p><p>上述模块的verilog代码为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> in,<br>    <span class="hljs-keyword">output</span> out;<br>);<br>    <span class="hljs-keyword">wire</span> not_in;<br>    <br>    <span class="hljs-keyword">assign</span> out=~not_in;<br>    <span class="hljs-keyword">assign</span> not_in=~in;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>请根据上述示例，完成下图中电路所对应的Verilog模块</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210082346567.png" /></p><h3 id="输入格式-4">输入格式</h3><p>四个线网型变量a、b、c、d</p><h3 id="输出格式-4">输出格式</h3><p>两个线网型变量out、out_n</p><h3 id="代码和解析-4">代码和解析</h3><p>这个题属于稍微复杂一点的组合逻辑，需要用到中间变量。在做题以前，我们先观察一下他给我们的代码，里面有这么两句：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> out=~not_in;<br><span class="hljs-keyword">assign</span> not_in=~in;<br></code></pre></td></tr></table></figure><p>有同学可能就问了，按照逻辑，难道不应该是<code>not_in</code>先有值，然后<code>out</code>才有值吗？怎么能先给<code>out</code>赋值呢？这就是Verilog的一个特点，那就是并行赋值。你不要把这两个语句当成C语言，先执行上面的，再执行下面的，而是要当成图里面那个电路，输入信号来的时候，<code>not_in</code>和<code>out</code>有先后之分吗？忽略光速和元件延时的情况下，显然没有。</p><p>根据给出的图，我们很容易写出下面的代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(a,b,c,d,out,out_n);<br>    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> a,b,c,d;<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> out,out_n;<br>    <span class="hljs-keyword">wire</span> x,y;<br>    <span class="hljs-keyword">assign</span> x = (a&amp;b);<br>    <span class="hljs-keyword">assign</span> y = (c&amp;d);<br>    <span class="hljs-keyword">assign</span> out = x|y;<br>    <span class="hljs-keyword">assign</span> out_n=~(x|y);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>但是有个问题，就是我们不知道这个代码对不对。那么怎么知道我们的代码是怎么运行起来呢？在C语言里，我们一般是编译执行然后在控制台里输入一些数据，看输出是不是符合我们的期待。在Verilog中，我们也要给程序输入一些信号，看输出的信号是否符合我们的期待，但是这个过程比C语言的要复杂一些：我们还要再写一个Verilog代码，它叫做“testbench”。</p><p>首先我们回到Vivado软件，鼠标选择Constraints，点加号，在弹出的窗口中选择第<strong>三</strong>个选项，点Next，点Creat File新建一个文件，文件名最好是“模块名_tb”。这里的“tb”就是"testbench"的意思。然后，在Simulation Source里面就生产力testbench代码。</p><p>testbench代码的基本结构是这样的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> 模块名_tb;<br>   <span class="hljs-keyword">reg</span> 输入端口名<span class="hljs-number">1</span>,输入端口名<span class="hljs-number">2</span>,...;<br>   <span class="hljs-keyword">wire</span> 输出端口名<span class="hljs-number">1</span>，输出端口名<span class="hljs-number">2</span>，...;<br>   模块名 模块的示例名(.端口名<span class="hljs-number">1</span>(端口<span class="hljs-number">1</span>),.端口名<span class="hljs-number">2</span>(端口<span class="hljs-number">2</span>),...);<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>       输入端口<span class="hljs-number">1</span>=值<span class="hljs-number">1_1</span>;输入端口<span class="hljs-number">2</span>=值<span class="hljs-number">1_2</span>;...<br>       #<span class="hljs-number">50</span>;<br>       输入端口<span class="hljs-number">1</span>=值<span class="hljs-number">2_1</span>;输入端口<span class="hljs-number">2</span>=值<span class="hljs-number">2_2</span>;...<br>       #<span class="hljs-number">50</span>;<br>       ...<br>       输入端口<span class="hljs-number">1</span>=值n_1;输入端口<span class="hljs-number">2</span>=值n_2;...<br>       #<span class="hljs-number">50</span>;<br>       <span class="hljs-built_in">$stop</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这里面有几个我们之前没见过的东西。首先是第一行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br></code></pre></td></tr></table></figure><p>这个以反撇号开头的语句叫做编译指令，用于说明参考时间单位和仿真时间精度。</p><p>然后是第五行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">模块名 模块的示例名(.端口名<span class="hljs-number">1</span>(端口<span class="hljs-number">1</span>),.端口名<span class="hljs-number">2</span>(端口<span class="hljs-number">2</span>),...);<br></code></pre></td></tr></table></figure><p>这个叫做“例化”，可以类比C语言里面的“调用”。在C语言中，调用一个函数只能按顺序传参，但是在Verilog里，可以像这里一样端口命名法传递信号。</p><p>然后是第十行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">#<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>这个的意思是延时50个时间单位。</p><p>于是，我们可以写出这道题的testbench代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> top_module_tb;<br>   <span class="hljs-keyword">reg</span> a, b, c, d;<br>   <span class="hljs-keyword">wire</span> out, out_n;<br>   top_module ul(<span class="hljs-variable">.a</span>(a),<span class="hljs-variable">.b</span>(b),<span class="hljs-variable">.c</span>(c),<span class="hljs-variable">.d</span>(d),<span class="hljs-variable">.out</span>(out),<span class="hljs-variable">.out_n</span>(out_n));<br>   <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>      a=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;d=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">0</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">0</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">0</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">0</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      d=<span class="hljs-number">1</span>;c=<span class="hljs-number">1</span>;b=<span class="hljs-number">1</span>;a=<span class="hljs-number">1</span>;<br>      #<span class="hljs-number">50</span>;<br>      <span class="hljs-built_in">$stop</span>;<br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>呃，说实话，这个代码不是我写的，是我写的代码帮我写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入模块名称:&quot;</span>);<br><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入input信号个数：&quot;</span>);<br><span class="hljs-type">int</span> NumInput;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;NumInput);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;依次输入input信号名称：&quot;</span>);<br>string inputSign[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i) &#123;<br>cin &gt;&gt; inputSign[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入output信号个数：&quot;</span>);<br><span class="hljs-type">int</span> NumOutput;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;NumOutput);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;依次输入output信号名称：&quot;</span>);<br>string outputSign[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i) &#123;<br>cin &gt;&gt; outputSign[i];<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;`timescale 1ns / 1ps\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;module &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;_tb;\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;   reg &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i)&#123;<br>cout &lt;&lt; inputSign[i];<br><span class="hljs-keyword">if</span>(i!=NumInput) cout&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;;&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   wire &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i)&#123;<br>cout &lt;&lt; outputSign[i];<br><span class="hljs-keyword">if</span>(i!=NumOutput) cout&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;;&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; ul(&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumInput; ++i)<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; inputSign[i] &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; inputSign[i] &lt;&lt; <span class="hljs-string">&quot;),&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= NumOutput; ++i) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; outputSign[i] &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; outputSign[i] &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br><span class="hljs-keyword">if</span> (i != NumOutput) cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;);&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   initial begin&quot;</span> &lt;&lt; endl;<br><span class="hljs-type">int</span> pow2in = <span class="hljs-number">1</span> &lt;&lt; NumInput;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= pow2in<span class="hljs-number">-1</span>; ++i) &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;      &quot;</span>;<br><span class="hljs-type">int</span> temp = i, cnt = NumInput;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= NumInput; ++j)<br>cout &lt;&lt; inputSign[j] &lt;&lt; <span class="hljs-string">&quot;=0;&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span> (temp &amp;&amp; cnt&gt;=<span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; inputSign[cnt] &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; temp % <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;;&quot;</span>;<br>temp = temp / <span class="hljs-number">2</span>;<br>--cnt;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;=<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=cnt;j&gt;=<span class="hljs-number">1</span>;--j)&#123;<br>cout &lt;&lt; inputSign[j] &lt;&lt; <span class="hljs-string">&quot;=0;&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;      #50;&quot;</span>&lt;&lt;endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;      $stop;&quot;</span>&lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;   end&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;endmodule&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存文件，点这个</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210090004442.png" alt="image-20221009000446371" /><figcaption aria-hidden="true">image-20221009000446371</figcaption></figure><p>Vivado就产生了对应的波形：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210090005315.png" alt="image-20221009000506234" /><figcaption aria-hidden="true">image-20221009000506234</figcaption></figure><p>我们就能照着这个看自己写的对不对了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220926-20221002）</title>
    <link href="/2022/10/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220926-20221002%EF%BC%89/"/>
    <url>/2022/10/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220926-20221002%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本周是第五周，我主要受三种情绪控制，其一是对十一假期的期盼，其二是十一假期的欢乐，其三是对十一只放三天的怒火。</p><p>原神3.1更新了，还挺好玩的，不过我不太喜欢这种地下迷宫，尤其是没有地图的这种，要吐了，晕。另外最近把赛博朋克2077又捡起来了，继续玩。下一部打算玩ever17。</p><p>日本史快看完了，下一本书准备看《论中国》。</p><p>又去打了打羽毛球，感觉强度有点大，当然其实是我太菜了（悲伤）</p><p>又看了一遍利兹与青鸟，不得不说是真的好看。于是我把我的二次元锐评完善了一些，在考虑要不要发到公众号上。</p><p>王老师找我做项目来着，选C++还是py我还是有点犹豫。如果算上这个，我手里现在有3个科研方面的项目了，会不会太多了？总之先做做看吧。</p><p>舍友请我们吃鹤一烤肉，不得不说四道口店比中关村店还是差太多了。尤其是饮料和水果这方面来说。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210042319974.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220919-20220925）</title>
    <link href="/2022/09/20/%E5%91%A8%E8%AE%B0%EF%BC%8820220919-20220925%EF%BC%89/"/>
    <url>/2022/09/20/%E5%91%A8%E8%AE%B0%EF%BC%8820220919-20220925%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220918</h2><p>这个电子电路2真尼玛逆天，上了三周课我还不知道在讲什么玩意，烦人。</p><p>当了复变助教了，感觉事不太多，钱也不太多，还行吧。</p><p>好多群友都保研了，恭喜，焦虑。</p><h2 id="section-1">20220919</h2><p>今晚屁也没干，游戏游戏没玩，作业作业没写，动画动画没看，盯着sb科研数据看了一晚上也没看出来什么结果。</p><p>不过赛博朋克是真的很好看，这周内打算写一篇不太短的评论，放在那个二次元合集里。此外，我还打算把二次元合集里面的评论扩充一下，改天发到公众号上。</p><p>从今天起，没课的早上要八点起床，没课的下午要两点起床。</p><h2 id="周记">周记</h2><p>这周懒了，我感觉一周记一次也挺好，哈哈。</p><p>这周有点麻啊，主要是突然感觉事情太多了，我看看啊，一个车的大创，一个10月中旬的电赛（我还啥也不会），一个11月中旬的数学竞赛，还有演化博弈科研，课内学习的就不说了。事情堆在一起，容易玉玉。而且电赛那sb stm32f3discovery上网查了半天也没有点靠谱资料，更加玉玉。总而言之这周比较郁闷，其根源在于事情太多而自己的效率太低。好在是把夏日重现补完了，上了实变函数，和朋友大吃了两顿，stm32实现了流水灯和指南针，SPI加速度计就摆烂了，也就没那么玉玉了，行吧。</p><p>原神两天没打了，3.1快更新吧，我等不及了。</p><p>好多群友都爆炎了，我也想爆炎，还有那卓越工程师计划，那是什么东西？</p><p>专属导师和四个朋友一起选了王君臣，不错。就是可怜了那一个我们都不认识的同学，不知道撞见小团体团建作何感想（）</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220912-20220918）</title>
    <link href="/2022/09/12/%E5%91%A8%E8%AE%B0%EF%BC%8820220912-20220918%EF%BC%89/"/>
    <url>/2022/09/12/%E5%91%A8%E8%AE%B0%EF%BC%8820220912-20220918%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>大三上第三周。</p><span id="more"></span><h2 id="section">20220912</h2><p>今天是2022年全部假期的倒数第三天。开了个会，打了会游戏，看了会书，写了会作业。</p><h2 id="section-1">20220913</h2><p>今天搞了一下科研</p><h2 id="section-2">20220914</h2><p>最近有两部很期待的动画更新了，分别是赛博朋克和四叠半，我很开心。</p><p>最近生活正在慢慢步入正轨，线下上课也恢复了，也有东西可看了。以后要争取每天八点起床。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209142355137.png" alt="image-20220914235336619" /><figcaption aria-hidden="true">image-20220914235336619</figcaption></figure><h2 id="section-3">20220915</h2><p>今天吃了个早饭，以后每天都要吃早饭。</p><p>今天上了DSP，写了写慕课作业。</p><p>以后要多出去自习。</p><h2 id="section-4">20220916</h2><p>今天玩了一会儿赛博朋克2077.</p><h2 id="section-5">20220917</h2><p>今天我干了一件值得在博客日记上大书特书的乐事，那就是我把我暑假陪朋友在西安玩的游记，里面的“去了”，“去玩了”全改成“调研了”，然后当社会实践报告交了。我暑假去钟楼、城墙、小寨、大雁塔、同盛祥、长安大排档调研了，好辛苦啊。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220905-20220911）</title>
    <link href="/2022/09/05/%E5%91%A8%E8%AE%B0%EF%BC%8820220905-20220911%EF%BC%89/"/>
    <url>/2022/09/05/%E5%91%A8%E8%AE%B0%EF%BC%8820220905-20220911%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>大三上第二周。</p><span id="more"></span><h2 id="section">20220905</h2><p>今天周一，上了两节课，写了微波线上作业，和朋友吃了个饭，开心。</p><p>今天刷了一整绝缘套，一个也没出，生气。</p><h2 id="section-1">20220906</h2><p>今日无事。</p><h2 id="section-2">20220907</h2><p>今天把微波作业写了，而且还和朋友自习了喵</p><p>本来说下周要线下上课，我看又没戏了，我佛了。</p><h2 id="section-3">200220908</h2><p>别急，再撑一天就放假。</p><p>DSP没太听懂，幸亏有网课。我对网课这个事物真是又爱又恨。怎么说呢，网课在使得没有资源的同学们享受教育这方面，以及对于像我这种笨笨的老师讲课听不懂的人来说，是很好的。但是现在网课成为了有些老师折磨学生的工具，把考核弄得极其复杂，这就不好了。</p><h2 id="section-4">20220909</h2><p>放假咯！</p><p>一觉醒来，老佛爷👍已经👎了......</p><p>今天找同学买了一本日本史，可以看一看。</p><h2 id="section-5">20220910</h2><p>今天去三大家里玩了。一开始的小满只有那么大一点儿，现在已经长得挺大的了，时间真快。</p><h2 id="section-6">20220911</h2><p>今天和朋友一起吃了个安妮餐厅，意大利菜。一个凯撒沙拉，一个四季披萨，一个大份海鲜意面，一个苹果派，俩人202。</p><p>凯撒沙拉没什么可说的，里面放的那个咸肉口感非常的不错，味道有点像咸蛋黄，可推荐。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255795.jpg" alt="凯撒沙拉和送的餐前面包" /><figcaption aria-hidden="true">凯撒沙拉和送的餐前面包</figcaption></figure><p>四季披萨很好吃，一张饼上有火腿、酸菜、茄子、蘑菇四种料，都还不错，除了我自己不太喜欢吃酸菜以外。用的芝士相当不错。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255034.jpg" alt="四季披萨" /><figcaption aria-hidden="true">四季披萨</figcaption></figure><p>海鲜意面的味道很有特色。餐厅标注的是辣，但是吃起来其实并不辣，倒像是“辛”。就很明显不是辣椒的味儿，而像是某种草的味儿。意面口感不错，但是那个饼有点咸了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255783.jpg" alt="海鲜面" /><figcaption aria-hidden="true">海鲜面</figcaption></figure><p>苹果派属实不好吃，太甜了，不知道意大利人怎么吃的，也不怕得糖尿病。送的冰激凌不错，香草味的，应该是用了真香草。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209122255927.jpg" alt="苹果派" /><figcaption aria-hidden="true">苹果派</figcaption></figure><p>上面四张食物的图片都是朋友拍的。</p><p>吃完以后去了颐和园。在颐和园里面走的时候有点伤感，因为上次来颐和园还是2019年9月初，那时我还没有入学，北京勃勃生机，万类竞发，犹在眼前。我在群里和朋友玩画图红包，笑得不亦乐乎。三年过去了，世界和我们都改变了很多，甚至连画图红包都没有了，真是可叹。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220829-20220904）</title>
    <link href="/2022/08/30/%E5%91%A8%E8%AE%B0%EF%BC%8820220829-20220904%EF%BC%89/"/>
    <url>/2022/08/30/%E5%91%A8%E8%AE%B0%EF%BC%8820220829-20220904%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220829</h2><p>今天上了模电2和微波，网课，感觉不如线下</p><p>想想上次线下上课还是4月，等于说是你航一个五一节放到现在了，我且看还能放几天</p><p>今天做核酸时看到的牌子。不觉得这很酷吗？作为一名学生我觉得这太酷了，很符合我对未来生活的想象。艺术并带着趣味。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208302354739.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section-1">20220830</h2><p>今天上了数电和体育。</p><p>我要立下目标：从今天起直到写完，每天至少写500字我的小说。</p><h2 id="section-2">20220831</h2><p>呜，今天早上上课上着上着就睡过去了，以后要在底下上课了呜。</p><h2 id="section-3">20220901</h2><p>今天学习效率还是不太高，要好好反思，打起精神来。</p><p>今天准备开始记账。</p><p>其实我越来越感觉，不论对开发商还是对消费者来说，所谓的氪金抽卡确实是比高价买断更先进的游戏付费方式。对消费者来说，氪金抽卡游戏的价格完全是由消费者来决定的，也就是说我想付多少钱就付多少钱，想不付多少钱就不付多少钱，而不是一定要先付个一二百乃至四五百才能玩，否则连体验都不能体验。我不体验体验怎么知道游戏好不好玩呢？那可能有人说我在饭店吃饭不也是先付钱再吃饭的吗？但是我一定要吃饭，却不一定要玩游戏。</p><p>对开发商来说，一定有很多不理性而且有很多钱的人有巨额氪金的情况，其给开发商带来收入不一定比买断制要低。而且免费也大大降低了游戏的门槛。譬如说我现在也给某款游戏充了若干元，对我来说其带来的乐趣是可以cover掉这一点消费的，而如果要我一次性付清这些钱才能玩游戏，那么我大概是肯定不想付的。</p><p>现在这种付费方式的最大缺点就是采取这种先进方式的游戏质量整体来说太差，和其付费方式的先进程度不能匹配，导致缺乏游戏性，对其游戏本身的批判蔓延到了对其付费方式的批判上。假以时日，当有能力制作优秀游戏的开发商意识到了这一点时，这样的付费方式一定会大行其道的，而且其实现在以及有这样的趋势了，我们拭目以待。</p><h2 id="section-4">20220902</h2><p>今天效率提高了一点，至少写了点作业，明天要继续进步。</p><p>今天科幻世界到了，我明天去取。</p><p>我打算从昨天起，不定期但以较高频率地在周记中发表一些篇幅不长的论述，字数不超过1000字，目的是提升我的逻辑语言能力。所以在写这些论述时，我首先尽量不使用梗，其次尽量不使用类比。</p><p>【键政预警】</p><p>其实我越来越感觉，中华文明即将成为全地球人类的希望。</p><p>首先，从近两年美、欧的乱象来看，他们是指望不上的。他们总是在内耗、在内斗、在垂直切分，搞什么LGBT巴拉巴拉这种无意义的事情。一个SLS咕咕了几年了？从我上初中时就开始吹逼，到现在也没见发射；马斯克不是说要去火星吗？亏我在重型猎鹰发射的时候还吹了一波，现在也只知道往近地轨道倒垃圾了。之前想要拿碳排放遏制中国的发展，最后反而是自己先坚持不下去了。他们甚至连联合起来遏制中国都做不到，还指望他们能做什么呢？一个新冠病毒，全地球齐心协力早在两年前就遏制完了的东西，拖拖拖拖到22年，还妄图利用大自然拉着少数掌握着真理的社会陪葬，这样的图谋是痴心妄想的。指望美、欧社会带动全人类向前走，已经不可能了，他们不把地球拖入万丈深渊，就谢天谢地了。</p><p>其次，中华文明是世界上最后的无神论灯塔。先进的无神论和中国特色社会主义思想必将为社会的发展提供澎湃的动力，这里不展开了，将来有机会单开一段。</p><p>戈尔巴乔夫前几天死了。苏联在冷战中的教训告诉我们，在大国积重难返时，一旦开始伤筋动骨地改制，那么下一步就只有崩溃了。可是已经积重难返了，不改制也是会渐渐没落的。美国事实上已经失败了，其积重难返已经显而易见了，无论是特朗普，还是拜登上台，已经没有回头路了，最大的区别无非是迅速惨败，还是日薄西山，当然还有一种选择，那就是投降。你们现在已经到了山穷水尽的地步，不要再做无谓的牺牲了。我们现在要面对的，正是这头巨兽垂死前最后的挣扎。进几年的经济形势还会更不好，生活还会更苦一些。但是我相信，未来十几年甚至几十年一定会大大地变好的。希望等我死掉了的时候，可以把我的骨灰发射到太阳系之外，而且我希望这并不需要花太多钱，并不显著地比把我埋到地里贵多少。我对这里的希望能实现有九成的把握，当然前提是在那之前我不出意外，哈哈</p><p>道路是曲折的，前途是光明的。</p><h2 id="section-5">20220903</h2><p>今天白天上课。我就觉得离奇，明明我的课表那么空，偏偏给周六放一节课，脑子有病？</p><p>今天报了个复变助教，不知道要不要我，无所谓了，反正活少钱少。</p><p>今天看了雀斑公主，锐评发到二刺螈评价合集里了。</p><h2 id="section-6">20220904</h2><p>今天歇息，没干啥事。</p><p>今天晚上下了个大雨，太刺激了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220822-20220828）</title>
    <link href="/2022/08/24/%E5%91%A8%E8%AE%B0%EF%BC%8820220822-20220828%EF%BC%89/"/>
    <url>/2022/08/24/%E5%91%A8%E8%AE%B0%EF%BC%8820220822-20220828%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220822</h2><p>今天花20块钱拿到了新校园卡，还挺好看的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208250021563.jpeg" alt="听说是纪念皮肤" /><figcaption aria-hidden="true">听说是纪念皮肤</figcaption></figure><h2 id="section-1">20220823</h2><p>今天不得不控诉一下Word这个软件的难用，不如latex一根脚趾头，不如markdown一根腿毛。</p><h2 id="section-2">20220824</h2><p>今天继续控诉一下Word这个软件的难用，不如latex一根脚趾头，不如markdown一根腿毛。</p><p>今天早上抢必胜客原神套餐没抢上，气死我了。明明北影节都能抢上的。</p><p>今天进原神也进不去，更新了一下显卡驱动好了。</p><p>今天玩了一会儿原神3.0，还挺好玩的。</p><p>今天嗓子有点疼，应该不是冠了吧。</p><h2 id="section-3">20220825</h2><p>今天打了一天森林书，没打完</p><h2 id="section-4">20220826</h2><p>今天把森林书打完了，太震撼了</p><h2 id="section-5">20220827</h2><p>今天做了原神新主线，观感还是不错的，希望mhy再接再厉。</p><p>今天发现微波还要考试，真nm离谱，哪有还没开学就考试的</p><h2 id="section-6">20220828</h2><p>今天是暑假的最后一天，但是其实也不是，因为明天是上网课。从2022年5月1日起，北航就一直在上网课，我倒要看看能上到什么时候。</p><p>今天看了《教父》</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第12届北影节游记</title>
    <link href="/2022/08/22/12%E5%B1%8A%E5%8C%97%E5%BD%B1%E8%8A%82%E6%B8%B8%E8%AE%B0/"/>
    <url>/2022/08/22/12%E5%B1%8A%E5%8C%97%E5%BD%B1%E8%8A%82%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这两天看了三部电影，应该是我有生以来在电影院看电影最频繁的一段时间。</p><span id="more"></span><h2 id="首先评价一下这三座电影院">首先评价一下这三座电影院</h2><h3 id="红剧场">红剧场</h3><p>“红剧场”，原名叫做“北京崇文区工人文化宫大剧场”。在此之前，我曾和朋友一起去海淀区工人文化宫看过一场《波斯语课》，所以说看到电影院的气质感到有些亲切。总的来说就是比较质朴的气质，值得一提的是，这是我这辈子第一次在二楼看电影，体验比想象中要好，各位有兴趣可以尝试一下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035665.jpg" alt="红剧场外景" /><figcaption aria-hidden="true">红剧场外景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035759.jpg" alt="红剧场内景" /><figcaption aria-hidden="true">红剧场内景</figcaption></figure><h3 id="深影国际影城">深影国际影城</h3><p>很现代化的影院，座椅和设备什么的比红剧场好很多，装潢也很漂亮。值得一提的是，似乎是这座影院养活了它所在的“哇沃生活广场”，这个广场的一二层都是饭店，生意很一般，整个三层都是影院。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035634.jpg" alt="深影国际影城" /><figcaption aria-hidden="true">深影国际影城</figcaption></figure><h3 id="天幕新彩云国际影城">天幕新彩云国际影城</h3><p>在中央新影旁边的一个院子里，进放映厅不让带水。它的巨幕厅非常非常巨大且震撼，一定要体验一次。一个趣事是，之前我和朋友曾在此看过《指环王3王者归来》，但是当甘道夫点燃烽火台时，影厅着火了。可能是影厅自带4D功能吧（笑)</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220035294.jpg" alt="天幕新彩云" /><figcaption aria-hidden="true">天幕新彩云</figcaption></figure><h2 id="再来说一下这三部电影剧透预警">再来说一下这三部电影（剧透预警）</h2><h3 id="攻壳机动队">攻壳机动队</h3><figure><img src="https://lain.bgm.tv/pic/cover/l/53/9f/237_a8aEP.jpg" alt="GHOST IN THE SHELL / 攻殻機動隊 攻壳机动队" /><figcaption aria-hidden="true">GHOST IN THE SHELL / 攻殻機動隊 攻壳机动队</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220037972.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：90</p><p>关键字：哲学、科幻、赛博朋克</p><p>锐评：《攻壳机动队》，押井守导演，1995年首映。影片风格朦胧，节奏工整饱满，平衡统一。科幻构想和哲学思考作为一部27年前的电影相当前卫。</p><h3 id="峠qiǎ-最后的武士">峠(qiǎ) 最后的武士</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182351048.jpeg" alt="峠 最后的武士" /><figcaption aria-hidden="true">峠 最后的武士</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220039035.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：84</p><p>关键字：复古、时代、剑戟</p><p>锐评：本来刚看完的时候我给它了非常高的评价，现在回想了以后还是适当下调了一点。在剧中，役所广司饰演的主角是一个思想开阔的和平主义者，但在历史的剧变中被困在了最后一个武士的躯壳里。一个思想先进的人，因为要坚守忠义，被迫守卫行将就木的秩序。整部电影的节奏是庄严肃穆的时代感，正如刘慈欣所说“时间静默地切开一切”，而我们只能看着主角在时代的剧变中一步步走向自己的悲剧。影片中也有温馨的“闲笔”，例如八音盒以及舞蹈情节，调剂了肃穆的基调。役所广司的表演相当精彩，没得说。本片的缺点在于：运镜上世纪五六十年代那味儿太重了，有点刻意了；而且对战争场面的刻画并不尽如人意；没有特别好地展现主角的国际视野和和平主义精神，只是由主角的嘴说出，并没有太多的行为等其它侧面来刻画。不过瑕不掩瑜，值得一看！</p><h3 id="平家物语-犬王">平家物语 犬王</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220040886.jpeg" alt="犬王" /><figcaption aria-hidden="true">犬王</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208220040966.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><p>个人评分：89</p><p>关键字：表现主义、音乐、live、汤浅政明</p><p>锐评：汤浅政明导演。汤浅政明是现代动画总最具想象力和无拘束的监督之一，这部作品和他之前的作品，例如《春宵苦短，少女前进吧！》一样，深具表现主义风格。影片中live场景很多，演出极具张力，在电影院看非常震撼。故事很简单，基调有些悲戚苍凉。用琵琶演奏出电吉他音色很神奇。另外，这是这三部电影里唯一有特典的一部。希望别的电影也能有点特典233333</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电影</tag>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220815-20220821）</title>
    <link href="/2022/08/18/%E5%91%A8%E8%AE%B0%EF%BC%8820220815-20220821%EF%BC%89/"/>
    <url>/2022/08/18/%E5%91%A8%E8%AE%B0%EF%BC%8820220815-20220821%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220815</h2><p>今天我爸开会去了，我就是自己玩。</p><p>首先去了这个啤酒博物馆</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181052168.jpg" alt="啤酒博物馆" /><figcaption aria-hidden="true">啤酒博物馆</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181005625.jpg" alt="啤酒博物馆门口的街道" /><figcaption aria-hidden="true">啤酒博物馆门口的街道</figcaption></figure><p>啤酒博物馆主要介绍青岛啤酒的历史和啤酒的制作方法，还送给我了两杯酒。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181005347.jpg" alt="当日原浆" /><figcaption aria-hidden="true">当日原浆</figcaption></figure><p>挺好喝的其实。但是我自己酒量太小，两杯就喝的有点晕了。</p><p>去完博物馆本来准备逛中山路的，但是中山路在施工，遗憾。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181006716.jpg" alt="施工中的中山路" /><figcaption aria-hidden="true">施工中的中山路</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181007966.jpg" alt="一个模型漫画商店" /><figcaption aria-hidden="true">一个模型漫画商店</figcaption></figure><p>从中山路走到天主教堂，中间有很多街边的小超市，都在卖散装啤酒。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181007027.jpg" alt="散装啤酒" /><figcaption aria-hidden="true">散装啤酒</figcaption></figure><p>因为之前已经喝了两杯了，我怕我醉了， 就买了一斤果啤，葡萄味的，以前没喝过。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181008944.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这是天主教堂，周围有很多现充。首先说明，我不是现充，你见过哪个现充一个人在街上逛游的？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181007790.jpg" alt="天主教堂" /><figcaption aria-hidden="true">天主教堂</figcaption></figure><p>旁边的那个什么青岛名建筑展览挺坑人的，都是沙盘，还有一堆卖东西的。</p><p>从天主教堂出来以后走去栈桥。在栈桥上正走着呢突然下雨了，下得还特别地大。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181010433.jpg" alt="栈桥" /><figcaption aria-hidden="true">栈桥</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181011640.jpg" alt="从栈桥拍大雨中的青岛天际线" /><figcaption aria-hidden="true">从栈桥拍大雨中的青岛天际线</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181012884.jpg" alt="大雨中在海上游泳的人" /><figcaption aria-hidden="true">大雨中在海上游泳的人</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181012246.jpg" alt="雨停了以后的青岛天际线" /><figcaption aria-hidden="true">雨停了以后的青岛天际线</figcaption></figure><p>然后坐地铁去大学路，听说这是个网红路。<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181052162.jpg" alt="大学路" /></p><p>为什么要叫大学路呢？是因为旁边是中国海洋大学吗？那知春路能不能改名为北航路啊</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181015059.jpg" alt="网红墙和给网红墙拍照的人" /><figcaption aria-hidden="true">网红墙和给网红墙拍照的人</figcaption></figure><p>我就知道一沾上网红准没好事。</p><p>晚上没干啥事情，喝了个崂山白花蛇草水。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181016351.jpg" alt="白花蛇草水" /><figcaption aria-hidden="true">白花蛇草水</figcaption></figure><p>这玩意是什么味儿呢？有人说是“烂茄子味”，我感觉是在海水里泡发霉了的凉席的味。</p><h2 id="section-1">20220816</h2><p>今天一大早起来发现北京健康宝弹窗了，举办了一下，一个小时以后又好了，很神奇，也有点慌。</p><p>早上九点去海军博物馆。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181021957.jpg" alt="去海军博物馆路上见到的喵喵" /><figcaption aria-hidden="true">去海军博物馆路上见到的喵喵</figcaption></figure><p>说来惭愧，其实我买的黄牛票，不过只有30块钱，完全值回票价，也算行吧。就是我到现场发现即使网上没票了也能现场约，但是一看就现场人那么多感觉还是买票好。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181020971.jpg" alt="海军博物馆" /><figcaption aria-hidden="true">海军博物馆</figcaption></figure><p>这地方人相当的不少。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181022057.jpg" alt="领导人题词" /><figcaption aria-hidden="true">领导人题词</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181022200.jpg" alt="军舰" /><figcaption aria-hidden="true">军舰</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181022459.jpg" alt="舰炮" /><figcaption aria-hidden="true">舰炮</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181023043.jpg" alt="舰载机" /><figcaption aria-hidden="true">舰载机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181023371.jpg" alt="纪念碑" /><figcaption aria-hidden="true">纪念碑</figcaption></figure><p>在军博转了一个早上，因为东西真的很多。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181026237.jpg" alt="海军博物馆的椅子" /><figcaption aria-hidden="true">海军博物馆的椅子</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181026762.jpg" alt="大小错落有致的阀门，有一种艺术感" /><figcaption aria-hidden="true">大小错落有致的阀门，有一种艺术感</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181026267.jpg" alt="军舰" /><figcaption aria-hidden="true">军舰</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181027246.jpg" alt="导弹" /><figcaption aria-hidden="true">导弹</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181027202.jpg" alt="战斗机" /><figcaption aria-hidden="true">战斗机</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181027806.jpg" alt="从军舰上看栈桥" /><figcaption aria-hidden="true">从军舰上看栈桥</figcaption></figure><p>本来还说去海底世界sakana的，结果人实在是太多了，算了，下次再sakana。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181028528.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>下午我爸会开完了，我们一起去了小鱼山公园，这个公园主要是爬山看观景台，能把青岛各大景点一览无余，非常推荐。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181029802.jpg" alt="从小鱼山看八大关" /><figcaption aria-hidden="true">从小鱼山看八大关</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181032263.jpg" alt="从小鱼山看栈桥" /><figcaption aria-hidden="true">从小鱼山看栈桥</figcaption></figure><p>然后坐隧道公交车去了金沙滩。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181032845.jpg" alt="这是一个剧院" /><figcaption aria-hidden="true">这是一个剧院</figcaption></figure><p>金沙滩的沙子很细，挺好看的，有很多游泳的人。</p><p>晚上吃了个海鲜大品牌，俩大老爷们没吃完，50块钱，牛得很。</p><h2 id="section-2">20220817</h2><p>圣诞节快乐！</p><p>今天从青岛启程去北京。一路上有惊无险，终于顺利抵达了北京。</p><p>到了北京并没有直接回学校，而是先去了北京国际电影节。</p><p>是和朋友一起看的《攻壳机动队 ghost in the shell》。相当具有哲思，需要注意的是这是一部27年前的电影。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181034263.jpg" alt="电影票" /><figcaption aria-hidden="true">电影票</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181036464.jpg" alt="红剧场" /><figcaption aria-hidden="true">红剧场</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181036651.jpg" alt="北影" /><figcaption aria-hidden="true">北影</figcaption></figure><p>顺便一提，这是我这辈子第一次在二楼看电影。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181037794.jpg" alt="二层" /><figcaption aria-hidden="true">二层</figcaption></figure><p>回宿舍以后宿舍变阿富汗了，逆天。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181048353.jpg" alt="宿舍" /><figcaption aria-hidden="true">宿舍</figcaption></figure><h2 id="section-3">20220818</h2><p>今天早上维护了一下博客，下午做了核酸，晚上又看了一场电影。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182350300.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这个小徽章是填一个调查问卷送的，北影主题的，挺好看的。</p><p>这部电影不是二次元，我就把影评写在这里了：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208182351048.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>个人评分：84</p><p>关键字：复古、时代、剑戟</p><p>锐评：本来刚看完的时候我给它了非常高的评价，现在回想了以后还是适当下调了一点。在剧中，役所广司饰演的主角是一个思想开阔的和平主义者，但在历史的剧变中被困在了最后一个武士的躯壳里。一个思想先进的人，因为要坚守忠义，被迫守卫行将就木的秩序。整部电影的节奏是庄严肃穆的时代感，正如刘慈欣所说“时间静默地切开一切”，而我们只能看着主角在时代的剧变中一步步走向自己的悲剧。影片中也有温馨的“闲笔”，例如八音盒以及舞蹈情节，调剂了肃穆的基调。役所广司的表演相当精彩，没得说。本片的缺点在于：运镜上世纪五六十年代那味儿太重了，有点刻意了；而且对战争场面的刻画并不尽如人意；没有特别好地展现主角的国际视野和和平主义精神，只是由主角的嘴说出，并没有太多的行为等其它侧面来刻画。不过瑕不掩瑜，值得一看！</p><h2 id="section-4">20220819</h2><blockquote><p>苏联公民们：</p><p>在我们祖国和我国各族人民命运面临严峻危急的时刻，我们向你们发出呼吁！我们伟大的祖国面临致命的危险！由戈尔巴乔夫发起并开始的改革政策，原想作为保障国家迅速发展和使社会生活民主化的手段，却因种种原因已走入死胡同。失去信仰、冷漠和绝望取代了最初的热情和希望。各级政权失去了居民的信任。在社会生活中，玩弄权术取代了对国家和公民命运的关心。对国家各级机构进行恶毒的嘲弄。整个国家实际上已失去控制。</p></blockquote><p>咳咳，跑题了。</p><p>今天有一个伟大的发现，就是冰杯真是个神奇的东西。</p><h2 id="section-5">20220820</h2><p>今天辅导员说西安人赞不返校。我越来越觉得我能返校真是个奇迹。</p><p>记一次和冠神赛跑：</p><p>我一开始是准备20几号返校，但是发现有个北京国际电影节，于是决定17号返校。到了13号决定去先青岛玩，再从青岛直接返校。这时候西安只有2个确诊，还在雁塔区。到了16号了突然感觉火车票太早了，想改签一下，就发现健康宝弹窗了，然后我就申诉了一下，就把弹窗解了。然而当天下午西安就出了几个高风险区，也就是如果我没及时发现弹窗，很可能就没那么容易解了。我17号一大早早上六点多就坐火车去北京，11点到了北京，然后先去看了北影节再去学校。前脚刚进学校没有几个小时，长安区就出了确诊。也就是如果我没去青岛，如果16号没想着改签一下，等等，都有可能回不来了。而现在我在宿舍写下这段记叙，心有余悸。</p><h2 id="section-6">20220821</h2><p>今天看了犬王，太爽了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220808-20220814）</title>
    <link href="/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220808-20220814%EF%BC%89/"/>
    <url>/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220808-20220814%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220808</h2><p>今天北影节的片单出了，我想看教父、攻壳机动队和平家物语。</p><p>今天是世界猫咪日，喵喵~</p><h2 id="section-1">20220809</h2><p>今天深感自己文学功底的浅陋，哎！</p><p>今天我爸说他要去青岛出差，可以带我去。我明天查一查青岛有什么。</p><p>今天细田守的雀斑公主定档了，可以和群友一起看，喵呜。</p><p>今天出了一档子逆天的事，什么不让老师加群什么的，纯粹的脑弹了属于是</p><h2 id="section-2">20220810</h2><p>今天继续写了小说，不过还没更新</p><p>今天继续看了大秦帝国</p><h2 id="section-3">20220811</h2><p>今天继续写了小说，不过还没更新</p><p>今天继续看了大秦帝国</p><p>今天做了个西红柿炒鸡蛋吃，好吃</p><h2 id="section-4">20220812</h2><p>今天和高中朋友date了捏</p><h2 id="section-5">20220813</h2><p>今天主要是收拾东西。其实我真的不想带那么多衣服，学校里衣服就很多了已经。</p><h2 id="section-6">20220814</h2><p>今天从西安去青岛了。</p><p>做的飞机是东航的天合联盟的涂装机，小惊喜</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180954989.jpg" alt="座机" /><figcaption aria-hidden="true">座机</figcaption></figure><p>青岛有个新冠路，相当的震撼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180953922.jpg" alt="“新冠高架路”中的“新”和“冠”,是新疆路和冠县路的首字组合体。" /><figcaption aria-hidden="true">“<em>新冠高架路</em>”中的“新”和“冠”,是新疆路和冠县路的首字组合体。</figcaption></figure><p>下午去了八大关景区。青岛很神奇，它的路都是以别的地方的名字来命名的，比如“八大关”就均以中国古代军事关隘命名，包括纵向连接香港西路的紫荆关路、宁武关路和韶关路，以及横向交织的武胜关路、嘉峪关路、函谷关路、正阳关路、临淮关路、居庸关路和山海关路。八大关最让我震撼的就是这个浮在半空中的雾，这是暖湿空气平流到较冷的下垫面上，下部冷却而形成的雾，叫做平流雾。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180957121.jpg" alt="平流雾" /><figcaption aria-hidden="true">平流雾</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208180958568.jpg" alt="从八大关看海" /><figcaption aria-hidden="true">从八大关看海</figcaption></figure><p>晚上去了奥帆中心和五四广场，据说是青岛夜景最漂亮的地方，过去一看确实挺震撼。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181001106.jpg" alt="奥帆中心的青岛会议中心" /><figcaption aria-hidden="true">奥帆中心的青岛会议中心</figcaption></figure><p>这个会议中心真的好漂亮，大悬挑大屋顶，大气磅礴。好看！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181001357.jpg" alt="青岛夜景" /><figcaption aria-hidden="true">青岛夜景</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208181002688.jpg" alt="五四广场" /><figcaption aria-hidden="true">五四广场</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220801-20220807）</title>
    <link href="/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220801-20220807%EF%BC%89/"/>
    <url>/2022/08/09/%E5%91%A8%E8%AE%B0%EF%BC%8820220801-20220807%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220801</h2><p>建军节，补记的，忘了。</p><h2 id="section-1">20220802</h2><p>今天去户县练了一天车，明天考科目三。</p><h2 id="section-2">20220803</h2><p>考个科目三真尼玛一波三折，早上去了先是没车，等到中午再去，然后又让等着。第一圈的时候开到一半下了场暴雨，安全员给踩了，又等了好久，第二圈才过，等回到家就九点了。</p><p>另：今天是我的生日，但年度总结咕了，过两天补。</p><h2 id="section-3">20220804</h2><p>今天复习（预习）科目四。</p><h2 id="section-4">20220805</h2><p>今天考过了科目四，但是那地方的打印机坏了，让我写个地址把证邮寄过去。下午见了一个同学，一起逛了西工大地铁站、大唐西市和高新区。不得不说北航输麻了。</p><h2 id="section-5">20220806</h2><p>今天看了一天大秦帝国。</p><h2 id="section-6">20220807</h2><p>今天早上去练车，中文吃水盆羊肉，下午睡觉。</p><p>水盆羊肉好吃，带的烧饼更好吃，有股面香味，鉴定为彳亍。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高中记忆拾贝</title>
    <link href="/2022/07/26/%E9%AB%98%E4%B8%AD%E8%AE%B0%E5%BF%86%E6%8B%BE%E8%B4%9D/"/>
    <url>/2022/07/26/%E9%AB%98%E4%B8%AD%E8%AE%B0%E5%BF%86%E6%8B%BE%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>转载自个人公众号。</p><span id="more"></span><h2 id="高三">高三</h2><p>说起高考，我对高考，或者“高三”的记忆是什么呢？两年过去了，如果让我说起我对高三的TOP印象（不分顺序），可能会有如下几个场景：</p><ol type="1"><li><p>第一节晚自习下课，和基友一起在操场散步，谈论二次元。他给我口述动画片，不得不说确实挺好看。操场上灯光并不是很亮，我俩就看着像月亮一样的灯光绕着走圈圈。后来我给他送了这个动画片的原作。</p></li><li><p>高三唯一一次哭，是因为理化生三科改理综以后我突然之间就获得了很大很大的优势（因为我自己写字比较快，能答完。好多大佬不会安排时间，第一次没答完题）。然后理综练得越来越多，大家越来越熟练，我的优势突然之间就没有那么大了，就突然慌了，然后当时杂乱的事情又比较多，就一下子就崩溃了，不过好得也很快。后来一看，这算啥事儿啊2333.</p></li><li><p>模考不想去了，直接给老师发个短信说不想去了，然后和父母看电影，散步，逛公园。爽。</p></li><li><p>每次模考完了以后，成绩当晚就出了。老师就拿着那张排名单往教室后面一贴，大家都怀着忐忑的心情一拥而上。</p></li><li><p>五楼考场，阳光明媚，闭着眼睛吹风，很舒服。不过我每次在五楼都发挥得不是很好，不知道为啥。</p></li><li><p>5月12日，放假。我写了一张大表安排时间，把座位搬到了落地窗前，“悠然见南山”，真的是终南山噢！然后严格按照这张大表复习，效果真的特别特别好。爸爸的厨艺在这一个月也增长很多。非常快乐，非常好。</p></li><li><p>和同桌一起体育课在操场打羽毛球。我们每次体育课都打球，其他人好多都拿个小本本在卷，不过他们都卷不过我俩 哈哈哈哈。</p></li></ol><p>啊，想不起来，就这些吧。我曾经问过我那个基友和那个同桌“你觉得高三生活是‘地狱’吗？”，他们都斩钉截铁地回答，不是。没有什么拼搏的汗水，没有什么崩溃的泪水，没有动员会上的热泪盈眶，没有什么地狱般的生活，普普通通地过完了，拿到了自己最期望的高考成绩，不多不低。网上人说的那些，纪录片、电视剧里说的那些东西一个都没出现。没什么实感就结束了。</p><p>整个高三一年，我根本没有什么“熬夜学习到凌晨两三点”，“拼命学习”，“刷完了多少本题”，“追着老师问问题”，“用完了多少笔芯”之类的“拼搏”的经历;也没有做到“杜绝一切娱乐”,基本上每天都能玩到手机（家长不太管），我高三甚至看完了一套凉宫春日小说，补了三四部番，还听了很多音乐（主要是东方吧）。甚至在6月6日晚上，我也是照常看了2集动画片（我还记得，是少女歌剧）然后平常地睡觉了。总之，整个高三，我就是平平常常的，老师说什么，我就干什么，基本上就是完成作业，额外做的题特别少。学校要求6：50到校，我基本6：45到；23：30放学我基本上不会拖超过5分钟。</p><p>太平淡了，啥也没有，就这样结束了。</p><p>所以我才会关注高考新闻，想凭吊一下青春吧，哈哈哈哈。</p><h2 id="高一高二">高一高二</h2><p>上次写了高三，这次就来写写我的高一和高二。说实话，高一和高二的生活，真的比高三有意思很多。如果要找“ Gauss 节点”的话，大概有这么几个节点：</p><ol type="1"><li><p>高一的朗诵比赛，我们选的是《长恨歌》，不得不说效果是真的非常非常好啊，尤其是那位女同学“迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共？”的时候，真的，都差点哭出来了。虽然最后得的奖不是很高（现在想起来也有点生气，made),但是算是高中三年生活的一个很好的开始吧。</p></li><li><p>然后就开始学电竞，刷OJ。之所以学电竞是被朋友撺掇的，当时电脑课老师问有没有学电竞的，他先举手，然后又把我的手举起来了，于是就开始学电竞。我高中三年最正确的选择之一，居然是别人替我作出的，哈哈哈哈。</p></li><li><p>第一次月考，考完运动会。班主任是位生物老师，她把我拉去帮忙改卷子了。之后我的生物一直学得非常好，或许应该好好感谢她。</p></li><li><p>电竞上课要上到很晚，有一次我们练习完了以后，整个教学楼全黑了，好几扇门也锁起来了。我们转了几圈终于出去了，哈哈大笑。</p></li><li><p>我的经历就是到了这个高一结束，竞赛课内两开花，成绩都挺好。然后班主任就把我调到竞赛班去了。我说另请高明吧，我实在我也不是谦虚，她说别的老师已经把你夸上天了，我就念了两句诗，叫：“...”（其实没念）。我实在是不觉得这个竞赛班是个好东西，一开始我们开了个班会，常务副校长同志语出惊人：“你们难道来高新一中就是为了上个西交吗？”，一下子给我整麻了。后来发现这竞赛班tm真不是人待的地方，整个物理“动量”部分就讲了十分钟，然后就发一堆难度巨大的题让做，我哪里会做，然后就啥也没学会。期中考试考了个全年级四百多名，洗澡的时候在浴室哭了一场，”心之壁“ DEF+5000。然后就爬回了一个“重点班”（高新一中有三级班：平行班、重点班、竞赛班）。于是我就刷到了一个成就：在高一一年，遍历高新一中的所有级别班次，听过所有理科老师的课程。</p></li><li><p>竞赛班没有作业，也不学文科。但是到了重点班突然要考文科，我直接发动【高速制作】，期末的文科三科考了285分，超高吧，嘻嘻。</p></li><li><p>高二我就来到了四班，其实我还是很喜欢四班的，在这里认识了几个好朋友。不过我的高二生活的前半段主要是在学竞赛，就在那个三楼的《网络实验室》里，做题，刷题，讲题，中午就听音乐，直到很晚才回家。第一次吃了学校的晚饭，挺难吃的。假期上课的时候就和同学们一起过马路吃肉夹馍。这段时光确实非常的快乐，肆意吮吸知识的感觉，非常非常的爽。也认识了好朋友，直到现在都是好朋友。但是做题就是另一回事儿了哈哈哈哈哈。看了珂朵莉，很好看。</p></li><li><p>高二暑假的时候非常非常的热。那时候有个梗图，说西安地表温度65度，吐鲁番63度。每天下午，我们要从高新一中走到初中部去上课，哈哈哈。</p></li><li><p>2017年11月11日，我永远记得。D1T1当场把我送走。当天中午心态基本就崩溃了。D2发挥的比D1好，但是也无济于事。然后就心态很崩嘛，当时刚好看完了珂朵莉，那心情，哎，你懂吧又哭了几场。也很感谢家长，和竞赛的队友，和班里的同学能及时把我拉起来，”心之壁“DEF +10000.</p><p>然后七天以后就是期中考试，理所应当地考了倒数。不过值得吹一下的是，生物还是仅仅用学过了的知识依然拿到了全班前十。</p></li><li><p>凉宫春日是我永远的光。我永远爱凉宫春日。没有凉宫春日就没有现在的我。虽然主要还是我自己努力的原因，如果说父母同学输入的是活化能，那么她就是大大降低了活化能的催化剂。一个月学完一个学期所有科目，从倒数第一拿到全班前十，奇迹的复活！</p></li></ol><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207262350119.jpeg" alt="奇迹の复活" /><figcaption aria-hidden="true">奇迹の复活</figcaption></figure><ol start="11" type="1"><li><p>高二下的一开始就是学考。学考组织了四次模拟，如果政史地理化生中任意一个科目考的分不是很高，就要《补习》。但是我一次都没《补习》。甚至历史还进入过全校前十，整得文科班老师对着他们班大发雷霆：你们就连个理科生都考不过吗？</p></li><li><p>高一高二的时候我们组织了研学旅行，分别是去了关中民俗博物院、白鹿原、华清池，一个我忘了名字的红色景点，和一个我忘了名字的山水景点等，还是很快乐的。</p></li><li><p>有一天早上起来发现下了大雪，学校停课了，于是直接去看了《星球大战》的电影。</p></li><li><p>暑假，入坑了东方。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220725-20220731）</title>
    <link href="/2022/07/26/%E5%91%A8%E8%AE%B0%EF%BC%8820220725-20220731%EF%BC%89/"/>
    <url>/2022/07/26/%E5%91%A8%E8%AE%B0%EF%BC%8820220725-20220731%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220725</h2><p>今天没做什么事，打游戏，看书，写代码，读论文等。</p><h2 id="section-1">20220726</h2><p>今天开了个组会，我竟然还“进度挺快”，震撼。</p><p>北航地方，历代大规模开学几十余次，是非曲折难以论说，但史家无不注意到，正是在这个大学，决定了多少代人生的盛衰兴亡、此兴彼落。</p><p>二〇二〇年十月，也正是在北航城郊，我有幸亲率数十健儿前去天津游玩，大获全胜！</p><p>我不明白，为什么大家都在谈论着“申请出校”，仿佛这大学对我们决定了凶多吉少。二〇一九年，我从西安踏上征途，开始了大学生活，老师学长竭诚欢迎，真可谓占尽天时，那种勃勃生机、万物竟发的境界，犹在眼前。短短三年之后，这里竟至于一变而成为我们的葬身之地了么？</p><h2 id="section-2">20220727</h2><p>今天玩了一天，一点也没学习。</p><h2 id="section-3">20220728</h2><p>今天终于开始动笔写我的小说了（）先完善一下大纲，预计下周起在本站上连载，不知道能写多少。</p><h2 id="section-4">20220729</h2><p>今天继续打游戏，看书，写小说大纲</p><h2 id="section-5">20220730</h2><p>今天去看了一个浮世绘画展，还挺不错的。曲江创意谷也不错。</p><p>今天晚上吃了烤肉。</p><h2 id="section-6">20220731</h2><p>今天下午停电了，去电影院避暑，看了《独行月球》，还不错，能打75/100分。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220718-20220724）</title>
    <link href="/2022/07/19/%E5%91%A8%E8%AE%B0%EF%BC%8820220718-20220724%EF%BC%89/"/>
    <url>/2022/07/19/%E5%91%A8%E8%AE%B0%EF%BC%8820220718-20220724%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="section">20220718</h2><p>今天朋友来家里玩了，晚上去昆明池看了看夜景，可惜有点下雨。</p><p>今天看了规则网络上的博弈，还读懂了代码。明天复现一下。</p><p>今天是京阿尼纵火事件三周年。</p><blockquote><p>夢を、育てます（培育梦想）</p><p>夢を、描きます（描绘梦想）</p><p>夢を、届けたい（想要传递梦想）</p><p>発想する会社。</p></blockquote><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207191023641.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section-1">20220719</h2><p>今天主要是写了一下规则网络PDG的代码，玩了一下原神新活动，感觉还是挺好玩的。</p><h2 id="section-2">20220720</h2><p>无语，今天扁桃体发炎了，去医院打了一晚上吊针，难顶</p><h2 id="section-3">20220721</h2><p>今天跑了一下和自己博弈的PDG，以及改成了雪堆博弈的。</p><p>今天玩了猫猫模拟器，还挺好玩的。</p><p>今天读了《故事》，</p><h2 id="section-4">20220722</h2><p>今天白天下了一天雨，下午天晴了，去昆明池了。今天的昆明池还是非常好看的，能见度非常高，而且还有很多喵喵。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242157635.jpg" alt="云销雨霁，彩彻区明" /><figcaption aria-hidden="true">云销雨霁，彩彻区明</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242157514.jpg" alt="潦水尽而寒潭清,烟光凝而暮山紫" /><figcaption aria-hidden="true">潦水尽而寒潭清,烟光凝而暮山紫</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242158212.jpg" alt="喵呜" /><figcaption aria-hidden="true">喵呜</figcaption></figure><h2 id="section-5">20220723</h2><p>今天把带Q-learning的规则网络PDG跑通了，效果比较理想</p><p>晚上去沣河大桥了。</p><h2 id="section-6">20220724</h2><p>今天玩了好多游戏，看了好多动画，还看了火箭发射。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人看过的各动画锐评：二</title>
    <link href="/2022/07/17/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84%EF%BC%9A%E4%BA%8C/"/>
    <url>/2022/07/17/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84%EF%BC%9A%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本文记录我看过的各动画作品，不一定全，也不一定看完了，电影动画都有。然后可能会进行个人主观感受相当强烈的《锐评》。在评价中，个人的情绪、心理、主观观感有相当大的比重，评价也很短，很随性。所以如果和你心目中的差距比较大不要喷哈。</p><p>如果真的要写长评或者认真去评价我会写单独的文章，这个就看一乐。</p><p>第一部分合集：<a href="https://blog.sakizuki.site/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/">本人看过的各动画锐评：一</a></p><span id="more"></span><p>简要评分标准如下：</p><table><thead><tr class="header"><th>评分</th><th>标准</th></tr></thead><tbody><tr class="odd"><td>95+</td><td>【极优】非常优秀的作品，让我印象深刻</td></tr><tr class="even"><td>85+</td><td>【优】各方面都很优秀的作品，或有非常打动我的长处</td></tr><tr class="odd"><td>75+</td><td>【良】良好的作品，我心中的“平均水平”</td></tr><tr class="even"><td>60+</td><td>【合格】合格的作品，没有什么亮点</td></tr><tr class="odd"><td>60-</td><td>【不合格】有明显短板的作品，不堪卒读</td></tr></tbody></table><p>当然上面的“平均水平”的意思是全部动画的平均水平，而不是我看过的平均水平。我尽量把平均分控制在85分左右。</p><h2 id="凉宫春日的消失100">凉宫春日的消失：100</h2><figure><img src="https://lain.bgm.tv/pic/cover/l/9b/9b/3375_33BCV.jpg" alt="凉宫春日的消失" /><figcaption aria-hidden="true">凉宫春日的消失</figcaption></figure><p>个人评分：100</p><p>关键字：穿越、科幻、京阿尼</p><p>锐评：我在前一篇里面说《叛逆的物语》是我第二喜欢的动画电影，那么《凉宫春日的消失》就是我最喜欢的动画电影。自从我第一次看完这部电影以后，每年的12月18日，我都多了一项固定的活动：观看《凉宫春日的消失》。这部作品对我的影响非常大，甚至于塑造了我近年来的三观。</p><p>《凉宫春日》对我来说，很可能就是我热爱动画的意义所在。</p><blockquote><p>要到几岁才开始不相信圣诞老人的存在，这种无聊到家的话题对我来说根本不痛不痒的，不过，如果说到我是几岁开始不相信圣诞老人，那个只存在于幻想世界的穿着红衣服的老公公的存在，我能很确定的说，我根本打从一开始就不相信，我知道幼儿园圣诞节庆祝会时出现的圣诞老人是假的，即使没有撞见老妈正在亲吻圣诞老人，机灵的我也早就怀疑只在圣诞节才工作的老头子是否真的存在了，不过，那些外星人、未来人、幽灵、妖怪、超能力者，还有邪恶组织以及和他们战斗的动画特摄漫画英雄，我发现他们根本不存在于这个世界的时候已经很晚了，不，说不定我早就发现了，只不过一直不想承认而已，因为我的内心深处是十分渴望那些外星人、未来人、幽灵、妖怪、超能力者，还有邪恶组织能够出现在眼前的，不过，现实却是意外地残酷，于是我开始常常惊叹世界的物理法则是多么正确，不知何时开始我就不再热心地观看电视上的UFO特别节目或灵异节目了，宇宙人？未来人？超能力者？这种东西怎么可能存在嘛，不过还是希望他们存在啊...我就像是参考着真实与幻想之间的最大公约数般渐渐地长大了，初中毕业之后，我也从这种小孩子的幻想中毕业了，逐渐习惯了这个世界的平凡，我就这样没啥感慨地成为了高中生——然后遇到了那家伙.....</p></blockquote><p>要到几岁才开始不相信圣诞老人的存在，我能很确定地说，我根本打从一开始就不相信。我们每个人小时候总是充满着各种各样的幻想，甚至是一小段枯燥的文字也能唤起我们无限的遐想，看着一个普普通通的飞机模型，就可以想象这架飞机是怎么遨游在蓝天上的，看着泡澡时泡沫在水中出现又消失，脑中已经在想象一个历经千年波澜壮阔的“泡沐帝国”的兴衰荣辱了，更不要提把三角板夹到笔夹上当战斗机这种事情了。可是当我们长大后，在周围各种各样人无数次地提醒下，我们会不再相信那些不存在的幻想，而只会去关心诸如一日三餐这种一成不变而又真实存在的日常琐事，只因为我们被告知现实就是现实，渐渐地我们开始变得麻木，开始变得循规蹈矩，开始变得安于现状。我们被人无数次地提醒着，现实就是现实，梦想就是梦想。一个人还没找齐的小小社团说自己要进军全国第一，这是梦想；一个小小城市里的普通初中生说自己要上清华北大，这是梦想；都上中学了，也该有点对现实的自觉了吧？</p><p>而凉宫春日则不这样，她不在意什么现实，而只是跟着那些虚无的想法前进。当然，这样的人在现实世界中几乎看不到，那么我们不妨把它当作作者的“理想模型”。而回首人类历史时，我们不难发现，正是“幻想”，正是“虚无的想法”，推动了人类文明的进程。人类的历史就是幻想的历史，人类的历史正是由一个一个的“团长”们写就的。</p><p>一个在地上生活了几万年的物种，突然说自己要飞上蓝天，在二百多年前，这还是十足的幻想。但是现在呢？人类不仅飞上了蓝天，还登上了月球，人类的双手的延申、人类的眼耳的延申，人类的思想的延申，已经到达了冥王星轨道，甚至已经越过了太阳系，向着更远处的星空前进。这，还是幻想吗？</p><p>自古以来只有大雨天才会降下的白色神罚，在三百多年前，这还是十足的幻想。但是现在呢？这天下降下的神罚已经走进了每一家每一户的角落，我能写下这篇文字，也要拜这小小的电流所赐。这，还是幻想吗？</p><p>过直线外一点至少有两条直线与之平行，在四百多年前，这当然是异想天开，是十足的幻想。可是非欧几何成了相对论的基础，现如今所有的定位卫星离了相对论都无法工作。这，还是幻想吗？</p><p>决定人类行动的是情感，推动时代前进的呢？正是那些满怀梦想，充满激情，大胆想象的狂人亦或是疯子们一次一次地用超乎寻常的想象力改变了我们习以为常的世界。而动画艺术，对我而言就象征着想象力，一切都没有限制，在一个个奇妙有趣的异世界中，我们流泪欢笑，一切都是那么地富有激情和浪漫色彩。这也正是我热爱动画艺术的原因。</p><blockquote><p>Day by day うんざりだよね だから</p><p>Day by Day 生活是如此腻味</p><p>堂々と断っちゃう 君になりなよ</p><p>你该堂堂正正拒绝 随心所欲地活着</p></blockquote><p>说完了《凉宫春日》的精神，该说说《凉宫春日的消失》这部电影本身了。这是一部堪称完美的剧场版动画。接近3个小时的片长，绝佳的制作水平（甚至为了体现人物的心理活动，在多处制作了细致的人物表情。而表现手法也深入人心，我印象最深的一段是：阿虚问三味线，你能听懂我说话吗？能就伸右手，不能就伸左手，而三味线的回答则是打了个滚。一段生活中的小小片段，就把世界和阿虚断绝关系的疏远感和无助感体现得淋漓尽致。他心中的疑问，只能被这冰冷世界的表面所反射，少年想做的事情并非是这个世界需要他做的事情，他能听到的并非世界的呼唤，而是自己的发问在这庞大世界中空洞的回音。而原作中大段的心理描写，在电影中则以意识流来处理，而这一段，以标志性的“阿虚踩自己”为代表，也堪称影史经典了，多说无益，自己去看看吧！配乐采用了钢琴曲为主的配乐，即使直接把OST拿出来也很好听。这部电影是没有短板，堪称完美的六边形战士，是《凉宫春日》系列动画中最浓墨重彩的一笔。</p><h2 id="颠倒的帕特玛73">颠倒的帕特玛：73</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207180050015.jpeg" alt="颠倒的帕特玛" /><figcaption aria-hidden="true">颠倒的帕特玛</figcaption></figure><p>个人评分：73</p><p>关键字：科幻，反乌托邦，爱情，世界观</p><p>锐评：一部很可惜的作品。世界观和设定是很亮眼的，可惜用了这么个世界观讲了一个观感一般的故事，感情线也有点粗糙，颇有高汤煮泡面的感觉。</p><h2 id="普罗米亚85">普罗米亚：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207180053299.jpeg" /></p><p>个人评分：85</p><p>关键字：作画，奇幻，燃</p><p>锐评：底子是一个很王道的故事，但是这么一个王道的故事做出来的整体质量很不错。就像是我来朗读《滕王阁序》和人家朗诵家来朗读《滕王阁序》一样，底子是一样的，但是观感就是有区别。情节安排方面，很紧凑，没什么尿点。而艺术风格就非常亮眼了，非常有扳机社风格，大色块，三角形。一言以蔽之：曰：燃得批爆，值得一爽。</p><h2 id="秒速五厘米80">秒速五厘米：80</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207242234613.jpeg" /></p><p>个人评分：82</p><p>关键字：恋爱、新海诚、小品</p><p>锐评：挺好看的一个小片子，就是看着也太着急了，急死我了。不知道为什么，第一个故事给我的感触是最深，最有代入感的，但是我明明没有经历过这样的事情，怎么回事呢？可能只是因为我在雪中坐过公交车？搞不明白了，哈哈。</p><h2 id="朝花夕誓于离别之朝束起约定之花83">朝花夕誓——于离别之朝束起约定之花：83</h2><p><img src="https://lain.bgm.tv/pic/cover/l/0e/1e/218971_PC00Z.jpg" /></p><p>个人评分：83</p><p>关键字：亲情、奇幻、治愈、温柔</p><p>个人锐评：一部很温柔的电影。画面精良，镜头也没什么大差错。整个电影就给人一种娓娓道来的，温柔平和的感觉，人物情感丰富，设定引人入胜，鉴定为好。</p><h2 id="福音战士新剧场版序85">福音战士新剧场版：序：85</h2><p><img src="https://lain.bgm.tv/pic/cover/l/e5/7c/772_yFW6i.jpg" /></p><p>个人评分：85</p><p>关键字：高清重制、EVA、科幻、萝卜</p><p>锐评：就是高清重制版，画质和节奏都比TV好不少，鉴定为彳亍。美术风格就是完全的痞子风辣。</p><h2 id="福音战士新剧场版破90">福音战士新剧场版：破：90</h2><p><img src="https://lain.bgm.tv/pic/cover/l/6f/ab/3302_rEfZV.jpg" /></p><p>个人评分：90</p><p>关键字：EVA、科幻、萝卜</p><p>锐评：从这部开始就不是高清重制版了，对剧情走向有比较大的改动。整体基调比TV积极（......），两段的配乐还是很震撼人心的，虽然不知道为什么，可能这就是艺术吧。</p><h2 id="福音战士新剧场版q52">福音战士新剧场版：Q：52</h2><p><img src="https://lain.bgm.tv/pic/cover/l/a6/bb/22505_O197k.jpg" /></p><p>个人评分：52</p><p>关键字：EVA、科幻、萝卜</p><p>锐评：垃圾得一批，没看终之前还以为看不懂是我的问题，看了终以后才知道就是这作品的问题。故事云里雾里，人员全员谜语，叙事完全失败。等于只有画面和配乐能给点分了。这人设我还不太喜欢，我的第一部不及格献给这部作品。</p><h2 id="福音战士新剧场版终90">福音战士新剧场版：终：90</h2><p><img src="https://lain.bgm.tv/pic/cover/l/04/dc/29883_jQ4Hz.jpg" /></p><p>个人评分：90</p><p>关键字：EVA、科幻、萝卜、告别</p><p>锐评：一部非常好的告别作。虽然看完以后还有很多谜团没有解开，不过也不需要在意了，就是这样的感觉。剧里剧外的人都补完了，再见了，所有的EVA。</p><h2 id="平家物语82">平家物语：82</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202208271617155.jpeg" alt="平家物語 平家物语" /><figcaption aria-hidden="true">平家物語 平家物语</figcaption></figure><p>个人评分：82</p><p>关键字：历史，山田尚子，温柔</p><p>锐评：这部动画原创了一个叫做“琵琶”的人物作为主视角，时间流转，她却不会老去。琵琶的眼睛能预知未来，我们也早已知晓了平家的未来，琵琶似乎是观众的化身。这个创意还是很有意思的。整体观感，怎么说呢，就像用红楼梦的打开方式看三国演义。本片艺术风格采取了和版画、浮世绘风格类似的画风，很有特点；细节安排丰富，美术引人入胜，镜头也比较有实验性。但本片信息量实在太大，对于不具备相关历史知识的人而言看起来有些费劲；且本片对“悲剧”的刻画似乎并不完美，在很多地方用喜剧化的演出来表现悲剧，有些煞风景。总而言之，是一部佳作，希望山田尚子再接再厉（</p><p>最后提醒大家：坚持辩证唯物主义，不要发毒誓，神仙收命不办事，说的就是你，平重盛</p><h2 id="龙与雀斑公主73">龙与雀斑公主：73</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202209050015658.jpeg" alt="竜とそばかすの姫 龙与雀斑公主" /><figcaption aria-hidden="true">竜とそばかすの姫 龙与雀斑公主</figcaption></figure><p>个人评分：73</p><p>关键字：音乐、vtb</p><p>锐评：这个电影，在电影院和不在电影院看，完全是两种体验。为什么呢？因为它的音乐很好听但是剧情太拉跨。人物太多，有些人物不知道出现的意义是什么；内容太多，看得出来想讲很多东西，但是东一榔头西一棒槌，一个也没讲深入。不过至少故事比泡泡好，哈哈。而且女主和她爸那个亲情线还挺温馨的。另外，我觉得女主本身比她在U世界里面那个皮好看。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220711-20220717）</title>
    <link href="/2022/07/11/%E5%91%A8%E8%AE%B0%EF%BC%8820220711-20220717%EF%BC%89/"/>
    <url>/2022/07/11/%E5%91%A8%E8%AE%B0%EF%BC%8820220711-20220717%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><h2 id="section">20220711</h2><p>今天和同学去吃了个自助烤肉，然后去参观了一下高新一中遗址。哎！时过境迁，人是物非啊！</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207112306073.png" alt="image-20220711230530007" /><figcaption aria-hidden="true">image-20220711230530007</figcaption></figure><blockquote><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。</p><p>阁中帝子今何在？槛外长江空自流！</p></blockquote><p>回家的时候坐了个双层巴士，看着走了三年还是六年的回家路，回忆涌上心头。当年我也就是在这条路上和初中同学一起背政治历史的，也是在这条路上和高中同学一起玩玩闹闹的，高三也是六点多的时候从这条路上上学，晚上十一点从这条路上回家的。哎，怎么就搬家了呢，我是真不想搬家，那里才是我心中永远的家。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207112230010.png" alt="永远滴家" /><figcaption aria-hidden="true">永远滴家</figcaption></figure><p>朋友们明天就要来西安了，后天就能去玩了，开心。</p><p>今天还看了两集十二国记。</p><h2 id="section-1">20220712</h2><p>今天学了《网络科学导论》的前两章和第三章的一部分，小写了点代码。</p><h2 id="section-2">20220713</h2><p>今天早上逛了钟楼</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132319209.jpg" alt="小雨，钟楼，南大街" /><figcaption aria-hidden="true">小雨，钟楼，南大街</figcaption></figure><p>其实我自己也好久没上钟楼了，今天和朋友们一起上。我记得以前钟楼还能敲呢，现在也不给敲了</p><p>然后去了易俗社，转了个博物馆，喝了个茶话弄</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132320896.jpg" alt="四人，秦腔，茶话弄" /><figcaption aria-hidden="true">四人，秦腔，茶话弄</figcaption></figure><p>下午先去了碑林</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132321332.jpg" alt="碑林，石刻，唐玄宗" /><figcaption aria-hidden="true">碑林，石刻，唐玄宗</figcaption></figure><p>说实在的，我是西安人，我也没去过碑林。今天是我第一次去碑林，请了一位讲解员，确实收获不少知识。比如说书法的演变啊，包括异体字之类的，还挺有趣的。</p><p>碑林出来以后就是书院门</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132322185.jpg" alt="古玩，字画，书院门" /><figcaption aria-hidden="true">古玩，字画，书院门</figcaption></figure><p>书院门就是一条卖古玩字画的街，古色古香的，很有文化气息。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132323619.jpg" alt="暗巷，精裱，路边摊" /><figcaption aria-hidden="true">暗巷，精裱，路边摊</figcaption></figure><p>晚上上了城墙。以前都是在元宵节看灯会上城墙的，很热闹；而今天城墙上没有多少人，很静谧，也挺舒服的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207132325782.jpg" alt="静谧，古城，红灯笼" /><figcaption aria-hidden="true">静谧，古城，红灯笼</figcaption></figure><p>城墙根底下有好多小众文艺范儿的酒吧，还有人唱歌，我在城墙上面的人也跟着沾光，不错。</p><h2 id="section-3">20220714</h2><p>今天的行程是：早上去小雁塔和西安博物院，中午吃长安大排档，下午转一转高新区</p><p>西安博物院的玻璃展览，展出了很多欧洲国家古代的玻璃。很惊讶两千年前的玻璃竟然已经能做出透明的效果的，我想如果中国古代也有这样的透明玻璃，化学会不会有更好的发展呢？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162252034.jpg" alt="千年前的欧洲玻璃瓶子" /><figcaption aria-hidden="true">千年前的欧洲玻璃瓶子</figcaption></figure><p>这是小雁塔公园。以前都是逛庙会的时候来，现在没多少人，园子里郁郁葱葱，也有一种别样的美感。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162254088.jpg" alt="小雁塔" /><figcaption aria-hidden="true">小雁塔</figcaption></figure><p>中午去吃了长安大排档。这个算是一个网红店，但是出品还算不错。我们点了一个葫芦鸡，一个口蘑炒牛肉，一个孜然牛肉。葫芦鸡的肉比较软烂，它的一个特色是蘸料有一个橘子辣酱，比较有新意，而且这个橘子辣酱还是比较好吃。口蘑炒牛肉是一个咸鲜的口，孜然牛肉孜然味儿不多，而且有点辣。总的来说还算不错。<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162257951.jpg" alt="葫芦鸡" /></p><p>下午先从小寨去大兴善寺。大兴善寺的安静和小寨的喧闹形成了鲜明的对比，很有意思。大兴善寺里面有很多乌龟，和猫猫。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162303684.jpg" alt="大兴善寺的猫猫" /><figcaption aria-hidden="true">大兴善寺的猫猫</figcaption></figure><p>最后去高新区逛了逛，到这个咖啡街区喝了个瑞幸咖啡。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162305086.jpg" alt="瑞幸" /><figcaption aria-hidden="true">瑞幸</figcaption></figure><p>这天晚上和同学重温了来自深渊，真好看</p><h2 id="section-4">20220715</h2><p>今天早上去了陕西省博物馆。这次最震撼我的是这个兽头人身俑。只能说古代人玩挺大。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162308762.jpg" alt="省博" /><figcaption aria-hidden="true">省博</figcaption></figure><p>中午吃了张记，一如既往的好吃。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162311442.jpg" alt="张记" /><figcaption aria-hidden="true">张记</figcaption></figure><p>下午去了大雁塔，还爬了大雁塔，累的要死。爬完以后说，本来还想着明天爬骊山，我看拉倒吧</p><p>爬完塔以后吃了个陕十三，就是个冰激淋店</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162313574.jpg" alt="陕十三" /><figcaption aria-hidden="true">陕十三</figcaption></figure><p>去了西安美术馆，看同学许的有趣愿望</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162313673.jpg" alt="什么凉宫春日" /><figcaption aria-hidden="true">什么凉宫春日</figcaption></figure><p>晚上听了音乐会</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162314969.jpg" alt="音乐会" /><figcaption aria-hidden="true">音乐会</figcaption></figure><h2 id="section-5">20220716</h2><p>今天去了兵马俑，我是西安人，今天还是第一次去兵马俑。去的时候下了雨，骊山笼罩在云雾之中，还挺好看的，不过就是爬不成了。上次来骊山是高中研学旅行的时候，就没成功爬上去，这次还是没爬，可惜。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162317658.jpg" alt="兵马俑" /><figcaption aria-hidden="true">兵马俑</figcaption></figure><p>兵马俑还算是很震撼的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162318776.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>中午在景区吃了个biangbiang面，一般，醋放太多了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162318398.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>晚上去洒金桥转了转，愉快的西安之旅到此就告一段落了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207162319003.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="section-6">20220717</h2><p>今天坐公交车回家了，下午玩了玩原神，晚上和高中打竞赛的几个同学出去吃饭。吃完饭以后看到一个彩票机，一个同学买了一张，没中，我寻思着我也买一张，结果就中了60，笑死我了，人生买第一次彩票就中了。什么嘛，我还挺能买的嘛。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈什么是二次元</title>
    <link href="/2022/07/07/%E6%B5%85%E8%B0%88%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    <url>/2022/07/07/%E6%B5%85%E8%B0%88%E4%BA%8C%E6%AC%A1%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>从“原神是不是二次元”说开去。</p><span id="more"></span><p>原神是不是二次元呢？在文章的一开始，我可以给出答案：在我心中，原神是二次元。</p><p>那么，什么是所谓的“二次元”呢？二次元，在平常的语境中，有两种含义。第一种，是指二维动画艺术，及其衍生作品，第二种含义，则是喜欢第一种作品的人。在我看来，这两种含义是有机地结合在一起的。</p><p>我第一次接触现代网络上最普遍意义的“二次元”，应该是在高一刚刚开学，也就是2016年的10月份。基于各种机缘巧合<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="说来搞笑，这里的“机缘巧合”是我在看一个《康熙怒斥群臣》的鬼畜时，“正大光明匾”升上来的一刻，弹幕里有人发了个“御坂美琴”。">[1]</span></a></sup>,我看的第一部是“二次元”是《某科学的超电磁炮》。但是很神奇的是，在接下来的一年中，我自己只是在不断地，一遍又一遍地去看这一部动画（实际上是两部，毕竟还有一个S）。所以说我认为，我真正的“入宅番”并不是《某科学的超电磁炮》，而是《末日时在做什么？有没有空？可以来拯救吗？》。在看过这部以后，我才开始找各种“二次元”动画片看，后来又陆续看了《凉宫春日的忧郁》，《工作细胞》，等等，不再一一列举了。后来在大学，我又在学校的二次元社团（也是学校最大的社团）里，担任了2-3年的职务。</p><p>那么在我心中，什么是二次元呢？其实我自己在选阅作品时是有一种很强烈的倾向的，也就是我很喜欢“幻想艺术”。相比于基于所有人的常理所构建的世界的作品，我更喜欢奇幻、科幻，这种“给世界一刀，看世界带伤运转”的作品。这一点，从我的博客的封面图也可以看得出来。为什么呢？我想，我在欣赏“二次元”作品时，是在躲避现实世界。</p><p>这时候，你就要说了：桀桀，又避世了吧？所以说二次元都是现实世界不如意的fw。是这样的吗？不是。如果真的说“避世”，那可能确实有一点。但是我之所以用了“躲避”，而不是“逃避”，正是为了说明这一点。躲避不同于逃避，逃避有恐惧的含义，而躲避，只是累了。二次元不等同于“社恐”，也不等同于“死宅”，当然也不等于“没有男/女朋友的人”（笑）。我可以白天在底下坐着几百人的讲台上激情洋溢地讲课，也可以和期中考试挂科了的同学坐下来谈心，但这不影响我到了晚上点开一集动画片，和美少女们在剑与魔法的世界中遨游吧？我不恐惧社交，也不是不擅长与社交，我只是很单纯的，不喜欢社交。现实世界太累了，压力太大了，人和人打交道，总要我打起十二分精神，开动所有的CPU，算这，算那。于是我选择了一个更加温暖柔情的世界来做我的避风港。</p><p>那么为什么王者荣耀在我眼中不是二次元，而原神则是呢？明明看艺术风格，王者荣耀也挺二次元的。没错，艺术风格只是一方面，“二次元”这个概念最核心的东西是和内容相关的，是提炼出来的那种纯粹。这种纯粹既可以理解为对现实世界的简单化，也可以理解为对现实世界的升华。王者荣耀这种游戏，激励人玩下去的是“人超越人的快乐”，是“人与人”之间的优越感，是“人与人”之间的攀比心。我这里这么强调“人与人”，正是为了说明，这样的游戏的本质还是社交，是现实世界中人和人的关系。而促使包括我自己在内的很大一部分人游玩原神的动机，则是为了体会那个风和日丽，鸟语花香，高山大川，千里冰封的“异世界”。甘雨一箭的伤害是一万还是十万很重要吗？圣遗物是暴击爆伤还是生命防御很重要吗？在一个小黑屋里杀光敌人，是用了一分钟，还是用了30秒，这很重要吗？当我驻足在风神像前，用风物之诗琴朴拙地弹奏一曲仅仅在我脑中存在过的旋律时，当我看到浅濑神社门前的猫猫云彩时，当我登上寒天之钉俯瞰大陆时，我想，这才是我游戏的意义。可以看出，这个相比现实世界更加温暖柔情的世界正是担当了我的避风港。因此，在我看来，原神是二次元，证毕。</p><p>当然，也有喜欢《原神》的人们，他们更关心在一个小黑屋里杀光敌人，是用了一分钟，还是用了30秒，或者说，他们关心的是有没有比别人更快。那么在这样的玩家看来，原神就不是二次元。在喜欢看剧情，喜欢看人物介绍的人看来，明日方舟是二次元；在把所有人物都当作数值和机制的集合，当作“塔”，一心一意地只为了拿到全世界最快的满级危机合约的玩家看起来，明日方舟就不是二次元。当然，这些玩家没有高下之分，这里说的，只是“是不是二次元”。</p><p>写到这里，可以说“二次元”理论的大厦已经基本建成了，只是上空还漂浮着两朵乌云。</p><p>首先，你刚刚说过，“二次元”这个概念最核心的东西是和内容相关的，是提炼出来的那种纯粹。那么我就要问了，照你这么说，电影电视剧也是二次元！小说也是二次元！这合理吗？</p><p>是的，这不合理。首先我们来说说电影电视剧的事。电影电视剧有一个特点，那就是它们是“实拍”的。无论特效做得再花里胡哨，这改变不了它们是实拍的本质。既然是实拍，那么我在观看的时候，就会不由自主地往真正的现实世界上去投影。我就会想，这些事情怎么可能发生呢？在现实世界里，他们肯定会这样这样，那样那样，然后怎样怎样~，最后落得一个悲惨的下场，所以说这电视剧拍得一点都不好。但是在观看动画作品时，和现实世界略有相似却大相径庭的画风每时每刻都在提醒我：这是你的避风港，把你的那些CPU都关掉，放松一下吧。</p><p>至于小说是不是二次元，在我看来是很模糊的。毕竟还有“轻小说”这种东西。不过我倾向于认为：小说就是二次元！因为在读小说的时候，我在脑子自然地构建着一整个世界。这就是文字艺术的魅力。（P.S. 当然，主角是美少女的最好。）</p><p>好好好，算你混过去了。那么第二点，我要一击致命了！那就是：动漫社为什么会存在？既然你们“二次元”都在躲避社交，那么一群二次元们怎么混在一起社交，不觉得矛盾么？所谓的动漫社，不过是现充聚会罢了！</p><p>必须承认的是，动漫社里面有现充<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="现充分为严现充和宽现充。严现充特指有男/女朋友的人；而宽现充则指有现充行为模式的人。现充行为模式是一套现充的行为模式（什么废话），包括但不限于：吃饭时，打球时，看电影/电视剧/动画时不专注于自己正做的事情，而专注于聊天；乐于社交（注意，还是提醒各位读者，乐于不同于擅于，不乐于不同于不擅于）等。严现充和宽现充不互相包含，但大部分严现充都是宽现充。这里的现充指的是宽现充。">[2]</span></a></sup>。但是，二次元也不少。为什么呢？二次元们躲避社交，不代表二次元们不需要社交。二次元和二次元之间，当然可以有基于二次元形成的纽带。当御坂美琴拿出硬币时，当珂朵莉拿起不属于她的杀人圣剑冲向无边无际的兽之海时，当凉宫春日大声说出“让世界变得更热闹”时，当阿瑠的歌在阿瑠死后不知道多少年响起时，当鹿目圆献出自己的“存在”来消灭魔女时......当在满屏“泪目”弹幕的那一刻，我，确实能感受到有很多和我一样的二次元宅宅，在为了虚拟世界中的虚拟女孩感动。那一刻，我们的心是连在一起的，是通过一个名叫“鹿目圆”的虚拟世界的虚拟女孩连在一起的。在某种意义上，在这一刻，我们这些素昧平生的二次元之间的距离，比我在现实世界中打起十二分精神，开动所有的CPU，算这，算那，来进行社交的对象的关系近得多。在人与人之间真诚地交流自己的兴趣时（当然这里的兴趣并不局限于二次元），也就不需要打起十二分精神算这算那了。因为此时的人是单纯的人，此时的世界是单纯的世界。这一刻联系着我们的，并不是所谓的“社交技巧”，甚至不是二次元作品本身，在我看来，这一刻联系着我们的，是人类的本性，是对善良和爱，感动和泪水，正义和激昂的确信。在这一刻，我似乎相信，即使在现实世界中，也有人在追寻着理想国。于是，我便能关掉CPU，放下十二分精神，只用自己的本性，和同好们畅谈鹿目圆，畅谈珂朵莉，畅谈阿瑠，畅谈他们背后的人类的最最美好的品性，和平时并不相信存在的理想国。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>说来搞笑，这里的“机缘巧合”是我在看一个《康熙怒斥群臣》的鬼畜时，“正大光明匾”升上来的一刻，弹幕里有人发了个“御坂美琴”。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>现充分为严现充和宽现充。严现充特指有男/女朋友的人；而宽现充则指有现充行为模式的人。现充行为模式是一套现充的行为模式（什么废话），包括但不限于：吃饭时，打球时，看电影/电视剧/动画时不专注于自己正做的事情，而专注于聊天；乐于社交（注意，还是提醒各位读者，乐于不同于擅于，不乐于不同于不擅于）等。严现充和宽现充不互相包含，但大部分严现充都是宽现充。这里的现充指的是宽现充。 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220704-20220710）</title>
    <link href="/2022/07/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220704-20220710%EF%BC%89/"/>
    <url>/2022/07/04/%E5%91%A8%E8%AE%B0%EF%BC%8820220704-20220710%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><h2 id="section">20220704</h2><p>今天没干什么事。早上在一个没有空调的球馆里打球，热得半死，也累得半死。下午没有做事，晚上把大决战看完了。</p><p>明天该收拾东西了。马上要回西安了。我真期待我的朋友们来西安玩啊。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207042231143.jpg" alt="管人" /><figcaption aria-hidden="true">管人</figcaption></figure><p>笑死，怎么专门把“管人”涂掉，什么隐喻。</p><p>昨天忘了说了，我真是气个半死，他妈整个魔女文画风的倒计时，我还以为是回天的预告，结果不是。</p><blockquote><p>你把大家都叫出来，就是为了说这点事啊？</p></blockquote><h2 id="section-1">20220705</h2><p>今天和朋友去国家图书馆看书了。确实很厉害啊，书是真的多。我看了一本《化物语》，感觉还是相当有意思的。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207062305004.jpg" alt="国图" /><figcaption aria-hidden="true">国图</figcaption></figure><p>悄悄说一句，我有点不太理解来国图看网课的人，何必呢（）</p><h2 id="section-2">20220706</h2><p>今天回到了西安，标志着暑假生活正式开始（不是）。西安的堂食都G了，本来还想去吃烤肉的，只能再等等了。</p><p>朋友想要报计组的助教，我还挺羡慕的。其实去年当助教我自己也挺开心的，只可惜下学期课太多，太难，事情太多，实在是没有时间了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207062303919.jpg" alt="阿房宫站" /><figcaption aria-hidden="true">阿房宫站</figcaption></figure><p>到达世界最高站，阿房宫站！</p><blockquote><p>覆压三百余里，隔离天日。骊山北构而西折，直走咸阳。二川溶溶，流入宫墙。五步一楼，十步一阁；廊腰缦回，檐牙高啄；各抱地势，钩心斗角。盘盘焉，囷囷焉，蜂房水涡，矗不知其几千万落！长桥卧波，未云何龙？复道行空，不霁何虹？高低冥迷，不知西东。歌台暖响，春光融融；舞殿冷袖，风雨凄凄。一日之内，一宫之间，而气候不齐。</p><p>——《阿房宫赋》</p></blockquote><h2 id="section-3">20220707</h2><p>今天早上整了个域名，也就是blog.sakizuki.site，大家以后也可以通过这个域名来访问我的博客。</p><p>本来打算今天下午学习，结果真的学习了，学习的成果是把课本下载好了，哈哈。</p><p>今晚看了《走向共和》，看了3集。</p><h2 id="section-4">20220708</h2><p>今天早上看了看数电，下午打了一会儿苍彼，然后吃了吃安倍晋三的瓜，晚上看了走向共和。</p><h2 id="section-5">20220709</h2><p>今天把数电前两章看完了，还看了两集相合之物，一集彼岸花物语，三集走向共和，玩了一会儿苍彼，打了一会儿羽毛球。</p><p>今天西安疫情快结束了。</p><h2 id="section-6">20220710</h2><p>今天看完了走向共和，这个剧还是相当不错的。</p><p>今天还看了四集动画片，玩了一会儿游戏。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人看过的各动画锐评：一</title>
    <link href="/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/"/>
    <url>/2022/07/03/%E6%9C%AC%E4%BA%BA%E7%9C%8B%E8%BF%87%E7%9A%84%E5%90%84%E5%8A%A8%E7%94%BB%E9%94%90%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>本文记录我看过的各动画作品，不一定全，也不一定看完了，电影动画都有。然后可能会进行个人主观感受相当强烈的《锐评》。在评价中，个人的情绪、心理、主观观感有相当大的比重，评价也很短，很随性。所以如果和你心目中的差距比较大不要喷哈。</p><p>如果真的要写长评或者认真去评价我会写单独的文章，这个就看一乐。</p><span id="more"></span><p>简要评分标准如下：</p><table><thead><tr class="header"><th>评分</th><th>标准</th></tr></thead><tbody><tr class="odd"><td>95+</td><td>【极优】非常优秀的作品，让我印象深刻</td></tr><tr class="even"><td>85+</td><td>【优】各方面都很优秀的作品，或有非常打动我的长处</td></tr><tr class="odd"><td>75+</td><td>【良】良好的作品，我心中的“平均水平”</td></tr><tr class="even"><td>60+</td><td>【合格】合格的作品，没有什么亮点</td></tr><tr class="odd"><td>60-</td><td>【不合格】有明显短板的作品，不堪卒读</td></tr></tbody></table><p>当然上面的“平均水平”的意思是全部动画的平均水平，而不是我看过的平均水平。我尽量把平均分控制在85分左右。</p><h2 id="赛马娘-pretty-derby-第二季-83">赛马娘 Pretty Derby 第二季 ：83</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335693.jpeg" alt="赛马娘" /><figcaption aria-hidden="true">赛马娘</figcaption></figure><p>个人评分：83</p><p>关键字：励志、运动、拟人、<del>轻百合</del></p><p>锐评：好动画，节奏合适，燃虐有度。本动画可以做到合理改编历史事实，抓住主要矛盾，删除没必要体现黑暗的一面并加入偶像元素，使得动画的一体性更高，不至于有割裂感。就论故事来说其实也就是关于梦想和挫折的故事，的一个制作比较优秀的动画。但是这个改编实在是太新奇了，竟然把赛马这一项运动改编成动画，不得不打个高分。</p><h2 id="奇巧计程车95">奇巧计程车：95</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335781.jpeg" alt="taxi" /><figcaption aria-hidden="true">taxi</figcaption></figure><p>个人评分：95</p><p>关键字：群像、推理、<del>叙述性诡计</del>、剧情向</p><p>锐评：其实我自己对这种有叙述性诡计的作品就自带了好感度（久美子：这是什么？听起来有点色情）。最有趣的是本作的叙诡只有依靠“动画”这一载体才能实现（类似于《罗杰疑案》的叙诡只有依靠文字才能实现？hhhh），所以在我心中非常加分。</p><p>而且本作剧情相当优秀、环环相扣；都市感很强；人物群像塑造不空洞，而且有我很喜欢的画面（比如那个月下飞车）。一点点小遗憾在于一个很重要的剧情依赖巧合推动，有一点点操纵剧本的脱离感。</p><h2 id="泡泡61">泡泡：61</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335770.jpeg" alt="bb" /><figcaption aria-hidden="true">bb</figcaption></figure><p>个人评分：61</p><p>关键字：后新海诚、奇幻、恋爱</p><p>锐评：这部作品平庸到了极点，尽管STAFF各种牛逼，又是虚渊玄又是泽野弘之又是荒木哲郎的，但是做出来的东西只能说是感觉不如新海诚。那么这是怎么会事呢？</p><blockquote><p>配角1: シン (shin) 配角2: カイ (kai) 配角3: マコト (makoto)</p></blockquote><p>只能说是一目了然不言而喻了好吧。当然我这里只是说平庸，而不是说差劲。之所以说平庸，是因为我感觉这几个staff肯定能做出更让人眼前一亮的东西，这个只能说是让人十分失望。但是就片论片，画面和音乐都还算是比较好，算是及格了吧。</p><p>如果日后人们分析日本动画电影时提到“后新海诚主义”，那么这部作品一定首当其冲，作为代表性平庸之作载入史册。这里推荐赵冰的《固守与超越：美日动画电影母题研究》，有兴趣的不妨看一看。</p><h2 id="魔法少女小圆叛逆的物语96">魔法少女小圆：叛逆的物语：96</h2><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335986.jpeg" alt="pn" /><figcaption aria-hidden="true">pn</figcaption></figure><p>（或有剧透）</p><p>关键字：剧情、百合、魔法少女、战斗、<del>看不懂</del></p><p>个人评分：96</p><p>锐评：神作！这是我心目中第二好看的动画电影。整个剧情看下来虽然初看不是很能看懂，但是其实很讲框架和逻辑，剧情发展得非常正规。而最后的转折更是画龙点睛之笔，如果整部作品在圆神把晓美焰接走后结束，那就太太太遗憾了——作为本篇主角的晓美焰，竟然没有为本篇主要矛盾的解决起到最关键的作用吗？可是新房创造性地、开天辟地 地设置了这个场景，设置了晓美焰撕裂圆神而成魔的结局，给本篇的整个结构画上了完美的句号。</p><h2 id="利兹与青鸟86">利兹与青鸟：86</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062335970.jpeg" alt="lzyqn" /> 关键字：音乐、文艺、青春</p><p>个人评分：86</p><p>锐评：这部作品应该走的是文艺风，整体风格都比较淡雅，音乐也很好，百合也很好，而且画风和本篇差别比较大。故事淡雅轻灵，作画细致入微，更以嵌入童话的手法来创新叙事。通过清灵的作画、配乐和叙事，本作塑造了一个非常纯粹的世界：没有“世界VS她”的抉择，也没有三角恋，没有本篇中的“政治”因素（笑），有的只是两个高中女生之间细腻而青涩的感情。配乐和故事也进行了非常有机的结合。我在《音乐分析与鉴赏》的课程中就选择了《利兹与青鸟》的第三乐章，得了90好几分。在讨论这部作品时，经常有人讨论谁是利兹而谁是青鸟，在我看来，没有人是利兹也没有人是青鸟，或者说，两个人互为利兹与青鸟。利兹与青鸟童话中的故事不是在暗示霙和希美两人关系的正确解法，而是在暗示霙和希美的现状：两人之间无法传达的心意，和阴差阳错的误解。在电影最后，她们终于了解了自己和对方，真正的抱在了一起，脚步声也从一开始的不同频在最后变成了协调的声音。</p><h2 id="少女歌剧含剧场版87">少女歌剧（含剧场版）：87</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336273.jpeg" /> 关键字：百合、战斗、奇幻、演出</p><p>个人评分：87</p><p>锐评：这个动画我一开始是在19年准备高考的时候看的，看的时候有很多既视感，什么少革小圆的。我的高中在2019年5月12日就放假了，基本上来说，是这部动画陪我走过的高中生涯的最后一个月。至于看的契机，大概是感觉里面的美少女非常帅气吧。本作的剧情虽然有点弱势，但是Revue看着是真的爽，尤其是第一集里面爱城华恋进入地下剧场，然后她跳到舞台中央时的那一段BGM，简直让人颅内高潮。每场Revue加上音乐和歌唱都是一场视听盛宴，可能这就是动画的魅力吧。当然战斗美少女百合CP俺也很喜欢。而剧场版更是扬长避短，用极具张力的演出和音乐不断挑动观众的神经，是一部非常优秀的粉丝向剧场版。</p><h2 id="恋爱小行星78">恋爱小行星：78</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336349.jpeg" /> 关键字：天文、地理、校园、治愈</p><p>个人评分：78</p><p>锐评：这个动画就是比较良好的动画。所谓的“轻百合八股”，就是选取一个小众爱好，加一点校园，加一点美少女，加一点美少女贴贴。比较好的地方在于校园日常的塑造，偶尔会出现那么一两个让我既视感很强的片段，女孩子的人设也很可爱。这部和“传统轻百合”还有一点区别，就是现实主义色彩更加浓重，也有很多三次元的联动。但是缺点没有完全把天文地理的魅力展现出来，知识和动画结合的略有些生硬。</p><h2 id="魔女之旅80">魔女之旅：80</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336761.jpeg" /> 关键字：公路、百合、<del>屑</del>、奇幻、单元剧</p><p>个人评分：80</p><p>锐评：人设大于剧情，伊雷娜的人设确实很讨喜，毕竟是讨论度极高的“屑魔女”嘛。百合+生草小片段的处理也算是版本答案，这一点在《莉克莉斯》中被发扬光大了。但是就是说作者的故事写的水平确实是差了一点。小说前期确实写的不怎么样，后面有些改观。改天要去看看《奇诺之旅》。</p><h2 id="来自深渊第一部深魂黎明85">来自深渊（第一部+深魂黎明）：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336929.jpeg" /> 关键字：世界观、虐、奇幻、冒险</p><p>个人评分：85</p><p>锐评：其实我看这部是看了2部总集篇+1部剧场版。只能说这个世界构建得实在是太有意思了，壮丽、神秘而精美，如果做成开放世界游戏肯定非常非常好玩，如果有个靠谱的游戏公司来做的话就太好了（现在这个游戏，我说句不好听的，感觉不如原神）。在世界观以及如此优秀的情况下剧情没有拉跨，就已经非常值得一看了，况且剧情也很精彩呢。这部动画在我看来是非常“遗憾”的动画，第一遗憾在创造了这么精彩的世界观，但是没有展开介绍，情节推进的速度太快，还没来得及欣赏这一层的生态呢，就要继续往下走了。第二遗憾在如果某些“血腥”或者说“恶趣味”的情节不要表现得这么露骨，让人看着心惊胆战（这部片是PG12真的合理吗？），它有可能本来会得到更高的评价，而不是让“土笔恶趣味”的阴影一直伴随着它。当然，这也可能是来自深渊之所以是来自深渊的原因吧，谁知道呢？</p><h2 id="末日时在做什么有没有空可以来拯救吗95">末日时在做什么？有没有空？可以来拯救吗？：95</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336289.jpeg" /> 关键字：奇幻、末世、恋爱、诺斯替</p><p>个人评分：95</p><p>锐评：这部作品应该对我的影响是非常非常大的，是我真正的“二次元入坑作”。当时是17年吧，我是在打OI的时候被同学（以及刷题网站？hhhh）安利到了这部番 <del>，然后就感受到了二次元的魅力，变成了萌萌二次元</del> 。第一集的斯卡布罗集市就非常地抓人眼球，然后就是这个摇摇欲坠又精致的异世界，然后就是珂朵莉和威廉甜甜的恋爱，然后就是刀子。鲁迅说过：“悲剧就是把美好的东西撕碎给人看”，在这部作品中我确实是体会到了悲剧带给我的震撼。后来我在NOIP2017被 <span class="math inline">\(ab-a-b\)</span> 背刺了以后，也是不停地在听这个动画里的歌，我记得里面有一句是：</p><blockquote><p>We never say good bye and never see again</p></blockquote><p>虽然说这部动画现在看来有这样那样的问题，诸如什么制作贫穷、宏大的世界观和渺小的爱情故事不搭配之类的问题，但是这些都不妨碍现在的我替2017年的我打出95分的高分，因为它在我心中永远是【神作】：非常优秀的作品，让我印象深刻。</p><p>另：本动画的原作小说也非常值得一看，今年还入围了日本星云奖。我最喜欢的是其中的第四本，在这一本中视角回到了500年前，作者将插叙手法运用得炉火纯青，带我领略了500年前大灾变的始末，和“叹月的最初之兽”的悲叹。</p><h2 id="索玛丽与森林之神70">索玛丽与森林之神：70</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336213.jpeg" /> 关键字：旅行、日常、萝莉、催泪</p><p>个人评分：70</p><p>锐评：我记得我看这部的原因就是它和上面说的末日时是一个公司做的。不过这部没给我留下太大印象，可能是不太对我胃口。就光记得催泪催得有点太生硬了。</p><h2 id="lovelive76">Lovelive！：76</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336901.jpeg" /> 关键字：偶像、校园、青春</p><p>个人评分：76</p><p>锐评：单就动画作品来看其实这部比较平凡，算是良作，说好听点就是淳朴吧，当成歌舞片看还挺好的。当然如果加上偶像企划等等一系列内容就另说了。但是这篇文章还是以动画评价为主，所以给到一个良作的档。</p><h2 id="轻音少女89">轻音少女：89</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336552.jpeg" /> 关键字：校园、青春、日常、<del>meta</del></p><p>个人评分：89</p><p>锐评：一部相当优秀的作品，各方面素质都不弱。这部作品是我在2019年高考后看的第一部动画。刚刚结束高中生活的我看着几个可爱的女孩子慢慢走完高中生活的感觉，很奇妙呢。而且在我看的时候她们高考出分和我高考出分是同步的，是同一天，也算是一个别样的体验了，这也是对我来说这部作品的关键字里面有 <del>meta</del> 的原因。其实我感觉这不正是我想要的青春吗。喜欢了什么就义无反顾地开始学习，钱不够了就大家一起打工赚钱，放课后的偷懒，上台前的特训，一起向着目标努力，一起经历疯疯傻傻的生活。最后的最后要毕业了，要分开了，以前一起做过什么很多都记不起来了呢，只记得十分地快乐幸福。 在我刚进大学的时候给我很多很多帮助的18级的前辈，比如aikx、喵燐、赫卡、半宅、薛汐、马老师、mlz、Sky等等，也马上就要毕业了。真伤感啊。</p><h2 id="吹响吧上低音号95">吹响吧！上低音号：95</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336575.jpeg" /> 关键字：社团、青春、音乐、古典、轻百合、励志</p><p>个人评分：95</p><p>锐评：我的高中完全没有社团这种东西的存在，但我却对这部作品的共鸣很强烈，这是为什么呢？其实是因为我把我的竞赛经历投射到了9妹子她们搞吹奏乐身上。我觉得这简直 <strong>完全同构</strong> 好吧，目标都是一路过关斩将， <strong>全国大会出席</strong> ，而且还有什么选拔、合宿（指集训）、等等。唯一的缺点就是9妹子找到了女朋友和男朋友，但我没找到，话虽如此，也算是认识了几个非常要好的朋友。</p><p>除开个人因素，本作作画精美；音乐极其优秀，大大加强了我对古典音乐的兴趣，我有一个相当大的愿望，就是能在音乐厅里欣赏一次本作的经典音乐，如《三日月之舞》、《利兹与青鸟》、《吹响吧！上低音号》、《北宇治四重奏》等。剧情多线交织，详略得当，总集篇的删减也算比较合理。总之来说综合素质可圈可点，所以：</p><p><strong>什么时候出第三季！！！！！！</strong></p><p>（反转了，已经出了）</p><h2 id="比宇宙更远的地方86">比宇宙更远的地方：86</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336539.jpeg" /> 关键字：青春，南极，浪漫</p><p>个人评分：86</p><p>锐评：其实从2019年元旦起，我有一个每年的12月31日都要一晚上看一部动画来跨年的习惯。19年我看的是《凉宫春日》（虽然不知道是几刷了），20年我看的是《紫罗兰永恒花园》，21年我看的就是《比宇宙更远的地方》。这部吸引我的关键字是“宇宙”，虽然实际上和宇宙没有什么关系。但并不影响这是部好作品。能把正值青春期孩子们的烦恼，友情，人际交往等关系充分表现出来，题材也很浪漫，虽然不是宇宙，但那是南极耶！！</p><h2 id="寒蝉鸣泣之时含解不含其它90">寒蝉鸣泣之时（含解，不含其它）:90</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336347.jpeg" /> 关键字：爱，悬疑，猎奇，友情</p><p>个人评分：90</p><p>锐评：一部爱与友情的治愈史诗，比较优秀的游戏改编作品。本作的最大有点一是设置精巧而符合逻辑的悬疑，二是让人看到美好的结局时的欣慰。尽管有着恐怖、血腥等等的形式，但是观众们拨开一层层漆黑的外壳时，最终却得到了晶莹剔透的果实。如果画风能更精致一点，然后血腥暴力稍微少一点就好了。毕竟一开始我也是忍着恐惧在看hhhh</p><h2 id="派对浪客诸葛孔明83">派对浪客诸葛孔明：83</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336014.jpeg" /></p><p>关键字：穿越、偶像、轻松、搞笑</p><p>个人评分：83</p><p>锐评：“酱酱<sub>爱7ki7ki棒棒</sub>”本作 算是四月黑马，观感尚佳，值得期待第二季。虽然名字乍一看挺逆天的，但是可以看出制作人员对孔明和三国历史还是有一定程度的了解的，不是光套个名字就硬上。另外英子莫名地合我的xp，总感觉很是喜欢这种帅帅的二次元女孩子，大加分！制作确实有点穷了，多来点钱应该会更好。</p><h2 id="未闻花名73">未闻花名：73</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336249.jpeg" /></p><p>关键字：友情、伤感、治愈</p><p>个人评价：72</p><p>锐评：这部是一部非常著名的动画，但是就我个人来说，没对我有什么太大的感触。氛围营造得有点刻意，不太好共情。好在ed还挺好听，算是挽回一点评价。</p><h2 id="来自新世界82">来自新世界：82</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336315.jpeg" /></p><p>关键字：科幻，反乌托邦，轻改</p><p>个人评分：82</p><p>锐评：这是一部很有经典气息科幻作品。什么是科幻小说的经典气息呢？科幻小说，也就是幻想和构造的艺术——作者假定一种技术或科学现象，以此假定为种子来进行逻辑推演，开花结果，最终形成了一篇精彩的作品，这才叫经典的科幻。正如前些年热映的《Arrival》中的“外星语言”、《三体》中的三体运动、《诗云》中的“穷举所有诗词”一样。很喜欢我忘了是谁说过的一句话：“科幻文学就是给世界一刀，看世界带病运转的样子”。（当然，多说两句题外话，科幻艺术并不能因为科幻而放弃艺术，毕竟大家看动画小说，看得还是人物塑造、故事情节以及情感，而不是线性代数课本。所以说，科幻作品以点子为基础，而以人物和故事为核心。并不是说一个人越“懂科学”，他所写出的科幻小说就越好）在这个层面，本作也是基于一个核心点子（即咒力，简单来说就是人的武力值近乎于无限地增大，锐利的矛能轻松击破所有的盾），然后推演文明如何演进。作为科幻作品，本作的内部的逻辑能够自洽，设定严谨，有着深刻的社会学思辨，非常难得。这部动画的原作实在是太强了，以至于能掩盖掉动画制作的种种缺陷，所谓瑕不掩瑜。但是还是推荐所有对这部作品有兴趣的人优先去阅读原作，如果实在是不想读文字再来看动画，真的。</p><h2 id="紫罗兰永恒花园85">紫罗兰永恒花园：85</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202210062336150.jpeg" /></p><p>关键字：画面，京阿尼，奇幻</p><p>评分：85</p><p>锐评：这部是我看过的画面最强大的TV动画，没有之一。在视听领域，这部动画应该可以说是做到了极致。剧情的薄弱没有掩盖到视听方面给我带来的震撼。太可惜了，如果剧本能再好好打磨一下，应该可以说是神作了。我之前提到过我有每年看一部动画片跨年的习惯，这部是我在2019年12月31日看的。之后回家以后和朋友看了外传剧场版，应该是1月20号前后，从影院一出来，一看手机，冠神遍地开花，于是我的前途命运被彻底改变了（笑）</p><p>这一部分到20篇为止，之后的我会另开一贴更新，敬请期待。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于离散系统和Z变换的那些事</title>
    <link href="/2022/07/03/%E5%85%B3%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E5%92%8CZ%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/07/03/%E5%85%B3%E4%BA%8E%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E5%92%8CZ%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>离散系统和Z变换，与连续系统和Laplace变换很像，但也有些不同，可以对比学习。 本文合计5598字。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="离散时间信号与系统">离散时间信号与系统</h2><h3 id="常用基本序列">常用基本序列</h3><ol type="1"><li><p>单位样值序列（对应冲激函数） <span class="math display">\[\delta(n)=\begin{cases}1 &amp; n=0\\\\0 &amp; \text{others}\end{cases}\]</span> 于是，仿照把任意信号分解成冲激函数和的形式，我们可以把任意序列分解成单位样值序列的和的形式，并且这个操作比在连续函数里更直观，即： <span class="math display">\[x(n)=\sum_{m=-\infty}^{\infty} x(m)\delta(n-m) \]</span></p></li><li><p>单位阶跃序列（对应单位阶跃函数） <span class="math display">\[u(n)=\begin{cases}1 &amp; n\geq 0\\\\0 &amp; n&lt;0\end{cases}\]</span> 类似于单位冲激函数和单位阶跃函数的关系，有： <span class="math display">\[u(n)=\sum_{m=-\infty}^{n}\delta(m)\]</span> 和单位阶跃函数不同，<span class="math inline">\(u(0)\)</span>有明确定义，为<span class="math inline">\(1\)</span>.</p></li><li><p>矩形序列</p><p>矩形序列<span class="math inline">\(G_N(n)\)</span>指的是从0开始（含0），含<span class="math inline">\(N-1\)</span>个<span class="math inline">\(1\)</span>的序列，即： <span class="math display">\[G_N(n)=\begin{cases}1 &amp; n\in[0,n)\\\\0 &amp; \text{others}\end{cases}\]</span> 矩形序列是两个单位阶跃序列的组合。有： <span class="math display">\[G_N(n)=u(n)-u(n-N)\]</span></p></li><li><p>（单边）指数序列 <span class="math display">\[x(n)=a^nu(u)\]</span> 当<span class="math inline">\(|a|&lt;1\)</span>时收敛，<span class="math inline">\(|a|&gt;1\)</span>和<span class="math inline">\(a=-1\)</span>时发散。</p><p>当<span class="math inline">\(a&lt;0\)</span>时会在<span class="math inline">\(x\)</span>轴两侧摆动。</p></li><li><p>正弦序列</p><p>正弦序列是由正弦函数采样的序列，有： <span class="math display">\[x(n)=A\sin(\omega t+\varphi)|_{t=nT_s}=A\sin(\omega nT_s+\varphi)\]</span> 其中<span class="math inline">\(T_s\)</span>是采样周期。定义数字角频率： <span class="math display">\[\Omega=\omega T_s\]</span> 与正弦函数不同，正弦序列不一定是周期序列。当且仅当 <span class="math display">\[\frac{2\pi} {\Omega}\]</span> 是有理数时，正弦序列才是周期序列。</p></li></ol><h3 id="离散序列基本运算">离散序列基本运算</h3><p>一般的运算和连续信号（函数）没有多少区别。需要注意的是压扩运算。压扩运算需要去除某些点，或者补充某些0点。</p><h3 id="离散时间系统">离散时间系统</h3><p>离散时间系统的描述和连续时间系统差别不大。不同于连续时间系统中常用积分器，离散时间系统中常用延时器，其符号为一个方框中写了一个“D”，作用是输入<span class="math inline">\(x(n)\)</span>，输出<span class="math inline">\(x(n-1)\)</span>。</p><p>记忆与无记忆、线性与非线性、时变与时不变、稳定与不稳定的含义和连续时间系统没有区别。</p><h3 id="差分方程时域求解方法">差分方程时域求解方法</h3><p>离散时间系统的数学表达式常用差分方程来表示，一般差分方程的形式为： <span class="math display">\[a_0y(n)+a_1y(n-1)+\cdots+a_Ny(n-N)=b_0x(n)+b_1x(n-1)+\cdots+b_My(n-M)\]</span> 求解的过程和微分方程类似：首先将方程右边置0求得齐次解；然后根据激励信号的特点选取含待定系数的特解，代入方程求得特解；再将齐次解和特解相加得完全解；最后代入 <strong>初始条件</strong> 求待定系数。</p><ol type="1"><li><p>求齐次解</p><p>将方程右边置0，得： <span class="math display">\[\sum_{k=0}^Na_ky(n-k)=0\]</span> 特征方程为： <span class="math display">\[\sum_{k=0}^Na_k\lambda^{N-k}=0\]</span> 这是一个关于<span class="math inline">\(\lambda\)</span>的多项式方程。求解特征方程得到特征根<span class="math inline">\(\lambda_1\cdots\lambda_N\)</span>。</p><p>如果<span class="math inline">\(\lambda_i\)</span>是单根或者共轭复根，那么齐次解中含有一项： <span class="math display">\[C_i\lambda_i^n\]</span> 如果<span class="math inline">\(\lambda_j\)</span>是<span class="math inline">\(r\)</span>重根，那么齐次解中含有项： <span class="math display">\[C_1n^{r-1}\lambda_j^n+C_2n^{r-2}\lambda_j^n+\cdots+C_{r-1}n\lambda_j^n+C_r\lambda_j^n\]</span></p></li><li><p>选取特解</p><p>常见激励和它对应的特解如下：</p><table><thead><tr class="header"><th style="text-align: center;">激励<span class="math inline">\(x(n)\)</span></th><th style="text-align: center;">特解</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(n^m\)</span></td><td style="text-align: center;"><span class="math inline">\(\sum_{i=0}^m P_{m-i}n^{m-i}\)</span></td><td style="text-align: center;">所有特征根不为1</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(n^m\)</span></td><td style="text-align: center;"><span class="math inline">\(n^r\sum_{i=0}^m P_{m-i}n^{m-i}\)</span></td><td style="text-align: center;">1是<span class="math inline">\(r\)</span>重特征根</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(P\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>不是特征根</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(P_1n\lambda^n+P_0\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>是特征单根</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\sum_{i=0}^rP_{r-i}n^{r-i}\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span>是<span class="math inline">\(r\)</span>重特征根</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sin(\beta n)\)</span>或<span class="math inline">\(\cos(\beta t)\)</span></td><td style="text-align: center;"><span class="math inline">\(P\cos(\beta n)+Q\sin(\beta n)\)</span> 或 <span class="math inline">\(A\cos(\beta n-\theta)\)</span></td><td style="text-align: center;">其中<span class="math inline">\(Ae^{j\theta}=P+jQ\)</span>,<span class="math inline">\(e^{\pm j\theta}\)</span>不是特征根</td></tr></tbody></table></li></ol><blockquote><p>【例】求解差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>， <strong>起始条件</strong> 为<span class="math inline">\(y(-2)=\frac12,y(-1)=0\)</span>。</p><p>【解】特征方程为： <span class="math display">\[\lambda^2+3\lambda+2=0\]</span> 特征根为 <span class="math display">\[\lambda_1=-1,\lambda_2=-2\]</span> 则齐次解为 <span class="math display">\[y_h(h)=C_1(-1)^n+C_2(-2)^n\]</span> 由于<span class="math inline">\(x(n)=2^n\)</span>，2不是特征根，选特解形式为 <span class="math display">\[y_p(n)=P\cdot2^n\]</span> 代入方程，有： <span class="math display">\[P\cdot2^n+3P\cdot2^{n-1}+2P\cdot 2^{n-2}=2^n\]</span> 两边同时除以<span class="math inline">\(2^n\)</span>，有： <span class="math display">\[3P=1\]</span> 得特解： <span class="math display">\[y_p(n)=\frac 13\cdot2^n\]</span> 则完全解形式为： <span class="math display">\[y(n)=C_1(-1)^n+C_2(-2)^n+\frac 13\cdot 2^n\]</span> 代入初始条件.因为方程右边的激励只在<span class="math inline">\(n\geq0\)</span>处有定义，我们要把已知的<span class="math inline">\(y(-1),y(-2)\)</span>转换成<span class="math inline">\(y(0),y(1)\)</span>.有： <span class="math display">\[\begin{cases}y(0)+3y(-1)+2y(-2)=x(0)\\\\y(1)+3y(0)+2y(-1)=x(1)\end{cases}\]</span> 得： <span class="math display">\[y(0)=0,y(1)=2\]</span> 将上述条件代入完全解形式，得： <span class="math display">\[\begin{cases}C_1+C_2+\frac 13=0\\\\-C_1-2C_2+\frac 23=1\end{cases}\]</span> 于是可解得完全解： <span class="math display">\[y(n)=\frac 23(-1)^n -(-2)^n +\frac 13 \cdot2^n \ \ n\geq 0\]</span></p></blockquote><h3 id="零输入和零状态响应">零输入和零状态响应</h3><ol type="1"><li><p>零输入响应</p><p>零输入响应就是只考虑起始状态，而把输入置0时，系统的响应。也就是 <span class="math display">\[\begin{cases}\sum_{i=0}^N a_iy_{zi}(n-i)=0\\\\[2ex]y_{zi}(-1)=y(-1)\\\\y_{zi}(-2)=y(-2)\\\\\cdots\\\\y_{zi}(-N)=y(-N)\end{cases}\]</span> 的解。其中<span class="math inline">\(y_{zi}\)</span>表示零输入（Zero Input）。</p></li><li><p>零状态响应</p><p>零状态响应的意思是起始状态全为0，仅仅考虑外加激励，所引起的响应。也就是 <span class="math display">\[\begin{cases}\sum_{i=0}^N a_iy_{zs}(n-i)=\sum_{i=0}^N b_ix(n-i)\\\\y(-1)=y(-2)=\cdots=0\end{cases}\]</span> 其中<span class="math inline">\(y_{zs}(n)\)</span>表示零状态（Zero State）。</p></li></ol><p>可以通过零输入响应和零状态响应求和的办法求解全响应。</p><blockquote><p>【例】求解差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>，初始条件为<span class="math inline">\(y(0)=1,y(1)=2\)</span>。</p><p>【解】特征方程为： <span class="math display">\[\lambda^2+3\lambda+2=0\]</span> 特征根为 <span class="math display">\[\lambda_1=-1,\lambda_2=-2\]</span> 则齐次解为 <span class="math display">\[y_h(n)=C_1(-1)^n+C_2(-2)^n\]</span> 因为初始条件包含了激励信号的影响，因此需要求出起始条件为： <span class="math display">\[y(-2)=\frac12,y(-1)=0\]</span> 则有： <span class="math display">\[\begin{cases}C_1(-1)^{-1}+C_2(-2)^{-1}=0\\\\C_1(-1)^{-2}+C_2(-2)^{-2}=\frac 12\\\\\end{cases}\]</span> 解得零输入响应为： <span class="math display">\[y_{zi}(n)=(-1)^n-2(-2)^n\]</span> 然后求零状态响应。由于<span class="math inline">\(x(n)=2^n\)</span>，2不是特征根，选特解形式为 <span class="math display">\[y_p(n)=P\cdot2^n\]</span> 代入方程，有： <span class="math display">\[P\cdot2^n+3P\cdot2^{n-1}+2P\cdot 2^{n-2}=2^n\]</span> 两边同时除以<span class="math inline">\(2^n\)</span>，有： <span class="math display">\[3P=1\]</span> 得特解： <span class="math display">\[y_p(n)=\frac 13\cdot2^n\]</span> 则零状态响应的形式为： <span class="math display">\[y_{zs}(n)=D_1(-1)^n+D_2(-2)^n+\frac 13 \cdot 2^n\]</span></p><p>因为求解的是零状态响应，因此此时系统的初始条件为：<span class="math inline">\(y(-1)=y(-2)=0\)</span>。代入差分方程，得初始条件： <span class="math display">\[y_{zs}(0)=0,y_{zs}(1)=1\]</span> 代入待定系数，解得： <span class="math display">\[y_{zs}(n)=-\frac 13(-1)^n+(-2)^n +\frac 13 \cdot (2^n)\]</span> 则全响应为 <span class="math display">\[\begin{aligned}y(n)&amp;=y_{zi}(n)+y_{zs}(n)\\\\&amp;=\frac 23(-1)^n -(-2)^n +\frac 13 \cdot2^n \ \ n\geq 0\end{aligned}\]</span></p></blockquote><h3 id="单位样值响应">单位样值响应</h3><p>单位响应就是激励信号是<span class="math inline">\(\delta(n)\)</span>时的零状态响应。它具有齐次解的形式，而且具有固定起始条件，即： <span class="math display">\[h(-N+1)=0,h(-N+2)=0,\cdots,h(0)=1\]</span></p><blockquote><p>【例】求以下系统的单位样值响应 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=2x(n-1)+x(n-2)\]</span> 【解】先求系统 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 的单位样值响应<span class="math inline">\(h_1\)</span>，再由线性时不变特性求<span class="math inline">\(h(n)\)</span>.</p><p>齐次解的形式为： <span class="math display">\[h_1(n)=[C_1(-1)^n+C_2(-2)^n]u(n)\]</span> 代入固定起始条件<span class="math inline">\(h(-1)=0,h(0)=1\)</span>： <span class="math display">\[\begin{cases}-C_1-\frac 12 C_2=0\\\\C_1+C_2=1\end{cases}\]</span> 得： <span class="math display">\[h_1(n)=[(-1)^(n+1)+2(-2)^n]u(n)\]</span> 有： <span class="math display">\[\begin{aligned}h(n)&amp;=2h_1(n-1)+h_1(n-2)\\\\&amp;=2[(-1)^n+2(-2)^{n-2}]u(n-1)+[(-1)^{n-1}+2(-2)^{n-2}]u(n-2)\\\\&amp;=\frac {\delta(n)}2+(-1)^nu(n)-1.5(-2)^nu(n)\end{aligned}\]</span></p></blockquote><h3 id="卷积和">卷积和</h3><p>两个序列<span class="math inline">\(x(n)\)</span>和<span class="math inline">\(h(n)\)</span>的“卷积和”定义如下： <span class="math display">\[y(n)=x(n)\bigotimes h(n)=\sum_{m=-\infty}^\infty x(m)h(n-m)\]</span> 卷积和具有交换律、结合律、分配律，此外，还有：</p><ol type="1"><li><p>移不变性 <span class="math display">\[x_1(n-m)\bigotimes x_2(n+k)=y(n-m+k)\]</span></p></li><li><p>序列和单位样值序列的卷积 <span class="math display">\[x(n)\bigotimes h(n-m)=x(n-m)\]</span></p></li><li><p>序列和单位阶跃序列的卷积 <span class="math display">\[x(n)\bigotimes u(n)=\sum_{i=-\infty}^n x(n)\]</span></p></li></ol><p>在计算两个有限长度序列的卷积时，可以像列乘法竖式一样，先把两个序列右对齐，然后算“乘法”（只是不进位），即：</p><ol type="1"><li>两序列右对齐</li><li>逐个样值对应相乘，不进位</li><li>同列乘积相加</li></ol><p>得到的结果<span class="math inline">\(y(n)\)</span>的第一个数的下标是两个原始序列的第一个数的下标的和。</p><p>对于无穷长序列一般只能通过定义公式计算。</p><h2 id="离散时间信号与系统变换域分析">离散时间信号与系统变换域分析</h2><h3 id="z变换"><span class="math inline">\(Z\)</span>变换</h3><p>类似于拉普拉斯变换，Z变换也分为双边和单边。</p><p>双边<span class="math inline">\(Z\)</span>变换的定义如下： <span class="math display">\[X(z)={\mathscr Z}[x(n)]=\sum_{n=-\infty}^\infty x(n)z^{-n}\]</span> 单边<span class="math inline">\(Z\)</span>变换的定义如下： <span class="math display">\[X(z)={\mathscr Z}[x(n)]=\sum_{n=0}^\infty x(n)z^{-n}\]</span></p><p>那么为什么和拉普拉斯变换这么像呢？这是因为<span class="math inline">\(Z\)</span>变换可以从拉普拉斯变换导出。</p><p>考虑对一个连续时间信号<span class="math inline">\(x(t)\)</span>进行时间间隔为<span class="math inline">\(T\)</span>的理想冲激抽样，抽样所得的信号记为<span class="math inline">\(x_s(t)\)</span>，则有： <span class="math display">\[x_s(t)=x(t)\cdot \delta_T(t)=\sum_{n=-\infty}^\infty x(nT)\delta(t-nT)\]</span> 对上式取<span class="math inline">\(Z\)</span>变换，有： <span class="math display">\[X_s(s)={\mathscr L}[x_s(t)]=\int_{0}^{\infty}\left[\sum_{n=-\infty}^\infty x(nT)\delta(t-nT)\right]e^{-st} {\mathbf d}t\]</span> 对调积分求和、利用冲激函数性质，有： <span class="math display">\[X_s(s)=\sum_{n=-\infty}^\infty x(nT)e^{-snT} \]</span> 设<span class="math inline">\(z=e^{sT}\)</span>，由于<span class="math inline">\(T\)</span>是给定常数，则<span class="math inline">\(z\)</span>是<span class="math inline">\(s\)</span>的函数，则有： <span class="math display">\[X_s(z)=\sum_{n=-\infty}^\infty x(nT)z^{-n}\]</span> 在一般的离散系统中，让<span class="math inline">\(T=1\)</span>，则有： <span class="math display">\[X_s(z)=\sum_{n=-\infty}^{\infty} x(n)z^{-n}\]</span> 一个序列的<span class="math inline">\(Z\)</span>变换，实际上是一个系数为这个序列的样值，变量为<span class="math inline">\(z^{-1}\)</span>的幂级数。即： <span class="math display">\[X(z)=\cdots+x(-2)z^2+x(-1)z^1+x(0)z^0+x(1)z^{-1}+x(2)z^{-2}+\cdots\]</span></p><h3 id="z变换的收敛域"><span class="math inline">\(Z\)</span>变换的收敛域</h3><p>既然是从拉普拉斯变换导出来的，而且还是幂级数，那就不得不讨论收敛域。</p><p>复习一下，分析里面判断级数收敛有很多方法，其中最常用的有达朗贝尔判别法，即对于变号级数， <span class="math display">\[\lim_{n\to \infty} \left|\frac{x(n+1)z^{-(n+1)} } {x(n)z^{-n} }\right|=\rho\]</span> 如果<span class="math inline">\(\rho&lt;1\)</span>，那么绝对收敛；如果<span class="math inline">\(\rho&gt;1\)</span>，那么发散。</p><p>结合拉普拉斯变换，我们把序列分成左边序列，右边序列，双边序列来讨论。由于 <span class="math display">\[z=e^{s}\]</span> 我们可以通过下图的方法来建立S平面和Z平面的联系。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/AAC37E072C27DA06CC75C6F0EE4975D9.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>有：</p><table><thead><tr class="header"><th>序列（函数）类型</th><th>Z变换收敛性形状</th><th>拉普拉斯变换收敛域形状</th></tr></thead><tbody><tr class="odd"><td>右边</td><td>以原点为中心的圆之外 <span class="math inline">\(\|z\|&gt;\|a\|\)</span></td><td>右半平面 <span class="math inline">\(Re[s]&gt;\alpha\)</span></td></tr><tr class="even"><td>左边</td><td>以原点为中心的圆之内 <span class="math inline">\(\|z\|&lt;\|b\|\)</span></td><td>左半平面 <span class="math inline">\(Re[s]&lt;\beta\)</span></td></tr><tr class="odd"><td>两边</td><td>以原点为圆心的圆环 <span class="math inline">\(\|z\|\in(a,b)\)</span></td><td>条带 <span class="math inline">\(Re[s]\in (\alpha,\beta)\)</span></td></tr></tbody></table><p>对于有限长的序列，收敛域是除去零点和无穷远点的整个Z平面。</p><h3 id="常见序列的z变换">常见序列的<span class="math inline">\(Z\)</span>变换</h3><table><thead><tr class="header"><th>序列名称</th><th>序列表达式</th><th><span class="math inline">\(Z\)</span>变换</th><th>收敛域</th></tr></thead><tbody><tr class="odd"><td>单位样值序列</td><td><span class="math inline">\(\delta(n)=(n=0)?1:0\)</span></td><td><span class="math inline">\(1\)</span></td><td>全平面</td></tr><tr class="even"><td>单位阶跃序列</td><td><span class="math inline">\(u(n)=(n\geq 0)?1:0\)</span></td><td><span class="math inline">\(\frac{z} {z-1}\)</span></td><td><span class="math inline">\(\|z\|&gt;1\)</span></td></tr><tr class="odd"><td>因果指数序列</td><td><span class="math inline">\(x(n)=a^nu(n)\)</span></td><td><span class="math inline">\(\frac{z} {z-a}\)</span></td><td><span class="math inline">\(\|z\|&gt;\|a\|\)</span></td></tr></tbody></table><h3 id="z变换的性质"><span class="math inline">\(Z\)</span>变换的性质</h3><p>设 <span class="math display">\[{\mathscr Z}[x(n)]=X(z),|z|\in(\alpha,\beta)\]</span></p><h4 id="时域性质">时域性质</h4><ol type="1"><li><p>反褶性质 <span class="math display">\[{\mathscr Z}[x(-n)]=X(z^{-1}),|z|\in(\frac 1\beta,\frac 1\alpha)\]</span></p></li><li><p>扩展性质 <span class="math display">\[{\mathscr Z}\left[x\left(\frac na \right)\right]=X(z^a),|z|\in (\alpha^{\frac 1a},\beta ^{\frac 1a})\]</span></p></li><li><p>位移性质</p><ol type="1"><li><p>单边</p><p>若<span class="math inline">\(x(n)\)</span>是双边序列，有： <span class="math display">\[{\mathscr Z}[x(n)u(n)]=X(z) ,|z|&gt;a\]</span> 则有： <span class="math display">\[{\mathscr Z}[x(n+m)u(n)]=z^m\left[ X(z)-\sum_{k=0}^{m-1} x(k)z^{-k} \right]\\\\{\mathscr Z}[x(n-m)u(n)]=z^{-m}\left[ X(z)+\sum_{k=-m}^{-1} x(k)z^{-k} \right]\\\\\]</span> 请注意这里的“位移”：<span class="math inline">\(x(n-m)u(n)\)</span>和拉普拉斯变换里的“位移”<span class="math inline">\(f(t-t_0)u(t-t_0)\)</span>，以及傅里叶变换里的“位移”<span class="math inline">\(f(t-t_0)\)</span>的区别。</p><p>特别的，如果<span class="math inline">\(x(n)\)</span>是因果序列，那么有： <span class="math display">\[\begin{aligned}{\mathscr Z}[x(n+m)u(n)]&amp;=z^m\left[ X(z)-\sum_{k=0}^{m-1} x(k)z^{-k} \right]\\\\{\mathscr Z}[x(n-m)u(n)]&amp;=z^{-m}X(z)\end{aligned}\]</span></p></li><li><p>双边</p><p>双边位移性质比较简单。 <span class="math display">\[{\mathscr Z}[x(n\pm m)]=z^{\pm m}X(z),|z|\in(\alpha,\beta)\]</span></p></li></ol></li><li><p>线性性质</p></li></ol><h4 id="频域性质">频域性质</h4><ol type="1"><li><p><span class="math inline">\(Z\)</span>域微分-序列线性加权 <span class="math display">\[{\mathscr Z}[n\cdot x(n)]=-z\frac{ {\mathbf d}X(z)} { {\mathbf d}z}\]</span></p></li><li><p><span class="math inline">\(Z\)</span>域压扩-序列指数加权 <span class="math display">\[{\mathscr Z}[a^n x(n)]=X\left(\frac za\right),\alpha&lt;\left|\frac za\right|&lt;\beta\]</span> 特殊的，如果要实现<span class="math inline">\(Z\)</span>域反褶运算，有： <span class="math display">\[{\mathscr Z}[(-1)^nx(n)]=X(-z)\]</span></p></li></ol><h4 id="其它性质">其它性质</h4><ol type="1"><li><p>时域卷积 <span class="math display">\[{\mathscr Z}[x_1(n)\bigotimes x_2(n)]=X_1(z)X_2(z)\]</span></p></li><li><p>初值定理</p><p>对于因果序列 <span class="math display">\[x(0)=\lim_{z\to \infty} X(z)\]</span></p></li><li><p>终值定理 <span class="math display">\[x(\infty)=\lim_{z\to 1}[(z-1)X(z)]\]</span></p></li></ol><h3 id="利用z变换性质求其它常用序列的z变换">利用<span class="math inline">\(Z\)</span>变换性质求其它常用序列的<span class="math inline">\(Z\)</span>变换</h3><ol type="1"><li><p>单位样值序列的平移<span class="math inline">\(\delta(n-m)\)</span></p><p>由时移性质，有： <span class="math display">\[{\mathscr Z}[\delta(n-m)]=z^{-m}\]</span></p></li><li><p>斜变序列<span class="math inline">\(x(n)=nu(n)\)</span></p><p>由<span class="math inline">\(Z\)</span>域微分-线性加权性质，有： <span class="math display">\[{\mathscr Z}[nu(n)]=-z\frac{ {\mathbf d} } {\mathbf dz}\left(\frac {z} {z-1}\right)=\frac{z} {(z-1)^2}\]</span></p></li><li><p>因果余弦序列<span class="math inline">\(x(n)=\cos(\omega_0 n)u(n)\)</span></p><p>由欧拉公式： <span class="math display">\[\cos(\omega_0 n)=\frac 12 \left(e^{j\omega_0n}+e^{-j\omega_0 n}\right)\]</span> 和已知的公式 <span class="math display">\[{\mathscr Z}[\left(e^{\pm j\omega_0}\right)^nu(n)]=\frac{z} {z-e^{\pm j\omega_0} },|z|&gt;1\]</span> 结合线性性质，得 <span class="math display">\[{\mathscr Z}[\cos(\omega_0 n)u(n)]=\frac{z^2 -z\cos(\omega_0)} {z^2-2z\cos \omega_0+1},|z|&gt;1\]</span> 同理，因果正弦序列为： <span class="math display">\[{\mathscr Z}[\sin(\omega_0 n)u(n)]=\frac{z\sin(\omega_0)} {z^2-2z\cos \omega_0+1},|z|&gt;1\]</span></p></li></ol><h3 id="逆z变换的求解">逆<span class="math inline">\(Z\)</span>变换的求解</h3><p>一般的线性时不变系统的<span class="math inline">\(Z\)</span>变换表达式往往具有有理多项式的形式。</p><h4 id="长除法">长除法</h4><p>长除法的意思就是根据<span class="math inline">\(Z\)</span>变换的定义，直接求解幂级数的系数，从而求解原始序列。</p><p>当收敛域形式为<span class="math inline">\(|z|&gt;a\)</span>时，幂级数表现出洛朗级数的形式，序列是右边序列，此时应把分母整理成降幂形式，再做长除法。</p><p>当收敛域形式为<span class="math inline">\(|z|&lt;b\)</span>时，幂级数表现出泰勒级数的形式，序列是左边序列，此时应把分母整理成升幂形式，再做长除法。</p><p>这种长除法只能得到序列的部分样值，而且多用于单边<span class="math inline">\(z\)</span>变换。对于双边<span class="math inline">\(z\)</span>变换，一般用部分分式展开法。</p><h4 id="部分分式分解法">部分分式分解法</h4><p>部分分式分解法的核心思想是把有理多项式分式分解成基本分式 <span class="math display">\[\frac{kz} {z-a}\]</span> 的和，然后由于 <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {z-a}\right]=ka^nu(n),|z|&gt;a\]</span> 或者 <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {z-a}\right]=-ka^nu(-n-1),|z|&lt;a\]</span> 来求解原始序列。</p><blockquote><p>【例】求解： <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{5z} {-3z^2+7z-2}\right]\]</span> 分收敛域为：(1) <span class="math inline">\(|z|&gt;2\)</span> (2) <span class="math inline">\(|z|\in (\frac 13 , 2)\)</span>两种情况。</p><p>【解】首先对 <span class="math display">\[\frac{X(z)} {z}=\frac{5} {-3z^2+7z-2}\]</span> 进行分解，过程略，如果不会请参考拉普拉斯变换部分相关内容。有： <span class="math display">\[\frac{X(z)} {z}=\frac{-1} {z-2}+\frac{1} {z-\frac{1} {3} }\]</span> 则： <span class="math display">\[X(z)=\frac{-z} {z-2}+\frac{z} {z-\frac{1} {3} }\]</span></p><ol type="1"><li><p>收敛域为<span class="math inline">\(|z|&gt;2\)</span></p><p>此时，有： <span class="math display">\[x(n)=-2^nu(n)+\left(\frac 13\right)^nu(n)\]</span></p></li><li><p>收敛域为<span class="math inline">\(|z|\in \left(\frac 13,2\right)\)</span></p><p>这时要考虑两个分式分别代表的收敛域是什么。因为线性组合的收敛域是各项的收敛域的交集。我们经分析，得：第一项对应收敛域<span class="math inline">\(|z|&lt;2\)</span>，第二项对应收敛域<span class="math inline">\(|z|&gt;\frac 13\)</span>。(如果反过来，那么收敛域就是空集，这和题目不符)，因此： <span class="math display">\[x(n)=2^nu(-n-1)+\left(\frac 13\right)^nu(n)\]</span></p></li></ol></blockquote><p>对于右边序列，如果出现共轭复根的情况，即 <span class="math display">\[\frac{kz} {z^2+a}\]</span> 则有 <span class="math display">\[\begin{aligned}\frac{kz} {z^2+a}&amp;=\frac{\frac{k} {\sqrt a}\cdot \frac{z} {\sqrt a} } {\left(\frac z{\sqrt a}\right)^2+1}\\\\&amp;=\frac{k} {\sqrt a}\frac{\frac{z} {\sqrt a}\sin \frac \pi 2} {\left(\frac z{\sqrt a}\right)^2-2\left(\frac z{\sqrt a}\right)\cos\frac \pi 2 +1}\\\\&amp;\to \frac{k} {\sqrt a}\cdot \sqrt{a}^n\cdot \sin\left(\frac{\pi} {2}n\right)u(n)\end{aligned}\]</span> 可以使用<code>mathematica</code>验证上述推导，输入：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">ZTransform</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">a</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">^</span><span class="hljs-punctuation">(</span><span class="hljs-variable">n</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">n</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">*</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">n</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-variable">n</span><span class="hljs-operator">,</span> <span class="hljs-variable">z</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>输出： <span class="math display">\[\frac{k z} {a+z^2}\]</span> 对于2阶重极点，有： <span class="math display">\[{\mathscr Z}^{-1}\left[\frac{kz} {(z-a)^2}\right]=a^{n-1}knu(n)\]</span> 对于更高阶的极点，有： <span class="math display">\[{\mathscr Z}\left[\frac{kz} {(z-a)^r}\right]=\frac{k} {(r-1)!}a^{n-r+1}\prod_{i=0}^{r-2}(n-i)=k a^{n-r+1} \binom{n} {r-1}\]</span></p><h3 id="用z变换求解差分方程">用<span class="math inline">\(Z\)</span>变换求解差分方程</h3><p>一般差分方程的形式如下： <span class="math display">\[\sum_{k=0}^N a_ky(n-k)=\sum_{r=0}^M b_rx(n-r)\]</span> 对等式两边取<span class="math inline">\(Z\)</span>变换： <span class="math display">\[\sum_{k=0}^N a_kz^{-k}\left[Y(z)+\sum_{l=-k}^{-1}y(l)z^{-l}\right]=\sum_{r=0}^M b_rz^{-r}\left[X(z)+\sum_{m=-r}^{-1}x(m)z^{-m}\right]\]</span> 则系统全响应（的<span class="math inline">\(Z\)</span>变换）为： <span class="math display">\[Y(z)=\frac{\sum_{r=0}^M b_rz^{-r}\left[X(z)+\sum_{m=-r}^{-1}x(m)z^{-m}\right]} {\sum_{k=0}^Na_kz^{-k} }-\frac{\sum_{k=0}^N\left[a_kz^{-k}\cdot\sum_{l=-k}^{-1}y(l)z^{-l}\right]} {\sum_{k=0}^Na_kz^{-k} }\]</span> 其中第一项代表零状态响应，第二项代表零输入响应。</p><p>......麻了没？这么多分式，<span class="math inline">\(\sum\)</span>，我打着都麻。其实这玩意很简单的，下面通过一个例题给大家表演一下。</p><blockquote><p>【例】差分方程 <span class="math display">\[y(n)+3y(n-1)+2y(n-2)=x(n)\]</span> 其中激励为<span class="math inline">\(x(n)=2^n,n\geq 0\)</span>， <strong>起始条件</strong> 为<span class="math inline">\(y(-2)=2,y(-1)=0\)</span>。求零输入、零状态和全响应。</p><p>【解】对方程两边取<span class="math inline">\(Z\)</span>变换，有： <span class="math display">\[Y(z)+3\left[z^{-1}Y(z)+y(-1)\right]+2\left[z^{-2}Y(z)+y(-2)+y(-1)z^{-1}\right]=X(z)\]</span> 代入数据： <span class="math display">\[(1+3z^{-1}+2z^{-2})Y(z)+4=\frac{z} {z-2}\]</span> 则： <span class="math display">\[\begin{aligned}Y(z)&amp;=\frac {-4} {1+3z^{-1}+2z^{-2} }+\frac{1} {1+3z^{-1}+2z^{-2} }\frac{z} {z-2}\\\\&amp;=\frac{-4z^2} {z^2+3z+2}+\frac{z^2} {z^2+3z+2}\frac{z} {z-2}\end{aligned}\]</span> 其中第一项代表零状态响应，第二项代表零输入响应。有： <span class="math display">\[Y_{zi}(z)=\frac{4z} {z+1}+\frac{-8z} {z+2}\]</span></p><p><span class="math display">\[Y_{zs}(z)=\frac{-\frac 13 z} {z+1}+\frac{z} {z+2}+\frac{\frac 13 z} {z-2}\]</span></p><p>则： <span class="math display">\[y_{zi}(n)=4(-1)^n-8(-2)^n\\\\y_{zs}(n)=-\frac 13 (-1)^n+(-2)^n+\frac 13 (2)^n\]</span> (<span class="math inline">\(n\geq 0\)</span>)</p></blockquote><h3 id="离散系统传递函数">离散系统传递函数</h3><p>就是单位样值响应（零状态）<span class="math inline">\(h(n)\)</span>的<span class="math inline">\(Z\)</span>变换<span class="math inline">\(H(z)\)</span>,一般有如下形式：</p><p><span class="math display">\[H(z)=\frac{\sum_{r=0}^M b_rz^{-r} } {\sum_{k=0}^N a_kz^{-k} }=G\frac{\prod _{r=1}^M (1-o_rz^{-1})} {\prod_{k=0}^N (1-p_kz^{-1})}\]</span></p><p>其中<span class="math inline">\(o\)</span>就是零点，<span class="math inline">\(p\)</span>就是极点。对于因果序列而言，极点分布和<span class="math inline">\(h(n)\)</span>大致时域形状的关系如下：</p><table><thead><tr class="header"><th><span class="math inline">\(H(z)\)</span>极点位置</th><th><span class="math inline">\(h(n)\)</span>时域形状</th></tr></thead><tbody><tr class="odd"><td>单位圆内实数</td><td>指数衰减序列</td></tr><tr class="even"><td>单位圆内共轭复数</td><td>衰减的正弦序列</td></tr><tr class="odd"><td>单位圆外实数</td><td>指数增长序列</td></tr><tr class="even"><td>单位圆外共轭复数</td><td>增长的正弦序列</td></tr><tr class="odd"><td>单位圆上实数</td><td>常序列（一阶）或逐渐增大</td></tr><tr class="even"><td>单位圆上共轭复数</td><td>幅度为常数或逐渐增大的正弦序列</td></tr></tbody></table><p>由此可以看出极点分布和系统稳定性的关系。另外，这个表也可以由<span class="math inline">\(s-z\)</span>平面变换得出。</p><p>至于因果性，那就更简单了。只要系统函数的极点分布在<span class="math inline">\(Z\)</span>平面内的一个半径有限的圆内就行，即保证收敛域为 <span class="math display">\[|z|&gt;R\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假计划</title>
    <link href="/2022/07/02/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/"/>
    <url>/2022/07/02/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>雄心壮志！！</p><span id="more"></span><h2 id="游戏">游戏</h2><ul><li>苍之彼方的四重奏</li><li>梅时露霁书~雨潺海汐间~</li><li>传送门</li><li>传送门2</li><li>Outer Wildes</li><li>OPUS龙脉常歌</li></ul><h2 id="动画片">动画片</h2><ul><li>无职转生</li><li>相合之物</li><li>白箱</li><li>奇诺之旅</li><li>摇曳露营2</li></ul><h2 id="书">书</h2><ul><li>科幻世界</li><li>固守与超越</li></ul><p>啊嗯，宏伟的计划！</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于分离变量法和物质极化的那些事</title>
    <link href="/2022/07/01/%E5%87%89%E5%AE%AB%E7%A7%8B%E6%9C%88/"/>
    <url>/2022/07/01/%E5%87%89%E5%AE%AB%E7%A7%8B%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<p>这部分写的有点混乱，主要原因是我自己也没搞得太明白。还是希望大家多多在评论里交流。</p><span id="more"></span><p>[toc]</p><h2 id="静电位拉普拉斯方程的变量可分离解">静电位拉普拉斯方程的变量可分离解</h2><p>拉普拉斯方程： <span class="math display">\[\nabla^2\Phi=0\]</span></p><h3 id="直角坐标系中">直角坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=X(x) Y(y) Z(z)=(A x+B)(C y+D)(E z+F)\]</span> 一般解： <span class="math display">\[\Phi(x, y, z)=\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{x} x\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{y} y\left\{\begin{array}{l}\sin \\\cos \\== \\e^{\pm} \\\sinh \\\cosh\end{array}\right\} K_{z} z\]</span> 满足： <span class="math display">\[\pm K_x^2\pm K_y^2\pm K_z^2=0\]</span> 选试探解时，必须从分割线两边选取，不能只取一边。</p><h3 id="柱坐标系中">柱坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=\left(A+B \ln r_ { c } \right)(C+D \varphi)(F+G z)\]</span> 其中第一项的物理意义是：<span class="math inline">\(z\)</span>方向上无限长均匀带电直线线电荷周围的电场。</p><p>一般解： <span class="math display">\[\Phi(\vec { r } )=\left(A r_ { C } ^ { n } +B r_ { C } ^ { -n } \right)(C \sin n \varphi+D \cos n \varphi)\]</span> 其物理意义如下：</p><ol type="1"><li><span class="math inline">\(n=1,B=C=0\)</span>：<span class="math inline">\(x\)</span>方向匀强电场</li><li><span class="math inline">\(n=1,B=D=0\)</span>：<span class="math inline">\(y\)</span>方向匀强电场</li><li><span class="math inline">\(n=1,A=C=0\)</span>​：沿着<span class="math inline">\(x\)</span>轴放置的二维电偶极子</li><li><span class="math inline">\(n=1,A=D=0\)</span>：沿着<span class="math inline">\(y\)</span>轴放置的二维电偶极子</li><li>对于整数<span class="math inline">\(n\)</span>，系统是一个<span class="math inline">\(2n\)</span>偶极子。当<span class="math inline">\(A\neq 0\)</span>时， 有放置在无穷远处多极子形式；当<span class="math inline">\(B\neq0\)</span>时，有放置在原点的多极子形式</li></ol><p>需要注意的是：上述系统的总电荷量都是0，只有平凡解中式<span class="math inline">\(\left(A+B \ln r_ { c } \right)\)</span>对应的系统总电荷量不为零。因此，系统有没有净电荷，可以作为判断要不要取<span class="math inline">\(\left(A+B \ln r_ { c } \right)\)</span>的依据。</p><h3 id="球坐标系中">球坐标系中</h3><p>平凡解： <span class="math display">\[\Phi(\vec { r } )=\left(A+\frac { B }  { r_ { s }  } \right)\left[C+D \ln \left(\tan \frac { \theta }  { 2 } \right)\right](F+G \varphi)\]</span> 其物理意义为：</p><ol type="1"><li>第一项表示了位于原点的点电荷</li><li>第二项是在一个空间两圆锥面之间夹着的区域的电荷分布</li><li>第三项是空间角域的电荷分布</li></ol><p>一般解： <span class="math display">\[\Phi(\vec { r } ) =\left[A r_ { S } ^ { n } +\frac { B }  { r_ { S } ^ { n+1 }  } \right] P_ { n } ^ { m } (\cos \theta)(C \sin m \varphi+D \cos m \varphi)\ \ (m\leq n)\]</span> 如果系统的总电荷量为0，它的电位中就不可能有$ { r_s } <span class="math inline">\(出现，因此只会有一般解中\)</span>n<span class="math inline">\(的形式出现。如果一个系统中总电荷量不是0，那么就可以有\)</span> { r_s } $出现。</p><h2 id="边界条件的选取规则">边界条件的选取规则</h2><h3 id="边界电位已知的系统">边界电位已知的系统</h3><p>直接写出边界上<span class="math inline">\(\Phi\)</span>等于已知的电位即可。</p><h3 id="带有自然边界条件的系统">带有自然边界条件的系统</h3><p>对于一个<strong>分布在有限区域的源</strong>（例如：给出某边界的电压表达式，在某表面上有电荷等），观察点离他越远，他对观察点的 <strong>场</strong> 的影响就越小。如果源在某个方向是无限的，那么在无限远处电位是常数，只有电场趋于零。如果源确实是有限的（例如：球面），那么可以认为电位在无穷远点是0，此时电场当然也是零。因此，有： <span class="math display">\[r\to \infty,E\to 0\]</span> 对于在某个方向无限的情况，特别地，如果在系统中给出了“地”，或者和地相连的零电位面，而且当前<span class="math inline">\(r\to \infty\)</span>的这个方向附近存在零电位面，那么这个条件很可能也可以被进一步加强为： <span class="math display">\[r\to \infty,\Phi\to 0\]</span> 在系统的原点处，往往有极值定理。这说明：在<span class="math inline">\(r=0\)</span>处，电位应该有限，即： <span class="math display">\[r\to 0,\Phi=0\]</span></p><h3 id="导数边界条件">导数边界条件</h3><p>在载流导体和空气的边界，电容器的边缘处，往往有： <span class="math display">\[\frac { \partial \Phi }  { \partial n } =0\]</span> 在有面自由电荷分布的边界上，有： <span class="math display">\[\varepsilon_0\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_0\frac { \partial \Phi_1 }  { \partial n } =\eta\]</span> 如果上面的情况是在两个电介质的交界处，有： <span class="math display">\[\varepsilon_0\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_0\frac { \partial \Phi_1 }  { \partial n } =\eta_f+\eta_p\]</span> 或 <span class="math display">\[\varepsilon_1\frac { \partial \Phi_2 }  { \partial n } -\varepsilon_2\frac { \partial \Phi_1 }  { \partial n } =\eta_f\]</span></p><p>在两个电导率不同的材料的交界面上，有： <span class="math display">\[\sigma_1\frac { \partial \Phi_1 }  { \partial n } =\sigma_1\frac { \partial \Phi_1 }  { \partial n } \]</span></p><h3 id="带有趋势性边界条件的静电系统">带有趋势性边界条件的静电系统</h3><p>近区：点电荷、电偶极子等，如果放在原点，那么<span class="math inline">\(r_s\to 0\)</span>时，电位趋向于点电荷和电偶极子的电荷。</p><p>远区：如果在一个看起来就很“大”的系统，例如：遍布于全空间的匀强电场中放入一个导体球，那么当<span class="math inline">\(r_s\to \infty\)</span>时，场分布应该和那么很“大”的系统一样。</p><h2 id="试探解的选取规则">试探解的选取规则</h2><h3 id="直角坐标系中-1">直角坐标系中</h3><p>首先确定：电位和哪些坐标量有关，和哪些坐标量无关。</p><p>然后，检查电位是否在某个方向线性变化。这里一般是看边界条件。如果确实线性变化，选平凡解。</p><p>然后，看系统在某坐标量上的零点个数。如果有超过1个零点，那么这个坐标量应该考虑三角函数形式。否则，可以考虑指数函数形式。需要特别注意的是：<span class="math inline">\(\cosh\)</span>函数是没有零点的。</p><p>然后，看对称性。三角函数中，<span class="math inline">\(\sin\)</span>是奇函数，<span class="math inline">\(\cos\)</span>是偶函数。在指数形式函数中，<span class="math inline">\(\sinh\)</span>是奇函数，<span class="math inline">\(\cosh\)</span>是偶函数。</p><h3 id="柱坐标系中-1">柱坐标系中</h3><p>在柱坐标系中确定<span class="math inline">\(n\)</span>的值时，应结合边界条件，看看边界条件中给出的是（例如）： <span class="math display">\[r_c=b,\Phi_1=\Phi_2=V_0\sin 2\varphi\]</span> 这时候<span class="math inline">\(n\)</span>就是2。如果边界条件是（例如）： <span class="math display">\[r_ { C } =R, \Phi_ { 1 } (\vec { r } )=\Phi_ { 2 } (\vec { r } )=V_ { 0 }  \cos \varphi\]</span> 这时候<span class="math inline">\(n\)</span>显然是<span class="math inline">\(1\)</span>，同时也可以确定<span class="math inline">\(C,D\)</span>的存在性。</p><p>如果系统中存在净电荷量，或者只和<span class="math inline">\(r_c\)</span>有关，那么可以考虑平凡解的<span class="math inline">\((A+B\ln r_c)\)</span>项。</p><h3 id="球坐标系中-1">球坐标系中</h3><p>首先也要确定<span class="math inline">\(n,m\)</span>的取值。如果系统和<span class="math inline">\(\phi\)</span>无关，那么这时候<span class="math inline">\(m\)</span>显然是0，这种情况很简单。如果不能确定，应看边界条件中有没有和勒让德函数形式契合的。如果有，那么<span class="math inline">\(n,m\)</span>的取值也随之确定。</p><p>如果系统和<span class="math inline">\(\theta,\varphi\)</span>看起来都没有关系，可以选取平凡解<span class="math inline">\((A+B/r_s)\)</span>。如果系统很契合“两个圆锥面”的物理情景，可选择平凡解的第二项。</p><h2 id="有物质存在时的场定律">有物质存在时的场定律</h2><h3 id="极化">极化</h3><h4 id="极化强度矢量">极化强度矢量</h4><p>定义式: <span class="math display">\[P=\lim_ { \Delta V\to 0 } \frac { \sum_ { i=1 } ^n p_i }  { \Delta V } \]</span> 其中ΔV是空间中的小体积元，pi是ΔV中一个电偶极子的电偶极矩。还有一个计算式： <span class="math display">\[P=\chi_e\varepsilon_0E\]</span> 其中<span class="math inline">\(\chi_e\)</span>是极化率。这个式子只有在非永久极化时才能使用。</p><h4 id="极化与高斯定律">极化与高斯定律</h4><p>有极化电荷密度： <span class="math display">\[\rho_P=-\nabla\cdot P\]</span> 由这个式子，可导出边界条件： <span class="math display">\[\eta_P=-i_n\cdot(P_1-P_2)\]</span> 宏观极化模型下的高斯定律： <span class="math display">\[\nabla\cdot(\varepsilon_0E+P)=\rho_f\]</span> 如果令电位移矢量<span class="math inline">\(D\)</span> <span class="math display">\[D=\varepsilon_0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=(1+\chi_e)\varepsilon_0E=\varepsilon_r\varepsilon_0E\]</span> 有： <span class="math display">\[\nabla\cdot D=\rho_f\]</span> 写成积分形式： <span class="math display">\[\oint_sD \mathrm { d } a=\iiint_v\rho_f \mathrm { d } V\]</span> 还可以导出以下两个边界条件： <span class="math display">\[i_n\cdot\varepsilon_0(E_1-E_2)=\eta_f+\eta_p\\i_n\cdot(D_1-D_2)=\eta_f\]</span></p><h4 id="极化与安培环路定律">极化与安培环路定律</h4><p>极化电流： <span class="math display">\[J_p=\frac { \partial P }  { \partial t } \]</span> 修正的安培环路定律： <span class="math display">\[\nabla\times H=J_f+\frac { \mathbf { d } D }  { \mathbf { d } t } \]</span> 积分形式： <span class="math display">\[\oint_cH\mathbf { d } s=\iint_sJ\mathbf { d } a+\frac { \mathbf { d }  }  { \mathbf { d } t } \iint_sD\mathbf { d } a\]</span></p><h4 id="求解问题思路">求解问题思路</h4><ol type="1"><li><p>永久极化问题</p><p>在永久极化的情况下，<span class="math inline">\(P=\chi_e\varepsilon_0E\)</span>不能用，这时候<span class="math inline">\(P\)</span>一般会直接告诉你。我们一般用 <span class="math display">\[\rho_P=-\nabla\cdot P\]</span> 求出极化电荷分布，然后把极化电荷当成电荷，用已知电荷求场的思路解决问题。</p></li><li><p>非永久极化问题</p><p>这时候一般用分离变量法求出场分布，然后再用<span class="math inline">\(D=\varepsilon E\)</span>求出电位移矢量，然后进一步求解极化电荷等等。</p></li></ol><h3 id="磁化">磁化</h3><p>这里只介绍磁荷模型，因为它可以导出电磁对偶关系。</p><h4 id="磁化强度矢量">磁化强度矢量</h4><p><span class="math display">\[M=\lim_ { \Delta V\to0 } \frac { \sum_ { i=1 } ^N m_i }  { \Delta V } \]</span></p><p>由电磁对偶关系（这里是<span class="math inline">\(\mu_0M\)</span>和<span class="math inline">\(P\)</span>对偶），就能直接得出：</p><p>磁荷密度： <span class="math display">\[\rho_M=-\nabla\cdot\mu_0M\]</span> 磁流密度： <span class="math display">\[J_M=\frac {   { \bf d }   }   {   {  \bf d  }  t  }  (\mu_0M)\]</span> 定义磁感应强度<span class="math inline">\(B\)</span>: <span class="math display">\[B=\mu_0(1+\chi_m)H=\mu H\]</span></p><h4 id="磁化与电磁感应定律">磁化与电磁感应定律</h4><p><span class="math display">\[\nabla \times E=-\frac { \partial B }  { \partial t } \]</span></p><p>积分形式： <span class="math display">\[\oint_cE  {  \bf d  }  s=-\frac {  { \bf d }  }  {  { \bf d } t } \iint_sB { \bf d } a\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220627-20220703）</title>
    <link href="/2022/06/27/%E5%91%A8%E8%AE%B0%EF%BC%8820220627-20220703%EF%BC%89/"/>
    <url>/2022/06/27/%E5%91%A8%E8%AE%B0%EF%BC%8820220627-20220703%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><hr /><h2 id="section">20220627</h2><p>今天应该是基本结束了信号的复习，接下来只需要刷题就好了。</p><p>其实我以及开始畅想暑假要学什么，玩什么，下学期要学什么，玩什么了，哈哈哈。</p><h2 id="section-1">20220628</h2><p>今天继续刷信号的题，把信号的试卷出完了。</p><p>今天随机到了珂朵莉的ed，使我又回忆起了高中的生活。也不知道将来刷到哪首歌时，会让我回忆起现在的生活呢？</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/C17FFB52A07BBB3E64407394300FB095.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>自从你航换了个党委书记以来，算是一天比一天阳间了，搞得我都想劝人报北航了，哈哈</p><h2 id="section-2">20220629</h2><p>完全不知道信号怎么复习，很恼怒。原因在于课本习题没答案。为什么习题会没有答案呢？没有答案的习题有什么意义呢？这不是管杀不管埋吗？世界上所有不带答案的习题都应该被扫进历史的垃圾篓。</p><p>今天在学校吃了个盖浇面，我其实很少在学校吃面，值得纪念。 <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/CC40121BE2038415C8AB4FAF54B42184.jpg" alt="img" /></p><p>相合之物还挺好看的，舒缓温馨，适合睡前看。</p><h2 id="section-3">20220630</h2><p>今天是疯狂星期四，大吃了一顿，爽。 <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/D464DF8998ED4A290E615EBA0C2003D1.jpg" alt="img" /></p><p>哎我真是服了这个2系，真是有意思，一个是你个线上虚拟仿真实验还要手写报告，还要把电路图打印下来再拍照上传？脱裤子放屁？？你说<span class="math inline">\(m\)</span>倍的以<span class="math inline">\(10\)</span>为底<span class="math inline">\(b\)</span>的对数呢？</p><p>一个是你考试，还不让用北航信纸，还非得用A4纸，还每页都得写《本人已知悉并将遵守.......相关内容》</p><p>对对对，还不让我扔期末答题纸，说是《开学上交》，真无语</p><h2 id="section-4">20220701</h2><p>放假咯！！</p><p>清华今天改了报备制，你航明天改，所以说</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/035D82F0B81D23332666DC2700B53EC1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><span class="math display">\[\text{北航}=\text{清华}\bigotimes \delta(t-1)\]</span></p><p>你航封了两个月，终于解封了，不知道这次能坚持多久。</p><h2 id="section-5">20220702</h2><p>哎，今天西安怎么突然出来一个阳性？本来还想带朋友来西安玩的......希望能快点好起来。</p><p>今天看完了《大决战》第一部，明天继续看第二部。</p><p>过两天，或者明天，试一下<code>Hugo</code></p><h2 id="section-6">20220703</h2><p>今天看完了大决战第二部，淮海战役。</p><p>今天换了个博客框架，感觉还挺好看的。</p><p><code>PicGO</code>的日志文件竟然有30G大，嫩逆天，不知道怎么搞的。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于傅里叶变换的那些事</title>
    <link href="/2022/06/27/%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/27/%E5%85%B3%E4%BA%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>所谓的变换，也就是信号的正交分解。如果两个函数的内积为<span class="math inline">\(0\)</span>，我们称为这两个函数正交。那么对于任意信号<span class="math inline">\(f(t)\)</span>，都可以写成一组正交函数系的和的形式（可以对比正交向量理解），这就是信号的正交分解。通过正交分解，可以对信号的特性有进一步的认识，也可以简化信号的分析和计算。</p><span id="more"></span><h2 id="傅里叶级数">傅里叶级数</h2><p>傅里叶级数是 <strong>周期信号</strong> 基于正交函数系<span class="math inline">\(\{e^{j\omega t}\}\)</span>的正交分解。</p><h3 id="三角函数形式的傅里叶级数">三角函数形式的傅里叶级数</h3><p>三角函数形式的傅里叶级数就是我们最熟悉的傅里叶级数。对于满足以下条件的函数<span class="math inline">\(f(t)\)</span>:</p><ul><li>周期函数，周期为<span class="math inline">\(T_1\)</span>，角频率为<span class="math inline">\(\omega_1=2\pi/T_1\)</span></li><li>间断点个数有限（可数）</li><li>极大极小值个数有限（可数）</li><li>绝对可积</li></ul><p>有： <span class="math display">\[f(t)=a_{0}+\sum_{n=1}^{\infty}\left(a_{n} \cos n \omega_{1} t+b_{n} \sin n \omega_{1} t\right)\]</span> 其中<span class="math inline">\(a_0\)</span>叫直流分量，<span class="math inline">\(a_n\)</span>叫<span class="math inline">\(n\)</span>次谐波余弦分量，<span class="math inline">\(b_n\)</span>叫<span class="math inline">\(n\)</span>次谐波正弦分量。有计算公式： <span class="math display">\[a_0=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \mathrm{d} t\]</span></p><p><span class="math display">\[a_n=\frac{2} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \cos n \omega_{1} t \mathrm{~d} t\]</span></p><p><span class="math display">\[b_n=\frac{2} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) \sin n \omega_{1} t \mathrm{~d} t\]</span></p><p>当然，也可通过和差化积公式，转换成只有正弦或余弦分量的形式，此处不再赘述。</p><p>有： <span class="math display">\[a_n=a_{-n},-b_n=b_{-n}\]</span></p><h3 id="指数形式傅里叶级数">指数形式傅里叶级数</h3><p>因为： <span class="math display">\[\sin x=\frac{1} {2j}(e^{jx}-e^{-jx})\]</span></p><p><span class="math display">\[\cos x=\frac 12 (e^{jx}+e^{-jx})\]</span></p><p>代入三角函数形式傅里叶级数中，就能得到指数形式傅里叶级数。这里给出部分关键步骤供参考。 <span class="math display">\[\begin{aligned}f(t)&amp;=a_{0}+\sum_{n=1}^{\infty}\left(a_{n} \cos n \omega_{1} t+b_{n} \sin n \omega_{1} t\right)\\\\&amp;=a_{0}+\sum_{n=1}^{\infty}\left(\frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t}+\frac{a_{n}+j b_{n} } {2} e^{-j n \omega_{1} t}\right)\\\\&amp;=a_{0}+\sum_{n=1}^{\infty} \frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t}+\sum_{n=-\infty}^{-1} \frac{a_{n}-j b_{n} } {2} e^{j n \omega_{1} t} &amp; a_n=a_{-n},-b_n=b_{-n}\\\\&amp;=\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\end{aligned}\]</span> 其中 <span class="math display">\[F\left(n \omega_{1}\right)=\begin{cases}a_{0}, &amp; n=0 \\\\ \frac{a_{n}-j b_{n} } {2}, &amp; n \neq 0\end{cases}\]</span> 即 <span class="math display">\[F(n\omega_1)=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) e^{-j n \omega_{1} t} \mathrm{d} t\]</span> 可以看出，<span class="math inline">\(F\left(n \omega_{1}\right)\)</span>一般而言是一个复数。它的模长和幅角满足： <span class="math display">\[|F\left(n \omega_{1}\right)|=\frac 12 \sqrt{a_n^2+b_n^2}\]</span></p><p><span class="math display">\[\tan \varphi_n=-\frac{b_n} {a_n}\]</span></p><h3 id="函数的对称性和傅里叶级数">函数的对称性和傅里叶级数</h3><p>因为<span class="math inline">\(\cos\)</span>是偶函数，<span class="math inline">\(\sin\)</span>是奇函数，所以函数本身的奇偶对称性和傅里叶系数的奇偶对称性有关系。</p><table><thead><tr class="header"><th style="text-align: center;">信号</th><th style="text-align: center;"><span class="math inline">\(a_n\)</span></th><th style="text-align: center;"><span class="math inline">\(b_n\)</span></th><th style="text-align: center;"><span class="math inline">\(F(n\omega_1)\)</span></th><th style="text-align: center;"><span class="math inline">\(\varphi_n\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">奇函数</td><td style="text-align: center;">0</td><td style="text-align: center;">不为0</td><td style="text-align: center;">纯虚数</td><td style="text-align: center;"><span class="math inline">\(\pm \pi/2\)</span></td></tr><tr class="even"><td style="text-align: center;">偶函数</td><td style="text-align: center;">不为0</td><td style="text-align: center;">0</td><td style="text-align: center;">实数</td><td style="text-align: center;"><span class="math inline">\(\pm \pi\)</span></td></tr><tr class="odd"><td style="text-align: center;">奇谐函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="在一个周期里的两个半周期里呈现奇对称的函数，即$f(t)=-f(t\pm \frac T2)$​">[1]</span></a></sup></td><td style="text-align: center;">只含奇次谐波</td><td style="text-align: center;">只含奇次谐波</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td></tr><tr class="even"><td style="text-align: center;">偶谐函数</td><td style="text-align: center;">只含直流分量和偶次谐波</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td><td style="text-align: center;">同前</td></tr></tbody></table><p>我们需要注意到：一个“偶谐函数”，和一个周期为<span class="math inline">\(T_1/2\)</span>的函数，实质上是一回事。</p><h3 id="从傅里叶级数看傅里叶变换">从傅里叶级数看傅里叶变换</h3><p>傅里叶级数只能描述周期函数。但是我如果非得描述非周期函数，又会怎么样呢？我们来考虑一下怎么把非周期函数强行变成周期函数，其实只需要让周期<span class="math inline">\(T\)</span>趋向于无穷大就好了。</p><p>对于 <span class="math display">\[F(n\omega_1)=\frac{1} {T_{1} } \int_{-\frac{T_{1} } {2} }^{\frac{T_{1} } {2} } f(t) e^{-j n \omega_{1} t} \mathrm{d} t\]</span> 让<span class="math inline">\(T\)</span>趋向于无穷大，则<span class="math inline">\(\omega\)</span>趋向于无穷小。因为函数满足绝对可积条件，所以右边是一个有限值比无穷大，趋向于0。而左边因为<span class="math inline">\(\omega\)</span>趋向于无穷小，取值点趋向于连续。有没有发现，这个过程有一点点像随机变量从连续型变成离散型时，分布列的变化情况（一方面，取值趋向于无穷小；另一方面，自变量趋向于连续）。于是，类似于“概率论”的知识，我们也可以定义“频谱密度函数”，让<span class="math inline">\(n\omega_1\to\omega\)</span>，有 <span class="math display">\[F(\omega)=\int_{-\infty}^\infty f(t)e^{-j\omega t}\mathrm{d}t\]</span> 这就是我们常说的傅里叶变换。</p><h2 id="傅里叶变换">傅里叶变换</h2><h3 id="傅里叶变换的定义式">傅里叶变换的定义式</h3><p><span class="math display">\[F(\omega)=\int_{-\infty}^\infty f(t)e^{-j\omega t}\mathrm{d}t\]</span></p><h3 id="基本信号及其傅里叶变换">基本信号及其傅里叶变换</h3><ol type="1"><li><p>矩形脉冲信号（门信号）</p><p>即： <span class="math display">\[G_N(t)=\begin{cases}1 &amp; |t|&lt;N\\\\0 &amp; |t|&gt;N\end{cases}\]</span> 有： <span class="math display">\[\mathscr{F}[G_N(t)]=2N\mathrm{Sa}(\omega N)\]</span></p></li><li><p>单边指数信号 <span class="math display">\[f_1(t)=\begin{cases}e^{-at} &amp; t\geq 0\\\\0 &amp; \text{others}\end{cases}\]</span> 则 <span class="math display">\[\mathscr{F}[f_1(t)]=\frac {1} {a+j\omega}\]</span> 类似地， <span class="math display">\[f_2(t)=\begin{cases}0 &amp; t\geq 0\\\\e^{bt} &amp; t&lt;0\end{cases}\]</span> 则 <span class="math display">\[\mathscr{F}[f_2(t)]=\frac 1{b-j\omega}\]</span></p></li><li><p>“偶”双边指数信号</p><p>把前面两个单边指数信号加起来就行了。 <span class="math display">\[f(t)=e^{-a|t|}\]</span> 则 <span class="math display">\[\mathscr{F}\left[e^{-a|t|}\right]=\frac{2a} {a^2+\omega^2}\]</span></p></li><li><p>符号函数 <span class="math display">\[\text{sgn}(t)=\begin{cases}1 &amp; t&gt;0\\\\0 &amp; t=0\\\\-1 &amp; t&lt;0\end{cases}\]</span> 为求符号函数的傅里叶变换，先求“奇双边指数函数”的傅里叶变换，然后让指数系数趋向于0即可。</p><p>奇双边指数函数，即 <span class="math display">\[f(t)=\begin{cases}e^{-at} &amp;t&gt;0\\\\-e^{-at} &amp; t&lt;0\end{cases}\]</span></p><p><span class="math display">\[\mathscr{F}[f(t)]=\frac{-2j\omega} {a^2+\omega^2}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220627114355617.png" alt="image-20220627114355617" /><figcaption aria-hidden="true">image-20220627114355617</figcaption></figure><p>当<span class="math inline">\(a\to0\)</span>时，这个函数就趋向于<span class="math inline">\(\text{sgn}(t)\)</span>。如图是<span class="math inline">\(a=0.01\)</span>的图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220627114553417.png" alt="image-20220627114553417" /><figcaption aria-hidden="true">image-20220627114553417</figcaption></figure><p>则有： <span class="math display">\[\mathscr{F}[\text{sgn}(t)]=\frac 2{j\omega}\]</span></p></li><li><p>冲激信号 <span class="math display">\[\mathscr{F}[\delta(t)]=1\]</span></p></li><li><p>阶跃信号 <span class="math display">\[\mathscr{F}[u(t)]=\pi \delta(\omega)+\frac 1{j\omega}\]</span> 这个结果可以通过符号函数平移得到。</p></li></ol><h3 id="傅里叶变换的性质">傅里叶变换的性质</h3><p>如果有： <span class="math display">\[\mathscr F[f(t)]=F(\omega)\]</span> 则有：</p><h4 id="基于定义的性质">基于定义的性质</h4><ol type="1"><li><p>对称性 <span class="math display">\[\mathscr F[F(t)]=2\pi f(-\omega)\]</span></p></li><li><p>奇虚偶实性</p><ul><li><span class="math inline">\(|F(\omega)|\)</span>是偶函数</li><li><span class="math inline">\(\varphi(\omega)\)</span>是奇函数</li><li>如果<span class="math inline">\(f(t)\)</span>是实偶函数，则<span class="math inline">\(F(\omega)\)</span>是实偶函数</li><li>如果<span class="math inline">\(f(t)\)</span>是实奇函数，则<span class="math inline">\(F(\omega)\)</span>是虚奇函数</li></ul></li></ol><h4 id="基于时间运算的性质">基于时间运算的性质</h4><ol type="1"><li><p>反褶性质 <span class="math display">\[\mathscr F[f(-t)]=F(-\omega)=F^*(\omega)\]</span></p></li><li><p>时移性质 <span class="math display">\[\mathscr F[f(t-t_0)]=F(\omega)e^{-j\omega t_0}\]</span> 可以说：时移不改变幅频特性，而改变相频特性。</p></li><li><p>压扩性质 <span class="math display">\[\mathscr F[f(at)]=\frac 1{|a|}F\left(\frac \omega a\right)\]</span> 对于频域带限信号，时域的压缩和扩展，会导致频谱范围的增大和减小，频率分量的减少和增加。</p></li><li><p>时域综合性质 <span class="math display">\[\mathscr F[f(at+b)]=\frac 1{|a|}F\left(\frac \omega a\right)e^{j\omega\frac ba}\]</span></p></li><li><p>线性</p></li><li><p>时域微分性质 <span class="math display">\[\mathscr F[f&#39;(t)]=j\omega F(\omega)\]</span> 进一步： <span class="math display">\[\mathscr F[f^{(n)}(t)]=(j\omega)^nF(\omega)\]</span> 因为函数加上任意常数后，微分都相同。在运用这个性质时，要把信号的直流分量提取出来单独处理。例如：尝试利用时域微分性质和线性性质分别由<span class="math inline">\(\text{sgn}(t)\)</span>函数的傅里叶变换计算<span class="math inline">\(u(t)\)</span>的傅里叶变换，并比较结果。</p></li><li><p>时域积分性质 <span class="math display">\[\mathscr F\left[\int_{-\infty}^t f(\tau)\mathrm d\tau\right]=\frac {F(\omega)} {j\omega}+\pi F(0)\delta(\omega)\]</span></p></li></ol><h4 id="基于频域运算的性质">基于频域运算的性质</h4><ol type="1"><li><p>频移性质 <span class="math display">\[\mathscr F[f(t)e^{j\omega_0 t}]=F(\omega-\omega_0)\]</span></p></li><li><p>频域微分-时域线性加权性质 <span class="math display">\[\mathscr F[t^nf(t)]=j^n \frac{\mathrm d^nF(\omega)} {\mathrm d \omega^n}\]</span></p></li></ol><h4 id="卷积性质">卷积性质</h4><ol type="1"><li><p>时域卷积 <span class="math display">\[\mathscr F[f_1(t)\bigotimes f_2(t)]=F_1(\omega)F_2(\omega)\]</span></p></li><li><p>频域卷积 <span class="math display">\[\mathscr F[f_1(t)f_2(t)]=\frac 1{2\pi}F_1(\omega)\bigotimes F_2(\omega)\]</span></p></li></ol><h3 id="由变换的性质计算常用信号的傅里叶变换">由变换的性质计算常用信号的傅里叶变换</h3><ol type="1"><li><p>直流信号<span class="math inline">\(E\)</span></p><p>由 <span class="math display">\[\mathscr F[\delta(t)]=1\]</span> 因对称性，有： <span class="math display">\[\mathscr F[1]=2\pi \delta(\omega)\]</span> 因线性，有： <span class="math display">\[\mathscr F[E]=2\pi E\delta(\omega)\]</span></p></li><li><p><span class="math inline">\(f(t)=1/t\)</span></p><p>由 <span class="math display">\[\mathscr F[\text{sgn} (t)]=\frac 2{j\omega}\]</span> 因对称性，有： <span class="math display">\[\mathscr F\left[\frac 2{jt}\right]=2\pi\text{sgn}(-\omega)\]</span> 因线性，有： <span class="math display">\[\mathscr F\left[\frac 1 t\right]=-j\pi\text{sgn}(\omega)\]</span></p></li><li><p>正余弦信号</p><p>由 <span class="math display">\[\mathscr F[1]=2\pi\delta(\omega)\]</span> 因频移性质，有： <span class="math display">\[\mathscr F[e^{j\omega_0t}]=2\pi\delta(\omega-\omega_0)\\\\\mathscr F[e^{-j\omega_0t}]=2\pi\delta(\omega+\omega_0)\\\\\]</span> 因三角函数分解公式： <span class="math display">\[\sin \omega_0t=\frac{1} {2j}(e^{j\omega_0t}-e^{-j\omega_0t})\\\\\cos \omega_0t=\frac 12 (e^{j\omega_0t}+e^{-j\omega_0t})\]</span> 有： <span class="math display">\[\mathscr F[\sin(\omega_0 t)]=-j\pi [\delta(\omega-\omega_0)-\delta(\omega+\omega_0)]\\\\\mathscr F [\cos(\omega_0 t)]=\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]\]</span></p></li><li><p>三角脉冲信号</p><p>定义三角脉冲信号<span class="math inline">\(T_\tau(t)\)</span>为形如下面的信号，计算傅里叶变换。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/2BED7AAC8763AB14671045D511389210.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由 <span class="math display">\[\mathscr F[G_N(t)]=2N\text{Sa}(N\omega)\]</span> 则三角脉冲信号<span class="math inline">\(T_\tau(t)\)</span>是门信号的卷积，具体地： <span class="math display">\[T_\tau(t)=\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\bigotimes\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\]</span> 由于 <span class="math display">\[\mathscr F\left[\sqrt{\frac 1\tau}G_{\frac \tau2}(t)\right]=\sqrt{\tau}\text{Sa}\left(\frac \tau2\omega\right)\]</span> 和卷积性质，有： <span class="math display">\[\mathscr F[T_\tau(t)]=\tau\text{Sa}^2\left(\frac \tau2 \omega\right)\]</span></p></li></ol><p>现将常用信号的傅里叶变换归纳如下：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(f(t)\)</span></th><th style="text-align: center;"><span class="math inline">\(F(\omega)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\delta(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\delta (t-t_0)\)</span></td><td style="text-align: center;"><span class="math inline">\(e^{-j\omega t_0}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(2\pi\delta(\omega)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{j\omega_0t}\)</span></td><td style="text-align: center;"><span class="math inline">\(2\pi\delta(\omega-\omega_0)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\pi\delta(\omega)-\frac 1{j\omega}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(sgn(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac 2{j\omega}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\cos(\omega_0t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sin(\omega_0t)\)</span></td><td style="text-align: center;"><span class="math inline">\(-j\pi [\delta(\omega-\omega_0)-\delta(\omega+\omega_0)]\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(e^{-a\|t\|}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{2a} {a^2+\omega^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(G_N(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(2NSa(N\omega)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_\tau(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\tau\text{Sa}^2\left(\frac \tau2 \omega\right)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-at}u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {j\omega+a}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1/t\)</span></td><td style="text-align: center;"><span class="math inline">\(-j\pi\text{sgn}(\omega)\)</span></td></tr></tbody></table><p>这里提出一个趣味问题：</p><blockquote><p>【例】：是否存在一个时域、频域都有限的信号？</p><p>【解】：不存在。如果时域有限，则信号可以表示为： <span class="math display">\[f(t)=f(t)G_N(t-t_0)\]</span> 而<span class="math inline">\(G_N(t)\)</span>的傅里叶变换的频带是无限的。卷积之后，频带也是无限长的。频域有限情况同理可知。</p></blockquote><h3 id="周期信号的傅里叶变换">周期信号的傅里叶变换</h3><p>在之前，我们研究的是周期信号的傅里叶级数，和非周期信号的傅里叶变换。现在为了把它们都纳入傅里叶分析的框架中，我们要讨论周期信号的傅里叶变换。</p><p>我们都知道，周期信号的傅里叶系数<span class="math inline">\(F(n\omega)\)</span>叫“频谱函数”，而非周期信号的傅里叶变换<span class="math inline">\(F(\omega)\)</span>叫“频谱密度函数”。那么如果我们非要用频谱密度函数来表示频谱函数，那么结果应该是出现在其角频率各次谐波处的冲激函数。（请联想概率论中，如果我们非要用“概率密度函数”来表示离散分布的“分布函数”，那么会出现什么现象？）</p><p>周期函数的傅里叶系数和它一个周期内函数的傅里叶变换的关系为：</p><p><span class="math display">\[F(n\omega_1)=\left.\frac 1{T_1}F_1(\omega)\right|_{\omega=n\omega_1}\]</span></p><p>对于周期函数的傅里叶级数</p><p><span class="math display">\[f(t)=\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\]</span></p><p>作傅里叶变换：</p><p><span class="math display">\[\mathscr F\left[\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\right]=\sum_{n=-\infty}^{\infty}F(n\omega_1)\mathscr F[e^{jn\omega_1 t}]\]</span></p><p>由于频移性质：</p><p><span class="math display">\[\mathscr F [e^{jn\omega_1 t}]=2\pi\delta(\omega-n\omega_1)\]</span></p><p>故：</p><p><span class="math display">\[\mathscr F[f(t)]=\mathscr F\left[\sum_{n=-\infty}^{\infty} F\left(n \omega_{1}\right) e^{j n \omega_{1} t}\right]=2\pi\sum_{n=-\infty}^{\infty}F(n\omega_1)\delta(\omega-n\omega_1)\]</span></p><p>这就是一般周期信号的傅里叶变换。</p><h4 id="典型周期信号的傅里叶变换">典型周期信号的傅里叶变换</h4><ol type="1"><li><p>正余弦信号</p><p>正余弦信号的傅里叶变换我们之前已经求过了。现在我们可以从一个新的视角来考虑这个问题。对于余弦信号而言，有：</p><p><span class="math display">\[\cos(\omega_1 t)=\frac 12(e^{j\omega_1 t}+e^{-j\omega_1t})\]</span></p><p>则其傅里叶级数的系数为：</p><p><span class="math display">\[F(n\omega_1)|_{n=\pm 1}=\frac 12\]</span></p><p>则其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[\cos(\omega_1 t)]=\pi[\delta(\omega-\omega_1)+\delta(\omega+\omega_1)]\]</span></p></li><li><p>周期冲激信号</p><p>周期冲激信号经常被用来采样，所以也算是一个常用的信号。我们来看一下它的傅里叶变换。</p><p>周期冲激信号的定义是：</p><p><span class="math display">\[\delta_{T_1}(t)=\sum_{n=-\infty}^{\infty}\delta(t-nT_1)\]</span></p><p>其傅里叶系数为：</p><p><span class="math display">\[F(n\omega_1)=\left.\frac 1{T_1}F_1(\omega)\right|_{\omega=n\omega_1}=\frac1{T_1}\]</span></p><p>则其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[\delta_{T_1}(t)]=\frac {2\pi} {T_1}\sum_{n=-\infty}^\infty \delta(\omega-n\omega_1)=\omega_1\sum_{n=-\infty}^\infty \delta(\omega-n\omega_1)\]</span></p><p>可以看出：周期冲激信号的傅里叶变换也是周期冲激信号。</p></li><li><p>周期矩形脉冲信号</p><p>周期矩形脉冲信号有两个参数：周期<span class="math inline">\(T_1\)</span>，脉宽<span class="math inline">\(\tau\)</span>，即：<img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/AFA6FB4DBB59084944CDA2465162854F.png" alt="img" /></p><p>记作：<span class="math inline">\(G_{T_1,\tau}(t)\)</span>，图中<span class="math inline">\(E=1\)</span>.</p><p>在一个周期中，其傅里叶变换为：</p><p><span class="math display">\[\mathscr F[G_{0,\tau}(t)]=\tau\text{Sa}\left(\frac{\omega\tau} {2}\right)\]</span></p><p>则周期矩形脉冲的傅里叶系数为</p><p><span class="math display">\[F(n\omega_1)=\frac{\tau} {T_1}\text{Sa}\left(\frac{n\omega_1\tau} {2}\right)\]</span></p><p>故周期矩形脉冲的傅里叶变换为</p><p><span class="math display">\[\tau\omega_1\sum_{n=-\infty}^{\infty}\text{Sa}\left(\frac{n\omega_1\tau} {2}\right)\delta(\omega-n\omega_1)\]</span></p></li></ol><h3 id="抽样">抽样</h3><p>一个基本的抽样过程等效于以下的模型：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/BEE55B4CEAA391E54CF074AFBC5F30B1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里的"<span class="math inline">\(\bigotimes\)</span>"是乘法的意思。即有：</p><p><span class="math display">\[f_s(t)=f(t)p(t)\]</span></p><p>这里的<span class="math inline">\(p(t)\)</span>就是脉冲信号，比如说周期冲激信号，周期矩形脉冲信号等等。</p><p>利用傅里叶变换的卷积定理，有（这里要熟练掌握冲激函数的卷积性质）：</p><p><span class="math display">\[\mathscr F[f_s(t)]=\frac 1{T_s}\sum_{n=-\infty}^{\infty}P_0(n\omega_s)F(\omega-n\omega_s)\]</span></p><p>也就是说，抽样信号的频谱是连续信号频谱以<span class="math inline">\(\omega_s\)</span>为周期的周期延拓，并收到脉冲信号频谱<span class="math inline">\(P_0(n\omega_s)\)</span>和脉冲信号周期<span class="math inline">\(T_s\)</span>的加权。</p><p>于是，我们发现，如果要求不发生频域混叠，那么原始连续信号必须在频域是带限信号。但是这实际上是不可能存在的。但是信号的主要频域往往确实是有限的，其它部分的分量可以忽略不计，为此我们可以定义<span class="math inline">\(-3\text{dB}\)</span>带宽，零点带宽等带宽（记作<span class="math inline">\(\omega_m\)</span>），把信号近似为一个频域带限信号。</p><p>那么，一个带限信号<span class="math inline">\(f(t)\)</span>,如果其频谱存在在频域区间<span class="math inline">\([-\omega_m,\omega_m]\)</span>，则可用抽样值唯一表示<span class="math inline">\(f(t)\)</span>,抽样值的间隔不能大于<span class="math inline">\(T_s=\frac{1} {2f_m}\)</span>,其中<span class="math inline">\(f_m=\frac{\omega_m} {2\pi}\)</span>，否则会发生频域混叠，这就是奈奎斯特采样定理。我们把<span class="math inline">\(f_s=2f_m\)</span>称作“奈奎斯特频率”，这是不发生频域混叠的最小抽样频率。</p><p>为了从抽样信号中恢复出原始信号，对理想冲激抽样，我们用一个截止频率为<span class="math inline">\(\omega_c\)</span>，幅度增益为<span class="math inline">\(T_s\)</span>的零延时低通滤波器即可，其中<span class="math inline">\(\omega_c\)</span>满足<span class="math inline">\(\omega_c\in[\omega_m,\omega_s-\omega_m]\)</span>.对于理想矩形脉冲抽样，滤波器的幅度增益应为<span class="math inline">\(T_s/(E\tau)\)</span></p><h2 id="连续系统实频域分析">连续系统实频域分析</h2><p>所谓的连续系统实频域分析，也就是利用傅里叶变换来分析连续系统。在本节，将首先介绍系统传递函数的概念，再介绍一类比较理想的系统：无失真系统，然后分析一类具体的系统：低通滤波器。</p><h3 id="系统频率响应">系统频率响应</h3><p>定义系统单位冲激响应<span class="math inline">\(h(t)\)</span>的傅里叶变换为系统频率响应。即：</p><p><span class="math display">\[H(\omega)=\int_{-\infty}^\infty h(t)e^{-j\omega t}\mathrm d t\]</span></p><p>如果系统的激励为<span class="math inline">\(e(t)\)</span>,激励的傅里叶变换为<span class="math inline">\(E(\omega)\)</span>，那么对系统的响应的傅里叶变换，有：</p><p><span class="math display">\[R(\omega)=E(\omega)\cdot H(\omega)\]</span></p><p>如果系统输入的是复指数信号<span class="math inline">\(e^{j\omega_0 t}\)</span>，那么有：</p><p><span class="math display">\[R=2\pi\delta(\omega-\omega_0)H(\omega)\]</span></p><p>则有：</p><p><span class="math display">\[r(t)=\frac 1{2\pi}\int_{-\infty}^{\infty}2\pi\delta(\omega-\omega_0)H(\omega)e^{j\omega t}\mathrm d t=e^{j\omega_0t}H(\omega_0)\]</span></p><p>这说明：系统对不同频率的正弦信号的幅度和相位加权不相同；不同的系统对相同频率的正弦信号的幅度和相位的加权也不相同。</p><p>对于频率响应<span class="math inline">\(H(\omega)\)</span>，称<span class="math inline">\(|H(\omega)|\)</span>为系统的幅频响应，而<span class="math inline">\(\varphi(\omega)\)</span>为系统的相频响应。</p><p>如果系统用微分方程</p><p><span class="math display">\[C_0r^{(n)}(t)+C_1r^{(n-1)}(t)+\cdots+C_nr(t)=E_0e^{(m)}(t)+E_1e^{(m-1)}(t)+\cdots+E_me(t)\]</span></p><p>可以直接写出其频率响应：</p><p><span class="math display">\[H(\omega)=\frac{\sum_{i=0}^nC_i(j\omega)^{n-i} } {\sum_{j=1}^m E_{j}(j\omega)^{m-j} }\]</span></p><p>在已知频率响应和激励，求系统响应时，一般有两种思路。其一是系统激励以傅里叶级数形式给出，这时只需要针对每个谐波分量计算对应的幅频响应和相频响应，然后把响应作用于激励即可。另一种思路是先求出激励的傅里叶变换，然后用图像和系统频率响应相乘，得到响应的傅里叶变换，最后得到结果。</p><h3 id="无失真系统">无失真系统</h3><p>输出响应能再现系统的输入，只有出现时刻和幅度不同，即没有改变输入波形的形状，这种系统叫做无失真系统。那么把冲激信号输入系统，就可以得到无失真系统的频响：</p><p><span class="math display">\[H(\omega)=ke^{-j\omega t_0}\]</span></p><p>则其幅频，相频特性如下：</p><p><span class="math display">\[|H(\omega)|=k\\\\\varphi(\omega)=-\omega t_0\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/33FCDB8A45A057AE5F76B35B9A69EBCE.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>相频特性是一条直线的含义是：相频特性表示了系统的延时，对信号的所有频率分量，应该有相同的延时，即相位附加值相同。例如输入<span class="math inline">\(E_1\sin(\omega_1t)\)</span>，那么理应得到输出<span class="math inline">\(E_1\sin\left[\omega(t+\varphi(\omega))\right]=E_1\sin\left[\omega(t+\frac{\varphi(\omega)} {\omega})\right]\)</span>，于是，为了对不同的频率分量得到相同的附加相移，就需要：</p><p><span class="math display">\[\forall \omega_1,\omega_2,\frac{\varphi(\omega_1)} {\omega_1}=\frac{\varphi(\omega_2)} {\omega_2}\]</span></p><h3 id="低通滤波器">低通滤波器</h3><p>理想滤波器是在特定频段范围内的无失真传输系统。这里之所以只讨论低通滤波器，是其它滤波器可以由低通滤波器转换而来。具体如何转换，我们后面再说。</p><p>理想低通滤波器的频响特性如下：</p><p><span class="math display">\[H(\omega)= \begin{cases}e^{-j \omega t_{0} } &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p>注意，切不可以以为理想低通滤波器的频响函数是频域门函数，因为还要考虑附加相移（时域延迟）。有：</p><p><span class="math display">\[|{H}(\omega)|= \begin{cases}1 &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p><span class="math display">\[\varphi(\omega)= \begin{cases}-\omega t_{0} &amp; |\omega|&lt;\omega_{c} \\\\ 0 &amp; |\omega| \geq \omega_{c}\end{cases}\]</span></p><p>对频响函数作傅里叶逆变换，可得单位冲激响应：</p><p><span class="math display">\[h(t)=\frac{\omega_{c} } {\pi} \cdot \text{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right]\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/DF189DDD56F929706856BF8B26DA1D67.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="其它滤波器">其它滤波器</h4><ul><li><p>高通滤波器</p><p>无失真全通系统-低通滤波器=高通滤波器。因而，有：</p><p><span class="math display">\[H_{h}(\omega)=e^{-\mathrm{j} \omega t_{0} }\left[1-u\left(\omega+\omega_{c}\right)+u\left(\omega-\omega_{c}\right)\right]\]</span></p><p><span class="math display">\[h_{h}(t)=\delta\left(t-t_{0}\right)-h_{l}(t)=\delta\left(t-t_{0}\right)-\frac{\omega_{c} } {\pi} \cdot \mathrm{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right]\]</span></p></li><li><p>带通滤波器</p><p>带通滤波器可以由理想低通滤波器频响向两侧搬移，再对相频特性进行修正得到。</p><p><span class="math display">\[H_{b}(\omega)=e^{-\mathrm{j} \omega_{0} }\left[\left(u\left(\omega+\omega_{h}\right)-u\left(\omega+\omega_{l}\right)\right)+\left(u\left(\omega-\omega_{l}\right)-u\left(\omega-\omega_{h}\right)\right)\right]\]</span></p><p><span class="math display">\[h_{b}(t)=\frac{2 \omega_{c} } {\pi} \cdot \operatorname{Sa}\left[\omega_{c}\left(t-t_{0}\right)\right] \cos \left[\omega_{0}\left(t-t_{0}\right)\right]\]</span></p><p>其中</p><p><span class="math display">\[\omega_{c}=\frac{\omega_{h}-\omega_{l} } {2}, \omega_{0}=\frac{\omega_{h}+\omega_{l} } {2}\]</span></p></li></ul><h3 id="系统的因果性">系统的因果性</h3><p>我们都知道，<span class="math inline">\(LTI\)</span>系统因果的充要条件是：</p><p><span class="math display">\[h(t)=h(t)u(t)\]</span></p><p>现在我们从频域考虑这个问题。</p><h4 id="佩里维纳准则">佩里维纳准则</h4><p>一个幅频响应绝对可积的系统物理可实现的必要条件是：</p><p><span class="math display">\[\int_{-\infty}^{\infty}\frac{|\ \ln|H(\omega)|\ |} {1+\omega^2}\mathrm d\omega&lt;\infty\]</span></p><p>从直观角度考虑，佩里维纳准则要求系统的幅频响应不能衰减得太快。特别的，如果幅频响应在某个连续频带上为<span class="math inline">\(0\)</span>，那么系统就不可实现。</p><h4 id="希尔伯特变换">希尔伯特变换</h4><p>接下来从时域入手，讨论判断系统因果性的充要条件。</p><p>从用卷积性质计算<span class="math inline">\(h(t)u(t)\)</span>的傅里叶变换入手，设<span class="math inline">\(H(\omega)=R(\omega)+jX(\omega)\)</span>，那么<span class="math inline">\(R,X\)</span>构成一希尔伯特变换对。所谓的希尔伯特变换是指：</p><p><span class="math display">\[\hat{x}(t)=\mathscr H[x(t)]=x(t)\bigotimes\frac1{\pi t}\]</span></p><p>把卷积展开，有：</p><p><span class="math display">\[\begin{aligned}\hat{x}(t) &amp;=\frac{1} {\pi} \int_{-\infty}^{\infty} x(\tau) \frac{1} {t-\tau} d \tau \\\\&amp;=-\frac{1} {\pi} \int_{-\infty}^{\infty} x(t+\tau) \frac{1} {\tau} d \tau \\\\&amp;=\frac{1} {\pi} \int_{-\infty}^{\infty} x(t-\tau) \frac{1} {\tau} d \tau\end{aligned}\]</span></p><p>对一个系统作希尔伯特变换，实质上是将其经过一个<span class="math inline">\(\pi/2\)</span>相移器（注意：这里不是时移）。</p><p>希尔伯特变换将在《随机过程理论》中再次详细说明，这里只提两个重要性质：</p><ul><li><p><span class="math display">\[\mathscr F[\hat{x}(t)]=-j\mathscr F[x(t)]sgn(\omega)\]</span></p></li><li><p><span class="math display">\[\mathscr H[\hat{x}(t)]=-x(t)\]</span></p></li></ul><p>则系统因果的充要条件是：频响函数<span class="math inline">\(H(\omega)\)</span>的实部和虚部是一对希尔伯特变换对。</p><h3 id="相关定理以及能量和功率">相关定理，以及能量和功率</h3><p>为了动态地描述两个信号的相关关系，避免基于内积定义的相关系数所带来的种种漏洞.</p><p>对于能量信号，我们定义相关函数：</p><p><span class="math display">\[R_{12}(\tau)=\int_{-\infty}^{\infty}f_1(t)f^*_2(t-\tau)\mathrm dt\]</span></p><p>定义自相关函数：</p><p><span class="math display">\[R(\tau)=\int_{-\infty}^{\infty} f(t) f^{*}(t-\tau) d t\]</span></p><p>如果信号是功率信号，上面的积分可能不收敛。定义功率信号的相关函数：</p><p><span class="math display">\[R_{12}(\tau)=\lim _{T \rightarrow \infty} \frac{1} {T} \int_{-\frac{T} {2} }^{\frac{T} {2} } f_{1}(t) f_{2}^{*}(t-\tau) \mathrm{d} t\]</span></p><p>自相关函数：</p><p><span class="math display">\[R(\tau)=\lim _{T \rightarrow \infty} \frac{1} {T} \int_{-\frac{T} {2} }^{\frac{T} {2} } f(t) f^{*}(t-\tau) d t\]</span></p><p>在下学期学的《随机过程理论》中，我们将从期望的角度重新认识相关函数。</p><p>有“相关定理”：</p><p><span class="math display">\[\mathscr{F}\left[R_{12}(\tau)\right]=F_{1}(\omega) F_{2}^{*}(\omega)\]</span></p><p>进一步，对自相关函数：</p><p><span class="math display">\[\mathscr{F}[R(\tau)]=|F(\omega)|^{2}\]</span></p><p>联想到帕塞瓦尔定理：</p><p><span class="math display">\[\int_{-\infty}^{\infty}|f(t)|^2\mathrm d t=\int_{-\infty}^{\infty}|F(2\pi f)|^2\mathrm d f\]</span></p><p>我们可以令<span class="math inline">\(\varepsilon(\omega)=|F(\omega)|^2\)</span>为“能量密度函数”，也叫“能量谱函数”，它反映了能量在频域上的分布。则能量谱函数和能量信号自相关函数是一对傅里叶变换对。</p><p>对于功率信号，定义功率谱函数：</p><p><span class="math display">\[p(\omega)=\lim_{T\to \infty}\frac{|F_T(\omega)|^2} {T}\]</span></p><p>则功率信号的功率谱函数和自相关函数也是一对傅里叶变换对，这叫做“维纳辛钦定理”。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>在一个周期里的两个半周期里呈现奇对称的函数，即<span class="math inline">(f(t)=-f(tT2))</span>​ <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验3：离散时间系统特性分析</title>
    <link href="/2022/06/22/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A3/"/>
    <url>/2022/06/22/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A3/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第三个实验，离散时间系统特性分析</p><span id="more"></span><h2 id="实验目的">实验目的</h2><ol type="1"><li><p>深入理解单位样值相应，离散系统的频率响应的概念；</p></li><li><p>掌握通过计算机进行求得离散系统的单位样值相应，以及离散系统的频率响应的方法。</p></li></ol><h2 id="实验原理">实验原理</h2><p>对于离散系统的单位样值而言，在实际处理过程中，不可能选取无穷多项的取值。往往是选取有限项的取值，当然这里会产生一个截尾误差，但只要这个误差在相对小一个范围里，可以忽略不计。</p><p>另外，在一些实际的离散系统中，往往不是事先就能得到描述系统的差分方程的，而是通过得到系统的某些相应值，则此时系统的分析就需借助计算机的数值处理来进行，得到描述系统的某些特征，甚至进而得到描述系统的数学模型。</p><p>本实验首先给出描述系统的差分方程，通过迭代的方法求得系统的单位样值响应，进而求得该离散系统的频率响应。限于试验条件，虽然给出了系统方程，但处理的方法依然具有同样的实际意义。</p><p>具体的方法是：</p><p>1．在给定系统方程的条件下，选取激励信号为<span class="math inline">\(\delta(n)\)</span>，系统的起始状态为零状态，通过迭代法，求得系统的单位样值响应<span class="math inline">\(h(n)(n=0,1,\cdots,N)\)</span></p><p>2．利用公式 <span class="math display">\[H(e^{j\Omega})=\sum_{n=0}^Nh(n)e^{-j\Omega n},\Omega\in[0,2\pi]\]</span> 计算系统的频率响应。</p><h2 id="实验内容">实验内容</h2><h3 id="求单位样值响应">求单位样值响应</h3><p>已知系统： <span class="math display">\[y(n)-1.3y(n-1)-0.4y(n-2)=x(n-1)\]</span> 求单位样值响应。</p><p>可以用迭代法求解，迭代公式为： <span class="math display">\[y(n)=x(n-1)+1.3y(n-1)+0.4y(n-2)\]</span></p><h3 id="求系统幅频响应">求系统幅频响应</h3><p>利用公式 <span class="math display">\[H(e^{j\Omega})=\sum_{n=0}^Nh(n)e^{-j\Omega n},\Omega\in[0,2\pi]\]</span> 计算系统的频率响应。</p><p>需要注意，计算出的<span class="math inline">\(H(e^{j\Omega})\)</span>是一个复数，但是C语言对复数的支持并不是很好，因此我们可以分别计算实部和虚部。有：</p><p><span class="math display">\[\Re\left[H(e^{j\Omega})\right]=\sum_{k=0}^{10}h(k)\cos(-\Omega k)\\\\\Im\left[H(e^{j\Omega})\right]=\sum_{k=0}^{10}h(k)\sin(-\Omega k)\\\\\text{Amp}=|H(e^{j\Omega})|=\sqrt{\Re ^2+\Im ^2}\\\\\varphi=\arctan(\frac{\Re\left[H(e^{j\Omega})\right]}{\Im\left[H(e^{j\Omega})\right]})\]</span></p><h2 id="实验代码及其流程图">实验代码及其流程图</h2><p>实验流程图如下：</p><p><img src="" /><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/234.bmp" alt="234" /></p><p>实验代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM2.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-type">int</span> x[MAXN];<br><span class="hljs-type">double</span> h[MAXN], t[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">h_</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> h[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>x[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>t[i] = i;<br>h[i] = x[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1.3</span> * <span class="hljs-built_in">h_</span>(i - <span class="hljs-number">1</span>) - <span class="hljs-number">0.4</span> * <span class="hljs-built_in">h_</span>(i - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>, h[i]);<br>&#125;<br><span class="hljs-type">double</span> w[MAXN], amp[MAXN], phi[MAXN];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">2</span> * PI; i += <span class="hljs-number">0.1</span> * PI) &#123;<br><span class="hljs-type">double</span> a = <span class="hljs-number">0.0</span>, b = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">10</span>; ++j) &#123;<br>a += h[j] * <span class="hljs-built_in">cos</span>(<span class="hljs-number">-1</span> * j * i);<br>b += h[j] * <span class="hljs-built_in">sin</span>(<span class="hljs-number">-1</span> * j * i);<br>&#125;<br><span class="hljs-type">double</span>  tem_phi = <span class="hljs-built_in">atan2</span>(b, a);<br>w[cnt] = i;<br>amp[cnt] = <span class="hljs-built_in">sqrt</span>(a * a + b * b);<br>phi[cnt] = tem_phi;<br>++cnt;<br>&#125;<br>PPMdata background, axis, grid, line;<br>background = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br><span class="hljs-function">Graph <span class="hljs-title">H</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;response.ppm&quot;</span>)</span></span>;<br><span class="hljs-function">Graph <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, PI, <span class="hljs-number">5.0</span>, <span class="hljs-number">2.5</span> * PI, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;amp-fre.ppm&quot;</span>)</span></span>;<br><span class="hljs-function">Graph <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, PI, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.5</span> * PI, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line, grid, background, axis, <span class="hljs-string">&quot;pha-fre.ppm&quot;</span>)</span></span>;<br>A.<span class="hljs-built_in">drawXY</span>(w, amp, cnt);<br>P.<span class="hljs-built_in">drawXY</span>(w, phi, cnt);<br>H.<span class="hljs-built_in">drawXY</span>(t, h, <span class="hljs-number">11</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8.4f %8.4f %8.4f\n&quot;</span>, w[i], amp[i], phi[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验结果">实验结果</h2><h3 id="系统单位样值响应">系统单位样值响应</h3><table><thead><tr class="header"><th><span class="math inline">\(n\)</span></th><th><span class="math inline">\(\delta(n)\)</span></th><th><span class="math inline">\(h(n)\)</span></th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>0.000000</td></tr><tr class="even"><td>1</td><td>0</td><td>1.000000</td></tr><tr class="odd"><td>2</td><td>0</td><td>1.300000</td></tr><tr class="even"><td>3</td><td>0</td><td>1.290000</td></tr><tr class="odd"><td>4</td><td>0</td><td>1.157000</td></tr><tr class="even"><td>5</td><td>0</td><td>0.988100</td></tr><tr class="odd"><td>6</td><td>0</td><td>0.821730</td></tr><tr class="even"><td>7</td><td>0</td><td>0.673009</td></tr><tr class="odd"><td>8</td><td>0</td><td>0.546220</td></tr><tr class="even"><td>9</td><td>0</td><td>0.440882</td></tr><tr class="odd"><td>10</td><td>0</td><td>0.354659</td></tr></tbody></table><p>响应-时间图如下</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/response.jpg" alt="response" /><figcaption aria-hidden="true">response</figcaption></figure><h3 id="系统幅频和相频特性">系统幅频和相频特性</h3><table><thead><tr class="header"><th><span class="math inline">\(\Omega\)</span></th><th><span class="math inline">\(\text{Amp}(\Omega)\)</span></th><th><span class="math inline">\(\varphi(\Omega)\)</span></th></tr></thead><tbody><tr class="odd"><td>0.0000</td><td>8.5716</td><td>0.0000</td></tr><tr class="even"><td>0.3142</td><td>6.1182</td><td>-1.3645</td></tr><tr class="odd"><td>0.6283</td><td>2.1370</td><td>-2.1140</td></tr><tr class="even"><td>0.9425</td><td>1.7731</td><td>-2.2523</td></tr><tr class="odd"><td>1.2566</td><td>0.7426</td><td>-2.7356</td></tr><tr class="even"><td>1.5708</td><td>0.9027</td><td>-2.5992</td></tr><tr class="odd"><td>1.8850</td><td>0.3754</td><td>-3.0217</td></tr><tr class="even"><td>2.1991</td><td>0.6304</td><td>-2.8331</td></tr><tr class="odd"><td>2.5133</td><td>0.2467</td><td>-3.1356</td></tr><tr class="even"><td>2.8274</td><td>0.5384</td><td>-3.0404</td></tr><tr class="odd"><td>3.1416</td><td>0.2124</td><td>3.1416</td></tr><tr class="even"><td>3.4558</td><td>0.5384</td><td>3.0404</td></tr><tr class="odd"><td>3.7699</td><td>0.2467</td><td>3.1356</td></tr><tr class="even"><td>4.0841</td><td>0.6304</td><td>2.8331</td></tr><tr class="odd"><td>4.3982</td><td>0.3754</td><td>3.0217</td></tr><tr class="even"><td>4.7124</td><td>0.9027</td><td>2.5992</td></tr><tr class="odd"><td>5.0265</td><td>0.7426</td><td>2.7356</td></tr><tr class="even"><td>5.3407</td><td>1.7731</td><td>2.2523</td></tr><tr class="odd"><td>5.6549</td><td>2.1370</td><td>2.1140</td></tr><tr class="even"><td>5.9690</td><td>6.1182</td><td>1.3645</td></tr><tr class="odd"><td>6.2832</td><td>8.5716</td><td>0.0000</td></tr></tbody></table><p>幅频曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/amp-fre.jpg" alt="amp-fre" /><figcaption aria-hidden="true">amp-fre</figcaption></figure><p>相频曲线如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/pha-fre.jpg" alt="pha-fre" /><figcaption aria-hidden="true">pha-fre</figcaption></figure><h2 id="实验总结">实验总结</h2><p><span class="math inline">\(0\)</span>时对应的是低频，<span class="math inline">\(\pi\)</span>时对应的是高频，通过幅频特性曲线可以看出，本系统是离散的低通滤波器。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220620-20220626）</title>
    <link href="/2022/06/21/%E5%91%A8%E8%AE%B0%EF%BC%8820220620-20220626%EF%BC%89/"/>
    <url>/2022/06/21/%E5%91%A8%E8%AE%B0%EF%BC%8820220620-20220626%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><hr /><h2 id="section">20220620</h2><p>今天学完了电磁场的所有知识。明天大概就可以开始刷题了。 八分之一个西瓜竟然只要3元，真便宜。</p><h2 id="section-1">20220621</h2><p>今天继续复习电磁场，刷往年题。 明天早上小刷一下模电，下午晚上继续电磁场。刷点难题。</p><h2 id="section-2">20220622</h2><p>我虽然拼上命读，仍然是弄混了，结果一个字也记不住。几天来，头都读晕了，真难。时变双机位时变考试时变疫情时变世界时变我自己，我急了我急了我急了我急了我急了我急了我急了</p><h2 id="section-3">20220623</h2><p>没做什么有意义的事——妈的，这些混蛋教授，不但不知道自己泄气，还整天考，不是你考，就是我考，考他娘的什么东西？电磁场考过了，星期日还有一次考——真混蛋，讲的简直不成东西，又考，像什么话。</p><h2 id="section-4">20220624</h2><p>今天继续紧张刺激地复习模电。今天做了一套题，又补充了一下知识。 今天躺在床上突然被警报声吵醒，我还以为是地震了，其实是高温橙色预警。这才6月下旬耶，全国的温度就直逼40度，是不是地球快爆炸了？ 今天更新了一下博客的标题，感觉好文艺 今天准备看一集相合之物，我还下载了欧比旺，等闲下来再看</p><h2 id="section-5">20220625</h2><p>今天又和朋友自习了，开心。复习了模电，摆烂了。 今天是真的热，我和朋友自习到晚上十点，一出新主楼门，一股热风，和吹风机一样。风又大，又热，真实绝了。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220626001926223.png" alt="妈的好几把热" /><figcaption aria-hidden="true">妈的好几把热</figcaption></figure><p>今天喝了两瓶饮料，其中有一瓶叫“橘皮乌龙”，很好喝，我认为大家都应该尝一尝。 今天看了一集欧比王。 我在拼多多买的东西过了半个月了还不发货，果然是骗子软件，当不得真。 今天听说原神和必胜客要联动，好好好，我就是OP捏。</p><h2 id="section-6">20220626</h2><p>今天模电考完了，题多的要死，抄都抄不完，感觉要寄了。 今天摆烂一晚上，爽爽。 昨天忘了说了，昨天我的裤兜帮我安装了10个应用，打了1个电话。 明天要把信号的傅里叶部分写了。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于电磁场辐射的那些事</title>
    <link href="/2022/06/21/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E8%BE%90%E5%B0%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/21/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E8%BE%90%E5%B0%84%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>这部分主要讨论的是电磁波是如何产生的。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="时变场的位函数">时变场的位函数</h2><p>这一部分不是重点，我写完其它的再来写。</p><h2 id="时变电偶极子的辐射">时变电偶极子的辐射</h2><h3 id="时变电偶极子">时变电偶极子</h3><p>时变电偶极子是由大小相等、方向相反的两个点电荷<span class="math inline">\(\pm q(t)\)</span>组成的，其中<span class="math inline">\(q(t)\)</span>按正弦形式变化。这两个点电荷间距为<span class="math inline">\(\mathbf{d}s\to 0\)</span>，电偶极子的有效长度（也叫电尺寸）为<span class="math inline">\(\mathbf{d}s/\lambda\)</span>。有时，需要对电偶极子的电尺寸进行检验，看它是不是满足“远小于一”的条件。如果不满足，不应用电偶极子模型分析。</p><p>对于电偶极子之间的电流，有关系式：</p><p><span class="math display">\[I(t)=\frac{\mathbf{d}q(t)} {\mathbf{d}t}\]</span></p><p>写成复数形式，就是</p><p><span class="math display">\[\dot{I}=j\omega \dot{q}\]</span></p><h3 id="全空间电磁场表达式">全空间电磁场表达式</h3><p>磁场：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>电场</p><p><span class="math display">\[\begin{cases}&amp;\dot{E}_{r_{s} }=-\frac{\dot{I} d s \beta^{2} \eta 2 \cos \theta} {4 \pi}\left[\frac{1} {\left(j \beta r_{s}\right)^{2} }+\frac{1} {\left(j \beta r_{s}\right)^{3} }\right] e^{-j \beta r_{s} } \\\\&amp;\dot{E}_{\theta}=-\frac{\dot{I} d s \beta^{2} \eta \sin \theta} {4 \pi}\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }+\frac{1} {\left(j \beta r_{s}\right)^{3} }\right] e^{-j \beta r_{s} }\end{cases}\]</span></p><p>其中，有：</p><p><span class="math display">\[\frac{\beta} {\omega \varepsilon}=\frac{1} {c \varepsilon}=\frac{\sqrt{\mu \varepsilon} } {\varepsilon}=\eta\]</span></p><p>这个<span class="math inline">\(\eta\)</span>就是波阻抗。</p><h3 id="时变电偶极子场的讨论">时变电偶极子场的讨论</h3><h4 id="近区场">近区场</h4><p>满足<span class="math inline">\(\beta r_s&lt;&lt;1\)</span>的条件，观察点<span class="math inline">\(P\)</span>离电偶极子比较近，这个区域称为近区。</p><p>在近区中，有：</p><p><span class="math display">\[(\beta r_s)^{-3}&gt;&gt;(\beta r_s)^{-2}&gt;&gt;(\beta r_s)^{-1}\]</span></p><p>而且</p><p><span class="math display">\[e^{-j\beta r_s}=0\]</span></p><p>对于磁场，本来<span class="math inline">\(\tilde{H}\)</span>的表达式是：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>中括号中第一项省去，后面的<span class="math inline">\(\exp\)</span>项省去，有：</p><p><span class="math display">\[\dot{H}_{\varphi\text{近} }\approx \frac{\dot{I} d s \sin \theta} {4 \pi r_{s}^{2} }\]</span></p><p>同理，对于电场，有：</p><p><span class="math display">\[\tilde{E}_{\text{近} }\approx \frac{\dot{I} d s} {4 \pi j \omega \varepsilon} \cdot \frac{1} {r_{s}^{3} }\left[i_{r s} 2 \cos \theta+i_{\theta} \sin \theta\right]\]</span></p><p>我们观察电场和磁场表达式，容易发现，近区场的主要成分是似静场，也就是近似于静电（磁）场的场。它的复坡印廷矢量是一个纯虚数，于是，这部分的能量不会被辐射出现，好像是被束缚在了近区，因此似静场也叫<strong>“束缚场”</strong>。我们可以说：时变电偶极子近区场的主要成分是束缚场；<strong>但是不可以说：近区场就是束缚场。</strong></p><h4 id="远区场">远区场</h4><p>当<span class="math inline">\(\beta r_s&gt;&gt;1\)</span>时，观察点<span class="math inline">\(P\)</span>离电偶极子很远，这样的区域称为远区。</p><p>在远区中，有：</p><p><span class="math display">\[(\beta r_s)^{-1}&gt;&gt;(\beta r_s)^{-2}&gt;&gt;(\beta r_s)^{-3}\]</span></p><p>对于磁场，本来<span class="math inline">\(\tilde{H}\)</span>的表达式是：</p><p><span class="math display">\[\dot{H}_{\varphi}=-\frac{\dot{I} d s \beta^{2} } {4 \pi} \sin \theta\left[\frac{1} {j \beta r_{s} }+\frac{1} {\left(j \beta r_{s}\right)^{2} }\right] e^{-j \beta r_{s} }\]</span></p><p>中括号中的第二项省去，有：</p><p><span class="math display">\[\dot{H}_{\varphi\text{远} } \approx \frac{i d s \sin \theta} {4 \pi r_{s} } j \beta e^{-j \beta r_{s} }=j \frac{i d s \sin \theta} {2 \lambda r_{s} } e^{-j \beta r_{s} }\]</span></p><p>很多同学可能不知道这个等号是怎么回事。我来说明一下：</p><p>有波长公式：</p><p><span class="math display">\[\lambda f=c\]</span></p><p>又有：</p><p><span class="math display">\[\omega=2\pi f\]</span></p><p>因此：</p><p><span class="math display">\[\lambda=\frac{2\pi c} {\omega}\]</span></p><p>又因为：</p><p><span class="math display">\[c=\frac 1{\sqrt{\mu\varepsilon} }\]</span></p><p>因此：</p><p><span class="math display">\[2\lambda\beta=2\cdot\frac{2\pi} {\omega\sqrt{\mu\varepsilon} }\cdot\omega\sqrt{\mu\varepsilon}=4\pi\]</span></p><p>可以看出，掌握电磁场中各个量的代换关系，是非常重要的。</p><p>同理，对于电场，有：</p><p><span class="math display">\[\dot{E}_{\theta} \approx j \eta \frac{\dot{I} d s} {2 \lambda r_{s} } \sin \theta e^{-j \beta r_{s} }\]</span></p><p>计算坡印廷矢量：</p><p><span class="math display">\[\tilde{S}=\frac{1} {2} \tilde{E} \times \widetilde{H}^{*}=i_{r_{s} } \frac{1} {2} \eta\left|\dot{H}_{\varphi}\right|^{2}\]</span></p><p>可以看出，在远区，电磁场有一个向外发射的功率流。远区中，电磁场携带的能量会全部辐射出去，因此远区场的 <strong>主要部分</strong> ，也就是和<span class="math inline">\(r_s^{-1}\)</span>成正比的这部分，被称为辐射场。辐射场中电场和磁场同相位，在等相位面上，电磁场振幅按照<span class="math inline">\(\sin \theta\)</span>规律变化，因此辐射波是一个非均匀球面波。</p><p>必须说明的是：辐射场在近区也是存在的，不过十分微弱，不起主导作用。即：近区场也有能量发射的部分，远区场也有能量交换的部分，这里讨论的只是占主导作用的部分。因此 <strong>不能说：近区场就是束缚场，远区场就是辐射场</strong> 。随着<span class="math inline">\(r_s\)</span>的增长，辐射场（即反比于<span class="math inline">\(r_s\)</span>的项）比其它反比于<span class="math inline">\(r_s\)</span>高次方的项减少的慢，因此辐射场渐渐起了主导作用。用一个示意图描述，就是：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620233646037.png" alt="image-20220620233646037" /><figcaption aria-hidden="true">image-20220620233646037</figcaption></figure><h4 id="方向性函数">方向性函数</h4><p>方向性函数的定义：</p><p><span class="math display">\[F(\theta,\varphi)=\frac{|E(\theta,\varphi)|} {|E_maxx|}\]</span></p><p>在时变电偶极子的情况下，有：</p><p><span class="math display">\[F(\theta,\varphi)=|\sin \theta|\]</span></p><p>在Mathematica中运行代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">SphericalPlot3D</span><span class="hljs-punctuation">[</span><br> <span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">\[Theta]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Theta]</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Pi</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Phi]</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以看出它长这样：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620234231700.png" alt="image-20220620234231700" /><figcaption aria-hidden="true">image-20220620234231700</figcaption></figure><p>其E面方向图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620234857788.png" alt="image-20220620234857788" /><figcaption aria-hidden="true">image-20220620234857788</figcaption></figure><p>H面方向图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220620235040126.png" alt="image-20220620235040126" /><figcaption aria-hidden="true">image-20220620235040126</figcaption></figure><h4 id="辐射功率和辐射电阻">辐射功率和辐射电阻</h4><p>时变电偶极子的辐射功率为：</p><p><span class="math display">\[\dot{P}_r=\oint_A\tilde{S}\mathbf{d}a=\frac \pi 3\eta I^2\left(\frac{ds} {\lambda}\right)^2\]</span></p><p>由</p><p><span class="math display">\[P=I^2R\]</span></p><p>得辐射电阻：</p><p><span class="math display">\[R_r=\frac{2\pi} {3}\eta\left(\frac{ds} {\lambda}\right)^2\]</span></p><h2 id="时变磁偶极子的辐射">时变磁偶极子的辐射</h2><h3 id="时变磁偶极子">时变磁偶极子</h3><p>时变磁偶极子的模型是一个面积为<span class="math inline">\(a\)</span>，载有电流<span class="math inline">\(I(t)\)</span>的导线环。当导线环的大小远远小于波长时，可以视为一个时变磁偶极子。</p><h3 id="电磁对偶原理">电磁对偶原理</h3><p>在讨论时变磁偶极子之前，首先来介绍电磁对偶原理。在之前，曾经提到过对称形式场定律：</p><p><span class="math display">\[\begin{cases}\nabla \times \boldsymbol{H}=\varepsilon_{0} \frac{\partial \boldsymbol{E} } {\partial t}+\boldsymbol{J} \\\\\nabla \cdot \varepsilon_{0} \boldsymbol{E}=\boldsymbol{\rho} \\\\\nabla \cdot \boldsymbol{J}=-\frac{\partial \rho} {\partial t}\end{cases}\]</span></p><p><span class="math display">\[\begin{cases}\nabla \times \boldsymbol{E}=-\mu_{0} \frac{\partial \boldsymbol{H} } {\partial t}-\boldsymbol{J}_{\mathrm{M} } \\\\\nabla \cdot \mu_{0} \boldsymbol{E}=\rho_{\mathrm{M} } \\\\\nabla \cdot \boldsymbol{J}_{\mathrm{M} }=-\frac{\partial \rho_{\mathrm{M} }} {\partial t}\end{cases}\]</span></p><p>这两组方程形式完全相同，只是第一个式子的源是电流、电荷；而第二个式子的源是磁流，磁荷。因此，如果一个只含电流、电荷源的系统的解<span class="math inline">\(E_1\)</span>,<span class="math inline">\(H_1\)</span>已经求得，那么对于一个其它完全相同，只是把电流换成磁流，把电荷换成磁荷的新系统，它的解<span class="math inline">\(E_2\)</span>和<span class="math inline">\(H_1\)</span>，<span class="math inline">\(H_2\)</span>和<span class="math inline">\(E_1\)</span>应该有完全一样的形式</p><p>不妨对比一般性的两个系统a和b，如下。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/73D6797EF70B879E8BF95BC4795FE7A4.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>两个系统有完全相同的区域和边界，只是把电流和磁流，电荷和磁荷调换。那么存在以下的代换关系：</p><p><span class="math display">\[\begin{aligned}E&amp;\to H\\\\H&amp;\to E\\\\\rho &amp;\to -\rho_M\\\\\rho_M &amp;\to -\rho\\\\J&amp;\to-J_M\\\\J_M &amp;\to-J\\\\\varepsilon &amp;\to -\mu\\\\\mu &amp;\to -\varepsilon\end{aligned}\]</span></p><p>如果上面系统<span class="math inline">\((a)\)</span>的解<span class="math inline">\(E_a,H_a\)</span>已经求出，按照上面的代换关系，就可以立刻得到系统<span class="math inline">\((b)\)</span>的解。</p><h3 id="全空间电磁场表达式-1">全空间电磁场表达式</h3><p>结合上面的电磁对偶关系，对于时变电偶极子式子里面的<span class="math inline">\(\beta/\eta=\omega\varepsilon\)</span>应该代换成<span class="math inline">\(-\beta\eta=-\omega\mu\)</span>,因此<span class="math inline">\(\eta\)</span>代换为<span class="math inline">\(-1/\eta\)</span>,还有关系<span class="math inline">\(\dot{I}ds\to-j\omega\mu\dot{I}a\)</span>，可以直接写出全空间电磁场表达式：</p><p><span class="math display">\[\begin{aligned}&amp;\dot{E}_{\varphi}(\boldsymbol{r})=\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} \sin \theta} {4 \pi}\left[\frac{1} {j \beta_{0} r_{s} }+\frac{1} {\left(j\beta_{0} r_{s}\right)^{2} }\right] e^{-j \beta_{0} r_{s} }  \\\\&amp;\dot{H}_{r_{s} }(\boldsymbol{r})=-\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} 2 \cos \theta} {4 \pi \eta_{0} }\left[\frac{1} {\left(j \beta_{0} r_{s}\right)^{2} }+\frac{1} {\left(j \beta_{0} r_{s}\right)^{3} }\right] e^{-j \beta_{0} r_{s} } \\\\&amp;\dot{H}_{\theta}(\boldsymbol{r})=-\frac{j \omega \mu_{0} \dot{I} a \beta_{0}^{2} \sin \theta} {4 \pi \eta_{0} }\left[\frac{1} {j \beta_{0} r_{s} }+\frac{1} {\left(j \beta_{s} r_{\omega}\right)^{2} }+\frac{1} {\left(j \beta_{s} r_{0}\right)^{3} }\right] e^{-j\beta_{0} r_{s} } \end{aligned}\]</span></p><h3 id="时变磁偶极子场的讨论">时变磁偶极子场的讨论</h3><h4 id="近区场-1">近区场</h4><p>近区场应该保留<span class="math inline">\((\beta r_s)\)</span>的最低次项（也就是<span class="math inline">\(\frac{1} {\beta r_s}\)</span>的最高次项）,删去<span class="math inline">\(e\)</span>的指数项，有：</p><p><span class="math display">\[E_\varphi\approx\frac{-j\omega\mu_0\dot{I}a\sin \theta} {4\pi r_s^2}\]</span></p><p><span class="math display">\[H\approx \frac{j\omega\mu_0\dot{I}a} {4\pi j\omega \mu_0}\frac{1} {r_s^3}(i_{rs}2\cos\theta+i_\theta\sin \theta)=\frac{\dot{I}a} {4\pi}\frac{1} {r_s^3}(i_{rs}2\cos\theta+i_\theta\sin \theta)\]</span></p><h4 id="远区场-1">远区场</h4><p><span class="math display">\[H_{远}-\frac{\pi \dot{I}a} {\lambda^2r_s}\sin \theta e^{-j\beta_0r_s}\]</span></p><p><span class="math display">\[E_{远}=\frac{\pi\eta\dot{I}a} {\lambda^2r_s}\sin\theta e^{-j\beta_0r_s}\]</span></p><h4 id="方向性函数-1">方向性函数</h4><p><span class="math display">\[F(\theta,\varphi)=|\sin \theta|\]</span></p><p>形状和电偶极子完全一样，但是E和H面的图要对换。</p><h4 id="辐射功率和辐射电阻-1">辐射功率和辐射电阻</h4><p>由电磁对偶原理，有：</p><p><span class="math display">\[P_r=\frac{\pi} {3\eta}\frac{\omega^2\mu^2I^2a^2} {\lambda^2}\]</span></p><p>化简后， 有：</p><p><span class="math display">\[P_r=\frac{4} {3}\pi^3\eta\frac{I^2a^2} {\lambda^2}\]</span></p><p>在自由空间中，把<span class="math inline">\(\eta=120\pi\)</span>代入，有：</p><p><span class="math display">\[P_r=160\pi^4\frac{I^2a^2} {\lambda^2}\]</span></p><p>辐射电阻为：</p><p><span class="math display">\[R_r=\frac{4\pi^3a^2\eta} {3\lambda^2}\]</span></p><h2 id="其它天线简述">其它天线简述</h2><h3 id="半波天线">半波天线</h3><p>可以理解为电偶极子天线长度变成半个波长。线天线的端点总是电流的波节点，中心点为波腹点。</p><p>方向性函数为：</p><p><span class="math display">\[F(\theta,\varphi)=\frac{\cos(\frac \pi 2\cos \theta)} {\sin \theta}\]</span></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220621114342987.png" alt="image-20220621114342987" /><figcaption aria-hidden="true">image-20220621114342987</figcaption></figure><p>它的指向性比交变电偶极子更窄。</p><p>天线长度越大，方向函数的零、极点越多，主向越向轴线靠拢。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于电磁场的能量的那些事</title>
    <link href="/2022/06/20/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E7%9A%84%E8%83%BD%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/20/%E5%85%B3%E4%BA%8E%E7%94%B5%E7%A3%81%E5%9C%BA%E7%9A%84%E8%83%BD%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>这章的核心是坡印廷定理。</p><span id="more"></span><hr /><h2 id="静电场和静磁场的能量">静电场和静磁场的能量</h2><p>在自由空间的分布电荷系统中，有两种方法计算系统蕴含的静电场能量： <span class="math display">\[W_E=\frac 12\iiint_V \varPhi(r)\rho(r) \mathbf{d}V\]</span> 和 <span class="math display">\[W_E=\iiint_V\frac 12\varepsilon_0\boldsymbol{E}(r)\cdot \boldsymbol{E}(r)\mathbf{d}V\]</span> 其中，定义电场能量密度 <span class="math display">\[w_E=\frac 12\varepsilon_0\boldsymbol{E}(r)\cdot \boldsymbol{E}(r)=\frac 12 \mu_0 |\boldsymbol{E}(r)|^2\ \ \text{(J/m$^3$)}\]</span> 对于点电荷系统来说，原则上不能利用电场能量密度<span class="math inline">\(w_E\)</span>来计算电场能，因为积分不收敛，会得到一个无穷大的结果，此时，只能使用 <span class="math display">\[W_E=\frac 12 \sum_{i=1}^nq_i\varPhi_i\]</span> 来计算。其中<span class="math inline">\(\varPhi_i\)</span>是在点电荷<span class="math inline">\(q_i\)</span>的位置上，除去<span class="math inline">\(q_i\)</span>以外的所有其它电荷产生的电势。有： <span class="math display">\[\varPhi_i=\sum_{k=1,k\neq i}^n \frac {q_k}{4\pi \varepsilon_0r_{ki}}\]</span> 对于自由空间中的电流系统，有磁场能计算公式： <span class="math display">\[W_H=\iiint_V \frac 12 \mu_0\boldsymbol{H}(r)\cdot\boldsymbol{H}(r)\mathbf{d}V\]</span> 于是可以定义磁能密度： <span class="math display">\[w_H=\frac 12 \mu_0\boldsymbol{H}(r)\cdot\boldsymbol{H}(r)=\frac 12 \mu_0 |\boldsymbol{H}(r)|^2\ \  \text{(J/m$^3$)}\]</span> 当然也有类似电场能的另一个公式： <span class="math display">\[W_H=\frac 12\sum_{i=1}^n \Psi_iI_i\]</span> 其中<span class="math inline">\(\Psi_i\)</span>表示系统中和线电流回路<span class="math inline">\(C_i\)</span>交链的磁通量。这个公式很少用到。</p><h2 id="坡印廷定理">坡印廷定理</h2><p>坡印廷定理的基本表达式为： <span class="math display">\[-\nabla \cdot \vec{S}(\vec{r}, t)=p(\vec{r}, t)+\frac{\partial w(\vec{r}, t)}{\partial t}\]</span> 其中<span class="math inline">\(S\)</span>是坡印廷矢量，定义为： <span class="math display">\[\vec{S}(\vec{r}, t)=\vec{E}(\vec{r}, t) \times \vec{H}(\vec{r}, t)\]</span> 其中各项的含义为：</p><ul><li><span class="math inline">\(-\nabla \cdot \vec{S}(\vec{r}, t)\)</span>，即坡印廷矢量的负散度。它表示外界向电磁场中某点所提供的功率流密度。</li><li><span class="math inline">\(p(\vec{r}, t)\)</span>，它表示电磁场对这点的电磁荷提供的电磁功率密度。</li><li><span class="math inline">\(\frac{\partial w(\vec{r}, t)}{\partial t}\)</span>，它表示电磁场在这点蕴含的能量密度的增加率。</li></ul><p>从整体上来说，也就是：外界向一点提供的电磁能必定用于对处在该点的电磁荷做功，和增加电磁场在该点的电磁能。</p><p>在物质中的坡印廷定理有以下形式： <span class="math display">\[-\nabla \cdot \vec{S}(\vec{r}, t)+p_{s}(\vec{r}, t)=p_{d}(\vec{r}, t)+p_{P}(\vec{r}, t)+p_{M}(\vec{r}, t)+\frac{\partial }{\partial t}[w_E(\vec{r}, t)+w_E(\vec{r}, t)]\]</span> 其中：</p><ul><li><p><span class="math inline">\(p_S\)</span>表示电源向电磁场提供的功率。有： <span class="math display">\[p_s(\vec{r},t)=-J_s(\vec{r},t)\cdot E(\vec{r},t)\]</span> 需要注意这里的符号。符号的意思是如果<span class="math inline">\(J_s(\vec{r},t)\cdot E(\vec{r},t)&gt;0\)</span>，这时候实际上是电磁场给电源充电。</p></li><li><p><span class="math inline">\(p_d\)</span>表示由于物质的电阻性而转化为焦耳热的功率。有： <span class="math display">\[p_d(\vec{r},t)=\sigma|\boldsymbol{E}(\vec{r},t)|^2\]</span></p></li><li><p><span class="math inline">\(p_P\)</span>表示用来增加物质极化程度的功率。有： <span class="math display">\[p_P(\vec{r},t)=\boldsymbol{E}(\vec{r},t)\cdot \frac{\partial \boldsymbol{P}(\vec{r},t)}{\partial t}\]</span> 其中<span class="math inline">\(P(\vec{r},t)\)</span>是极化强度，对于简单媒质来说，有： <span class="math display">\[\boldsymbol{P}(\vec{r},t)=\chi_e\varepsilon_0\boldsymbol{E}(\vec{r},t)\]</span> 其中<span class="math inline">\(\chi_e\)</span>是电极化率。</p></li><li><p><span class="math inline">\(p_M\)</span>表示用来增加物质磁化程度的功率。有： <span class="math display">\[p_M(\vec{r},t)=\boldsymbol{H}(\vec{r},t)\cdot \mu_0\frac{\partial \boldsymbol{M}(\vec{r},t)}{\partial t}\]</span></p></li><li><p>上面四条加起来称为“物质消耗的功率”,也就是坡印廷定理一般表达式的<span class="math inline">\(p(\vec{r},t)\)</span>，特殊地，对于电阻性导体，只存在<span class="math inline">\(p_d\)</span>。</p></li><li><p><span class="math inline">\(w_E,w_H\)</span>表示电磁场的储能。</p></li></ul><p>在做题时，还会遇到一个模型，叫“同轴电缆”，一开始我完全不知道它是啥玩意。其实，“同轴电缆”是一个由两部分导体组成的系统，“内导体”是一个半径为<span class="math inline">\(a\)</span>的圆柱体，“外导体”是一片半径为<span class="math inline">\(b\)</span>的圆柱面，这俩是同心的。制造同轴电缆的导体可能是理想的，也可能不是理想的。在一端的内外导体之间，往往接有圆对称的电压源。</p><h2 id="物质中的极化能和磁化能">物质中的极化能和磁化能</h2><h3 id="电容器的能量极化能">电容器的能量：极化能</h3><p>对于公式： <span class="math display">\[p_P(\vec{r},t)=\boldsymbol{E}(\vec{r},t)\cdot \frac{\partial \boldsymbol{P}(\vec{r},t)}{\partial t}\]</span> 将 <span class="math display">\[\boldsymbol{P}(\vec{r},t)=\chi_e\varepsilon_0\boldsymbol{E}(\vec{r},t)\]</span> 代入，可推导得： <span class="math display">\[p_P(\vec{r},t)=\frac{\partial}{\partial t}\left[\frac 12 \boldsymbol{P}(\vec{r},t)\cdot \boldsymbol{E}(\vec{r},t)\right]\]</span> 于是有极化能密度： <span class="math display">\[w_P(\vec{r},t)=\frac 12\boldsymbol{P}(\vec{r},t)\cdot \boldsymbol{E}(\vec{r},t)\]</span> "极化能"的意思，就是电容器两个导体板子中间夹的那一坨电介质因为要极化所以得到的能量。为了完整讨论电介质的能量，我们还要加上电场的能量，即： <span class="math display">\[w_E(\vec{r},t)=\frac 12 \varepsilon_0|E(\vec{r},t)|^2\]</span> 有电能密度： <span class="math display">\[\begin{aligned}w_e&amp;=w_p+w_E\\&amp;=\frac 12E(\vec{r},t)\cdot D(\vec{r},t)\end{aligned}\]</span> 其中<span class="math inline">\(D(\vec{r},t)\)</span>叫电位移矢量，定义如下： <span class="math display">\[D=\varepsilon_0E+P=\varepsilon_0E+\chi_e\varepsilon_0E=(1+\chi_e)\varepsilon_0E=\varepsilon_r\varepsilon_0E\]</span> 于是： <span class="math display">\[w_e=\frac 12 \varepsilon E^2\]</span></p><p>再结合电分里面的电容公式： <span class="math display">\[W_c=\frac 12 CV^2\]</span> 就能求出电容量。</p><h3 id="电感器的能量磁化能">电感器的能量：磁化能</h3><p><span class="math display">\[p_M(\vec{r},t)=\boldsymbol{H}(\vec{r},t)\cdot \mu_0\frac{\partial \boldsymbol{M}(\vec{r},t)}{\partial t}\]</span></p><p>其中<span class="math inline">\(M\)</span>叫磁化强度，有： <span class="math display">\[\mu_0M=(\mu-\mu_0)H\]</span> 在单值简单介质中，有磁化能密度： <span class="math display">\[w_M=\frac 12 \mu_0H(\vec{r},t)\cdot M(\vec{r},t)\]</span> 再加上磁场本身的能量，就有磁能密度： <span class="math display">\[w_H=\frac 12 B\cdot H=\frac 12 \mu H^2\]</span></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统课程设计：频分复用系统设计</title>
    <link href="/2022/06/16/%E4%BF%A1%E5%8F%B7%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <url>/2022/06/16/%E4%BF%A1%E5%8F%B7%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是大作业，频分复用系统设计</p><span id="more"></span><h2 id="实验目的">实验目的</h2><p>本次实验尝试设计一种频分复用系统，接收三个带限信号，通过选取不同的调制频率<span class="math inline">\(\omega_c\)</span>，将所需传输的信号的频谱搬移到不同频段，在同一物理信道中传输多路信号。频分复用的原理框图如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/41CA9D78D2872ED5A23ED8B6346EC6EC.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="实验过程">实验过程</h2><h3 id="读取信号">读取信号</h3><p>输入信号以列表的方式给出，表的形式如下：</p><table><thead><tr class="header"><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(f_1(t)\)</span></th><th><span class="math inline">\(f_2(t)\)</span></th><th><span class="math inline">\(f_3(t)\)</span></th></tr></thead><tbody><tr class="odd"><td>-10</td><td>-0.0498</td><td>0.0032</td><td>0.0031</td></tr><tr class="even"><td>-9.9</td><td>-0.0424</td><td>0.0023</td><td>0.0032</td></tr><tr class="odd"><td>-9.8</td><td>-0.0344</td><td>0.0015</td><td>0.0031</td></tr><tr class="even"><td>-9.7</td><td>-0.0258</td><td>0.0008</td><td>0.003</td></tr><tr class="odd"><td>-9.6</td><td>-0.0167</td><td>0.0004</td><td>0.0028</td></tr><tr class="even"><td>-9.5</td><td>-0.0073</td><td>0.0001</td><td>0.0025</td></tr><tr class="odd"><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr class="even"><td>9.8</td><td>-0.0344</td><td>0.0015</td><td>0.0031</td></tr><tr class="odd"><td>9.9</td><td>-0.0424</td><td>0.0023</td><td>0.0032</td></tr></tbody></table><p>读取数据相关的程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> T[MAXN], f1[MAXN], f2[MAXN], f3[MAXN];<br>tf tf_f1[MAXN], tf_f2[MAXN], tf_f3[MAXN];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;T[cnt], &amp;f1[cnt], &amp;f2[cnt], &amp;f3[cnt]) != EOF) &#123;<br>tf_f1[cnt] = (tf) &#123;T[cnt], f1[cnt]&#125;;<br>tf_f2[cnt] = (tf) &#123;T[cnt], f2[cnt]&#125;;<br>tf_f3[cnt] = (tf) &#123;T[cnt], f3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> length = cnt;<br></code></pre></td></tr></table></figure><p>其中<code>tf</code>结构体是为运算方便定义的结构，其中有两个<code>double</code>型量，即<code>t</code>和<code>f</code>，用来存储时间-信号表。</p><p>原始信号的波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616164757519.png" alt="image-20220616164757519" /><figcaption aria-hidden="true">image-20220616164757519</figcaption></figure><h3 id="获取原始信号的频域图像分析频域特征">获取原始信号的频域图像，分析频域特征</h3><p>对三个原始信号作傅里叶变换，并绘制频域图像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> W[MAXN], F1[MAXN], F2[MAXN], F3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-3.0</span>; w &lt;= <span class="hljs-number">3.0</span>; w += <span class="hljs-number">0.01</span>) &#123;<br>    W[cnt] = w;<br>    F1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f1, length);<br>    F2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f2, length);<br>    F3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f3, length);<br>    ++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">inputWSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;inputW.ppm&quot;</span>)</span></span>;<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F1, cnt, line_blue);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F2, cnt, line_green);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F3, cnt, line_red);<br>inputWSignal.<span class="hljs-built_in">draw</span>();<br></code></pre></td></tr></table></figure><p>其中<code>fourierTransform</code>函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, tf f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].t - f[<span class="hljs-number">0</span>].t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].f * <span class="hljs-built_in">cos</span>(w * f[i].t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>绘制出的频域波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616164823488.png" alt="image-20220616164823488" /><figcaption aria-hidden="true">image-20220616164823488</figcaption></figure><p>可以看出，输入的三个信号都是带限信号。有： <span class="math display">\[\omega_{m1}=1\\\omega_{m2}=2\\\omega_{m3}=\frac \pi 2\]</span> 因此，我们可以使用频分复用的方法把这三个信号合在一个信道中传输。</p><h3 id="频域搬移和信道组合">频域搬移和信道组合</h3><p>由公式： <span class="math display">\[g(t)=\sum_{i=1}^3 f_i(t)\cos(\omega_it)\]</span> 我们可以将这三个信号的频域进行搬移，并组合在一个信道中进行传输。其中<span class="math inline">\(\cos(\omega_it)\)</span>就起到了幅度调制，频域搬移的作用。这是因为： <span class="math display">\[\begin{aligned}\mathscr{F}[f(t)\cos(\omega_0 t)]&amp;=\frac{1}{2\pi}\mathscr{F}[f(t)]\bigotimes\mathscr{F}[\cos(\omega_0 t)]\\&amp;=\frac{1}{2\pi}F(\omega)\bigotimes\pi[\delta(\omega+\omega_0)+\delta(\omega-\omega_0)]\\&amp;=\frac 12[F(\omega+\omega_0)-F(\omega-\omega_0)]\end{aligned}\]</span> 在选择载波频率时，考虑到原始采样频率为<span class="math inline">\(f=10\text{Hz}\)</span>，所以载波频率分别选择 <span class="math display">\[\omega_1=5,\omega_2=12.5,\omega_3=20\]</span> 这部分的代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> omega1 = <span class="hljs-number">5.0</span>, omega2 = <span class="hljs-number">12.5</span>, omega3 = <span class="hljs-number">20.0</span>;<br><span class="hljs-type">double</span> g[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br>tf tf_g[MAXN];<br><span class="hljs-type">int</span> g_length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>g[cnt] = (f1[cnt] * <span class="hljs-built_in">cos</span>(omega1 * t) + f2[cnt] * <span class="hljs-built_in">cos</span>(omega2 * t) + f3[cnt] * <span class="hljs-built_in">cos</span>(omega3 * t));<br>tf_g[cnt] = (tf) &#123;t, g[cnt]&#125;;<br>++cnt;<br>&#125;<br>g_length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">GT</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GT.ppm&quot;</span>)</span></span>;<br>GT.<span class="hljs-built_in">drawXY</span>(T, g, cnt, line_blue);<br><span class="hljs-type">double</span> G[MAXN], w2[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>w2[cnt] = w;<br>G[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_g, g_length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">GW</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GW.ppm&quot;</span>)</span></span>;<br>GW.<span class="hljs-built_in">drawXY</span>(w2, G, cnt, line_blue);<br></code></pre></td></tr></table></figure><p>同时分别画出了<span class="math inline">\(g(t)\)</span>的时域、频域图像，如下：</p><p>时域图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616172004693.png" alt="image-20220616172004693" /><figcaption aria-hidden="true">image-20220616172004693</figcaption></figure><p>频域图像：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616171953072.png" alt="image-20220616171953072" /><figcaption aria-hidden="true">image-20220616171953072</figcaption></figure><p>可见：已经实现了频域搬移。</p><h3 id="使用带通滤波器接受信号">使用带通滤波器接受信号</h3><p>在解调过程中，使用带通滤波器接受信号。对于三个信号，分别采用中心频率为<span class="math inline">\(\omega_i\)</span>，通过频带宽度为<span class="math inline">\(\omega_{mi}\)</span>的带通滤波器。信号<span class="math inline">\(g(t)\)</span>经过带通滤波器以后，被分为了三路信号。对这三路信号，每一路再乘以<span class="math inline">\(\cos(\omega_i t)\)</span>，就把频带移动到了中间。如下图所示：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616172628586.png" alt="image-20220616172628586" /><figcaption aria-hidden="true">image-20220616172628586</figcaption></figure><p>我们再对这三个信号过一个低通滤波器，就能恢复出原来的信号了。</p><p>这部分的代码如下：</p><ol type="1"><li><p>通过带通滤波器分开三路信号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> G1[MAXN], G2[MAXN], G3[MAXN];<br>wF wF_g1[MAXN], wF_g2[MAXN], wF_g3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(G1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G1));<br><span class="hljs-built_in">memset</span>(G2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G2));<br><span class="hljs-built_in">memset</span>(G3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G3));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>G1[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, w);<br>G2[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">12.5</span>, <span class="hljs-number">5.0</span>, w);<br>G3[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">20.0</span>, PI, w);<br>wF_g1[cnt] = (wF) &#123;w, G1[cnt]&#125;;<br>wF_g2[cnt] = (wF) &#123;w, G2[cnt]&#125;;<br>wF_g3[cnt] = (wF) &#123;w, G3[cnt]&#125;;<br>++cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分别再乘以<span class="math inline">\(\cos(\omega_i t)\)</span>再次搬移频域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> G1length = cnt;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> fG1[MAXN], fG2[MAXN], fG3[MAXN];<br>tf tf_fG1[MAXN], tf_fG2[MAXN], tf_fG3[MAXN];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>fG1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g1, G1length);<br>fG2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g2, G1length);<br>fG3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g3, G1length);<br>fG1[cnt] *= <span class="hljs-built_in">cos</span>(omega1 * t);<br>fG2[cnt] *= <span class="hljs-built_in">cos</span>(omega2 * t);<br>fG3[cnt] *= <span class="hljs-built_in">cos</span>(omega3 * t);<br>tf_fG1[cnt] = (tf) &#123;t, fG1[cnt]&#125;;<br>tf_fG2[cnt] = (tf) &#123;t, fG2[cnt]&#125;;<br>tf_fG3[cnt] = (tf) &#123;t, fG3[cnt]&#125;;<br>++cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过低通滤波器，恢复原始信号，并绘制出输出信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> GfG1[MAXN], GfG2[MAXN], GfG3[MAXN];<br>wF wf_gfg1[MAXN], wf_gfg2[MAXN], wf_gfg3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>GfG1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG1, g_length);<br>GfG2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG2, g_length);<br>GfG3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG3, g_length);<br>GfG1[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG2[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG3[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>wf_gfg1[cnt] = (wF) &#123;w, GfG1[cnt]&#125;;<br>wf_gfg2[cnt] = (wF) &#123;w, GfG2[cnt]&#125;;<br>wf_gfg3[cnt] = (wF) &#123;w, GfG3[cnt]&#125;;<br>++cnt;<br>&#125;<br>length = cnt;<br><span class="hljs-type">double</span> finalf1[MAXN], finalf2[MAXN], finalf3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10</span>; t &lt;= <span class="hljs-number">10</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>finalf1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg1, length);<br>finalf2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg2, length);<br>finalf3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg3, length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">outputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;output.ppm&quot;</span>)</span></span>;<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf1, cnt, line_blue);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf2, cnt, line_green);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf3, cnt, line_red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><p>输出信号的波形如下：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220616173101518.png" alt="image-20220616173101518" /><figcaption aria-hidden="true">image-20220616173101518</figcaption></figure><p>可以看出，本次实验较好地完成了频分复用信号传输的任务。</p><p>计算三个信号的均方误差，有：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">MSE1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000048221</span><br><span class="hljs-attribute">MSE2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000652</span><br><span class="hljs-attribute">MSE3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.000000173</span><br></code></pre></td></tr></table></figure><p>可以看出，这个系统的效果还是比较理想。</p><h2 id="实验心得体会">实验心得体会</h2><p>本次实验我综合运用了《信号与系统》课程的相关知识，如奈奎斯特采样定理、傅里叶变换的相关内容，完成了综合信号传输系统的设计，对我的学习非常的有帮助。</p><h2 id="附录">附录</h2><p>本次实验完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM2.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 3000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDTH 1920</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIGHT 1080</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forvec(TYPE,NAME,IT) for(vector<span class="hljs-string">&lt;TYPE&gt;</span>::iterator IT=NAME.begin();IT!=NAME.end();++IT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forset(TYPE,NAME,IT) for(set<span class="hljs-string">&lt;TYPE&gt;</span>::iterator IT=NAME.begin();IT!=NAME.end();++IT)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> EPS = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*fun_p)</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">double</span> t, f;<br>&#125; tf;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">wF</span> &#123;<br><span class="hljs-type">double</span> w, F;<br>&#125; wF;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierInvTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> t, wF f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].w - f[<span class="hljs-number">0</span>].w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].F * <span class="hljs-built_in">cos</span>(t * f[i].w) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans / (<span class="hljs-number">2.0</span> * PI);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, tf f[], <span class="hljs-type">int</span> length)</span> </span>&#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">double</span> step = f[<span class="hljs-number">1</span>].t - f[<span class="hljs-number">0</span>].t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>ans = ans + f[i].f * <span class="hljs-built_in">cos</span>(w * f[i].t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bandPassFilter</span><span class="hljs-params">(<span class="hljs-type">double</span> center, <span class="hljs-type">double</span> band, <span class="hljs-type">double</span> w)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(w - center) &lt; (band / <span class="hljs-number">2.0</span>) || <span class="hljs-built_in">fabs</span>(w + center) &lt; (band / <span class="hljs-number">2.0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><span class="hljs-comment">//return (fabs(w - center) &lt; (band / 2.0)) ? 1.0 : 0.0;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;inputSignal.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>PPMdata background, axis, grid, line_blue, line_green, line_red;<br>background = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line_blue = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br>line_green = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">66</span>, <span class="hljs-number">96</span>, <span class="hljs-number">45</span>);<br>line_red = <span class="hljs-built_in">makePPMdata</span>(<span class="hljs-number">193</span>, <span class="hljs-number">50</span>, <span class="hljs-number">142</span>);<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> T[MAXN], f1[MAXN], f2[MAXN], f3[MAXN];<br>tf tf_f1[MAXN], tf_f2[MAXN], tf_f3[MAXN];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;T[cnt], &amp;f1[cnt], &amp;f2[cnt], &amp;f3[cnt]) != EOF) &#123;<br>tf_f1[cnt] = (tf) &#123;T[cnt], f1[cnt]&#125;;<br>tf_f2[cnt] = (tf) &#123;T[cnt], f2[cnt]&#125;;<br>tf_f3[cnt] = (tf) &#123;T[cnt], f3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">inputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;input.ppm&quot;</span>)</span></span>;<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f1, cnt, line_blue);<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f2, cnt, line_green);<br>inputSignal.<span class="hljs-built_in">drawXY</span>(T, f3, cnt, line_red);<br>inputSignal.<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-type">double</span> W[MAXN], F1[MAXN], F2[MAXN], F3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-3.0</span>; w &lt;= <span class="hljs-number">3.0</span>; w += <span class="hljs-number">0.01</span>) &#123;<br>W[cnt] = w;<br>F1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f1, length);<br>F2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f2, length);<br>F3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_f3, length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">inputWSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;inputW.ppm&quot;</span>)</span></span>;<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F1, cnt, line_blue);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F2, cnt, line_green);<br>inputWSignal.<span class="hljs-built_in">drawXY</span>(W, F3, cnt, line_red);<br>inputWSignal.<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-type">double</span> omega1 = <span class="hljs-number">5.0</span>, omega2 = <span class="hljs-number">12.5</span>, omega3 = <span class="hljs-number">20.0</span>;<br><span class="hljs-type">double</span> g[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br>tf tf_g[MAXN];<br><span class="hljs-type">int</span> g_length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>g[cnt] = (f1[cnt] * <span class="hljs-built_in">cos</span>(omega1 * t) + f2[cnt] * <span class="hljs-built_in">cos</span>(omega2 * t) + f3[cnt] * <span class="hljs-built_in">cos</span>(omega3 * t));<br>tf_g[cnt] = (tf) &#123;t, g[cnt]&#125;;<br>++cnt;<br>&#125;<br>g_length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">GT</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GT.ppm&quot;</span>)</span></span>;<br>GT.<span class="hljs-built_in">drawXY</span>(T, g, cnt, line_blue);<br><span class="hljs-type">double</span> G[MAXN], w2[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>w2[cnt] = w;<br>G[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_g, g_length);<br>++cnt;<br>&#125;<br><span class="hljs-function">Graph <span class="hljs-title">GW</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;GW.ppm&quot;</span>)</span></span>;<br>GW.<span class="hljs-built_in">drawXY</span>(w2, G, cnt, line_blue);<br><br><span class="hljs-type">double</span> G1[MAXN], G2[MAXN], G3[MAXN];<br>wF wF_g1[MAXN], wF_g2[MAXN], wF_g3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(G1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G1));<br><span class="hljs-built_in">memset</span>(G2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G2));<br><span class="hljs-built_in">memset</span>(G3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G3));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>G1[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, w);<br>G2[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">12.5</span>, <span class="hljs-number">5.0</span>, w);<br>G3[cnt] = G[cnt] * <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">20.0</span>, PI, w);<br>wF_g1[cnt] = (wF) &#123;w, G1[cnt]&#125;;<br>wF_g2[cnt] = (wF) &#123;w, G2[cnt]&#125;;<br>wF_g3[cnt] = (wF) &#123;w, G3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">int</span> G1length = cnt;<br><span class="hljs-function">Graph <span class="hljs-title">Gerr</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;Gerr.ppm&quot;</span>)</span></span>;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> fG1[MAXN], fG2[MAXN], fG3[MAXN];<br>tf tf_fG1[MAXN], tf_fG2[MAXN], tf_fG3[MAXN];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10.0</span>; t &lt;= <span class="hljs-number">10.0</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>fG1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g1, G1length);<br>fG2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g2, G1length);<br>fG3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wF_g3, G1length);<br>fG1[cnt] *= <span class="hljs-built_in">cos</span>(omega1 * t);<br>fG2[cnt] *= <span class="hljs-built_in">cos</span>(omega2 * t);<br>fG3[cnt] *= <span class="hljs-built_in">cos</span>(omega3 * t);<br>tf_fG1[cnt] = (tf) &#123;t, fG1[cnt]&#125;;<br>tf_fG2[cnt] = (tf) &#123;t, fG2[cnt]&#125;;<br>tf_fG3[cnt] = (tf) &#123;t, fG3[cnt]&#125;;<br>++cnt;<br>&#125;<br><span class="hljs-type">double</span> GfG1[MAXN], GfG2[MAXN], GfG3[MAXN];<br>wF wf_gfg1[MAXN], wf_gfg2[MAXN], wf_gfg3[MAXN];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = <span class="hljs-number">-40</span>; w &lt;= <span class="hljs-number">40</span>; w += <span class="hljs-number">0.1</span>) &#123;<br>GfG1[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG1, g_length);<br>GfG2[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG2, g_length);<br>GfG3[cnt] = <span class="hljs-built_in">fourierTransform</span>(w, tf_fG3, g_length);<br>GfG1[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG2[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>GfG3[cnt] *= <span class="hljs-built_in">bandPassFilter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, w)*<span class="hljs-number">2.0</span>;<br>wf_gfg1[cnt] = (wF) &#123;w, GfG1[cnt]&#125;;<br>wf_gfg2[cnt] = (wF) &#123;w, GfG2[cnt]&#125;;<br>wf_gfg3[cnt] = (wF) &#123;w, GfG3[cnt]&#125;;<br>++cnt;<br>&#125;<br>length = cnt;<br><span class="hljs-type">double</span> finalf1[MAXN], finalf2[MAXN], finalf3[MAXN];<br><span class="hljs-type">double</span> MSE[<span class="hljs-number">4</span>];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-10</span>; t &lt;= <span class="hljs-number">10</span>; t += <span class="hljs-number">0.1</span>) &#123;<br>finalf1[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg1, length);<br>finalf2[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg2, length);<br>finalf3[cnt] = <span class="hljs-built_in">fourierInvTransform</span>(t, wf_gfg3, length);<br>MSE[<span class="hljs-number">1</span>]+=(finalf1[cnt]-f1[cnt])*(finalf1[cnt]-f1[cnt]);<br>MSE[<span class="hljs-number">2</span>]+=(finalf2[cnt]-f2[cnt])*(finalf2[cnt]-f2[cnt]);<br>MSE[<span class="hljs-number">3</span>]+=(finalf3[cnt]-f3[cnt])*(finalf3[cnt]-f3[cnt]);<br>++cnt;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i) MSE[i]/=(cnt*<span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MSE%d = %.9lf\n&quot;</span>,i,MSE[i]);<br><span class="hljs-function">Graph <span class="hljs-title">outputSignal</span><span class="hljs-params">(WIDTH, HIGHT, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, line_blue, grid, background, axis, <span class="hljs-string">&quot;output.ppm&quot;</span>)</span></span>;<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf1, cnt, line_blue);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf2, cnt, line_green);<br>outputSignal.<span class="hljs-built_in">drawXY</span>(T, finalf3, cnt, line_red);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>"arrayToPPM2.hpp"</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 999999999</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstdio&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstdlib&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cmath&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFuncY(x1,y1,x2,y2,y) ((y-y1)*(x2-x1)/(y2-y1)+x1)</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">double</span> <span class="hljs-params">(*fun_P)</span> <span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;<br><span class="hljs-function">T <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;<br>a = b;<br>b = c;<br>&#125;<br><br><span class="hljs-function">PPMdata <span class="hljs-title">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>PPMdata ans;<br>ans.r = r, ans.g = g, ans.b = b;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">private</span>:<br>PPMdata **matrix;<br><span class="hljs-type">int</span> width;<br><span class="hljs-type">int</span> height;<br><span class="hljs-type">double</span> centerX;<br><span class="hljs-type">double</span> centerY;<br><span class="hljs-type">double</span> rangeX;<br><span class="hljs-type">double</span> rangeY;<br><span class="hljs-type">double</span> gridX;<br><span class="hljs-type">double</span> gridY;<br>PPMdata line, grid, bgc, axis;<br><span class="hljs-type">char</span> *fileName;<br><br><span class="hljs-type">double</span> stepX, stepY;<br><span class="hljs-type">bool</span> drawed;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> idth,<br>      <span class="hljs-type">int</span> eight,<br>      <span class="hljs-type">double</span> enterX,<br>      <span class="hljs-type">double</span> enterY,<br>      <span class="hljs-type">double</span> angeX,<br>      <span class="hljs-type">double</span> angeY,<br>      <span class="hljs-type">double</span> ridX,<br>      <span class="hljs-type">double</span> ridY,<br>      PPMdata ine,<br>      PPMdata rid,<br>      PPMdata ack,<br>      PPMdata xis,<br>      <span class="hljs-type">char</span> *fName);<br>~<span class="hljs-built_in">Graph</span>();<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> y2,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> size,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawPos</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">drawXY</span><span class="hljs-params">(<span class="hljs-type">double</span> *x, <span class="hljs-type">double</span> *y, <span class="hljs-type">int</span> arrayLen,PPMdata color)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num2MatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">bool</span> flag)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>Graph::<span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> idth,<br>             <span class="hljs-type">int</span> eight,<br>             <span class="hljs-type">double</span> enterX,<br>             <span class="hljs-type">double</span> enterY,<br>             <span class="hljs-type">double</span> angeX,<br>             <span class="hljs-type">double</span> angeY,<br>             <span class="hljs-type">double</span> ridX,<br>             <span class="hljs-type">double</span> ridY,<br>             PPMdata ine,<br>             PPMdata rid,<br>             PPMdata ack,<br>             PPMdata xis,<br>             <span class="hljs-type">char</span> *fName) &#123;<br>width = idth;<br>height = eight;<br>centerX = enterX;<br>centerY = enterY;<br>rangeX = angeX;<br>rangeY = angeY;<br>gridX = ridX;<br>gridY = ridY;<br>line = ine;<br>grid = rid;<br>bgc = ack;<br>axis = xis;<br>fileName = fName;<br>drawed = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br>matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PPMdata *) * height);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(width, <span class="hljs-built_in">sizeof</span>(PPMdata));<br>&#125;<br><br>stepX = rangeX / (width * <span class="hljs-number">1.0</span>);<br>stepY = rangeY / (height * <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>matrix[i][j] = bgc;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br><span class="hljs-built_in">drawPos</span>(<span class="hljs-built_in">num2MatPos</span>(centerX + i * gridX, <span class="hljs-number">1</span>), j, grid);<br><span class="hljs-built_in">drawPos</span>(<span class="hljs-built_in">num2MatPos</span>(centerX - i * gridX, <span class="hljs-number">1</span>), j, grid);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">drawPos</span>(j, <span class="hljs-built_in">num2MatPos</span>(centerY + i * gridY, <span class="hljs-number">0</span>), grid);<br><span class="hljs-built_in">drawPos</span>(j, <span class="hljs-built_in">num2MatPos</span>(centerY - i * gridY, <span class="hljs-number">0</span>), grid);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br><span class="hljs-built_in">drawPos</span>(i, height / <span class="hljs-number">2</span>, axis);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-built_in">drawPos</span>(width / <span class="hljs-number">2</span>, i, axis);<br>&#125;<br><br>&#125;<br><br>Graph::~<span class="hljs-built_in">Graph</span>() &#123;<br><span class="hljs-keyword">if</span> (drawed == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Object has been deleted!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::draw</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (drawed) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This Graph has been drawed in %s.\n&quot;</span>, fileName);<br>&#125;<br><span class="hljs-built_in">freopen</span>(fileName, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = height - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; --i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">fclose</span>(stdout);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>drawed = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Graph::num2MatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">bool</span> flag)</span> </span>&#123;<br><span class="hljs-comment">//flag=1 x else y</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(width / <span class="hljs-number">2</span> + (num - centerX) / rangeX * width);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">return</span> (<span class="hljs-type">int</span>)(height / <span class="hljs-number">2</span> + (num - centerY) / rangeY * height);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::drawPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> size,PPMdata color)</span> </span>&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">num2MatPos</span>(x, <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> v = <span class="hljs-built_in">num2MatPos</span>(y, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br><span class="hljs-type">int</span> U = u + i, V = v + j;<br><span class="hljs-keyword">if</span> (U &gt;= width || U &lt; <span class="hljs-number">0</span> || V &gt;= height || V &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> matrix[V][U] = color;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph::drawPos</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, PPMdata color)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> matrix[v][u] = color;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph::drawLine</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2,PPMdata color)</span> </span>&#123;<br><span class="hljs-type">int</span> u1, u2, v1, v2;<br>u1 = <span class="hljs-built_in">num2MatPos</span>(x1, <span class="hljs-number">1</span>);<br>u2 = <span class="hljs-built_in">num2MatPos</span>(x2, <span class="hljs-number">1</span>);<br>v1 = <span class="hljs-built_in">num2MatPos</span>(y1, <span class="hljs-number">0</span>);<br>v2 = <span class="hljs-built_in">num2MatPos</span>(y2, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (u1 &gt;= width || u1 &lt; <span class="hljs-number">0</span> || u2 &gt;= width || u2 &lt; <span class="hljs-number">0</span> || v1 &gt;= height || v1 &lt; <span class="hljs-number">0</span> || v2 &gt;= height || v2 &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawLineError:out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">double</span> k = INF;<br><span class="hljs-keyword">if</span> (u2 != u1)<br>k = (v2 * <span class="hljs-number">1.0</span> - v1 * <span class="hljs-number">1.0</span>) / (u2 * <span class="hljs-number">1.0</span> - u1 * <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(k) &gt;= <span class="hljs-number">2.0</span>) &#123;<br><span class="hljs-keyword">if</span> (y1 &gt; y2) &#123;<br><span class="hljs-built_in">swap</span>(x1, x2);<br><span class="hljs-built_in">swap</span>(y1, y2);<br>&#125;<br>k=(x2-x1)/(y2-y1);<br><span class="hljs-type">double</span> x11=x1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> y = y1; y &lt;= y2; y += stepY) &#123;<br><span class="hljs-built_in">drawPoint</span>(x11, y, <span class="hljs-number">1</span>,color);<br>x11+=stepY*k;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(x1&gt;x2)&#123;<br><span class="hljs-built_in">swap</span>(x1,x2);<br><span class="hljs-built_in">swap</span>(y1,y2);<br>&#125;<br>k=(y2-y1)/(x2-x1);<br><span class="hljs-type">double</span> y11=y1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> x = x1; x &lt;= x2; x += stepX) &#123;<br><span class="hljs-built_in">drawPoint</span>(x, y11, <span class="hljs-number">1</span>,color);<br>y11+=stepX*k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph::drawXY</span><span class="hljs-params">(<span class="hljs-type">double</span> *x, <span class="hljs-type">double</span> *y_save, <span class="hljs-type">int</span> arrayLen,PPMdata color)</span> </span>&#123;<br><br><span class="hljs-type">double</span> *y = (<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) * (arrayLen + <span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i)<br>y[i] = y_save[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawXYError:X is not increasing.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;drawXYError:X out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br><span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (i &gt;= arrayLen) <span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">drawLine</span>(x[i - <span class="hljs-number">1</span>], y[i - <span class="hljs-number">1</span>], x[i], y[i],color);<br>&#125;<br><span class="hljs-built_in">free</span>(y);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于平面电磁波的那些事</title>
    <link href="/2022/06/15/%E5%85%B3%E4%BA%8E%E5%B9%B3%E9%9D%A2%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/06/15/%E5%85%B3%E4%BA%8E%E5%B9%B3%E9%9D%A2%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>主要是课本和PPT的总结，加了一点点我学习时的疑问和感悟。电磁场是真™的难，能学懂的都是神人，反正我是学不懂，哈人。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="平面电磁波相关概念">平面电磁波相关概念</h2><ul><li>等相面：同一时刻，空间振动相位相同的点连成的面</li><li>等幅面：同一时刻，空间振动幅度相同的点连成的面</li><li>平面波：等相面是平面的波</li><li>均匀平面波：也叫UPW，指等相面和等幅面重合的平面波。即：在均匀平面波的等相面上，波有相同的振幅</li><li>球面波：等相面是球面的波</li><li>柱面波：等相面是柱面的波</li><li>TEM波：电场强度和磁场强度矢量在传播方向上的分量为0的电磁波。均匀平面波一定是TEM波，反之不然。例：均匀球面波也是TEM波。</li></ul><h2 id="自由空间平面电磁波的时域解">自由空间平面电磁波的时域解</h2><p>由麦克斯韦方程组的推导，设源量为0，各量不随<span class="math inline">\(x,y\)</span>变化而变化（即等相位面是<span class="math inline">\(xoy\)</span>平面）。</p><p>由于 <span class="math display">\[\begin{aligned}\nabla\cdot \varepsilon_0E=0\\\\\nabla\cdot \mu_0H=0\end{aligned}\]</span> 因此<span class="math inline">\(E,H\)</span>的<span class="math inline">\(z\)</span>分量和<span class="math inline">\(z\)</span>无关。</p><p>由于 <span class="math display">\[\nabla \times H=\varepsilon \frac{\partial E} {\partial t}\]</span> 考虑<span class="math inline">\(i_z\)</span>分量，有： <span class="math display">\[\frac{\partial H_y} {\partial x}-\frac{\partial H_z} {\partial y}=\varepsilon _0\frac{\partial E_z} {\partial t}=0\]</span> 则<span class="math inline">\(E\)</span>的<span class="math inline">\(z\)</span>分量和时间无关(同理，<span class="math inline">\(H\)</span>也是)。因此<span class="math inline">\(E_z,H_z\)</span>是和时间，空间都没有关系的常数。在讨论时变场时不考虑常量，因此。 <span class="math display">\[\begin{aligned}E(z,t)=i_xE_x(z,t)+i_yE_y(z,t)\\\\H(z,t)=i_xH_x(z,t)+i_yH_y(z,t)\\\\\end{aligned}\]</span> 代入麦克斯韦方程 <span class="math display">\[\begin{aligned}\nabla \times E=-\mu_0\frac{\partial H} {\partial t}\\\\\nabla \times H=\varepsilon \frac{\partial E} {\partial t}\\\\\end{aligned}\]</span> 有 <span class="math display">\[\begin{cases}\frac{\partial E_y} {\partial z}=\mu_0\frac{\partial H_x} {\partial t}\\\\[2ex]\frac{\partial H_x} {\partial z}=\varepsilon_0\frac{\partial E_y} {\partial t}\\\\\end{cases}\]</span> 和 <span class="math display">\[\begin{cases}\frac{\partial E_x} {\partial z}=-\mu_0\frac{\partial H_y} {\partial t}\\\\[2ex]\frac{\partial H_y} {\partial z}=-\varepsilon_0\frac{\partial E_x} {\partial t}\\\\\end{cases}\]</span></p><p>一维波动方程（以第二组为例）： <span class="math display">\[\begin{aligned}\frac{\partial E_x} {\partial z^2}=\mu_0\varepsilon_0\frac{\partial^2 E_x} {\partial t^2}\\\\\frac{\partial^2 H_y} {\partial z^2}=\mu_0\varepsilon_0\frac{\partial^2H_y} {\partial t^2}\end{aligned}\]</span> 写成统一的形式： <span class="math display">\[\frac{\partial^2 u} {\partial z^2}=\frac{1} {v^2}\frac{\partial ^u} {\partial t^2}\]</span> 它的解实际上是宗量为<span class="math inline">\((z\pm vt)\)</span>的任意二阶可微分函数，即： <span class="math display">\[u=f(z\pm vt)\]</span> 那么结合麦克斯韦方程组，在电磁场中，它的解为： <span class="math display">\[\begin{aligned}E_x=f_1(z-vt)+f_2(z+vt)=E_x^+ + E_x^-\\\\H_y=\sqrt{\frac{\varepsilon_0} {\mu_0} }[f_1(z-vt)-f_2(z+vt)]=H_y^+ + H_y^-\end{aligned}\]</span> 同理，对1，有： <span class="math display">\[\begin{aligned}E_y=E_y^+ + E_y^-\\\\H_x=H_x^+ + H_x^-\end{aligned}\]</span> 那么所有沿着<span class="math inline">\(z\)</span>传播的平面波都可以写成上面四个解的线性组合。对于<span class="math inline">\(E\)</span>，有： <span class="math display">\[E=i_x(A_1E_x^+ + B_1E_x^-)+i_y(A_2E_y^+ + B_2E_y^-)\]</span> 于是，均匀平面波有这些传播特性：</p><ol type="1"><li><p>电场方向和磁场方向总和波的传播方向，也就是波印庭矢量的方向垂直，即： <span class="math display">\[S=E\times H\]</span></p></li><li><p>自由空间中，相速度等于光速，有： <span class="math display">\[v=c=(\mu_0\varepsilon_0)^{-1/2}\]</span></p></li><li><p>空间中任意一点，电场和磁场的波形和相位都相同，而且他们的数值之比是常数，这个比叫空间波阻抗，有： <span class="math display">\[\eta_0=\frac{|E|} {|H|}=\sqrt{\frac{\mu_0} {\varepsilon_0} }=120\pi\]</span></p></li><li><p>空间中任意一点，电场和磁场正交</p></li><li><p>空间中任意一点，电场和磁场的能量密度相等。</p></li></ol><p>## 正弦时变场和复数场定律</p><p>对于一个瞬时正弦时变场： <span class="math display">\[A(r,t)=i_xA_x(r)\cos\left[\omega t+\theta_x(r)\right]+i_yA_y(r)\cos\left[\omega t+\theta_y(r)\right]+i_zA_z(r)\cos\left[\omega t+\theta_z(r)\right]\]</span> 可以借鉴“相量法”的思想，把它写成复矢量形式： <span class="math display">\[A(r,t)=\Re[\tilde{A}(r)e^{j\omega t}]\]</span> 其中<span class="math inline">\(\tilde{A}(r)\)</span>就是我们所说的正弦量的复表示。有： <span class="math display">\[\tilde{A}(r)=i_xA_x(r)\angle\theta_x(r)+i_yA_y(r)\angle\theta_y(r)+i_zA_z(r)\angle\theta_z(r)\]</span> 在麦克斯韦方程组中，把对时间求导的<span class="math inline">\(\frac{\partial } {\partial t}\)</span>换成<span class="math inline">\(j\omega\)</span>，把各量换成复矢量表示，就得到了复数场定律。</p><p><strong>简单媒质</strong>中复数场定律如下： <span class="math display">\[\begin{aligned}\nabla \times \tilde{E}(\vec{r})&amp;=-j \omega \mu \widetilde{H}(\vec{r}) \\\\\nabla \times \widetilde{H}(\vec{r})&amp;=\tilde{J}_{f}(\vec{r})+j \omega \varepsilon \widetilde{E}(\vec{r}) \\\\\nabla \cdot \varepsilon \tilde{E}(\vec{r})&amp;=\dot{\rho}_{f}(\vec{r}) \\\\\nabla \cdot \mu \widetilde{H}(\vec{r})&amp;=0 \\\\\nabla \cdot \tilde{J}_{f}(\vec{r})&amp;=-j \omega \dot{\rho}_{f}(\vec{r})\end{aligned}\]</span></p><h2 id="正弦均匀平面波">正弦均匀平面波</h2><p>由复数场定律可导出<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>齐次亥姆霍兹方程： <span class="math display">\[\begin{aligned}\Delta\tilde{E}(r)+\beta^2\tilde{E}(r)=0\\\\\Delta\tilde{H}(r)+\beta^2\tilde{H}(r)=0\end{aligned}\]</span> 其中 <span class="math display">\[\beta=\omega\sqrt{\mu\varepsilon}=\frac{2\pi} {\lambda}\]</span> 我们知道沿<span class="math inline">\(z\)</span>传播的均匀平面波有两组独立的解<span class="math inline">\(\dot{E}_x-\dot{H}_y\)</span>和<span class="math inline">\(\dot{E}_y-\dot{H}_x\)</span>，只需讨论第一组，有解： <span class="math display">\[\dot{E}_x(z)=\dot{E}_{m_1}e^{j\beta z}+\dot{E}_{m_2}e^{ -j\beta z}\]</span> 结合 <span class="math display">\[\nabla\times\tilde{E}(r)=-j\omega\tilde{H}(r)\]</span> 可以求出<span class="math inline">\(\dot{H}_y\)</span>.</p><p>写出对应的时域表达式，有： <span class="math display">\[\begin{aligned}E_x(z,t)&amp;=\Re[\dot{E}_x(z)e^{j\omega t}]\\\\&amp;=|\dot{E}_{m1}|\cos(\omega t+\beta z+\alpha_1)+|\dot{E}_{m2}|\cos(\omega t-\beta z+\alpha_2)\\\\&amp;=|\dot{E}_{m1}|\cos\left[\beta(z+vt)+\alpha_1\right]+|\dot{E}_{m2}|\cos\left[\beta(z-vt)+\alpha_2\right]\end{aligned}\]</span> 其中<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(\dot{E}_m\)</span>的幅角。于是，各项的物理意义便很明显了：复振幅<span class="math inline">\(\dot{E}_m\)</span>反映了电场在<span class="math inline">\(z=0\)</span>点的初始振幅和相位，而<span class="math inline">\(e^{\pm j\beta z}\)</span>反映了相位随空间位置的变化和波的传播情况。其中<span class="math inline">\(\beta\)</span>称为空间相位常数。</p><h3 id="复数场极化方向的判断">复数场极化方向的判断</h3><p>电场的极化方向也就是说电场矢量尖端在和电磁场传播方向垂直的平面上划出的轨迹形状。有圆、椭圆、线极化三种。在判断复数场的极化方向时，有以下的操作步骤。</p><p>对于复数场 <span class="math display">\[\begin{aligned}\tilde{E}(r)&amp;=\dot{E}_me^{-j\beta z}\\\\&amp;=[E_R(z)+j\cdot E_I(z)]e^{-j\beta z}\end{aligned}\]</span></p><ol type="1"><li><p>线极化：以下三条件<strong>任意</strong>满足一项 <span class="math display">\[E_R(z)=0,\ E_I(z)=0, E_R(z)//E_I(z)\]</span></p></li><li><p>圆极化：<strong>同时</strong>满足以下条件 <span class="math display">\[E_R(z)\cdot E_I(z)=0 ,\ |E_R(z)|=|E_I(z)|\]</span></p></li><li><p>椭圆极化：其余情况。</p></li></ol><p>判断左旋还是右旋的方法是：在右手系（即右手从<span class="math inline">\(x\)</span>轴握向<span class="math inline">\(y\)</span>轴，大拇指指向<span class="math inline">\(z+\)</span>方向）中，画出电磁场传播方向（也就是波因亭矢量的方向）、<span class="math inline">\(E_R\)</span>、<span class="math inline">\(E_I\)</span>，然后用右手从<span class="math inline">\(E_I\)</span>向<span class="math inline">\(E_R\)</span>握，如果大拇指指向<span class="math inline">\(S\)</span>，那么就是右旋，否则是左旋。</p><h3 id="空间任意方向电磁场的表达">空间任意方向电磁场的表达</h3><p>前面我们讨论的都是沿着<span class="math inline">\(z\)</span>轴的电磁场。如果指向<span class="math inline">\(i_xa+i_yb+i_zc\)</span>的电磁场，我们就要改变<span class="math inline">\(e\)</span>的指数。有： <span class="math display">\[\tilde{E}(r)=\dot{E}_me^{-j(ax+by+cz)}\]</span> 这时，<span class="math inline">\(\beta=\sqrt{a^2+b^2+c^2}\)</span>.</p><p>通过例题来感受一下。</p><blockquote><p>【例】已知均匀平面波的电场为 <span class="math display">\[E(\boldsymbol{r},t)=10(i_x+2i_y+E_zi_z)\cos(\omega t+3x-y-z)\]</span> 求：传播方向（用单位矢量表示），波长，角频率，极化状态，磁场（用复矢量表示）</p><p>【解】 <span class="math display">\[\begin{aligned}\tilde{E}(\boldsymbol{r})&amp;=\dot{E}_0e^{-j\boldsymbol{\beta \cdot r} }\\\\&amp;=10(i_x+2i_y+E_zi_z)e^{-j(-3x+y+z)}\\\\\end{aligned}\]</span> 波的传播方向： <span class="math display">\[\boldsymbol{i}_\beta=\frac{\boldsymbol{\beta} } {|\boldsymbol{\beta}|}=\frac{-3i_x+i_y+i_z} {\sqrt{3^2+1+1} }=\left(\frac{-3} {\sqrt{11} },\frac 1{\sqrt{11} },\frac 1{\sqrt{11} }\right)\]</span> 波长： <span class="math display">\[\lambda=\frac{2\pi} {\beta}=\frac{2\pi} {\sqrt{11} }=1.89\text{(m)}\]</span> 角频率： <span class="math display">\[\omega=\beta c=3\sqrt{11}\times 10^8 \text{(rad/s)}\]</span> 由于电场方向和电磁场传播方向应该正交，即： <span class="math display">\[\boldsymbol{\beta}\cdot \dot{E}_0=0\]</span> 则解得<span class="math inline">\(E_z=1\)</span></p><p>由于满足 <span class="math display">\[\Im[E_0]=0\]</span> 因此是线极化波。</p><p>由 <span class="math display">\[H=\frac 1{\eta_0}i_\beta\times\tilde{E}(r,t)\]</span> 可求得<span class="math inline">\(H\)</span>.</p></blockquote><h2 id="复数形式场的功率讨论">复数形式场的功率讨论</h2><h3 id="复矢量乘积的意义">复矢量乘积的意义</h3><p>容易证明：两个复矢量的共轭叉（点）积的实部的一半等于相应的正弦时变量叉（点）积的时间平均值。</p><p>即： <span class="math display">\[\langle\vec{A}(t) \times \vec{B}(t)\rangle=\frac{1} {2} \operatorname{Re}\left(\tilde{A} \times \tilde{B}^{*}\right)\]</span></p><p><span class="math display">\[\langle\vec{A}(t) \cdot \vec{B}(t)\rangle=\frac{1} {2} \operatorname{Re}\left(\tilde{A} \cdot \tilde{B}^{*}\right)\]</span></p><p>证明提示：</p><p>用公式 <span class="math display">\[\vec{A}(t)=\frac{1} {2}\left[\tilde{A} e^{j \omega t}+\tilde{A}^{*} e^{-j \omega t}\right]\]</span> 把时变量运算式中的时变量和复矢量关联起来。</p><h3 id="复数坡印廷矢量">复数坡印廷矢量</h3><p>在前面，我们学过时域坡印廷矢量： <span class="math display">\[\boldsymbol{S}(\boldsymbol{r},t)=\boldsymbol{E}(\boldsymbol{r},t)\times\boldsymbol{H}(\boldsymbol{r},t)\]</span> 将电场，磁场的时域表达式用复数形式来表示，即： <span class="math display">\[\begin{aligned}\boldsymbol{E}(\boldsymbol{r},t)=\frac 12[\tilde{E}(r)e^{j\omega t}+\tilde{E}^*(r)e^{-j\omega t}]\\\\\boldsymbol{H}(\boldsymbol{r},t)=\frac 12[\tilde{H}(r)e^{j\omega t}+\tilde{H}^*(r)e^{-j\omega t}]\end{aligned}\]</span> 代入： <span class="math display">\[\boldsymbol{S}(\boldsymbol{r},t)=\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)]+\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)2^{j2\omega t}]\]</span> 定义复数坡印廷矢量： <span class="math display">\[\tilde{S}(r)=\frac 12 \tilde{E}(r)\times\tilde{H}^*(r)\]</span> 则有： <span class="math display">\[\frac 12\Re[\tilde{E}(r)\times \tilde{H}^*(r)]=\langle S(r,t)\rangle=\Re[\tilde{S}(r)]\]</span> 于是，我们可以说：复数坡印廷矢量的实部表示有功功率流密度，虚部可以解释为无功功率流密度。（这里可以类比电路分析中的复功率<span class="math inline">\(\dot{P}=\dot{V}_m\dot{I}_m/2=P+jQ\)</span>）</p><h3 id="复数坡印廷定理">复数坡印廷定理</h3><p>复数坡印廷定理的微分形式表达式如下： <span class="math display">\[-\nabla \cdot \tilde{S}(\vec{r})-\frac{1} {2}\left[\tilde{E}(\vec{r}) \cdot \tilde{J}_{S}^{*}(\vec{r})\right]=\frac{1} {2}\left[\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})\right]+j 2 \omega\left[\frac{\mu} {4}|\widetilde{H}(\vec{r})|^{2}-\frac{\varepsilon} {4}|\tilde{E}(\vec{r})|^{2}\right]\]</span> 为了理解其中各项物理意义，解释如下：</p><ul><li><p>等号左边第二项 <span class="math display">\[\Re\left[-\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{S}^{*}(\vec{r})\right]=\langle J_s(r,t)\times E(r,t)\rangle=\langle p_s(r,t)\rangle\]</span> 这一项表示电源提供的有功功率</p></li><li><p>等号右边第一项 <span class="math display">\[\Re\left[\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})\right]=\langle p_d(r,t)\rangle\]</span> 这一项表示电阻消耗的功率（即焦耳热功率）。注意：因为 <span class="math display">\[\frac 12\tilde{E}(\vec{r}) \cdot \tilde{J}_{d}^{*}(\vec{r})=\frac 12\sigma |\tilde{E}(r)|^2\]</span> 所以这一项实际上是纯实数。</p></li><li><p>等号右边第二项 <span class="math display">\[\frac{\mu} {4}|\widetilde{H}(\vec{r})|^{2}=\langle\frac 12 \mu H(r,t)\cdot H(r,t)\rangle=\langle w_m(r,t)\rangle\]</span> 这一项可以理解为电感能量，也是纯实数（乘以前面的系数就是纯虚数了）</p></li><li><p>等号右边第三项 <span class="math display">\[\frac{\varepsilon} {4}|\tilde{E}(\vec{r})|^{2}=\langle\frac 12 \varepsilon E(r,t)\cdot E(r,t)\rangle=\langle w_e(r,t)\rangle\]</span> 这一项可以理解为电容的能量。</p></li></ul><p>我们把上面那个式子的实部和虚部拆开，有：</p><ul><li><p>实部： <span class="math display">\[\langle-\nabla \cdot \vec{S}(\vec{r}, t)\rangle+\left\langle p_{s}(\vec{r}, t)\right\rangle=\left\langle p_{d}(\vec{r}, t)\right\rangle\]</span> 电磁场向某点提供的电磁功率密度的时间平均值（有功电磁功率密度）与电源向该点提供的电磁功率密度的时间平均值（有功电磁功率密度）之和，等于该点焦耳热损耗功率密度的时间平均值。</p></li><li><p>虚部 <span class="math display">\[-\operatorname{Im}[\nabla \cdot \tilde{S}(\vec{r})]+q_{S}(\vec{r})=2 \omega\left[\left\langle w_{m}(\vec{r}, t)\right\rangle-\left\langle w_{e}(\vec{r}, t)\right\rangle\right]\]</span> 电磁场和电源向某点提供的无功电磁功率密度等于该点的磁能功率密度时间平均值和电能功率密度时间平均值之差的<span class="math inline">\(2𝜔\)</span>倍</p></li></ul><h2 id="平面波在有耗媒质中的传播">平面波在有耗媒质中的传播</h2><p>有耗媒质的根本特征是其电导率<span class="math inline">\(\sigma\)</span>不为零，进而，其中的传导电流<span class="math inline">\(J_d\)</span>不为零。因此，电磁波在其中传播时会产生损耗。特别的，如果电导率很高，以至于成为导体（例如金属），那么电磁波在其中几乎不能传播，只能在表面传播，这叫做“趋肤效应”。电磁波不能在理想导体中传播。</p><p>考虑复数形式的修正安培环路定律： <span class="math display">\[\nabla \times \tilde{H}(r)=\tilde{J}+j\omega \varepsilon\tilde{E}(r)\]</span> 将 <span class="math display">\[\tilde{J}=\sigma\tilde{E}(r)\]</span> 代入，有： <span class="math display">\[\nabla \times \tilde{H}(r)=\sigma\tilde{E}(r)+j\omega \varepsilon\tilde{E}(r)=j\omega\left(\frac{\sigma} {j\omega}+\varepsilon\right)\tilde{E}(r)\]</span> 定义复介电常数： <span class="math display">\[\dot{\varepsilon}=\left(\frac{\sigma} {j\omega}+\varepsilon\right)\]</span> 用复介电常数替换复麦克斯韦方程组中<strong>所有</strong>的介电常数，就能得到有耗媒质中的场定律。</p><p>需要注意的是，这时候波阻抗也变成了复数，即： <span class="math display">\[\dot{\eta}=\frac{\mu} {\dot{\varepsilon} }\]</span> 仿照前面的过程<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，导出复亥姆霍兹方程。仿照传播常数(波数)<span class="math inline">\(\beta\)</span>，定义复传播常数 <span class="math display">\[\dot{k}=\omega\sqrt{\dot{\varepsilon}\mu}=\beta-j\alpha\]</span> 那么，在有耗媒质中传播的电磁波的电场和磁场的复表示如下： <span class="math display">\[\begin{aligned}&amp;\widetilde{E}(r)=\hat{\imath}_{x} \dot{E}_{x 0} e^{-\alpha z} e^{-j \beta z}=\hat{\imath}_{x}\left|\dot{E}_{x 0}\right| e^{j \varphi_{x 0} } e^{-\alpha z} e^{-j \beta z} \\\\&amp;\widetilde{H}(r)=\hat{\imath}_{y} \frac{\dot{E}_{x 0} } {\dot{\eta} } e^{-\alpha z} \cdot e^{-j \beta z}=\hat{\imath}_{y}\left|\frac{\dot{E}_{x 0} } {\dot{\eta} }\right| e^{j\left(\varphi_{x 0}-\varphi_{\eta}\right)} e^{-\alpha z} e^{-j \beta z}\end{aligned}\]</span> 这里之所以要特意把<span class="math inline">\(\dot{E}_{x0}\)</span>以及<span class="math inline">\(\dot{E}_{x0}/\dot{\eta}\)</span>拆开成模长-幅角模式来写，是为了体现平面波在有耗媒质中的传播特点。</p><p>在有耗无源简单媒质中传播的均匀平面波是一个沿传播方向衰减的均匀平面波，衰减因子用<span class="math inline">\(\alpha\)</span>表示。电磁波频率越高，衰减因子越大，最终会趋向于 <span class="math display">\[\max \alpha=\frac {\sigma} {2}\sqrt{\frac{\mu} {\varepsilon} }\]</span> <strong>且磁场与电场不再同相</strong>。这是因为波阻抗不再是实数。</p><h3 id="导体的趋肤效应">导体的趋肤效应</h3><p>导体的电导率<span class="math inline">\(\sigma\)</span>越大，衰减因子也就越大。透入深度表示幅度衰减为<span class="math inline">\(e^{-1}\)</span>的深度，对良导体，其值为： <span class="math display">\[\delta=\sqrt{\frac 2{\omega\sigma\mu} }\]</span></p><h2 id="平面波的反射和折射">平面波的反射和折射</h2><h3 id="相关概念">相关概念</h3><ul><li><p>入射线：入射波波矢量<span class="math inline">\(\boldsymbol{\beta}_i\)</span>所在的直线</p></li><li><p>入射面：同时包含入射线和界面法线的平面</p></li><li><p>入射角：入射线和法线的夹角</p></li><li><p>反射线：反射波波矢量<span class="math inline">\(\boldsymbol{\beta}_r\)</span>所在的直线</p></li><li><p>反射面：同时包含反射线和界面法线的平面</p></li><li><p>反射角：反射线和法线的夹角</p></li><li><p>折射线：折射波波矢量<span class="math inline">\(\boldsymbol{\beta}_\tau\)</span>所在的直线</p></li><li><p>折射角：折射线和界面法线的夹角</p></li><li><p>垂直极化：线极化波的电场和入射面垂直</p></li><li><p>平行极化<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>：线极化波的电场和入射面平行</p></li><li><p>媒质的折射指数（折射率）： <span class="math display">\[n=\sqrt{\mu_r\varepsilon_r}\]</span> 其中<span class="math inline">\(\mu_r,\varepsilon_r\)</span>是相对磁导率和相对介电常数<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p></li><li><p>媒质的波数： <span class="math display">\[\beta=\omega\sqrt{\mu_1\varepsilon_1}=\beta_0n_1\]</span></p></li><li><p>媒质的波阻抗： <span class="math display">\[\eta_1=\sqrt{\frac{\mu_1} {\varepsilon_1} }=\eta_0\sqrt{\frac{\mu_{r1} } {\varepsilon_{r1} }}\]</span></p></li><li><p>Snell定律</p><ul><li>反射线和折射线都在入射面内</li><li>反射角等于入射角</li><li>折射角和入射角的正弦之比等于折射率之比，也等于波数之比和波的传播速度之比。</li></ul></li><li><p>光密（疏）介质：一个媒质的折射指数（折射率）越大，光（电磁波）在其中传播的速度越慢，波数<span class="math inline">\(\beta\)</span>越大，它就越可以被称为光密介质。真空是最疏的介质。</p></li></ul><h3 id="自由空间和理想导体界面的反射">自由空间和理想导体界面的反射</h3><h4 id="正入射">正入射</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/5711CB1D86975C4E56B6223EE37219FC.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图所示，入射波为 <span class="math display">\[\begin{aligned}\tilde{E}(r)=i_x\dot{E}_{i0}e^{-j\beta_0z}\\\\\tilde{H}(r)=i_y\frac{\dot{E}_{i0} } {\eta_0}e^{-j\beta_0z}\end{aligned}\]</span> 那么反射波的形式为： <span class="math display">\[\begin{aligned}\tilde{E}_r(r)=i_x\dot{E}_{r0}e^{j\beta_0z}\\\\\tilde{H}_r(r)=i_y\frac{\dot{E}_{r0} } {\eta_0}e^{j\beta_0z}\end{aligned}\]</span> 下面求<span class="math inline">\(\dot{E}_{r0}\)</span>。由边界条件： <span class="math display">\[i_n\times(\tilde{E}_1-\tilde{E}_2)=0\]</span> 其中： <span class="math display">\[\begin{aligned}\tilde{E}_1&amp;=\tilde{E}_i+\tilde{E}_r\\\\\tilde{E}_2&amp;=0\\\\i_n&amp;=-i_z\end{aligned}\]</span> 代入，得： <span class="math display">\[\dot{E_{r0} }=-\dot{E}_{i0}\]</span> 则有： <span class="math display">\[\begin{aligned}\tilde{E}_r(r)=-i_x\dot{E}_{i0}e^{j\beta_0z}\\\\\tilde{H}_r(r)=-i_y\frac{\dot{E}_{i0} } {\eta_0}e^{j\beta_0z}\end{aligned}\]</span> 合成波表达式为<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>： <span class="math display">\[\begin{aligned}\tilde{E}(r)=-2j\cdot i_x \dot{E}_{i0}\sin \beta_0z\\\\\tilde{H}(r)=2\cdot i_y\frac{\dot{E}_{i0} } {\eta_0}\cos \beta_0z\end{aligned}\]</span> 为了研究合成波的性质，我们把它转换到时域： <span class="math display">\[\begin{aligned}E(r,t)=i_x\cdot2|\dot{E}_{i0}|(\sin\beta_0z)\sin(\omega t+\varphi)\\\\H(r,t)=i_y\cdot\frac{2} {\eta_0}|\dot{E}_{i0}|(\cos\beta_0z)\cos(\omega t+\varphi)\end{aligned}\]</span> 我们可以看到，这表达了一列驻波。在驻波中电场和磁场有所谓“三个90度”关系，即：</p><ul><li>电场和磁场在空间分布上的相位差为90度。这说明：电场最强的 <strong>地方</strong> 磁场最弱。</li><li>电场和磁场在时间分布上的相位差为90度。这说明：电场最强的 <strong>时刻</strong> 磁场最弱。</li><li>电场和磁场在空间方向上相差90度。</li></ul><p>在驻波中，没有能量指向性的传播，只有能量形式的转换。</p><h4 id="斜入射">斜入射</h4><p>首先以垂直极化为例分析问题：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220617223348.png" /></p><p><strong>特别注意：不要看着这张图上面画了线，就以为电磁波“只在那条线上存在”，我们这里讨论的是平面波，入射波、反射波都在<span class="math inline">\(z&lt;0\)</span>整个空间上存在，所以可以直接合成，不需要也不应该考虑位置。</strong></p><p>入射方向： <span class="math display">\[\vec{\beta}_{i}=\beta_{0}\left(i_{x} \sin \theta_{i}+i_{z} \cos \theta_{i}\right)\]</span> 反射方向： <span class="math display">\[\vec{\beta}_{r}=\beta_{0}\left(i_{x} \sin \theta_{r}-i_{z} \cos \theta_{r}\right)\]</span> 那么，分别有入射场和反射场： <span class="math display">\[\begin{aligned}\tilde{E}_{i} &amp;=i_{y} \dot{E}_{i 0} e^{-j \vec{\beta}_{i} \cdot \vec{r} }=i_{y} \dot{E}_{i 0} e^{-j \beta_{0}\left(x \sin \theta_{i}+z \cos \theta_{i}\right)} \\\\\tilde{E}_{r} &amp;=i_{y} \dot{E}_{r 0} e^{-j \beta_{0}\left(x \sin \theta_{r}-z \cos \theta_{r}\right)}\end{aligned}\]</span> 由边界条件计算，得： <span class="math display">\[\dot{E}_{r0}=-\dot{E}_{i0}\]</span> 那么空间中的合成电场为：</p>$$<span class="math display">\[\begin{aligned}\tilde{E}&amp;=\tilde{E}_{i}+\tilde{E}_{r}=i_{y}\left[\dot{E}_{i 0} e^{-j \beta_{0}(x \sin \theta+z \cos \theta)}-\dot{E}_{i 0} e^{-j \beta_{0}(x \sin \theta-z \cos \theta)}\right]\\\\&amp;=i_{y} \dot{E}_{i 0}\left(e^{-j \beta_{0} z \cos \theta}-e^{j \beta_{0} z \cos \theta}\right) e^{-j \beta_{0} x \sin \theta}\\\\&amp;=-i_{y} \dot{E}_{i 0} j 2 \sin \left(\beta_{0} z \cos \theta\right) e^{-j \beta_{0} x \sin \theta} \end{aligned}\]</span><p>$$</p><p>记 <span class="math inline">\(\beta_0\cos \theta=\beta_z,\beta_0\sin\theta=\beta_x\)</span> ，有：</p><p><span class="math display">\[\tilde{E}=-i_{y} 2 j \dot{E}_{i 0} \sin \beta_{z} z \cdot e^{-j \beta_{x} x}\]</span></p><p>再由麦克斯韦方程组可求得磁场。</p><p>观察<span class="math inline">\(\tilde{E}\)</span>的表达式，我们发现有以下特点：</p><ol type="1"><li>在<span class="math inline">\(x\)</span>是常数的平面上，<span class="math inline">\(e^{-j\beta_xx}\)</span>是常数，所以<span class="math inline">\(x=C\)</span>是波的等相面。在<span class="math inline">\(x=C\)</span>的平面上，场量按三角函数形式分布，波显示出驻波性质。</li><li>在<span class="math inline">\(z\)</span>是常数的平面上，<span class="math inline">\(\sin \beta_zz\)</span>是常数，波的表达式表现出一般平面波的形式，是行波。而且在等相面上振幅不是常数，是非均匀平面波。</li><li>于是，我们可以发现：合成波只在<span class="math inline">\(x\)</span>方向有能量传输，而在<span class="math inline">\(z\)</span>方向没有。</li></ol><p>正入射时，入射波和反射波的合成波形成了一种特殊的传播方式，我们称之为驻波。 <strong>斜入射时，入射波和反射波的合成波也形成了一种特殊的传播方式，我们称之为导行波。</strong> 这里的电场指向<span class="math inline">\(y\)</span>，和传播方向垂直，我们称之为横电波（TE波）。</p><p>导行波的等相面是 <span class="math display">\[\omega t-\beta_x x=C\]</span> 因此，其相速度为 <span class="math display">\[v_p=\frac c {\sin\theta}\]</span> 神奇！相速度超过了光速！但是我们都知道光速是无论如何不能超过的，这是怎么回事呢？我们要先理解相速度和群速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/v2-192809449ccca511cddfb1735ed54b8d_720w.gif" alt="这个图片只用来说明相速度和群速度的概念" /><figcaption aria-hidden="true">这个图片只用来说明相速度和群速度的概念</figcaption></figure><ul><li>相速度是等相位面传播的速度，也就是图中红色方块的速度。</li><li>群速度的波包移动的速度，是能量传递的速度，也就是绿色圆点移动的速度。</li></ul><p>我们可以看出，只有群速度是真正的速度。譬如说，我拿着一个激光笔扫过夜空，那么激光笔在云层上反射的光点可能会具有非常非常非常高的速度，那么难道说真的有物体在以这个速度移动吗？不是这样的。相速度只是一种“看起来”的速度，是一个虚假的速度。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/0F8C440DC9578247F927A8C922F4A842.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图，在这个情景中，黑色的实线和虚线是等相位面，蓝色是相速度，绿色是群速度，红色是光速。这么一说大家应该可以理解了。在一个周期里，导行波过<span class="math inline">\(A\)</span>点的等相位面的相位传到了<span class="math inline">\(C\)</span>点，从<span class="math inline">\(X\)</span>方向看，就像是相位从<span class="math inline">\(B\)</span>移动到了<span class="math inline">\(C\)</span>，而此时能量只是从A移动到了<span class="math inline">\(C’\)</span>。</p><p>在平行极化时，合成波的磁场是横向的，电场是<span class="math inline">\(xOz\)</span>面内的椭圆极化波。合成波依然在<span class="math inline">\(x\)</span>方向表现行波，在<span class="math inline">\(z\)</span>方向表现为驻波。这种波叫横磁波（TM波）。</p><h3 id="在两种理想介质分界面处的反射和折射">在两种理想介质分界面处的反射和折射</h3><p>这里讨论的是两种均匀、线性、各向同性、无耗理想介质分界面处的反射和折射。</p><h4 id="两种无耗介质交界面的垂直入射">两种无耗介质交界面的垂直入射</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/12414515.png" /></p><p>入射波为 <span class="math display">\[\begin{aligned}\tilde{E}(r)=i_x\dot{E}_{i0}e^{-j\beta_0z}\\\\\tilde{H}(r)=i_y\frac{\dot{E}_{i0} } {\eta_0}e^{-j\beta_0z}\end{aligned}\]</span> 不难写出反射波，折射波的表达式：只需要把入射波中的<span class="math inline">\(E_{i0}\)</span>换成<span class="math inline">\(E_{r0},E_{\tau 0}\)</span>，再注意一下方向就行了，十分的简单。我们的问题现在是：<span class="math inline">\(E_{i0}\)</span>和<span class="math inline">\(E_{r0},E_{\tau 0}\)</span>的关系是？</p><p>由边界条件： <span class="math display">\[\begin{aligned}i_{n} \times\left.\left(\tilde{E}_{1}-\tilde{E}_{2}\right)\right|_{z=0}=0 \quad \\\\i_{n} \times\left.\left(\widetilde{H}_{1}-\widetilde{H}_{2}\right)\right|_{z=0}=\tilde{k}_{f}=0\end{aligned}\]</span> 得： <span class="math display">\[\left\{\begin{array} {l}\dot{E}_{i 0}+\dot{E}_{r 0}=\dot{E}_{\tau 0} \\\\\dot{H}_{i 0}-\dot{H}_{r 0}=\dot{H}_{\tau 0} \Rightarrow \frac{\dot{E}_{i 0} } {\eta_{1} }-\frac{\dot{E}_{r 0} } {\eta_{1} }=\frac{\dot{E}_{\tau 0} } {\eta_{2} }\end{array}\right.\]</span></p><p>于是有反射系数： <span class="math display">\[\Gamma=\frac{\dot{E}_{r 0} } {\dot{E}_{i 0} }=\frac{\eta_{2}-\eta_{1} } {\eta_{2}+\eta_{1} }\]</span> 透射系数： <span class="math display">\[T=\frac{\dot{E}_{\tau 0} } {\dot{E}_{i 0} }=\frac{2 \eta_{2} } {\eta_{2}+\eta_{1} }\]</span></p><h4 id="三层介质垂直入射无反射条件">三层介质垂直入射无反射条件</h4><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220617234904444.png" /></p><p>一般来说应用场景是：I是空气（真空），III是玻璃，II是增透膜，要求你调整增透膜的<span class="math inline">\(\eta_2\)</span>和厚度。有以下两种情况都能达到目的：</p><ol type="1"><li><span class="math inline">\(\eta_1=\eta_3,d=n\lambda_2/2\)</span></li><li><span class="math inline">\(\eta_2=\sqrt{\eta_1\eta_3},d=(2n+1)\lambda_2/4\)</span></li></ol><p>请注意，这里的波长是在介质2中的波长。电磁场在不同介质中，频率是不会变 ，而波长会变。</p><h4 id="斜入射-1">斜入射</h4><p>还是以垂直极化为例：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220617235606731.png" /></p><p>同样，由边界条件计算反射、透射系数，有：</p><p>反射系数： <span class="math display">\[\Gamma_{\perp}=\frac{\dot{E}_{r 0} } {\dot{E}_{i 0} }=\frac{\eta_{2} \cos \theta_{1}-\eta_{1} \cos \theta_{2} } {\eta_{2} \cos \theta_{1}+\eta_{1} \cos \theta_{2} }\]</span></p><p>透射系数： <span class="math display">\[T_{\perp}=\frac{\dot{E}_{\tau 0} } {\dot{E}_{i 0} }=\frac{2 \eta_{2} \cos \theta_{1} } {\eta_{2} \cos \theta_{1}+\eta_{1} \cos \theta_{2} }\]</span></p><p>有时候会出现一些神奇的现象：</p><ul><li><p>全反射</p><p>全反射无论是磁介质（<span class="math inline">\(\mu_r\neq 1\)</span>）还是电介质（<span class="math inline">\(\varepsilon_r\neq 1\)</span>）都可以产生。当从光密介质射入光疏介质时，当入射角达到一个临界值<span class="math inline">\(\theta_c\)</span>时，反射线和介质表面重合（反射角是<span class="math inline">\(\pi/2\)</span>），这时称为出现全反射现象，<span class="math inline">\(\theta_c\)</span>是全反射临界角。有： <span class="math display">\[\sin \theta_c=\frac{n_2} {n_1}\]</span></p></li><li><p>全折射 当入射波垂直极化时，在电介质交界面，不会出现全折射现象，只有磁介质交界面才会出现。无论从疏到密，还是从密到疏，都能发生全折射现象。全折射的临界角<span class="math inline">\(\theta_{P_\perp}\)</span>称为布茹斯特角。有： <span class="math display">\[\theta_{P_\perp}=\sqrt{\frac{\mu_2} {\mu_1+\mu_2} }\]</span></p></li></ul><p>我写了一个代码来计算反射系数和折射系数：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">er1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质1的相对介电常数&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">mur1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质1的相对磁导率&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">er2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质2的相对介电常数&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">mur2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Input</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;介质2的相对磁导率&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">eta0</span><span class="hljs-operator">=</span><span class="hljs-number">120</span><span class="hljs-operator">*</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">;</span><br><span class="hljs-variable">eta1</span><span class="hljs-operator">=</span><span class="hljs-variable">eta0</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur1</span><span class="hljs-operator">/</span><span class="hljs-variable">er1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">eta2</span><span class="hljs-operator">=</span><span class="hljs-variable">eta0</span><span class="hljs-operator">*</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur2</span><span class="hljs-operator">/</span><span class="hljs-variable">er2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">n1</span><span class="hljs-operator">=</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur1</span><span class="hljs-operator">*</span><span class="hljs-variable">er1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">n2</span><span class="hljs-operator">=</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">mur2</span><span class="hljs-operator">*</span><span class="hljs-variable">er2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span><span class="hljs-built_in">ArcSin</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sin</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">*</span><span class="hljs-variable">n1</span><span class="hljs-operator">/</span><span class="hljs-variable">n2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Gammaa</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">-</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">Tt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:=</span> <span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-operator">*</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-punctuation">(</span><span class="hljs-variable">eta2</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">eta1</span><span class="hljs-operator">*</span><span class="hljs-built_in">Cos</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Rfl</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Gammaa</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-built_in">Abs</span><span class="hljs-punctuation">[</span><span class="hljs-variable">Tt</span><span class="hljs-punctuation">[</span><span class="hljs-variable">theta</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">theta</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-operator">,</span><span class="hljs-built_in">Pi</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">,</span><span class="hljs-built_in">PlotLegends</span><span class="hljs-operator">-&gt;</span><span class="hljs-string">&quot;Expressions&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>例如，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>会给出图像</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220618114117442.png" alt="全反射现象示意图" /><figcaption aria-hidden="true">全反射现象示意图</figcaption></figure><p>全反射现象十分明显。</p><p>再例如输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>会给出图像</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220618114215103.png" alt="全折射现象示意图" /><figcaption aria-hidden="true">全折射现象示意图</figcaption></figure><p>从疏介质射入密介质，这里发生了全折射。</p><hr /><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>由于<span class="math inline">\(\nabla\times\tilde{E}(r)=-j\omega\mu\tilde{H}(r)\)</span>，两边取旋度，有<span class="math inline">\(\nabla\times\nabla\times\tilde{E}(r)=-j\omega\mu\nabla \times \tilde{H}(r)\)</span>，代入<span class="math inline">\(\nabla \times \tilde{H}(r)=j\omega\varepsilon\tilde{E}(r)\)</span>，并结合矢量公式<span class="math inline">\(\nabla\times\nabla\times A=\nabla[\nabla \cdot A]-\Delta A\)</span>即可推出。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>由于<span class="math inline">\(\nabla\times\tilde{E}(r)=-j\omega\mu\tilde{H}(r)\)</span>，两边取旋度，有<span class="math inline">\(\nabla\times\nabla\times\tilde{E}(r)=-j\omega\mu\nabla \times \tilde{H}(r)\)</span>，代入<span class="math inline">\(\nabla \times \tilde{H}(r)=j\omega\varepsilon\tilde{E}(r)\)</span>，并结合矢量公式<span class="math inline">\(\nabla\times\nabla\times A=\nabla[\nabla \cdot A]-\Delta A\)</span>即可推出。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>椭圆极化波和圆极化波可以分解成两个垂直的线极化波，进而，可以分解成垂直极化和平行极化波。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>相对磁导率（介电常数）意思是媒质中的磁导率（介电常数）和真空中的比值。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p><span class="math inline">\(\sin x=\frac{1} {2j}(e^{jx}-e^{-jx})\)</span>,<span class="math inline">\(\cos x=\frac{1} {2}(e^{jx}+e^{-jx})\)</span><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电磁场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告4：集成运放实验2</title>
    <link href="/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A4/"/>
    <url>/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A4/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第四个实验，运用555定时器和集成运放的实验。</p><span id="more"></span><h2 id="方波发生器">方波发生器</h2><p>LM555是一款具有精确定时功能的芯片，利用其工作原理，可以实现脉冲波发射电路。在电路正常工作时，可以通过调节滑动变阻器<span class="math inline">\(R_1\)</span>，来调节脉冲波的占空比。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607230056150.png" alt="image-20220607230056150" /><figcaption aria-hidden="true">image-20220607230056150</figcaption></figure><h2 id="锯齿波发生器">锯齿波发生器</h2><p>锯齿波的产生原理是对方波进行积分。在这里使用一个单运放积分器即可。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220608223724447.png" alt="image-20220608223724447" /><figcaption aria-hidden="true">image-20220608223724447</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220608223742381.png" alt="image-20220608223742381" /><figcaption aria-hidden="true">image-20220608223742381</figcaption></figure><h2 id="正弦波发生器">正弦波发生器</h2><p>正弦波发生器的工作原理是对脉冲波进行滤波得到基波分量，这里使用一个单运放有源滤波器进行滤波。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220609113906066.png" alt="image-20220609113906066" /><figcaption aria-hidden="true">image-20220609113906066</figcaption></figure><h2 id="系统级实验">系统级实验</h2><p>系统级实验需要把前面三项实验组合在一起，其中三次谐波分量的生成需要一个带通滤波器。还应该考虑电路之间的互相影响，调节元器件参数。</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220613142835570.png" alt="image-20220613142835570" /><figcaption aria-hidden="true">image-20220613142835570</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220613142910664.png" alt="image-20220613142910664" /><figcaption aria-hidden="true">image-20220613142910664</figcaption></figure><h2 id="感想与体会">感想与体会</h2><p>这部分就自己写哈</p><hr /><p>本实验各文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E5%AE%9E%E9%AA%8C%202%EF%BC%88555%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89.zip">集成运放实验2 555定时器 下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告3：集成运放实验1</title>
    <link href="/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A3/"/>
    <url>/2022/06/14/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A3/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第三个实验，集成运放实验1。</p><span id="more"></span><h2 id="单运放波形发生器">单运放波形发生器</h2><p>考虑到波形近似的可能，在方波生成器参考点引入反馈，可以获得近似三角波的波形。其中电容<span class="math inline">\(C_1\)</span>较大时可以获得良好的积分曲线，但是同时可能导致波形发生器的频率太低，也就是说信号的幅度，周期，频率是相互制约的。综合考虑实验要求，<span class="math inline">\(C_1\)</span>选择<span class="math inline">\(1\mu F\)</span>。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607204743998.png" alt="image-20220607204743998" /><figcaption aria-hidden="true">image-20220607204743998</figcaption></figure><h2 id="单运放加法器">单运放加法器</h2><p>考虑到正相加法器的电阻参数是互相关联的，不能单独调整，而且信号源的内阻会影响电路的增益，而反相加法器实现简单，调试方便，因此这里选用反相加法电路。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607204102829.png" alt="image-20220607204102829" /><figcaption aria-hidden="true">image-20220607204102829</figcaption></figure><h2 id="单运放四阶滤波器">单运放四阶滤波器</h2><p>此处采用四阶带通有源滤波器设计，其滤波效果更好，带外衰减比较大。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607214307585.png" alt="image-20220607214307585" /><figcaption aria-hidden="true">image-20220607214307585</figcaption></figure><h2 id="比较器">比较器</h2><p>对速度要求不高时，采用无穷大阻抗反馈可以把普通运算放大器作为比较器使用。故采用如图所示的设计。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607221123119.png" alt="image-20220607221123119" /><figcaption aria-hidden="true">image-20220607221123119</figcaption></figure><h2 id="系统级实验">系统级实验</h2><p>系统级实验是前面四个实验的组合，级联时需要考虑前后级模块的匹配问题，适当调整参数。三</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607224348279.png" alt="image-20220607224348279" /><figcaption aria-hidden="true">image-20220607224348279</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607224402833.png" alt="image-20220607224402833" /><figcaption aria-hidden="true">image-20220607224402833</figcaption></figure><h2 id="感想与体会">感想与体会</h2><p>这部分就自己写哈。</p><hr /><p>本次实验各文件下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E5%AE%9E%E9%AA%8C%201.zip">集成运放实验1下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220613-20220619）</title>
    <link href="/2022/06/13/%E5%91%A8%E8%AE%B0%EF%BC%8820220613-20220619%EF%BC%89/"/>
    <url>/2022/06/13/%E5%91%A8%E8%AE%B0%EF%BC%8820220613-20220619%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><p>@[toc]</p><hr /><h2 id="section">20220613</h2><blockquote><p>今天是6月13号，晚上的8：36</p></blockquote><p>经典咏流传。没想到这么快就迎来《考试周破防》一周年了。一年以前的北京，还是一个能出去打剧本杀，然后在酒店通宵的北京。可是现在......哎，不提也罢。</p><p>今天早上虽然起来了，但是好像没做什么事情。下午做完了信号实验，然后确定了一下信号大作业的题目。</p><p>看看，不做计划就是这样：基本上啥也没干。所以明天要做计划。</p><p><strong>明天早上要八点半起来！然后写电磁场作业、再复习复习电磁场，下午上课，晚上先做电影大作业再做信号大作业。</strong></p><p>我的模电、信号实验报告都会在这学期彻底结束以后放在博客上。相关的实验文件和代码会放在GitHub上。</p><h2 id="section-1">20220614</h2><p>今天写了电磁场作业，但是没写完。写了军理卷子，信号大作业，信号大作业也没做完，但是感觉工作量还算可以了。</p><p>明天要做这些事：复习电磁场的平面波部分，最好能写篇笔记；写完电磁场作业；写完信号大作业；复习模电的频响部分；写电影大作业，重要程度从高到低。</p><p>今天我的一个朋友去澳门大学参观的申请被通过了，挺好的。我们的境外大学的项目又硬核、又是线上、还贵，我也不太想参加。</p><p>今天我们班得了优秀团支部，虽然不知道这玩意有啥用，但总之就是优秀吧。</p><h2 id="section-2">20220615</h2><p>今天复习了电磁场的平面波部分，写了篇笔记；写完了电磁场作业；写完了信号大作业；还写了个🐌报告。</p><p>别的没什么值得说的了。平淡的一天。</p><p>今天下了个百合游戏，感觉应该挺好玩。</p><h2 id="section-3">20220616</h2><p>今天继续复习了电磁场，但是还有问题没搞明白，那就是“导行波”到底是个什么东西。</p><p>今天写完了信号大作业的实验，复习了一下模电的频响和运放部分。</p><p>今天点了个外卖，叫“堡藏”，一个虾仁鸡肉饼汉堡和一个鱼肉肉卷，汉堡还不错，肉卷感觉菜有点多了，总之也还算可以，打分能打个75。不过这家默认给甜辣酱，好评。</p><p>今天看完了派对咖孔明，观感不错，期待第二季。</p><p>把相合之物加进补番序列中。</p><h2 id="section-4">20220617</h2><p>本学年度最后一课，堂堂结束！ 今天主要学了电磁场，把平面电磁波相关的部分算是彻底搞完了，开心。 明天要学模电。就是这样。 哎，xc，真奇怪，为什么总有那么多神神秘秘的说法呢？我只是想生活得简单一点。</p><h2 id="section-5">20220618</h2><p>今天把电磁场平面波的博客发出去了，而且还比较粗略地把模电的知识点都过了一遍。接下来就该刷题、刷PPT了。模电没法写博客，图太多了，画图太累。</p><p>我趣，我多长时间没看动画了？夏日重现都忘了看了！！明天一定看。</p><p>明天要：做模电题，复习电磁场的能量部分，写信号课后题作业。出卷子的作业等考完模电再说。</p><h2 id="section-6">20220619</h2><p>今天学习的内容：电影大作业，体育大作业，博雅材料，信号课后题</p><p>另外今天我还做了一件非常有意义的事情！那就是，彻底整理并记录了一下我的桌子上的杂物！！总计121件！！！牛逼吧！！！！</p><p>今天看了夏日重现。</p><p>明天要：做模电题，复习电磁场的能量部分，从现在到模电考完我再看一眼信号我就是狗。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xc能为宅宅做的35件实事</title>
    <link href="/2022/06/11/xc%E8%83%BD%E4%B8%BA%E5%AE%85%E5%AE%85%E5%81%9A%E7%9A%8435%E4%BB%B6%E5%AE%9E%E4%BA%8B/"/>
    <url>/2022/06/11/xc%E8%83%BD%E4%B8%BA%E5%AE%85%E5%AE%85%E5%81%9A%E7%9A%8435%E4%BB%B6%E5%AE%9E%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>1. 承担一半（或以上）的小组作业或科研工作。</strong></p><p>你需要承担自己份内的小组作业，按时完成，不需请求，不找借口。要知道，我们当前的习惯性的任务分配模式，包括我们对此的观念，都是非常有利于xc的，是宅宅歧视的。作为支持宅权主义的xc，你有责任与这些传统观念抗争。如果说宅权主义是理论，那么多写两行代码就是实践。请在接下来的一周记录你写了多少代码，并和你组中的宅宅作比较，看看任务分配是否平均。</p><p><strong>2. 在与群友、同事的关系中，承担一半（或以上）的精神支持工作。</strong></p><p>你要认识到，宅宅所承担的情绪劳动要比xc多得多[注1]，而这项劳动会占据他们实现个人抱负的时间和精力。</p><p>[注1]：读者自证不难</p><p><strong>3. 购买二次元的文化产品。</strong></p><p>不管你是喜欢法国电影、天体物理学，还是棒球、观鸟……请保证二次元的声音和宅宅创作的文化产品出现在你的文化消费清单之中。如果此前你的消费清单上从没出现过二次元的作品，现在就努力把它们找出来吧。</p><p><strong>4. 给宅宅留出空间。</strong> 宅宅出门在外都会觉得缺乏安全感并感到紧张，尤其是在晚间出行或单独出行的时候。这种不安全感在有陌生xc接近并且抱在一起互相啃食时会加剧。想一想有多少宅宅曾经在公共场合被xc虐待，你就知道宅宅的这种恐惧并非无缘无故。同时请注意，即使你不是那种真会对宅宅造成威胁的xc，也请不要随意离他们太近，因为他们没法在大街上判断出你到底危不危险。</p><p>举个例子：在公交上，请优先坐在情侣旁边、而不是宅宅旁边的空座上。如果你与独自走夜路的宅宅同路，请穿到马路对面走，避免跟在他身后，这样他就不用担心自己是否被虐狗了。</p><p><strong>5. 请充分利用自己的xc身份制止宅宅歧视。</strong></p><p>例如：公开反驳那些在群里秀恩爱的线虫。如果在酒吧里、在聚会上、在地铁上……看到你的宅宅朋友似乎正苦于应付面前的情侣，都请你友好地上前打断他们，为你的宅宅朋友制造出一个可以脱身的机会。 我知道做这样的事情可能会非常困难和尴尬，而且大家都不太清楚究竟怎么做才更合适，但是总该去努力尝试一下。如果自己一时的尴尬能让宅宅感到更舒适，那这么做也是值得的。</p><p><strong>6. 如果有宅宅告诉你“这是xc对我的歧视”，请相信他。</strong></p><p><strong>7. 请弄清楚什么情况下是可以秀恩爱的。</strong></p><p><strong>8. 承担被移出群聊的责任。</strong></p><p><strong>9. 每天观看一集动画片</strong></p><p><strong>10. 接受进步的文化娱乐观念。</strong></p><p><strong>11. 如果你看电影，请平等地做观赏者。</strong></p><p>你在看xc电影时，也同时要看等量（或以上）的二次元儿电影。</p><p><strong>12. 注意到并反对那些在无形中强化了xc和宅宅角色分工的行为。</strong></p><p>比如说吃饭的时候，请观察是不是基本上只有宅宅在认真吃饭，而xc们则在一旁聊天娱乐，高谈阔论。如果是这样，请主动改变这种情况，并说服其他xc跟你一起这样做。</p><p><strong>13. 请留心自己与身边的宅宅之间是否存在明显和不明显的权利差异。</strong></p><p>请努力意识到所有基于种族、阶级、性别、性取向、年龄等因素的固有结构性权利差异。当你受益于这些结构性不平等时，你要能意识到自己究竟享有了哪些特权，并尝试打破这些不平等，以实现权利的均衡。</p><p><strong>14. 请将真诚和尊重作为与宅宅保持群友关系和同事关系的前提。</strong></p><p>你与宅宅交往的方式基本可以反映出你对宅宅的价值观。如果你像对待垃圾一样对待自己的群友，那不管你有多支持宅权主义理论都没用。</p><p><strong>15. 请不要做宅宅歧视的线上旁观者。</strong></p><p>如果在网络上，尤其是社交网络上看到宅宅歧视言论或行为，请一定站起来质疑它们。</p><p><strong>16. 当你和宅宅在一个组里时，请对自己的财务状况负责。</strong></p><p>如果你不能对自己的财务状况负起责任来，你的组员必定会因此受牵连。由于宅宅收入普遍低于xc，但是宅宅的寿命又普遍长于xc，所以这也是个宅权议题。</p><p><strong>17. 请对自己的健康负责。</strong></p><p><strong>18. 不要盯着宅宅看或者对他们的生活评头论足。</strong></p><p><strong>19. 留意媒体中出现的各种专家和重要信息提供者的属性。</strong></p><p>当你在电视中看到或者在文章中读到某位专家的观点，请注意一下这些专家是不是都是xc，他们的观点是不是都是从xc的角度提出的，或者请至少想一想，若是从宅宅的角度来看这个问题，可能会有哪些不同。</p><p><strong>20. 请确保你也有一些宅宅偶像和榜样。</strong></p><p><strong>21. 在生活中向他人夸赞你身边宅宅的优点和成就。</strong></p><p>当你在日常对话和交流中提到某个你知道的宅宅时，请正面积极地评价他。请利用自己的关系网为你的宅宅朋友提供与他人合作共事的机会。</p><p><strong>22. 在你的xc朋友面前表现得正直一点（也就是说，不要因为xc情义就纵容他那些对宅宅失礼的行为）。</strong></p><p>当你的男性朋友表现得很大xc主义的时候（例如胡乱秀恩爱，侮辱宅宅等等），请做一个正直的朋友，去劝阻他。你的正直想法仅仅停留在脑中是不够的，要说出口，让他们意识到自己的错误。</p><p><strong>23. 不要嫌你的群友“死宅”，他“死宅”可能是因为你“线虫”。</strong></p><p>注：特意采用“死宅”来翻译“otaku”，是想提醒大家注意，这个中文词汇本身就很有宅宅歧视的意味。</p><p><strong>24. 仅仅承认你有宅宅歧视的倾向和保守老旧的思想是不够的，你得付诸行动，做出改变。</strong></p><p><strong>25. 将宅宅当做朋友看待。</strong></p><p>如果你没有二次元朋友，请弄明白为什么。尝试交一些宅宅朋友，并确保你和他的友谊是真诚可信的、有意义的。我们越多与他人接触，多关心别人，越能建立一个更平等的社会。</p><p><strong>26. 寻找宅宅领袖或导师（也就是说成为宅宅的下属）</strong></p><p>如果你在寻找一名导师，或者想到某个组织当志愿者，请去找二次元组织或者由二次元领导的组织。你可以从权威的宅宅身上学到很多东西。</p><p><strong>27. 请对每一个二次元角色的生日负责。</strong></p><p>请记住你自己的宅宅群友喜欢的lp的生日、纪念日和重要活动的日期。</p><p><strong>28. 不要对宅宅的xp指手画脚。</strong></p><p><strong>29. 千万不要提议与需要出门宅宅朋友同行。</strong></p><p><strong>30. 将宅权主义融入你与其他xc的日常交谈中。</strong></p><p><strong>31. 如果你在酒精或者npy的作用下可能会对宅宅有失礼的行为，那就请你不要摄入酒精或者npy。</strong></p><p><strong>32. 请留意你所占据的公共空间，不管是身体上的还是情绪上的，不要占据过多的，超出基本需求的空间。</strong></p><p><strong>33. 真正着手解决地位不平等问题。</strong></p><p><strong>34. 要明白你的xc是一种与生俱来的特权，并努力放弃你所拥有的特权；不要以为宅宅是与生俱来的劣势，也不要觉得克服这种劣势仅仅是宅宅的责任。</strong></p><p><strong>35. 认同自己“宅权主义者”的身份。</strong></p><p>将宅权主义当做是一种自然地、平常的、无可争议的信念，因为本来就应该是这样的。不要躲藏掩饰，不要使用“人道主义者”或者“宅权主义同盟”这样的概念，因为这会让人们更容易觉得“宅权主义”是个很恐怖的字眼儿。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记（20220606-20220612）</title>
    <link href="/2022/06/08/%E5%91%A8%E8%AE%B0%EF%BC%8820220606-20220612%EF%BC%89/"/>
    <url>/2022/06/08/%E5%91%A8%E8%AE%B0%EF%BC%8820220606-20220612%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>于是终于打算写一写周记，其实是日记合集，希望能坚持。</p><span id="more"></span><hr /><h2 id="section">20220606</h2><p>因为这篇是8号才想起来写的，所以忘了。今日无事。 今天配置了一下Typora自动上传图片。</p><h2 id="section-1">20220607</h2><p>今天做了一天模电实验。前四个实验的报告我已经发在博客里了，不过是Hide模式，防止抄袭吧。 555定时器生成三角波的实验还没调出来。 今天出考表了。焦虑。一方面是，我热爱知识，但我痛恨考试。另一方面是，一学期又碌碌无为地过去了。</p><h2 id="section-2">20220608</h2><p>今天可以说是学了一天电磁场。主要学了平面波、复数形式场定律的内容，清了一下作业。复数形式场定律很像相量法，可以结合起来学。 另外：今天看了真理元素的《这才是电真正的工作原理》，感觉受益匪浅。这个视频主要讨论了如果导线长度非常非常长，但是在电源旁边有一个灯泡 <img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220608182609659.png" alt="image-20220608182609659" /> 那么打开开关，灯泡过多久才会亮的问题。电路中能量通过电磁场在空间中传播，而不是靠电子携带。开关闭合前电路中已经有正负电荷分布，开关闭合后电荷重新分配，这一过程产生的电磁波以开关为中心，以光速向外扩散，受这一电磁波影响的导线即会接收到能量，出现电流。 另外这个视频的背景也非常的有趣，一言以之，曰：</p><blockquote><p>真理越辩越明。</p></blockquote><p>一位我高考时候加的学弟也高考了。祝福他有美好的前程。</p><p>555定时器生成三角波的实验调出来了，生成正弦波的还没有。老是削顶失真。</p><h2 id="section-3">20220609</h2><p>今天早上做了基物实验《太阳能电池》，这是我的最后一个基物实验，也很可能是我人生中最后一次参与标题中有“物理”二字的课程。虽然不是和物理“say goodbye”吧，也是蛮感慨的。</p><blockquote><p>再见了，所有的“物理”。</p></blockquote><p>所以这次的B站视频以《One last kiss》作为BGM。</p><p>下午学了信号，晚上复习了信号，写了总结，无需多言。</p><p>今天发了助学金。</p><p>上周六的抽代出分了，90多分，还行，挺好的。我的数学二学位也快毕业了。</p><p>555定时器生成正弦波的实验调出来了。</p><p>今天洗了澡。</p><h2 id="section-4">20220610</h2><p>今天学了一下AB分离法。</p><p>不会吧不会吧，不会真的只有我做了模电实验吧，这下小丑竟是我自己了。</p><p>晚上吃了朋友送的榴莲蛋糕，好吃。</p><p>哈哈哈，这互联网又搞笑了，怎么回事呢？</p><p>明天要：总结模电笔记，学电磁场，晚上写Z变换笔记。</p><h2 id="section-5">20220611</h2><p>结果是今天早上和下午写了Z变换笔记，晚上把期中考前的模电总结了。</p><p>明天应当继续学习电磁场。</p><p>今晚和朋友一起自习了，还下雨了，挺开心的。要是没有考试就更是开心了。</p><p>为什么只有我的电路能仿真？？难道是我的问题？？？</p><h2 id="section-6">20220612</h2><p>麻了呀，越起越晚，我咋这么fw呢？明天一定要早起！</p><p>今天学了一下电磁场，写完了Z变换，做完了模电实验。</p><p>今天吃了个牛肉卷外卖，很好吃捏。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告2：差分放大电路仿真与分析</title>
    <link href="/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A2/"/>
    <url>/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A2/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第二个实验，差分放大电路。</p><span id="more"></span><hr /><h2 id="差分放大电路">差分放大电路</h2><h3 id="普通差分放大电路">普通差分放大电路</h3><p>实验原始电路图如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607164117446.png" alt="image-20220607164117446" /><figcaption aria-hidden="true">image-20220607164117446</figcaption></figure><h4 id="直流工作点分析">直流工作点分析</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607164142482.png" alt="image-20220607164142482" /><figcaption aria-hidden="true">image-20220607164142482</figcaption></figure><table><thead><tr class="header"><th style="text-align: center;">Variable</th><th style="text-align: center;">Operating point value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V(1)-V(11)/V</td><td style="text-align: center;">12.22515</td></tr><tr class="even"><td style="text-align: center;">I(Q3[IB])/uA</td><td style="text-align: center;">2.07344</td></tr><tr class="odd"><td style="text-align: center;">I(Q3[IC])/uA</td><td style="text-align: center;">359.1267</td></tr><tr class="even"><td style="text-align: center;">I(Q3[IE])/uA</td><td style="text-align: center;">-361.20014</td></tr></tbody></table><p>即： <span class="math display">\[V_{be}=12.23\text{mV}\\I_b=2.07\mu\text{A}\\I_c=359 \mu\text{A}\\I_e=-361\mu\text{A}\]</span> 三极管工作在放大区。</p><h4 id="测量静态工作电流">测量静态工作电流</h4><p>测量电路及结果如图所示，电流表设置为直流模式：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607164553377.png" alt="image-20220607164553377" /><figcaption aria-hidden="true">image-20220607164553377</figcaption></figure><p>电流源提供的静态工作电流约<span class="math inline">\(722\mu\text{A}\)</span>.</p><h4 id="测量输入输出电阻">测量输入、输出电阻</h4><p>测量输入电阻，在输入部分测量电流和电压，相除即可得到输入电阻。</p><p>测量电路和结果如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165012310.png" alt="image-20220607165012310" /><figcaption aria-hidden="true">image-20220607165012310</figcaption></figure><p>有： <span class="math display">\[R_i=\frac VI=33750\Omega\]</span> 测量输出电阻，分别测量开关<span class="math inline">\(S_1\)</span>打开和闭合时的电压，通过公式计算输出电阻。</p><p>测量电路和结果如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165247200.png" alt="image-20220607165247200" /><figcaption aria-hidden="true">image-20220607165247200</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165316048.png" alt="image-20220607165316048" /><figcaption aria-hidden="true">image-20220607165316048</figcaption></figure><p>有： <span class="math display">\[R_o=\frac{V_2-V_1}{V_1}R_L=1059\Omega\]</span></p><h4 id="测量单端输出差模放大倍数">测量单端输出差模放大倍数</h4><p>在输出端、输入端接入电压表，测量并求比值。</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165450973.png" alt="image-20220607165450973" /> <span class="math display">\[A=\frac{V_o}{V_i}=5.94\]</span></p><h4 id="用仪表测量幅频相频曲线">用仪表测量幅频、相频曲线</h4><p>把波特测试仪连入电路并测量。</p><p>电路：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607165832111.png" alt="image-20220607165832111" /><figcaption aria-hidden="true">image-20220607165832111</figcaption></figure><p>结果：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607110325379.png" alt="image-20220607110325379" /><figcaption aria-hidden="true">image-20220607110325379</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607110341367.png" alt="image-20220607110341367" /><figcaption aria-hidden="true">image-20220607110341367</figcaption></figure><h4 id="用交流分析给出幅频相频曲线">用交流分析给出幅频、相频曲线</h4><p>在“仿真”中选择交流分析，选定合适的参数和输出量并进行仿真。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607110425299.png" alt="image-20220607110425299" /><figcaption aria-hidden="true">image-20220607110425299</figcaption></figure><h4 id="温度扫描">温度扫描</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607111351195.png" alt="image-20220607111351195" /><figcaption aria-hidden="true">image-20220607111351195</figcaption></figure><p>单管放大器电路以及温度扫描：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607111249985.png" alt="image-20220607111249985" /><figcaption aria-hidden="true">image-20220607111249985</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607111230796.png" alt="image-20220607111230796" /><figcaption aria-hidden="true">image-20220607111230796</figcaption></figure><p>由此可见，差放有抑制温漂的功能。</p><h4 id="最大不失真输出电压">最大不失真输出电压</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607172410632.png" alt="image-20220607172410632" /><figcaption aria-hidden="true">image-20220607172410632</figcaption></figure><p>最大不失真输出电压约为11.94V。</p><h3 id="有源负载差分放大电路">有源负载差分放大电路</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607172622665.png" alt="image-20220607172622665" /><figcaption aria-hidden="true">image-20220607172622665</figcaption></figure><p>有<span class="math inline">\(1k\Omega\)</span>负载时，放大倍数约为10.41。</p><p>这个电路的特点有：</p><ol type="1"><li>单端输出</li><li>共模抑制比无穷多</li><li>差模电压增益很大</li></ol><h2 id="cmos差分放大电路">CMOS差分放大电路</h2><h3 id="原始电路图">原始电路图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607192057086.png" alt="image-20220607192057086" /><figcaption aria-hidden="true">image-20220607192057086</figcaption></figure><p>在选取管子时，应该右键管子编辑模型，以将L、N的长度编辑到书上给定的长度。</p><h3 id="直流工作点分析-1">直流工作点分析</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607192231241.png" alt="image-20220607192231241" /><figcaption aria-hidden="true">image-20220607192231241</figcaption></figure><p>查询手册，得：<span class="math inline">\(V_{GS(th)}=1.6\text{V}\)</span> <span class="math display">\[V_{GS}=V_2-V_1=2.36&gt;V_{GS(th)}\\V_{DS}=V_4-V_1=3.65&gt;V_{GS}-V{GS(th)}\]</span> 因此，工作在恒流区。</p><h3 id="测量差模放大倍数">测量差模放大倍数</h3><p>在一端设置<span class="math inline">\(10\)</span>mV输入信号，并测定单端输出电压，电路图和结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607193641714.png" alt="image-20220607193641714" /><figcaption aria-hidden="true">image-20220607193641714</figcaption></figure><p>如图，有： <span class="math display">\[A_{vd1}=\frac{V_o}{V_i}=78\]</span> 用示波器测量波形如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607195027828.png" alt="image-20220607195027828" /><figcaption aria-hidden="true">image-20220607195027828</figcaption></figure><h3 id="测量共模放大倍数">测量共模放大倍数</h3><p>在两端端设置彼此相同的1V输入信号，并测定单端输出电压，电路图和结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607194543351.png" alt="image-20220607194543351" /><figcaption aria-hidden="true">image-20220607194543351</figcaption></figure><p>如图所示，两边放相同的信号源，测量共模放大倍数。有： <span class="math display">\[A_{vc1}=\frac{V_o}{V_i}=0.054\]</span> 用示波器测量波形：<img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220607194857656.png" alt="image-20220607194857656" /></p><h3 id="填写记录表格">填写记录表格</h3><p>共模抑制比计算公式为： <span class="math display">\[K_{CMR}=\frac{A_{vd1}}{A_{vc1}}\]</span></p><table><thead><tr class="header"><th>参数</th><th><span class="math inline">\(V_{i1}\)</span></th><th><span class="math inline">\(V_{o1}\)</span></th><th><span class="math inline">\(A_{vd1}\)</span></th><th><span class="math inline">\(V_{ic}\)</span></th><th><span class="math inline">\(V_{o1}\)</span></th><th><span class="math inline">\(A_{vc1}\)</span></th><th><span class="math inline">\(K_{CMR}\)</span></th></tr></thead><tbody><tr class="odd"><td>值</td><td>9.996mV</td><td>769.686mV</td><td>78</td><td>1V</td><td>54.45mV</td><td>0.054</td><td>1444.44</td></tr></tbody></table><h2 id="感想和体会">感想和体会</h2><p>这部分就自己写哈</p><hr /><p>本次实验各文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8.zip">差分放大器实验下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子电路实验报告1：共射放大器和射极跟随器</title>
    <link href="/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A1/"/>
    <url>/2022/06/07/%E6%A8%A1%E7%94%B5%E6%8A%A5%E5%91%8A1/</url>
    
    <content type="html"><![CDATA[<p>这是模电的实验报告，我模电的实验部分得了29分，满分30分，应该还算不低，于是把报告发出来，供大家参考。</p><p>这是第一个实验，共射放大器和射极跟随器。</p><span id="more"></span><h2 id="共射放大器的分析和设计">共射放大器的分析和设计</h2><h3 id="实验目的">实验目的</h3><ol type="1"><li><p>进一步了解 Multisim 的各项功能，熟练掌握其使用方法，为后续课程打好基础。</p></li><li><p>通过使用 Multisim 来仿真电路，测试如图 1 所示的单管共射放大电路的静态工作点、电压放大倍数、输入电阻和输出电阻，并观察静态工作点的变化对输出波形的影响。</p></li><li><p>加深对放大电路工作原理的理解和参数变化对输出波形的影响。</p></li><li><p>观察失真现象，了解其产生的原因。</p></li></ol><h3 id="实验原理图">实验原理图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530203406386.png" alt="image-20220530203406386" /><figcaption aria-hidden="true">image-20220530203406386</figcaption></figure><h3 id="实验内容及仿真数据">实验内容及仿真数据</h3><h4 id="进行直流工作点分析判断工作状态">进行直流工作点分析，判断工作状态</h4><p>用“分析”-“Analyses and simulation”工具中的“直流工作点”分析，得结果如下：</p><table><thead><tr class="header"><th style="text-align: center;">Variable</th><th style="text-align: center;">Operating point value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">V(4)-V(5)</td><td style="text-align: center;">6.76596</td></tr><tr class="even"><td style="text-align: center;">V(3)-V(5)</td><td style="text-align: center;">0.618865</td></tr><tr class="odd"><td style="text-align: center;">I(Q1[IB])</td><td style="text-align: center;">6.21E-06</td></tr><tr class="even"><td style="text-align: center;">I(Q1[IC])</td><td style="text-align: center;">0.000967</td></tr><tr class="odd"><td style="text-align: center;">I(Q1[IE])</td><td style="text-align: center;">-0.00097</td></tr></tbody></table><p>则有： <span class="math display">\[V_{be}=V(3)-V(5)=0.618865 \text{V}\\V_{ce}=V(4)-V(5)=6.76596\text{V}\\I_b=6.21\mu\text{A}\\I_c=967\mu\text{A}\\I_e=-970\mu\text{A}\]</span> 可知：管子工作在放大区。</p><h4 id="测量输入电阻">测量输入电阻</h4><p>使用万用表器件，测量电路以及测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530205610684.png" alt="image-20220530205610684" /><figcaption aria-hidden="true">image-20220530205610684</figcaption></figure><p>有结果：</p><table><thead><tr class="header"><th>项目</th><th>值</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(U_i\)</span></td><td>3.794mV</td></tr><tr class="even"><td><span class="math inline">\(I_i\)</span></td><td>1.209μA</td></tr></tbody></table><p>计算： <span class="math display">\[\begin{aligned}R_i&amp;=\frac{U_i}{I_i}\\&amp;=\frac{3.794\times10^{-3}}{1.209\times 10^{-6}}\\[1.5ex]&amp;=3138.13\ \Omega\end{aligned}\]</span> 故输入电阻为<span class="math inline">\(3138.13\Omega\)</span>，此时的频率为<span class="math inline">\(1\text{kHz}\)</span></p><h4 id="测量输出电阻">测量输出电阻</h4><p>为测量输出电阻，将信号源置<span class="math inline">\(0\)</span>，将负载电阻从电路中取出，换成信号源，用电流表测量输出支路电流。</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530212159779.png" alt="image-20220530212159779" /><figcaption aria-hidden="true">image-20220530212159779</figcaption></figure><p>则有： <span class="math display">\[\begin{aligned}R_o&amp;=\frac{U_o}{I_o}\\&amp;=\frac{10\times10^{-3}}{3.922\times10^{-6}}\\[1.5ex]&amp;=2549.71\Omega\end{aligned}\]</span> 所以输出电阻为<span class="math inline">\(2549.71\Omega\)</span></p><h4 id="用测量仪表测定幅频相频曲线">用测量仪表测定幅频、相频曲线</h4><p>如图所示，将波特分析仪连入电路：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530214705599.png" alt="image-20220530214705599" /><figcaption aria-hidden="true">image-20220530214705599</figcaption></figure><p>选择“幅值”模式，调整范围：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530214736718.png" alt="image-20220530214736718" /><figcaption aria-hidden="true">image-20220530214736718</figcaption></figure><p>选择“相位”模式：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530221124547.png" alt="image-20220530221124547" /><figcaption aria-hidden="true">image-20220530221124547</figcaption></figure><h4 id="用交流分析测幅频相频曲线">用交流分析测幅频、相频曲线</h4><p>用“分析”-“Analyses and simulation”工具中的“交流分析”，如图设置参数：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530221813255.png" alt="image-20220530221813255" /><figcaption aria-hidden="true">image-20220530221813255</figcaption></figure><p>将输出设置为<span class="math inline">\(V(6)\)</span>，开始分析：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530221847557.png" alt="image-20220530221847557" /><figcaption aria-hidden="true">image-20220530221847557</figcaption></figure><h4 id="分别在5-个频点利用示波器测出输入和输出的关系并仔细观察放大倍数和相位差">分别在5 个频点利用示波器测出输入和输出的关系，并仔细观察放大倍数和相位差</h4><p>电路连接方式如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530222634242.png" alt="image-20220530222634242" /><figcaption aria-hidden="true">image-20220530222634242</figcaption></figure><ol type="1"><li>30Hz</li></ol><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530231206151.png" alt="image-20220530231206151" /><figcaption aria-hidden="true">image-20220530231206151</figcaption></figure><p>图中<span class="math inline">\(T_1\)</span>，<span class="math inline">\(T_2\)</span>分别对应输入、输出通道的最大值。由<span class="math inline">\(\Delta \varphi=2\pi f(T_2-T_1)\)</span>可知： <span class="math display">\[   \max V_i=6.620\text{mV} \\   \max V_o=65.526\text{mV} \\   \Delta \varphi=51.132\degree   \]</span></p><ol start="2" type="1"><li><p>1kHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530232304194.png" alt="image-20220530232304194" /> <span class="math display">\[\max V_i=5.334\text{mV} \\\max V_o=238.006\text{mV} \\\Delta \varphi=168.75\degree\]</span></p></li><li><p>100kHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530232540514.png" alt="image-20220530232540514" /> <span class="math display">\[\max V_i=5.282\text{mV} \\\max V_o=236.081\text{mV} \\\Delta \varphi=181.548\degree\]</span></p></li><li><p>4MHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530233003943.png" alt="image-20220530233003943" /> <span class="math display">\[\max V_i=1.582\text{mV} \\\max V_o=73.091\text{mV} \\\Delta \varphi=180\degree\]</span></p></li><li><p>100MHz</p><p><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220530233500579.png" alt="image-20220530233500579" /> <span class="math display">\[\max V_i=193.301\mu\text{V} \\\max V_o=2.919\text{mV} \\\Delta \varphi=258.228\degree\]</span></p></li></ol><p>汇总，得：</p><table><thead><tr class="header"><th>f/Hz</th><th>max <span class="math inline">\(V_i\)</span>/mV</th><th>max<span class="math inline">\(V_o\)</span>/mV</th><th><span class="math inline">\(\Delta \varphi/\degree\)</span></th><th><span class="math inline">\(A\)</span></th></tr></thead><tbody><tr class="odd"><td>30</td><td>6.620</td><td>65.526</td><td>51.132</td><td>9.90</td></tr><tr class="even"><td>1k</td><td>5.334</td><td>238.006</td><td>168.75</td><td>44.62</td></tr><tr class="odd"><td>100k</td><td>5.282</td><td>236.081</td><td>181.548</td><td>44.70</td></tr><tr class="even"><td>4M</td><td>1.582</td><td>73.091</td><td>180</td><td>46.20</td></tr><tr class="odd"><td>100M</td><td>0.193</td><td>2.919</td><td>258.228</td><td>15.12</td></tr></tbody></table><h3 id="最大不失真输出电压的优化">最大不失真输出电压的优化</h3><h4 id="原电路最大不失真输出电压">原电路最大不失真输出电压</h4><p>原电路如图所示：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605152356360.png" alt="image-20220605152356360" /><figcaption aria-hidden="true">image-20220605152356360</figcaption></figure><p>设置信号源电压为变量<span class="math inline">\(v_i\)</span>，用参数扫描功能，从<span class="math inline">\(5\text{mV}\)</span>到<span class="math inline">\(15\text{mv}\)</span>扫描，用瞬态分析，分析时间设置为一个周期，即<span class="math inline">\(0.001\text{ms}\)</span>，得图形：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605152905709.png" alt="image-20220605152905709" /><figcaption aria-hidden="true">image-20220605152905709</figcaption></figure><p>可见在约<span class="math inline">\(10\text{mV}\)</span>时出现饱和失真。将信号源设置为<span class="math inline">\(10\text{mV}\)</span>，用示波器分析</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605153150707.png" alt="image-20220605153150707" /><figcaption aria-hidden="true">image-20220605153150707</figcaption></figure><p>可得最大不失真电压为<span class="math inline">\(4.5\text{mV}\)</span>左右。</p><h4 id="调整电阻后的最大不失真输出电压">调整电阻后的最大不失真输出电压</h4><p>调整<span class="math inline">\(R_1\)</span>,<span class="math inline">\(R_2\)</span>的比值，加入射级电阻，电路及参数扫描结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605151534469.png" alt="image-20220605151534469" /><figcaption aria-hidden="true">image-20220605151534469</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605151417177.png" alt="image-20220605151417177" /><figcaption aria-hidden="true">image-20220605151417177</figcaption></figure><p>将信号源设置为<span class="math inline">\(211\text{mV}\)</span>，用示波器分析：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220605153340470.png" alt="image-20220605153340470" /><figcaption aria-hidden="true">image-20220605153340470</figcaption></figure><p>此时输出电压约为<span class="math inline">\(2.2\text{V}\)</span>，比之前的电路提升了487.8倍。</p><h4 id="添加有源负载后的最大不失真电压">添加有源负载后的最大不失真电压</h4><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220702230017279.png" alt="image-20220702230017279" /><figcaption aria-hidden="true">image-20220702230017279</figcaption></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/image-20220702230157561.png" alt="image-20220702230157561" /><figcaption aria-hidden="true">image-20220702230157561</figcaption></figure><p>最大不失真输出电压进一步提高到了<span class="math inline">\(3.13V\)</span>左右。</p><h2 id="射极跟随器分析与设计">射极跟随器分析与设计</h2><h3 id="实验目的-1">实验目的</h3><ol type="1"><li>使用Multisim搭建仿真电路图，测定电路的静态工作点、电压放大倍数、输入电阻、输出电阻、观察静态工作点的变化对输入、输出特性的影响。</li><li>设计有源负载射随器</li><li>了解失真现象</li></ol><h3 id="原始电路图">原始电路图</h3><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606233327519.png" alt="image-20220606233327519" /><figcaption aria-hidden="true">image-20220606233327519</figcaption></figure><h3 id="射随器仿真实验">射随器仿真实验</h3><h4 id="进行直流工作点分析判断工作状态-1">进行直流工作点分析，判断工作状态</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606202123233.png" alt="image-20220606202123233" /><figcaption aria-hidden="true">image-20220606202123233</figcaption></figure><p>结果如下：</p><table><thead><tr class="header"><th>Variable</th><th>Operating point value</th></tr></thead><tbody><tr class="odd"><td>I(Q1[IC])</td><td>0.001601</td></tr><tr class="even"><td>V(3)-V(1)</td><td>0.63146175</td></tr><tr class="odd"><td>V(vcc)-V(1)</td><td>7.89915</td></tr></tbody></table><p>则有： <span class="math display">\[V_{be}=0.631\text{V}\\V_{ce}=7.899\text{V}\\I_c=1.6\text{mA}\]</span> 由此可见，管子工作在放大区。</p><h4 id="测量输入电阻-1">测量输入电阻</h4><p>电路及仿真结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606204235062.png" alt="image-20220606204235062" /><figcaption aria-hidden="true">image-20220606204235062</figcaption></figure><p>则有： <span class="math display">\[I_i=\frac{u_1}{R_4}=2.5\times10^{-8}\text{A}\\U_i=9.255\text{mV}\\R_i=356.44\text{k}\Omega\]</span></p><h4 id="测量输出电阻-1">测量输出电阻</h4><p>电路及相关测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606210346703.png" alt="image-20220606210346703" /><figcaption aria-hidden="true">image-20220606210346703</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606210415737.png" alt="image-20220606210415737" /><figcaption aria-hidden="true">image-20220606210415737</figcaption></figure><p>设开关闭合时电压为<span class="math inline">\(V_1\)</span>，开关打开时电压为<span class="math inline">\(V_2\)</span>，有： <span class="math display">\[R_0=\frac{V_2-V_1}{V_1}R_l=17.7\Omega\]</span></p><h4 id="用测量仪表测定幅频相频曲线-1">用测量仪表测定幅频、相频曲线</h4><p>电路图如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606213854747.png" alt="image-20220606213854747" /><figcaption aria-hidden="true">image-20220606213854747</figcaption></figure><p>测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606214506998.png" alt="image-20220606214506998" /><figcaption aria-hidden="true">image-20220606214506998</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606214610105.png" alt="image-20220606214610105" /><figcaption aria-hidden="true">image-20220606214610105</figcaption></figure><h4 id="用交流分析测幅频相频曲线-1">用交流分析测幅频、相频曲线</h4><p>结果如图：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606215412272.png" alt="image-20220606215412272" /><figcaption aria-hidden="true">image-20220606215412272</figcaption></figure><h4 id="最大不失真输出电压">最大不失真输出电压</h4><p>由参数扫描得，射随器最大不失真输出电压为<span class="math inline">\(7.158\text{V}\)</span></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606231952324.png" alt="image-20220606231952324" /><figcaption aria-hidden="true">image-20220606231952324</figcaption></figure><h3 id="有源负载射随器仿真实验">有源负载射随器仿真实验</h3><h4 id="直流工作点分析">直流工作点分析</h4><p>电路图和直流工作点分析结果如下，其中绿色部分为镜像电流源负载</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606221933500.png" alt="image-20220606221933500" /><figcaption aria-hidden="true">image-20220606221933500</figcaption></figure><table><thead><tr class="header"><th>Variable</th><th>Operating point value</th></tr></thead><tbody><tr class="odd"><td>I(Q1[IC])</td><td>0.00160115</td></tr><tr class="even"><td>V(3)-V(1)</td><td>0.63146373</td></tr><tr class="odd"><td>V(vcc)-V(1)</td><td>7.89959</td></tr></tbody></table><p>工作点和上个实验中射随器工作点基本一致。</p><h4 id="测量输入电阻-2">测量输入电阻</h4><p>电路图和相关测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230225977.png" alt="image-20220606230225977" /><figcaption aria-hidden="true">image-20220606230225977</figcaption></figure><p>有： <span class="math display">\[R_i=\frac{V_S}{V_i-V_s}R_6=429.42\text{kV}\]</span></p><h4 id="测量输出电阻-2">测量输出电阻</h4><p>电路图和相关测量结果如下：<img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606225533334.png" alt="image-20220606225533334" /></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606225549913.png" alt="image-20220606225549913" /><figcaption aria-hidden="true">image-20220606225549913</figcaption></figure><p>设开关闭合时电压为<span class="math inline">\(V_1\)</span>，开关打开时电压为<span class="math inline">\(V_2\)</span>，有： <span class="math display">\[R_0=\frac{V_2-V_1}{V_1}R_l=17.7\Omega\]</span></p><h4 id="用测量仪表测定幅频相频曲线-2">用测量仪表测定幅频、相频曲线</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230655603.png" alt="image-20220606230655603" /><figcaption aria-hidden="true">image-20220606230655603</figcaption></figure><p>测量结果如下：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230740927.png" alt="image-20220606230740927" /><figcaption aria-hidden="true">image-20220606230740927</figcaption></figure><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606230803991.png" alt="image-20220606230803991" /><figcaption aria-hidden="true">image-20220606230803991</figcaption></figure><h4 id="用交流分析测幅频相频曲线-2">用交流分析测幅频、相频曲线</h4><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606231140129.png" alt="image-20220606231140129" /><figcaption aria-hidden="true">image-20220606231140129</figcaption></figure><h4 id="最大不失真输出电压-1">最大不失真输出电压</h4><p>由参数扫描得，有源负载射随器最大不失真输出电压为<span class="math inline">\(7.920\text{V}\)</span></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606231847858.png" alt="image-20220606231847858" /><figcaption aria-hidden="true">image-20220606231847858</figcaption></figure><p>修改电路，再进行参数扫描</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606232942274.png" alt="image-20220606232942274" /><figcaption aria-hidden="true">image-20220606232942274</figcaption></figure><p>得最大不失真输出电压为<span class="math inline">\(9.621\text{V}\)</span>,比最初提升了<span class="math inline">\(34.41\%\)</span></p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220606232756093.png" alt="image-20220606232756093" /><figcaption aria-hidden="true">image-20220606232756093</figcaption></figure><h2 id="感想和体会">感想和体会</h2><p>这部分大家就自己写哈。</p><hr /><p>本次实验涉及到的各个文件的下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E5%85%B1%E5%B0%84%E6%94%BE%E5%A4%A7%E5%99%A8%E5%92%8C%E5%B0%84%E6%9E%81%E8%B7%9F%E9%9A%8F%E5%99%A8.zip">共射放大器和射极跟随器实验下载</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验报告</tag>
      
      <tag>电子电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理统计重点内容梳理</title>
    <link href="/2022/05/31/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2022/05/31/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E9%87%8D%E7%82%B9%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>周日就要考了，救命...... 另外，本文只是考试内容，有很多很好玩的内容，如方差分析，逐次回归，正交试验等没有涉及。</p><span id="more"></span><p>@[toc]</p><h2 id="估计">估计</h2><h3 id="umvue一致最小方差无偏估计">UMVUE一致最小方差无偏估计</h3><p><strong>定义（一致最小方差无偏估计）</strong> ：设<span class="math inline">\(U_q\)</span>表示参数<span class="math inline">\(q(\theta)\)</span>所有的方差有限的估计组成的集合，如果存在无偏估计<span class="math inline">\(T*(\mathbf{x})\)</span>，使得： <span class="math display">\[Var_\theta(T^*(x))\leq Var_\theta(T(x))\]</span> 对任何<span class="math inline">\(\theta\)</span>,任何<span class="math inline">\(T(x)\in U_q\)</span>成立，那么<span class="math inline">\(T^*(x)\)</span>就是一致最小方差无偏估计。</p><p>一般来说，我们可以用完全充分统计量的方法来寻找一致最小方差无偏估计。首先看几个概念：</p><p><strong>定义（统计量）</strong> :<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是来自总体<span class="math inline">\(X\)</span>的样本，那么仅和<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>有关的函数<span class="math inline">\(T(x_1,\cdots,x_n)\)</span>就是一个 <strong>统计量</strong></p><p><strong>定义（充分统计量）</strong> :设总体分布族为<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>,<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是来自总体<span class="math inline">\(X\)</span>的样本，<span class="math inline">\(T\)</span>是统计量。如果给定<span class="math inline">\(T=t\)</span>，样本的条件分布函数<span class="math inline">\(F_\theta(\{x\}|t)\)</span>和参数<span class="math inline">\(\theta\)</span>无关，那么称<span class="math inline">\(T\)</span>是充分统计量。</p><p><strong>定理（因子分解定理）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，统计量<span class="math inline">\(T\)</span>充分，等价于：存在一个定义在<span class="math inline">\(I\times\Theta\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="$I$是$T(x)$的值域，$\Theta$是$\theta$的值域">[2]</span></a></sup>上的实函数<span class="math inline">\(g(t,\theta)\)</span>，和定义在样本空间上的不依赖于参数<span class="math inline">\(\theta\)</span>的实函数<span class="math inline">\(h(x)\)</span>，使得对于样本的联合分布有： <span class="math display">\[p(x;\theta)=g(T(x),\theta)\cdot h(x)\]</span> 对样本空间上的每一个<span class="math inline">\(x\)</span>都成立。</p><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自泊松总体的<span class="math inline">\(n\)</span>个样本，求充分统计量。</p><p>【解】联合分布： <span class="math display">\[p(\{x\};\lambda)=\frac{e^{-n\lambda} } {x_1!x_2!\cdots x_n!}\lambda^{\sum_{i=1}^nx_i}\]</span> 取 <span class="math display">\[T=\sum x_i,g(T,\lambda)=e^{-n\lambda}\lambda^T,h(x)=\frac 1{x_1!x_2!\cdots x_n!}\]</span> 有 <span class="math display">\[p(\{x\};\lambda)=g(T,\lambda)h(x)\]</span> 则<span class="math inline">\(T=\sum x_i\)</span>是充分统计量。</p></blockquote><p><strong>定义*（完全统计量）</strong> ：对于总体<span class="math inline">\(X\)</span>的分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，<span class="math inline">\(g(X)\)</span>是随机变量，如果有：“对一切<span class="math inline">\(\theta\)</span>，<span class="math inline">\(E_\theta[g(x)]=0 \to P_\theta[g(x)=0]=1\)</span>”，则称这个分布族是完全分布族。如果统计量<span class="math inline">\(T\)</span>的分布族是完全的，那么<span class="math inline">\(T\)</span>就是完全统计量。</p><p><strong>定理（充分性定理）</strong> ：设<span class="math inline">\(\{x\}\)</span>是来自总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>的<span class="math inline">\(n\)</span>个简单样本，如果联合密度函数（联合分布列）可以分解为： <span class="math display">\[p(\{x\},\theta)=c(\theta)h(\{x\})\exp\left\{ \sum_{k=1}^mw_k(\theta)T_k(\{x\}) \right\}\]</span> 其中：</p><ul><li><span class="math inline">\(h(\{x\})\)</span>仅是<span class="math inline">\(x_1,\cdots,x_n\)</span>的函数</li><li><span class="math inline">\(w=[w_1(\theta),\cdots,w_k(\theta)]\)</span>是定义在<span class="math inline">\(\Theta^m\)</span>空间上的取值为<span class="math inline">\(A\subset{\mathbb R}^m\)</span>的向量函数</li><li><span class="math inline">\(c(\theta)\)</span>仅是<span class="math inline">\(\theta\)</span>的函数</li></ul><p>如果<span class="math inline">\(A\)</span>包含内点，那么<span class="math inline">\(T_1,\cdots,T_m\)</span>都是完全充分的。</p><blockquote><p>【例】设<span class="math inline">\(\{x\}\)</span>是来自二项分布<span class="math inline">\(B(1,\theta)\)</span><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="$B(n,p)$表示重复$n$次试验，每次试验成功的概率为$p$，成功的试验数目。这里实际上退化成了两点分布。">[3]</span></a></sup>总体的<span class="math inline">\(n\)</span>个简单样本，求<span class="math inline">\(\theta\)</span>的完全充分统计量。</p><p>【解】联合分布列： <span class="math display">\[\begin{aligned}p(\{x\};\theta)&amp;=\prod_{i=1}^n \theta^{x_i}(1-\theta)^{1-x_i}\\\\&amp;=(1-\theta)^n\exp\left\{ \ln\frac{\theta} {1-\theta}\sum_{i=1}^n x_i \right\}\end{aligned}\]</span> 取：</p><ul><li><span class="math inline">\(w=\ln\frac{\theta} {1-\theta}\)</span>，<span class="math inline">\(m=1\)</span></li><li><span class="math inline">\(c(\theta)=(1-\theta)^n\)</span></li><li><span class="math inline">\(h(\{x\})=1\)</span></li><li><span class="math inline">\(T=\sum x_i\)</span></li></ul><p>则<span class="math inline">\(T\)</span>是完全充分统计量。</p></blockquote><p><strong>定理（Lehmann-Scheffe定理）</strong>： 设<span class="math inline">\(S(x)\)</span>是完全充分统计量，<span class="math inline">\(\varphi(x)\)</span>是<span class="math inline">\(q(\theta)\)</span>的方差有限的无偏估计，则 <span class="math display">\[T(x)=E_\theta[\varphi(x)|S(x)]\]</span> 是<span class="math inline">\(q(\theta)\)</span>的一致最小方差无偏估计。</p><p>Lehmann-Scheffe定理实际上提供了两种根据完全充分统计量<span class="math inline">\(S(x)\)</span>寻求<span class="math inline">\(q(\theta)\)</span>的UMVUE的路径：</p><ol type="1"><li><p>如果能获得<span class="math inline">\(q(\theta)\)</span>的无偏估计<span class="math inline">\(\varphi(x)\)</span>，那么直接按照公式计算即可。</p><blockquote><p>【例】设<span class="math inline">\(\{x\}\)</span>是来自泊松总体的<span class="math inline">\(n\)</span>个简单样本，求<span class="math inline">\(q(\lambda)=e^{-\lambda}\)</span>的UMVUE。</p><p>【解】泊松分布列为： <span class="math display">\[p(x;\lambda)=\frac{\lambda^x} {x!}e^{-\lambda}=e^{-\lambda}\frac 1{x!}\exp(\ln (\lambda) x)\ \ x=0,1,2,\cdots\]</span> 则联合分布列的分解： <span class="math display">\[p(\{x\};\theta)=e^{-n\lambda}\prod_{i=1}^n\frac{1} {x_i!}\exp(\ln \lambda \sum_{i=1}^n x_i)\]</span> 取：</p><ul><li><span class="math inline">\(S(x)=\sum x_i\)</span></li><li><span class="math inline">\(w(\lambda)=\ln \lambda\)</span>,<span class="math inline">\(m=1\)</span></li><li><span class="math inline">\(c(\lambda)=e^{-n\lambda}\)</span></li><li><span class="math inline">\(h=\prod \frac{1} {x_i!}\)</span></li></ul><p>则<span class="math inline">\(S\)</span>是完全充分统计量。</p><p>接下来寻找<span class="math inline">\(q(\lambda)\)</span>的无偏估计。取 <span class="math display">\[\varphi(x)=I_{x_1=0}(x_1,\cdots,x_n)\]</span> 其中<span class="math inline">\(I\)</span>是指示函数<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="指示函数$I_a()$：当条件$a$为真时为$1$，反之为$0$.">[4]</span></a></sup>.</p><p>则： <span class="math display">\[E_\lambda[\varphi(x)]=P[x_1=0]=e^{-n\lambda}\]</span> 故<span class="math inline">\(\varphi\)</span>是<span class="math inline">\(q(\lambda)\)</span>的无偏估计。则有： <span class="math display">\[T=E[\varphi|S(x)=s]\]</span> 则有： <span class="math display">\[T=\frac{P[x_1=0]P[\sum_{k=2}^nx_k=s]} {P[\sum_{k=1}^nx_k=s]}\]</span> 由于泊松分布的和是泊松分布，<span class="math inline">\(\lambda\)</span>参数求和，则： <span class="math display">\[T=\left(\frac{n-1} {n}\right)^{\sum x_i}\]</span></p></blockquote></li><li><p>由于<span class="math inline">\(T(x)\)</span>一定是<span class="math inline">\(S(x)\)</span>的函数，因此如果能获取<span class="math inline">\(S(x)\)</span>的函数<span class="math inline">\(h(S(x))\)</span>，并将其无偏化，则可以获得UMVUE。</p><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>个简单样本，其中<span class="math inline">\(\mu\)</span>是已知量，求<span class="math inline">\(\sigma^2\)</span>的UMVUE。</p><p>【解】样本的联合密度函数为： <span class="math display">\[p(\{x\};\sigma^2)=(2\pi\sigma^2)^{-\frac{n} {2} }\exp\left\{-\frac{1} {2\sigma^2}\sum_{i=1}^{n}(x_i-\mu)^2 \right\}\]</span> 取：</p><ul><li><span class="math inline">\(c(\sigma^2)=(2\pi\sigma^2)^{-\frac n2}\)</span></li><li><span class="math inline">\(h(\{x\})=1\)</span></li><li><span class="math inline">\(w(\sigma^2)=-\frac{1} {2\sigma^2},m=1\)</span></li><li><span class="math inline">\(S(x)=\sum(x_i-\mu)^2\)</span></li></ul><p>则<span class="math inline">\(S(x)\)</span>是完全充分统计量。由于 <span class="math display">\[E[S(x)]=E\left[\sum(x_i-\mu)^2\right]=n\sigma^2\]</span> 则： <span class="math display">\[E\left[\frac{1} {n}S(x)\right]=\sigma^2\]</span> 于是<span class="math inline">\(S/n\)</span>既是待估计量的无偏估计，也是完全充分统计量<span class="math inline">\(S\)</span>的函数，因此 <span class="math display">\[\frac Sn=\frac 1n \sum_{i=1}^n(x_i-\mu)^2\]</span> 是待估计量的UMVUE。</p></blockquote></li></ol><h3 id="有效估计">有效估计</h3><h3 id="矩估计">矩估计</h3><p>矩估计法的思想是基于替换原理，用样本矩替换相应的总体矩，进而求出某些待估计参数的过程。</p><p>其中的样本矩的意思是根据<span class="math inline">\(n\)</span>次抽样算出来的矩，比如说抽样<span class="math inline">\(n\)</span>次的样本是<span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span>，那么<span class="math inline">\(k\)</span>阶样本原点矩就是 <span class="math display">\[A_k=\frac 1n\sum_{i=1}^n x_i^k\]</span> 而总体矩的意思是将待估计参数代入分布的理论形式中，通过理论分析计算期望而得出的矩。假如待估计参数是<span class="math inline">\(\theta\)</span>,那么<span class="math inline">\(k\)</span>阶总体原点矩是 <span class="math display">\[\mu_k=E_\theta[X^k]\]</span> 求矩估计的一般步骤是：将待估计的参数<span class="math inline">\(q(\theta)\)</span>表示成各阶总体矩<span class="math inline">\(\mu_k\)</span>的函数,然后用样本矩替换总体矩，就可以获得矩估计。</p><blockquote><p>【例】总体<span class="math inline">\(X\)</span>服从<span class="math inline">\([a,b]\)</span>上的均匀分布，也就是说，其概率密度函数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="$p(x;a,b)$的含义是：该函数以$x$为自变量，有两个参数$a$和$b$">[1]</span></a></sup>为： <span class="math display">\[p(x;a,b)=\begin{cases}\frac{1} {b-a} &amp;x\in[a,b]\\\\0 &amp;\text{others}\end{cases}\]</span> <span class="math inline">\(\{x_1,x_2,\cdots,x_n\}\)</span>是总体<span class="math inline">\(X\)</span>的简单抽样样本。求<span class="math inline">\(a,b\)</span>的矩估计。</p><p>【解】设<span class="math inline">\(\mu_1=E[x],v_2=D[x]\)</span>,有： <span class="math display">\[\begin{cases}\mu_1=\frac{1} {2}(a+b)\\\\[2ex]v_2=\frac{1} {12}(b-a)^2\\\\[2ex]\end{cases}\]</span> 解方程，可得： <span class="math display">\[a=\mu_1-\sqrt{3v_2}\\\\b=\mu_1+\sqrt{3v_2}\]</span> 用样本均值替换总体均值，用样本方差替换二阶中心矩，有： <span class="math display">\[\mu_1 \to \bar{x}\\\\v_2 \to \frac{1} {n}\sum_{i=1}^n(x_i-\bar{x})^2\]</span> 则可得<span class="math inline">\(a,b\)</span>的矩估计： <span class="math display">\[a=\bar{x}-\sqrt{\frac 3n\sum_{i=1}^n(x_i-\bar{x})^2}\\\\b=\bar{x}+\sqrt{\frac 3n\sum_{i=1}^n(x_i-\bar{x})^2}\]</span></p></blockquote><h3 id="极大似然估计">极大似然估计</h3><p>极大似然估计的思想是：如果在一次试验中产生了一个结果，那么一般认为试验条件对这个结果的发生有利，也就是这个结果发生的概率最大。</p><p>一般步骤是：先求出一个似然函数<span class="math inline">\(L(\theta;x_1,x_2,\cdots,x_n)\)</span>，它以待估计量<span class="math inline">\(\theta\)</span>为自变量，以试验结果为参数，它的含义是当前试验结果出现的概率。然后通过将<span class="math inline">\(L\)</span>(因为概率往往是乘积形式，有时我们也用<span class="math inline">\(\ln L\)</span>)对<span class="math inline">\(\theta\)</span>求偏导的方法，得出<span class="math inline">\(L\)</span>取得上界时<span class="math inline">\(\theta\)</span>的值，并将其作为估计结果。</p><blockquote><p>【例】总体<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.其中<span class="math inline">\(\mu,\sigma^2\)</span>的参数空间为<span class="math inline">\(\mu\in{\mathbb R},\sigma^2&gt;0\)</span>，<span class="math inline">\(\{x_1,\cdots,x_n\}\)</span>是简单样本，求<span class="math inline">\(\mu,\sigma^2\)</span>的极大似然估计。</p><p>【解】总体的密度函数为： <span class="math display">\[p(x;\mu,\sigma^2)=\frac{1} {\sqrt{2\pi\sigma^2} }\exp(\frac{-(x-\mu)^2} {2\sigma^2})\]</span> 则有“似然函数”： <span class="math display">\[\begin{aligned}L(\mu,\sigma^2;x_1,\cdots,x_n)=\prod_{i=1}^np(x_1;\mu,\sigma^2)\end{aligned}\]</span> 则 <span class="math display">\[\ln L=-\frac n2\ln(2\pi)-\frac n2 \ln(\sigma^2)-\frac 1{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\]</span> 分别对<span class="math inline">\(\mu,\sigma^2\)</span>求导，得： <span class="math display">\[\begin{cases}\frac{\partial \ln L} {\partial \mu}=\frac{1} {\sigma^2}\sum_{i=1}^n(x_i-\mu)=0\\\\\frac{\partial \ln L} {\partial \sigma^2}=-\frac n{2\sigma^2}+\frac 1{2(\sigma^2)^2}\sum_{i=1}^n(x_i-\mu)=0\end{cases}\]</span> 解得： <span class="math display">\[\mu=\bar{x}\\\\\sigma^2=\frac 1n \sum(x_i-\bar{x})^2\]</span></p></blockquote><h3 id="区间估计定义">区间估计（定义）</h3><p><strong>定义（区间估计）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，如果存在两个统计量<span class="math inline">\(T_1(x),T_2(x)\)</span>，对于给定的<span class="math inline">\(\alpha\)</span>，有： <span class="math display">\[P\left\{\theta\in [T_1(x),T_2(x)]\right\}\geq 1-\alpha\]</span> 对任意<span class="math inline">\(\theta\)</span>都成立，称<span class="math inline">\([T_1,T_2]\)</span>是参数<span class="math inline">\(\theta\)</span>置信度为<span class="math inline">\(1-\alpha\)</span>的区间估计。</p><p>区间估计的含义是，假设做<span class="math inline">\(m\)</span>组重复试验，每组抽取<span class="math inline">\(n\)</span>个样本，这样就可以得到<span class="math inline">\(m\)</span>个区间<span class="math inline">\([T_1,T_2]\)</span>。在这<span class="math inline">\(m\)</span>个区间中，大约有<span class="math inline">\(100(1-\alpha)\%\)</span>包含<span class="math inline">\(\theta\)</span>的真值。我们不能说<span class="math inline">\(\theta\)</span>落入区间<span class="math inline">\([T_1,T_2]\)</span>的概率是<span class="math inline">\(1-\alpha\)</span>，这是因为<span class="math inline">\(\theta\)</span>的真值是一个客观存在的不变量。</p><h3 id="minimax估计">Minimax估计</h3><p><strong>定义（Minimax估计）</strong> ：对于总体分布族<span class="math inline">\(\{p_\theta:\theta\in\Theta\}\)</span>，<span class="math inline">\(G_q\)</span>是由待估参数<span class="math inline">\(q(\theta)\)</span>的估计量（决策函数）<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="决策函数的自变量是样本$\{x\}$，因变量是对待估计量的估计">[5]</span></a></sup>组成的集合，如果存在<span class="math inline">\(T^*\in G_q\)</span>，有： <span class="math display">\[\sup_{\theta\in\Theta}R(\theta,T^*)\leq\sup_{\theta\in\Theta}R(\theta,T)\]</span> 对任意<span class="math inline">\(T\in G_q\)</span>成立，则称<span class="math inline">\(T^*\)</span>是Minimax估计。其中<span class="math inline">\(R(\theta,T)\)</span>是风险函数，定义如下： <span class="math display">\[R(\theta,T)=E_\theta[L(\theta,T(x))]\]</span> 其中<span class="math inline">\(L(\theta,T)\)</span>是损失函数，意思是当待估计量是<span class="math inline">\(\theta\)</span>，然后你估计它为<span class="math inline">\(T(x)\)</span>时产生的损失。</p><blockquote><p>【例】总体服从两点分布<span class="math inline">\(B(1,p)\)</span>，<span class="math inline">\(p \in \{\frac 14,\frac12\}\)</span>，损失函数如下表所示，求<span class="math inline">\(p\)</span>的Minimax估计。</p><table><thead><tr class="header"><th><span class="math inline">\(p\)</span></th><th><span class="math inline">\(a_1=1/4\)</span></th><th><span class="math inline">\(a_2=1/2\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(p_1=1/4\)</span></td><td>1</td><td>4</td></tr><tr class="even"><td><span class="math inline">\(p_2=1/2\)</span></td><td>3</td><td>2</td></tr></tbody></table><p>【解】仅仅取1个观察值，那么总共有4种决策函数：</p><ol type="1"><li><p><code>T1=1/4</code></p></li><li><p><code>T2=(x==0)?1/4:1/2</code></p></li><li><p><code>T3=(x==0)?1/2:1/4</code></p></li><li><p><code>T4=1/2</code></p><p>响应的风险表如下：</p><table><thead><tr class="header"><th><span class="math inline">\(T_i\)</span></th><th><span class="math inline">\(R(p_1,T_i)\)</span></th><th><span class="math inline">\(R(p_2,T_i)\)</span></th><th><span class="math inline">\(\max R\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>3</td><td>3</td></tr><tr class="even"><td>2</td><td>7/4</td><td>5/2</td><td>5/2</td></tr><tr class="odd"><td>3</td><td>13/4</td><td>5/2</td><td>13/4</td></tr><tr class="even"><td>4</td><td>4</td><td>2</td><td>4</td></tr></tbody></table><p>例如，我们求<span class="math inline">\(R(p_2,T_2)\)</span>: <span class="math display">\[\begin{aligned}R(p_2,T_2)&amp;=E_{p_2}[L(p_2,T_2)]\\\\&amp;=P_{p_2}\{x=0\}L(p_2,1/4)+P_{p_2}\{x=1\}L(p_2,1/2)\\\\&amp;=\frac 12\times 3+\frac 12 \times 2\\\\&amp;=\frac 52\end{aligned}\]</span> 在第四列中选取最小的，所以应该选<span class="math inline">\(T_2\)</span>。</p></li></ol></blockquote><h2 id="假设检验">假设检验</h2><h3 id="结合实际问题的假设检验">结合实际问题的假设检验</h3><p>对于正态总体而言，有：</p><ol type="1"><li><p>单个方差已知时总体均值的检验 <span class="math display">\[H_0:\mu=\mu_0\ \ H_1:\mu\neq\mu_0\]</span> 检验统计量为： <span class="math display">\[z=\frac{\bar{x}-\mu_0} {\sigma/\sqrt{n} }\sim N(0,1)\]</span> 这种检验方法叫做“<span class="math inline">\(z\)</span>检验”</p><p>拒绝域为： <span class="math display">\[W=\{|z|\geq z_{1-\frac\alpha 2}\}\]</span></p></li><li><p>单个方差未知时总体均值的检验 <span class="math display">\[H_0:\mu=\mu_0\ \ H_1:\mu\neq\mu_0\]</span> 检验统计量： <span class="math display">\[t=\frac{\bar{x}-\mu_0} {S/\sqrt{n} }\sim t(n-1)\]</span> 这种检验方式叫做<span class="math inline">\(t\)</span>检验。</p><p>拒绝域： <span class="math display">\[W=\left\{\frac{\bar{x}-\mu_0} {S/\sqrt{n} }\geq t_{1-\frac \alpha2}(n-1)\right\}\]</span></p></li><li><p>单个均值未知时方差的检验 <span class="math display">\[H_0:\sigma^2=\sigma_0^2\]</span> 检验统计量： <span class="math display">\[\chi^2=\frac{(n-1)S^2} {\sigma_0^2} \sim \chi^2(n-1)\]</span> 拒绝域： <span class="math display">\[W=\{\chi^2\leq\chi^2_{\frac \alpha2}(n-1)\}\cup \{\chi^2\geq\chi_{1-\frac \alpha2}^2(n-1)\}\]</span></p></li><li><p>单个均值已知时方差的检验 <span class="math display">\[H_0:\sigma^2=\sigma_0^2\]</span> 检验统计量： <span class="math display">\[\chi^2=\frac 1{\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\sim\chi^2(n)\]</span> 拒绝域: <span class="math display">\[W=\{\chi^2\leq\chi^2_{\frac \alpha2}(n)\}\cup \{\chi^2\geq\chi_{1-\frac \alpha2}^2(n)\}\]</span></p></li><li><p>两个总体均值相等的检验</p><ol type="1"><li><p>两个方差<span class="math inline">\(\sigma_1,\sigma_2\)</span>已知</p><p>检验统计量： <span class="math display">\[z=\frac{\bar{x}-\bar{y} } {\sqrt{\frac{\sigma_1^2} {n_1}+\frac{\sigma^2_2} {n_2} }}\]</span></p><p>拒绝域： <span class="math display">\[W=\{|z|\geq z_{1-\frac\alpha 2}\}\]</span></p></li><li><p>两个方差未知但相等</p><p>检验统计量： <span class="math display">\[S^2_w=\frac{(n_1-1)S^2_1+(n_2-1)S_2^2} {n_1+n_2-2}\\\\t=\frac{\bar{x}-\bar{y} } {S_w\sqrt{\frac 1{n_1}+\frac1{n_2} }}\sim t(n_1+n_2-2)\]</span> 拒绝域 <span class="math display">\[W=\{|t|\geq t_{1-\frac \alpha2}(n_1+n_2-2)\}\]</span></p></li><li><p>方差情况未知但样本数相等</p><p>检验统计量 <span class="math display">\[z_i=x_i-y_i\\\\t=\frac{\bar{z} } {S_z/\sqrt{n} }\sim t(n-1)\]</span> 拒绝域 <span class="math display">\[W=\{|t|\geq t_{1-\frac \alpha2}(n-1)\}\]</span></p></li></ol></li></ol><h3 id="umpt一致最优势检验">UMPT一致最优势检验</h3><p>首先我们明确几个概念</p><p><strong>定义（检验函数）</strong> 检验函数<span class="math inline">\(\varphi(x)\)</span>一般定义如下： <span class="math display">\[\varphi(x)=I_{x\in W}(x)\]</span> 也就是拒绝域上的示性函数，即： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;x\in W\\\\0, &amp;\text{others}\end{cases}\]</span> 当检验函数为1时，选择拒绝<span class="math inline">\(H_0\)</span>。这样的检验函数叫非随机化检验函数。如果得到样本<span class="math inline">\(x\)</span>后，以概率<span class="math inline">\(\varphi(x)\)</span>，这就是随机化检验函数。</p><p><strong>定义（检验的势函数）</strong> 样本观测值落入拒绝域的概率称为势函数<span class="math inline">\(g(\theta)\)</span>.</p><p><strong>定义（检验的水平）</strong> 对于给定的<span class="math inline">\(\alpha\in[0,1]\)</span>,如果检验<span class="math inline">\(\varphi(x)\)</span>对所有<span class="math inline">\(\theta\in\Theta_0\)</span>满足<span class="math inline">\(E_{\theta}[\varphi(x)]\leq\alpha\)</span>，称<span class="math inline">\(\varphi(x)\)</span>的水平是<span class="math inline">\(\alpha\)</span></p><p>一个自然的比较检验的优劣的方式是：在相同的检验水平<span class="math inline">\(\alpha\)</span>下，如果 <span class="math display">\[E_{\theta_1}[\varphi_1(x)]\geq E_{\theta_1}[\varphi_2(x)]\]</span> 那么就说<span class="math inline">\(\varphi_1\)</span>比较好。</p><p><strong>定理（N-P引理）</strong> 对于假设检验问题： <span class="math display">\[H_0:\theta= \theta_0\ \ \ H_1:\theta=\theta_1\]</span> 以及给定检验水平<span class="math inline">\(\alpha\)</span>,有：</p><ol type="1"><li><p>存在非负常数<span class="math inline">\(k\)</span>，检验 <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;L(x)\geq k\\\\1, &amp;L(x)&lt; k\\\\\end{cases}\]</span> 满足 <span class="math display">\[E_{\theta_0}[\varphi(x)]=\alpha\]</span> 而且检验函数<span class="math inline">\(\varphi(x)\)</span>是水平为<span class="math inline">\(\alpha\)</span>的最优势检验。其中<span class="math inline">\(L(x)\)</span>是似然比统计量： <span class="math display">\[L(x)=\frac{p(x;\theta_1)} {p(x;\theta_0)}\]</span></p></li><li><p>如果检验函数<span class="math inline">\(\varphi(x)\)</span>是水平为<span class="math inline">\(\alpha\)</span>的最优势检验，那么一定存在非负常数<span class="math inline">\(k\)</span>，使得<span class="math inline">\(\varphi(x)\)</span>满足（1）的第一个式子，如果有<span class="math inline">\(E_{\theta_1}[\varphi(x)]\leq 1\)</span>，那么第二个式子也满足。</p></li></ol><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自正态总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>维简单随机样本，<span class="math inline">\(\mu\geq 0,\sigma\)</span>已知。对于假设： <span class="math display">\[H_0:\mu=0\ \ H_1:\mu=\mu_1&gt;0\]</span> 求水平为<span class="math inline">\(\alpha\)</span>的最优势检验。</p><p>【解】检验函数具有如下形式： <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;L(x)\geq k\\\\1, &amp;L(x)&lt; k\\\\\end{cases}\]</span> 其中<span class="math inline">\(L(x)\)</span>满足： <span class="math display">\[\begin{aligned}L(x)&amp;=\frac{p(x;\mu_1)} {p(x;0)}\\\\&amp;=\exp\left\{\frac{n\mu_1\bar{x} } {\sigma^2}-\frac{n\mu_1^2} {2\sigma^2}\right\}\end{aligned}\]</span> <span class="math inline">\(k\)</span>由 <span class="math display">\[E_{\mu=0}[\varphi(x)]=P_{\mu=0}\{L(x)\geq k\}=\alpha\]</span> 确定。</p><p>由于<span class="math inline">\(L(x)\)</span>随<span class="math inline">\(\bar{x}\)</span>单增，因此 <span class="math display">\[\{x|L(x)\geq k\}=\{x|\bar{x}\geq c\}\]</span> 对于给定的<span class="math inline">\(\alpha\)</span>，有： <span class="math display">\[P_{\mu=0}\{L(x)\geq k\}=P_{\mu=0}\{\bar{x}\geq c\}=1-\Phi\left(\frac{c} {\sigma/\sqrt{n} }\right)=\alpha\]</span> 得<span class="math inline">\(c=\sigma z_{1-\alpha}/\sqrt{n}\)</span></p><p>则检验函数： <span class="math display">\[\varphi(x)=\begin{cases}0, &amp;\bar(x)\geq c\\\\1, &amp;\bar(x)&lt; c\\\\\end{cases}\]</span></p></blockquote><p><strong>定义（一致最优势检验）</strong> 如果检验问题是： <span class="math display">\[H_0:\theta\in \Theta_0\ \ \ H_1:\theta\in\Theta_1\]</span> 对于<span class="math inline">\(\Theta_0\)</span>中的每个<span class="math inline">\(\theta\)</span>，<span class="math inline">\(\varphi\)</span>都是最优势检验，那么<span class="math inline">\(\varphi\)</span>称为一致最优势检验。</p><p><strong>定理（UMPT的确定） </strong> 对于单参数的密度函数（分布列）<span class="math inline">\(p(x;\theta)\)</span>，如果可以表示为： <span class="math display">\[p(x;\theta)=d(\theta)h(x)\exp\{c(\theta)T(x)\}\]</span> 其中<span class="math inline">\(c(\theta)\)</span>严格单增，那么对于检验问题： <span class="math display">\[H_0:\theta\leq \theta_0\ \ H_1:\theta&gt;\theta_0\]</span></p><ol type="1"><li><p>水平为<span class="math inline">\(\alpha\)</span>的UMPT存在，为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;T(x)&gt; c\\\\r, &amp;T(x)=c\\\\0, &amp;T(x)&lt; c\\\\\end{cases}\]</span> 常数<span class="math inline">\(c,r\)</span>由<span class="math inline">\(E_{\theta_0}[\varphi(x)]=\alpha\)</span>确定。</p></li><li><p>势函数<span class="math inline">\(g(\theta)=E_{\theta}[\varphi(x)]\)</span>单增。</p></li></ol><p>注解：</p><ol type="1"><li><p>如果<span class="math inline">\(c(\theta)\)</span>单减，结论仍然成立，只需将检验函数中的不等号调换。</p></li><li><p>对于检验问题： <span class="math display">\[H_0:\theta=\theta_0\ \ H_1:\theta&gt;\theta_0\]</span> 结论完全照原样成立。</p></li><li><p>对于检验问题 <span class="math display">\[H_0:\theta\geq \theta_0\ \ H_1:\theta&lt;\theta_0\]</span> 只需取<span class="math inline">\(\theta&#39;=-\theta\)</span>即可。</p></li></ol><blockquote><p>【例】<span class="math inline">\(\{x\}\)</span>是来自正态总体<span class="math inline">\(N(\mu,\sigma^2)\)</span>的<span class="math inline">\(n\)</span>维简单随机样本，<span class="math inline">\(\mu\)</span>已知，<span class="math inline">\(\sigma^2\)</span>未知，求检验： <span class="math display">\[H_0:\sigma^2\leq \sigma_0^2\ \ H_1:\sigma^2&gt;\sigma_0^2\]</span> 的UMPT。</p><p>【解】对于联合密度函数，有： <span class="math display">\[p(x;\theta)=\left(\frac{1} {\sqrt{2\pi\sigma^2} }\right)^n\exp\left\{-\frac{1} {2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\right\}\]</span> 其中：</p><ol type="1"><li><span class="math inline">\(d(\sigma^2)=\left(\frac{1} {\sqrt{2\pi\sigma^2} }\right)^n\)</span></li><li><span class="math inline">\(h(x)=1\)</span></li><li><span class="math inline">\(c(\sigma^2)=-\frac{1} {2\sigma^2}\)</span></li><li><span class="math inline">\(T(x)=\sum_{i=1}^n(x_i-\mu)^2\)</span></li></ol><p>则UMPT存在，为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;T(x)\geq c\\\\0, &amp;T(x)&lt; c\\\\\end{cases}\]</span> 由 <span class="math display">\[E_{\sigma^2}[\varphi(x)]=P_{\sigma_0^2}\left\{\frac{1} {\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\geq\frac{c} {\sigma_0^2} \right\}=\alpha\]</span> 其中 <span class="math display">\[\frac{1} {\sigma_0^2}\sum_{i=1}^n(x_i-\mu)^2\sim \chi^2(n)\]</span> 故 <span class="math display">\[c=\sigma_0^2\chi^2_{1-\alpha}(n)\]</span> 综上所述，UMPT为： <span class="math display">\[\varphi(x)=\begin{cases}1, &amp;\sum_{i=1}^n(x_i-\mu)^2\geq \sigma_0^2\chi^2_{1-\alpha}(n)\\\\0, &amp;\sum_{i=1}^n(x_i-\mu)^2&lt; \sigma_0^2\chi^2_{1-\alpha}(n)\\\\\end{cases}\]</span></p></blockquote><h2 id="分布">分布</h2><p>由正态分布导出的三大分布：</p><h3 id="chi2分布"><span class="math inline">\(\chi^2\)</span>分布</h3><p>设<span class="math inline">\(X_1\cdots X_n\)</span>是服从<span class="math inline">\(N(0,1)\)</span>的随机变量，而且互相独立，则 <span class="math display">\[\sum_{i=1}^nX_i^2 \sim \chi^2(n)\]</span> 叫做：服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(\chi^2\)</span>分布。</p><h3 id="t分布"><span class="math inline">\(t\)</span>分布</h3><p>设<span class="math inline">\(X\sim N(0,1),Y\sim\chi^2(n)\)</span>，而且相互独立，则 <span class="math display">\[\frac{X} {\sqrt{Y/n} }\sim t(n)\]</span> 叫做：服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(t\)</span>分布，也叫学生分布。</p><h3 id="f分布"><span class="math inline">\(F\)</span>分布</h3><p>设<span class="math inline">\(X\sim \chi^2(n_1),Y\sim\chi^2(n_2)\)</span>，而且相互独立，则 <span class="math display">\[\frac{X/n_1} {Y/n_2}\sim F(n_1,n_2)\]</span></p><h3 id="分位数">分位数</h3><p>对于随机变量<span class="math inline">\(X\)</span>的分布函数<span class="math inline">\(F(x)\)</span>，给定实数<span class="math inline">\(p\in[0,1]\)</span>，若： <span class="math display">\[p\{X\leq x_p\}=F(x_p)=p\]</span> 称<span class="math inline">\(x_p\)</span>是此概率分布的<span class="math inline">\(p\)</span>分位数。</p><h2 id="线性回归">线性回归</h2><p>证明：<span class="math inline">\(e=Y-\hat{Y}\)</span>和<span class="math inline">\(\hat{\beta}=(X&#39;X)^{-1}X&#39;Y\)</span>不相关。</p><p>证明：<span class="math inline">\(e=[I_n-X(X&#39;X)^{-1}X&#39;]Y\)</span></p><p>由 <span class="math display">\[Cov(Ax,By)=ACov(x,y)B&#39;\]</span> 得： <span class="math display">\[\begin{aligned}Cov(e,\hat{\beta})&amp;=Cov([I_n-X(X&#39;X)^{-1}X&#39;]Y,(X&#39;X)^{-1}X&#39;Y)\\\\&amp;=[I_n-X(X&#39;X)^{-1}X&#39;]D[Y][(X&#39;X)^{-1}X&#39;]&#39;\\\\&amp;=\sigma^2[I_n-X(X&#39;X)^{-1}X&#39;][(X&#39;X)^{-1}X&#39;]&#39;\\\\&amp;=\sigma^2[(X&#39;X)^{-1}X]-[X(X&#39;X)^{-1}(X&#39;(X&#39;X)^{-1}X)]\\\\&amp;=\sigma^2[(X&#39;X)^{-1}X-X(X&#39;X)^{-1}]\\\\&amp;=0\end{aligned}\]</span></p><h2 id="主成分分析">主成分分析</h2><p>设总体<span class="math inline">\(\boldsymbol{x}=(x_1,x_2,\cdots,x_p)&#39;\)</span>是<span class="math inline">\(p\)</span>元总体，<span class="math inline">\(E[\boldsymbol{x}]=\boldsymbol{\mu},Var(\boldsymbol{x})=\boldsymbol{\Sigma}=(\sigma_{ij})\)</span>。我们的目标是把这<span class="math inline">\(p\)</span>个指标综合成少数几个指标，也就是所谓的主成分。要求这几个指标能尽量多地反应原来<span class="math inline">\(p\)</span>个指标所提供的信息，而且彼此不相关。</p><p>首先考虑把这<span class="math inline">\(p\)</span>个指标全综合到一个数值<span class="math inline">\(y_1\)</span>里，有： <span class="math display">\[y_1=u_1x_1+\cdots+u_px_p=\boldsymbol{u&#39;x}\]</span> 因为方差越大，信息量越大，所以我们的目的是：在<span class="math inline">\(\boldsymbol{u&#39;u}=1\)</span>的条件下，让<span class="math inline">\(Var(y)=\boldsymbol{u&#39;\Sigma u}\)</span>最大。</p><p>有如下定理：</p><p><strong>定理</strong> ：设<span class="math inline">\(\boldsymbol{\Sigma}\)</span>的特征值从大到小依次是<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_p\geq0\)</span>,<span class="math inline">\(\lambda_i\)</span>对应的单位特征向量为<span class="math inline">\(\boldsymbol{a_i}\)</span>，则：</p><ol type="1"><li>在<span class="math inline">\(\boldsymbol{u&#39;u}=1\)</span>的条件下，<span class="math inline">\(\boldsymbol{u&#39;\Sigma u}\)</span>在<span class="math inline">\(\boldsymbol{u=a_1}\)</span>时取得最大值<span class="math inline">\(\lambda_1\)</span></li><li>在<span class="math inline">\(\boldsymbol{u&#39;u}=1,\boldsymbol{u&#39;a_i}=0\)</span>的条件下（<span class="math inline">\(i=1,2,3,\cdots,k-1\)</span>），<span class="math inline">\(\boldsymbol{u&#39;\Sigma u}\)</span>在<span class="math inline">\(u=a_k\)</span>处取得最大值<span class="math inline">\(\lambda_k\)</span></li></ol><p>于是，我们称<span class="math inline">\(y_1=\boldsymbol{u&#39;a_1}\)</span>为第一主成分，如果信息量仍然不够，应该选择第二主成分。由于要保证主成分之间的独立性，则条件应该加上<span class="math inline">\(Cov(y_1,y_2)=\boldsymbol{a&#39;_1\Sigma u}=\lambda\boldsymbol{u&#39;a_1}=0\)</span>,于是遵循（2）的规则继续取就行了。如此这样不断地取，直到累计方差贡献率 <span class="math display">\[\frac{\lambda_1+\cdots+\lambda_k} {\lambda_1+\lambda_2+\cdots+\lambda_p}\]</span> 达到预设值（往往为百分之七十五），就结束分析。</p><hr /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><span class="math inline">(p(x;a,b))</span>的含义是：该函数以<span class="math inline">(x)</span>为自变量，有两个参数<span class="math inline">(a)</span>和<span class="math inline">(b)</span> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><span class="math inline">(I)</span>是<span class="math inline">(T(x))</span>的值域，<span class="math inline">()</span>是<span class="math inline">()</span>的值域 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><span class="math inline">(B(n,p))</span>表示重复<span class="math inline">(n)</span>次试验，每次试验成功的概率为<span class="math inline">(p)</span>，成功的试验数目。这里实际上退化成了两点分布。 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>指示函数<span class="math inline">(I_a())</span>：当条件<span class="math inline">(a)</span>为真时为<span class="math inline">(1)</span>，反之为<span class="math inline">(0)</span>. <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>决策函数的自变量是样本<span class="math inline">({x})</span>，因变量是对待估计量的估计 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数定义整理：第二弹</title>
    <link href="/2022/05/27/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E5%BC%B9/"/>
    <url>/2022/05/27/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p>环为什么叫做环？</p><span id="more"></span><hr /><h2 id="第三章-环与域">第三章 环与域</h2><p><strong>定义1（加群）</strong> .一个交换群叫做加群，当这个群的代数运算叫做”加法“，并用符号<span class="math inline">\(+\)</span>表示。</p><p><strong>定义2（环）</strong> .一个集合<span class="math inline">\(R\)</span>叫做一个环，当：</p><ol type="1"><li><span class="math inline">\(R\)</span>是一个加群，即<span class="math inline">\(R\)</span>对一个叫加法的代数运算作成一个交换群</li><li><span class="math inline">\(R\)</span>对另一个叫做乘法的代数运算封闭</li><li>这个乘法适合结合律</li><li>这里的加法和乘法适合左右分配律</li></ol><blockquote><p>例如：全体整数作成的集合对普通加法和乘法构成一个环。需要注意的是，环的定义中的乘法并不总满足交换律。</p></blockquote><p><strong>定义3（交换环）</strong> .一个环<span class="math inline">\(R\)</span>被称作交换环，当： <span class="math display">\[\forall a,b\in R,ab=ba\]</span> <strong>定义4（环的单位元）</strong> 如果一个环<span class="math inline">\(R\)</span>中存在一个元素<span class="math inline">\(e\)</span>,使得 <span class="math display">\[\forall a\in R,ea=ae=a\]</span> 那么这个<span class="math inline">\(e\)</span>叫做环<span class="math inline">\(R\)</span>的单位元。环并不总有单位元。</p><blockquote><p>例如：全体偶数对普通加法和普通乘法作成环，但是没有单位元。</p></blockquote><p><strong>定义5（零因子）</strong> .如果在一个环里，<span class="math inline">\(a\neq0,b\neq0\)</span>但是<span class="math inline">\(ab=0\)</span>，那么<span class="math inline">\(a\)</span>是环中的一个左零因子，<span class="math inline">\(b\)</span>是环中的一个右零因子。</p><blockquote><p>例如：对于所有形如<span class="math inline">\(\begin{pmatrix}x&amp;0\\y&amp;0\\\end{pmatrix}\)</span>的矩阵，对普通矩阵加法和普通矩阵乘法构成的环而言，有： <span class="math display">\[\begin{pmatrix}1 &amp; 0\\0 &amp;0\\\end{pmatrix}\begin{pmatrix}0 &amp; 0\\1 &amp; 0\\\end{pmatrix}=\begin{pmatrix}0 &amp; 0\\0 &amp;0\\\end{pmatrix}\]</span> 于是<span class="math inline">\(\begin{pmatrix}1 &amp; 0\\0 &amp;0\\\end{pmatrix}\)</span>是一个左零因子，<span class="math inline">\(\begin{pmatrix}0 &amp; 0\\1 &amp; 0\\\end{pmatrix}\)</span>是一个右零因子。</p></blockquote><blockquote><p>在一个没有零因子的环中两个消去律都成立，并且如果有任意一个消去律成立，就没有零因子。</p></blockquote><p><strong>定义6（整环）</strong> 符合以下性质的环<span class="math inline">\(R\)</span>叫做整环：</p><ol type="1"><li>乘法适合交换律</li><li><span class="math inline">\(R\)</span>有单位元<span class="math inline">\(1\)</span></li><li><span class="math inline">\(R\)</span>没有零因子</li></ol><p><strong>定义7（除环）</strong> 符合以下性质的环<span class="math inline">\(R\)</span>叫做除环：</p><ol type="1"><li><span class="math inline">\(R\)</span>至少包含一个不为<span class="math inline">\(0\)</span>的元</li><li><span class="math inline">\(R\)</span>有单位元</li><li><span class="math inline">\(R\)</span>的每一个不为<span class="math inline">\(0\)</span>的元有一个逆元</li></ol><blockquote><p>显然，除环没有零因子，而且除环中的元素（除了0）对于乘法来说构成群。在一个除环中，只要<span class="math inline">\(a\neq 0\)</span>,我们就能拿<span class="math inline">\(a\)</span>去除任意一个元<span class="math inline">\(b\)</span>，这就是除环名字的来历。</p></blockquote><p><strong>定义8（域）</strong> 一个交换除环叫做一个域。</p><p><strong>定义9（环的特征）</strong> 一个无零因子环<span class="math inline">\(R\)</span>的非零元的相同的（对于加法来说）的阶叫做环的特征。</p><blockquote><p>环的特征如果有限，那么它一定是个素数。</p></blockquote><p><strong>定义10（子环）</strong> 一个环<span class="math inline">\(R\)</span>的子集<span class="math inline">\(S\)</span>如果对<span class="math inline">\(R\)</span>的代数运算也作成一个环，那么它叫做<span class="math inline">\(R\)</span>的子环。</p><p><strong>定义11（多项式）</strong> 假设<span class="math inline">\(R_0\)</span>是一个有单位元的交换环，<span class="math inline">\(R\)</span>是<span class="math inline">\(R_0\)</span>的子环，且包含<span class="math inline">\(R_0\)</span>的单位元。我们在<span class="math inline">\(R_0\)</span>中取出一个元<span class="math inline">\(x\)</span>。一个可以写成 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n\]</span> 的<span class="math inline">\(R_0\)</span>的元叫做<span class="math inline">\(R\)</span>上的<span class="math inline">\(x\)</span>的多项式。</p><p><strong>定义12（多项式环）</strong> 我们把所有<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式放在一个集合中，叫做<span class="math inline">\(R[x]\)</span>，那么<span class="math inline">\(R[x]\)</span>叫做<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式环。</p><p><strong>定义13（未定元，次数）</strong> <span class="math inline">\(R_0\)</span>的一个元<span class="math inline">\(x\)</span>叫做<span class="math inline">\(R\)</span>上的一个未定元，如果<span class="math inline">\(R\)</span>中不存在不全为零的<span class="math inline">\(a_0,a_1,a_2,\cdots,a_n\)</span>，使得 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n=0\]</span> <span class="math inline">\(R\)</span>上的一个未定元<span class="math inline">\(x\)</span>的一元多项式只能用一种方法写成 <span class="math display">\[a_0+a_1x+\cdots+a_nx^n ,a_n\neq0\]</span> 的形式。其中<span class="math inline">\(n\)</span>叫做多项式的次数。</p><p><strong>定义14（无关未定元）</strong> <span class="math inline">\(R_0\)</span>上的<span class="math inline">\(n\)</span>个元<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>叫做<span class="math inline">\(R\)</span>上的无关未定元，假如任何一个<span class="math inline">\(R\)</span>上<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>的多项式都不为零，除非系数全为零。</p><p><strong>定义15（理想）</strong> 环<span class="math inline">\(R\)</span>的一个子环<span class="math inline">\({\mathfrak A}\)</span>叫做一个 <strong>理想子环，简称理想</strong> ，当：</p><ol type="1"><li><span class="math inline">\(a,b\in{\mathfrak A}\to a-b\in {\mathfrak A}\)</span></li><li><span class="math inline">\(a\in{\mathfrak A},r\in R\to ra,ar\in{\mathfrak A}\)</span></li></ol><blockquote><p>一个环有两个平凡的理想，分别的只含零元的零理想、R自己（单位理想）</p></blockquote><p><strong>定义16（主理想）</strong> 给定一个环<span class="math inline">\(R\)</span>，取其中的一个元素<span class="math inline">\(a\)</span>，利用<span class="math inline">\(a\)</span>作成一个集合<span class="math inline">\({\mathfrak A}\)</span>,其中包含所有形如： <span class="math display">\[(x_1ay_1+\cdots+x_may_m)+sa+st+na\]</span> （其中<span class="math inline">\(x,y,s,t\in R\)</span>，<span class="math inline">\(n\)</span>是整数）形式的元。那么<span class="math inline">\({\mathfrak A}\)</span>是含有<span class="math inline">\(a\)</span>的最小理想，叫做由<span class="math inline">\(a\)</span>生成的 <strong>主理想</strong> ，用<span class="math inline">\((a)\)</span>表示。</p><p>特别地：</p><ul><li>如果<span class="math inline">\(R\)</span>是交换环，<span class="math inline">\((a)\)</span>的元都可以写成<span class="math inline">\(ra+na\)</span>的形式。其中<span class="math inline">\(r\in R,n\)</span>是整数</li><li>如果<span class="math inline">\(R\)</span>有单位元，<span class="math inline">\((a)\)</span>的元都可以写成<span class="math inline">\(\sum x_iay_i\)</span>的形式。</li><li>如果<span class="math inline">\(R\)</span>既是交换环由于单位元，那么<span class="math inline">\((a)\)</span>都可以写成<span class="math inline">\(ra\)</span>的形式。</li></ul><p><strong>定义17（生成理想）</strong> <span class="math inline">\({\mathfrak A}\)</span>叫做由<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span> <strong>生成的理想</strong> ，用<span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span>来表示。<span class="math inline">\({\mathfrak A}\)</span>包含所有可以写成 <span class="math display">\[s_1+s_2+\cdots+s_n(s_1\in(a_i))\]</span> 的元。</p><p><strong>定义18（剩余类环）</strong> 给定一个环<span class="math inline">\(R\)</span>，<span class="math inline">\({\mathfrak A}\)</span>是它的一个理想。就加法来看，<span class="math inline">\({\mathfrak A}\)</span>是<span class="math inline">\(R\)</span>的不变子群，这样<span class="math inline">\({\mathfrak A}\)</span>的陪集 <span class="math display">\[[a],[b],\cdots\]</span> 作成<span class="math inline">\(R\)</span>的一个分类，我们把这些类叫做模<span class="math inline">\({\mathfrak A}\)</span>的剩余类，<span class="math inline">\(\bar{R}\)</span>是所有模<span class="math inline">\({\mathfrak A}\)</span>的剩余类组成的集合，它也是一个环，我们称其为 <strong>剩余类环</strong> ，记作： <span class="math display">\[R/{\mathfrak A}\]</span></p><blockquote><p>事实上，<span class="math inline">\(R\)</span>和<span class="math inline">\(\bar{R}\)</span>同态。</p></blockquote><p><strong>定义19（最大理想）</strong> 一个环<span class="math inline">\(R\)</span>的一个不等于<span class="math inline">\(R\)</span>的理想<span class="math inline">\({\mathfrak A}\)</span>叫做 <strong>最大理想</strong> ，当除了<span class="math inline">\(R\)</span>和<span class="math inline">\({\mathfrak A}\)</span>以外，没有包含<span class="math inline">\({\mathfrak A}\)</span>的理想。</p><p>最大理想有时候也叫做极大理想。如果<span class="math inline">\(R\)</span>是有单位元的交换环，<span class="math inline">\({\mathfrak A}\)</span>是<span class="math inline">\(R\)</span>的理想，那么<span class="math inline">\(R/{\mathfrak A}\)</span>是一个域等价于<span class="math inline">\({\mathfrak A}\)</span>是最大理想。</p><p><strong>定义20（商域）</strong> 一个域<span class="math inline">\(Q\)</span>叫做一个环<span class="math inline">\(R\)</span>的 <strong>商域</strong> ，假如<span class="math inline">\(Q\)</span>包含<span class="math inline">\(R\)</span>，并且<span class="math inline">\(Q\)</span>恰好由 <span class="math display">\[\frac{a}{b}\ \ (a,b\in R,b\neq 0)\]</span> 组成。</p><h2 id="第四章-整环里的因子分解">第四章 整环里的因子分解</h2><p><strong>定理1（整数环上唯一分解定理）</strong> 一个整数可以唯一地写成若干个素数的乘积。</p><p><strong>定义21（整除,因子）</strong> 我们说整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(a\)</span>可以被整环<span class="math inline">\(I\)</span>中的另一个元<span class="math inline">\(b\)</span> <strong>整除</strong> ，当能在<span class="math inline">\(I\)</span>中找出一个元<span class="math inline">\(c\)</span>，使得 <span class="math display">\[a=bc\]</span> 如果<span class="math inline">\(a\)</span>能被<span class="math inline">\(b\)</span>整除，记作<span class="math inline">\(b|a\)</span>，我们说<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的 <strong>因子</strong>。</p><p><strong>定义22（单位，相伴元）</strong> 整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(\varepsilon\)</span>叫做<span class="math inline">\(I\)</span>的一个 <strong>单位</strong> ，当<span class="math inline">\(\varepsilon\)</span>是有逆元的元。<span class="math inline">\(b\)</span>叫做<span class="math inline">\(a\)</span>的 <strong>相伴元</strong> ，假如 <span class="math display">\[b=\varepsilon a\]</span></p><blockquote><p>例如，整数环中有两个单位，分别是<span class="math inline">\(1\)</span>和<span class="math inline">\(-1\)</span>；整复数环中有四个单位，分别是<span class="math inline">\(\pm 1\)</span>,<span class="math inline">\(\pm i\)</span>。显然，单位的乘积、单位的逆元也是单位。</p></blockquote><p><strong>定义23（平凡因子、真因子）</strong> 单位和<span class="math inline">\(a\)</span>的相伴元叫做<span class="math inline">\(a\)</span>的 <strong>平凡因子</strong> ，<span class="math inline">\(a\)</span>的其它因子叫做<span class="math inline">\(a\)</span>的 <strong>真因子</strong> 。</p><p><strong>定义24（素元）</strong> 一个整环<span class="math inline">\(I\)</span>的一个既不是零元、也不是单位、还没有真因子的元<span class="math inline">\(p\)</span>叫做 <strong>素元</strong> 。</p><blockquote><p>这样的话，单位元和素元的积也是素元。</p></blockquote><p><strong>定义25（唯一分解）</strong> 我们说一个整环<span class="math inline">\(I\)</span>的一个元<span class="math inline">\(a\)</span>在<span class="math inline">\(I\)</span>里有 <strong>唯一分解</strong> ，假如：</p><ol type="1"><li><span class="math inline">\(a=p_1p_2\cdots p_r\)</span>，其中<span class="math inline">\(p_i\)</span>是素元</li><li>若同时<span class="math inline">\(a=q_1q_2\cdots q_s\)</span>，其中<span class="math inline">\(q\)</span>是素元，那么<span class="math inline">\(r=s\)</span>，并且我们可以把<span class="math inline">\(q_i\)</span>的次序调换一下，使得<span class="math inline">\(\forall i,q_i=p_i\varepsilon\)</span></li></ol><blockquote><p>一个整环的泠鸢和单位显然是没有唯一分解的，但是其实不是零元也不是单位的元也不一定有唯一分解，例如在环<span class="math inline">\(I=\{a+\sqrt{3}bi|a,b\in {\mathbb Z}\}\)</span>中的元<span class="math inline">\(4\)</span>，有： <span class="math display">\[4=2\times2=(1+\sqrt{3}i)\times(1-\sqrt{3}i)\]</span></p></blockquote><p><strong>定义26（唯一分解环）</strong> 如果一个整环<span class="math inline">\(I\)</span>的每一个不是零元也不是单位的元都能唯一分解，那么<span class="math inline">\(I\)</span>叫做 <strong>唯一分解环</strong> 。</p><p><strong>定义27（公因子，最大公因子）</strong> 如果一个元<span class="math inline">\(c\)</span>能同时整除<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，这个元<span class="math inline">\(c\)</span>叫做<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>的 <strong>公因子</strong> 。如果公因子<span class="math inline">\(d\)</span>能被每个公因子整除，那么这个<span class="math inline">\(d\)</span>叫做 <strong>最大公因子</strong> 。</p><p><strong>定义28（互素）</strong> 一列数的最大公因子是单位，那称这一列数 <strong>互素</strong> 。</p><p><strong>定义29（主理想环）</strong> 如果整环<span class="math inline">\(I\)</span>的每个理想都是主理想，那么称<span class="math inline">\(I\)</span>是 <strong>主理想环</strong> 。</p><blockquote><p>主理想环有个很重要的性质：在主理想环中构造一个序列<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，其中后项一定是前项的真因子，那么这个序列长度有限。而且一个主理想环一定是唯一分解环。</p></blockquote><p><strong>定义30（欧氏环）</strong> 一个满足下列性质的整环<span class="math inline">\(I\)</span>叫做 <strong>欧氏环</strong> ：</p><ol type="1"><li><p>有一个从<span class="math inline">\(I\)</span>的非零元所组成的集合到自然数集合的映射<span class="math inline">\(\phi\)</span>存在</p></li><li><p>对于<span class="math inline">\(I\)</span>中一个非零元<span class="math inline">\(a\)</span>，<span class="math inline">\(I\)</span>中任何元<span class="math inline">\(b\)</span>都可写成 <span class="math display">\[b=qa+r\ \ (q,r\in I)\]</span> 的形式，且有：<span class="math inline">\(r=0\)</span>或<span class="math inline">\(\phi(r)&lt;\phi(a)\)</span></p></li></ol><blockquote><p>所有欧氏环都是主理想环，于是也是唯一分解环。而且一个域<span class="math inline">\(F\)</span>上的一元多项式环<span class="math inline">\(F[x]\)</span>是一个欧氏环。</p></blockquote><p><strong>定义31（本原多项式）</strong> <span class="math inline">\(I[x]\)</span>的一个元<span class="math inline">\(f(x)\)</span>叫做本原多项式，假如<span class="math inline">\(f(x)\)</span>系数的最大公因子是单位。</p><p>如果有<span class="math inline">\(f(x)=g(x)h(x)\)</span>，那么<span class="math inline">\(f(x)\)</span>是本原多项式，当且仅当<span class="math inline">\(g(x),h(x)\)</span>是本原多项式。</p><p><strong>定义32（多项式的根）</strong> <span class="math inline">\(I\)</span>的元<span class="math inline">\(a\)</span>叫做<span class="math inline">\(I[x]\)</span>的多项式<span class="math inline">\(f(x)\)</span>的一个 <strong>根</strong> ，当且仅当<span class="math inline">\(f(a)=0\)</span></p><p><strong>定义33（多项式的重根）</strong> <span class="math inline">\(I\)</span>的元<span class="math inline">\(a\)</span>叫做<span class="math inline">\(I[x]\)</span>的多项式<span class="math inline">\(f(x)\)</span>的一个 <strong><span class="math inline">\(k\)</span>重根</strong> ，假如<span class="math inline">\(f(x)\)</span>能被<span class="math inline">\((x-a)^k\)</span>整除，其中<span class="math inline">\(k\)</span>大于1.</p><p><strong>定义34（多项式的导数）</strong> 对于多项式 <span class="math display">\[f(x)=\sum_{i=0}^na_ix^i\]</span> 其导数为 <span class="math display">\[f&#39;(x)=\sum_{i=1}^{n}ia_ix^{i-1}\]</span></p><h2 id="第五章扩域">第五章：扩域</h2><p><strong>定义35（扩域）</strong> 一个域<span class="math inline">\(E\)</span>叫做一个域<span class="math inline">\(F\)</span>的 <strong>扩域</strong> ，当<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域</p><p>例如：实数域是有理数域的扩域，复数域是实数域的扩域。</p><blockquote><p>事实上，令<span class="math inline">\(E\)</span>是一个域，如果<span class="math inline">\(E\)</span>的特征是无穷大，那么它含有一个和有理数域同构的子域；如果<span class="math inline">\(E\)</span>的特征是素数<span class="math inline">\(p\)</span>，那么它含一个和<span class="math inline">\(R/(p)\)</span>同构的子域，其中<span class="math inline">\(R\)</span>是整数环，<span class="math inline">\((p)\)</span>是由<span class="math inline">\(p\)</span>生成的主理想。</p></blockquote><p><strong>定义36（素域）</strong> 一个域叫做一个 <strong>素域</strong> ，假如它不含任何真子域。</p><p><strong>定义37（单扩域）</strong> 添加一个元素<span class="math inline">\(\alpha\)</span>于域<span class="math inline">\(F\)</span>中所得的扩域<span class="math inline">\(F(\alpha)\)</span>叫做<span class="math inline">\(F\)</span>的一个单扩域</p><p><strong>定义38（代数元）</strong> 如果对于域<span class="math inline">\(F\)</span>中的一个元素<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(F\)</span>中存在不全为零的元<span class="math inline">\(a_1,\cdots,a_n\)</span>，使得： <span class="math display">\[a_0+a_1\alpha+a_2\alpha+\cdots+a_n\alpha^n=0\]</span> 那么<span class="math inline">\(\alpha\)</span>叫做 <strong>代数元</strong> 。如果这样的<span class="math inline">\(a_1,\cdots,a_n\)</span>不存在，<span class="math inline">\(\alpha\)</span>就叫做 <strong>超越元</strong> 。</p><blockquote><p>代数数就是整数环上的代数元。</p></blockquote><p><strong>定义39（极小多项式）</strong> <span class="math inline">\(F[x]\)</span>中满足<span class="math inline">\(p(\alpha)=0\)</span>的次数最低的多项式 <span class="math display">\[p(x)=x^n+a_{n-1}x^{n-1}+\cdots+a_0\]</span> 叫做<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(F\)</span>上的 <strong>极小多项式</strong> ，<span class="math inline">\(n\)</span>叫做<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(F\)</span>上的 <strong>次数</strong></p><p><strong>定义40（代数扩域）</strong> 如果域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>的每一个元都是<span class="math inline">\(F\)</span>的代数元，那么<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F\)</span>的 <strong>代数扩域（扩张）</strong> 。</p><blockquote><p>假如<span class="math inline">\(K\)</span>是<span class="math inline">\(F\)</span>的扩域，那么<span class="math inline">\(K\)</span>可以视作是<span class="math inline">\(F\)</span>上的一个向量空间（对于<span class="math inline">\(K\)</span>的加法和<span class="math inline">\(F\times K\to K\)</span>的乘法）。也就是说，对于任意<span class="math inline">\(K\)</span>上的元素<span class="math inline">\(\alpha\)</span> ，存在一组来自于<span class="math inline">\(K\)</span>的基，使<span class="math inline">\(\alpha\)</span>可以被那些基线性表出，而表示的基的各项系数都在<span class="math inline">\(F\)</span>内。</p><p>例如：复数域是实数域的扩域，而复数域的“基”就是<span class="math inline">\(1\)</span>和<span class="math inline">\(i\)</span></p></blockquote><p><strong>定义41（有限扩域，扩域的次数）</strong> 如果域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>作为<span class="math inline">\(F\)</span>上的向量空间的维数为<span class="math inline">\(n\)</span>，那么<span class="math inline">\(n\)</span>称作扩域<span class="math inline">\(E\)</span>在<span class="math inline">\(F\)</span>上的 <strong>次数</strong> ，记作<span class="math inline">\((E:F)=n\)</span>.此时<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F\)</span>的一个 <strong>有限扩域</strong> 。</p><blockquote><p>若有 <span class="math display">\[F\subset I\subset E\]</span> 则有 <span class="math display">\[(E:F)=(E:I)(I:F)\]</span></p></blockquote><p><strong>定义42（多项式的分裂域/根域）</strong> 域<span class="math inline">\(F\)</span>的一个扩域<span class="math inline">\(E\)</span>叫做<span class="math inline">\(F[x]\)</span>的<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(F\)</span>上的一个 <strong>分裂域（也叫根域）</strong> ，如果：</p><ol type="1"><li><p>在<span class="math inline">\(E[x]\)</span>中，<span class="math inline">\(f(x)\)</span>可以分解为一次因子的积 <span class="math display">\[f(x)=a_n(x-\alpha_1)(x-\alpha_2)\cdots(x-\alpha_n)\]</span></p></li><li><p>在一个比<span class="math inline">\(E\)</span>小的域中，<span class="math inline">\(f(x)\)</span>不能被这样分解。</p></li></ol><blockquote><p>有： <span class="math display">\[E=F(\alpha_1,\alpha_2\cdots,\alpha_n)\]</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于用R语言进行方差分析的乐子二则</title>
    <link href="/2022/05/23/%E5%85%B3%E4%BA%8E%E7%94%A8R%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%90%E5%AD%90%E4%BA%8C%E5%88%99/"/>
    <url>/2022/05/23/%E5%85%B3%E4%BA%8E%E7%94%A8R%E8%AF%AD%E8%A8%80%E8%BF%9B%E8%A1%8C%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%B9%90%E5%AD%90%E4%BA%8C%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>我们都知道R语言是非常强的统计工具，今天想着用R语言来做数理统计作业，却被摆了两道，哈哈。</p><span id="more"></span><h2 id="方差分析">方差分析</h2><p>要讨论这两则乐子，首先要知道什么是方差分析。</p><h3 id="单变量方差分析">单变量方差分析</h3><p>单因素方差分析可以看成基础统计中两样本<span class="math inline">\(t\)</span>检验的一个推广， 要比较试验观测值的某个因变量（称为“指标”）按照一个分组变量（称为“因素”）分组后， 各组的因变量均值有无显著差异。</p><p>设因素A有p个不同的水平<span class="math inline">\(A_1,A_2,\cdots,A_p\)</span>,在每个水平下，总体<span class="math inline">\(X_i\sim N(\mu_i,\sigma^2)\)</span>,需要检验的是这<span class="math inline">\(p\)</span>个样本的平均值有没有显著差异，即： <span class="math display">\[H_0:\mu_1=\mu_2=\cdots=\mu_p\]</span> 一般地，我们在每个水平中抽取<span class="math inline">\(r\)</span>个样本，形成如下的样本表：</p><table><thead><tr class="header"><th><span class="math inline">\(A_1\)</span></th><th><span class="math inline">\(x_{11}\)</span></th><th><span class="math inline">\(x_{12}\)</span></th><th><span class="math inline">\(\cdots\)</span></th><th><span class="math inline">\(x_{1r}\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(A_2\)</span></td><td><span class="math inline">\(x_{21}\)</span></td><td><span class="math inline">\(x_{22}\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(x_{2r}\)</span></td></tr><tr class="even"><td><span class="math inline">\(\cdots\)</span></td><td></td><td></td><td><span class="math inline">\(\cdots\)</span></td><td></td></tr><tr class="odd"><td><span class="math inline">\(A_P\)</span></td><td><span class="math inline">\(x_{p1}\)</span></td><td><span class="math inline">\(x_{p2}\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(x_{pr}\)</span></td></tr></tbody></table><p>【例】：用R语言对下列数据进行方差分析：</p><table><thead><tr class="header"><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr class="odd"><td>58</td><td>58</td><td>48</td></tr><tr class="even"><td>64</td><td>69</td><td>57</td></tr><tr class="odd"><td>55</td><td>71</td><td>59</td></tr><tr class="even"><td>66</td><td>64</td><td>47</td></tr><tr class="odd"><td>67</td><td>68</td><td>49</td></tr></tbody></table><p>【解】先把表格转换成纵列形式</p><table><thead><tr class="header"><th>grp</th><th>y</th></tr></thead><tbody><tr class="odd"><td>A</td><td>58</td></tr><tr class="even"><td>A</td><td>64</td></tr><tr class="odd"><td>A</td><td>55</td></tr><tr class="even"><td>A</td><td>66</td></tr><tr class="odd"><td>A</td><td>67</td></tr><tr class="even"><td>B</td><td>58</td></tr><tr class="odd"><td>B</td><td>69</td></tr><tr class="even"><td>B</td><td>71</td></tr><tr class="odd"><td>B</td><td>64</td></tr><tr class="even"><td>B</td><td>68</td></tr><tr class="odd"><td>C</td><td>48</td></tr><tr class="even"><td>C</td><td>57</td></tr><tr class="odd"><td>C</td><td>59</td></tr><tr class="even"><td>C</td><td>47</td></tr><tr class="odd"><td>C</td><td>49</td></tr></tbody></table><p>将上表保存为<code>R1.csv</code>，在”我的文档“中。在R软件中输入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">data <span class="hljs-operator">&lt;-</span> read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;R1.csv&quot;</span><span class="hljs-punctuation">)</span><br>data<br></code></pre></td></tr></table></figure><p>可以读入数据，并展示数据。</p><p>然后建立方差分析模型，在R软件中输入：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>y<span class="hljs-operator">~</span>grp<span class="hljs-punctuation">,</span>data<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>即可输出分析结果，如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value  Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>   <br>grp          <span class="hljs-number">2</span>    <span class="hljs-number">520</span>  <span class="hljs-number">260.00</span>   <span class="hljs-number">9.176</span> <span class="hljs-number">0.00382</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">12</span>    <span class="hljs-number">340</span>   <span class="hljs-number">28.33</span>                   <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们看到<code>grp</code>的<span class="math inline">\(P_r\)</span>值有<span class="math inline">\(0.00382&lt;0.05\)</span>，所以可以认为各组之间有显著差异。</p><h3 id="双变量方差分析">双变量方差分析</h3><p>在实际任务中，影响实验结果的因素可能不止一个，这时就要用到双变量方差分析（或者正交实验）。在两个因素的实验中，不但每一个因素会对结果起作用，而且两个因素联合起来往往也会对结果起作用。如果你不能理解这个结论，不妨设想这样一个例子：工人在工厂工作时，对工人效率的影响因素有工人和机器。如果工人专业技能高、机器运行状况好，那么效率很自然地就会比较高。但是一个资质平平的工人如果对某个状况一般的机器非常熟悉，以至于把这个机器什么时候会出现什么误差都记得滚瓜烂熟，那么把他俩结合起来，也有可能获得很高的效率。</p><p>为了进行双变量方差分析，进行双因素重复性实验，得到的数据表往往是这样给出的：</p><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320029199.png" /></p><p>这时，我就美美地开始做题了！</p><h2 id="第一道题">第一道题</h2><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320064532.png" /></p><p>我一看这不简单？于是美美列了个表：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B   Y<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">106</span><br><span class="hljs-number">4</span>  <span class="hljs-number">4</span> <span class="hljs-number">1</span>  <span class="hljs-number">98</span><br><span class="hljs-number">5</span>  <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">102</span><br><span class="hljs-number">6</span>  <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">112</span><br><span class="hljs-number">7</span>  <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">105</span><br><span class="hljs-number">8</span>  <span class="hljs-number">8</span> <span class="hljs-number">1</span>  <span class="hljs-number">95</span><br><span class="hljs-number">9</span>  <span class="hljs-number">1</span> <span class="hljs-number">2</span>  <span class="hljs-number">95</span><br><span class="hljs-number">10</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>  <span class="hljs-number">94</span><br><span class="hljs-number">11</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">105</span><br><span class="hljs-number">12</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span>  <span class="hljs-number">97</span><br><span class="hljs-number">13</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-number">98</span><br><span class="hljs-number">14</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">112</span><br><span class="hljs-number">15</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">103</span><br><span class="hljs-number">16</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span>  <span class="hljs-number">92</span><br><span class="hljs-number">17</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>  <span class="hljs-number">89</span><br><span class="hljs-number">18</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>  <span class="hljs-number">88</span><br><span class="hljs-number">19</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>  <span class="hljs-number">87</span><br><span class="hljs-number">20</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>  <span class="hljs-number">95</span><br><span class="hljs-number">21</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span>  <span class="hljs-number">97</span><br><span class="hljs-number">22</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">101</span><br><span class="hljs-number">23</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span>  <span class="hljs-number">97</span><br><span class="hljs-number">24</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span>  <span class="hljs-number">90</span><br><span class="hljs-number">25</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>  <span class="hljs-number">83</span><br><span class="hljs-number">26</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span>  <span class="hljs-number">84</span><br><span class="hljs-number">27</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>  <span class="hljs-number">90</span><br><span class="hljs-number">28</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">90</span><br><span class="hljs-number">29</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">88</span><br><span class="hljs-number">30</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span>  <span class="hljs-number">94</span><br><span class="hljs-number">31</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span>  <span class="hljs-number">88</span><br><span class="hljs-number">32</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span>  <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>读取数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">X<span class="hljs-operator">=</span>read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;R.csv&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>建立模型并分析：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod<span class="hljs-operator">&lt;-</span>aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">+</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">1</span>   <span class="hljs-number">74.0</span>    <span class="hljs-number">74.0</span>   <span class="hljs-number">2.385</span>    <span class="hljs-number">0.133</span>    <br>B            <span class="hljs-number">1</span>  <span class="hljs-number">926.4</span>   <span class="hljs-number">926.4</span>  <span class="hljs-number">29.857</span> <span class="hljs-number">6.99e-06</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">29</span>  <span class="hljs-number">899.8</span>    <span class="hljs-number">31.0</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其中：</p><table><thead><tr class="header"><th>项目</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Df</td><td>自由度</td></tr><tr class="even"><td>Sum Sq</td><td>平方和</td></tr><tr class="odd"><td>Mean Sq</td><td>均方</td></tr><tr class="even"><td>F value</td><td>F值</td></tr><tr class="odd"><td>Pr(&gt;F)</td><td>p值</td></tr></tbody></table><p>哈哈，聪明的你一定看出问题了吧，那就是这俩的自由度都是<span class="math inline">\(1\)</span>，这是怎么会事呢？</p><p>原来是因为我的两个标签<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都用了数字，而R语言里的数据类型有数字、字符等。它把我们的1，2，3，...当成了一个连续变量，于是就出错了。当然这个问题可以用<code>ac.factor()</code>函数解决，但是我直接把标签换成字母也能解决。</p><p>修改了以后的输出为：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">7</span>  <span class="hljs-number">747.5</span>   <span class="hljs-number">106.8</span>   <span class="hljs-number">12.78</span> <span class="hljs-number">2.62e-06</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>B            <span class="hljs-number">3</span>  <span class="hljs-number">977.3</span>   <span class="hljs-number">325.8</span>   <span class="hljs-number">39.00</span> <span class="hljs-number">9.12e-09</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">21</span>  <span class="hljs-number">175.4</span>     <span class="hljs-number">8.4</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个结果是正确的。我们可以发现<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都对结果有不可忽视的影响。</p><h2 id="第二道题">第二道题</h2><p>三位操作工分别在四台不同的机器上操作了3天，其产量如下表所示：</p><p><img src="https://suzumiyaakizuki.github.io/post-images/1653320084039.png" /></p><p>于是我想当然哈，以为三次实验，加一下就好了，于是列了这么个表：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B  Y<br><span class="hljs-number">1</span>  a x <span class="hljs-number">47</span><br><span class="hljs-number">2</span>  b x <span class="hljs-number">51</span><br><span class="hljs-number">3</span>  <span class="hljs-built_in">c</span> x <span class="hljs-number">48</span><br><span class="hljs-number">4</span>  d x <span class="hljs-number">60</span><br><span class="hljs-number">5</span>  a y <span class="hljs-number">54</span><br><span class="hljs-number">6</span>  b y <span class="hljs-number">45</span><br><span class="hljs-number">7</span>  <span class="hljs-built_in">c</span> y <span class="hljs-number">51</span><br><span class="hljs-number">8</span>  d y <span class="hljs-number">48</span><br><span class="hljs-number">9</span>  a z <span class="hljs-number">55</span><br><span class="hljs-number">10</span> b z <span class="hljs-number">63</span><br><span class="hljs-number">11</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">54</span><br><span class="hljs-number">12</span> d z <span class="hljs-number">51</span><br></code></pre></td></tr></table></figure><p>建立模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">+</span>B<span class="hljs-operator">+</span>A<span class="hljs-operator">:</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq<br>A            <span class="hljs-number">3</span>   <span class="hljs-number">8.25</span>    <span class="hljs-number">2.75</span><br>B            <span class="hljs-number">2</span>  <span class="hljs-number">81.50</span>   <span class="hljs-number">40.75</span><br>A<span class="hljs-operator">:</span>B          <span class="hljs-number">6</span> <span class="hljs-number">220.50</span>   <span class="hljs-number">36.75</span><br></code></pre></td></tr></table></figure><p>根据<span class="math inline">\(F\)</span>值，我们可以看出....欸我<span class="math inline">\(F\)</span>值呢？咋没了？</p><p>这是因为，在”加和“（或者求平均值）的时候，就顺带消除了<span class="math inline">\(A\times B\)</span>的影响。这是因为<span class="math inline">\(A\times B\)</span>的离差平方和为： <span class="math display">\[S_{A\times B}=\sum_{i=1}^p\sum_{j=1}^q\sum_{k=1}^r (\bar{x}_{ij\cdot} -\bar{x}_{i\cdot \cdot } - \bar{x}_{\cdot j \cdot } +\bar{x})^2\]</span> 对于多次重复实验，应该把它们分拆开，每次都单独算。列表如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs R">   A B  Y<br><span class="hljs-number">1</span>  a x <span class="hljs-number">15</span><br><span class="hljs-number">2</span>  b x <span class="hljs-number">17</span><br><span class="hljs-number">3</span>  <span class="hljs-built_in">c</span> x <span class="hljs-number">15</span><br><span class="hljs-number">4</span>  d x <span class="hljs-number">18</span><br><span class="hljs-number">5</span>  a y <span class="hljs-number">19</span><br><span class="hljs-number">6</span>  b y <span class="hljs-number">15</span><br><span class="hljs-number">7</span>  <span class="hljs-built_in">c</span> y <span class="hljs-number">18</span><br><span class="hljs-number">8</span>  d y <span class="hljs-number">15</span><br><span class="hljs-number">9</span>  a z <span class="hljs-number">16</span><br><span class="hljs-number">10</span> b z <span class="hljs-number">19</span><br><span class="hljs-number">11</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">12</span> d z <span class="hljs-number">17</span><br><span class="hljs-number">13</span> a x <span class="hljs-number">15</span><br><span class="hljs-number">14</span> b x <span class="hljs-number">17</span><br><span class="hljs-number">15</span> <span class="hljs-built_in">c</span> x <span class="hljs-number">17</span><br><span class="hljs-number">16</span> d x <span class="hljs-number">20</span><br><span class="hljs-number">17</span> a y <span class="hljs-number">19</span><br><span class="hljs-number">18</span> b y <span class="hljs-number">15</span><br><span class="hljs-number">19</span> <span class="hljs-built_in">c</span> y <span class="hljs-number">17</span><br><span class="hljs-number">20</span> d y <span class="hljs-number">16</span><br><span class="hljs-number">21</span> a z <span class="hljs-number">18</span><br><span class="hljs-number">22</span> b z <span class="hljs-number">22</span><br><span class="hljs-number">23</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">24</span> d z <span class="hljs-number">17</span><br><span class="hljs-number">25</span> a x <span class="hljs-number">17</span><br><span class="hljs-number">26</span> b x <span class="hljs-number">17</span><br><span class="hljs-number">27</span> <span class="hljs-built_in">c</span> x <span class="hljs-number">16</span><br><span class="hljs-number">28</span> d x <span class="hljs-number">22</span><br><span class="hljs-number">29</span> a y <span class="hljs-number">16</span><br><span class="hljs-number">30</span> b y <span class="hljs-number">15</span><br><span class="hljs-number">31</span> <span class="hljs-built_in">c</span> y <span class="hljs-number">16</span><br><span class="hljs-number">32</span> d y <span class="hljs-number">17</span><br><span class="hljs-number">33</span> a z <span class="hljs-number">21</span><br><span class="hljs-number">34</span> b z <span class="hljs-number">22</span><br><span class="hljs-number">35</span> <span class="hljs-built_in">c</span> z <span class="hljs-number">18</span><br><span class="hljs-number">36</span> d z <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>建立模型：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">mod <span class="hljs-operator">&lt;-</span> aov<span class="hljs-punctuation">(</span>Y<span class="hljs-operator">~</span>A<span class="hljs-operator">*</span>B<span class="hljs-punctuation">,</span>X<span class="hljs-punctuation">)</span><br>summary<span class="hljs-punctuation">(</span>mod<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R">            Df Sum Sq Mean Sq <span class="hljs-built_in">F</span> value   Pr<span class="hljs-punctuation">(</span><span class="hljs-operator">&gt;</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span>    <br>A            <span class="hljs-number">3</span>   <span class="hljs-number">2.75</span>   <span class="hljs-number">0.917</span>   <span class="hljs-number">0.532</span> <span class="hljs-number">0.664528</span>    <br>B            <span class="hljs-number">2</span>  <span class="hljs-number">27.17</span>  <span class="hljs-number">13.583</span>   <span class="hljs-number">7.887</span> <span class="hljs-number">0.002330</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span> <br>A<span class="hljs-operator">:</span>B          <span class="hljs-number">6</span>  <span class="hljs-number">73.50</span>  <span class="hljs-number">12.250</span>   <span class="hljs-number">7.113</span> <span class="hljs-number">0.000192</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>Residuals   <span class="hljs-number">24</span>  <span class="hljs-number">41.33</span>   <span class="hljs-number">1.722</span>                     <br><span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span><br>Signif. codes<span class="hljs-operator">:</span>  <span class="hljs-number">0</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.001</span> ‘<span class="hljs-operator">*</span><span class="hljs-operator">*</span>’ <span class="hljs-number">0.01</span> ‘<span class="hljs-operator">*</span>’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们可以看到，效率主要和工人的水平以及工人和机器的交互有关。</p><p>哈哈，我是铸币。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于拉普拉斯变换的那些事</title>
    <link href="/2022/05/21/%E5%85%B3%E4%BA%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/05/21/%E5%85%B3%E4%BA%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>拉普拉斯变换在许多工程技术和科学研究领域中有着广泛的应用，特别是在力学系统、电学系统、自动控制系统、可靠性系统以及随机服务系统等系统科学中都起着重要作用。本文大概写了一下常用的拉普拉斯变换技巧，非常的详细，我感觉任何人都能看懂。 本文约5200字，阅读时间22分钟。</p><span id="more"></span><h2 id="拉普拉斯变换概述">拉普拉斯变换概述</h2><p>说到拉普拉斯变换，就不得不提到奥列弗·赫维赛德。不得不说这位更是重量级，尽管大家可能不认识他，但是大家一定知道<code>Heaviside()</code>函数（在Mathematica中是<code>HeavisideTheta[]</code>函数）,这就是所谓的单位阶跃函数，我们一般简写为<span class="math inline">\(u(t)\)</span>或者<span class="math inline">\(\varepsilon(t)\)</span>。而且他在电子信息领域还有很多重要的贡献，比如说归纳整理了麦克斯韦方程组。而这里我们要说的是，他提出了运算微积分的思想，把常微分方程转换成了代数方程。具体地，他提出了微分算子<span class="math inline">\(p\)</span>: <span class="math display">\[p^n \leftrightarrow\frac{ {\mathbf d}^n()} { {\mathbf d}t^n}\]</span> 积分算子： <span class="math display">\[\frac{1} {p}\leftrightarrow \int_{-\infty}^t(){\mathbf d}\tau\]</span> 于是就能把常微分方程化成代数方程了。这种想法在当时并不被学界认可，但是我们现在发现这就是拉普拉斯变换的前身。</p><p>......扯远了，那么什么是拉普拉斯变换呢？我们都知道傅里叶变换很好用，但是要用它就必须得满足狄利特雷条件，其中有一条就是<span class="math inline">\(f(t)\)</span>绝对可积，这可不是什么简单的条件，于是就导致很多常见的函数没有傅里叶变换。那么为了推广傅里叶变换，给<span class="math inline">\(f(t)\)</span>乘上一个很强的衰减系数<span class="math inline">\(e^{-\sigma t}\)</span>,这时很多函数就变得绝对可积了。</p><p>容易发现，<span class="math inline">\(e^{-\sigma t}\)</span>往往在<span class="math inline">\(t&gt;0\)</span>的时候才表现出”衰减“的性质，于是我们往往讨论单边拉普拉斯变换，即： <span class="math display">\[{\mathscr L}[f(t)]=F(s)=\int_{0-}^{\infty}f(t)e^{-(\sigma +j\omega)t} {\mathbf d}t\]</span> 其中<span class="math inline">\(s={\sigma + j\omega}\)</span>.</p><p>拉普拉斯变换需要讨论收敛域的问题。我们把让上述无穷积分收敛的<span class="math inline">\(s\)</span>所在的区域称为收敛域。收敛域的边界是平行于虚轴的直线。对于右边信号而言，收敛域往往是<span class="math inline">\(Re[s]&gt;\alpha\)</span>的形式，也就是右半边平面。在讨论右边信号和单边拉普拉斯变换时，往往省去对收敛域的讨论。但对于双边拉普拉斯变换来说，一定要讨论收敛域。因为此时对于同一个<span class="math inline">\(F(s)\)</span>，不同的收敛域会导致反变换的结果不同。</p><h2 id="拉普拉斯变换性质">拉普拉斯变换性质</h2><p>设<span class="math inline">\({\mathscr L}[f(t)]=F(s)\)</span>，则</p><p>拉普拉斯变换常用的性质有：</p><h3 id="时域性质">时域性质</h3><ol type="1"><li><p>时移性质： <span class="math display">\[{\mathscr  L}[f(t-t_0)u(t-t_0)]=F(s)e^{-st_0}\]</span> 需要注意到：<span class="math inline">\(f(t-t_0)u(t-t_0)\)</span>、<span class="math inline">\(f(t-t_0)u(t)\)</span>、<span class="math inline">\(f(t-t_0)\)</span>是互不相同的。</p></li><li><p>压扩(相似)性质： <span class="math display">\[{\mathscr  L}[f(at)]=\frac{1} {a}F(\frac{s} {a})\]</span></p></li><li><p>线性性质</p></li><li><p>时域微分性质： <span class="math display">\[\begin{aligned}{\mathscr L}[\frac{ {\mathbf d}^n f(t)} { {\mathbf d}t}]&amp;=s^nF(s)-s^{n-1}f(0_-)-s^{n-2}f&#39;(0_-)-\cdots-f^{(n-1)}(0_-)\\\\&amp;=s^nF(s)-\sum_{k=0}^{n-1}s^{n-1-k}f^{(k)}(0_-)\end{aligned}\]</span></p><p>如果<span class="math inline">\(f(t)\)</span>为因果信号，即<span class="math inline">\(f(t)=f(t)u(t)\)</span>，那么： <span class="math display">\[{\mathscr  L}[\frac{ {\mathbf d}^n f(t)} { {\mathbf d}t}]=s^nF(s)\]</span> 我们看出这个形式和前面所说的”微分算子“有异曲同工之妙。这也是用拉普拉斯变换解微分方程的基础。</p></li><li><p>时域积分性质： <span class="math display">\[{\mathscr  L}[\int_{-\infty}^tf(\tau){\mathbf d}\tau]=\frac{F(s)} {s}+\frac{f^{(-1)}(0_-)} {s}\]</span></p></li></ol><h3 id="频域性质">频域性质</h3><ol type="1"><li><p>频移性质： <span class="math display">\[{\mathscr  L}[e^{s_0t}f(t)]=F(s-s_0)\]</span> 请注意和时移性质之间的区别。时间变成<span class="math inline">\(t-t_0\)</span>，乘的指数因子也是<span class="math inline">\(e^{-st_0}\)</span>，但是频域变成<span class="math inline">\(s-s_0\)</span>后，乘的指数因子却是<span class="math inline">\(e^{s_0t}\)</span>，符号不同。</p></li><li><p>频域微分性质： <span class="math display">\[{\mathscr  L}[-tf(t)]=\frac{ {\mathbf d}F(s)} { {\mathbf d}s}\]</span> 同样，注意符号。一般的，有： <span class="math display">\[{\mathscr  L}[(-t)^nf(t)]=\frac{ {\mathbf d}^nF} { {\mathbf d}s^n}\]</span></p></li><li><p>频域积分性质： <span class="math display">\[{\mathscr  L}[\frac{f(t)} {t}]=\int_s^\infty F(\lambda){\mathbf d}\lambda\]</span></p></li></ol><h3 id="其它定理">其它定理</h3><p>对于卷积运算，有卷积性质：</p><ol type="1"><li>时域卷积</li></ol><p><span class="math display">\[{\mathscr  L}[f_1(t)\bigotimes f_2(t)]=F_1(s)F_2(s)\]</span></p><ol start="2" type="1"><li>频域卷积 <span class="math display">\[{\mathscr  L}[f_1(t)f_2(t)]=\frac{1} {2\pi j}F_1(s)\bigotimes F_2(s)\]</span> 频域卷积很少用到。</li></ol><p>此外，还有终、初值定理：</p><ol type="1"><li><p>初值定理 <span class="math display">\[f(0_+)=\lim_{s\to \infty}sF(s)\]</span></p></li><li><p>终值定理 <span class="math display">\[\lim_{t\to \infty}f(t)=\lim_{s\to 0}sF(s)\]</span></p></li></ol><h2 id="常用拉普拉斯变换表">常用拉普拉斯变换表</h2><table><thead><tr class="header"><th style="text-align: center;">原函数</th><th style="text-align: center;">像函数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span>或<span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s}\)</span></td></tr></tbody></table><p>就一个？没错。因为其它的常用的基本上都能用性质推导出来。</p><ol type="1"><li><p><span class="math inline">\(t^n\)</span></p><p>由频域微分性质<span class="math inline">\({\mathscr L}[(-t)^nf(t)]=\frac{ {\mathbf d}^nF} { {\mathbf d}s^n}\)</span>，将<span class="math inline">\(f(t)=u(t),F=s^{-1}\)</span>代入，可得： <span class="math display">\[{\mathscr  L}[t^n]=\frac{n!} {s^{n+1} }\]</span></p></li><li><p><span class="math inline">\(e^{at}\)</span></p><p>由频移性质<span class="math inline">\({\mathscr L}[e^{s_0t}f(t)]=F(s-s_0)\)</span>可得： <span class="math display">\[{\mathscr  L}[e^{at}]=\frac{1} {s-a}\]</span></p></li><li><p><span class="math inline">\(t^ne^{at}\)</span></p><p>对<span class="math inline">\(t^n\)</span>的拉普拉斯变换应用频移性质，有： <span class="math display">\[{\mathscr  L}[t^n e^{at}]=\frac{n!} {(s-a)^{n+1} }\]</span></p></li><li><p><span class="math inline">\(\cos (\omega t)\)</span></p><p>由 <span class="math display">\[\cos(\omega t)=\frac{1} {2}(e^{-j\omega t}+e^{j\omega t})\]</span> 运用<span class="math inline">\(e^{at}\)</span>的拉普拉斯变换，可得 <span class="math display">\[{\mathscr  L}[\cos (\omega t)]=\frac{s} {s^2+\omega ^2}\]</span></p></li><li><p><span class="math inline">\(\sin (\omega t)\)</span></p><p>由 <span class="math display">\[\sin(\omega t)=\frac{1} {2j}(e^{j\omega t}-e^{-j\omega t})\]</span> 得 <span class="math display">\[{\mathscr  L}[\sin(\omega t)]=\frac{\omega} {s^2+\omega ^2}\]</span></p></li></ol><p>虽说如此，表格还是需要的。现归纳如下：</p><table><thead><tr class="header"><th style="text-align: center;">原函数</th><th style="text-align: center;">像函数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u(t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac 1s\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{n!} {s^{n+1} }\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {s-a}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(te^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1} {(s-a)^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t^ne^{at}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{n!} {(s-a)^{n+1} }\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sin (\omega t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\omega} {s^2+\omega^2}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\cos (\omega t)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{s} {s^2+\omega^2}\)</span></td></tr></tbody></table><h2 id="多项式分式的拉普拉斯逆变换">多项式分式的拉普拉斯逆变换</h2><p>一个有理真分式形式的拉普拉斯变换式可以写成： <span class="math display">\[F(s)=\frac{N(s)} {D(s)}\]</span> 其中<span class="math inline">\(N\)</span>和<span class="math inline">\(D\)</span>都是多项式，<span class="math inline">\(D\)</span>的次数更高。接下来讲解如何计算这样的式子的拉普拉斯反变换。</p><p>基于代数方程的理论，上面的式子可以写成： <span class="math display">\[F(s)=\frac{K_1} {(s-p_1)}+\frac{K_1} {(s-p_1)}+\cdots+\frac{K_n} {(s-p_n)}\]</span> 即分解成很多小分式的和，其中<span class="math inline">\(p\)</span>为<span class="math inline">\(D\)</span>的根。多项式的根可能有单根、多重根，共轭复数根三种情况，我们来分别讨论。</p><h3 id="单根">单根</h3><p>单根对应的小分式为： <span class="math display">\[\frac{K_i} {s-p_i}\]</span> 在计算时，只需要给<span class="math inline">\(F(s)\)</span>两边同时乘以<span class="math inline">\((s-p_i)\)</span>，这样就能把这个极点消掉了，然后将<span class="math inline">\(s=p_i\)</span>代入<span class="math inline">\((s-p_i)F(s)\)</span>中（温馨提示：不要看到<span class="math inline">\((s-p_i)\)</span>乘以什么什么的形式就以为是0哦！），就能算出<span class="math inline">\(K_i\)</span>了。</p><p>这个小分式对应的原函数是<span class="math inline">\(K_ie^{p_it}\)</span>.</p><p>举例如下：</p><blockquote><p>【例】计算下式的拉普拉斯反变换 <span class="math display">\[\frac{2s^2+3s+3} {s^3+6s^2+11s+6}\]</span> 【解】首先计算极点。打开计算器，按顺序输入：<kbd>设置</kbd> <kbd>8</kbd> <kbd>2</kbd> <kbd>3</kbd>，进入求解三次多项式方程的页面。输入<kbd>1</kbd> <kbd>=</kbd> <kbd>6</kbd> <kbd>=</kbd> <kbd>1</kbd> <kbd>1</kbd> <kbd>=</kbd> <kbd>6</kbd>，将分母的多项式输入计算器。按<kbd>=</kbd>，即可得到三个根为： <span class="math display">\[-3,-1,-2\]</span> 于是<span class="math inline">\(F(s)\)</span>可以写为： <span class="math display">\[\begin{aligned}F(s)&amp;=\frac{2s^2+3s+3} {(s+1)(s+2)(s+3)}\\&amp;=\frac{K_1} {s+1}+\frac{K_2} {s+2}+\frac{K_3} {s+3}\end{aligned}\]</span> 我们看到都是单根，于是继续进行求解。</p><p>按计算器<kbd>设置</kbd> <kbd>1</kbd>返回计算模式。依次在键盘上输入<kbd>-</kbd> <kbd>1</kbd> <kbd>STO</kbd> <kbd>(-)[即A]</kbd>，屏幕上显示</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> -&gt; A<br>      <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>意思是给变量A赋值为-1.</p><p>按<kbd>AC</kbd>，在计算器上输入<span class="math inline">\((s+1)F(s)\)</span>，即： <span class="math display">\[\frac{2A^2+3A+3} {(A+2)(A+3)}\]</span> 按<kbd>=</kbd>,屏幕上的结果即为<span class="math inline">\(K_1=1\)</span></p><p>如法炮制，可以计算出<span class="math inline">\(K_2=-5,K_3=6\)</span></p><p>则原函数为 <span class="math display">\[f(t)=(e^{-t}+5e^{-2t}+6e^{-3t})u(t)\]</span></p></blockquote><h3 id="共轭复根">共轭复根</h3><p>共轭复根对应的小分式为： <span class="math display">\[\frac{K_1} {s-(a+bj)}+\frac{K_2} {s-(a-bj)}\]</span> 其中<span class="math inline">\(K_1\)</span>和<span class="math inline">\(K_2\)</span>是一对共轭复数。因为共轭复根归根结底也是单根，所以可以继续使用上面的解法来求解<span class="math inline">\(K_1,K_2\)</span>，但是只用求解其中的一个就行，因为它们共轭。假设<span class="math inline">\((a+bj)\)</span>对应的系数<span class="math inline">\(K_1=r\angle \theta=re^{i\theta}\)</span>,这对共轭复根对应的原函数为： <span class="math display">\[\begin{aligned}f(t)&amp;=re^{j\theta}e^{(a+bj)t}+re^{-j\theta}e^{(a-bj)t}\\&amp;=re^{at}(e^{j(bt+\theta)}+e^{-j(bt+\theta)})\\&amp;=2re^{at}\cos(bt+\theta)\end{aligned}\]</span></p><blockquote><p>【例】求解下式的拉普拉斯反变换： <span class="math display">\[\frac{2s+4} {s^2+2s+2}\]</span> 【解】按照上题的办法用计算器求解极点，得极点： <span class="math display">\[-1+j,-1-j\]</span> 于是原式可以写为： <span class="math display">\[\begin{aligned}F(s)&amp;=\frac{2s+4} {[s-(-1+j)][s-(-1-j)]}\\&amp;=\frac{K_1} {s-(-1+j)}+\frac{K_2} {s-(-1-j)}\end{aligned}\]</span> 下面求<span class="math inline">\(K_1\)</span>.按<kbd>设置</kbd> <kbd>2</kbd>进入复数计算模式，按<kbd>-</kbd> <kbd>1</kbd> <kbd>+</kbd> <kbd>ENG</kbd> 输入<span class="math inline">\(-1+j\)</span>，按<kbd>STO</kbd> <kbd>(-)</kbd>存入变量A中。输入 <span class="math display">\[\frac{2A+4} {A-(-1-j)}\]</span> 按<kbd>=</kbd>,屏幕上显示计算结果为<span class="math inline">\(K_1=1-j\)</span>.</p><p>按<kbd>shift</kbd> <kbd>设置</kbd> <kbd>↓</kbd> <kbd>2</kbd> <kbd>2</kbd>将复数显示切换为模长-幅角形式，屏幕上显示：<span class="math inline">\(\sqrt{2}\angle -45\)</span> ,这里的单位是度。按<kbd>shift</kbd> <kbd>设置</kbd> <kbd>2</kbd> <kbd>2</kbd>把角度单位改为弧度，屏幕上显示<span class="math inline">\(\sqrt{2}\angle -\frac{1} {4}\pi\)</span>.</p><p>那么对应的原函数为 <span class="math display">\[f(t)=2\sqrt{2}e^{-t}\cos(t-\frac{\pi} {4})u(t)\]</span></p></blockquote><h3 id="多重根">多重根</h3><p><span class="math inline">\(k\)</span>重根对应的小分式如下： <span class="math display">\[G(s)=\frac{K_1} {(s-p)^k}+\frac{K_2} {(s-p)^{k-1} }+\cdots+\frac{K_k} {s-p}\]</span> 给两边同时乘以<span class="math inline">\((s-p)^k\)</span>，有： <span class="math display">\[(s-p)^kG(s)=K_1+K_2(s-p)+\cdots +K_k(s-p)^{k-1}\]</span> 于是我们知道： <span class="math display">\[K_m=\frac{1} {(m-1)!}\frac{d^{m-1} } {ds^{m-1} }[(s-p)^kG(s)]_{s=p}\]</span> 这项对应的原函数为： <span class="math display">\[e^{pt}\left[\frac{K_1} {(k-1)!}t^{k-1}+\frac{K_2} {(k-2)!}t^{k-2}+\cdots+K_k\right]\]</span></p><blockquote><p>【例】求解下式的拉普拉斯反变换： <span class="math display">\[\frac{s^2} {(s+2)(s+1)^2}\]</span> 【解】因为题目已经帮我们因式分解好了，于是我们直接拆开： <span class="math display">\[F(s)=\frac{K_0} {s+2}+\frac{K_1} {(s+1)^2}+\frac{K_2} {s+1}\]</span> <span class="math inline">\(K_0\)</span>很容易计算，为<span class="math inline">\(4\)</span>。</p><p>对等式两端同时乘以<span class="math inline">\((s+1)^2\)</span>，有： <span class="math display">\[\frac{s^2} {s+2}=K_0\frac{(s+1)^2} {s+2}+K_1+(s+1)K_2\]</span> 将<span class="math inline">\(s=-1\)</span>代入得<span class="math inline">\(K_1=1\)</span></p><p>在计算器中输入： <span class="math display">\[\left. \frac{ {\mathbf d} } { {\mathbf d}x}\left(\frac{x^2} {x+2}\right) \right |_{x=-1}\]</span> 按等号，得<span class="math inline">\(K_2=-3\)</span>.</p><p>于是原函数为 <span class="math display">\[f(t)=(4e^{-2t}-3e^{-t}+te^{-t})u(t)\]</span></p></blockquote><h2 id="运算电路">运算电路</h2><p>运算电路说的就是在RLC电路中，通过把元件的时域<span class="math inline">\(u-i\)</span>微分方程通过拉普拉斯变换转换成代数方程然后求解的过程，其操作过程和相量法是相似的。具体来说：</p><h3 id="电阻">电阻</h3><p>形式不变，仍为<span class="math inline">\(R\)</span></p><h3 id="电容">电容</h3><p>如果电容的值为<span class="math inline">\(C\)</span>，初值条件为<span class="math inline">\(u_c(0_-)\)</span>，那么在运算电路中，电容模型变为<span class="math inline">\(\frac{1} {sC}\)</span>，并且串联一个和初值电压方向相同，值为<span class="math inline">\(\frac{1} {s}u_c(0_-)\)</span>的电压源。</p><h3 id="电感">电感</h3><p>如果电感的值为<span class="math inline">\(L\)</span>，初值条件为<span class="math inline">\(i_L(0_-)\)</span>，那么在运算电路中，电感模型变为<span class="math inline">\(Ls\)</span>，并且并联一个和初值电流方向相同的，值为<span class="math inline">\(\frac{1} {s}i_L(0_-)\)</span>的电流源。</p><h2 id="系统函数与响应的分解">系统函数与响应的分解</h2><p>在拉普拉斯变换下，系统函数有两种定义。</p><ol type="1"><li><p>基于单位冲激响应的定义： <span class="math display">\[H(s)={\mathscr L}[h(t)]=\int_{0-}^{\infty}h(t)e^{-st} {\mathbf d}t\]</span></p></li><li><p>基于一般激励的零状态响应的拉普拉斯变换<span class="math inline">\(R(s)\)</span>和激励的拉普拉斯变换<span class="math inline">\(E(s)\)</span>的比值的定义： <span class="math display">\[H(s)=\frac{R(s)} {E(s)}\]</span></p></li></ol><p>在之前的学习中，我们学过响应可以分为自由响应、强迫响应、暂态响应、稳态响应等部分，我们可以以拉普拉斯变换的视角来重新看待这些概念。</p><p>假设系统函数和输入激励只含一阶零极点，即： <span class="math display">\[H(s)=\frac{N(s)} {D(s)}=k_h\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\]</span></p><p><span class="math display">\[E(s)=k_e\frac{\prod_{l=1}^u(s-z_l)} {\prod _{k=1}^v(s-p_k)}\]</span></p><p>于是系统响应的拉普拉斯变换<span class="math inline">\(R=E\times H\)</span>为： <span class="math display">\[R(s)=k_hk_e\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\frac{\prod_{l=1}^u(s-z_l)} {\prod _{k=1}^v(s-p_k)}\]</span> 拉普拉斯逆变换，得系统的响应<span class="math inline">\(r(t)={\mathscr L}^{-1}[R(s)]\)</span>为： <span class="math display">\[r(t)=\left(\sum_{i=1}^nA_ie^{p_it}+\sum_{k=1}^vA_ke^{p_kt}\right)u(t)\]</span></p><h3 id="自由响应和强迫响应">自由响应和强迫响应</h3><p>我们可以看到，左边的求和式<span class="math inline">\(\sum_{i=1}^nA_ie^{p_it}\)</span>来自于<span class="math inline">\(H(s)\)</span>，是系统本身（的极点）决定的，对应于微分方程的齐次解。我们知道 <strong>齐次解和激励无关，所以称之为自由响应。</strong> 而<span class="math inline">\(\sum_{k=1}^vA_ke^{p_kt}\)</span>项来自于<span class="math inline">\(R(s)\)</span>，也就是微分方程的特解。我们知道 <strong>特解取决于外加激励，所以称之为强迫响应。</strong></p><h3 id="暂态响应和稳态响应">暂态响应和稳态响应</h3><p>我们将<span class="math inline">\(R(s)\)</span>的极点分成位于“左半平面”和“虚轴以及右半平面”的两类。位于左半平面的极点带来的响应会乘以一个<span class="math inline">\(e^{-at}\)</span>的系数（其中<span class="math inline">\(a&gt;0\)</span>)，因此如果时间比较长，便会近似等于<span class="math inline">\(0\)</span>。 <strong>这种左半平面的极点对应的响应是暂时的，因此称作暂态响应。</strong> 相反，位于虚轴或右半平面的极点带来的响应往往要不是<span class="math inline">\(\cos\)</span>震荡形式，要不会乘以一个<span class="math inline">\(e^{at}\)</span>的系数（其中<span class="math inline">\(a&gt;0\)</span>),这种响应 <strong>不会随着时间推移而消失，所以称为稳态响应。</strong></p><h2 id="系统框图">系统框图</h2><p>在之前的推文中其实我介绍了一种绘制系统框图的技术。现在我们来介绍一种基于拉普拉斯变换的，更简单的技术。</p><p>对于微分方程系统（<span class="math inline">\(n&gt;m\)</span>） <span class="math display">\[C_0r^{(n)}(t)+C_1r^{(n-1)}(t)+\cdots+C_nr(t)=E_0e^{(m)}(t)+E_1e^{(m-1)}(t)+\cdots+E_me(t)\]</span> 有系统函数 <span class="math display">\[H(s)=\frac{\sum_{j=0}^mE_js^{m-j} } {\sum_{i=0}^nC_is^{n-i} }\]</span> 因为我们系统框图里面一般都用积分器，所以我们也把系统函数进行一个变形（上下同除以<span class="math inline">\(s^n\)</span>）也就是把微分方程变成积分方程（方程两边进行<span class="math inline">\(n\)</span>次积分）： <span class="math display">\[H(s)=\frac{\sum_{j=0}^mE_js^{-n+m-j} } {\sum_{i=0}^nC_is^{-i} }\]</span> 这样的系统可以拆分成两个系统的级联,设置中间变量<span class="math inline">\(W(s)\)</span>： <span class="math display">\[H_1(s)=\frac{W(s)} {E(s)}=\frac 1 {\sum_{i=0}^nC_is^{-i} }\\H_2(s)=\frac{R(s)} {W(s)}=\sum_{j=0}^mE_js^{-n+m-j}\]</span> 经过变形， 有： <span class="math display">\[C_0W(s)=E(s)-W(s)\sum_{i=1}^nC_is^{-i}\\R(s)=W(s)H_2(s)\]</span> 于是框图如下所示：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653882298205.png" /></p><h2 id="系统幅相频特性和波特图">系统幅相频特性和波特图</h2><p>系统幅相频特性就是系统的响应随着输入信号频率的变化而变化的性质，而我们常用波特图来进行描述。波特图是一种比较特殊的绘图方式，其纵轴为<span class="math inline">\(20\lg H/\text{dB}\)</span>，横轴为<span class="math inline">\(\omega\)</span>，且横轴是对数坐标。（由于纵轴的<span class="math inline">\(\text{dB}\)</span>已经隐含了对数坐标的事实，所以其实是双对数图）</p><p>一般来说，线性时不变系统的传递函数可以写作： <span class="math display">\[H(s)=H_0\frac{\prod_{j=1}^m (s-z_j)} {\prod _{i=1}^n (s-p_i)}\]</span> 其中<span class="math inline">\(\{z_1,z_2,\cdots,z_m\}\)</span>叫做系统的零点，<span class="math inline">\(\{p_1,p_2,\cdots,p_n\}\)</span>叫做系统的极点。如果一个系统稳定，那么其极点一定在左半平面，而且极点个数一定大于等于零点个数。</p><p>用<span class="math inline">\(j\omega\)</span>代替上面的<span class="math inline">\(s\)</span>，有： <span class="math display">\[H(j\omega)=H_0\frac{(j\omega-z_1)(j\omega-z_2)\cdots(j\omega-z_m)} {(j\omega-p_1)(j\omega-p_2)\cdots(j\omega-p_n)}\]</span> 取对数，因为对数可以把乘除式化为加减式，有幅频特性表达式： <span class="math display">\[\begin{aligned}20\lg H(\omega)&amp;=20\lg H_0\\&amp;+\left(20\lg \sqrt{\omega^2+z_1^2}+20\lg \sqrt{\omega^2+z_2^2}+\cdots+20\lg \sqrt{\omega^2+z_m^2}\right)\\&amp;-\left(20\lg \sqrt{\omega^2+p_1^2}+20\lg \sqrt{\omega^2+p_2^2}+\cdots+20\lg \sqrt{\omega^2+p_n^2}\right)\end{aligned}\]</span> 由于复数作积是相角相加，复数作商是相角相减，有相频表达式： <span class="math display">\[\varphi(\omega)=\tan^{-1}\left(-\frac\omega {z_1}\right )+\tan^{-1}\left(-\frac\omega {z_2}\right )+\cdots-\tan^{-1}\left(-\frac\omega {p_1}\right )-\cdots\]</span> 为表达方便，记： <span class="math display">\[\omega_z=-z,\omega_p=-p\]</span></p><h3 id="幅频波特图">幅频波特图</h3><h4 id="常数因子">常数因子</h4><p>即<span class="math inline">\(H&#39;(\omega)=K\)</span>项，有：</p><p><span class="math inline">\(20\lg H&#39;(\omega)=20\lg K\)</span>是常数</p><p><span class="math inline">\(\varphi(\omega)=0\)</span>恒为0</p><p>对应的图像如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653825965018.png" /></p><h4 id="jomega因子零零点因子"><span class="math inline">\(j\omega\)</span>因子（零零点因子）</h4><p>即<span class="math inline">\(H&#39;(\omega)=j\omega\)</span>，有：</p><p><span class="math inline">\(20\lg H&#39;(\omega)=20\lg \omega\)</span></p><p><span class="math inline">\(\varphi(\omega)=90\degree\)</span></p><p>对应的图像如下：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653825989648.png" /></p><h4 id="一般一阶零点因子">一般一阶零点因子</h4><p>即<span class="math inline">\(A(j\omega)=j\omega+\omega_z\)</span></p><p>可以变形为：<span class="math inline">\(A(j\omega)=\omega_z(1+\frac{j\omega} {\omega_z})\)</span></p><p>其中<span class="math inline">\(\omega_z\)</span>可以划归进常数因子，我们只需考虑<span class="math inline">\(A&#39;(\omega)=(1+j\frac{\omega} {z_i})\)</span>.有：</p><p><span class="math inline">\(20\lg A&#39;(\omega)=20\lg \sqrt{1+(\frac\omega{\omega_z})^2}\)</span></p><p><span class="math inline">\(\varphi&#39;(\omega)=\tan^{-1}\left(\frac{\omega} {\omega_z}\right)\)</span></p><p>我们观察幅频特性，它并不是一个非常容易画的函数。但是我们感性认识一下，发现它应该近似于一个线性函数。我们取零点为<span class="math inline">\(-10^1\)</span>，即<span class="math inline">\(\omega_z=10^1\)</span>，用mathematica 12绘制图像：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-number">20</span><span class="hljs-operator">*</span><span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">Sqrt</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">(</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-variable">x</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><span class="hljs-punctuation">)</span><span class="hljs-operator">^</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <br>  <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">100000</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826010267.png" /></p><p>我们发现它近似于一个与<span class="math inline">\(x\)</span>轴交于<span class="math inline">\(1\)</span>点，增长速度为<span class="math inline">\(20\text{dB}/\)</span>十倍频的直线。</p><p>如法炮制，绘制相频曲线：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">ArcTan</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-operator">^</span><span class="hljs-variable">x</span><span class="hljs-punctuation">)</span><span class="hljs-operator">/</span><span class="hljs-number">10</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">x</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Log10</span><span class="hljs-punctuation">[</span><span class="hljs-number">100000</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826030142.png" /></p><p>以上两个图的横轴是<span class="math inline">\(10^x \omega_{zi}\)</span>上面的那个指数，所以你看着是<span class="math inline">\(0\)</span>的地方，其实对应的是<span class="math inline">\(1\omega_z\)</span></p><p>于是，我们可以得到近似画法：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826050805.png" /></p><h4 id="极点因子">极点因子</h4><p>即： <span class="math display">\[A(\omega)=\frac{1} {j\omega+\omega_p}\]</span></p><p>可以变形为： <span class="math display">\[A(j\omega)=\frac{1} {w_p(j\frac{\omega} {\omega_p}+1)}\]</span> 同理，<span class="math inline">\(\omega_p^{-1}\)</span>也可以划归为常数因子，则： <span class="math display">\[A&#39;(\omega)=\frac 1 {j\frac \omega {\omega_p}+1}\]</span> 有：</p><p><span class="math inline">\(20\lg A&#39;(\omega)=-20\lg \sqrt{1+(\frac{\omega} {\omega_p})^2}\)</span></p><p><span class="math inline">\(\varphi&#39;(\omega)=-\tan^{-1}(\frac{\omega} {\omega_p})\)</span></p><p>这个其实就是前面一阶零点的相反数，也就不需要再拿软件画图看性质了。这里的<span class="math inline">\(\omega_p=-p_i\)</span>.简化图如下： <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1653826066834.png" /></p><h4 id="作图的一般流程">作图的一般流程</h4><ol type="1"><li><p>首先求出各零、极点，将网络函数写成 <span class="math display">\[H(j\omega)=H_0\frac{(j\omega-z_1)(j\omega-z_2)\cdots(j\omega-z_m)} {(j\omega-p_1)(j\omega-p_2)\cdots(j\omega-p_n)}\]</span> 的形式。</p></li><li><p>提取各零、极点因子的常数项，把零点和极点转换成<span class="math inline">\(\omega_z,\omega_p\)</span>,把它们都变成<span class="math inline">\((1+j\frac{\omega} {\omega_z})\)</span>、<span class="math inline">\(\frac{1} {1+j\frac{\omega} {\omega_p} }\)</span>的形式。这时，有： <span class="math display">\[H(j\omega)=H(0)\frac{(1+j\frac{\omega} {\omega_{z1} })(1+j\frac{\omega} {\omega_{z2} })\cdots(1+j\frac{\omega} {\omega_{zm} })} {(1+j\frac{\omega} {\omega_{p1} })(1+j\frac{\omega} {\omega_{p2} })\cdots(1+j\frac{\omega} {\omega_{pn} })}\]</span> 其中： <span class="math display">\[H(0)=H_0\frac{\prod _{i=1}^m \omega_{zi} } {\prod_{i=1}^n \omega_{p_i} }\]</span></p></li><li><p>根据叠加原理，结合上面各个因子的图像画出波特图。</p></li></ol><h2 id="系统稳定性的判断">系统稳定性的判断</h2><p>在<strong>6.2 暂态响应和稳态响应</strong>中，我们讨论过系统零极点的位置对系统的响应的影响。即：<span class="math inline">\(H(s)\)</span>的极点如果全部位于左半平面，则系统稳定。当虚轴存在一阶零点时，称为边界稳定或者震荡稳定；当右半平面有极点，或者虚轴上有高阶极点时，称系统不稳定。</p><ol type="1"><li><p>首先基于<span class="math inline">\(H(s)=N/D\)</span>的阶次进行分析。其中<span class="math inline">\(N\)</span>是<span class="math inline">\(m\)</span>阶多项式，<span class="math inline">\(D\)</span>是<span class="math inline">\(n\)</span>阶多项式。</p><p>如果<span class="math inline">\(m&gt;n\)</span>，系统一定存在一个无穷远点处的极点。基于这个事实，有以下系统稳定的必要条件：</p><ol type="1"><li><span class="math inline">\(m\leq n\)</span>是系统稳定的必要条件</li><li><span class="math inline">\(m&gt;n+1\)</span>时，系统一定不稳定</li></ol><p>因此，我们在前面几乎只讨论<span class="math inline">\(m\leq n\)</span>的系统。</p></li><li><p>基于分母多项式的根的分布判别</p><ol type="1"><li><p>必要条件</p><ol type="1"><li><span class="math inline">\(D(s)\)</span>的所有系数都同号</li><li><span class="math inline">\(D(s)\)</span>不缺项，或者缺全部的奇次或偶次项</li></ol><p>上面两个条件是必要条件，只要任一条件不被满足，系统就不是稳定的。但是即使全部满足，系统也不一定稳定。例如： <span class="math display">\[D(s)=2s^3+s^2+3s+9\]</span></p></li><li><p>劳斯判据</p><p>劳斯判据就是列劳斯表，然后看第一列是不是全同号。劳斯表是这样列的：</p><p>前两行，第一行从前往后是<span class="math inline">\(a_n,a_{n-2},a_{n-4},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>；第二行，是<span class="math inline">\(a_{n-1},a_{n-3},\cdots\)</span>，直到下标小于<span class="math inline">\(0\)</span>。设劳斯表第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素是<span class="math inline">\(m_{ij}\)</span>，在第三行之后，有： <span class="math display">\[m_{ij}=-\frac{1} {m_{i-1,i} }\begin{vmatrix}m_{i-2,1} &amp; m_{i-2,j+1}\\m_{i-1,1} &amp; m_{i-1,j+1}\\\end{vmatrix}\]</span> 如果出现<span class="math inline">\(0\)</span>，那就把它替换成一个<span class="math inline">\(\varepsilon&gt;0\)</span>极小量，然后继续算。 我写了个代码来进行这个过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 100+10</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">hls</span><span class="hljs-params">(<span class="hljs-type">double</span> aa, <span class="hljs-type">double</span> ab, <span class="hljs-type">double</span> ba, <span class="hljs-type">double</span> bb)</span> </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  aa ab</span><br><span class="hljs-comment">  ba bb</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> aa * bb - ab * ba;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0.0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">-1.0</span>;<br>&#125;<br><br><span class="hljs-type">double</span> epsilon = <span class="hljs-number">0.01</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入多项式的次数：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-type">double</span> a[MAXN], lis[MAXN][MAXN];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从低到高输入系数：&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;a[i]);<br>  <span class="hljs-type">int</span> lincnt;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; (n - (<span class="hljs-number">2</span> * (j - <span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span>); ++j) &#123;<br>              lis[i][j] = a[n - (<span class="hljs-number">2</span> * (j - <span class="hljs-number">1</span>))];<br>              lincnt = j;<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>              <span class="hljs-keyword">if</span> (n - (<span class="hljs-number">2</span> * j - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) lis[i][j] = a[n - (<span class="hljs-number">2</span> * j - <span class="hljs-number">1</span>)];<br>              <span class="hljs-keyword">else</span> lis[i][j] = <span class="hljs-number">0</span>;<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>              lis[i][j] = <span class="hljs-built_in">hls</span>(lis[i - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], lis[i - <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>], lis[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], lis[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]) / (-lis[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(lis[i][j]) &lt; eps) &#123;<br>                  <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>                      lis[i][j] = epsilon;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  flag = <span class="hljs-number">0</span>;<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 行全为0，系统不稳定，判定结束。\n&quot;</span>, i);<br>              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>          &#125;<br><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\&quot;%d\&quot;&quot;</span>, i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lincnt; ++j) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%+8.2f&quot;</span>, lis[i][j]);<br>      &#125;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> f = <span class="hljs-built_in">sgn</span>(lis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sgn</span>(lis[i][<span class="hljs-number">1</span>]) != f) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第 %d 行出现异号，不稳定.\n&quot;</span>, i);<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;稳定。\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，对于<span class="math inline">\(s^4+2s^3+8s^2+3s+4\)</span>，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&quot;1&quot;   <span class="hljs-string">+1</span>.00   <span class="hljs-string">+8</span>.00   <span class="hljs-string">+4</span>.00<br>&quot;2&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+3</span>.00   <span class="hljs-string">+0</span>.00<br>&quot;3&quot;   <span class="hljs-string">+6</span>.50   <span class="hljs-string">+4</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;4&quot;   <span class="hljs-string">+1</span>.77   <span class="hljs-string">+0</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;5&quot;   <span class="hljs-string">+4</span>.00   <span class="hljs-string">-0</span>.00   <span class="hljs-string">-0</span>.00<br>稳定。<br></code></pre></td></tr></table></figure><p>对于<span class="math inline">\(2s^4+2s^3+4s^2+4s+5\)</span>，输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&quot;1&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+4</span>.00   <span class="hljs-string">+5</span>.00<br>&quot;2&quot;   <span class="hljs-string">+2</span>.00   <span class="hljs-string">+4</span>.00   <span class="hljs-string">+0</span>.00<br>&quot;3&quot;   <span class="hljs-string">+0</span>.01   <span class="hljs-string">+5</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;4&quot; <span class="hljs-string">-996</span>.00   <span class="hljs-string">+0</span>.00   <span class="hljs-string">-0</span>.00<br>&quot;5&quot;   <span class="hljs-string">+5</span>.00   <span class="hljs-string">-0</span>.00   <span class="hljs-string">+0</span>.00<br>第 4 行出现异号，不稳定.<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数定义整理：第一弹</title>
    <link href="/2022/05/20/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <url>/2022/05/20/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<p>抽象代数课程概念繁杂，而且很多概念都使用了非常非常基础的字眼（例如“群”group，不觉得这是一个在日常生活中很基础的字吗？）因此，如果对基础概念不了如指掌，做题的时候很可能连题目也看不懂。本文整理一下抽象代数里面的概念，附带很有限的批注和定理，以供速查使用。</p><span id="more"></span><h2 id="基本概念">基本概念</h2><p><strong>定义 1(代数运算)</strong> . 一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span>的映射叫做一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span> 的代数运算。其中<span class="math inline">\(A^n\)</span>到<span class="math inline">\(A\)</span>的代数运算叫做<span class="math inline">\(A\)</span>上的<span class="math inline">\(n\)</span>元 运算。</p><p>例：定义<span class="math inline">\(A=\mathbb{Z},B=\{x|x\in \mathbb{Z}\ \&amp;\ x\neq 0\},D=\mathbb{Q}\)</span>,则除法： <span class="math display">\[(a,b)\to\frac ab = a/b\]</span> 是一个<span class="math inline">\(A\times B\)</span>到<span class="math inline">\(D\)</span>的代数运算。但是除法并不是<span class="math inline">\(\mathbb{Q}\)</span>上的二元运算。</p><p><strong>定义 2 (结合律)</strong>. 我们说一个<span class="math inline">\(A\)</span>上的代数运算<span class="math inline">\(\circ\)</span>适合结合律， 假如对于<span class="math inline">\(A\)</span>中的任意三个元<span class="math inline">\(a,b,c\)</span>，都有 <span class="math display">\[(a\circ b)\circ c=a\circ (b\circ c)\]</span> 其中<span class="math inline">\(a,b,c\)</span>不一定不相同。</p><p><strong>定义 3 (连算)</strong>. 假如对于<span class="math inline">\(A\)</span>的不少于<span class="math inline">\(2\)</span>个固定的元<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，对于下列的符号 <span class="math display">\[a_1\circ a_2 \circ \cdots a_n\]</span> 的任意一种加括号的方式<span class="math inline">\(\pi_i(a_1\circ a_2 \circ \cdots a_n)\)</span>都相等， 那么我们就把这些所有的<span class="math inline">\(\pi_i\)</span>用 <span class="math display">\[a_1\circ a_2 \circ \cdots a_n\]</span> 来表示， 叫做连算。</p><p>事实上，如果<span class="math inline">\(\circ\)</span>适合结合律，那么连算就存在。</p><p><strong>定义 4 (交换律)</strong>. 我们说一个<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(D\)</span>的代数运算<span class="math inline">\(\circ\)</span>适合交换律， 假如对于<span class="math inline">\(A\)</span>上的任意两个元<span class="math inline">\(a,b\)</span>，有： <span class="math display">\[a\circ b=b\circ a\]</span></p><p>事实上，如果<span class="math inline">\(\circ\)</span>同时适合交换律和结合律，那么连算式中 的元顺序就可以任意交换。</p><p><strong>定义 5 (分配律)</strong>. 对于<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span></p><p><span class="math inline">\(\bigotimes\)</span>是一个<span class="math inline">\(B\times A\)</span>到<span class="math inline">\(A\)</span>的代数运算。</p><p><span class="math inline">\(\bigoplus\)</span>是一个<span class="math inline">\(A\)</span>的代数运算。</p><p>假如对于<span class="math inline">\(B\)</span>的任意<span class="math inline">\(b\)</span>，<span class="math inline">\(A\)</span>的任意<span class="math inline">\(a_1,a_2\)</span>来说：</p><ol type="1"><li><p>有左分配律：假如 <span class="math display">\[b\bigotimes(a_1\bigoplus a_2)=(b\bigotimes a_1)\bigoplus(b\bigotimes a_2)\]</span></p></li><li><p>有右分配律：假如 <span class="math display">\[(a_1\bigoplus a_2)\bigotimes b=(a_1 \bigotimes b)\bigoplus(a_2 \bigotimes b )\]</span></p></li></ol><p><strong>定义 6 (满射)</strong>. 若是在一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>下，<span class="math inline">\(\bar{A}\)</span>的 每一个元都至少是<span class="math inline">\(A\)</span>中某一个元的象，那么<span class="math inline">\(\phi\)</span>叫做一个<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的 满射。</p><p>例如，<span class="math inline">\(f(x)=\sin(x)\)</span>就不是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的满射，因为不存在<span class="math inline">\(x\in \mathbb{R},f(x)=2\)</span> 但是，<span class="math inline">\(f(x)=\ln(x)\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的满射。</p><p><strong>定义 7 (单射)</strong>. 一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>，假如 <span class="math display">\[a\neq b\to \bar{a}\neq \bar{b}\]</span> 那么<span class="math inline">\(\phi\)</span>是一个单射。</p><p>例如，<span class="math inline">\(f(x)=x^2\)</span>就不是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的单射，因为<span class="math inline">\(1\neq -1\)</span>但是<span class="math inline">\(f(1)=f(-1)\)</span>. 但是，<span class="math inline">\(f(x)=e^x\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的单射。</p><p><strong>定义 8(一一映射)</strong> . 如果集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>既是满射又是单射，那么它就是一一映射。 一一映射的逆是一个<span class="math inline">\(\bar{A}\to A\)</span>的一一映射，用<span class="math inline">\(\phi^{-1}\)</span>表示。</p><p>例如，<span class="math inline">\(f(x)=x^3\)</span>就是一个<span class="math inline">\({\mathbb R}\to {\mathbb R}\)</span>的一一映射。</p><p><strong>定义 9 (变换)</strong>. 一个<span class="math inline">\(A\to A\)</span>的映射叫做变换。</p><p><strong>定义 10 (同态映射)</strong>. 一个集合<span class="math inline">\(A\)</span>到<span class="math inline">\(\bar{A}\)</span>的映射<span class="math inline">\(\phi\)</span>叫做对于代数运算 <span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>的同态映射，假如在<span class="math inline">\(\phi\)</span>之下， 对于<span class="math inline">\(\forall a,b \in A\)</span>，只要 <span class="math display">\[a\to \bar{a},b\to \bar{b}\]</span> 就有。 <span class="math display">\[a\circ b\to \bar{a}\bar{\circ}\bar{b}\]</span> 如果<span class="math inline">\(\phi\)</span>还是个满射，那么就叫做同态满射。</p><p><strong>定义 11 (同构映射)</strong>. 如果一个同态满射还是一一映射，那么它就是同构映射。 如果<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同构，记作： <span class="math display">\[A\cong \bar{A}\]</span></p><p>事实上，如果对于<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>来说，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同构， 那么我们可以说，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>这两个集合对于这两个运算来说除了名字 以外没有区别。</p><p><strong>定义 12 (自同构)</strong>. 对于<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\circ\)</span>来说的一个<span class="math inline">\(A\to A\)</span>的同构映射称为一个对于<span class="math inline">\(\circ\)</span>来说的<span class="math inline">\(A\)</span>的自同构。</p><p><strong>定义 13 (关系)</strong>. 一个<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(\{T,F\}\)</span>的映射<span class="math inline">\(R\)</span>称作<span class="math inline">\(A\)</span>的元 之间的一个关系。如果<span class="math inline">\(R(a,b)=T\)</span>，那么称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>符合 这个关系，记作：<span class="math inline">\(aRb\)</span></p><p><strong>定义 14 (等价关系)</strong>. 如果关系<span class="math inline">\(\sim\)</span>满足以下三点：</p><ol type="1"><li><p><span class="math inline">\(\forall a\in A,a\sim a\)</span></p></li><li><p><span class="math inline">\(\forall a,b\in A,a\sim b\to b\sim a\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in A,a\sim b\wedge b\sim c\to a\sim c\)</span></p></li></ol><p>那么称这个关系为等价关系。</p><p>常见的等价关系有：等于、同余、矩阵相似、矩阵合同等。</p><p><strong>定义 15(分类)</strong> . 如果把集合<span class="math inline">\(A\)</span>分成若干个称作类的子集，使得A的每个元属于且仅属于一个 类，那么这些类的全体叫做集合<span class="math inline">\(A\)</span>的一个分类。</p><p>集合的一个分类决定了集合的元之间的一个等价关系。 集合的元之间的一个等价关系决定了集合的一个分类。</p><p><strong>定义 16 (代表和代表团)</strong>. 假如有一个集合的一个分类，那么一个类里面的任意一个元 叫做这个类的一个代表，由每个类的一个代表组成的集合叫做这个集合 的代表团。</p><h2 id="群论">群论</h2><p><strong>定义 17 (群的第一定义)</strong>. 一个不空集合<span class="math inline">\(G\)</span>和一个叫做乘法的代数运算组成的结构叫做一个群，如果：</p><ol type="1"><li><p>*<span class="math inline">\(\forall a,b\in G,ab\in G\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in G,a(bc)=(ab)c\)</span></p></li><li><p><span class="math inline">\(\forall a,b \in G,\exists x,y\in G\ {\mathbf s.t.} ax=b\wedge ya=b\)</span></p></li></ol><p><strong>定义 18 (群的第二定义)</strong>. 一个不空集合<span class="math inline">\(G\)</span>和一个叫做乘法的代数运算组成的结构叫做一个群，如果：</p><ol type="1"><li><p><span class="math inline">\(\forall a,b\in G,ab\in G\)</span></p></li><li><p><span class="math inline">\(\forall a,b,c\in G,a(bc)=(ab)c\)</span></p></li><li><p><span class="math inline">\(\exists e\in G ,\forall a\in G,ea=a\)</span>,这个<span class="math inline">\(e\)</span>叫做左单位元</p></li><li><p><span class="math inline">\(\forall a\in G, \exists a^{-1}\in G,a^{-1}a=e\)</span></p></li></ol><p><strong>定义 19 (群的阶)</strong>. 一个元素有限的群叫做有限群，一个元素无限的群叫做无限群。 有限群元的个数叫做群的阶。</p><p><strong>定义 20 (交换群)</strong>. 如果<span class="math inline">\(\forall a,b\in G,ab=ba\)</span>，那么群<span class="math inline">\((G,\cdot)\)</span>称为交换群，也叫阿贝尔群。</p><p><strong>定义 21 (单位元)</strong>. 一个群<span class="math inline">\(G\)</span>的<strong>唯一</strong>能使 <span class="math display">\[ea=ae=e\]</span> 的元叫做群<span class="math inline">\(G\)</span>的单位元。</p><p><strong>定义 22 (逆元)</strong>. 对于群<span class="math inline">\(G\)</span>的每一个元<span class="math inline">\(a\)</span>，<span class="math inline">\(G\)</span>中存在<strong>唯一</strong>的一个元<span class="math inline">\(a^{-1}\)</span>， 使得 <span class="math display">\[a^{-1}a=aa^{-1}=e\]</span> 这个<span class="math inline">\(a^{-1}\)</span>叫做群<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的逆元。</p><p><strong>定义 23 (群中元素的阶）</strong>. 对于群<span class="math inline">\(G\)</span>中的一个元素<span class="math inline">\(a\)</span>,能够使得 <span class="math display">\[a^m=e\]</span> 的最小的正整数<span class="math inline">\(m\)</span>称作<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的阶。如果 不存在这样的<span class="math inline">\(m\)</span>，那么称元素<span class="math inline">\(a\)</span>的阶为无穷大。</p><p>例如：</p><ol type="1"><li><p>对于群<span class="math inline">\((\mathbb{R}+,\times)\)</span>,<span class="math inline">\(1\)</span>的阶为<span class="math inline">\(1\)</span>，其余每个元素的阶为<span class="math inline">\(\infty\)</span>.</p></li><li><p>对于群<span class="math inline">\((\{x|x^3=1,x\in \mathbb{C}\},\times)\)</span>,<span class="math inline">\(1\)</span>的阶为<span class="math inline">\(1\)</span>，其余元素的阶为<span class="math inline">\(3\)</span>.</p></li></ol><p><strong>定理 1 (消去律)</strong>. 一个群的乘法适合消去律： <span class="math display">\[\begin{cases}            ax=ax&#39; \to x=x&#39;\\            ya=y&#39;a \to y=y&#39;\\        \end{cases}\]</span></p><p><strong>定义 24 (有限群的另一定义)</strong>. 一个乘法和一个有限集合构成一个群，假如"封闭性"、"结合律"和"消去律"能被满足。</p><p><strong>定义 25 (变换群)</strong>. 首先我们用一种特殊的记法来表示变换： <span class="math display">\[\tau : a\to a&#39;=a^\tau\]</span> 我们把一个集合的所有变换放到一个集合里： <span class="math display">\[S=\{\tau,\lambda,\mu,\cdots\}\]</span> 看这个集合中的两个元<span class="math inline">\(\tau,\lambda\)</span>： <span class="math display">\[t:a\to a^\tau,\lambda:a\to a^\lambda\]</span> 于是给了一个元<span class="math inline">\(a\)</span>，我们可以得出一个唯一的元<span class="math inline">\((a^\tau)^\lambda\)</span>. 我们规定变换的乘积： <span class="math display">\[\tau\lambda : a\to (a^\tau)^\lambda=a^{\tau\lambda}\]</span> 那么一个集合<span class="math inline">\(A\)</span>的若干个一一变换对于上述规定的乘法作成的群叫做<span class="math inline">\(A\)</span>的一个变换群。</p><p>事实上，任何一个群都和一个变换群同构，任意一个抽象的群都能在变换群中找到一个具体的例子。</p><p><strong>定义 26 (置换)</strong>. 一个有限集合的一个一一变换叫做一个置换。</p><p><strong>定义 27(对称群)</strong> . 一个包含<span class="math inline">\(n\)</span>个元的集合的全体置换作成的群叫做<span class="math inline">\(n\)</span>次对称群，记作：<span class="math inline">\(S_n\)</span>.</p><p><strong>定义 28 (<span class="math inline">\(k\)</span>-循环置换)</strong>. <span class="math inline">\(S_n\)</span>中的一个把<span class="math inline">\(a_{i_1}\)</span>变到<span class="math inline">\(a_{i_2}\)</span>,把<span class="math inline">\(a_{i_2}\)</span>变到<span class="math inline">\(a_{i_3}\)</span>,<span class="math inline">\(\cdots\)</span> ,把<span class="math inline">\(a_{i_k}\)</span>变到<span class="math inline">\(a_{i_1}\)</span>，而使其它元不变的置换，叫做<span class="math inline">\(k\)</span>-循环置换。这样的 循环置换可以用以下<span class="math inline">\(k\)</span>个符号同时表示： <span class="math display">\[(i_1i_2\cdots i_k),(i_2i_3\cdots i_ki_1),\cdots (i_ki_1\cdots i_{k-1})\]</span></p><p>事实上，每个<span class="math inline">\(n\)</span>元置换<span class="math inline">\(\pi\)</span>都能写成若干个没有重复数字的循环置换的乘积。 事实上，每个有限群都和一个置换群同构。</p><p><strong>定义 29 (循环群)</strong>. 如果一个群<span class="math inline">\(G\)</span>的每一个元都是其中某一个固定元<span class="math inline">\(a\)</span>的乘方，那么 我们把<span class="math inline">\(G\)</span>叫做循环群，并用符号<span class="math inline">\(G=(a)\)</span>来表示，其中<span class="math inline">\(a\)</span>叫做<span class="math inline">\(G\)</span>的生成元。</p><p>其实<span class="math inline">\(G\)</span>的构造完全由<span class="math inline">\(a\)</span>的阶数<span class="math inline">\(n\)</span>决定。如果有限，那么<span class="math inline">\(G\)</span>同构于整数加群，否则 同构于模<span class="math inline">\(n\)</span>剩余类加群。</p><p><strong>定义 30 (子群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子集<span class="math inline">\(H\)</span>叫做<span class="math inline">\(G\)</span>的一个子群，假如 <span class="math inline">\(H\)</span>对于<span class="math inline">\(G\)</span>的乘法来说也构成一个群。</p><p><strong>定义 31 (陪集)</strong>. 对于一个群<span class="math inline">\(G\)</span>和它的一个子群<span class="math inline">\(H\)</span>,我们规定一个关系<span class="math inline">\(\sim\)</span>: <span class="math display">\[a\sim b \leftrightarrow ab^{-1}\in H\]</span> 那么由上述等价关系<span class="math inline">\(\sim\)</span>所决定的类叫做子群<span class="math inline">\(H\)</span>的右陪集，记作： <span class="math inline">\(Ha\)</span>，它刚好包含所有能写成 <span class="math inline">\(ha (h\in H)\)</span> 的<span class="math inline">\(G\)</span>的元。</p><p>如果把等价关系的定义换成： <span class="math display">\[a\sim b \leftrightarrow b^{-1}a\in H\]</span> 包含元<span class="math inline">\(a\)</span>的陪集叫做左陪集，用<span class="math inline">\(aH\)</span>表示。</p><p><strong>定义 32 (指数)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(H\)</span>的右陪集或左陪集（事实上，这俩一定相等）的个数 叫做<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>里的指数。</p><p><strong>定义 33 (不变子群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(N\)</span>叫做<span class="math inline">\(G\)</span>的不变子群，有：<span class="math inline">\(\forall a\in G,Na=aN\)</span></p><p>一个群<span class="math inline">\(G\)</span>的一个子群<span class="math inline">\(N\)</span>是不变子群的充分必要条件是：<span class="math inline">\(\forall a\in G,n\in N \to ana^{-1}\in N\)</span></p><p><strong>定义 34 (中心)</strong>. 如果<span class="math inline">\(N\)</span>包含<span class="math inline">\(G\)</span>中所有有以下性质的元<span class="math inline">\(n\)</span>: <span class="math display">\[\forall a\in G,na=an\]</span> 那么<span class="math inline">\(N\)</span>是<span class="math inline">\(G\)</span>的一个不变子群。这个不变子群叫做中心。</p><p>简言之：中心和<span class="math inline">\(G\)</span>的每个元素可交换。</p><p><strong>定义 35 (商群)</strong>. 一个群<span class="math inline">\(G\)</span>的一个不变子群<span class="math inline">\(N\)</span>的陪集作成的集合<span class="math inline">\(S\)</span>对于集合乘法构成一个群， 这个群叫做商群，记作<span class="math inline">\(G/N\)</span>.这里的"乘法"，指的是： <span class="math inline">\((xN)(yN)=(xy)N\)</span></p><p>一个群<span class="math inline">\(G\)</span>和它的每一个商群同态。</p><p><strong>定义 36 (核)</strong>. 如果<span class="math inline">\(\phi\)</span>是群<span class="math inline">\(G\)</span>到<span class="math inline">\(\bar{G}\)</span>的同态满射，那么<span class="math inline">\(\bar{G}\)</span> 的单位元<span class="math inline">\(\bar{e}\)</span>在<span class="math inline">\(\phi\)</span>下的所有逆象称为同态满射<span class="math inline">\(\phi\)</span>的核。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于微分方程和系统框图的那些事</title>
    <link href="/2022/05/18/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/05/18/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>昨天做了做作业，发现有通过系统框图写微分方程、和通过微分方程画系统框图这两种题目。初看完全摸不着头脑，但是只要把握<span class="math inline">\(LTI\)</span>系统的性质就很简单了。</p><span id="more"></span><h2 id="怎么通过系统框图写微分方程">怎么通过系统框图写微分方程？</h2><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837378264.png" /></p><p>我们很容易想到，首先设一个中间变量<span class="math inline">\(x(t)\)</span>，这里我把<span class="math inline">\(x(t)\)</span>放在第二个积分器和<span class="math inline">\(\frac{1}{2}\)</span>倍乘器中间。那么两个积分器之间的信号就是<span class="math inline">\(x&#39;(t)\)</span>，第一个积分器前的信号就是<span class="math inline">\(x&#39;&#39;(t)\)</span>，根据两个累加器，我们可以列出方程： <span class="math display">\[\begin{cases}r(t)=-\frac{3}{2}x&#39;(t)+\frac{1}{2}x(t)\\e(t)+\frac{3}{8}x(t)-\frac{1}{4}x&#39;(t)=x&#39;&#39;(t)\end{cases}\]</span> 整理得： <span class="math display">\[\begin{cases}r(t)=-\frac{3}{2}x&#39;(t)+\frac{1}{2}x(t)\\e(t)=-\frac{3}{8}x(t)+\frac{1}{4}x&#39;(t)+x&#39;&#39;(t)\end{cases}\]</span> 那然后怎么消掉<span class="math inline">\(x(t)\)</span>呢？有人说，线性变换，加加减减就行了呀。没错，非常正确，但是我算不出来。我想了一想，发现了一种方法，可以立刻就把微分方程写出来：只需要把第<span class="math inline">\(2\)</span>个式子右边的<span class="math inline">\(&#39;x&#39;\)</span>统一换成<span class="math inline">\(&#39;r&#39;\)</span>，写在等号左边，然后把第<span class="math inline">\(1\)</span>个式子右边的<span class="math inline">\(&#39;x&#39;\)</span>统一换成<span class="math inline">\(&#39;e&#39;\)</span>，写在等号的右边，就大功告成啦！对这个题来说，就是： <span class="math display">\[r&#39;&#39;(t)+\frac{1}{4}r&#39;(t)-\frac{3}{8}r(t)=-\frac{3}{2}e&#39;(t)+\frac{1}{2}e(t)\]</span> 这么简单么？只替换两个字符就行了？为啥啊？其实，这利用了<span class="math inline">\(LTI\)</span>系统的性质。</p><p>我们把第二个式子也看作一个线性系统，输入<span class="math inline">\(e(t)\)</span>，输出<span class="math inline">\(x(t)\)</span>。那么如果我们把输入改为 <span class="math display">\[\frac{1}{2}e(t)-\frac{3}{2}e&#39;(t)\]</span> 此时这个小系统的输出是什么呢？显然，是 <span class="math display">\[\frac{1}{2}x(t)-\frac{3}{2}x&#39;(t)\]</span> 这是什么呢？结合方程组第一个式子，我们发现这就是<span class="math inline">\(r(t)\)</span>。</p><p>对于第二个式子所代表的,输入<span class="math inline">\(e\)</span>输出<span class="math inline">\(x\)</span>的系统 <span class="math display">\[e(t)=-\frac{3}{8}x(t)+\frac{1}{4}x&#39;(t)+x&#39;&#39;(t)\]</span> 现在我们输入了<span class="math inline">\(\frac{1}{2}e(t)-\frac{3}{2}e&#39;(t)\)</span>,输出了<span class="math inline">\(r(t)\)</span>，那么填进去，就有： <span class="math display">\[r&#39;&#39;(t)+\frac{1}{4}r&#39;(t)-\frac{3}{8}r(t)=-\frac{3}{2}e&#39;(t)+\frac{1}{2}e(t)\]</span> 完毕。</p><h2 id="怎么通过微分方程画系统框图">怎么通过微分方程画系统框图</h2><p>例如： <span class="math display">\[r&#39;&#39;(t)+5r&#39;(t)+6r(t)=9e&#39;(t)+5e(t)\]</span> 这个系统相对来说还是比较复杂的。我们遵循上一部分的思路，逆过来思考。</p><ol type="1"><li><p>设<span class="math inline">\(x(t)\)</span>是系统输入为<span class="math inline">\(e(t)\)</span>时的输出，即： <span class="math display">\[x&#39;&#39;(t)+5x&#39;(t)+6x(t)=e(t)\]</span></p></li><li><p>这时由于<span class="math inline">\(LTI\)</span>系统的线性时不变性质（把上面那个式子右边的<span class="math inline">\(e(t)\)</span>变成<span class="math inline">\(9e&#39;(t)+5e(t)\)</span>），有： <span class="math display">\[r(t)=9x&#39;(t)+5x(t)\]</span></p></li><li><p>把1.中的式子进行一个移项，变成： <span class="math display">\[x&#39;&#39;(t)=e(t)-5x&#39;(t)-6x(t)\]</span></p></li><li><p>现在可以开始画图了。因为是二阶系统，所以先画2个积分器，标上<span class="math inline">\(x(t)\)</span>,再画上加法器</p></li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837311836.png" /></p><ol start="5" type="1"><li>我们知道加法器是等号的来源，把上面两个等式画上去，就完成啦。</li></ol><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652837321749.png" /></p><p>好了，现在你已经是系统框图大师啦！</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种基于纯C语言的函数绘图解决方案</title>
    <link href="/2022/05/16/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BA%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/05/16/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BA%AFC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>本文尝试实现一种利用C语言绘制函数图像的方法。最终输出为PPM格式图片。 <span id="more"></span></p><h2 id="一ppm图片格式">一、PPM图片格式</h2><p>我们首先来看一下我们的问题：怎么用纯C语言写一个<code>plot()</code>函数。那么我们迎面而来遇到的第一个问题就是：我们平常使用的C语言，往往是在一个黑框框里面输入一堆数字，然后输出一堆数字，而现在却要展示一张图片，这怎么做呢？但是我们静下心来想一想，就会发现所谓的图片实际上也是文件，而文件就是可以用C语言的<code>freopen</code>读写的。但是我们平时读写的都是纯文本文件，现在却要写入一张图片文件。怎么做到呢？这时就需要一种非常简单的图片编码：PPM格式。</p><p>PPM格式是 Netpbm <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Netpbm#File_formats">[1]</span></a></sup>的一部分。这个项目使用和定义了几种图形格式。便携式像素映射格式（PPM）、便携式灰图格式（PGM） 和便携式位图格式（PBM） ，旨在便于在平台之间交换。</p><p>一个PPM文件由两部分组成，即文件头和数据流。文件头的第一部分是一个Magic Number，格式为<code>P%d</code>，表示了文件的类型，具体如下表所示：</p><table><thead><tr class="header"><th>类型</th><th>ASCII （普通）</th><th><strong>二进制（原始）</strong></th></tr></thead><tbody><tr class="odd"><td>便携式位图（PBM）</td><td>P1</td><td>P4</td></tr><tr class="even"><td>便携式灰度图（PGM）</td><td>P2</td><td>P5</td></tr><tr class="odd"><td>便携式像素映像（PPM）</td><td>P3</td><td>P6</td></tr></tbody></table><p>文件头的第二部分是两个数字，表示了图像的宽度和高度。</p><p>而PGM和PPM文件的文件头有第三部分，是一个数字，表示颜色（分量）的最大值。</p><p>数据流部分是以矩阵形式显示的像素点。接下来我们看几个例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">P1</span><br><span class="hljs-comment"># This is an example bitmap of the letter &quot;J&quot;</span><br><span class="hljs-attribute">6</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669222979.png" alt="123" /><figcaption aria-hidden="true">123</figcaption></figure><p>这是一个PBM（位图）格式的文件，其中0表示白色，1表示黑色。显示成图片的话是这个样子（放大了20倍）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">P2</span><br><span class="hljs-comment"># Shows the word &quot;FEEP&quot; (example from Netpbm man page on PGM)</span><br><span class="hljs-attribute">24</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">15</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">11</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">15</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个一个PGM（灰度图）的例子，我们可以看到第四行，这就是所谓“颜色（分量）的最大值”。它对应的图片是这个样子（当然也经过了放大）：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669278002.png" /></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">P3           <span class="hljs-comment"># &quot;P3&quot; means this is a RGB color image in ASCII</span><br>3<span class="hljs-number"> 2 </span>         <span class="hljs-comment"># &quot;3 2&quot; is the width and height of the image in pixels</span><br>255          <span class="hljs-comment"># &quot;255&quot; is the maximum value for each color</span><br><span class="hljs-comment"># The part above is the header</span><br><span class="hljs-comment"># The part below is the image data: RGB triplets</span><br>255  <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># red</span><br> <span class="hljs-number"> 0 </span>255  <span class="hljs-number"> 0 </span> <span class="hljs-comment"># green</span><br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span>255  <span class="hljs-comment"># blue</span><br>255<span class="hljs-number"> 255 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># yellow</span><br>255<span class="hljs-number"> 255 </span>255  <span class="hljs-comment"># white</span><br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> <span class="hljs-comment"># black</span><br></code></pre></td></tr></table></figure><p>这是一个PPM图片的例子，我们可以看到每个像素点使用了三个数字来指定颜色，也就是我们所说的RGB。</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669396133.png" /></p><p>到这里，你应该已经掌握了PPM格式图片怎么写了吧！</p><h2 id="二定义函数表">二、定义函数表</h2><p>为了方便绘图，首先我们定义PPM数据类型，由RGB三个颜色分量组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br></code></pre></td></tr></table></figure><p>这个结构体的构造函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span>;<br></code></pre></td></tr></table></figure><p>主要执行绘图功能的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span>;<br></code></pre></td></tr></table></figure><p>其中各参数的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>char *name</code></td><td>输出文件的文件名</td></tr><tr class="even"><td><code>PPMdata **matrix</code></td><td>PPM文件流矩阵，大小至少为height*width</td></tr><tr class="odd"><td><code>const double *x</code></td><td>采样点x坐标</td></tr><tr class="even"><td><code>double *y</code></td><td>采样点y坐标</td></tr><tr class="odd"><td><code>int width</code></td><td>整个图像的宽度 单位：像素</td></tr><tr class="even"><td><code>int height</code></td><td>整个图像的高度 单位：像素</td></tr><tr class="odd"><td><code>int arrayLen</code></td><td>采样点的数目</td></tr><tr class="even"><td><code>double centerX</code></td><td>图片中心点对应的直角坐标X</td></tr><tr class="odd"><td><code>double centerY</code></td><td>图片中心点对应的直角坐标Y</td></tr><tr class="even"><td><code>double rangeX</code></td><td>X直角坐标范围</td></tr><tr class="odd"><td><code>double rangeY</code></td><td>Y直角坐标范围</td></tr><tr class="even"><td><code>double gridX</code></td><td>X网格宽度（单位：直角坐标）</td></tr><tr class="odd"><td><code>double gridY</code></td><td>Y网格宽度（单位：直角坐标）</td></tr></tbody></table><p>将直角坐标量转化为像素量（矩阵下标量）的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span>;<br></code></pre></td></tr></table></figure><p>其中各参数的意义为：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>double num</code></td><td>待转换的直角坐标量x</td></tr><tr class="even"><td><code>double center</code></td><td>图片该方向中心点对应的直角坐标c</td></tr><tr class="odd"><td><code>double range</code></td><td>该方向直角坐标范围r</td></tr><tr class="even"><td><code>int picLen</code></td><td>图片该方向的像素大小p</td></tr></tbody></table><p>转换公式为： <span class="math display">\[p\left(\frac 12+\frac{x-c}{r}\right)\]</span> 在图像上绘制坐标点的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span><br></code></pre></td></tr></table></figure><p>各新参数的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>int x</code></td><td>要绘制的点的像素X坐标</td></tr><tr class="even"><td><code>int y</code></td><td>要绘制的点的像素Y坐标</td></tr><tr class="odd"><td><code>PPMdata color</code></td><td>颜色</td></tr><tr class="even"><td><code>int size</code></td><td>点的大小，最后绘制出来是一个<span class="math inline">\(2size+1\)</span>边长的正方形</td></tr></tbody></table><p>将<code>PPMdata</code>数据矩阵转换为<code>.ppm</code>图像文件的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName,PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br></code></pre></td></tr></table></figure><p>没有新的参数。</p><p>由于绘图时采用分段线性拟合算法，定义线性函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br></code></pre></td></tr></table></figure><p>这个定义的意思是：<span class="math inline">\(y=\text{linerFunc}(x_1,y_1,x_2,y_2,x)\)</span>表示一条经过<span class="math inline">\((x_1,y_2)\)</span>和<span class="math inline">\((x_2,y_2)\)</span>，以<span class="math inline">\(x\)</span>为自变量的直线。直线方程为： <span class="math display">\[y=(x-x_1)\frac{y_2-y_1}{x_2-x_1}+y_1\]</span></p><h2 id="三实现函数">三、实现函数</h2><p>这部分以<code>arrayToPPM()</code>函数的实现为主线，完整介绍各个函数的实现方法。</p><h3 id="第一步检测数据的合法性">第一步，检测数据的合法性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: X is not increasing.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: X out of range.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br>        <span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，为了方便，我们强制把像素大小设置为偶数。然后主要检查三个事：</p><ol type="1"><li><span class="math inline">\(x\)</span>坐标是否严格单调递增。若不是，返回错误并退出。</li><li><span class="math inline">\(x\)</span>坐标是否在范围内。若不是，返回错误并退出。</li><li><span class="math inline">\(y\)</span>坐标是否在范围内。若不是，强制将其设置在范围内。</li></ol><h3 id="第二步定义ppmdata颜色">第二步，定义PPMdata颜色。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">PPMdata background, axis, grid, line;<br>background = makePPMdata(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = makePPMdata(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = makePPMdata(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = makePPMdata(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br></code></pre></td></tr></table></figure><p>各变量的意义如下：</p><table><thead><tr class="header"><th>项目</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>background</code></td><td>背景颜色</td></tr><tr class="even"><td><code>axis</code></td><td>主坐标轴颜色</td></tr><tr class="odd"><td><code>grid</code></td><td>网格颜色</td></tr><tr class="even"><td><code>line</code></td><td>要画的函数的颜色</td></tr></tbody></table><p>这里就用配色软件找一个好看的颜色就行。</p><h3 id="第三步绘制背景板">第三步，绘制背景板</h3><ol type="1"><li><p>画背景</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>        matrix[i][j] = background;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>画网格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br>        drawPoint(matrix, width, height, numToMatPos(centerX + i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>        drawPoint(matrix, width, height, numToMatPos(centerX - i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//纵向网格</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>        drawPoint(matrix, width, height, j, numToMatPos(centerY + i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>        drawPoint(matrix, width, height, j, numToMatPos(centerY - i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//横向网格</span><br></code></pre></td></tr></table></figure></li><li><p>画主坐标轴</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br>    drawPoint(matrix, width, height, i, height / <span class="hljs-number">2</span>, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>    drawPoint(matrix, width, height, width / <span class="hljs-number">2</span>, i, axis, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的“主坐标轴”，恒定位于图像的正中心。</p></li></ol><p>这里涉及到了<code>drawPoint()</code>函数。它的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br>            <span class="hljs-type">int</span> u = x + i, v = y + j;<br>            <span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">else</span> matrix[v][u] = color;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要还是要检测是不是越界了，不然容易<code>RE</code>.还有一个需要注意的地方就是第6行，这里的x和y互换了。为什么要互换呢？我们想一想矩阵下标的顺序和坐标的顺序有什么区别就好了。</p><h3 id="第四步画函数">第四步，画函数</h3><p>我们经过了这么长的准备，终于要开始画函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> stepX = rangeX / width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> X = centerX - rangeX / <span class="hljs-number">2</span>; X &lt; centerX + rangeX / <span class="hljs-number">2</span>; X += stepX) &#123;<br>    <span class="hljs-type">int</span> linerIndex = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (X &lt; x[i]) &#123;<br>            linerIndex = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (linerIndex == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">double</span> u, v, Y;<br>        u = numToMatPos(X, centerX, rangeX, width);<br>        Y = linerFunc(x[linerIndex], y[linerIndex], x[linerIndex + <span class="hljs-number">1</span>], y[linerIndex + <span class="hljs-number">1</span>], X);<br>        v = numToMatPos(Y, centerY, rangeY, height);<br>        drawPoint(matrix, width, height, u, v, line, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然我们用的是分段线性拟合法，那么就要确认当前在哪个段里，也就是代码中的<code>linerIndex</code>变量。</p><p><code>X</code>就是枚举变量。如果当前比<code>x[]</code>数列中的最小值还小，那么不应该有图像，否则找到当前所在的段，然后画一条线段。</p><h3 id="第五步写文件">第五步，写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">matToPPM(name, matrix, width, height);<br></code></pre></td></tr></table></figure><p>这里<code>matToPPM</code>函数的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>    freopen(fileName, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    fclose(<span class="hljs-built_in">stdout</span>);<br>    freopen(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是重定向，输出，再重定向回来，没什么特别值得说明的。</p><h2 id="四试用一下">四、试用一下</h2><p>我们把上面那一堆函数和实现打包到一个<code>.h</code>文件里。然后我们写个代码调用一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> x[<span class="hljs-number">1001</span>], y[<span class="hljs-number">1001</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.1</span>) &#123;<br>        x[cnt] = i;<br>        y[cnt] = <span class="hljs-built_in">sin</span>(i*<span class="hljs-number">2.0</span>)/(i*<span class="hljs-number">2.0</span>);<br>        ++cnt;<br>    &#125;<br>    <span class="hljs-comment">//创建matrix 矩阵</span><br>    PPMdata **matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PPMdata *) * <span class="hljs-number">1080</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1080</span>; i++) <br>        matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1920</span>, <span class="hljs-keyword">sizeof</span>(PPMdata));<br>    <span class="hljs-type">char</span> c[]=<span class="hljs-string">&quot;out.ppm&quot;</span>;<br>    arrayToPPM(c, matrix, x, y, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3.14159</span>/<span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;complete.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码的功能是绘制 <span class="math display">\[y=\frac{\sin 2x}{2x}\]</span> 的图像。</p><p>编译运行，在目录下输出了一个<code>out.ppm</code>文件，打开：</p><p><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669362308.png" /></p><p>大功告成咯！</p><h2 id="五更多讨论">五、更多讨论</h2><p>这个代码存在以下问题：</p><ol type="1"><li>面对函数变化率特别高的情况下表现不理想，会有间断的情况，如下图所示：</li></ol><p><span class="math display">\[   y=\tan x\]</span> <img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/1652669353744.png" /></p><ol start="2" type="1"><li>需要人工指定的变量太多，日后我会开发一版能自动适应采样点，选择合适的坐标、范围的绘图函数。</li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://en.wikipedia.org/wiki/Netpbm#File_formats <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验2：信号的矩形脉冲抽样与恢复</title>
    <link href="/2022/05/10/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A2/"/>
    <url>/2022/05/10/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A2/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第二个实验，信号的矩形脉冲抽样与恢复</p><span id="more"></span><h2 id="一实验结果展示">一、实验结果展示</h2><h3 id="各频域图像">各频域图像</h3><ol type="1"><li><p><span class="math inline">\(F(\omega)\)</span>原始频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130549021.png" alt="image-20220604130549021" /><figcaption aria-hidden="true">image-20220604130549021</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130602889.png" alt="image-20220604130602889" /><figcaption aria-hidden="true">image-20220604130602889</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样频域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130625486.png" alt="image-20220604130625486" /><figcaption aria-hidden="true">image-20220604130625486</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130636810.png" alt="image-20220604130636810" /><figcaption aria-hidden="true">image-20220604130636810</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130648381.png" alt="image-20220604130648381" /><figcaption aria-hidden="true">image-20220604130648381</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130659596.png" alt="image-20220604130659596" /><figcaption aria-hidden="true">image-20220604130659596</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样滤波后频域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130713220.png" alt="image-20220604130713220" /><figcaption aria-hidden="true">image-20220604130713220</figcaption></figure></li></ol><h3 id="各时域图像">各时域图像</h3><ol type="1"><li><p><span class="math inline">\(F(\omega)\)</span>傅里叶反变换后时域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130724746.png" alt="image-20220604130724746" /><figcaption aria-hidden="true">image-20220604130724746</figcaption></figure></li><li><p><span class="math inline">\(0.2\text{Hz}\)</span>采样滤波后恢复的时域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130735531.png" alt="image-20220604130735531" /><figcaption aria-hidden="true">image-20220604130735531</figcaption></figure></li><li><p><span class="math inline">\(0.5\text{Hz}\)</span>采样滤波后恢复的时域图像：</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130746852.png" alt="image-20220604130746852" /><figcaption aria-hidden="true">image-20220604130746852</figcaption></figure></li><li><p><span class="math inline">\(1\text{Hz}\)</span>采样滤波后恢复的时域图像</p><figure><img src="https://raw.githubusercontent.com/SuzumiyaAkizuki/image/main/image-20220604130758457.png" alt="image-20220604130758457" /><figcaption aria-hidden="true">image-20220604130758457</figcaption></figure></li></ol><h2 id="二实验结果分析">二、实验结果分析</h2><p>由奈奎斯特抽样定理，一个带限信号<span class="math inline">\(f(t)\)</span>,如果其频谱存在在频域（角频率）区间<span class="math inline">\([-\omega_m,\omega_m]\)</span>，则可用抽样值唯一表示<span class="math inline">\(f(t)\)</span>,抽样值的间隔不能大于<span class="math inline">\(T_s=\frac{1}{2f_m}\)</span>,其中<span class="math inline">\(f_m=\frac{\omega_m}{2\pi}\)</span>.</p><p>在本实验中，<span class="math inline">\(\omega_m=\frac \pi2\)</span>，即采样的频率需要达到<span class="math inline">\(2\frac{\omega_m}{2\pi}=0.5\text{Hz}\)</span>。所以<span class="math inline">\(0.5\text{Hz}\)</span>和<span class="math inline">\(1\text{Hz}\)</span>采样后可以恢复，而<span class="math inline">\(0.2\text{Hz}\)</span>采样后就不能恢复出原来的波形。</p><h2 id="三实验代码">三、实验代码</h2><ol type="1"><li><p>实验用代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arrayToPPM.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxn 5005</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.1415926535</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">double</span> <span class="hljs-params">(*fun_p)</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">F</span><span class="hljs-params">(<span class="hljs-type">double</span> omega)</span> &#123;<br><span class="hljs-keyword">return</span> ((omega &gt;= <span class="hljs-number">-0.5</span> * PI &amp;&amp; omega &lt;= <span class="hljs-number">0.5</span> * PI) ? <span class="hljs-built_in">cos</span>(omega) : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fourierTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> w, fun_p f, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> step)</span> &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = left; t &lt;= right; t += step) &#123;<br>ans = ans + f(t) * <span class="hljs-built_in">cos</span>(w * t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">fourierInvTransform</span><span class="hljs-params">(<span class="hljs-type">double</span> t, fun_p f, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> step)</span> &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w = left; w &lt;= right; w += step) &#123;<br>ans = ans + f(w) * <span class="hljs-built_in">cos</span>(w * t) * step;<br>&#125;<br><span class="hljs-keyword">return</span> ans / (<span class="hljs-number">2.0</span> * PI);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">sample</span><span class="hljs-params">(<span class="hljs-type">double</span> t, <span class="hljs-type">double</span> fre, <span class="hljs-type">double</span> tau)</span> &#123; <span class="hljs-comment">//时域矩形抽样函数</span><br><span class="hljs-type">double</span> clc = <span class="hljs-number">1.0</span> / fre;<br>t = <span class="hljs-built_in">fabs</span>(t);<br><span class="hljs-type">double</span> res = <span class="hljs-built_in">fmod</span>(t, clc);<br><span class="hljs-keyword">if</span> (res &gt; (clc / <span class="hljs-number">2.0</span>)) res -= clc;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">fabs</span>(res) &lt;= (tau / <span class="hljs-number">2.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>);<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(<span class="hljs-type">double</span> w, <span class="hljs-type">double</span> fre, <span class="hljs-type">double</span> tau)</span> &#123;<br><span class="hljs-keyword">if</span> (w &gt;= -PI / <span class="hljs-number">2.0</span> &amp;&amp; w &lt;= PI / <span class="hljs-number">2.0</span>)<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1.0</span> / fre) / tau;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">double</span> t[maxn], ft[maxn];<br>PPMdata **matrix;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> w[maxn], Fw[maxn];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-0.5</span> * PI - <span class="hljs-number">0.5</span>; w0 &lt;= <span class="hljs-number">0.5</span> * PI + <span class="hljs-number">0.5</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>w[cnt] = w0;<br>Fw[cnt] = F(w0);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out1.ppm&quot;</span>, matrix, w, Fw, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> * PI, <span class="hljs-number">3</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 1 finished------\n&quot;</span>);<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t0 = <span class="hljs-number">-20.0</span>; t0 &lt;= <span class="hljs-number">20.0</span>; t0 += <span class="hljs-number">0.1</span>) &#123;<br>t[cnt] = t0;<br>ft[cnt] = fourierInvTransform(t0, F, <span class="hljs-number">-0.5</span> * PI - <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span> * PI + <span class="hljs-number">0.5</span>, <span class="hljs-number">0.001</span>);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out2.ppm&quot;</span>, matrix, t, ft, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 2 finished------\n&quot;</span>);<br><br><span class="hljs-type">double</span> Fw_2[maxn], Fw_5[maxn], Fw_10[maxn];<br><br><br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-20.0</span>; i &lt;= <span class="hljs-number">20.0</span>; i += <span class="hljs-number">0.1</span>) &#123; <span class="hljs-comment">//计算傅里叶积分</span><br>Fw_2[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>Fw_5[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>Fw_10[cnt] += <span class="hljs-built_in">cos</span>(w0 * i) * ft[j] * sample(i, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.01</span>) * <span class="hljs-number">0.01</span>;<br>++j;<br>&#125;<br>w[cnt] = w0;<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out3_1.ppm&quot;</span>, matrix, w, Fw_2, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out3_2.ppm&quot;</span>, matrix, w, Fw_5, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out3_3.ppm&quot;</span>, matrix, w, Fw_10, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0.1</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.02</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------task 3 finished------\n&quot;</span>);<br><br><span class="hljs-type">double</span> Fw2_fil[maxn], Fw5_fil[maxn], Fw10_fil[maxn];<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>Fw2_fil[cnt] = Fw_2[cnt] * filter(w0, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.01</span>);<br>Fw5_fil[cnt] = Fw_5[cnt] * filter(w0, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.01</span>);<br>Fw10_fil[cnt] = Fw_10[cnt] * filter(w0, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.01</span>);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out4_1.ppm&quot;</span>, matrix, w, Fw2_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4_2.ppm&quot;</span>, matrix, w, Fw5_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4_3.ppm&quot;</span>, matrix, w, Fw10_fil, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">4</span>, PI / <span class="hljs-number">4.0</span>, <span class="hljs-number">0.5</span>);<br><br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> ft_2[maxn], ft_5[maxn], ft_10[maxn];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t0 = <span class="hljs-number">-20.0</span>; t0 &lt;= <span class="hljs-number">20.0</span>; t0 += <span class="hljs-number">0.1</span>) &#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> w0 = <span class="hljs-number">-10.0</span>; w0 &lt;= <span class="hljs-number">10.0</span>; w0 += <span class="hljs-number">0.01</span>) &#123;<br>ft_2[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw2_fil[j] * <span class="hljs-number">0.01</span>;<br>ft_5[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw5_fil[j] * <span class="hljs-number">0.01</span>;<br>ft_10[cnt] += <span class="hljs-built_in">cos</span>(w0 * t0) * Fw10_fil[j] * <span class="hljs-number">0.01</span>;<br>++j;<br>&#125;<br>ft_2[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>ft_5[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>ft_10[cnt] /= (<span class="hljs-number">2.0</span> * PI);<br>++cnt;<br>&#125;<br>arrayToPPM(<span class="hljs-string">&quot;out4-4.ppm&quot;</span>, matrix, t, ft_2, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4-5.ppm&quot;</span>, matrix, t, ft_5, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br>arrayToPPM(<span class="hljs-string">&quot;out4-6.ppm&quot;</span>, matrix, t, ft_10, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, cnt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.03</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其中的<code>arratToPPM.h</code>是本人编写的绘图用代码库。文件内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 999999999</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> linerFunc(x1,y1,x2,y2,x) ((x-x1)*(y2-y1)/(x2-x1)+y1)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> r, g, b;<br>&#125; PPMdata;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span>;<br><br>PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">drawMatrix</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br><br><br><br>PPMdata <span class="hljs-title function_">makePPMdata</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> &#123;<br>PPMdata ans;<br>ans.r = r, ans.g = g, ans.b = b;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numToMatPos</span><span class="hljs-params">(<span class="hljs-type">double</span> num, <span class="hljs-type">double</span> center, <span class="hljs-type">double</span> range, <span class="hljs-type">double</span> picLen)</span> &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(picLen / <span class="hljs-number">2</span> + (num - center) / range * picLen);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">drawMatrix</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color)</span> &#123;<br><span class="hljs-keyword">if</span> (x &gt;= width || x &lt; <span class="hljs-number">0</span> || y &gt;= height || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> matrix[y][x] = color;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">drawPoint</span><span class="hljs-params">(PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, PPMdata color, <span class="hljs-type">int</span> size)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span> * size; i &lt;= size; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span> * size; j &lt;= size; ++j) &#123;<br><span class="hljs-type">int</span> u = x + i, v = y + j;<br><span class="hljs-keyword">if</span> (u &gt;= width || u &lt; <span class="hljs-number">0</span> || v &gt;= height || v &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> matrix[v][u] = color;<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">matToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName, PPMdata **matrix, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>freopen(fileName, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;P3\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, width, height);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;255\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, matrix[i][j].r, matrix[i][j].g, matrix[i][j].b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>fclose(<span class="hljs-built_in">stdout</span>);<br>freopen(<span class="hljs-string">&quot;CON&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arrayToPPM</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">               PPMdata **matrix,</span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">double</span> *x,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> *y,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> arrayLen,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> centerY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> rangeY,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridX,</span><br><span class="hljs-params">               <span class="hljs-type">double</span> gridY)</span> &#123;<br><br>matrix = (PPMdata **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PPMdata *) * height);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>matrix[i] = (PPMdata *) <span class="hljs-built_in">calloc</span>(width, <span class="hljs-keyword">sizeof</span>(PPMdata));<br>&#125;<br><span class="hljs-keyword">if</span> (height % <span class="hljs-number">2</span>) ++height;<br><span class="hljs-keyword">if</span> (width % <span class="hljs-number">2</span>) ++width;<br><span class="hljs-type">double</span> *y_save=(<span class="hljs-type">double</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>)*(arrayLen+<span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrayLen;++i) y_save[i]=y[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br>y[i] = centerY - (y[i] - centerY);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (x[i] &lt; x[i - <span class="hljs-number">1</span>] &amp;&amp; i &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR:X is not increasing.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(x[i] &gt; centerX - (rangeX / <span class="hljs-number">2.0</span>) &amp;&amp; x[i] &lt; centerX + (rangeX / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR:X out of range.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!(y[i] &gt; centerY - (rangeY / <span class="hljs-number">2.0</span>) &amp;&amp; y[i] &lt; centerY + (rangeY / <span class="hljs-number">2.0</span>))) &#123;<br><span class="hljs-keyword">if</span> (y[i] &gt; centerY + (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY + (rangeY / <span class="hljs-number">2.0</span>);<br><span class="hljs-keyword">if</span> (y[i] &lt; centerY - (rangeY / <span class="hljs-number">2.0</span>)) y[i] = centerY - (rangeY / <span class="hljs-number">2.0</span>);<br>&#125;<br>&#125;<br>PPMdata background, axis, grid, line;<br>background = makePPMdata(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">251</span>);<br>axis = makePPMdata(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>);<br>grid = makePPMdata(<span class="hljs-number">189</span>, <span class="hljs-number">192</span>, <span class="hljs-number">186</span>);<br>line = makePPMdata(<span class="hljs-number">0</span>, <span class="hljs-number">92</span>, <span class="hljs-number">175</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>matrix[i][j] = background;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerX + i * gridX &lt;= centerX + rangeX / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<br>drawPoint(matrix, width, height, numToMatPos(centerX + i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>drawPoint(matrix, width, height, numToMatPos(centerX - i * gridX, centerX, rangeX, width), j, grid, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; centerY + i * gridY &lt;= centerY + rangeY / <span class="hljs-number">2</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; width; ++j) &#123;<br>drawPoint(matrix, width, height, j, numToMatPos(centerY + i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>drawPoint(matrix, width, height, j, numToMatPos(centerY - i * gridY, centerY, rangeY, height), grid, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; width; ++i) &#123;<br>drawPoint(matrix, width, height, i, height / <span class="hljs-number">2</span>, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; ++i) &#123;<br>drawPoint(matrix, width, height, width / <span class="hljs-number">2</span>, i, axis, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">double</span> stepX = rangeX / width;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> X = centerX - rangeX / <span class="hljs-number">2</span>; X &lt; centerX + rangeX / <span class="hljs-number">2</span>; X += stepX) &#123;<br><span class="hljs-type">int</span> linerIndex = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayLen; ++i) &#123;<br><span class="hljs-keyword">if</span> (X &lt; x[i]) &#123;<br>linerIndex = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (linerIndex == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">double</span> u, v, Y;<br>u = numToMatPos(X, centerX, rangeX, width);<br>Y = linerFunc(x[linerIndex], y[linerIndex], x[linerIndex + <span class="hljs-number">1</span>], y[linerIndex + <span class="hljs-number">1</span>], X);<br>v = numToMatPos(Y, centerY, rangeY, height);<br>drawPoint(matrix, width, height, u, v, line, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br>matToPPM(name, matrix, width, height);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s Draw finish!\n&quot;</span>,name);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height;++i)<br><span class="hljs-built_in">free</span>(matrix[i]);<br><span class="hljs-built_in">free</span>(matrix);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrayLen;++i) y[i]=y_save[i];<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验1：连续时间系统卷积的数值计算</title>
    <link href="/2022/04/06/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A1/"/>
    <url>/2022/04/06/%E4%BF%A1%E5%8F%B7%E6%8A%A5%E5%91%8A1/</url>
    
    <content type="html"><![CDATA[<p>这是信号与系统的实验报告。我信号与系统总共就扣了几分，也不知道是期末扣的，还是实验扣的。即使全是实验扣的，这实验也算做的挺好的。于是把报告发出来给大家参考。 这是第一个实验，连续时间系统卷积的数值计算</p><span id="more"></span><h2 id="一实验原理">一、实验原理</h2><p>卷积积分不仅可以通过直接积分或查表的方法来求解，还可以用积分的数值计算方法来求解。在线性系统的分析过程中，有时会遇到复杂的激励信号，或者有时只是一组测试数据或曲线，冲激响应也可能出现同样的情况。显然，此时直接计算积分或查表都有困难，而采用近似的数值计算方法可以解决这个问题，求得卷积积分。</p><p>两个信号<span class="math inline">\(f_1(t)\)</span>和<span class="math inline">\(f_2(t)\)</span>的卷积<span class="math inline">\(f_1(t)*f_2(t)\)</span>定义为： <span class="math display">\[f_1(t)*f_2(t)=\int_{-\infty}^{\infty}f_1(t-\tau)f_2(\tau){\bf d}\tau\]</span> 在计算卷积积分时，我们通常采取“翻转→平移→相乘→叠加”的方法。</p><ol type="1"><li><p>将信号取值离散化，即以 Ts 为周期，对信号取值，得到一系列宽度间隔为 Ts 的矩形脉冲原信号的离散取值点，用所得离散取值点矩形脉冲来表示原来的连续时间信号；</p></li><li><p>将进行卷积的两个信号序列之一反转，与另一信号相乘，并求积分，所得为 t=0 时的卷积积分的值。以 Ts 为单位左右移动反转的信号，与另一信号相乘求积分，求的 t&lt;0 和 t&gt;0 时卷积积分的值；</p></li><li><p>将所得卷积积分值与对应的 t 标在图上，连成一条光滑的曲线，即为所求卷积积分的曲线。</p></li></ol><p>上述过程，在形式上，就是用 <span class="math display">\[\sum_{\tau=\tau_0}^{\tau_1}f_1(t-\tau)f_2(\tau)\Delta\tau\]</span> 来逼近<span class="math inline">\(f_1(t)*f_2(t)\)</span>。其中<span class="math inline">\(\tau_0\)</span>是一个很小的值，<span class="math inline">\(\tau_1\)</span>是一个很大的值，<span class="math inline">\(\Delta \tau\)</span>是每次<span class="math inline">\(\tau\)</span>增加的值。</p><h2 id="二实验内容">二、实验内容</h2><p><span class="math display">\[f_1(t)=u(t+2)-u(t-2)\\f_2(t)=t[u(t)-u(t-2)]+(4-t)[u(t-2)-u(t-4)]\]</span></p><p>用数值方法计算<span class="math inline">\(f_1*f_2\)</span>，将结果用表格列出，并画出图像。</p><h2 id="三实验过程">三、实验过程</h2><h3 id="程序框图">1. 程序框图</h3><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091624871.png" alt="image-20220709162415460" /><figcaption aria-hidden="true">image-20220709162415460</figcaption></figure><h3 id="程序代码">2. 程序代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> dt = <span class="hljs-number">0.1</span>;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">u</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> (t &gt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> u(t + <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> t * <span class="hljs-number">1.0</span> * (u(t) - u(t - <span class="hljs-number">2</span>)) + (<span class="hljs-number">4</span> - t) * <span class="hljs-number">1.0</span> * (u(t - <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>freopen(<span class="hljs-string">&quot;ans.xls&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-2.5</span>; t &lt;= <span class="hljs-number">6.5</span>; t += dt) &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.01</span>) &#123;<br>ans += f1(t - i) * f2(i) * <span class="hljs-number">0.01</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f\t%.3f\n&quot;</span>, t, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果">3. 运行结果</h3><p><strong>部分表格：</strong></p><p>其中<span class="math inline">\(g(t)=f_1(t)*f_2(t)\)</span></p><table><thead><tr class="header"><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(g(t)\)</span></th><th><span class="math inline">\(t\)</span></th><th><span class="math inline">\(g(t)\)</span></th></tr></thead><tbody><tr class="odd"><td>-2</td><td>0</td><td>2.1</td><td>3.995</td></tr><tr class="even"><td>-1.9</td><td>0.005</td><td>2.2</td><td>3.981</td></tr><tr class="odd"><td>-1.8</td><td>0.019</td><td>2.3</td><td>3.957</td></tr><tr class="even"><td>-1.7</td><td>0.044</td><td>2.4</td><td>3.922</td></tr><tr class="odd"><td>-1.6</td><td>0.078</td><td>2.5</td><td>3.877</td></tr><tr class="even"><td>-1.5</td><td>0.123</td><td>2.6</td><td>3.823</td></tr><tr class="odd"><td>-1.4</td><td>0.177</td><td>2.7</td><td>3.758</td></tr><tr class="even"><td>-1.3</td><td>0.242</td><td>2.8</td><td>3.684</td></tr><tr class="odd"><td>-1.2</td><td>0.316</td><td>2.9</td><td>3.599</td></tr><tr class="even"><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td><td><span class="math inline">\(\cdots\)</span></td></tr></tbody></table><p>完整表格下载地址：</p><p><a href="https://docsdown.oss-cn-beijing.aliyuncs.com/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.xls">实验结果</a></p><p><strong>绘制图像：</strong></p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091624863.png" alt="image-20220405220304046" /><figcaption aria-hidden="true">image-20220405220304046</figcaption></figure><p>使用Excel 365软件绘制图像。</p><h2 id="四解析求解和误差分析">四、解析求解和误差分析</h2><p>使用符号计算语言<code>Mathematica</code>运行下列代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-variable">t</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-punctuation">(</span><span class="hljs-number">4</span> <span class="hljs-operator">-</span> <span class="hljs-variable">t</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">-</span> <br>      <span class="hljs-built_in">UnitStep</span><span class="hljs-punctuation">[</span><span class="hljs-variable">t</span> <span class="hljs-operator">-</span> <span class="hljs-number">4</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Convolve</span><span class="hljs-punctuation">[</span><span class="hljs-variable">f1</span><span class="hljs-operator">,</span> <span class="hljs-variable">f2</span><span class="hljs-operator">,</span> <span class="hljs-variable">t</span><span class="hljs-operator">,</span> <span class="hljs-variable">\[Tau]</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Plot</span><span class="hljs-punctuation">[</span><span class="hljs-variable">g</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">\[Tau]</span><span class="hljs-operator">,</span> <span class="hljs-operator">-</span><span class="hljs-number">4</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-built_in">PiecewiseExpand</span><span class="hljs-punctuation">[</span><span class="hljs-variable">g</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>可以得到卷积结果的解析式为： <span class="math display">\[g(\tau)=\begin{cases} \frac{1}{2} (\tau +2)^2 &amp; -2\leq \tau &lt;0 \\[1.5ex] \frac{1}{2} \left(-\tau ^2+4 \tau +4\right) &amp; 0\leq \tau &lt;4 \\[1.5ex] \frac{1}{2} \left(\tau ^2-12 \tau +36\right) &amp; 4\leq \tau &lt;6 \\[1.5ex] 0 &amp; \text{others}\end{cases}\]</span> 画出的图像为：</p><figure><img src="https://akizukipic.oss-cn-beijing.aliyuncs.com/img/202207091638947.png" alt="image-20220709163735914" /><figcaption aria-hidden="true">image-20220709163735914</figcaption></figure><p>将其代入程序，可计算得数值算法的均方误差 <span class="math display">\[\begin{aligned}\text{MSE}&amp;=\sum_{i=1}^n[ans_i-g(t_i)]^2\\&amp;=0.000029\end{aligned}\]</span> 计算代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> dt = <span class="hljs-number">0.1</span>;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">u</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> (t &gt; <span class="hljs-number">0.0</span>) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> u(t + <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span> &#123;<br><span class="hljs-keyword">return</span> t * <span class="hljs-number">1.0</span> * (u(t) - u(t - <span class="hljs-number">2</span>)) + (<span class="hljs-number">4</span> - t) * <span class="hljs-number">1.0</span> * (u(t - <span class="hljs-number">2</span>) - u(t - <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">double</span> t)</span>&#123;<br><span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-number">-2</span> &amp;&amp; t&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (t+<span class="hljs-number">2.0</span>)*(t+<span class="hljs-number">2.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;t &amp;&amp; t&lt;=<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> (-t*t+<span class="hljs-number">4.0</span>*t+<span class="hljs-number">4.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">4</span>&lt;t &amp;&amp; t&lt;=<span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> (t*t<span class="hljs-number">-12.0</span>*t+<span class="hljs-number">36.0</span>)*<span class="hljs-number">0.5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>freopen(<span class="hljs-string">&quot;ans.xls&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-type">double</span> e=<span class="hljs-number">0.0</span>;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> t = <span class="hljs-number">-2.5</span>; t &lt;= <span class="hljs-number">6.5</span>; t += dt) &#123;<br><span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> i = <span class="hljs-number">-10.0</span>; i &lt;= <span class="hljs-number">10.0</span>; i += <span class="hljs-number">0.01</span>) &#123;<br>ans += f1(t - i) * f2(i) * <span class="hljs-number">0.01</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f\t%.3f\n&quot;</span>, t, ans);<br>e+=(ans-g(t))*(ans-g(t));<br>++cnt;<br>&#125;<br>fclose(<span class="hljs-built_in">stdout</span>);<br>freopen(<span class="hljs-string">&quot;CON&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MSE = %f&quot;</span>,e/(cnt*<span class="hljs-number">1.0</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
